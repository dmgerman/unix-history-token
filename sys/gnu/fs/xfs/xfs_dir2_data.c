begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2002,2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_da_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_leaf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_data.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_leaf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_block.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * Check the consistency of the data block.  * The input can also be a block-format directory.  * Pop an assert if we find anything bad.  */
end_comment

begin_function
name|void
name|xfs_dir2_data_check
parameter_list|(
name|xfs_inode_t
modifier|*
name|dp
parameter_list|,
comment|/* incore inode pointer */
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|)
comment|/* data block's buffer */
block|{
name|xfs_dir2_dataptr_t
name|addr
decl_stmt|;
comment|/* addr for leaf lookup */
name|xfs_dir2_data_free_t
modifier|*
name|bf
decl_stmt|;
comment|/* bestfree table */
name|xfs_dir2_block_tail_t
modifier|*
name|btp
init|=
name|NULL
decl_stmt|;
comment|/* block tail */
name|int
name|count
decl_stmt|;
comment|/* count of entries found */
name|xfs_dir2_data_t
modifier|*
name|d
decl_stmt|;
comment|/* data block pointer */
name|xfs_dir2_data_entry_t
modifier|*
name|dep
decl_stmt|;
comment|/* data entry */
name|xfs_dir2_data_free_t
modifier|*
name|dfp
decl_stmt|;
comment|/* bestfree entry */
name|xfs_dir2_data_unused_t
modifier|*
name|dup
decl_stmt|;
comment|/* unused entry */
name|char
modifier|*
name|endp
decl_stmt|;
comment|/* end of useful data */
name|int
name|freeseen
decl_stmt|;
comment|/* mask of bestfrees seen */
name|xfs_dahash_t
name|hash
decl_stmt|;
comment|/* hash of current name */
name|int
name|i
decl_stmt|;
comment|/* leaf index */
name|int
name|lastfree
decl_stmt|;
comment|/* last entry was unused */
name|xfs_dir2_leaf_entry_t
modifier|*
name|lep
init|=
name|NULL
decl_stmt|;
comment|/* block leaf entries */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* current data position */
name|int
name|stale
decl_stmt|;
comment|/* count of stale leaves */
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|d
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_DATA_MAGIC
operator|||
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_BLOCK_MAGIC
argument_list|)
expr_stmt|;
name|bf
operator|=
name|d
operator|->
name|hdr
operator|.
name|bestfree
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|d
operator|->
name|u
expr_stmt|;
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_BLOCK_MAGIC
condition|)
block|{
name|btp
operator|=
name|XFS_DIR2_BLOCK_TAIL_P
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_dir2_block_t
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
name|lep
operator|=
name|XFS_DIR2_BLOCK_LEAF_P
argument_list|(
name|btp
argument_list|)
expr_stmt|;
name|endp
operator|=
operator|(
name|char
operator|*
operator|)
name|lep
expr_stmt|;
block|}
else|else
name|endp
operator|=
operator|(
name|char
operator|*
operator|)
name|d
operator|+
name|mp
operator|->
name|m_dirblksize
expr_stmt|;
name|count
operator|=
name|lastfree
operator|=
name|freeseen
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Account for zero bestfree entries. 	 */
if|if
condition|(
operator|!
name|bf
index|[
literal|0
index|]
operator|.
name|length
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|bf
index|[
literal|0
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
name|freeseen
operator||=
literal|1
operator|<<
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bf
index|[
literal|1
index|]
operator|.
name|length
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|bf
index|[
literal|1
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
name|freeseen
operator||=
literal|1
operator|<<
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bf
index|[
literal|2
index|]
operator|.
name|length
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|bf
index|[
literal|2
index|]
operator|.
name|offset
argument_list|)
expr_stmt|;
name|freeseen
operator||=
literal|1
operator|<<
literal|2
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|bf
index|[
literal|0
index|]
operator|.
name|length
argument_list|)
operator|>=
name|be16_to_cpu
argument_list|(
name|bf
index|[
literal|1
index|]
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|bf
index|[
literal|1
index|]
operator|.
name|length
argument_list|)
operator|>=
name|be16_to_cpu
argument_list|(
name|bf
index|[
literal|2
index|]
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Loop over the data/unused entries. 	 */
while|while
condition|(
name|p
operator|<
name|endp
condition|)
block|{
name|dup
operator|=
operator|(
name|xfs_dir2_data_unused_t
operator|*
operator|)
name|p
expr_stmt|;
comment|/* 		 * If it's unused, look for the space in the bestfree table. 		 * If we find it, account for that, else make sure it 		 * doesn't need to be there. 		 */
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|dup
operator|->
name|freetag
argument_list|)
operator|==
name|XFS_DIR2_DATA_FREE_TAG
condition|)
block|{
name|ASSERT
argument_list|(
name|lastfree
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
operator|*
name|XFS_DIR2_DATA_UNUSED_TAG_P
argument_list|(
name|dup
argument_list|)
argument_list|)
operator|==
operator|(
name|char
operator|*
operator|)
name|dup
operator|-
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
name|dfp
operator|=
name|xfs_dir2_data_freefind
argument_list|(
name|d
argument_list|,
name|dup
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfp
condition|)
block|{
name|i
operator|=
call|(
name|int
call|)
argument_list|(
name|dfp
operator|-
name|bf
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|freeseen
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|freeseen
operator||=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|dup
operator|->
name|length
argument_list|)
operator|<=
name|be16_to_cpu
argument_list|(
name|bf
index|[
literal|2
index|]
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p
operator|+=
name|be16_to_cpu
argument_list|(
name|dup
operator|->
name|length
argument_list|)
expr_stmt|;
name|lastfree
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * It's a real entry.  Validate the fields. 		 * If this is a block directory then make sure it's 		 * in the leaf section of the block. 		 * The linear search is crude but this is DEBUG code. 		 */
name|dep
operator|=
operator|(
name|xfs_dir2_data_entry_t
operator|*
operator|)
name|p
expr_stmt|;
name|ASSERT
argument_list|(
name|dep
operator|->
name|namelen
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|xfs_dir_ino_validate
argument_list|(
name|mp
argument_list|,
name|INT_GET
argument_list|(
name|dep
operator|->
name|inumber
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
operator|*
name|XFS_DIR2_DATA_ENTRY_TAG_P
argument_list|(
name|dep
argument_list|)
argument_list|)
operator|==
operator|(
name|char
operator|*
operator|)
name|dep
operator|-
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|lastfree
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_BLOCK_MAGIC
condition|)
block|{
name|addr
operator|=
name|XFS_DIR2_DB_OFF_TO_DATAPTR
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_dirdatablk
argument_list|,
call|(
name|xfs_dir2_data_aoff_t
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dep
operator|-
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|hash
operator|=
name|xfs_da_hashname
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dep
operator|->
name|name
argument_list|,
name|dep
operator|->
name|namelen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|be32_to_cpu
argument_list|(
name|btp
operator|->
name|count
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|lep
index|[
name|i
index|]
operator|.
name|address
argument_list|)
operator|==
name|addr
operator|&&
name|be32_to_cpu
argument_list|(
name|lep
index|[
name|i
index|]
operator|.
name|hashval
argument_list|)
operator|==
name|hash
condition|)
break|break;
block|}
name|ASSERT
argument_list|(
name|i
operator|<
name|be32_to_cpu
argument_list|(
name|btp
operator|->
name|count
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p
operator|+=
name|XFS_DIR2_DATA_ENTSIZE
argument_list|(
name|dep
operator|->
name|namelen
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Need to have seen all the entries and all the bestfree slots. 	 */
name|ASSERT
argument_list|(
name|freeseen
operator|==
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_BLOCK_MAGIC
condition|)
block|{
for|for
control|(
name|i
operator|=
name|stale
operator|=
literal|0
init|;
name|i
operator|<
name|be32_to_cpu
argument_list|(
name|btp
operator|->
name|count
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|lep
index|[
name|i
index|]
operator|.
name|address
argument_list|)
operator|==
name|XFS_DIR2_NULL_DATAPTR
condition|)
name|stale
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|lep
index|[
name|i
index|]
operator|.
name|hashval
argument_list|)
operator|>=
name|be32_to_cpu
argument_list|(
name|lep
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|hashval
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|count
operator|==
name|be32_to_cpu
argument_list|(
name|btp
operator|->
name|count
argument_list|)
operator|-
name|be32_to_cpu
argument_list|(
name|btp
operator|->
name|stale
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|stale
operator|==
name|be32_to_cpu
argument_list|(
name|btp
operator|->
name|stale
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Given a data block and an unused entry from that block,  * return the bestfree entry if any that corresponds to it.  */
end_comment

begin_function
name|xfs_dir2_data_free_t
modifier|*
name|xfs_dir2_data_freefind
parameter_list|(
name|xfs_dir2_data_t
modifier|*
name|d
parameter_list|,
comment|/* data block */
name|xfs_dir2_data_unused_t
modifier|*
name|dup
parameter_list|)
comment|/* data unused entry */
block|{
name|xfs_dir2_data_free_t
modifier|*
name|dfp
decl_stmt|;
comment|/* bestfree entry */
name|xfs_dir2_data_aoff_t
name|off
decl_stmt|;
comment|/* offset value needed */
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|__KERNEL__
argument_list|)
name|int
name|matched
decl_stmt|;
comment|/* matched the value */
name|int
name|seenzero
decl_stmt|;
comment|/* saw a 0 bestfree entry */
endif|#
directive|endif
name|off
operator|=
call|(
name|xfs_dir2_data_aoff_t
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dup
operator|-
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|&&
name|defined
argument_list|(
name|__KERNEL__
argument_list|)
comment|/* 	 * Validate some consistency in the bestfree table. 	 * Check order, non-overlapping entries, and if we find the 	 * one we're looking for it has to be exact. 	 */
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_DATA_MAGIC
operator|||
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_BLOCK_MAGIC
argument_list|)
expr_stmt|;
for|for
control|(
name|dfp
operator|=
operator|&
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
operator|,
name|seenzero
operator|=
name|matched
operator|=
literal|0
init|;
name|dfp
operator|<
operator|&
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
name|XFS_DIR2_DATA_FD_COUNT
index|]
condition|;
name|dfp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|dfp
operator|->
name|offset
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|dfp
operator|->
name|length
argument_list|)
expr_stmt|;
name|seenzero
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|ASSERT
argument_list|(
name|seenzero
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|dfp
operator|->
name|offset
argument_list|)
operator|==
name|off
condition|)
block|{
name|matched
operator|=
literal|1
expr_stmt|;
name|ASSERT
argument_list|(
name|dfp
operator|->
name|length
operator|==
name|dup
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|off
operator|<
name|be16_to_cpu
argument_list|(
name|dfp
operator|->
name|offset
argument_list|)
condition|)
name|ASSERT
argument_list|(
name|off
operator|+
name|be16_to_cpu
argument_list|(
name|dup
operator|->
name|length
argument_list|)
operator|<=
name|be16_to_cpu
argument_list|(
name|dfp
operator|->
name|offset
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|dfp
operator|->
name|offset
argument_list|)
operator|+
name|be16_to_cpu
argument_list|(
name|dfp
operator|->
name|length
argument_list|)
operator|<=
name|off
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|matched
operator|||
name|be16_to_cpu
argument_list|(
name|dfp
operator|->
name|length
argument_list|)
operator|>=
name|be16_to_cpu
argument_list|(
name|dup
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfp
operator|>
operator|&
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
condition|)
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|dfp
index|[
operator|-
literal|1
index|]
operator|.
name|length
argument_list|)
operator|>=
name|be16_to_cpu
argument_list|(
name|dfp
index|[
literal|0
index|]
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * If this is smaller than the smallest bestfree entry, 	 * it can't be there since they're sorted. 	 */
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|dup
operator|->
name|length
argument_list|)
operator|<
name|be16_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
name|XFS_DIR2_DATA_FD_COUNT
operator|-
literal|1
index|]
operator|.
name|length
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* 	 * Look at the three bestfree entries for our guy. 	 */
for|for
control|(
name|dfp
operator|=
operator|&
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
init|;
name|dfp
operator|<
operator|&
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
name|XFS_DIR2_DATA_FD_COUNT
index|]
condition|;
name|dfp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|dfp
operator|->
name|offset
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|dfp
operator|->
name|offset
argument_list|)
operator|==
name|off
condition|)
return|return
name|dfp
return|;
block|}
comment|/* 	 * Didn't find it.  This only happens if there are duplicate lengths. 	 */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Insert an unused-space entry into the bestfree table.  */
end_comment

begin_function
name|xfs_dir2_data_free_t
modifier|*
comment|/* entry inserted */
name|xfs_dir2_data_freeinsert
parameter_list|(
name|xfs_dir2_data_t
modifier|*
name|d
parameter_list|,
comment|/* data block pointer */
name|xfs_dir2_data_unused_t
modifier|*
name|dup
parameter_list|,
comment|/* unused space */
name|int
modifier|*
name|loghead
parameter_list|)
comment|/* log the data header (out) */
block|{
name|xfs_dir2_data_free_t
modifier|*
name|dfp
decl_stmt|;
comment|/* bestfree table pointer */
name|xfs_dir2_data_free_t
name|new
decl_stmt|;
comment|/* new bestfree entry */
ifdef|#
directive|ifdef
name|__KERNEL__
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_DATA_MAGIC
operator|||
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_BLOCK_MAGIC
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dfp
operator|=
name|d
operator|->
name|hdr
operator|.
name|bestfree
expr_stmt|;
name|new
operator|.
name|length
operator|=
name|dup
operator|->
name|length
expr_stmt|;
name|new
operator|.
name|offset
operator|=
name|cpu_to_be16
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dup
operator|-
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
comment|/* 	 * Insert at position 0, 1, or 2; or not at all. 	 */
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|new
operator|.
name|length
argument_list|)
operator|>
name|be16_to_cpu
argument_list|(
name|dfp
index|[
literal|0
index|]
operator|.
name|length
argument_list|)
condition|)
block|{
name|dfp
index|[
literal|2
index|]
operator|=
name|dfp
index|[
literal|1
index|]
expr_stmt|;
name|dfp
index|[
literal|1
index|]
operator|=
name|dfp
index|[
literal|0
index|]
expr_stmt|;
name|dfp
index|[
literal|0
index|]
operator|=
name|new
expr_stmt|;
operator|*
name|loghead
operator|=
literal|1
expr_stmt|;
return|return
operator|&
name|dfp
index|[
literal|0
index|]
return|;
block|}
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|new
operator|.
name|length
argument_list|)
operator|>
name|be16_to_cpu
argument_list|(
name|dfp
index|[
literal|1
index|]
operator|.
name|length
argument_list|)
condition|)
block|{
name|dfp
index|[
literal|2
index|]
operator|=
name|dfp
index|[
literal|1
index|]
expr_stmt|;
name|dfp
index|[
literal|1
index|]
operator|=
name|new
expr_stmt|;
operator|*
name|loghead
operator|=
literal|1
expr_stmt|;
return|return
operator|&
name|dfp
index|[
literal|1
index|]
return|;
block|}
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|new
operator|.
name|length
argument_list|)
operator|>
name|be16_to_cpu
argument_list|(
name|dfp
index|[
literal|2
index|]
operator|.
name|length
argument_list|)
condition|)
block|{
name|dfp
index|[
literal|2
index|]
operator|=
name|new
expr_stmt|;
operator|*
name|loghead
operator|=
literal|1
expr_stmt|;
return|return
operator|&
name|dfp
index|[
literal|2
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a bestfree entry from the table.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_dir2_data_freeremove
parameter_list|(
name|xfs_dir2_data_t
modifier|*
name|d
parameter_list|,
comment|/* data block pointer */
name|xfs_dir2_data_free_t
modifier|*
name|dfp
parameter_list|,
comment|/* bestfree entry pointer */
name|int
modifier|*
name|loghead
parameter_list|)
comment|/* out: log data header */
block|{
ifdef|#
directive|ifdef
name|__KERNEL__
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_DATA_MAGIC
operator|||
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_BLOCK_MAGIC
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * It's the first entry, slide the next 2 up. 	 */
if|if
condition|(
name|dfp
operator|==
operator|&
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
condition|)
block|{
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
operator|=
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|1
index|]
expr_stmt|;
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|1
index|]
operator|=
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|2
index|]
expr_stmt|;
block|}
comment|/* 	 * It's the second entry, slide the 3rd entry up. 	 */
elseif|else
if|if
condition|(
name|dfp
operator|==
operator|&
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|1
index|]
condition|)
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|1
index|]
operator|=
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|2
index|]
expr_stmt|;
comment|/* 	 * Must be the last entry. 	 */
else|else
name|ASSERT
argument_list|(
name|dfp
operator|==
operator|&
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the 3rd entry, must be zero now. 	 */
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|2
index|]
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|2
index|]
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
operator|*
name|loghead
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a data block, reconstruct its bestfree map.  */
end_comment

begin_function
name|void
name|xfs_dir2_data_freescan
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* filesystem mount point */
name|xfs_dir2_data_t
modifier|*
name|d
parameter_list|,
comment|/* data block pointer */
name|int
modifier|*
name|loghead
parameter_list|,
comment|/* out: log data header */
name|char
modifier|*
name|aendp
parameter_list|)
comment|/* in: caller's endp */
block|{
name|xfs_dir2_block_tail_t
modifier|*
name|btp
decl_stmt|;
comment|/* block tail */
name|xfs_dir2_data_entry_t
modifier|*
name|dep
decl_stmt|;
comment|/* active data entry */
name|xfs_dir2_data_unused_t
modifier|*
name|dup
decl_stmt|;
comment|/* unused data entry */
name|char
modifier|*
name|endp
decl_stmt|;
comment|/* end of block's data */
name|char
modifier|*
name|p
decl_stmt|;
comment|/* current entry pointer */
ifdef|#
directive|ifdef
name|__KERNEL__
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_DATA_MAGIC
operator|||
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_BLOCK_MAGIC
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Start by clearing the table. 	 */
name|memset
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|bestfree
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|bestfree
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|loghead
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Set up pointers. 	 */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|d
operator|->
name|u
expr_stmt|;
if|if
condition|(
name|aendp
condition|)
name|endp
operator|=
name|aendp
expr_stmt|;
elseif|else
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_BLOCK_MAGIC
condition|)
block|{
name|btp
operator|=
name|XFS_DIR2_BLOCK_TAIL_P
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_dir2_block_t
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
name|endp
operator|=
operator|(
name|char
operator|*
operator|)
name|XFS_DIR2_BLOCK_LEAF_P
argument_list|(
name|btp
argument_list|)
expr_stmt|;
block|}
else|else
name|endp
operator|=
operator|(
name|char
operator|*
operator|)
name|d
operator|+
name|mp
operator|->
name|m_dirblksize
expr_stmt|;
comment|/* 	 * Loop over the block's entries. 	 */
while|while
condition|(
name|p
operator|<
name|endp
condition|)
block|{
name|dup
operator|=
operator|(
name|xfs_dir2_data_unused_t
operator|*
operator|)
name|p
expr_stmt|;
comment|/* 		 * If it's a free entry, insert it. 		 */
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|dup
operator|->
name|freetag
argument_list|)
operator|==
name|XFS_DIR2_DATA_FREE_TAG
condition|)
block|{
name|ASSERT
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dup
operator|-
operator|(
name|char
operator|*
operator|)
name|d
operator|==
name|be16_to_cpu
argument_list|(
operator|*
name|XFS_DIR2_DATA_UNUSED_TAG_P
argument_list|(
name|dup
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_dir2_data_freeinsert
argument_list|(
name|d
argument_list|,
name|dup
argument_list|,
name|loghead
argument_list|)
expr_stmt|;
name|p
operator|+=
name|be16_to_cpu
argument_list|(
name|dup
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * For active entries, check their tags and skip them. 		 */
else|else
block|{
name|dep
operator|=
operator|(
name|xfs_dir2_data_entry_t
operator|*
operator|)
name|p
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dep
operator|-
operator|(
name|char
operator|*
operator|)
name|d
operator|==
name|be16_to_cpu
argument_list|(
operator|*
name|XFS_DIR2_DATA_ENTRY_TAG_P
argument_list|(
name|dep
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
name|XFS_DIR2_DATA_ENTSIZE
argument_list|(
name|dep
operator|->
name|namelen
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize a data block at the given block number in the directory.  * Give back the buffer for the created block.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_dir2_data_init
parameter_list|(
name|xfs_da_args_t
modifier|*
name|args
parameter_list|,
comment|/* directory operation args */
name|xfs_dir2_db_t
name|blkno
parameter_list|,
comment|/* logical dir block number */
name|xfs_dabuf_t
modifier|*
modifier|*
name|bpp
parameter_list|)
comment|/* output block buffer */
block|{
name|xfs_dabuf_t
modifier|*
name|bp
decl_stmt|;
comment|/* block buffer */
name|xfs_dir2_data_t
modifier|*
name|d
decl_stmt|;
comment|/* pointer to block */
name|xfs_inode_t
modifier|*
name|dp
decl_stmt|;
comment|/* incore directory inode */
name|xfs_dir2_data_unused_t
modifier|*
name|dup
decl_stmt|;
comment|/* unused entry pointer */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|int
name|i
decl_stmt|;
comment|/* bestfree index */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer */
name|int
name|t
decl_stmt|;
comment|/* temp */
name|dp
operator|=
name|args
operator|->
name|dp
expr_stmt|;
name|mp
operator|=
name|dp
operator|->
name|i_mount
expr_stmt|;
name|tp
operator|=
name|args
operator|->
name|trans
expr_stmt|;
comment|/* 	 * Get the buffer set up for the block. 	 */
name|error
operator|=
name|xfs_da_get_buf
argument_list|(
name|tp
argument_list|,
name|dp
argument_list|,
name|XFS_DIR2_DB_TO_DA
argument_list|(
name|mp
argument_list|,
name|blkno
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|bp
argument_list|,
name|XFS_DATA_FORK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the header. 	 */
name|d
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|d
operator|->
name|hdr
operator|.
name|magic
operator|=
name|cpu_to_be32
argument_list|(
name|XFS_DIR2_DATA_MAGIC
argument_list|)
expr_stmt|;
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
operator|.
name|offset
operator|=
name|cpu_to_be16
argument_list|(
sizeof|sizeof
argument_list|(
name|d
operator|->
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|XFS_DIR2_DATA_FD_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
name|i
index|]
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
name|i
index|]
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Set up an unused entry for the block's body. 	 */
name|dup
operator|=
operator|&
name|d
operator|->
name|u
index|[
literal|0
index|]
operator|.
name|unused
expr_stmt|;
name|dup
operator|->
name|freetag
operator|=
name|cpu_to_be16
argument_list|(
name|XFS_DIR2_DATA_FREE_TAG
argument_list|)
expr_stmt|;
name|t
operator|=
name|mp
operator|->
name|m_dirblksize
operator|-
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|d
operator|->
name|hdr
argument_list|)
expr_stmt|;
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|cpu_to_be16
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|dup
operator|->
name|length
operator|=
name|cpu_to_be16
argument_list|(
name|t
argument_list|)
expr_stmt|;
operator|*
name|XFS_DIR2_DATA_UNUSED_TAG_P
argument_list|(
name|dup
argument_list|)
operator|=
name|cpu_to_be16
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dup
operator|-
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
comment|/* 	 * Log it and return it. 	 */
name|xfs_dir2_data_log_header
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|xfs_dir2_data_log_unused
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
name|dup
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Log an active data entry from the block.  */
end_comment

begin_function
name|void
name|xfs_dir2_data_log_entry
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
comment|/* block buffer */
name|xfs_dir2_data_entry_t
modifier|*
name|dep
parameter_list|)
comment|/* data entry pointer */
block|{
name|xfs_dir2_data_t
modifier|*
name|d
decl_stmt|;
comment|/* data block pointer */
name|d
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_DATA_MAGIC
operator|||
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_BLOCK_MAGIC
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dep
operator|-
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|XFS_DIR2_DATA_ENTRY_TAG_P
argument_list|(
name|dep
argument_list|)
operator|+
literal|1
operator|)
operator|-
operator|(
name|char
operator|*
operator|)
name|d
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Log a data block header.  */
end_comment

begin_function
name|void
name|xfs_dir2_data_log_header
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|)
comment|/* block buffer */
block|{
name|xfs_dir2_data_t
modifier|*
name|d
decl_stmt|;
comment|/* data block pointer */
name|d
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_DATA_MAGIC
operator|||
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_BLOCK_MAGIC
argument_list|)
expr_stmt|;
name|xfs_da_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|d
operator|->
name|hdr
operator|-
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
argument_list|,
call|(
name|uint
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|d
operator|->
name|hdr
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Log a data unused entry.  */
end_comment

begin_function
name|void
name|xfs_dir2_data_log_unused
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
comment|/* block buffer */
name|xfs_dir2_data_unused_t
modifier|*
name|dup
parameter_list|)
comment|/* data unused pointer */
block|{
name|xfs_dir2_data_t
modifier|*
name|d
decl_stmt|;
comment|/* data block pointer */
name|d
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_DATA_MAGIC
operator|||
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_BLOCK_MAGIC
argument_list|)
expr_stmt|;
comment|/* 	 * Log the first part of the unused entry. 	 */
name|xfs_da_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dup
operator|-
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|dup
operator|->
name|length
operator|+
sizeof|sizeof
argument_list|(
name|dup
operator|->
name|length
argument_list|)
operator|-
literal|1
operator|-
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Log the end (tag) of the unused entry. 	 */
name|xfs_da_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XFS_DIR2_DATA_UNUSED_TAG_P
argument_list|(
name|dup
argument_list|)
operator|-
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|XFS_DIR2_DATA_UNUSED_TAG_P
argument_list|(
name|dup
argument_list|)
operator|-
operator|(
name|char
operator|*
operator|)
name|d
operator|+
sizeof|sizeof
argument_list|(
name|xfs_dir2_data_off_t
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make a byte range in the data block unused.  * Its current contents are unimportant.  */
end_comment

begin_function
name|void
name|xfs_dir2_data_make_free
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
comment|/* block buffer */
name|xfs_dir2_data_aoff_t
name|offset
parameter_list|,
comment|/* starting byte offset */
name|xfs_dir2_data_aoff_t
name|len
parameter_list|,
comment|/* length in bytes */
name|int
modifier|*
name|needlogp
parameter_list|,
comment|/* out: log header */
name|int
modifier|*
name|needscanp
parameter_list|)
comment|/* out: regen bestfree */
block|{
name|xfs_dir2_data_t
modifier|*
name|d
decl_stmt|;
comment|/* data block pointer */
name|xfs_dir2_data_free_t
modifier|*
name|dfp
decl_stmt|;
comment|/* bestfree pointer */
name|char
modifier|*
name|endptr
decl_stmt|;
comment|/* end of data area */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* filesystem mount point */
name|int
name|needscan
decl_stmt|;
comment|/* need to regen bestfree */
name|xfs_dir2_data_unused_t
modifier|*
name|newdup
decl_stmt|;
comment|/* new unused entry */
name|xfs_dir2_data_unused_t
modifier|*
name|postdup
decl_stmt|;
comment|/* unused entry after us */
name|xfs_dir2_data_unused_t
modifier|*
name|prevdup
decl_stmt|;
comment|/* unused entry before us */
name|mp
operator|=
name|tp
operator|->
name|t_mountp
expr_stmt|;
name|d
operator|=
name|bp
operator|->
name|data
expr_stmt|;
comment|/* 	 * Figure out where the end of the data area is. 	 */
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_DATA_MAGIC
condition|)
name|endptr
operator|=
operator|(
name|char
operator|*
operator|)
name|d
operator|+
name|mp
operator|->
name|m_dirblksize
expr_stmt|;
else|else
block|{
name|xfs_dir2_block_tail_t
modifier|*
name|btp
decl_stmt|;
comment|/* block tail */
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_BLOCK_MAGIC
argument_list|)
expr_stmt|;
name|btp
operator|=
name|XFS_DIR2_BLOCK_TAIL_P
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_dir2_block_t
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
name|endptr
operator|=
operator|(
name|char
operator|*
operator|)
name|XFS_DIR2_BLOCK_LEAF_P
argument_list|(
name|btp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If this isn't the start of the block, then back up to 	 * the previous entry and see if it's free. 	 */
if|if
condition|(
name|offset
operator|>
sizeof|sizeof
argument_list|(
name|d
operator|->
name|hdr
argument_list|)
condition|)
block|{
name|__be16
modifier|*
name|tagp
decl_stmt|;
comment|/* tag just before us */
name|tagp
operator|=
operator|(
name|__be16
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|d
operator|+
name|offset
operator|)
operator|-
literal|1
expr_stmt|;
name|prevdup
operator|=
operator|(
name|xfs_dir2_data_unused_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|d
operator|+
name|be16_to_cpu
argument_list|(
operator|*
name|tagp
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|prevdup
operator|->
name|freetag
argument_list|)
operator|!=
name|XFS_DIR2_DATA_FREE_TAG
condition|)
name|prevdup
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|prevdup
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If this isn't the end of the block, see if the entry after 	 * us is free. 	 */
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|d
operator|+
name|offset
operator|+
name|len
operator|<
name|endptr
condition|)
block|{
name|postdup
operator|=
operator|(
name|xfs_dir2_data_unused_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|d
operator|+
name|offset
operator|+
name|len
operator|)
expr_stmt|;
if|if
condition|(
name|be16_to_cpu
argument_list|(
name|postdup
operator|->
name|freetag
argument_list|)
operator|!=
name|XFS_DIR2_DATA_FREE_TAG
condition|)
name|postdup
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|postdup
operator|=
name|NULL
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|needscanp
operator|==
literal|0
argument_list|)
expr_stmt|;
name|needscan
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Previous and following entries are both free, 	 * merge everything into a single free entry. 	 */
if|if
condition|(
name|prevdup
operator|&&
name|postdup
condition|)
block|{
name|xfs_dir2_data_free_t
modifier|*
name|dfp2
decl_stmt|;
comment|/* another bestfree pointer */
comment|/* 		 * See if prevdup and/or postdup are in bestfree table. 		 */
name|dfp
operator|=
name|xfs_dir2_data_freefind
argument_list|(
name|d
argument_list|,
name|prevdup
argument_list|)
expr_stmt|;
name|dfp2
operator|=
name|xfs_dir2_data_freefind
argument_list|(
name|d
argument_list|,
name|postdup
argument_list|)
expr_stmt|;
comment|/* 		 * We need a rescan unless there are exactly 2 free entries 		 * namely our two.  Then we know what's happening, otherwise 		 * since the third bestfree is there, there might be more 		 * entries. 		 */
name|needscan
operator|=
operator|(
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|2
index|]
operator|.
name|length
operator|!=
literal|0
operator|)
expr_stmt|;
comment|/* 		 * Fix up the new big freespace. 		 */
name|be16_add
argument_list|(
operator|&
name|prevdup
operator|->
name|length
argument_list|,
name|len
operator|+
name|be16_to_cpu
argument_list|(
name|postdup
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|XFS_DIR2_DATA_UNUSED_TAG_P
argument_list|(
name|prevdup
argument_list|)
operator|=
name|cpu_to_be16
argument_list|(
operator|(
name|char
operator|*
operator|)
name|prevdup
operator|-
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
name|xfs_dir2_data_log_unused
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
name|prevdup
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|needscan
condition|)
block|{
comment|/* 			 * Has to be the case that entries 0 and 1 are 			 * dfp and dfp2 (don't know which is which), and 			 * entry 2 is empty. 			 * Remove entry 1 first then entry 0. 			 */
name|ASSERT
argument_list|(
name|dfp
operator|&&
name|dfp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfp
operator|==
operator|&
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|1
index|]
condition|)
block|{
name|dfp
operator|=
operator|&
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|dfp2
operator|==
name|dfp
argument_list|)
expr_stmt|;
name|dfp2
operator|=
operator|&
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|1
index|]
expr_stmt|;
block|}
name|xfs_dir2_data_freeremove
argument_list|(
name|d
argument_list|,
name|dfp2
argument_list|,
name|needlogp
argument_list|)
expr_stmt|;
name|xfs_dir2_data_freeremove
argument_list|(
name|d
argument_list|,
name|dfp
argument_list|,
name|needlogp
argument_list|)
expr_stmt|;
comment|/* 			 * Now insert the new entry. 			 */
name|dfp
operator|=
name|xfs_dir2_data_freeinsert
argument_list|(
name|d
argument_list|,
name|prevdup
argument_list|,
name|needlogp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dfp
operator|==
operator|&
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dfp
operator|->
name|length
operator|==
name|prevdup
operator|->
name|length
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|dfp
index|[
literal|1
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|dfp
index|[
literal|2
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * The entry before us is free, merge with it. 	 */
elseif|else
if|if
condition|(
name|prevdup
condition|)
block|{
name|dfp
operator|=
name|xfs_dir2_data_freefind
argument_list|(
name|d
argument_list|,
name|prevdup
argument_list|)
expr_stmt|;
name|be16_add
argument_list|(
operator|&
name|prevdup
operator|->
name|length
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|XFS_DIR2_DATA_UNUSED_TAG_P
argument_list|(
name|prevdup
argument_list|)
operator|=
name|cpu_to_be16
argument_list|(
operator|(
name|char
operator|*
operator|)
name|prevdup
operator|-
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
name|xfs_dir2_data_log_unused
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
name|prevdup
argument_list|)
expr_stmt|;
comment|/* 		 * If the previous entry was in the table, the new entry 		 * is longer, so it will be in the table too.  Remove 		 * the old one and add the new one. 		 */
if|if
condition|(
name|dfp
condition|)
block|{
name|xfs_dir2_data_freeremove
argument_list|(
name|d
argument_list|,
name|dfp
argument_list|,
name|needlogp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xfs_dir2_data_freeinsert
argument_list|(
name|d
argument_list|,
name|prevdup
argument_list|,
name|needlogp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Otherwise we need a scan if the new entry is big enough. 		 */
else|else
block|{
name|needscan
operator|=
name|be16_to_cpu
argument_list|(
name|prevdup
operator|->
name|length
argument_list|)
operator|>
name|be16_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|2
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * The following entry is free, merge with it. 	 */
elseif|else
if|if
condition|(
name|postdup
condition|)
block|{
name|dfp
operator|=
name|xfs_dir2_data_freefind
argument_list|(
name|d
argument_list|,
name|postdup
argument_list|)
expr_stmt|;
name|newdup
operator|=
operator|(
name|xfs_dir2_data_unused_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|d
operator|+
name|offset
operator|)
expr_stmt|;
name|newdup
operator|->
name|freetag
operator|=
name|cpu_to_be16
argument_list|(
name|XFS_DIR2_DATA_FREE_TAG
argument_list|)
expr_stmt|;
name|newdup
operator|->
name|length
operator|=
name|cpu_to_be16
argument_list|(
name|len
operator|+
name|be16_to_cpu
argument_list|(
name|postdup
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|XFS_DIR2_DATA_UNUSED_TAG_P
argument_list|(
name|newdup
argument_list|)
operator|=
name|cpu_to_be16
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newdup
operator|-
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
name|xfs_dir2_data_log_unused
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
name|newdup
argument_list|)
expr_stmt|;
comment|/* 		 * If the following entry was in the table, the new entry 		 * is longer, so it will be in the table too.  Remove 		 * the old one and add the new one. 		 */
if|if
condition|(
name|dfp
condition|)
block|{
name|xfs_dir2_data_freeremove
argument_list|(
name|d
argument_list|,
name|dfp
argument_list|,
name|needlogp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xfs_dir2_data_freeinsert
argument_list|(
name|d
argument_list|,
name|newdup
argument_list|,
name|needlogp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Otherwise we need a scan if the new entry is big enough. 		 */
else|else
block|{
name|needscan
operator|=
name|be16_to_cpu
argument_list|(
name|newdup
operator|->
name|length
argument_list|)
operator|>
name|be16_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|2
index|]
operator|.
name|length
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Neither neighbor is free.  Make a new entry. 	 */
else|else
block|{
name|newdup
operator|=
operator|(
name|xfs_dir2_data_unused_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|d
operator|+
name|offset
operator|)
expr_stmt|;
name|newdup
operator|->
name|freetag
operator|=
name|cpu_to_be16
argument_list|(
name|XFS_DIR2_DATA_FREE_TAG
argument_list|)
expr_stmt|;
name|newdup
operator|->
name|length
operator|=
name|cpu_to_be16
argument_list|(
name|len
argument_list|)
expr_stmt|;
operator|*
name|XFS_DIR2_DATA_UNUSED_TAG_P
argument_list|(
name|newdup
argument_list|)
operator|=
name|cpu_to_be16
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newdup
operator|-
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
name|xfs_dir2_data_log_unused
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
name|newdup
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xfs_dir2_data_freeinsert
argument_list|(
name|d
argument_list|,
name|newdup
argument_list|,
name|needlogp
argument_list|)
expr_stmt|;
block|}
operator|*
name|needscanp
operator|=
name|needscan
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take a byte range out of an existing unused space and make it un-free.  */
end_comment

begin_function
name|void
name|xfs_dir2_data_use_free
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_dabuf_t
modifier|*
name|bp
parameter_list|,
comment|/* data block buffer */
name|xfs_dir2_data_unused_t
modifier|*
name|dup
parameter_list|,
comment|/* unused entry */
name|xfs_dir2_data_aoff_t
name|offset
parameter_list|,
comment|/* starting offset to use */
name|xfs_dir2_data_aoff_t
name|len
parameter_list|,
comment|/* length to use */
name|int
modifier|*
name|needlogp
parameter_list|,
comment|/* out: need to log header */
name|int
modifier|*
name|needscanp
parameter_list|)
comment|/* out: need regen bestfree */
block|{
name|xfs_dir2_data_t
modifier|*
name|d
decl_stmt|;
comment|/* data block */
name|xfs_dir2_data_free_t
modifier|*
name|dfp
decl_stmt|;
comment|/* bestfree pointer */
name|int
name|matchback
decl_stmt|;
comment|/* matches end of freespace */
name|int
name|matchfront
decl_stmt|;
comment|/* matches start of freespace */
name|int
name|needscan
decl_stmt|;
comment|/* need to regen bestfree */
name|xfs_dir2_data_unused_t
modifier|*
name|newdup
decl_stmt|;
comment|/* new unused entry */
name|xfs_dir2_data_unused_t
modifier|*
name|newdup2
decl_stmt|;
comment|/* another new unused entry */
name|int
name|oldlen
decl_stmt|;
comment|/* old unused entry's length */
name|d
operator|=
name|bp
operator|->
name|data
expr_stmt|;
name|ASSERT
argument_list|(
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_DATA_MAGIC
operator|||
name|be32_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|magic
argument_list|)
operator|==
name|XFS_DIR2_BLOCK_MAGIC
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|dup
operator|->
name|freetag
argument_list|)
operator|==
name|XFS_DIR2_DATA_FREE_TAG
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|offset
operator|>=
operator|(
name|char
operator|*
operator|)
name|dup
operator|-
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|offset
operator|+
name|len
operator|<=
operator|(
name|char
operator|*
operator|)
name|dup
operator|+
name|be16_to_cpu
argument_list|(
name|dup
operator|->
name|length
argument_list|)
operator|-
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dup
operator|-
operator|(
name|char
operator|*
operator|)
name|d
operator|==
name|be16_to_cpu
argument_list|(
operator|*
name|XFS_DIR2_DATA_UNUSED_TAG_P
argument_list|(
name|dup
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Look up the entry in the bestfree table. 	 */
name|dfp
operator|=
name|xfs_dir2_data_freefind
argument_list|(
name|d
argument_list|,
name|dup
argument_list|)
expr_stmt|;
name|oldlen
operator|=
name|be16_to_cpu
argument_list|(
name|dup
operator|->
name|length
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dfp
operator|||
name|oldlen
operator|<=
name|be16_to_cpu
argument_list|(
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|2
index|]
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check for alignment with front and back of the entry. 	 */
name|matchfront
operator|=
operator|(
name|char
operator|*
operator|)
name|dup
operator|-
operator|(
name|char
operator|*
operator|)
name|d
operator|==
name|offset
expr_stmt|;
name|matchback
operator|=
operator|(
name|char
operator|*
operator|)
name|dup
operator|+
name|oldlen
operator|-
operator|(
name|char
operator|*
operator|)
name|d
operator|==
name|offset
operator|+
name|len
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|needscanp
operator|==
literal|0
argument_list|)
expr_stmt|;
name|needscan
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we matched it exactly we just need to get rid of it from 	 * the bestfree table. 	 */
if|if
condition|(
name|matchfront
operator|&&
name|matchback
condition|)
block|{
if|if
condition|(
name|dfp
condition|)
block|{
name|needscan
operator|=
operator|(
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|2
index|]
operator|.
name|offset
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|needscan
condition|)
name|xfs_dir2_data_freeremove
argument_list|(
name|d
argument_list|,
name|dfp
argument_list|,
name|needlogp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * We match the first part of the entry. 	 * Make a new entry with the remaining freespace. 	 */
elseif|else
if|if
condition|(
name|matchfront
condition|)
block|{
name|newdup
operator|=
operator|(
name|xfs_dir2_data_unused_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|d
operator|+
name|offset
operator|+
name|len
operator|)
expr_stmt|;
name|newdup
operator|->
name|freetag
operator|=
name|cpu_to_be16
argument_list|(
name|XFS_DIR2_DATA_FREE_TAG
argument_list|)
expr_stmt|;
name|newdup
operator|->
name|length
operator|=
name|cpu_to_be16
argument_list|(
name|oldlen
operator|-
name|len
argument_list|)
expr_stmt|;
operator|*
name|XFS_DIR2_DATA_UNUSED_TAG_P
argument_list|(
name|newdup
argument_list|)
operator|=
name|cpu_to_be16
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newdup
operator|-
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
name|xfs_dir2_data_log_unused
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
name|newdup
argument_list|)
expr_stmt|;
comment|/* 		 * If it was in the table, remove it and add the new one. 		 */
if|if
condition|(
name|dfp
condition|)
block|{
name|xfs_dir2_data_freeremove
argument_list|(
name|d
argument_list|,
name|dfp
argument_list|,
name|needlogp
argument_list|)
expr_stmt|;
name|dfp
operator|=
name|xfs_dir2_data_freeinsert
argument_list|(
name|d
argument_list|,
name|newdup
argument_list|,
name|needlogp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dfp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dfp
operator|->
name|length
operator|==
name|newdup
operator|->
name|length
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|dfp
operator|->
name|offset
argument_list|)
operator|==
operator|(
name|char
operator|*
operator|)
name|newdup
operator|-
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
comment|/* 			 * If we got inserted at the last slot, 			 * that means we don't know if there was a better 			 * choice for the last slot, or not.  Rescan. 			 */
name|needscan
operator|=
name|dfp
operator|==
operator|&
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
comment|/* 	 * We match the last part of the entry. 	 * Trim the allocated space off the tail of the entry. 	 */
elseif|else
if|if
condition|(
name|matchback
condition|)
block|{
name|newdup
operator|=
name|dup
expr_stmt|;
name|newdup
operator|->
name|length
operator|=
name|cpu_to_be16
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|d
operator|+
name|offset
operator|)
operator|-
operator|(
name|char
operator|*
operator|)
name|newdup
argument_list|)
expr_stmt|;
operator|*
name|XFS_DIR2_DATA_UNUSED_TAG_P
argument_list|(
name|newdup
argument_list|)
operator|=
name|cpu_to_be16
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newdup
operator|-
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
name|xfs_dir2_data_log_unused
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
name|newdup
argument_list|)
expr_stmt|;
comment|/* 		 * If it was in the table, remove it and add the new one. 		 */
if|if
condition|(
name|dfp
condition|)
block|{
name|xfs_dir2_data_freeremove
argument_list|(
name|d
argument_list|,
name|dfp
argument_list|,
name|needlogp
argument_list|)
expr_stmt|;
name|dfp
operator|=
name|xfs_dir2_data_freeinsert
argument_list|(
name|d
argument_list|,
name|newdup
argument_list|,
name|needlogp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dfp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dfp
operator|->
name|length
operator|==
name|newdup
operator|->
name|length
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|be16_to_cpu
argument_list|(
name|dfp
operator|->
name|offset
argument_list|)
operator|==
operator|(
name|char
operator|*
operator|)
name|newdup
operator|-
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
comment|/* 			 * If we got inserted at the last slot, 			 * that means we don't know if there was a better 			 * choice for the last slot, or not.  Rescan. 			 */
name|needscan
operator|=
name|dfp
operator|==
operator|&
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
comment|/* 	 * Poking out the middle of an entry. 	 * Make two new entries. 	 */
else|else
block|{
name|newdup
operator|=
name|dup
expr_stmt|;
name|newdup
operator|->
name|length
operator|=
name|cpu_to_be16
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|d
operator|+
name|offset
operator|)
operator|-
operator|(
name|char
operator|*
operator|)
name|newdup
argument_list|)
expr_stmt|;
operator|*
name|XFS_DIR2_DATA_UNUSED_TAG_P
argument_list|(
name|newdup
argument_list|)
operator|=
name|cpu_to_be16
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newdup
operator|-
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
name|xfs_dir2_data_log_unused
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
name|newdup
argument_list|)
expr_stmt|;
name|newdup2
operator|=
operator|(
name|xfs_dir2_data_unused_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|d
operator|+
name|offset
operator|+
name|len
operator|)
expr_stmt|;
name|newdup2
operator|->
name|freetag
operator|=
name|cpu_to_be16
argument_list|(
name|XFS_DIR2_DATA_FREE_TAG
argument_list|)
expr_stmt|;
name|newdup2
operator|->
name|length
operator|=
name|cpu_to_be16
argument_list|(
name|oldlen
operator|-
name|len
operator|-
name|be16_to_cpu
argument_list|(
name|newdup
operator|->
name|length
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|XFS_DIR2_DATA_UNUSED_TAG_P
argument_list|(
name|newdup2
argument_list|)
operator|=
name|cpu_to_be16
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newdup2
operator|-
operator|(
name|char
operator|*
operator|)
name|d
argument_list|)
expr_stmt|;
name|xfs_dir2_data_log_unused
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
name|newdup2
argument_list|)
expr_stmt|;
comment|/* 		 * If the old entry was in the table, we need to scan 		 * if the 3rd entry was valid, since these entries 		 * are smaller than the old one. 		 * If we don't need to scan that means there were 1 or 2 		 * entries in the table, and removing the old and adding 		 * the 2 new will work. 		 */
if|if
condition|(
name|dfp
condition|)
block|{
name|needscan
operator|=
operator|(
name|d
operator|->
name|hdr
operator|.
name|bestfree
index|[
literal|2
index|]
operator|.
name|length
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|needscan
condition|)
block|{
name|xfs_dir2_data_freeremove
argument_list|(
name|d
argument_list|,
name|dfp
argument_list|,
name|needlogp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xfs_dir2_data_freeinsert
argument_list|(
name|d
argument_list|,
name|newdup
argument_list|,
name|needlogp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|xfs_dir2_data_freeinsert
argument_list|(
name|d
argument_list|,
name|newdup2
argument_list|,
name|needlogp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
operator|*
name|needscanp
operator|=
name|needscan
expr_stmt|;
block|}
end_function

end_unit

