begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2003 Silicon Graphics, Inc.  All Rights Reserved.  *  * This program is free software; you can redistribute it and/or modify it  * under the terms of version 2 of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful, but  * WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  *  * Further, this software is distributed without any warranty that it is  * free of the rightful claim of any third person regarding infringement  * or the like.  Any license provided herein, whether implied or  * otherwise, applies only to this software file.  Patent licenses, if  * any, provided herein do not apply to combinations of this program with  * other software, or any other product whatsoever.  *  * You should have received a copy of the GNU General Public License along  * with this program; if not, write the Free Software Foundation, Inc., 59  * Temple Place - Suite 330, Boston MA 02111-1307, USA.  *  * Contact information: Silicon Graphics, Inc., 1600 Amphitheatre Pkwy,  * Mountain View, CA  94043, or:  *  * http://www.sgi.com  *  * For further information regarding this notice, see:  *  * http://oss.sgi.com/projects/GenInfo/SGIGPLNoticeExplan/  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_macros.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_itable.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_buf_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_refcache.h"
end_include

begin_decl_stmt
name|STATIC
name|lock_t
name|xfs_refcache_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|xfs_inode_t
modifier|*
modifier|*
name|xfs_refcache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|xfs_refcache_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|xfs_refcache_busy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|STATIC
name|int
name|xfs_refcache_count
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|xfs_refcache_init
parameter_list|(
name|void
parameter_list|)
block|{
name|spinlock_init
argument_list|(
operator|&
name|xfs_refcache_lock
argument_list|,
literal|"xfs_refcache"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Insert the given inode into the reference cache.  */
end_comment

begin_function
name|void
name|xfs_refcache_insert
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|xfs_inode_t
modifier|*
name|release_ip
decl_stmt|;
name|xfs_inode_t
modifier|*
modifier|*
name|refcache
decl_stmt|;
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
operator|(
name|ip
operator|->
name|i_iolock
operator|)
argument_list|,
name|MR_UPDATE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If an unmount is busy blowing entries out of the cache, 	 * then don't bother. 	 */
if|if
condition|(
name|xfs_refcache_busy
condition|)
block|{
return|return;
block|}
comment|/* 	 * If we tuned the refcache down to zero, don't do anything. 	 */
if|if
condition|(
operator|!
name|xfs_refcache_size
condition|)
block|{
return|return;
block|}
comment|/* 	 * The inode is already in the refcache, so don't bother 	 * with it. 	 */
if|if
condition|(
name|ip
operator|->
name|i_refcache
operator|!=
name|NULL
condition|)
block|{
return|return;
block|}
name|vp
operator|=
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* ASSERT(vp->v_count> 0); */
name|VN_HOLD
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 	 * We allocate the reference cache on use so that we don't 	 * waste the memory on systems not being used as NFS servers. 	 */
if|if
condition|(
name|xfs_refcache
operator|==
name|NULL
condition|)
block|{
name|refcache
operator|=
operator|(
name|xfs_inode_t
operator|*
operator|*
operator|)
name|kmem_zalloc
argument_list|(
name|XFS_REFCACHE_SIZE_MAX
operator|*
sizeof|sizeof
argument_list|(
name|xfs_inode_t
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|refcache
operator|=
name|NULL
expr_stmt|;
block|}
name|spin_lock
argument_list|(
operator|&
name|xfs_refcache_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If we allocated memory for the refcache above and it still 	 * needs it, then use the memory we allocated.  Otherwise we'll 	 * free the memory below. 	 */
if|if
condition|(
name|refcache
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|xfs_refcache
operator|==
name|NULL
condition|)
block|{
name|xfs_refcache
operator|=
name|refcache
expr_stmt|;
name|refcache
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * If an unmount is busy clearing out the cache, don't add new 	 * entries to it. 	 */
if|if
condition|(
name|xfs_refcache_busy
condition|)
block|{
name|spin_unlock
argument_list|(
operator|&
name|xfs_refcache_lock
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 		 * If we allocated memory for the refcache above but someone 		 * else beat us to using it, then free the memory now. 		 */
if|if
condition|(
name|refcache
operator|!=
name|NULL
condition|)
block|{
name|kmem_free
argument_list|(
name|refcache
argument_list|,
name|XFS_REFCACHE_SIZE_MAX
operator|*
sizeof|sizeof
argument_list|(
name|xfs_inode_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|release_ip
operator|=
name|xfs_refcache
index|[
name|xfs_refcache_index
index|]
expr_stmt|;
if|if
condition|(
name|release_ip
operator|!=
name|NULL
condition|)
block|{
name|release_ip
operator|->
name|i_refcache
operator|=
name|NULL
expr_stmt|;
name|xfs_refcache_count
operator|--
expr_stmt|;
name|ASSERT
argument_list|(
name|xfs_refcache_count
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
name|xfs_refcache
index|[
name|xfs_refcache_index
index|]
operator|=
name|ip
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_refcache
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_refcache
operator|=
operator|&
operator|(
name|xfs_refcache
index|[
name|xfs_refcache_index
index|]
operator|)
expr_stmt|;
name|xfs_refcache_count
operator|++
expr_stmt|;
name|ASSERT
argument_list|(
name|xfs_refcache_count
operator|<=
name|xfs_refcache_size
argument_list|)
expr_stmt|;
name|xfs_refcache_index
operator|++
expr_stmt|;
if|if
condition|(
name|xfs_refcache_index
operator|==
name|xfs_refcache_size
condition|)
block|{
name|xfs_refcache_index
operator|=
literal|0
expr_stmt|;
block|}
name|spin_unlock
argument_list|(
operator|&
name|xfs_refcache_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Save the pointer to the inode to be released so that we can 	 * VN_RELE it once we've dropped our inode locks in xfs_rwunlock(). 	 * The pointer may be NULL, but that's OK. 	 */
name|ip
operator|->
name|i_release
operator|=
name|release_ip
expr_stmt|;
comment|/* 	 * If we allocated memory for the refcache above but someone 	 * else beat us to using it, then free the memory now. 	 */
if|if
condition|(
name|refcache
operator|!=
name|NULL
condition|)
block|{
name|kmem_free
argument_list|(
name|refcache
argument_list|,
name|XFS_REFCACHE_SIZE_MAX
operator|*
sizeof|sizeof
argument_list|(
name|xfs_inode_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * If the given inode is in the reference cache, purge its entry and  * release the reference on the vnode.  */
end_comment

begin_function
name|void
name|xfs_refcache_purge_ip
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * If we're not pointing to our entry in the cache, then 	 * we must not be in the cache. 	 */
if|if
condition|(
name|ip
operator|->
name|i_refcache
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|spin_lock
argument_list|(
operator|&
name|xfs_refcache_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_refcache
operator|==
name|NULL
condition|)
block|{
name|spin_unlock
argument_list|(
operator|&
name|xfs_refcache_lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Clear both our pointer to the cache entry and its pointer 	 * back to us. 	 */
name|ASSERT
argument_list|(
operator|*
operator|(
name|ip
operator|->
name|i_refcache
operator|)
operator|==
name|ip
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ip
operator|->
name|i_refcache
operator|)
operator|=
name|NULL
expr_stmt|;
name|ip
operator|->
name|i_refcache
operator|=
name|NULL
expr_stmt|;
name|xfs_refcache_count
operator|--
expr_stmt|;
name|ASSERT
argument_list|(
name|xfs_refcache_count
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|xfs_refcache_lock
argument_list|)
expr_stmt|;
name|vp
operator|=
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* ASSERT(vp->v_count> 1); */
name|VOP_RELEASE
argument_list|(
name|vp
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called from the XFS unmount code to purge all entries for the  * given mount from the cache.  It uses the refcache busy counter to  * make sure that new entries are not added to the cache as we purge them.  */
end_comment

begin_function
name|void
name|xfs_refcache_purge_mp
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
if|if
condition|(
name|xfs_refcache
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|spin_lock
argument_list|(
operator|&
name|xfs_refcache_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Bumping the busy counter keeps new entries from being added 	 * to the cache.  We use a counter since multiple unmounts could 	 * be in here simultaneously. 	 */
name|xfs_refcache_busy
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xfs_refcache_size
condition|;
name|i
operator|++
control|)
block|{
name|ip
operator|=
name|xfs_refcache
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_mount
operator|==
name|mp
operator|)
condition|)
block|{
name|xfs_refcache
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ip
operator|->
name|i_refcache
operator|=
name|NULL
expr_stmt|;
name|xfs_refcache_count
operator|--
expr_stmt|;
name|ASSERT
argument_list|(
name|xfs_refcache_count
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|xfs_refcache_lock
argument_list|)
expr_stmt|;
name|vp
operator|=
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|VOP_RELEASE
argument_list|(
name|vp
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|spin_lock
argument_list|(
operator|&
name|xfs_refcache_lock
argument_list|)
expr_stmt|;
block|}
block|}
name|xfs_refcache_busy
operator|--
expr_stmt|;
name|ASSERT
argument_list|(
name|xfs_refcache_busy
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|xfs_refcache_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called from the XFS sync code to ensure that the refcache  * is emptied out over time.  We purge a small number of entries with  * each call.  */
end_comment

begin_function
name|void
name|xfs_refcache_purge_some
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|int
name|iplist_index
decl_stmt|;
name|xfs_inode_t
modifier|*
modifier|*
name|iplist
decl_stmt|;
if|if
condition|(
operator|(
name|xfs_refcache
operator|==
name|NULL
operator|)
operator|||
operator|(
name|xfs_refcache_count
operator|==
literal|0
operator|)
condition|)
block|{
return|return;
block|}
name|iplist_index
operator|=
literal|0
expr_stmt|;
name|iplist
operator|=
operator|(
name|xfs_inode_t
operator|*
operator|*
operator|)
name|kmem_zalloc
argument_list|(
name|xfs_refcache_purge_count
operator|*
sizeof|sizeof
argument_list|(
name|xfs_inode_t
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|spin_lock
argument_list|(
operator|&
name|xfs_refcache_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Store any inodes we find in the next several entries 	 * into the iplist array to be released after dropping 	 * the spinlock.  We always start looking from the currently 	 * oldest place in the cache.  We move the refcache index 	 * forward as we go so that we are sure to eventually clear 	 * out the entire cache when the system goes idle. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xfs_refcache_purge_count
condition|;
name|i
operator|++
control|)
block|{
name|ip
operator|=
name|xfs_refcache
index|[
name|xfs_refcache_index
index|]
expr_stmt|;
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
block|{
name|xfs_refcache
index|[
name|xfs_refcache_index
index|]
operator|=
name|NULL
expr_stmt|;
name|ip
operator|->
name|i_refcache
operator|=
name|NULL
expr_stmt|;
name|xfs_refcache_count
operator|--
expr_stmt|;
name|ASSERT
argument_list|(
name|xfs_refcache_count
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|iplist
index|[
name|iplist_index
index|]
operator|=
name|ip
expr_stmt|;
name|iplist_index
operator|++
expr_stmt|;
block|}
name|xfs_refcache_index
operator|++
expr_stmt|;
if|if
condition|(
name|xfs_refcache_index
operator|==
name|xfs_refcache_size
condition|)
block|{
name|xfs_refcache_index
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|spin_unlock
argument_list|(
operator|&
name|xfs_refcache_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Now drop the inodes we collected. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iplist_index
condition|;
name|i
operator|++
control|)
block|{
name|VOP_RELEASE
argument_list|(
name|XFS_ITOV
argument_list|(
name|iplist
index|[
name|i
index|]
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|XFS_ITOV
argument_list|(
name|iplist
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|iplist
argument_list|,
name|xfs_refcache_purge_count
operator|*
sizeof|sizeof
argument_list|(
name|xfs_inode_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called when the refcache is dynamically resized  * via a sysctl.  *  * If the new size is smaller than the old size, purge all  * entries in slots greater than the new size, and move  * the index if necessary.  *  * If the refcache hasn't even been allocated yet, or the  * new size is larger than the old size, just set the value  * of xfs_refcache_size.  */
end_comment

begin_function
name|void
name|xfs_refcache_resize
parameter_list|(
name|int
name|xfs_refcache_new_size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|int
name|iplist_index
init|=
literal|0
decl_stmt|;
name|xfs_inode_t
modifier|*
modifier|*
name|iplist
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * If the new size is smaller than the current size, 	 * purge entries to create smaller cache, and 	 * reposition index if necessary. 	 * Don't bother if no refcache yet. 	 */
if|if
condition|(
name|xfs_refcache
operator|&&
operator|(
name|xfs_refcache_new_size
operator|<
name|xfs_refcache_size
operator|)
condition|)
block|{
name|iplist
operator|=
operator|(
name|xfs_inode_t
operator|*
operator|*
operator|)
name|kmem_zalloc
argument_list|(
name|XFS_REFCACHE_SIZE_MAX
operator|*
sizeof|sizeof
argument_list|(
name|xfs_inode_t
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|spin_lock
argument_list|(
operator|&
name|xfs_refcache_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|xfs_refcache_new_size
init|;
name|i
operator|<
name|xfs_refcache_size
condition|;
name|i
operator|++
control|)
block|{
name|ip
operator|=
name|xfs_refcache
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
block|{
name|xfs_refcache
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ip
operator|->
name|i_refcache
operator|=
name|NULL
expr_stmt|;
name|xfs_refcache_count
operator|--
expr_stmt|;
name|ASSERT
argument_list|(
name|xfs_refcache_count
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|iplist
index|[
name|iplist_index
index|]
operator|=
name|ip
expr_stmt|;
name|iplist_index
operator|++
expr_stmt|;
block|}
block|}
name|xfs_refcache_size
operator|=
name|xfs_refcache_new_size
expr_stmt|;
comment|/* 		 * Move index to beginning of cache if it's now past the end 		 */
if|if
condition|(
name|xfs_refcache_index
operator|>=
name|xfs_refcache_new_size
condition|)
name|xfs_refcache_index
operator|=
literal|0
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|xfs_refcache_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Now drop the inodes we collected. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iplist_index
condition|;
name|i
operator|++
control|)
block|{
name|VOP_RELEASE
argument_list|(
name|XFS_ITOV
argument_list|(
name|iplist
index|[
name|i
index|]
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|XFS_ITOV
argument_list|(
name|iplist
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|iplist
argument_list|,
name|XFS_REFCACHE_SIZE_MAX
operator|*
sizeof|sizeof
argument_list|(
name|xfs_inode_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|spin_lock
argument_list|(
operator|&
name|xfs_refcache_lock
argument_list|)
expr_stmt|;
name|xfs_refcache_size
operator|=
name|xfs_refcache_new_size
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|xfs_refcache_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xfs_refcache_iunlock
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|uint
name|lock_flags
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|release_ip
decl_stmt|;
name|int
name|error
decl_stmt|;
name|release_ip
operator|=
name|ip
operator|->
name|i_release
expr_stmt|;
name|ip
operator|->
name|i_release
operator|=
name|NULL
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|release_ip
operator|!=
name|NULL
condition|)
block|{
name|VOP_RELEASE
argument_list|(
name|XFS_ITOV
argument_list|(
name|release_ip
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|XFS_ITOV
argument_list|(
name|release_ip
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|xfs_refcache_destroy
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|xfs_refcache
condition|)
block|{
name|kmem_free
argument_list|(
name|xfs_refcache
argument_list|,
name|XFS_REFCACHE_SIZE_MAX
operator|*
sizeof|sizeof
argument_list|(
name|xfs_inode_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_refcache
operator|=
name|NULL
expr_stmt|;
block|}
name|spinlock_destroy
argument_list|(
operator|&
name|xfs_refcache_lock
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

