begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rtalloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fsops.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rw.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans_space.h"
end_include

begin_comment
comment|/*  * Prototypes for internal functions.  */
end_comment

begin_function_decl
name|STATIC
name|int
name|xfs_rtallocate_range
parameter_list|(
name|xfs_mount_t
modifier|*
parameter_list|,
name|xfs_trans_t
modifier|*
parameter_list|,
name|xfs_rtblock_t
parameter_list|,
name|xfs_extlen_t
parameter_list|,
name|xfs_buf_t
modifier|*
modifier|*
parameter_list|,
name|xfs_fsblock_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_rtany_summary
parameter_list|(
name|xfs_mount_t
modifier|*
parameter_list|,
name|xfs_trans_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|xfs_rtblock_t
parameter_list|,
name|xfs_buf_t
modifier|*
modifier|*
parameter_list|,
name|xfs_fsblock_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_rtcheck_range
parameter_list|(
name|xfs_mount_t
modifier|*
parameter_list|,
name|xfs_trans_t
modifier|*
parameter_list|,
name|xfs_rtblock_t
parameter_list|,
name|xfs_extlen_t
parameter_list|,
name|int
parameter_list|,
name|xfs_rtblock_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_rtfind_back
parameter_list|(
name|xfs_mount_t
modifier|*
parameter_list|,
name|xfs_trans_t
modifier|*
parameter_list|,
name|xfs_rtblock_t
parameter_list|,
name|xfs_rtblock_t
parameter_list|,
name|xfs_rtblock_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_rtfind_forw
parameter_list|(
name|xfs_mount_t
modifier|*
parameter_list|,
name|xfs_trans_t
modifier|*
parameter_list|,
name|xfs_rtblock_t
parameter_list|,
name|xfs_rtblock_t
parameter_list|,
name|xfs_rtblock_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_rtget_summary
parameter_list|(
name|xfs_mount_t
modifier|*
parameter_list|,
name|xfs_trans_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|xfs_rtblock_t
parameter_list|,
name|xfs_buf_t
modifier|*
modifier|*
parameter_list|,
name|xfs_fsblock_t
modifier|*
parameter_list|,
name|xfs_suminfo_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_rtmodify_range
parameter_list|(
name|xfs_mount_t
modifier|*
parameter_list|,
name|xfs_trans_t
modifier|*
parameter_list|,
name|xfs_rtblock_t
parameter_list|,
name|xfs_extlen_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|xfs_rtmodify_summary
parameter_list|(
name|xfs_mount_t
modifier|*
parameter_list|,
name|xfs_trans_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|xfs_rtblock_t
parameter_list|,
name|int
parameter_list|,
name|xfs_buf_t
modifier|*
modifier|*
parameter_list|,
name|xfs_fsblock_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Internal functions.  */
end_comment

begin_comment
comment|/*  * xfs_lowbit32: get low bit set out of 32-bit argument, -1 if none set.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_lowbit32
parameter_list|(
name|__uint32_t
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
condition|)
return|return
name|ffs
argument_list|(
name|v
argument_list|)
operator|-
literal|1
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate space to the bitmap or summary file, and zero it, for growfs.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_growfs_rt_alloc
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_extlen_t
name|oblocks
parameter_list|,
comment|/* old count of blocks */
name|xfs_extlen_t
name|nblocks
parameter_list|,
comment|/* new count of blocks */
name|xfs_ino_t
name|ino
parameter_list|)
comment|/* inode number (bitmap/summary) */
block|{
name|xfs_fileoff_t
name|bno
decl_stmt|;
comment|/* block number in file */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* temporary buffer for zeroing */
name|int
name|cancelflags
decl_stmt|;
comment|/* flags for xfs_trans_cancel */
name|int
name|committed
decl_stmt|;
comment|/* transaction committed flag */
name|xfs_daddr_t
name|d
decl_stmt|;
comment|/* disk block address */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_fsblock_t
name|firstblock
decl_stmt|;
comment|/* first block allocated in xaction */
name|xfs_bmap_free_t
name|flist
decl_stmt|;
comment|/* list of freed blocks */
name|xfs_fsblock_t
name|fsbno
decl_stmt|;
comment|/* filesystem block for bno */
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
comment|/* pointer to incore inode */
name|xfs_bmbt_irec_t
name|map
decl_stmt|;
comment|/* block map output */
name|int
name|nmap
decl_stmt|;
comment|/* number of block maps */
name|int
name|resblks
decl_stmt|;
comment|/* space reservation */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer */
comment|/* 	 * Allocate space to the file, as necessary. 	 */
while|while
condition|(
name|oblocks
operator|<
name|nblocks
condition|)
block|{
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_GROWFSRT_ALLOC
argument_list|)
expr_stmt|;
name|resblks
operator|=
name|XFS_GROWFSRT_SPACE_RES
argument_list|(
name|mp
argument_list|,
name|nblocks
operator|-
name|oblocks
argument_list|)
expr_stmt|;
name|cancelflags
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Reserve space& log for one extent added to the file. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
name|resblks
argument_list|,
name|XFS_GROWRTALLOC_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|XFS_TRANS_PERM_LOG_RES
argument_list|,
name|XFS_DEFAULT_PERM_LOG_COUNT
argument_list|)
operator|)
condition|)
goto|goto
name|error_exit
goto|;
name|cancelflags
operator|=
name|XFS_TRANS_RELEASE_LOG_RES
expr_stmt|;
comment|/* 		 * Lock the inode. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_iget
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ino
argument_list|,
literal|0
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|,
operator|&
name|ip
argument_list|)
operator|)
condition|)
goto|goto
name|error_exit
goto|;
name|XFS_BMAP_INIT
argument_list|(
operator|&
name|flist
argument_list|,
operator|&
name|firstblock
argument_list|)
expr_stmt|;
comment|/* 		 * Allocate blocks to the bitmap file. 		 */
name|nmap
operator|=
literal|1
expr_stmt|;
name|cancelflags
operator||=
name|XFS_TRANS_ABORT
expr_stmt|;
name|error
operator|=
name|xfs_bmapi
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|oblocks
argument_list|,
name|nblocks
operator|-
name|oblocks
argument_list|,
name|XFS_BMAPI_WRITE
operator||
name|XFS_BMAPI_METADATA
argument_list|,
operator|&
name|firstblock
argument_list|,
name|resblks
argument_list|,
operator|&
name|map
argument_list|,
operator|&
name|nmap
argument_list|,
operator|&
name|flist
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|nmap
operator|<
literal|1
condition|)
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error_exit
goto|;
comment|/* 		 * Free any blocks freed up in the transaction, then commit. 		 */
name|error
operator|=
name|xfs_bmap_finish
argument_list|(
operator|&
name|tp
argument_list|,
operator|&
name|flist
argument_list|,
name|firstblock
argument_list|,
operator|&
name|committed
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error_exit
goto|;
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_RELEASE_LOG_RES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * Now we need to clear the allocated blocks. 		 * Do this one block per transaction, to keep it simple. 		 */
name|cancelflags
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bno
operator|=
name|map
operator|.
name|br_startoff
operator|,
name|fsbno
operator|=
name|map
operator|.
name|br_startblock
init|;
name|bno
operator|<
name|map
operator|.
name|br_startoff
operator|+
name|map
operator|.
name|br_blockcount
condition|;
name|bno
operator|++
operator|,
name|fsbno
operator|++
control|)
block|{
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_GROWFSRT_ZERO
argument_list|)
expr_stmt|;
comment|/* 			 * Reserve log for one block zeroing. 			 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_GROWRTZERO_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
goto|goto
name|error_exit
goto|;
comment|/* 			 * Lock the bitmap inode. 			 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_iget
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|ino
argument_list|,
literal|0
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|,
operator|&
name|ip
argument_list|)
operator|)
condition|)
goto|goto
name|error_exit
goto|;
comment|/* 			 * Get a buffer for the block. 			 */
name|d
operator|=
name|XFS_FSB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|fsbno
argument_list|)
expr_stmt|;
name|bp
operator|=
name|xfs_trans_get_buf
argument_list|(
name|tp
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|d
argument_list|,
name|mp
operator|->
name|m_bsize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
goto|goto
name|error_exit
goto|;
block|}
name|memset
argument_list|(
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
argument_list|)
expr_stmt|;
name|xfs_trans_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * Commit the transaction. 			 */
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Go on to the next extent, if any. 		 */
name|oblocks
operator|=
name|map
operator|.
name|br_startoff
operator|+
name|map
operator|.
name|br_blockcount
expr_stmt|;
block|}
return|return
literal|0
return|;
name|error_exit
label|:
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|cancelflags
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt to allocate an extent minlen<=len<=maxlen starting from  * bitmap block bbno.  If we don't get maxlen then use prod to trim  * the length, if given.  Returns error; returns starting block in *rtblock.  * The lengths are all in rtextents.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_rtallocate_extent_block
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_rtblock_t
name|bbno
parameter_list|,
comment|/* bitmap block number */
name|xfs_extlen_t
name|minlen
parameter_list|,
comment|/* minimum length to allocate */
name|xfs_extlen_t
name|maxlen
parameter_list|,
comment|/* maximum length to allocate */
name|xfs_extlen_t
modifier|*
name|len
parameter_list|,
comment|/* out: actual length allocated */
name|xfs_rtblock_t
modifier|*
name|nextp
parameter_list|,
comment|/* out: next block to try */
name|xfs_buf_t
modifier|*
modifier|*
name|rbpp
parameter_list|,
comment|/* in/out: summary block buffer */
name|xfs_fsblock_t
modifier|*
name|rsb
parameter_list|,
comment|/* in/out: summary block number */
name|xfs_extlen_t
name|prod
parameter_list|,
comment|/* extent product factor */
name|xfs_rtblock_t
modifier|*
name|rtblock
parameter_list|)
comment|/* out: start block allocated */
block|{
name|xfs_rtblock_t
name|besti
decl_stmt|;
comment|/* best rtblock found so far */
name|xfs_rtblock_t
name|bestlen
decl_stmt|;
comment|/* best length found so far */
name|xfs_rtblock_t
name|end
decl_stmt|;
comment|/* last rtblock in chunk */
name|int
name|error
decl_stmt|;
comment|/* error value */
name|xfs_rtblock_t
name|i
decl_stmt|;
comment|/* current rtblock trying */
name|xfs_rtblock_t
name|next
decl_stmt|;
comment|/* next rtblock to try */
name|int
name|stat
decl_stmt|;
comment|/* status from internal calls */
comment|/* 	 * Loop over all the extents starting in this bitmap block, 	 * looking for one that's long enough. 	 */
for|for
control|(
name|i
operator|=
name|XFS_BLOCKTOBIT
argument_list|(
name|mp
argument_list|,
name|bbno
argument_list|)
operator|,
name|besti
operator|=
operator|-
literal|1
operator|,
name|bestlen
operator|=
literal|0
operator|,
name|end
operator|=
name|XFS_BLOCKTOBIT
argument_list|(
name|mp
argument_list|,
name|bbno
operator|+
literal|1
argument_list|)
operator|-
literal|1
init|;
name|i
operator|<=
name|end
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * See if there's a free extent of maxlen starting at i. 		 * If it's not so then next will contain the first non-free. 		 */
name|error
operator|=
name|xfs_rtcheck_range
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|i
argument_list|,
name|maxlen
argument_list|,
literal|1
argument_list|,
operator|&
name|next
argument_list|,
operator|&
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|stat
condition|)
block|{
comment|/* 			 * i for maxlen is all free, allocate and return that. 			 */
name|error
operator|=
name|xfs_rtallocate_range
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|i
argument_list|,
name|maxlen
argument_list|,
name|rbpp
argument_list|,
name|rsb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
operator|*
name|len
operator|=
name|maxlen
expr_stmt|;
operator|*
name|rtblock
operator|=
name|i
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 		 * In the case where we have a variable-sized allocation 		 * request, figure out how big this free piece is, 		 * and if it's big enough for the minimum, and the best 		 * so far, remember it. 		 */
if|if
condition|(
name|minlen
operator|<
name|maxlen
condition|)
block|{
name|xfs_rtblock_t
name|thislen
decl_stmt|;
comment|/* this extent size */
name|thislen
operator|=
name|next
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|thislen
operator|>=
name|minlen
operator|&&
name|thislen
operator|>
name|bestlen
condition|)
block|{
name|besti
operator|=
name|i
expr_stmt|;
name|bestlen
operator|=
name|thislen
expr_stmt|;
block|}
block|}
comment|/* 		 * If not done yet, find the start of the next free space. 		 */
if|if
condition|(
name|next
operator|<
name|end
condition|)
block|{
name|error
operator|=
name|xfs_rtfind_forw
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|next
argument_list|,
name|end
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
else|else
break|break;
block|}
comment|/* 	 * Searched the whole thing& didn't find a maxlen free extent. 	 */
if|if
condition|(
name|minlen
operator|<
name|maxlen
operator|&&
name|besti
operator|!=
operator|-
literal|1
condition|)
block|{
name|xfs_extlen_t
name|p
decl_stmt|;
comment|/* amount to trim length by */
comment|/* 		 * If size should be a multiple of prod, make that so. 		 */
if|if
condition|(
name|prod
operator|>
literal|1
operator|&&
operator|(
name|p
operator|=
name|do_mod
argument_list|(
name|bestlen
argument_list|,
name|prod
argument_list|)
operator|)
condition|)
name|bestlen
operator|-=
name|p
expr_stmt|;
comment|/* 		 * Allocate besti for bestlen& return that. 		 */
name|error
operator|=
name|xfs_rtallocate_range
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|besti
argument_list|,
name|bestlen
argument_list|,
name|rbpp
argument_list|,
name|rsb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
operator|*
name|len
operator|=
name|bestlen
expr_stmt|;
operator|*
name|rtblock
operator|=
name|besti
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Allocation failed.  Set *nextp to the next block to try. 	 */
operator|*
name|nextp
operator|=
name|next
expr_stmt|;
operator|*
name|rtblock
operator|=
name|NULLRTBLOCK
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate an extent of length minlen<=len<=maxlen, starting at block  * bno.  If we don't get maxlen then use prod to trim the length, if given.  * Returns error; returns starting block in *rtblock.  * The lengths are all in rtextents.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_rtallocate_extent_exact
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_rtblock_t
name|bno
parameter_list|,
comment|/* starting block number to allocate */
name|xfs_extlen_t
name|minlen
parameter_list|,
comment|/* minimum length to allocate */
name|xfs_extlen_t
name|maxlen
parameter_list|,
comment|/* maximum length to allocate */
name|xfs_extlen_t
modifier|*
name|len
parameter_list|,
comment|/* out: actual length allocated */
name|xfs_buf_t
modifier|*
modifier|*
name|rbpp
parameter_list|,
comment|/* in/out: summary block buffer */
name|xfs_fsblock_t
modifier|*
name|rsb
parameter_list|,
comment|/* in/out: summary block number */
name|xfs_extlen_t
name|prod
parameter_list|,
comment|/* extent product factor */
name|xfs_rtblock_t
modifier|*
name|rtblock
parameter_list|)
comment|/* out: start block allocated */
block|{
name|int
name|error
decl_stmt|;
comment|/* error value */
name|xfs_extlen_t
name|i
decl_stmt|;
comment|/* extent length trimmed due to prod */
name|int
name|isfree
decl_stmt|;
comment|/* extent is free */
name|xfs_rtblock_t
name|next
decl_stmt|;
comment|/* next block to try (dummy) */
name|ASSERT
argument_list|(
name|minlen
operator|%
name|prod
operator|==
literal|0
operator|&&
name|maxlen
operator|%
name|prod
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Check if the range in question (for maxlen) is free. 	 */
name|error
operator|=
name|xfs_rtcheck_range
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|bno
argument_list|,
name|maxlen
argument_list|,
literal|1
argument_list|,
operator|&
name|next
argument_list|,
operator|&
name|isfree
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
if|if
condition|(
name|isfree
condition|)
block|{
comment|/* 		 * If it is, allocate it and return success. 		 */
name|error
operator|=
name|xfs_rtallocate_range
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|bno
argument_list|,
name|maxlen
argument_list|,
name|rbpp
argument_list|,
name|rsb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
operator|*
name|len
operator|=
name|maxlen
expr_stmt|;
operator|*
name|rtblock
operator|=
name|bno
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * If not, allocate what there is, if it's at least minlen. 	 */
name|maxlen
operator|=
name|next
operator|-
name|bno
expr_stmt|;
if|if
condition|(
name|maxlen
operator|<
name|minlen
condition|)
block|{
comment|/* 		 * Failed, return failure status. 		 */
operator|*
name|rtblock
operator|=
name|NULLRTBLOCK
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Trim off tail of extent, if prod is specified. 	 */
if|if
condition|(
name|prod
operator|>
literal|1
operator|&&
operator|(
name|i
operator|=
name|maxlen
operator|%
name|prod
operator|)
condition|)
block|{
name|maxlen
operator|-=
name|i
expr_stmt|;
if|if
condition|(
name|maxlen
operator|<
name|minlen
condition|)
block|{
comment|/* 			 * Now we can't do it, return failure status. 			 */
operator|*
name|rtblock
operator|=
name|NULLRTBLOCK
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* 	 * Allocate what we can and return it. 	 */
name|error
operator|=
name|xfs_rtallocate_range
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|bno
argument_list|,
name|maxlen
argument_list|,
name|rbpp
argument_list|,
name|rsb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
operator|*
name|len
operator|=
name|maxlen
expr_stmt|;
operator|*
name|rtblock
operator|=
name|bno
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate an extent of length minlen<=len<=maxlen, starting as near  * to bno as possible.  If we don't get maxlen then use prod to trim  * the length, if given.  The lengths are all in rtextents.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_rtallocate_extent_near
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_rtblock_t
name|bno
parameter_list|,
comment|/* starting block number to allocate */
name|xfs_extlen_t
name|minlen
parameter_list|,
comment|/* minimum length to allocate */
name|xfs_extlen_t
name|maxlen
parameter_list|,
comment|/* maximum length to allocate */
name|xfs_extlen_t
modifier|*
name|len
parameter_list|,
comment|/* out: actual length allocated */
name|xfs_buf_t
modifier|*
modifier|*
name|rbpp
parameter_list|,
comment|/* in/out: summary block buffer */
name|xfs_fsblock_t
modifier|*
name|rsb
parameter_list|,
comment|/* in/out: summary block number */
name|xfs_extlen_t
name|prod
parameter_list|,
comment|/* extent product factor */
name|xfs_rtblock_t
modifier|*
name|rtblock
parameter_list|)
comment|/* out: start block allocated */
block|{
name|int
name|any
decl_stmt|;
comment|/* any useful extents from summary */
name|xfs_rtblock_t
name|bbno
decl_stmt|;
comment|/* bitmap block number */
name|int
name|error
decl_stmt|;
comment|/* error value */
name|int
name|i
decl_stmt|;
comment|/* bitmap block offset (loop control) */
name|int
name|j
decl_stmt|;
comment|/* secondary loop control */
name|int
name|log2len
decl_stmt|;
comment|/* log2 of minlen */
name|xfs_rtblock_t
name|n
decl_stmt|;
comment|/* next block to try */
name|xfs_rtblock_t
name|r
decl_stmt|;
comment|/* result block */
name|ASSERT
argument_list|(
name|minlen
operator|%
name|prod
operator|==
literal|0
operator|&&
name|maxlen
operator|%
name|prod
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If the block number given is off the end, silently set it to 	 * the last block. 	 */
if|if
condition|(
name|bno
operator|>=
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextents
condition|)
name|bno
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextents
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Try the exact allocation first. 	 */
name|error
operator|=
name|xfs_rtallocate_extent_exact
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|bno
argument_list|,
name|minlen
argument_list|,
name|maxlen
argument_list|,
name|len
argument_list|,
name|rbpp
argument_list|,
name|rsb
argument_list|,
name|prod
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 	 * If the exact allocation worked, return that. 	 */
if|if
condition|(
name|r
operator|!=
name|NULLRTBLOCK
condition|)
block|{
operator|*
name|rtblock
operator|=
name|r
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bbno
operator|=
name|XFS_BITTOBLOCK
argument_list|(
name|mp
argument_list|,
name|bno
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|log2len
operator|=
name|xfs_highbit32
argument_list|(
name|minlen
argument_list|)
expr_stmt|;
comment|/* 	 * Loop over all bitmap blocks (bbno + i is current block). 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Get summary information of extents of all useful levels 		 * starting in this bitmap block. 		 */
name|error
operator|=
name|xfs_rtany_summary
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|log2len
argument_list|,
name|mp
operator|->
name|m_rsumlevels
operator|-
literal|1
argument_list|,
name|bbno
operator|+
name|i
argument_list|,
name|rbpp
argument_list|,
name|rsb
argument_list|,
operator|&
name|any
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 		 * If there are any useful extents starting here, try 		 * allocating one. 		 */
if|if
condition|(
name|any
condition|)
block|{
comment|/* 			 * On the positive side of the starting location. 			 */
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
comment|/* 				 * Try to allocate an extent starting in 				 * this block. 				 */
name|error
operator|=
name|xfs_rtallocate_extent_block
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|bbno
operator|+
name|i
argument_list|,
name|minlen
argument_list|,
name|maxlen
argument_list|,
name|len
argument_list|,
operator|&
name|n
argument_list|,
name|rbpp
argument_list|,
name|rsb
argument_list|,
name|prod
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 				 * If it worked, return it. 				 */
if|if
condition|(
name|r
operator|!=
name|NULLRTBLOCK
condition|)
block|{
operator|*
name|rtblock
operator|=
name|r
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* 			 * On the negative side of the starting location. 			 */
else|else
block|{
comment|/* i< 0 */
comment|/* 				 * Loop backwards through the bitmap blocks from 				 * the starting point-1 up to where we are now. 				 * There should be an extent which ends in this 				 * bitmap block and is long enough. 				 */
for|for
control|(
name|j
operator|=
operator|-
literal|1
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
block|{
comment|/* 					 * Grab the summary information for 					 * this bitmap block. 					 */
name|error
operator|=
name|xfs_rtany_summary
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|log2len
argument_list|,
name|mp
operator|->
name|m_rsumlevels
operator|-
literal|1
argument_list|,
name|bbno
operator|+
name|j
argument_list|,
name|rbpp
argument_list|,
name|rsb
argument_list|,
operator|&
name|any
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 					 * If there's no extent given in the 					 * summary that means the extent we 					 * found must carry over from an 					 * earlier block.  If there is an 					 * extent given, we've already tried 					 * that allocation, don't do it again. 					 */
if|if
condition|(
name|any
condition|)
continue|continue;
name|error
operator|=
name|xfs_rtallocate_extent_block
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|bbno
operator|+
name|j
argument_list|,
name|minlen
argument_list|,
name|maxlen
argument_list|,
name|len
argument_list|,
operator|&
name|n
argument_list|,
name|rbpp
argument_list|,
name|rsb
argument_list|,
name|prod
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 					 * If it works, return the extent. 					 */
if|if
condition|(
name|r
operator|!=
name|NULLRTBLOCK
condition|)
block|{
operator|*
name|rtblock
operator|=
name|r
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* 				 * There weren't intervening bitmap blocks 				 * with a long enough extent, or the 				 * allocation didn't work for some reason 				 * (i.e. it's a little * too short). 				 * Try to allocate from the summary block 				 * that we found. 				 */
name|error
operator|=
name|xfs_rtallocate_extent_block
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|bbno
operator|+
name|i
argument_list|,
name|minlen
argument_list|,
name|maxlen
argument_list|,
name|len
argument_list|,
operator|&
name|n
argument_list|,
name|rbpp
argument_list|,
name|rsb
argument_list|,
name|prod
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 				 * If it works, return the extent. 				 */
if|if
condition|(
name|r
operator|!=
name|NULLRTBLOCK
condition|)
block|{
operator|*
name|rtblock
operator|=
name|r
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
comment|/* 		 * Loop control.  If we were on the positive side, and there's 		 * still more blocks on the negative side, go there. 		 */
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
operator|(
name|int
operator|)
name|bbno
operator|-
name|i
operator|>=
literal|0
condition|)
name|i
operator|=
operator|-
name|i
expr_stmt|;
comment|/* 		 * If positive, and no more negative, but there are more 		 * positive, go there. 		 */
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
operator|(
name|int
operator|)
name|bbno
operator|+
name|i
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_rbmblocks
operator|-
literal|1
condition|)
name|i
operator|++
expr_stmt|;
comment|/* 		 * If negative or 0 (just started), and there are positive 		 * blocks to go, go there.  The 0 case moves to block 1. 		 */
elseif|else
if|if
condition|(
name|i
operator|<=
literal|0
operator|&&
operator|(
name|int
operator|)
name|bbno
operator|-
name|i
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_rbmblocks
operator|-
literal|1
condition|)
name|i
operator|=
literal|1
operator|-
name|i
expr_stmt|;
comment|/* 		 * If negative or 0 and there are more negative blocks, 		 * go there. 		 */
elseif|else
if|if
condition|(
name|i
operator|<=
literal|0
operator|&&
operator|(
name|int
operator|)
name|bbno
operator|+
name|i
operator|>
literal|0
condition|)
name|i
operator|--
expr_stmt|;
comment|/* 		 * Must be done.  Return failure. 		 */
else|else
break|break;
block|}
operator|*
name|rtblock
operator|=
name|NULLRTBLOCK
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate an extent of length minlen<=len<=maxlen, with no position  * specified.  If we don't get maxlen then use prod to trim  * the length, if given.  The lengths are all in rtextents.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_rtallocate_extent_size
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_extlen_t
name|minlen
parameter_list|,
comment|/* minimum length to allocate */
name|xfs_extlen_t
name|maxlen
parameter_list|,
comment|/* maximum length to allocate */
name|xfs_extlen_t
modifier|*
name|len
parameter_list|,
comment|/* out: actual length allocated */
name|xfs_buf_t
modifier|*
modifier|*
name|rbpp
parameter_list|,
comment|/* in/out: summary block buffer */
name|xfs_fsblock_t
modifier|*
name|rsb
parameter_list|,
comment|/* in/out: summary block number */
name|xfs_extlen_t
name|prod
parameter_list|,
comment|/* extent product factor */
name|xfs_rtblock_t
modifier|*
name|rtblock
parameter_list|)
comment|/* out: start block allocated */
block|{
name|int
name|error
decl_stmt|;
comment|/* error value */
name|int
name|i
decl_stmt|;
comment|/* bitmap block number */
name|int
name|l
decl_stmt|;
comment|/* level number (loop control) */
name|xfs_rtblock_t
name|n
decl_stmt|;
comment|/* next block to be tried */
name|xfs_rtblock_t
name|r
decl_stmt|;
comment|/* result block number */
name|xfs_suminfo_t
name|sum
decl_stmt|;
comment|/* summary information for extents */
name|ASSERT
argument_list|(
name|minlen
operator|%
name|prod
operator|==
literal|0
operator|&&
name|maxlen
operator|%
name|prod
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Loop over all the levels starting with maxlen. 	 * At each level, look at all the bitmap blocks, to see if there 	 * are extents starting there that are long enough (>= maxlen). 	 * Note, only on the initial level can the allocation fail if 	 * the summary says there's an extent. 	 */
for|for
control|(
name|l
operator|=
name|xfs_highbit32
argument_list|(
name|maxlen
argument_list|)
init|;
name|l
operator|<
name|mp
operator|->
name|m_rsumlevels
condition|;
name|l
operator|++
control|)
block|{
comment|/* 		 * Loop over all the bitmap blocks. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_rbmblocks
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * Get the summary for this level/block. 			 */
name|error
operator|=
name|xfs_rtget_summary
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|l
argument_list|,
name|i
argument_list|,
name|rbpp
argument_list|,
name|rsb
argument_list|,
operator|&
name|sum
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 			 * Nothing there, on to the next block. 			 */
if|if
condition|(
operator|!
name|sum
condition|)
continue|continue;
comment|/* 			 * Try allocating the extent. 			 */
name|error
operator|=
name|xfs_rtallocate_extent_block
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|i
argument_list|,
name|maxlen
argument_list|,
name|maxlen
argument_list|,
name|len
argument_list|,
operator|&
name|n
argument_list|,
name|rbpp
argument_list|,
name|rsb
argument_list|,
name|prod
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 			 * If it worked, return that. 			 */
if|if
condition|(
name|r
operator|!=
name|NULLRTBLOCK
condition|)
block|{
operator|*
name|rtblock
operator|=
name|r
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 			 * If the "next block to try" returned from the 			 * allocator is beyond the next bitmap block, 			 * skip to that bitmap block. 			 */
if|if
condition|(
name|XFS_BITTOBLOCK
argument_list|(
name|mp
argument_list|,
name|n
argument_list|)
operator|>
name|i
operator|+
literal|1
condition|)
name|i
operator|=
name|XFS_BITTOBLOCK
argument_list|(
name|mp
argument_list|,
name|n
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Didn't find any maxlen blocks.  Try smaller ones, unless 	 * we're asking for a fixed size extent. 	 */
if|if
condition|(
name|minlen
operator|>
operator|--
name|maxlen
condition|)
block|{
operator|*
name|rtblock
operator|=
name|NULLRTBLOCK
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Loop over sizes, from maxlen down to minlen. 	 * This time, when we do the allocations, allow smaller ones 	 * to succeed. 	 */
for|for
control|(
name|l
operator|=
name|xfs_highbit32
argument_list|(
name|maxlen
argument_list|)
init|;
name|l
operator|>=
name|xfs_highbit32
argument_list|(
name|minlen
argument_list|)
condition|;
name|l
operator|--
control|)
block|{
comment|/* 		 * Loop over all the bitmap blocks, try an allocation 		 * starting in that block. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_rbmblocks
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * Get the summary information for this level/block. 			 */
name|error
operator|=
name|xfs_rtget_summary
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|l
argument_list|,
name|i
argument_list|,
name|rbpp
argument_list|,
name|rsb
argument_list|,
operator|&
name|sum
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 			 * If nothing there, go on to next. 			 */
if|if
condition|(
operator|!
name|sum
condition|)
continue|continue;
comment|/* 			 * Try the allocation.  Make sure the specified 			 * minlen/maxlen are in the possible range for 			 * this summary level. 			 */
name|error
operator|=
name|xfs_rtallocate_extent_block
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|i
argument_list|,
name|XFS_RTMAX
argument_list|(
name|minlen
argument_list|,
literal|1
operator|<<
name|l
argument_list|)
argument_list|,
name|XFS_RTMIN
argument_list|(
name|maxlen
argument_list|,
operator|(
literal|1
operator|<<
operator|(
name|l
operator|+
literal|1
operator|)
operator|)
operator|-
literal|1
argument_list|)
argument_list|,
name|len
argument_list|,
operator|&
name|n
argument_list|,
name|rbpp
argument_list|,
name|rsb
argument_list|,
name|prod
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 			 * If it worked, return that extent. 			 */
if|if
condition|(
name|r
operator|!=
name|NULLRTBLOCK
condition|)
block|{
operator|*
name|rtblock
operator|=
name|r
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 			 * If the "next block to try" returned from the 			 * allocator is beyond the next bitmap block, 			 * skip to that bitmap block. 			 */
if|if
condition|(
name|XFS_BITTOBLOCK
argument_list|(
name|mp
argument_list|,
name|n
argument_list|)
operator|>
name|i
operator|+
literal|1
condition|)
name|i
operator|=
name|XFS_BITTOBLOCK
argument_list|(
name|mp
argument_list|,
name|n
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Got nothing, return failure. 	 */
operator|*
name|rtblock
operator|=
name|NULLRTBLOCK
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Mark an extent specified by start and len allocated.  * Updates all the summary information as well as the bitmap.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_rtallocate_range
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_rtblock_t
name|start
parameter_list|,
comment|/* start block to allocate */
name|xfs_extlen_t
name|len
parameter_list|,
comment|/* length to allocate */
name|xfs_buf_t
modifier|*
modifier|*
name|rbpp
parameter_list|,
comment|/* in/out: summary block buffer */
name|xfs_fsblock_t
modifier|*
name|rsb
parameter_list|)
comment|/* in/out: summary block number */
block|{
name|xfs_rtblock_t
name|end
decl_stmt|;
comment|/* end of the allocated extent */
name|int
name|error
decl_stmt|;
comment|/* error value */
name|xfs_rtblock_t
name|postblock
decl_stmt|;
comment|/* first block allocated> end */
name|xfs_rtblock_t
name|preblock
decl_stmt|;
comment|/* first block allocated< start */
name|end
operator|=
name|start
operator|+
name|len
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Assume we're allocating out of the middle of a free extent. 	 * We need to find the beginning and end of the extent so we can 	 * properly update the summary. 	 */
name|error
operator|=
name|xfs_rtfind_back
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|start
argument_list|,
literal|0
argument_list|,
operator|&
name|preblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 	 * Find the next allocated block (end of free extent). 	 */
name|error
operator|=
name|xfs_rtfind_forw
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|end
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextents
operator|-
literal|1
argument_list|,
operator|&
name|postblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 	 * Decrement the summary information corresponding to the entire 	 * (old) free extent. 	 */
name|error
operator|=
name|xfs_rtmodify_summary
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|XFS_RTBLOCKLOG
argument_list|(
name|postblock
operator|+
literal|1
operator|-
name|preblock
argument_list|)
argument_list|,
name|XFS_BITTOBLOCK
argument_list|(
name|mp
argument_list|,
name|preblock
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|rbpp
argument_list|,
name|rsb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 	 * If there are blocks not being allocated at the front of the 	 * old extent, add summary data for them to be free. 	 */
if|if
condition|(
name|preblock
operator|<
name|start
condition|)
block|{
name|error
operator|=
name|xfs_rtmodify_summary
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|XFS_RTBLOCKLOG
argument_list|(
name|start
operator|-
name|preblock
argument_list|)
argument_list|,
name|XFS_BITTOBLOCK
argument_list|(
name|mp
argument_list|,
name|preblock
argument_list|)
argument_list|,
literal|1
argument_list|,
name|rbpp
argument_list|,
name|rsb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
comment|/* 	 * If there are blocks not being allocated at the end of the 	 * old extent, add summary data for them to be free. 	 */
if|if
condition|(
name|postblock
operator|>
name|end
condition|)
block|{
name|error
operator|=
name|xfs_rtmodify_summary
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|XFS_RTBLOCKLOG
argument_list|(
name|postblock
operator|-
name|end
argument_list|)
argument_list|,
name|XFS_BITTOBLOCK
argument_list|(
name|mp
argument_list|,
name|end
operator|+
literal|1
argument_list|)
argument_list|,
literal|1
argument_list|,
name|rbpp
argument_list|,
name|rsb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
comment|/* 	 * Modify the bitmap to mark this extent allocated. 	 */
name|error
operator|=
name|xfs_rtmodify_range
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|start
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Return whether there are any free extents in the size range given  * by low and high, for the bitmap block bbno.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_rtany_summary
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount structure */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|int
name|low
parameter_list|,
comment|/* low log2 extent size */
name|int
name|high
parameter_list|,
comment|/* high log2 extent size */
name|xfs_rtblock_t
name|bbno
parameter_list|,
comment|/* bitmap block number */
name|xfs_buf_t
modifier|*
modifier|*
name|rbpp
parameter_list|,
comment|/* in/out: summary block buffer */
name|xfs_fsblock_t
modifier|*
name|rsb
parameter_list|,
comment|/* in/out: summary block number */
name|int
modifier|*
name|stat
parameter_list|)
comment|/* out: any good extents here? */
block|{
name|int
name|error
decl_stmt|;
comment|/* error value */
name|int
name|log
decl_stmt|;
comment|/* loop counter, log2 of ext. size */
name|xfs_suminfo_t
name|sum
decl_stmt|;
comment|/* summary data */
comment|/* 	 * Loop over logs of extent sizes.  Order is irrelevant. 	 */
for|for
control|(
name|log
operator|=
name|low
init|;
name|log
operator|<=
name|high
condition|;
name|log
operator|++
control|)
block|{
comment|/* 		 * Get one summary datum. 		 */
name|error
operator|=
name|xfs_rtget_summary
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|log
argument_list|,
name|bbno
argument_list|,
name|rbpp
argument_list|,
name|rsb
argument_list|,
operator|&
name|sum
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 		 * If there are any, return success. 		 */
if|if
condition|(
name|sum
condition|)
block|{
operator|*
name|stat
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* 	 * Found nothing, return failure. 	 */
operator|*
name|stat
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Get a buffer for the bitmap or summary file block specified.  * The buffer is returned read and locked.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_rtbuf_get
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount structure */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_rtblock_t
name|block
parameter_list|,
comment|/* block number in bitmap or summary */
name|int
name|issum
parameter_list|,
comment|/* is summary not bitmap */
name|xfs_buf_t
modifier|*
modifier|*
name|bpp
parameter_list|)
comment|/* output: buffer for the block */
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* block buffer, result */
name|xfs_daddr_t
name|d
decl_stmt|;
comment|/* disk addr of block */
name|int
name|error
decl_stmt|;
comment|/* error value */
name|xfs_fsblock_t
name|fsb
decl_stmt|;
comment|/* fs block number for block */
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
comment|/* bitmap or summary inode */
name|ip
operator|=
name|issum
condition|?
name|mp
operator|->
name|m_rsumip
else|:
name|mp
operator|->
name|m_rbmip
expr_stmt|;
comment|/* 	 * Map from the file offset (block) and inode number to the 	 * file system block. 	 */
name|error
operator|=
name|xfs_bmapi_single
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_DATA_FORK
argument_list|,
operator|&
name|fsb
argument_list|,
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|fsb
operator|!=
name|NULLFSBLOCK
argument_list|)
expr_stmt|;
comment|/* 	 * Convert to disk address for buffer cache. 	 */
name|d
operator|=
name|XFS_FSB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|fsb
argument_list|)
expr_stmt|;
comment|/* 	 * Read the buffer. 	 */
name|error
operator|=
name|xfs_trans_read_buf
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|d
argument_list|,
name|mp
operator|->
name|m_bsize
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|bp
operator|&&
operator|!
name|XFS_BUF_GETERROR
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * Check that the given extent (block range) is allocated already.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_rtcheck_alloc_range
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_rtblock_t
name|bno
parameter_list|,
comment|/* starting block number of extent */
name|xfs_extlen_t
name|len
parameter_list|,
comment|/* length of extent */
name|int
modifier|*
name|stat
parameter_list|)
comment|/* out: 1 for allocated, 0 for not */
block|{
name|xfs_rtblock_t
name|new
decl_stmt|;
comment|/* dummy for xfs_rtcheck_range */
return|return
name|xfs_rtcheck_range
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|bno
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
operator|&
name|new
argument_list|,
name|stat
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * Check whether the given block in the bitmap has the given value.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* 1 for matches, 0 for not */
name|xfs_rtcheck_bit
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount structure */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_rtblock_t
name|start
parameter_list|,
comment|/* bit (block) to check */
name|int
name|val
parameter_list|)
comment|/* 1 for free, 0 for allocated */
block|{
name|int
name|bit
decl_stmt|;
comment|/* bit number in the word */
name|xfs_rtblock_t
name|block
decl_stmt|;
comment|/* bitmap block number */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buf for the block */
name|xfs_rtword_t
modifier|*
name|bufp
decl_stmt|;
comment|/* pointer into the buffer */
comment|/* REFERENCED */
name|int
name|error
decl_stmt|;
comment|/* error value */
name|xfs_rtword_t
name|wdiff
decl_stmt|;
comment|/* difference between bit& expected */
name|int
name|word
decl_stmt|;
comment|/* word number in the buffer */
name|xfs_rtword_t
name|wval
decl_stmt|;
comment|/* word value from buffer */
name|block
operator|=
name|XFS_BITTOBLOCK
argument_list|(
name|mp
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_rtbuf_get
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|block
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
name|bufp
operator|=
operator|(
name|xfs_rtword_t
operator|*
operator|)
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|word
operator|=
name|XFS_BITTOWORD
argument_list|(
name|mp
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|bit
operator|=
call|(
name|int
call|)
argument_list|(
name|start
operator|&
operator|(
name|XFS_NBWORD
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|wval
operator|=
name|bufp
index|[
name|word
index|]
expr_stmt|;
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|wdiff
operator|=
operator|(
name|wval
operator|^
operator|-
name|val
operator|)
operator|&
operator|(
operator|(
name|xfs_rtword_t
operator|)
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
return|return
operator|!
name|wdiff
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Check that the given extent (block range) is free already.  */
end_comment

begin_comment
unit|STATIC int
comment|/* error */
end_comment

begin_comment
unit|xfs_rtcheck_free_range( 	xfs_mount_t	*mp,
comment|/* file system mount point */
end_comment

begin_comment
unit|xfs_trans_t	*tp,
comment|/* transaction pointer */
end_comment

begin_comment
unit|xfs_rtblock_t	bno,
comment|/* starting block number of extent */
end_comment

begin_comment
unit|xfs_extlen_t	len,
comment|/* length of extent */
end_comment

begin_comment
unit|int		*stat)
comment|/* out: 1 for free, 0 for not */
end_comment

begin_comment
unit|{ 	xfs_rtblock_t	new;
comment|/* dummy for xfs_rtcheck_range */
end_comment

begin_endif
unit|return xfs_rtcheck_range(mp, tp, bno, len, 1,&new, stat); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Check that the given range is either all allocated (val = 0) or  * all free (val = 1).  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_rtcheck_range
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_rtblock_t
name|start
parameter_list|,
comment|/* starting block number of extent */
name|xfs_extlen_t
name|len
parameter_list|,
comment|/* length of extent */
name|int
name|val
parameter_list|,
comment|/* 1 for free, 0 for allocated */
name|xfs_rtblock_t
modifier|*
name|new
parameter_list|,
comment|/* out: first block not matching */
name|int
modifier|*
name|stat
parameter_list|)
comment|/* out: 1 for matches, 0 for not */
block|{
name|xfs_rtword_t
modifier|*
name|b
decl_stmt|;
comment|/* current word in buffer */
name|int
name|bit
decl_stmt|;
comment|/* bit number in the word */
name|xfs_rtblock_t
name|block
decl_stmt|;
comment|/* bitmap block number */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buf for the block */
name|xfs_rtword_t
modifier|*
name|bufp
decl_stmt|;
comment|/* starting word in buffer */
name|int
name|error
decl_stmt|;
comment|/* error value */
name|xfs_rtblock_t
name|i
decl_stmt|;
comment|/* current bit number rel. to start */
name|xfs_rtblock_t
name|lastbit
decl_stmt|;
comment|/* last useful bit in word */
name|xfs_rtword_t
name|mask
decl_stmt|;
comment|/* mask of relevant bits for value */
name|xfs_rtword_t
name|wdiff
decl_stmt|;
comment|/* difference from wanted value */
name|int
name|word
decl_stmt|;
comment|/* word number in the buffer */
comment|/* 	 * Compute starting bitmap block number 	 */
name|block
operator|=
name|XFS_BITTOBLOCK
argument_list|(
name|mp
argument_list|,
name|start
argument_list|)
expr_stmt|;
comment|/* 	 * Read the bitmap block. 	 */
name|error
operator|=
name|xfs_rtbuf_get
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|block
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|bufp
operator|=
operator|(
name|xfs_rtword_t
operator|*
operator|)
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Compute the starting word's address, and starting bit. 	 */
name|word
operator|=
name|XFS_BITTOWORD
argument_list|(
name|mp
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|b
operator|=
operator|&
name|bufp
index|[
name|word
index|]
expr_stmt|;
name|bit
operator|=
call|(
name|int
call|)
argument_list|(
name|start
operator|&
operator|(
name|XFS_NBWORD
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * 0 (allocated) => all zero's; 1 (free) => all one's. 	 */
name|val
operator|=
operator|-
name|val
expr_stmt|;
comment|/* 	 * If not starting on a word boundary, deal with the first 	 * (partial) word. 	 */
if|if
condition|(
name|bit
condition|)
block|{
comment|/* 		 * Compute first bit not examined. 		 */
name|lastbit
operator|=
name|XFS_RTMIN
argument_list|(
name|bit
operator|+
name|len
argument_list|,
name|XFS_NBWORD
argument_list|)
expr_stmt|;
comment|/* 		 * Mask of relevant bits. 		 */
name|mask
operator|=
operator|(
operator|(
operator|(
name|xfs_rtword_t
operator|)
literal|1
operator|<<
operator|(
name|lastbit
operator|-
name|bit
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
name|bit
expr_stmt|;
comment|/* 		 * Compute difference between actual and desired value. 		 */
if|if
condition|(
operator|(
name|wdiff
operator|=
operator|(
operator|*
name|b
operator|^
name|val
operator|)
operator|&
name|mask
operator|)
condition|)
block|{
comment|/* 			 * Different, compute first wrong bit and return. 			 */
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|i
operator|=
name|XFS_RTLOBIT
argument_list|(
name|wdiff
argument_list|)
operator|-
name|bit
expr_stmt|;
operator|*
name|new
operator|=
name|start
operator|+
name|i
expr_stmt|;
operator|*
name|stat
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|=
name|lastbit
operator|-
name|bit
expr_stmt|;
comment|/* 		 * Go on to next block if that's where the next word is 		 * and we need the next word. 		 */
if|if
condition|(
operator|++
name|word
operator|==
name|XFS_BLOCKWSIZE
argument_list|(
name|mp
argument_list|)
operator|&&
name|i
operator|<
name|len
condition|)
block|{
comment|/* 			 * If done with this block, get the next one. 			 */
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_rtbuf_get
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
operator|++
name|block
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|b
operator|=
name|bufp
operator|=
operator|(
name|xfs_rtword_t
operator|*
operator|)
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|word
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Go on to the next word in the buffer. 			 */
name|b
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Starting on a word boundary, no partial word. 		 */
name|i
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Loop over whole words in buffers.  When we use up one buffer 	 * we move on to the next one. 	 */
while|while
condition|(
name|len
operator|-
name|i
operator|>=
name|XFS_NBWORD
condition|)
block|{
comment|/* 		 * Compute difference between actual and desired value. 		 */
if|if
condition|(
operator|(
name|wdiff
operator|=
operator|*
name|b
operator|^
name|val
operator|)
condition|)
block|{
comment|/* 			 * Different, compute first wrong bit and return. 			 */
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|i
operator|+=
name|XFS_RTLOBIT
argument_list|(
name|wdiff
argument_list|)
expr_stmt|;
operator|*
name|new
operator|=
name|start
operator|+
name|i
expr_stmt|;
operator|*
name|stat
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|+=
name|XFS_NBWORD
expr_stmt|;
comment|/* 		 * Go on to next block if that's where the next word is 		 * and we need the next word. 		 */
if|if
condition|(
operator|++
name|word
operator|==
name|XFS_BLOCKWSIZE
argument_list|(
name|mp
argument_list|)
operator|&&
name|i
operator|<
name|len
condition|)
block|{
comment|/* 			 * If done with this block, get the next one. 			 */
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_rtbuf_get
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
operator|++
name|block
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|b
operator|=
name|bufp
operator|=
operator|(
name|xfs_rtword_t
operator|*
operator|)
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|word
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Go on to the next word in the buffer. 			 */
name|b
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * If not ending on a word boundary, deal with the last 	 * (partial) word. 	 */
if|if
condition|(
operator|(
name|lastbit
operator|=
name|len
operator|-
name|i
operator|)
condition|)
block|{
comment|/* 		 * Mask of relevant bits. 		 */
name|mask
operator|=
operator|(
operator|(
name|xfs_rtword_t
operator|)
literal|1
operator|<<
name|lastbit
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* 		 * Compute difference between actual and desired value. 		 */
if|if
condition|(
operator|(
name|wdiff
operator|=
operator|(
operator|*
name|b
operator|^
name|val
operator|)
operator|&
name|mask
operator|)
condition|)
block|{
comment|/* 			 * Different, compute first wrong bit and return. 			 */
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|i
operator|+=
name|XFS_RTLOBIT
argument_list|(
name|wdiff
argument_list|)
expr_stmt|;
operator|*
name|new
operator|=
name|start
operator|+
name|i
expr_stmt|;
operator|*
name|stat
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|i
operator|=
name|len
expr_stmt|;
block|}
comment|/* 	 * Successful, return. 	 */
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
operator|*
name|new
operator|=
name|start
operator|+
name|i
expr_stmt|;
operator|*
name|stat
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Copy and transform the summary file, given the old and new  * parameters in the mount structures.  */
end_comment

begin_decl_stmt
name|STATIC
name|int
comment|/* error */
name|xfs_rtcopy_summary
argument_list|(
name|xfs_mount_t
operator|*
expr|omp
argument_list|,
comment|/* old file system mount point */
name|xfs_mount_t
operator|*
name|nmp
argument_list|,
comment|/* new file system mount point */
name|xfs_trans_t
operator|*
name|tp
argument_list|)
comment|/* transaction pointer */
block|{
name|xfs_rtblock_t
name|bbno
decl_stmt|;
comment|/* bitmap block number */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* summary buffer */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|int
name|log
decl_stmt|;
comment|/* summary level number (log length) */
name|xfs_suminfo_t
name|sum
decl_stmt|;
comment|/* summary data */
name|xfs_fsblock_t
name|sumbno
decl_stmt|;
comment|/* summary block number */
name|bp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|log
operator|=
expr|omp
operator|->
name|m_rsumlevels
operator|-
literal|1
init|;
name|log
operator|>=
literal|0
condition|;
name|log
operator|--
control|)
block|{
for|for
control|(
name|bbno
operator|=
expr|omp
operator|->
name|m_sb
operator|.
name|sb_rbmblocks
operator|-
literal|1
init|;
operator|(
name|xfs_srtblock_t
operator|)
name|bbno
operator|>=
literal|0
condition|;
name|bbno
operator|--
control|)
block|{
name|error
operator|=
name|xfs_rtget_summary
argument_list|(omp,
name|tp
argument_list|,
name|log
argument_list|,
name|bbno
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|sumbno
argument_list|,
operator|&
name|sum
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|sum
operator|==
literal|0
condition|)
continue|continue;
name|error
operator|=
name|xfs_rtmodify_summary
argument_list|(omp,
name|tp
argument_list|,
name|log
argument_list|,
name|bbno
argument_list|,
operator|-
name|sum
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|sumbno
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|xfs_rtmodify_summary
argument_list|(
name|nmp
argument_list|,
name|tp
argument_list|,
name|log
argument_list|,
name|bbno
argument_list|,
name|sum
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|sumbno
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|ASSERT
argument_list|(
name|sum
operator|>
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Searching backward from start to limit, find the first block whose  * allocated/free state is different from start's.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_rtfind_back
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_rtblock_t
name|start
parameter_list|,
comment|/* starting block to look at */
name|xfs_rtblock_t
name|limit
parameter_list|,
comment|/* last block to look at */
name|xfs_rtblock_t
modifier|*
name|rtblock
parameter_list|)
comment|/* out: start block found */
block|{
name|xfs_rtword_t
modifier|*
name|b
decl_stmt|;
comment|/* current word in buffer */
name|int
name|bit
decl_stmt|;
comment|/* bit number in the word */
name|xfs_rtblock_t
name|block
decl_stmt|;
comment|/* bitmap block number */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buf for the block */
name|xfs_rtword_t
modifier|*
name|bufp
decl_stmt|;
comment|/* starting word in buffer */
name|int
name|error
decl_stmt|;
comment|/* error value */
name|xfs_rtblock_t
name|firstbit
decl_stmt|;
comment|/* first useful bit in the word */
name|xfs_rtblock_t
name|i
decl_stmt|;
comment|/* current bit number rel. to start */
name|xfs_rtblock_t
name|len
decl_stmt|;
comment|/* length of inspected area */
name|xfs_rtword_t
name|mask
decl_stmt|;
comment|/* mask of relevant bits for value */
name|xfs_rtword_t
name|want
decl_stmt|;
comment|/* mask for "good" values */
name|xfs_rtword_t
name|wdiff
decl_stmt|;
comment|/* difference from wanted value */
name|int
name|word
decl_stmt|;
comment|/* word number in the buffer */
comment|/* 	 * Compute and read in starting bitmap block for starting block. 	 */
name|block
operator|=
name|XFS_BITTOBLOCK
argument_list|(
name|mp
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_rtbuf_get
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|block
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|bufp
operator|=
operator|(
name|xfs_rtword_t
operator|*
operator|)
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Get the first word's index& point to it. 	 */
name|word
operator|=
name|XFS_BITTOWORD
argument_list|(
name|mp
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|b
operator|=
operator|&
name|bufp
index|[
name|word
index|]
expr_stmt|;
name|bit
operator|=
call|(
name|int
call|)
argument_list|(
name|start
operator|&
operator|(
name|XFS_NBWORD
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|start
operator|-
name|limit
operator|+
literal|1
expr_stmt|;
comment|/* 	 * Compute match value, based on the bit at start: if 1 (free) 	 * then all-ones, else all-zeroes. 	 */
name|want
operator|=
operator|(
operator|*
name|b
operator|&
operator|(
operator|(
name|xfs_rtword_t
operator|)
literal|1
operator|<<
name|bit
operator|)
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
comment|/* 	 * If the starting position is not word-aligned, deal with the 	 * partial word. 	 */
if|if
condition|(
name|bit
operator|<
name|XFS_NBWORD
operator|-
literal|1
condition|)
block|{
comment|/* 		 * Calculate first (leftmost) bit number to look at, 		 * and mask for all the relevant bits in this word. 		 */
name|firstbit
operator|=
name|XFS_RTMAX
argument_list|(
call|(
name|xfs_srtblock_t
call|)
argument_list|(
name|bit
operator|-
name|len
operator|+
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
operator|(
name|xfs_rtword_t
operator|)
literal|1
operator|<<
operator|(
name|bit
operator|-
name|firstbit
operator|+
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
name|firstbit
expr_stmt|;
comment|/* 		 * Calculate the difference between the value there 		 * and what we're looking for. 		 */
if|if
condition|(
operator|(
name|wdiff
operator|=
operator|(
operator|*
name|b
operator|^
name|want
operator|)
operator|&
name|mask
operator|)
condition|)
block|{
comment|/* 			 * Different.  Mark where we are and return. 			 */
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|i
operator|=
name|bit
operator|-
name|XFS_RTHIBIT
argument_list|(
name|wdiff
argument_list|)
expr_stmt|;
operator|*
name|rtblock
operator|=
name|start
operator|-
name|i
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|=
name|bit
operator|-
name|firstbit
operator|+
literal|1
expr_stmt|;
comment|/* 		 * Go on to previous block if that's where the previous word is 		 * and we need the previous word. 		 */
if|if
condition|(
operator|--
name|word
operator|==
operator|-
literal|1
operator|&&
name|i
operator|<
name|len
condition|)
block|{
comment|/* 			 * If done with this block, get the previous one. 			 */
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_rtbuf_get
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
operator|--
name|block
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|bufp
operator|=
operator|(
name|xfs_rtword_t
operator|*
operator|)
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|word
operator|=
name|XFS_BLOCKWMASK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|b
operator|=
operator|&
name|bufp
index|[
name|word
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Go on to the previous word in the buffer. 			 */
name|b
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Starting on a word boundary, no partial word. 		 */
name|i
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Loop over whole words in buffers.  When we use up one buffer 	 * we move on to the previous one. 	 */
while|while
condition|(
name|len
operator|-
name|i
operator|>=
name|XFS_NBWORD
condition|)
block|{
comment|/* 		 * Compute difference between actual and desired value. 		 */
if|if
condition|(
operator|(
name|wdiff
operator|=
operator|*
name|b
operator|^
name|want
operator|)
condition|)
block|{
comment|/* 			 * Different, mark where we are and return. 			 */
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|i
operator|+=
name|XFS_NBWORD
operator|-
literal|1
operator|-
name|XFS_RTHIBIT
argument_list|(
name|wdiff
argument_list|)
expr_stmt|;
operator|*
name|rtblock
operator|=
name|start
operator|-
name|i
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|+=
name|XFS_NBWORD
expr_stmt|;
comment|/* 		 * Go on to previous block if that's where the previous word is 		 * and we need the previous word. 		 */
if|if
condition|(
operator|--
name|word
operator|==
operator|-
literal|1
operator|&&
name|i
operator|<
name|len
condition|)
block|{
comment|/* 			 * If done with this block, get the previous one. 			 */
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_rtbuf_get
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
operator|--
name|block
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|bufp
operator|=
operator|(
name|xfs_rtword_t
operator|*
operator|)
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|word
operator|=
name|XFS_BLOCKWMASK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|b
operator|=
operator|&
name|bufp
index|[
name|word
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Go on to the previous word in the buffer. 			 */
name|b
operator|--
expr_stmt|;
block|}
block|}
comment|/* 	 * If not ending on a word boundary, deal with the last 	 * (partial) word. 	 */
if|if
condition|(
name|len
operator|-
name|i
condition|)
block|{
comment|/* 		 * Calculate first (leftmost) bit number to look at, 		 * and mask for all the relevant bits in this word. 		 */
name|firstbit
operator|=
name|XFS_NBWORD
operator|-
operator|(
name|len
operator|-
name|i
operator|)
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
operator|(
name|xfs_rtword_t
operator|)
literal|1
operator|<<
operator|(
name|len
operator|-
name|i
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
name|firstbit
expr_stmt|;
comment|/* 		 * Compute difference between actual and desired value. 		 */
if|if
condition|(
operator|(
name|wdiff
operator|=
operator|(
operator|*
name|b
operator|^
name|want
operator|)
operator|&
name|mask
operator|)
condition|)
block|{
comment|/* 			 * Different, mark where we are and return. 			 */
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|i
operator|+=
name|XFS_NBWORD
operator|-
literal|1
operator|-
name|XFS_RTHIBIT
argument_list|(
name|wdiff
argument_list|)
expr_stmt|;
operator|*
name|rtblock
operator|=
name|start
operator|-
name|i
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|i
operator|=
name|len
expr_stmt|;
block|}
comment|/* 	 * No match, return that we scanned the whole area. 	 */
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
operator|*
name|rtblock
operator|=
name|start
operator|-
name|i
operator|+
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Searching forward from start to limit, find the first block whose  * allocated/free state is different from start's.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_rtfind_forw
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_rtblock_t
name|start
parameter_list|,
comment|/* starting block to look at */
name|xfs_rtblock_t
name|limit
parameter_list|,
comment|/* last block to look at */
name|xfs_rtblock_t
modifier|*
name|rtblock
parameter_list|)
comment|/* out: start block found */
block|{
name|xfs_rtword_t
modifier|*
name|b
decl_stmt|;
comment|/* current word in buffer */
name|int
name|bit
decl_stmt|;
comment|/* bit number in the word */
name|xfs_rtblock_t
name|block
decl_stmt|;
comment|/* bitmap block number */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buf for the block */
name|xfs_rtword_t
modifier|*
name|bufp
decl_stmt|;
comment|/* starting word in buffer */
name|int
name|error
decl_stmt|;
comment|/* error value */
name|xfs_rtblock_t
name|i
decl_stmt|;
comment|/* current bit number rel. to start */
name|xfs_rtblock_t
name|lastbit
decl_stmt|;
comment|/* last useful bit in the word */
name|xfs_rtblock_t
name|len
decl_stmt|;
comment|/* length of inspected area */
name|xfs_rtword_t
name|mask
decl_stmt|;
comment|/* mask of relevant bits for value */
name|xfs_rtword_t
name|want
decl_stmt|;
comment|/* mask for "good" values */
name|xfs_rtword_t
name|wdiff
decl_stmt|;
comment|/* difference from wanted value */
name|int
name|word
decl_stmt|;
comment|/* word number in the buffer */
comment|/* 	 * Compute and read in starting bitmap block for starting block. 	 */
name|block
operator|=
name|XFS_BITTOBLOCK
argument_list|(
name|mp
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_rtbuf_get
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|block
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|bufp
operator|=
operator|(
name|xfs_rtword_t
operator|*
operator|)
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Get the first word's index& point to it. 	 */
name|word
operator|=
name|XFS_BITTOWORD
argument_list|(
name|mp
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|b
operator|=
operator|&
name|bufp
index|[
name|word
index|]
expr_stmt|;
name|bit
operator|=
call|(
name|int
call|)
argument_list|(
name|start
operator|&
operator|(
name|XFS_NBWORD
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|limit
operator|-
name|start
operator|+
literal|1
expr_stmt|;
comment|/* 	 * Compute match value, based on the bit at start: if 1 (free) 	 * then all-ones, else all-zeroes. 	 */
name|want
operator|=
operator|(
operator|*
name|b
operator|&
operator|(
operator|(
name|xfs_rtword_t
operator|)
literal|1
operator|<<
name|bit
operator|)
operator|)
condition|?
operator|-
literal|1
else|:
literal|0
expr_stmt|;
comment|/* 	 * If the starting position is not word-aligned, deal with the 	 * partial word. 	 */
if|if
condition|(
name|bit
condition|)
block|{
comment|/* 		 * Calculate last (rightmost) bit number to look at, 		 * and mask for all the relevant bits in this word. 		 */
name|lastbit
operator|=
name|XFS_RTMIN
argument_list|(
name|bit
operator|+
name|len
argument_list|,
name|XFS_NBWORD
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
operator|(
name|xfs_rtword_t
operator|)
literal|1
operator|<<
operator|(
name|lastbit
operator|-
name|bit
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
name|bit
expr_stmt|;
comment|/* 		 * Calculate the difference between the value there 		 * and what we're looking for. 		 */
if|if
condition|(
operator|(
name|wdiff
operator|=
operator|(
operator|*
name|b
operator|^
name|want
operator|)
operator|&
name|mask
operator|)
condition|)
block|{
comment|/* 			 * Different.  Mark where we are and return. 			 */
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|i
operator|=
name|XFS_RTLOBIT
argument_list|(
name|wdiff
argument_list|)
operator|-
name|bit
expr_stmt|;
operator|*
name|rtblock
operator|=
name|start
operator|+
name|i
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|=
name|lastbit
operator|-
name|bit
expr_stmt|;
comment|/* 		 * Go on to next block if that's where the next word is 		 * and we need the next word. 		 */
if|if
condition|(
operator|++
name|word
operator|==
name|XFS_BLOCKWSIZE
argument_list|(
name|mp
argument_list|)
operator|&&
name|i
operator|<
name|len
condition|)
block|{
comment|/* 			 * If done with this block, get the previous one. 			 */
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_rtbuf_get
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
operator|++
name|block
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|b
operator|=
name|bufp
operator|=
operator|(
name|xfs_rtword_t
operator|*
operator|)
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|word
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Go on to the previous word in the buffer. 			 */
name|b
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Starting on a word boundary, no partial word. 		 */
name|i
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Loop over whole words in buffers.  When we use up one buffer 	 * we move on to the next one. 	 */
while|while
condition|(
name|len
operator|-
name|i
operator|>=
name|XFS_NBWORD
condition|)
block|{
comment|/* 		 * Compute difference between actual and desired value. 		 */
if|if
condition|(
operator|(
name|wdiff
operator|=
operator|*
name|b
operator|^
name|want
operator|)
condition|)
block|{
comment|/* 			 * Different, mark where we are and return. 			 */
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|i
operator|+=
name|XFS_RTLOBIT
argument_list|(
name|wdiff
argument_list|)
expr_stmt|;
operator|*
name|rtblock
operator|=
name|start
operator|+
name|i
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|+=
name|XFS_NBWORD
expr_stmt|;
comment|/* 		 * Go on to next block if that's where the next word is 		 * and we need the next word. 		 */
if|if
condition|(
operator|++
name|word
operator|==
name|XFS_BLOCKWSIZE
argument_list|(
name|mp
argument_list|)
operator|&&
name|i
operator|<
name|len
condition|)
block|{
comment|/* 			 * If done with this block, get the next one. 			 */
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_rtbuf_get
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
operator|++
name|block
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|b
operator|=
name|bufp
operator|=
operator|(
name|xfs_rtword_t
operator|*
operator|)
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|word
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Go on to the next word in the buffer. 			 */
name|b
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * If not ending on a word boundary, deal with the last 	 * (partial) word. 	 */
if|if
condition|(
operator|(
name|lastbit
operator|=
name|len
operator|-
name|i
operator|)
condition|)
block|{
comment|/* 		 * Calculate mask for all the relevant bits in this word. 		 */
name|mask
operator|=
operator|(
operator|(
name|xfs_rtword_t
operator|)
literal|1
operator|<<
name|lastbit
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* 		 * Compute difference between actual and desired value. 		 */
if|if
condition|(
operator|(
name|wdiff
operator|=
operator|(
operator|*
name|b
operator|^
name|want
operator|)
operator|&
name|mask
operator|)
condition|)
block|{
comment|/* 			 * Different, mark where we are and return. 			 */
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|i
operator|+=
name|XFS_RTLOBIT
argument_list|(
name|wdiff
argument_list|)
expr_stmt|;
operator|*
name|rtblock
operator|=
name|start
operator|+
name|i
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|i
operator|=
name|len
expr_stmt|;
block|}
comment|/* 	 * No match, return that we scanned the whole area. 	 */
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
operator|*
name|rtblock
operator|=
name|start
operator|+
name|i
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Mark an extent specified by start and len freed.  * Updates all the summary information as well as the bitmap.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_rtfree_range
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_rtblock_t
name|start
parameter_list|,
comment|/* starting block to free */
name|xfs_extlen_t
name|len
parameter_list|,
comment|/* length to free */
name|xfs_buf_t
modifier|*
modifier|*
name|rbpp
parameter_list|,
comment|/* in/out: summary block buffer */
name|xfs_fsblock_t
modifier|*
name|rsb
parameter_list|)
comment|/* in/out: summary block number */
block|{
name|xfs_rtblock_t
name|end
decl_stmt|;
comment|/* end of the freed extent */
name|int
name|error
decl_stmt|;
comment|/* error value */
name|xfs_rtblock_t
name|postblock
decl_stmt|;
comment|/* first block freed> end */
name|xfs_rtblock_t
name|preblock
decl_stmt|;
comment|/* first block freed< start */
name|end
operator|=
name|start
operator|+
name|len
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Modify the bitmap to mark this extent freed. 	 */
name|error
operator|=
name|xfs_rtmodify_range
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|start
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 	 * Assume we're freeing out of the middle of an allocated extent. 	 * We need to find the beginning and end of the extent so we can 	 * properly update the summary. 	 */
name|error
operator|=
name|xfs_rtfind_back
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|start
argument_list|,
literal|0
argument_list|,
operator|&
name|preblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 	 * Find the next allocated block (end of allocated extent). 	 */
name|error
operator|=
name|xfs_rtfind_forw
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|end
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextents
operator|-
literal|1
argument_list|,
operator|&
name|postblock
argument_list|)
expr_stmt|;
comment|/* 	 * If there are blocks not being freed at the front of the 	 * old extent, add summary data for them to be allocated. 	 */
if|if
condition|(
name|preblock
operator|<
name|start
condition|)
block|{
name|error
operator|=
name|xfs_rtmodify_summary
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|XFS_RTBLOCKLOG
argument_list|(
name|start
operator|-
name|preblock
argument_list|)
argument_list|,
name|XFS_BITTOBLOCK
argument_list|(
name|mp
argument_list|,
name|preblock
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|rbpp
argument_list|,
name|rsb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
comment|/* 	 * If there are blocks not being freed at the end of the 	 * old extent, add summary data for them to be allocated. 	 */
if|if
condition|(
name|postblock
operator|>
name|end
condition|)
block|{
name|error
operator|=
name|xfs_rtmodify_summary
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|XFS_RTBLOCKLOG
argument_list|(
name|postblock
operator|-
name|end
argument_list|)
argument_list|,
name|XFS_BITTOBLOCK
argument_list|(
name|mp
argument_list|,
name|end
operator|+
literal|1
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|,
name|rbpp
argument_list|,
name|rsb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
comment|/* 	 * Increment the summary information corresponding to the entire 	 * (new) free extent. 	 */
name|error
operator|=
name|xfs_rtmodify_summary
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|XFS_RTBLOCKLOG
argument_list|(
name|postblock
operator|+
literal|1
operator|-
name|preblock
argument_list|)
argument_list|,
name|XFS_BITTOBLOCK
argument_list|(
name|mp
argument_list|,
name|preblock
argument_list|)
argument_list|,
literal|1
argument_list|,
name|rbpp
argument_list|,
name|rsb
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Read and return the summary information for a given extent size,  * bitmap block combination.  * Keeps track of a current summary block, so we don't keep reading  * it from the buffer cache.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_rtget_summary
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount structure */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|int
name|log
parameter_list|,
comment|/* log2 of extent size */
name|xfs_rtblock_t
name|bbno
parameter_list|,
comment|/* bitmap block number */
name|xfs_buf_t
modifier|*
modifier|*
name|rbpp
parameter_list|,
comment|/* in/out: summary block buffer */
name|xfs_fsblock_t
modifier|*
name|rsb
parameter_list|,
comment|/* in/out: summary block number */
name|xfs_suminfo_t
modifier|*
name|sum
parameter_list|)
comment|/* out: summary info for this block */
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buffer for summary block */
name|int
name|error
decl_stmt|;
comment|/* error value */
name|xfs_fsblock_t
name|sb
decl_stmt|;
comment|/* summary fsblock */
name|int
name|so
decl_stmt|;
comment|/* index into the summary file */
name|xfs_suminfo_t
modifier|*
name|sp
decl_stmt|;
comment|/* pointer to returned data */
comment|/* 	 * Compute entry number in the summary file. 	 */
name|so
operator|=
name|XFS_SUMOFFS
argument_list|(
name|mp
argument_list|,
name|log
argument_list|,
name|bbno
argument_list|)
expr_stmt|;
comment|/* 	 * Compute the block number in the summary file. 	 */
name|sb
operator|=
name|XFS_SUMOFFSTOBLOCK
argument_list|(
name|mp
argument_list|,
name|so
argument_list|)
expr_stmt|;
comment|/* 	 * If we have an old buffer, and the block number matches, use that. 	 */
if|if
condition|(
name|rbpp
operator|&&
operator|*
name|rbpp
operator|&&
operator|*
name|rsb
operator|==
name|sb
condition|)
name|bp
operator|=
operator|*
name|rbpp
expr_stmt|;
comment|/* 	 * Otherwise we have to get the buffer. 	 */
else|else
block|{
comment|/* 		 * If there was an old one, get rid of it first. 		 */
if|if
condition|(
name|rbpp
operator|&&
operator|*
name|rbpp
condition|)
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
operator|*
name|rbpp
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_rtbuf_get
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|sb
argument_list|,
literal|1
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 		 * Remember this buffer and block for the next call. 		 */
if|if
condition|(
name|rbpp
condition|)
block|{
operator|*
name|rbpp
operator|=
name|bp
expr_stmt|;
operator|*
name|rsb
operator|=
name|sb
expr_stmt|;
block|}
block|}
comment|/* 	 * Point to the summary information& copy it out. 	 */
name|sp
operator|=
name|XFS_SUMPTR
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|,
name|so
argument_list|)
expr_stmt|;
operator|*
name|sum
operator|=
operator|*
name|sp
expr_stmt|;
comment|/* 	 * Drop the buffer if we're not asked to remember it. 	 */
if|if
condition|(
operator|!
name|rbpp
condition|)
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Set the given range of bitmap bits to the given value.  * Do whatever I/O and logging is required.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_rtmodify_range
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_rtblock_t
name|start
parameter_list|,
comment|/* starting block to modify */
name|xfs_extlen_t
name|len
parameter_list|,
comment|/* length of extent to modify */
name|int
name|val
parameter_list|)
comment|/* 1 for free, 0 for allocated */
block|{
name|xfs_rtword_t
modifier|*
name|b
decl_stmt|;
comment|/* current word in buffer */
name|int
name|bit
decl_stmt|;
comment|/* bit number in the word */
name|xfs_rtblock_t
name|block
decl_stmt|;
comment|/* bitmap block number */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buf for the block */
name|xfs_rtword_t
modifier|*
name|bufp
decl_stmt|;
comment|/* starting word in buffer */
name|int
name|error
decl_stmt|;
comment|/* error value */
name|xfs_rtword_t
modifier|*
name|first
decl_stmt|;
comment|/* first used word in the buffer */
name|int
name|i
decl_stmt|;
comment|/* current bit number rel. to start */
name|int
name|lastbit
decl_stmt|;
comment|/* last useful bit in word */
name|xfs_rtword_t
name|mask
decl_stmt|;
comment|/* mask o frelevant bits for value */
name|int
name|word
decl_stmt|;
comment|/* word number in the buffer */
comment|/* 	 * Compute starting bitmap block number. 	 */
name|block
operator|=
name|XFS_BITTOBLOCK
argument_list|(
name|mp
argument_list|,
name|start
argument_list|)
expr_stmt|;
comment|/* 	 * Read the bitmap block, and point to its data. 	 */
name|error
operator|=
name|xfs_rtbuf_get
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|block
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|bufp
operator|=
operator|(
name|xfs_rtword_t
operator|*
operator|)
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Compute the starting word's address, and starting bit. 	 */
name|word
operator|=
name|XFS_BITTOWORD
argument_list|(
name|mp
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|first
operator|=
name|b
operator|=
operator|&
name|bufp
index|[
name|word
index|]
expr_stmt|;
name|bit
operator|=
call|(
name|int
call|)
argument_list|(
name|start
operator|&
operator|(
name|XFS_NBWORD
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * 0 (allocated) => all zeroes; 1 (free) => all ones. 	 */
name|val
operator|=
operator|-
name|val
expr_stmt|;
comment|/* 	 * If not starting on a word boundary, deal with the first 	 * (partial) word. 	 */
if|if
condition|(
name|bit
condition|)
block|{
comment|/* 		 * Compute first bit not changed and mask of relevant bits. 		 */
name|lastbit
operator|=
name|XFS_RTMIN
argument_list|(
name|bit
operator|+
name|len
argument_list|,
name|XFS_NBWORD
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
operator|(
name|xfs_rtword_t
operator|)
literal|1
operator|<<
operator|(
name|lastbit
operator|-
name|bit
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
name|bit
expr_stmt|;
comment|/* 		 * Set/clear the active bits. 		 */
if|if
condition|(
name|val
condition|)
operator|*
name|b
operator||=
name|mask
expr_stmt|;
else|else
operator|*
name|b
operator|&=
operator|~
name|mask
expr_stmt|;
name|i
operator|=
name|lastbit
operator|-
name|bit
expr_stmt|;
comment|/* 		 * Go on to the next block if that's where the next word is 		 * and we need the next word. 		 */
if|if
condition|(
operator|++
name|word
operator|==
name|XFS_BLOCKWSIZE
argument_list|(
name|mp
argument_list|)
operator|&&
name|i
operator|<
name|len
condition|)
block|{
comment|/* 			 * Log the changed part of this block. 			 * Get the next one. 			 */
name|xfs_trans_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|first
operator|-
operator|(
name|char
operator|*
operator|)
name|bufp
argument_list|)
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|b
operator|-
operator|(
name|char
operator|*
operator|)
name|bufp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_rtbuf_get
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
operator|++
name|block
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|first
operator|=
name|b
operator|=
name|bufp
operator|=
operator|(
name|xfs_rtword_t
operator|*
operator|)
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|word
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Go on to the next word in the buffer 			 */
name|b
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Starting on a word boundary, no partial word. 		 */
name|i
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Loop over whole words in buffers.  When we use up one buffer 	 * we move on to the next one. 	 */
while|while
condition|(
name|len
operator|-
name|i
operator|>=
name|XFS_NBWORD
condition|)
block|{
comment|/* 		 * Set the word value correctly. 		 */
operator|*
name|b
operator|=
name|val
expr_stmt|;
name|i
operator|+=
name|XFS_NBWORD
expr_stmt|;
comment|/* 		 * Go on to the next block if that's where the next word is 		 * and we need the next word. 		 */
if|if
condition|(
operator|++
name|word
operator|==
name|XFS_BLOCKWSIZE
argument_list|(
name|mp
argument_list|)
operator|&&
name|i
operator|<
name|len
condition|)
block|{
comment|/* 			 * Log the changed part of this block. 			 * Get the next one. 			 */
name|xfs_trans_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|first
operator|-
operator|(
name|char
operator|*
operator|)
name|bufp
argument_list|)
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|b
operator|-
operator|(
name|char
operator|*
operator|)
name|bufp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_rtbuf_get
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
operator|++
name|block
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|first
operator|=
name|b
operator|=
name|bufp
operator|=
operator|(
name|xfs_rtword_t
operator|*
operator|)
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|word
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Go on to the next word in the buffer 			 */
name|b
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * If not ending on a word boundary, deal with the last 	 * (partial) word. 	 */
if|if
condition|(
operator|(
name|lastbit
operator|=
name|len
operator|-
name|i
operator|)
condition|)
block|{
comment|/* 		 * Compute a mask of relevant bits. 		 */
name|bit
operator|=
literal|0
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
name|xfs_rtword_t
operator|)
literal|1
operator|<<
name|lastbit
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* 		 * Set/clear the active bits. 		 */
if|if
condition|(
name|val
condition|)
operator|*
name|b
operator||=
name|mask
expr_stmt|;
else|else
operator|*
name|b
operator|&=
operator|~
name|mask
expr_stmt|;
name|b
operator|++
expr_stmt|;
block|}
comment|/* 	 * Log any remaining changed bytes. 	 */
if|if
condition|(
name|b
operator|>
name|first
condition|)
name|xfs_trans_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|first
operator|-
operator|(
name|char
operator|*
operator|)
name|bufp
argument_list|)
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|b
operator|-
operator|(
name|char
operator|*
operator|)
name|bufp
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Read and modify the summary information for a given extent size,  * bitmap block combination.  * Keeps track of a current summary block, so we don't keep reading  * it from the buffer cache.  */
end_comment

begin_function
name|STATIC
name|int
comment|/* error */
name|xfs_rtmodify_summary
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|int
name|log
parameter_list|,
comment|/* log2 of extent size */
name|xfs_rtblock_t
name|bbno
parameter_list|,
comment|/* bitmap block number */
name|int
name|delta
parameter_list|,
comment|/* change to make to summary info */
name|xfs_buf_t
modifier|*
modifier|*
name|rbpp
parameter_list|,
comment|/* in/out: summary block buffer */
name|xfs_fsblock_t
modifier|*
name|rsb
parameter_list|)
comment|/* in/out: summary block number */
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buffer for the summary block */
name|int
name|error
decl_stmt|;
comment|/* error value */
name|xfs_fsblock_t
name|sb
decl_stmt|;
comment|/* summary fsblock */
name|int
name|so
decl_stmt|;
comment|/* index into the summary file */
name|xfs_suminfo_t
modifier|*
name|sp
decl_stmt|;
comment|/* pointer to returned data */
comment|/* 	 * Compute entry number in the summary file. 	 */
name|so
operator|=
name|XFS_SUMOFFS
argument_list|(
name|mp
argument_list|,
name|log
argument_list|,
name|bbno
argument_list|)
expr_stmt|;
comment|/* 	 * Compute the block number in the summary file. 	 */
name|sb
operator|=
name|XFS_SUMOFFSTOBLOCK
argument_list|(
name|mp
argument_list|,
name|so
argument_list|)
expr_stmt|;
comment|/* 	 * If we have an old buffer, and the block number matches, use that. 	 */
if|if
condition|(
name|rbpp
operator|&&
operator|*
name|rbpp
operator|&&
operator|*
name|rsb
operator|==
name|sb
condition|)
name|bp
operator|=
operator|*
name|rbpp
expr_stmt|;
comment|/* 	 * Otherwise we have to get the buffer. 	 */
else|else
block|{
comment|/* 		 * If there was an old one, get rid of it first. 		 */
if|if
condition|(
name|rbpp
operator|&&
operator|*
name|rbpp
condition|)
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
operator|*
name|rbpp
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_rtbuf_get
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|sb
argument_list|,
literal|1
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 		 * Remember this buffer and block for the next call. 		 */
if|if
condition|(
name|rbpp
condition|)
block|{
operator|*
name|rbpp
operator|=
name|bp
expr_stmt|;
operator|*
name|rsb
operator|=
name|sb
expr_stmt|;
block|}
block|}
comment|/* 	 * Point to the summary information, modify and log it. 	 */
name|sp
operator|=
name|XFS_SUMPTR
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|,
name|so
argument_list|)
expr_stmt|;
operator|*
name|sp
operator|+=
name|delta
expr_stmt|;
name|xfs_trans_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
operator|-
operator|(
name|char
operator|*
operator|)
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
argument_list|)
argument_list|,
call|(
name|uint
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
operator|-
operator|(
name|char
operator|*
operator|)
name|XFS_BUF_PTR
argument_list|(
name|bp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|sp
argument_list|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Visible (exported) functions.  */
end_comment

begin_comment
comment|/*  * Grow the realtime area of the filesystem.  */
end_comment

begin_function
name|int
name|xfs_growfs_rt
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* mount point for filesystem */
name|xfs_growfs_rt_t
modifier|*
name|in
parameter_list|)
comment|/* growfs rt input struct */
block|{
name|xfs_rtblock_t
name|bmbno
decl_stmt|;
comment|/* bitmap block number */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* temporary buffer */
name|int
name|cancelflags
decl_stmt|;
comment|/* flags for xfs_trans_cancel */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
comment|/* bitmap inode, used as lock */
name|xfs_mount_t
modifier|*
name|nmp
decl_stmt|;
comment|/* new (fake) mount structure */
name|xfs_drfsbno_t
name|nrblocks
decl_stmt|;
comment|/* new number of realtime blocks */
name|xfs_extlen_t
name|nrbmblocks
decl_stmt|;
comment|/* new number of rt bitmap blocks */
name|xfs_drtbno_t
name|nrextents
decl_stmt|;
comment|/* new number of realtime extents */
name|uint8_t
name|nrextslog
decl_stmt|;
comment|/* new log2 of sb_rextents */
name|xfs_extlen_t
name|nrsumblocks
decl_stmt|;
comment|/* new number of summary blocks */
name|uint
name|nrsumlevels
decl_stmt|;
comment|/* new rt summary levels */
name|uint
name|nrsumsize
decl_stmt|;
comment|/* new size of rt summary, bytes */
name|xfs_sb_t
modifier|*
name|nsbp
decl_stmt|;
comment|/* new superblock */
name|xfs_extlen_t
name|rbmblocks
decl_stmt|;
comment|/* current number of rt bitmap blocks */
name|xfs_extlen_t
name|rsumblocks
decl_stmt|;
comment|/* current number of rt summary blks */
name|xfs_sb_t
modifier|*
name|sbp
decl_stmt|;
comment|/* old superblock */
name|xfs_fsblock_t
name|sumbno
decl_stmt|;
comment|/* summary block number */
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
comment|/* transaction pointer */
name|sbp
operator|=
operator|&
name|mp
operator|->
name|m_sb
expr_stmt|;
comment|/* 	 * Initial error checking. 	 */
if|if
condition|(
name|mp
operator|->
name|m_rtdev_targp
operator|||
name|mp
operator|->
name|m_rbmip
operator|==
name|NULL
operator|||
operator|(
name|nrblocks
operator|=
name|in
operator|->
name|newblocks
operator|)
operator|<=
name|sbp
operator|->
name|sb_rblocks
operator|||
operator|(
name|sbp
operator|->
name|sb_rblocks
operator|&&
operator|(
name|in
operator|->
name|extsize
operator|!=
name|sbp
operator|->
name|sb_rextsize
operator|)
operator|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
comment|/* 	 * Read in the last block of the device, make sure it exists. 	 */
name|error
operator|=
name|xfs_read_buf
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_rtdev_targp
argument_list|,
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|in
operator|->
name|newblocks
operator|-
literal|1
argument_list|)
argument_list|,
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|ASSERT
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate new parameters.  These are the final values to be reached. 	 */
name|nrextents
operator|=
name|nrblocks
expr_stmt|;
name|do_div
argument_list|(
name|nrextents
argument_list|,
name|in
operator|->
name|extsize
argument_list|)
expr_stmt|;
name|nrbmblocks
operator|=
name|roundup_64
argument_list|(
name|nrextents
argument_list|,
name|NBBY
operator|*
name|sbp
operator|->
name|sb_blocksize
argument_list|)
expr_stmt|;
name|nrextslog
operator|=
name|xfs_highbit32
argument_list|(
name|nrextents
argument_list|)
expr_stmt|;
name|nrsumlevels
operator|=
name|nrextslog
operator|+
literal|1
expr_stmt|;
name|nrsumsize
operator|=
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_suminfo_t
argument_list|)
operator|*
name|nrsumlevels
operator|*
name|nrbmblocks
expr_stmt|;
name|nrsumblocks
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
name|nrsumsize
argument_list|)
expr_stmt|;
name|nrsumsize
operator|=
name|XFS_FSB_TO_B
argument_list|(
name|mp
argument_list|,
name|nrsumblocks
argument_list|)
expr_stmt|;
comment|/* 	 * New summary size can't be more than half the size of 	 * the log.  This prevents us from getting a log overflow, 	 * since we'll log basically the whole summary file at once. 	 */
if|if
condition|(
name|nrsumblocks
operator|>
operator|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_logblocks
operator|>>
literal|1
operator|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
comment|/* 	 * Get the old block counts for bitmap and summary inodes. 	 * These can't change since other growfs callers are locked out. 	 */
name|rbmblocks
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_rbmip
operator|->
name|i_d
operator|.
name|di_size
argument_list|)
expr_stmt|;
name|rsumblocks
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_rsumip
operator|->
name|i_d
operator|.
name|di_size
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate space to the bitmap and summary files, as necessary. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_growfs_rt_alloc
argument_list|(
name|mp
argument_list|,
name|rbmblocks
argument_list|,
name|nrbmblocks
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_rbmino
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_growfs_rt_alloc
argument_list|(
name|mp
argument_list|,
name|rsumblocks
argument_list|,
name|nrsumblocks
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_rsumino
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|nmp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Loop over the bitmap blocks. 	 * We will do everything one bitmap block at a time. 	 * Skip the current block if it is exactly full. 	 * This also deals with the case where there were no rtextents before. 	 */
for|for
control|(
name|bmbno
operator|=
name|sbp
operator|->
name|sb_rbmblocks
operator|-
operator|(
operator|(
name|sbp
operator|->
name|sb_rextents
operator|&
operator|(
operator|(
literal|1
operator|<<
name|mp
operator|->
name|m_blkbit_log
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
operator|)
init|;
name|bmbno
operator|<
name|nrbmblocks
condition|;
name|bmbno
operator|++
control|)
block|{
comment|/* 		 * Allocate a new (fake) mount/sb. 		 */
name|nmp
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nmp
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|*
name|nmp
operator|=
operator|*
name|mp
expr_stmt|;
name|nsbp
operator|=
operator|&
name|nmp
operator|->
name|m_sb
expr_stmt|;
comment|/* 		 * Calculate new sb and mount fields for this round. 		 */
name|nsbp
operator|->
name|sb_rextsize
operator|=
name|in
operator|->
name|extsize
expr_stmt|;
name|nsbp
operator|->
name|sb_rbmblocks
operator|=
name|bmbno
operator|+
literal|1
expr_stmt|;
name|nsbp
operator|->
name|sb_rblocks
operator|=
name|XFS_RTMIN
argument_list|(
name|nrblocks
argument_list|,
name|nsbp
operator|->
name|sb_rbmblocks
operator|*
name|NBBY
operator|*
name|nsbp
operator|->
name|sb_blocksize
operator|*
name|nsbp
operator|->
name|sb_rextsize
argument_list|)
expr_stmt|;
name|nsbp
operator|->
name|sb_rextents
operator|=
name|nsbp
operator|->
name|sb_rblocks
expr_stmt|;
name|do_div
argument_list|(
name|nsbp
operator|->
name|sb_rextents
argument_list|,
name|nsbp
operator|->
name|sb_rextsize
argument_list|)
expr_stmt|;
name|nsbp
operator|->
name|sb_rextslog
operator|=
name|xfs_highbit32
argument_list|(
name|nsbp
operator|->
name|sb_rextents
argument_list|)
expr_stmt|;
name|nrsumlevels
operator|=
name|nmp
operator|->
name|m_rsumlevels
operator|=
name|nsbp
operator|->
name|sb_rextslog
operator|+
literal|1
expr_stmt|;
name|nrsumsize
operator|=
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_suminfo_t
argument_list|)
operator|*
name|nrsumlevels
operator|*
name|nsbp
operator|->
name|sb_rbmblocks
expr_stmt|;
name|nrsumblocks
operator|=
name|XFS_B_TO_FSB
argument_list|(
name|mp
argument_list|,
name|nrsumsize
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|m_rsumsize
operator|=
name|nrsumsize
operator|=
name|XFS_FSB_TO_B
argument_list|(
name|mp
argument_list|,
name|nrsumblocks
argument_list|)
expr_stmt|;
comment|/* 		 * Start a transaction, get the log reservation. 		 */
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_GROWFSRT_FREE
argument_list|)
expr_stmt|;
name|cancelflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_GROWRTFREE_LOG_RES
argument_list|(
name|nmp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
goto|goto
name|error_exit
goto|;
comment|/* 		 * Lock out other callers by grabbing the bitmap inode lock. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_iget
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_rbmino
argument_list|,
literal|0
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|,
operator|&
name|ip
argument_list|)
operator|)
condition|)
goto|goto
name|error_exit
goto|;
name|ASSERT
argument_list|(
name|ip
operator|==
name|mp
operator|->
name|m_rbmip
argument_list|)
expr_stmt|;
comment|/* 		 * Update the bitmap inode's size. 		 */
name|mp
operator|->
name|m_rbmip
operator|->
name|i_d
operator|.
name|di_size
operator|=
name|nsbp
operator|->
name|sb_rbmblocks
operator|*
name|nsbp
operator|->
name|sb_blocksize
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|mp
operator|->
name|m_rbmip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
name|cancelflags
operator||=
name|XFS_TRANS_ABORT
expr_stmt|;
comment|/* 		 * Get the summary inode into the transaction. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_iget
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_rsumino
argument_list|,
literal|0
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|,
operator|&
name|ip
argument_list|)
operator|)
condition|)
goto|goto
name|error_exit
goto|;
name|ASSERT
argument_list|(
name|ip
operator|==
name|mp
operator|->
name|m_rsumip
argument_list|)
expr_stmt|;
comment|/* 		 * Update the summary inode's size. 		 */
name|mp
operator|->
name|m_rsumip
operator|->
name|i_d
operator|.
name|di_size
operator|=
name|nmp
operator|->
name|m_rsumsize
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|mp
operator|->
name|m_rsumip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
comment|/* 		 * Copy summary data from old to new sizes. 		 * Do this when the real size (not block-aligned) changes. 		 */
if|if
condition|(
name|sbp
operator|->
name|sb_rbmblocks
operator|!=
name|nsbp
operator|->
name|sb_rbmblocks
operator|||
name|mp
operator|->
name|m_rsumlevels
operator|!=
name|nmp
operator|->
name|m_rsumlevels
condition|)
block|{
name|error
operator|=
name|xfs_rtcopy_summary
argument_list|(
name|mp
argument_list|,
name|nmp
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error_exit
goto|;
block|}
comment|/* 		 * Update superblock fields. 		 */
if|if
condition|(
name|nsbp
operator|->
name|sb_rextsize
operator|!=
name|sbp
operator|->
name|sb_rextsize
condition|)
name|xfs_trans_mod_sb
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_SB_REXTSIZE
argument_list|,
name|nsbp
operator|->
name|sb_rextsize
operator|-
name|sbp
operator|->
name|sb_rextsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsbp
operator|->
name|sb_rbmblocks
operator|!=
name|sbp
operator|->
name|sb_rbmblocks
condition|)
name|xfs_trans_mod_sb
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_SB_RBMBLOCKS
argument_list|,
name|nsbp
operator|->
name|sb_rbmblocks
operator|-
name|sbp
operator|->
name|sb_rbmblocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsbp
operator|->
name|sb_rblocks
operator|!=
name|sbp
operator|->
name|sb_rblocks
condition|)
name|xfs_trans_mod_sb
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_SB_RBLOCKS
argument_list|,
name|nsbp
operator|->
name|sb_rblocks
operator|-
name|sbp
operator|->
name|sb_rblocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsbp
operator|->
name|sb_rextents
operator|!=
name|sbp
operator|->
name|sb_rextents
condition|)
name|xfs_trans_mod_sb
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_SB_REXTENTS
argument_list|,
name|nsbp
operator|->
name|sb_rextents
operator|-
name|sbp
operator|->
name|sb_rextents
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsbp
operator|->
name|sb_rextslog
operator|!=
name|sbp
operator|->
name|sb_rextslog
condition|)
name|xfs_trans_mod_sb
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_SB_REXTSLOG
argument_list|,
name|nsbp
operator|->
name|sb_rextslog
operator|-
name|sbp
operator|->
name|sb_rextslog
argument_list|)
expr_stmt|;
comment|/* 		 * Free new extent. 		 */
name|bp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|xfs_rtfree_range
argument_list|(
name|nmp
argument_list|,
name|tp
argument_list|,
name|sbp
operator|->
name|sb_rextents
argument_list|,
name|nsbp
operator|->
name|sb_rextents
operator|-
name|sbp
operator|->
name|sb_rextents
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|sumbno
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error_exit
goto|;
comment|/* 		 * Mark more blocks free in the superblock. 		 */
name|xfs_trans_mod_sb
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_SB_FREXTENTS
argument_list|,
name|nsbp
operator|->
name|sb_rextents
operator|-
name|sbp
operator|->
name|sb_rextents
argument_list|)
expr_stmt|;
comment|/* 		 * Free the fake mp structure. 		 */
name|kmem_free
argument_list|(
name|nmp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nmp
argument_list|)
argument_list|)
expr_stmt|;
name|nmp
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Update mp values into the real mp structure. 		 */
name|mp
operator|->
name|m_rsumlevels
operator|=
name|nrsumlevels
expr_stmt|;
name|mp
operator|->
name|m_rsumsize
operator|=
name|nrsumsize
expr_stmt|;
comment|/* 		 * Commit the transaction. 		 */
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* 	 * Error paths come here. 	 */
name|error_exit
label|:
if|if
condition|(
name|nmp
condition|)
name|kmem_free
argument_list|(
name|nmp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nmp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
name|cancelflags
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate an extent in the realtime subvolume, with the usual allocation  * parameters.  The length units are all in realtime extents, as is the  * result block number.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_rtallocate_extent
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_rtblock_t
name|bno
parameter_list|,
comment|/* starting block number to allocate */
name|xfs_extlen_t
name|minlen
parameter_list|,
comment|/* minimum length to allocate */
name|xfs_extlen_t
name|maxlen
parameter_list|,
comment|/* maximum length to allocate */
name|xfs_extlen_t
modifier|*
name|len
parameter_list|,
comment|/* out: actual length allocated */
name|xfs_alloctype_t
name|type
parameter_list|,
comment|/* allocation type XFS_ALLOCTYPE... */
name|int
name|wasdel
parameter_list|,
comment|/* was a delayed allocation extent */
name|xfs_extlen_t
name|prod
parameter_list|,
comment|/* extent product factor */
name|xfs_rtblock_t
modifier|*
name|rtblock
parameter_list|)
comment|/* out: start block allocated */
block|{
name|int
name|error
decl_stmt|;
comment|/* error value */
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
comment|/* inode for bitmap file */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* file system mount structure */
name|xfs_rtblock_t
name|r
decl_stmt|;
comment|/* result allocated block */
name|xfs_fsblock_t
name|sb
decl_stmt|;
comment|/* summary file block number */
name|xfs_buf_t
modifier|*
name|sumbp
decl_stmt|;
comment|/* summary file block buffer */
name|ASSERT
argument_list|(
name|minlen
operator|>
literal|0
operator|&&
name|minlen
operator|<=
name|maxlen
argument_list|)
expr_stmt|;
name|mp
operator|=
name|tp
operator|->
name|t_mountp
expr_stmt|;
comment|/* 	 * If prod is set then figure out what to do to minlen and maxlen. 	 */
if|if
condition|(
name|prod
operator|>
literal|1
condition|)
block|{
name|xfs_extlen_t
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|maxlen
operator|%
name|prod
operator|)
condition|)
name|maxlen
operator|-=
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|minlen
operator|%
name|prod
operator|)
condition|)
name|minlen
operator|+=
name|prod
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|maxlen
operator|<
name|minlen
condition|)
block|{
operator|*
name|rtblock
operator|=
name|NULLRTBLOCK
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* 	 * Lock out other callers by grabbing the bitmap inode lock. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_iget
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_rbmino
argument_list|,
literal|0
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|,
operator|&
name|ip
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|sumbp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Allocate by size, or near another block, or exactly at some block. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|XFS_ALLOCTYPE_ANY_AG
case|:
name|error
operator|=
name|xfs_rtallocate_extent_size
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|minlen
argument_list|,
name|maxlen
argument_list|,
name|len
argument_list|,
operator|&
name|sumbp
argument_list|,
operator|&
name|sb
argument_list|,
name|prod
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_ALLOCTYPE_NEAR_BNO
case|:
name|error
operator|=
name|xfs_rtallocate_extent_near
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|bno
argument_list|,
name|minlen
argument_list|,
name|maxlen
argument_list|,
name|len
argument_list|,
operator|&
name|sumbp
argument_list|,
operator|&
name|sb
argument_list|,
name|prod
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFS_ALLOCTYPE_THIS_BNO
case|:
name|error
operator|=
name|xfs_rtallocate_extent_exact
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|bno
argument_list|,
name|minlen
argument_list|,
name|maxlen
argument_list|,
name|len
argument_list|,
operator|&
name|sumbp
argument_list|,
operator|&
name|sb
argument_list|,
name|prod
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 	 * If it worked, update the superblock. 	 */
if|if
condition|(
name|r
operator|!=
name|NULLRTBLOCK
condition|)
block|{
name|long
name|slen
init|=
operator|(
name|long
operator|)
operator|*
name|len
decl_stmt|;
name|ASSERT
argument_list|(
operator|*
name|len
operator|>=
name|minlen
operator|&&
operator|*
name|len
operator|<=
name|maxlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|wasdel
condition|)
name|xfs_trans_mod_sb
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_SB_RES_FREXTENTS
argument_list|,
operator|-
name|slen
argument_list|)
expr_stmt|;
else|else
name|xfs_trans_mod_sb
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_SB_FREXTENTS
argument_list|,
operator|-
name|slen
argument_list|)
expr_stmt|;
block|}
operator|*
name|rtblock
operator|=
name|r
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Free an extent in the realtime subvolume.  Length is expressed in  * realtime extents, as is the block number.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_rtfree_extent
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_rtblock_t
name|bno
parameter_list|,
comment|/* starting block number to free */
name|xfs_extlen_t
name|len
parameter_list|)
comment|/* length of extent freed */
block|{
name|int
name|error
decl_stmt|;
comment|/* error value */
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
comment|/* bitmap file inode */
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
comment|/* file system mount structure */
name|xfs_fsblock_t
name|sb
decl_stmt|;
comment|/* summary file block number */
name|xfs_buf_t
modifier|*
name|sumbp
decl_stmt|;
comment|/* summary file block buffer */
name|mp
operator|=
name|tp
operator|->
name|t_mountp
expr_stmt|;
comment|/* 	 * Synchronize by locking the bitmap inode. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_iget
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_rbmino
argument_list|,
literal|0
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|,
operator|&
name|ip
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
if|#
directive|if
name|defined
argument_list|(
name|__KERNEL__
argument_list|)
operator|&&
name|defined
argument_list|(
name|DEBUG
argument_list|)
comment|/* 	 * Check to see that this whole range is currently allocated. 	 */
block|{
name|int
name|stat
decl_stmt|;
comment|/* result from checking range */
name|error
operator|=
name|xfs_rtcheck_alloc_range
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|bno
argument_list|,
name|len
argument_list|,
operator|&
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|stat
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sumbp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Free the range of realtime blocks. 	 */
name|error
operator|=
name|xfs_rtfree_range
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|bno
argument_list|,
name|len
argument_list|,
operator|&
name|sumbp
argument_list|,
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 	 * Mark more blocks free in the superblock. 	 */
name|xfs_trans_mod_sb
argument_list|(
name|tp
argument_list|,
name|XFS_TRANS_SB_FREXTENTS
argument_list|,
operator|(
name|long
operator|)
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * If we've now freed all the blocks, reset the file sequence 	 * number to 0. 	 */
if|if
condition|(
name|tp
operator|->
name|t_frextents_delta
operator|+
name|mp
operator|->
name|m_sb
operator|.
name|sb_frextents
operator|==
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextents
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_NEWRTBM
operator|)
condition|)
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator||=
name|XFS_DIFLAG_NEWRTBM
expr_stmt|;
operator|*
operator|(
name|__uint64_t
operator|*
operator|)
operator|&
name|ip
operator|->
name|i_d
operator|.
name|di_atime
operator|=
literal|0
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize realtime fields in the mount structure.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_rtmount_init
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
comment|/* file system mount structure */
block|{
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* buffer for last block of subvolume */
name|xfs_daddr_t
name|d
decl_stmt|;
comment|/* address of last block of subvolume */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_sb_t
modifier|*
name|sbp
decl_stmt|;
comment|/* filesystem superblock copy in mount */
name|sbp
operator|=
operator|&
name|mp
operator|->
name|m_sb
expr_stmt|;
if|if
condition|(
name|sbp
operator|->
name|sb_rblocks
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mp
operator|->
name|m_rtdev_targp
operator|==
name|NULL
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: This filesystem has a realtime volume, use rtdev=device option"
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|ENODEV
argument_list|)
return|;
block|}
name|mp
operator|->
name|m_rsumlevels
operator|=
name|sbp
operator|->
name|sb_rextslog
operator|+
literal|1
expr_stmt|;
name|mp
operator|->
name|m_rsumsize
operator|=
operator|(
name|uint
operator|)
sizeof|sizeof
argument_list|(
name|xfs_suminfo_t
argument_list|)
operator|*
name|mp
operator|->
name|m_rsumlevels
operator|*
name|sbp
operator|->
name|sb_rbmblocks
expr_stmt|;
name|mp
operator|->
name|m_rsumsize
operator|=
name|roundup
argument_list|(
name|mp
operator|->
name|m_rsumsize
argument_list|,
name|sbp
operator|->
name|sb_blocksize
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_rbmip
operator|=
name|mp
operator|->
name|m_rsumip
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Check that the realtime section is an ok size. 	 */
name|d
operator|=
operator|(
name|xfs_daddr_t
operator|)
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_rblocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_BB_TO_FSB
argument_list|(
name|mp
argument_list|,
name|d
argument_list|)
operator|!=
name|mp
operator|->
name|m_sb
operator|.
name|sb_rblocks
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: realtime mount -- %llu != %llu"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|XFS_BB_TO_FSB
argument_list|(
name|mp
argument_list|,
name|d
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|mp
operator|->
name|m_sb
operator|.
name|sb_rblocks
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|E2BIG
argument_list|)
return|;
block|}
name|error
operator|=
name|xfs_read_buf
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_rtdev_targp
argument_list|,
name|d
operator|-
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: realtime mount -- xfs_read_buf failed, returned %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|E2BIG
argument_list|)
return|;
return|return
name|error
return|;
block|}
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Get the bitmap and summary inodes into the mount structure  * at mount time.  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_rtmount_inodes
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
comment|/* file system mount structure */
block|{
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_sb_t
modifier|*
name|sbp
decl_stmt|;
name|sbp
operator|=
operator|&
name|mp
operator|->
name|m_sb
expr_stmt|;
if|if
condition|(
name|sbp
operator|->
name|sb_rbmino
operator|==
name|NULLFSINO
condition|)
return|return
literal|0
return|;
name|error
operator|=
name|xfs_iget
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|sbp
operator|->
name|sb_rbmino
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|mp
operator|->
name|m_rbmip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|ASSERT
argument_list|(
name|mp
operator|->
name|m_rbmip
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|sbp
operator|->
name|sb_rsumino
operator|!=
name|NULLFSINO
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_iget
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|sbp
operator|->
name|sb_rsumino
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|mp
operator|->
name|m_rsumip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|VN_RELE
argument_list|(
name|XFS_ITOV
argument_list|(
name|mp
operator|->
name|m_rbmip
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|mp
operator|->
name|m_rsumip
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Pick an extent for allocation at the start of a new realtime file.  * Use the sequence number stored in the atime field of the bitmap inode.  * Translate this to a fraction of the rtextents, and return the product  * of rtextents and the fraction.  * The fraction sequence is 0, 1/2, 1/4, 3/4, 1/8, ..., 7/8, 1/16, ...  */
end_comment

begin_function
name|int
comment|/* error */
name|xfs_rtpick_extent
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount point */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_extlen_t
name|len
parameter_list|,
comment|/* allocation length (rtextents) */
name|xfs_rtblock_t
modifier|*
name|pick
parameter_list|)
comment|/* result rt extent */
block|{
name|xfs_rtblock_t
name|b
decl_stmt|;
comment|/* result block */
name|int
name|error
decl_stmt|;
comment|/* error return value */
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
comment|/* bitmap incore inode */
name|int
name|log2
decl_stmt|;
comment|/* log of sequence number */
name|__uint64_t
name|resid
decl_stmt|;
comment|/* residual after log removed */
name|__uint64_t
name|seq
decl_stmt|;
comment|/* sequence number of file creation */
name|__uint64_t
modifier|*
name|seqp
decl_stmt|;
comment|/* pointer to seqno in inode */
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_iget
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_rbmino
argument_list|,
literal|0
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|,
operator|&
name|ip
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|ASSERT
argument_list|(
name|ip
operator|==
name|mp
operator|->
name|m_rbmip
argument_list|)
expr_stmt|;
name|seqp
operator|=
operator|(
name|__uint64_t
operator|*
operator|)
operator|&
name|ip
operator|->
name|i_d
operator|.
name|di_atime
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator|&
name|XFS_DIFLAG_NEWRTBM
operator|)
condition|)
block|{
name|ip
operator|->
name|i_d
operator|.
name|di_flags
operator||=
name|XFS_DIFLAG_NEWRTBM
expr_stmt|;
operator|*
name|seqp
operator|=
literal|0
expr_stmt|;
block|}
name|seq
operator|=
operator|*
name|seqp
expr_stmt|;
if|if
condition|(
operator|(
name|log2
operator|=
name|xfs_highbit64
argument_list|(
name|seq
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|b
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|resid
operator|=
name|seq
operator|-
operator|(
literal|1ULL
operator|<<
name|log2
operator|)
expr_stmt|;
name|b
operator|=
operator|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextents
operator|*
operator|(
operator|(
name|resid
operator|<<
literal|1
operator|)
operator|+
literal|1ULL
operator|)
operator|)
operator|>>
operator|(
name|log2
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|b
operator|>=
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextents
condition|)
name|b
operator|=
name|do_mod
argument_list|(
name|b
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextents
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|+
name|len
operator|>
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextents
condition|)
name|b
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextents
operator|-
name|len
expr_stmt|;
block|}
operator|*
name|seqp
operator|=
name|seq
operator|+
literal|1
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
operator|*
name|pick
operator|=
name|b
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*  * Debug code: print out the value of a range in the bitmap.  */
end_comment

begin_function
name|void
name|xfs_rtprint_range
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount structure */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
comment|/* transaction pointer */
name|xfs_rtblock_t
name|start
parameter_list|,
comment|/* starting block to print */
name|xfs_extlen_t
name|len
parameter_list|)
comment|/* length to print */
block|{
name|xfs_extlen_t
name|i
decl_stmt|;
comment|/* block number in the extent */
name|printk
argument_list|(
literal|"%Ld: "
argument_list|,
operator|(
name|long
name|long
operator|)
name|start
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|printk
argument_list|(
literal|"%d"
argument_list|,
name|xfs_rtcheck_bit
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|start
operator|+
name|i
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Debug code: print the summary file.  */
end_comment

begin_function
name|void
name|xfs_rtprint_summary
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* file system mount structure */
name|xfs_trans_t
modifier|*
name|tp
parameter_list|)
comment|/* transaction pointer */
block|{
name|xfs_suminfo_t
name|c
decl_stmt|;
comment|/* summary data */
name|xfs_rtblock_t
name|i
decl_stmt|;
comment|/* bitmap block number */
name|int
name|l
decl_stmt|;
comment|/* summary information level */
name|int
name|p
decl_stmt|;
comment|/* flag for printed anything */
name|xfs_fsblock_t
name|sb
decl_stmt|;
comment|/* summary block number */
name|xfs_buf_t
modifier|*
name|sumbp
decl_stmt|;
comment|/* summary block buffer */
name|sumbp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|l
operator|=
literal|0
init|;
name|l
operator|<
name|mp
operator|->
name|m_rsumlevels
condition|;
name|l
operator|++
control|)
block|{
for|for
control|(
name|p
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_rbmblocks
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|xfs_rtget_summary
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|,
name|l
argument_list|,
name|i
argument_list|,
operator|&
name|sumbp
argument_list|,
operator|&
name|sb
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|printk
argument_list|(
literal|"%Ld-%Ld:"
argument_list|,
literal|1LL
operator|<<
name|l
argument_list|,
name|XFS_RTMIN
argument_list|(
operator|(
literal|1LL
operator|<<
name|l
operator|)
operator|+
operator|(
operator|(
literal|1LL
operator|<<
name|l
operator|)
operator|-
literal|1LL
operator|)
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_rextents
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
literal|1
expr_stmt|;
block|}
name|printk
argument_list|(
literal|" %Ld:%d"
argument_list|,
operator|(
name|long
name|long
operator|)
name|i
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
condition|)
name|printk
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sumbp
condition|)
name|xfs_trans_brelse
argument_list|(
name|tp
argument_list|,
name|sumbp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

end_unit

