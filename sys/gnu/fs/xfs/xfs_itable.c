begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2002,2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_itable.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_USERACC
end_ifndef

begin_define
define|#
directive|define
name|useracc
parameter_list|(
name|ubuffer
parameter_list|,
name|size
parameter_list|,
name|flags
parameter_list|,
name|foo
parameter_list|)
value|(0)
end_define

begin_define
define|#
directive|define
name|unuseracc
parameter_list|(
name|ubuffer
parameter_list|,
name|size
parameter_list|,
name|flags
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|STATIC
name|int
name|xfs_bulkstat_one_iget
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* mount point for filesystem */
name|xfs_ino_t
name|ino
parameter_list|,
comment|/* inode number to get data for */
name|xfs_daddr_t
name|bno
parameter_list|,
comment|/* starting bno of inode cluster */
name|xfs_bstat_t
modifier|*
name|buf
parameter_list|,
comment|/* return buffer */
name|int
modifier|*
name|stat
parameter_list|)
comment|/* BULKSTAT_RV_... */
block|{
name|xfs_dinode_core_t
modifier|*
name|dic
decl_stmt|;
comment|/* dinode core info pointer */
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
comment|/* incore inode pointer */
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|xfs_iget
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|ino
argument_list|,
literal|0
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|,
operator|&
name|ip
argument_list|,
name|bno
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|stat
operator|=
name|BULKSTAT_RV_NOTHING
expr_stmt|;
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|ip
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_blkno
operator|!=
operator|(
name|xfs_daddr_t
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|==
literal|0
condition|)
block|{
operator|*
name|stat
operator|=
name|BULKSTAT_RV_NOTHING
expr_stmt|;
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
goto|goto
name|out_iput
goto|;
block|}
name|vp
operator|=
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|dic
operator|=
operator|&
name|ip
operator|->
name|i_d
expr_stmt|;
comment|/* xfs_iget returns the following without needing 	 * further change. 	 */
name|buf
operator|->
name|bs_nlink
operator|=
name|dic
operator|->
name|di_nlink
expr_stmt|;
name|buf
operator|->
name|bs_projid
operator|=
name|dic
operator|->
name|di_projid
expr_stmt|;
name|buf
operator|->
name|bs_ino
operator|=
name|ino
expr_stmt|;
name|buf
operator|->
name|bs_mode
operator|=
name|dic
operator|->
name|di_mode
expr_stmt|;
name|buf
operator|->
name|bs_uid
operator|=
name|dic
operator|->
name|di_uid
expr_stmt|;
name|buf
operator|->
name|bs_gid
operator|=
name|dic
operator|->
name|di_gid
expr_stmt|;
name|buf
operator|->
name|bs_size
operator|=
name|dic
operator|->
name|di_size
expr_stmt|;
name|vn_atime_to_bstime
argument_list|(
name|vp
argument_list|,
operator|&
name|buf
operator|->
name|bs_atime
argument_list|)
expr_stmt|;
name|buf
operator|->
name|bs_mtime
operator|.
name|tv_sec
operator|=
name|dic
operator|->
name|di_mtime
operator|.
name|t_sec
expr_stmt|;
name|buf
operator|->
name|bs_mtime
operator|.
name|tv_nsec
operator|=
name|dic
operator|->
name|di_mtime
operator|.
name|t_nsec
expr_stmt|;
name|buf
operator|->
name|bs_ctime
operator|.
name|tv_sec
operator|=
name|dic
operator|->
name|di_ctime
operator|.
name|t_sec
expr_stmt|;
name|buf
operator|->
name|bs_ctime
operator|.
name|tv_nsec
operator|=
name|dic
operator|->
name|di_ctime
operator|.
name|t_nsec
expr_stmt|;
name|buf
operator|->
name|bs_xflags
operator|=
name|xfs_ip2xflags
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|buf
operator|->
name|bs_extsize
operator|=
name|dic
operator|->
name|di_extsize
operator|<<
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocklog
expr_stmt|;
name|buf
operator|->
name|bs_extents
operator|=
name|dic
operator|->
name|di_nextents
expr_stmt|;
name|buf
operator|->
name|bs_gen
operator|=
name|dic
operator|->
name|di_gen
expr_stmt|;
name|memset
argument_list|(
name|buf
operator|->
name|bs_pad
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
operator|->
name|bs_pad
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|->
name|bs_dmevmask
operator|=
name|dic
operator|->
name|di_dmevmask
expr_stmt|;
name|buf
operator|->
name|bs_dmstate
operator|=
name|dic
operator|->
name|di_dmstate
expr_stmt|;
name|buf
operator|->
name|bs_aextents
operator|=
name|dic
operator|->
name|di_anextents
expr_stmt|;
switch|switch
condition|(
name|dic
operator|->
name|di_format
condition|)
block|{
case|case
name|XFS_DINODE_FMT_DEV
case|:
name|buf
operator|->
name|bs_rdev
operator|=
name|ip
operator|->
name|i_df
operator|.
name|if_u2
operator|.
name|if_rdev
expr_stmt|;
name|buf
operator|->
name|bs_blksize
operator|=
name|BLKDEV_IOSIZE
expr_stmt|;
name|buf
operator|->
name|bs_blocks
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|XFS_DINODE_FMT_LOCAL
case|:
case|case
name|XFS_DINODE_FMT_UUID
case|:
name|buf
operator|->
name|bs_rdev
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|bs_blksize
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
expr_stmt|;
name|buf
operator|->
name|bs_blocks
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|XFS_DINODE_FMT_EXTENTS
case|:
case|case
name|XFS_DINODE_FMT_BTREE
case|:
name|buf
operator|->
name|bs_rdev
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|bs_blksize
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
expr_stmt|;
name|buf
operator|->
name|bs_blocks
operator|=
name|dic
operator|->
name|di_nblocks
operator|+
name|ip
operator|->
name|i_delayed_blks
expr_stmt|;
break|break;
block|}
name|out_iput
label|:
name|xfs_iput
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_bulkstat_one_dinode
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* mount point for filesystem */
name|xfs_ino_t
name|ino
parameter_list|,
comment|/* inode number to get data for */
name|xfs_dinode_t
modifier|*
name|dip
parameter_list|,
comment|/* dinode inode pointer */
name|xfs_bstat_t
modifier|*
name|buf
parameter_list|)
comment|/* return buffer */
block|{
name|xfs_dinode_core_t
modifier|*
name|dic
decl_stmt|;
comment|/* dinode core info pointer */
name|dic
operator|=
operator|&
name|dip
operator|->
name|di_core
expr_stmt|;
comment|/* 	 * The inode format changed when we moved the link count and 	 * made it 32 bits long.  If this is an old format inode, 	 * convert it in memory to look like a new one.  If it gets 	 * flushed to disk we will convert back before flushing or 	 * logging it.  We zero out the new projid field and the old link 	 * count field.  We'll handle clearing the pad field (the remains 	 * of the old uuid field) when we actually convert the inode to 	 * the new format. We don't change the version number so that we 	 * can distinguish this from a real new format inode. 	 */
if|if
condition|(
name|INT_GET
argument_list|(
name|dic
operator|->
name|di_version
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|==
name|XFS_DINODE_VERSION_1
condition|)
block|{
name|buf
operator|->
name|bs_nlink
operator|=
name|INT_GET
argument_list|(
name|dic
operator|->
name|di_onlink
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|buf
operator|->
name|bs_projid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|->
name|bs_nlink
operator|=
name|INT_GET
argument_list|(
name|dic
operator|->
name|di_nlink
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|buf
operator|->
name|bs_projid
operator|=
name|INT_GET
argument_list|(
name|dic
operator|->
name|di_projid
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
block|}
name|buf
operator|->
name|bs_ino
operator|=
name|ino
expr_stmt|;
name|buf
operator|->
name|bs_mode
operator|=
name|INT_GET
argument_list|(
name|dic
operator|->
name|di_mode
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|buf
operator|->
name|bs_uid
operator|=
name|INT_GET
argument_list|(
name|dic
operator|->
name|di_uid
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|buf
operator|->
name|bs_gid
operator|=
name|INT_GET
argument_list|(
name|dic
operator|->
name|di_gid
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|buf
operator|->
name|bs_size
operator|=
name|INT_GET
argument_list|(
name|dic
operator|->
name|di_size
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|buf
operator|->
name|bs_atime
operator|.
name|tv_sec
operator|=
name|INT_GET
argument_list|(
name|dic
operator|->
name|di_atime
operator|.
name|t_sec
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|buf
operator|->
name|bs_atime
operator|.
name|tv_nsec
operator|=
name|INT_GET
argument_list|(
name|dic
operator|->
name|di_atime
operator|.
name|t_nsec
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|buf
operator|->
name|bs_mtime
operator|.
name|tv_sec
operator|=
name|INT_GET
argument_list|(
name|dic
operator|->
name|di_mtime
operator|.
name|t_sec
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|buf
operator|->
name|bs_mtime
operator|.
name|tv_nsec
operator|=
name|INT_GET
argument_list|(
name|dic
operator|->
name|di_mtime
operator|.
name|t_nsec
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|buf
operator|->
name|bs_ctime
operator|.
name|tv_sec
operator|=
name|INT_GET
argument_list|(
name|dic
operator|->
name|di_ctime
operator|.
name|t_sec
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|buf
operator|->
name|bs_ctime
operator|.
name|tv_nsec
operator|=
name|INT_GET
argument_list|(
name|dic
operator|->
name|di_ctime
operator|.
name|t_nsec
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|buf
operator|->
name|bs_xflags
operator|=
name|xfs_dic2xflags
argument_list|(
name|dic
argument_list|)
expr_stmt|;
name|buf
operator|->
name|bs_extsize
operator|=
name|INT_GET
argument_list|(
name|dic
operator|->
name|di_extsize
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<<
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocklog
expr_stmt|;
name|buf
operator|->
name|bs_extents
operator|=
name|INT_GET
argument_list|(
name|dic
operator|->
name|di_nextents
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|buf
operator|->
name|bs_gen
operator|=
name|INT_GET
argument_list|(
name|dic
operator|->
name|di_gen
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
operator|->
name|bs_pad
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
operator|->
name|bs_pad
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|->
name|bs_dmevmask
operator|=
name|INT_GET
argument_list|(
name|dic
operator|->
name|di_dmevmask
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|buf
operator|->
name|bs_dmstate
operator|=
name|INT_GET
argument_list|(
name|dic
operator|->
name|di_dmstate
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|buf
operator|->
name|bs_aextents
operator|=
name|INT_GET
argument_list|(
name|dic
operator|->
name|di_anextents
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|INT_GET
argument_list|(
name|dic
operator|->
name|di_format
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
block|{
case|case
name|XFS_DINODE_FMT_DEV
case|:
name|buf
operator|->
name|bs_rdev
operator|=
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_u
operator|.
name|di_dev
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
name|buf
operator|->
name|bs_blksize
operator|=
name|BLKDEV_IOSIZE
expr_stmt|;
name|buf
operator|->
name|bs_blocks
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|XFS_DINODE_FMT_LOCAL
case|:
case|case
name|XFS_DINODE_FMT_UUID
case|:
name|buf
operator|->
name|bs_rdev
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|bs_blksize
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
expr_stmt|;
name|buf
operator|->
name|bs_blocks
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|XFS_DINODE_FMT_EXTENTS
case|:
case|case
name|XFS_DINODE_FMT_BTREE
case|:
name|buf
operator|->
name|bs_rdev
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|bs_blksize
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
expr_stmt|;
name|buf
operator|->
name|bs_blocks
operator|=
name|INT_GET
argument_list|(
name|dic
operator|->
name|di_nblocks
argument_list|,
name|ARCH_CONVERT
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return stat information for one inode.  * Return 0 if ok, else errno.  */
end_comment

begin_function
name|int
comment|/* error status */
name|xfs_bulkstat_one
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* mount point for filesystem */
name|xfs_ino_t
name|ino
parameter_list|,
comment|/* inode number to get data for */
name|void
name|__user
modifier|*
name|buffer
parameter_list|,
comment|/* buffer to place output in */
name|int
name|ubsize
parameter_list|,
comment|/* size of buffer */
name|void
modifier|*
name|private_data
parameter_list|,
comment|/* my private data */
name|xfs_daddr_t
name|bno
parameter_list|,
comment|/* starting bno of inode cluster */
name|int
modifier|*
name|ubused
parameter_list|,
comment|/* bytes used by me */
name|void
modifier|*
name|dibuff
parameter_list|,
comment|/* on-disk inode buffer */
name|int
modifier|*
name|stat
parameter_list|)
comment|/* BULKSTAT_RV_... */
block|{
name|xfs_bstat_t
modifier|*
name|buf
decl_stmt|;
comment|/* return buffer */
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* error value */
name|xfs_dinode_t
modifier|*
name|dip
decl_stmt|;
comment|/* dinode inode pointer */
name|dip
operator|=
operator|(
name|xfs_dinode_t
operator|*
operator|)
name|dibuff
expr_stmt|;
if|if
condition|(
operator|!
name|buffer
operator|||
name|ino
operator|==
name|mp
operator|->
name|m_sb
operator|.
name|sb_rbmino
operator|||
name|ino
operator|==
name|mp
operator|->
name|m_sb
operator|.
name|sb_rsumino
operator|||
operator|(
name|XFS_SB_VERSION_HASQUOTA
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
operator|&&
operator|(
name|ino
operator|==
name|mp
operator|->
name|m_sb
operator|.
name|sb_uquotino
operator|||
name|ino
operator|==
name|mp
operator|->
name|m_sb
operator|.
name|sb_gquotino
operator|)
operator|)
condition|)
block|{
operator|*
name|stat
operator|=
name|BULKSTAT_RV_NOTHING
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|ubsize
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
condition|)
block|{
operator|*
name|stat
operator|=
name|BULKSTAT_RV_NOTHING
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|ENOMEM
argument_list|)
return|;
block|}
name|buf
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|dip
operator|==
name|NULL
condition|)
block|{
comment|/* We're not being passed a pointer to a dinode.  This happens 		 * if BULKSTAT_FG_IGET is selected.  Do the iget. 		 */
name|error
operator|=
name|xfs_bulkstat_one_iget
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|,
name|bno
argument_list|,
name|buf
argument_list|,
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out_free
goto|;
block|}
else|else
block|{
name|xfs_bulkstat_one_dinode
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|,
name|dip
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|copy_to_user
argument_list|(
name|buffer
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|stat
operator|=
name|BULKSTAT_RV_NOTHING
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out_free
goto|;
block|}
operator|*
name|stat
operator|=
name|BULKSTAT_RV_DIDONE
expr_stmt|;
if|if
condition|(
name|ubused
condition|)
operator|*
name|ubused
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
expr_stmt|;
name|out_free
label|:
name|kmem_free
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Return stat information in bulk (by-inode) for the filesystem.  */
end_comment

begin_function
name|int
comment|/* error status */
name|xfs_bulkstat
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* mount point for filesystem */
name|xfs_ino_t
modifier|*
name|lastinop
parameter_list|,
comment|/* last inode returned */
name|int
modifier|*
name|ubcountp
parameter_list|,
comment|/* size of buffer/count returned */
name|bulkstat_one_pf
name|formatter
parameter_list|,
comment|/* func that'd fill a single buf */
name|void
modifier|*
name|private_data
parameter_list|,
comment|/* private data for formatter */
name|size_t
name|statstruct_size
parameter_list|,
comment|/* sizeof struct filling */
name|char
name|__user
modifier|*
name|ubuffer
parameter_list|,
comment|/* buffer with inode stats */
name|int
name|flags
parameter_list|,
comment|/* defined in xfs_itable.h */
name|int
modifier|*
name|done
parameter_list|)
comment|/* 1 if there are more stats to get */
block|{
name|xfs_agblock_t
name|agbno
init|=
literal|0
decl_stmt|;
comment|/* allocation group block number */
name|xfs_buf_t
modifier|*
name|agbp
decl_stmt|;
comment|/* agi header buffer */
name|xfs_agi_t
modifier|*
name|agi
decl_stmt|;
comment|/* agi header data */
name|xfs_agino_t
name|agino
decl_stmt|;
comment|/* inode # in allocation group */
name|xfs_agnumber_t
name|agno
decl_stmt|;
comment|/* allocation group number */
name|xfs_daddr_t
name|bno
decl_stmt|;
comment|/* inode cluster start daddr */
name|int
name|chunkidx
decl_stmt|;
comment|/* current index into inode chunk */
name|int
name|clustidx
decl_stmt|;
comment|/* current index into inode cluster */
name|xfs_btree_cur_t
modifier|*
name|cur
decl_stmt|;
comment|/* btree cursor for ialloc btree */
name|int
name|end_of_ag
decl_stmt|;
comment|/* set if we've seen the ag end */
name|int
name|error
decl_stmt|;
comment|/* error code */
name|int
name|fmterror
decl_stmt|;
comment|/* bulkstat formatter result */
name|__int32_t
name|gcnt
decl_stmt|;
comment|/* current btree rec's count */
name|xfs_inofree_t
name|gfree
decl_stmt|;
comment|/* current btree rec's free mask */
name|xfs_agino_t
name|gino
decl_stmt|;
comment|/* current btree rec's start inode */
name|int
name|i
decl_stmt|;
comment|/* loop index */
name|int
name|icount
decl_stmt|;
comment|/* count of inodes good in irbuf */
name|xfs_ino_t
name|ino
decl_stmt|;
comment|/* inode number (filesystem) */
name|xfs_inobt_rec_t
modifier|*
name|irbp
decl_stmt|;
comment|/* current irec buffer pointer */
name|xfs_inobt_rec_t
modifier|*
name|irbuf
decl_stmt|;
comment|/* start of irec buffer */
name|xfs_inobt_rec_t
modifier|*
name|irbufend
decl_stmt|;
comment|/* end of good irec buffer entries */
name|xfs_ino_t
name|lastino
init|=
literal|0
decl_stmt|;
comment|/* last inode number returned */
name|int
name|nbcluster
decl_stmt|;
comment|/* # of blocks in a cluster */
name|int
name|nicluster
decl_stmt|;
comment|/* # of inodes in a cluster */
name|int
name|nimask
decl_stmt|;
comment|/* mask for inode clusters */
name|int
name|nirbuf
decl_stmt|;
comment|/* size of irbuf */
name|int
name|rval
decl_stmt|;
comment|/* return value error code */
name|int
name|tmp
decl_stmt|;
comment|/* result value from btree calls */
name|int
name|ubcount
decl_stmt|;
comment|/* size of user's buffer */
name|int
name|ubleft
decl_stmt|;
comment|/* bytes left in user's buffer */
name|char
name|__user
modifier|*
name|ubufp
decl_stmt|;
comment|/* pointer into user's buffer */
name|int
name|ubelem
decl_stmt|;
comment|/* spaces used in user's buffer */
name|int
name|ubused
decl_stmt|;
comment|/* bytes used by formatter */
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
comment|/* ptr to on-disk inode cluster buf */
name|xfs_dinode_t
modifier|*
name|dip
decl_stmt|;
comment|/* ptr into bp for specific inode */
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
comment|/* ptr to in-core inode struct */
comment|/* 	 * Get the last inode value, see if there's nothing to do. 	 */
name|ino
operator|=
operator|(
name|xfs_ino_t
operator|)
operator|*
name|lastinop
expr_stmt|;
name|dip
operator|=
name|NULL
expr_stmt|;
name|agno
operator|=
name|XFS_INO_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|agino
operator|=
name|XFS_INO_TO_AGINO
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|agno
operator|>=
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
operator|||
name|ino
operator|!=
name|XFS_AGINO_TO_INO
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|agino
argument_list|)
condition|)
block|{
operator|*
name|done
operator|=
literal|1
expr_stmt|;
operator|*
name|ubcountp
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ubcount
operator|=
operator|*
name|ubcountp
expr_stmt|;
comment|/* statstruct's */
name|ubleft
operator|=
name|ubcount
operator|*
name|statstruct_size
expr_stmt|;
comment|/* bytes */
operator|*
name|ubcountp
operator|=
name|ubelem
operator|=
literal|0
expr_stmt|;
operator|*
name|done
operator|=
literal|0
expr_stmt|;
name|fmterror
operator|=
literal|0
expr_stmt|;
name|ubufp
operator|=
name|ubuffer
expr_stmt|;
name|nicluster
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
operator|>=
name|XFS_INODE_CLUSTER_SIZE
argument_list|(
name|mp
argument_list|)
condition|?
name|mp
operator|->
name|m_sb
operator|.
name|sb_inopblock
else|:
operator|(
name|XFS_INODE_CLUSTER_SIZE
argument_list|(
name|mp
argument_list|)
operator|>>
name|mp
operator|->
name|m_sb
operator|.
name|sb_inodelog
operator|)
expr_stmt|;
name|nimask
operator|=
operator|~
operator|(
name|nicluster
operator|-
literal|1
operator|)
expr_stmt|;
name|nbcluster
operator|=
name|nicluster
operator|>>
name|mp
operator|->
name|m_sb
operator|.
name|sb_inopblog
expr_stmt|;
comment|/* 	 * Lock down the user's buffer. If a buffer was not sent, as in the case 	 * disk quota code calls here, we skip this. 	 */
if|if
condition|(
name|ubuffer
operator|&&
operator|(
name|error
operator|=
name|useracc
argument_list|(
name|ubuffer
argument_list|,
name|ubcount
operator|*
name|statstruct_size
argument_list|,
operator|(
name|B_READ
operator||
name|B_PHYS
operator|)
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
return|return
name|error
return|;
block|}
comment|/* 	 * Allocate a page-sized buffer for inode btree records. 	 * We could try allocating something smaller, but for normal 	 * calls we'll always (potentially) need the whole page. 	 */
name|irbuf
operator|=
name|kmem_alloc
argument_list|(
name|NBPC
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|nirbuf
operator|=
name|NBPC
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|irbuf
argument_list|)
expr_stmt|;
comment|/* 	 * Loop over the allocation groups, starting from the last 	 * inode returned; 0 means start of the allocation group. 	 */
name|rval
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ubleft
operator|>=
name|statstruct_size
operator|&&
name|agno
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
condition|)
block|{
name|bp
operator|=
name|NULL
expr_stmt|;
name|down_read
argument_list|(
operator|&
name|mp
operator|->
name|m_peraglock
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_ialloc_read_agi
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|agno
argument_list|,
operator|&
name|agbp
argument_list|)
expr_stmt|;
name|up_read
argument_list|(
operator|&
name|mp
operator|->
name|m_peraglock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 			 * Skip this allocation group and go to the next one. 			 */
name|agno
operator|++
expr_stmt|;
name|agino
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|agi
operator|=
name|XFS_BUF_TO_AGI
argument_list|(
name|agbp
argument_list|)
expr_stmt|;
comment|/* 		 * Allocate and initialize a btree cursor for ialloc btree. 		 */
name|cur
operator|=
name|xfs_btree_init_cursor
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|agbp
argument_list|,
name|agno
argument_list|,
name|XFS_BTNUM_INO
argument_list|,
operator|(
name|xfs_inode_t
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|irbp
operator|=
name|irbuf
expr_stmt|;
name|irbufend
operator|=
name|irbuf
operator|+
name|nirbuf
expr_stmt|;
name|end_of_ag
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If we're returning in the middle of an allocation group, 		 * we need to get the remainder of the chunk we're in. 		 */
if|if
condition|(
name|agino
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Lookup the inode chunk that this inode lives in. 			 */
name|error
operator|=
name|xfs_inobt_lookup_le
argument_list|(
name|cur
argument_list|,
name|agino
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
comment|/* no I/O error */
name|tmp
operator|&&
comment|/* lookup succeeded */
comment|/* got the record, should always work */
operator|!
operator|(
name|error
operator|=
name|xfs_inobt_get_rec
argument_list|(
name|cur
argument_list|,
operator|&
name|gino
argument_list|,
operator|&
name|gcnt
argument_list|,
operator|&
name|gfree
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|&&
name|i
operator|==
literal|1
operator|&&
comment|/* this is the right chunk */
name|agino
operator|<
name|gino
operator|+
name|XFS_INODES_PER_CHUNK
operator|&&
comment|/* lastino was not last in chunk */
operator|(
name|chunkidx
operator|=
name|agino
operator|-
name|gino
operator|+
literal|1
operator|)
operator|<
name|XFS_INODES_PER_CHUNK
operator|&&
comment|/* there are some left allocated */
name|XFS_INOBT_MASKN
argument_list|(
name|chunkidx
argument_list|,
name|XFS_INODES_PER_CHUNK
operator|-
name|chunkidx
argument_list|)
operator|&
operator|~
name|gfree
condition|)
block|{
comment|/* 				 * Grab the chunk record.  Mark all the 				 * uninteresting inodes (because they're 				 * before our start point) free. 				 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chunkidx
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|XFS_INOBT_MASK
argument_list|(
name|i
argument_list|)
operator|&
operator|~
name|gfree
condition|)
name|gcnt
operator|++
expr_stmt|;
block|}
name|gfree
operator||=
name|XFS_INOBT_MASKN
argument_list|(
literal|0
argument_list|,
name|chunkidx
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|irbp
operator|->
name|ir_startino
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|gino
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|irbp
operator|->
name|ir_freecount
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|gcnt
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|irbp
operator|->
name|ir_free
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|gfree
argument_list|)
expr_stmt|;
name|irbp
operator|++
expr_stmt|;
name|agino
operator|=
name|gino
operator|+
name|XFS_INODES_PER_CHUNK
expr_stmt|;
name|icount
operator|=
name|XFS_INODES_PER_CHUNK
operator|-
name|gcnt
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * If any of those tests failed, bump the 				 * inode number (just in case). 				 */
name|agino
operator|++
expr_stmt|;
name|icount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 			 * In any case, increment to the next record. 			 */
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|xfs_inobt_increment
argument_list|(
name|cur
argument_list|,
literal|0
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Start of ag.  Lookup the first inode chunk. 			 */
name|error
operator|=
name|xfs_inobt_lookup_ge
argument_list|(
name|cur
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|icount
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Loop through inode btree records in this ag, 		 * until we run out of inodes or space in the buffer. 		 */
while|while
condition|(
name|irbp
operator|<
name|irbufend
operator|&&
name|icount
operator|<
name|ubcount
condition|)
block|{
comment|/* 			 * Loop as long as we're unable to read the 			 * inode btree. 			 */
while|while
condition|(
name|error
condition|)
block|{
name|agino
operator|+=
name|XFS_INODES_PER_CHUNK
expr_stmt|;
if|if
condition|(
name|XFS_AGINO_TO_AGBNO
argument_list|(
name|mp
argument_list|,
name|agino
argument_list|)
operator|>=
name|be32_to_cpu
argument_list|(
name|agi
operator|->
name|agi_length
argument_list|)
condition|)
break|break;
name|error
operator|=
name|xfs_inobt_lookup_ge
argument_list|(
name|cur
argument_list|,
name|agino
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * If ran off the end of the ag either with an error, 			 * or the normal way, set end and stop collecting. 			 */
if|if
condition|(
name|error
operator|||
operator|(
name|error
operator|=
name|xfs_inobt_get_rec
argument_list|(
name|cur
argument_list|,
operator|&
name|gino
argument_list|,
operator|&
name|gcnt
argument_list|,
operator|&
name|gfree
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|||
name|i
operator|==
literal|0
condition|)
block|{
name|end_of_ag
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 			 * If this chunk has any allocated inodes, save it. 			 */
if|if
condition|(
name|gcnt
operator|<
name|XFS_INODES_PER_CHUNK
condition|)
block|{
name|INT_SET
argument_list|(
name|irbp
operator|->
name|ir_startino
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|gino
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|irbp
operator|->
name|ir_freecount
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|gcnt
argument_list|)
expr_stmt|;
name|INT_SET
argument_list|(
name|irbp
operator|->
name|ir_free
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|gfree
argument_list|)
expr_stmt|;
name|irbp
operator|++
expr_stmt|;
name|icount
operator|+=
name|XFS_INODES_PER_CHUNK
operator|-
name|gcnt
expr_stmt|;
block|}
comment|/* 			 * Set agino to after this chunk and bump the cursor. 			 */
name|agino
operator|=
name|gino
operator|+
name|XFS_INODES_PER_CHUNK
expr_stmt|;
name|error
operator|=
name|xfs_inobt_increment
argument_list|(
name|cur
argument_list|,
literal|0
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Drop the btree buffers and the agi buffer. 		 * We can't hold any of the locks these represent 		 * when calling iget. 		 */
name|xfs_btree_del_cursor
argument_list|(
name|cur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|agbp
argument_list|)
expr_stmt|;
comment|/* 		 * Now format all the good inodes into the user's buffer. 		 */
name|irbufend
operator|=
name|irbp
expr_stmt|;
for|for
control|(
name|irbp
operator|=
name|irbuf
init|;
name|irbp
operator|<
name|irbufend
operator|&&
name|ubleft
operator|>=
name|statstruct_size
condition|;
name|irbp
operator|++
control|)
block|{
comment|/* 			 * Read-ahead the next chunk's worth of inodes. 			 */
if|if
condition|(
operator|&
name|irbp
index|[
literal|1
index|]
operator|<
name|irbufend
condition|)
block|{
comment|/* 				 * Loop over all clusters in the next chunk. 				 * Do a readahead if there are any allocated 				 * inodes in that cluster. 				 */
for|for
control|(
name|agbno
operator|=
name|XFS_AGINO_TO_AGBNO
argument_list|(
name|mp
argument_list|,
name|INT_GET
argument_list|(
name|irbp
index|[
literal|1
index|]
operator|.
name|ir_startino
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
operator|,
name|chunkidx
operator|=
literal|0
init|;
name|chunkidx
operator|<
name|XFS_INODES_PER_CHUNK
condition|;
name|chunkidx
operator|+=
name|nicluster
operator|,
name|agbno
operator|+=
name|nbcluster
control|)
block|{
if|if
condition|(
name|XFS_INOBT_MASKN
argument_list|(
name|chunkidx
argument_list|,
name|nicluster
argument_list|)
operator|&
operator|~
operator|(
name|INT_GET
argument_list|(
name|irbp
index|[
literal|1
index|]
operator|.
name|ir_free
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|)
condition|)
name|xfs_btree_reada_bufs
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|agbno
argument_list|,
name|nbcluster
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * Now process this chunk of inodes. 			 */
for|for
control|(
name|agino
operator|=
name|INT_GET
argument_list|(
name|irbp
operator|->
name|ir_startino
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|,
name|chunkidx
operator|=
literal|0
operator|,
name|clustidx
operator|=
literal|0
init|;
name|ubleft
operator|>
literal|0
operator|&&
name|INT_GET
argument_list|(
name|irbp
operator|->
name|ir_freecount
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|<
name|XFS_INODES_PER_CHUNK
condition|;
name|chunkidx
operator|++
operator|,
name|clustidx
operator|++
operator|,
name|agino
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|chunkidx
operator|<
name|XFS_INODES_PER_CHUNK
argument_list|)
expr_stmt|;
comment|/* 				 * Recompute agbno if this is the 				 * first inode of the cluster. 				 * 				 * Careful with clustidx.   There can be 				 * multple clusters per chunk, a single 				 * cluster per chunk or a cluster that has 				 * inodes represented from several different 				 * chunks (if blocksize is large). 				 * 				 * Because of this, the starting clustidx is 				 * initialized to zero in this loop but must 				 * later be reset after reading in the cluster 				 * buffer. 				 */
if|if
condition|(
operator|(
name|chunkidx
operator|&
operator|(
name|nicluster
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|agbno
operator|=
name|XFS_AGINO_TO_AGBNO
argument_list|(
name|mp
argument_list|,
name|INT_GET
argument_list|(
name|irbp
operator|->
name|ir_startino
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
operator|+
operator|(
operator|(
name|chunkidx
operator|&
name|nimask
operator|)
operator|>>
name|mp
operator|->
name|m_sb
operator|.
name|sb_inopblog
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BULKSTAT_FG_QUICK
condition|)
block|{
name|ino
operator|=
name|XFS_AGINO_TO_INO
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|agino
argument_list|)
expr_stmt|;
name|bno
operator|=
name|XFS_AGB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|agbno
argument_list|)
expr_stmt|;
comment|/* 						 * Get the inode cluster buffer 						 */
name|ASSERT
argument_list|(
name|xfs_inode_zone
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ip
operator|=
name|kmem_zone_zalloc
argument_list|(
name|xfs_inode_zone
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_ino
operator|=
name|ino
expr_stmt|;
name|ip
operator|->
name|i_mount
operator|=
name|mp
expr_stmt|;
if|if
condition|(
name|bp
condition|)
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_itobp
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|ip
argument_list|,
operator|&
name|dip
argument_list|,
operator|&
name|bp
argument_list|,
name|bno
argument_list|,
name|XFS_IMAP_BULKSTAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|clustidx
operator|=
name|ip
operator|->
name|i_boffset
operator|/
name|mp
operator|->
name|m_sb
operator|.
name|sb_inodesize
expr_stmt|;
name|kmem_zone_free
argument_list|(
name|xfs_inode_zone
argument_list|,
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_TEST_ERROR
argument_list|(
name|error
operator|!=
literal|0
argument_list|,
name|mp
argument_list|,
name|XFS_ERRTAG_BULKSTAT_READ_CHUNK
argument_list|,
name|XFS_RANDOM_BULKSTAT_READ_CHUNK
argument_list|)
condition|)
block|{
name|bp
operator|=
name|NULL
expr_stmt|;
name|ubleft
operator|=
literal|0
expr_stmt|;
name|rval
operator|=
name|error
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 				 * Skip if this inode is free. 				 */
if|if
condition|(
name|XFS_INOBT_MASK
argument_list|(
name|chunkidx
argument_list|)
operator|&
name|INT_GET
argument_list|(
name|irbp
operator|->
name|ir_free
argument_list|,
name|ARCH_CONVERT
argument_list|)
condition|)
continue|continue;
comment|/* 				 * Count used inodes as free so we can tell 				 * when the chunk is used up. 				 */
name|INT_MOD
argument_list|(
name|irbp
operator|->
name|ir_freecount
argument_list|,
name|ARCH_CONVERT
argument_list|,
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ino
operator|=
name|XFS_AGINO_TO_INO
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|agino
argument_list|)
expr_stmt|;
name|bno
operator|=
name|XFS_AGB_TO_DADDR
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|agbno
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|BULKSTAT_FG_QUICK
condition|)
block|{
name|dip
operator|=
operator|(
name|xfs_dinode_t
operator|*
operator|)
name|xfs_buf_offset
argument_list|(
name|bp
argument_list|,
operator|(
name|clustidx
operator|<<
name|mp
operator|->
name|m_sb
operator|.
name|sb_inodelog
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_magic
argument_list|,
name|ARCH_CONVERT
argument_list|)
operator|!=
name|XFS_DINODE_MAGIC
operator|||
operator|!
name|XFS_DINODE_GOOD_VERSION
argument_list|(
name|INT_GET
argument_list|(
name|dip
operator|->
name|di_core
operator|.
name|di_version
argument_list|,
name|ARCH_CONVERT
argument_list|)
argument_list|)
condition|)
continue|continue;
block|}
comment|/* 				 * Get the inode and fill in a single buffer. 				 * BULKSTAT_FG_QUICK uses dip to fill it in. 				 * BULKSTAT_FG_IGET uses igets. 				 * See: xfs_bulkstat_one& xfs_dm_bulkstat_one. 				 * This is also used to count inodes/blks, etc 				 * in xfs_qm_quotacheck. 				 */
name|ubused
operator|=
name|statstruct_size
expr_stmt|;
name|error
operator|=
name|formatter
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|,
name|ubufp
argument_list|,
name|ubleft
argument_list|,
name|private_data
argument_list|,
name|bno
argument_list|,
operator|&
name|ubused
argument_list|,
name|dip
argument_list|,
operator|&
name|fmterror
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmterror
operator|==
name|BULKSTAT_RV_NOTHING
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOMEM
condition|)
name|ubleft
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fmterror
operator|==
name|BULKSTAT_RV_GIVEUP
condition|)
block|{
name|ubleft
operator|=
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|rval
operator|=
name|error
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ubufp
condition|)
name|ubufp
operator|+=
name|ubused
expr_stmt|;
name|ubleft
operator|-=
name|ubused
expr_stmt|;
name|ubelem
operator|++
expr_stmt|;
name|lastino
operator|=
name|ino
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bp
condition|)
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * Set up for the next loop iteration. 		 */
if|if
condition|(
name|ubleft
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|end_of_ag
condition|)
block|{
name|agno
operator|++
expr_stmt|;
name|agino
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|agino
operator|=
name|XFS_INO_TO_AGINO
argument_list|(
name|mp
argument_list|,
name|lastino
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* 	 * Done, we're either out of filesystem or space to put the data. 	 */
name|kmem_free
argument_list|(
name|irbuf
argument_list|,
name|NBPC
argument_list|)
expr_stmt|;
if|if
condition|(
name|ubuffer
condition|)
name|unuseracc
argument_list|(
name|ubuffer
argument_list|,
name|ubcount
operator|*
name|statstruct_size
argument_list|,
operator|(
name|B_READ
operator||
name|B_PHYS
operator|)
argument_list|)
expr_stmt|;
operator|*
name|ubcountp
operator|=
name|ubelem
expr_stmt|;
if|if
condition|(
name|agno
operator|>=
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
condition|)
block|{
comment|/* 		 * If we ran out of filesystem, mark lastino as off 		 * the end of the filesystem, so the next call 		 * will return immediately. 		 */
operator|*
name|lastinop
operator|=
operator|(
name|xfs_ino_t
operator|)
name|XFS_AGINO_TO_INO
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|done
operator|=
literal|1
expr_stmt|;
block|}
else|else
operator|*
name|lastinop
operator|=
operator|(
name|xfs_ino_t
operator|)
name|lastino
expr_stmt|;
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/*  * Return stat information in bulk (by-inode) for the filesystem.  * Special case for non-sequential one inode bulkstat.  */
end_comment

begin_function
name|int
comment|/* error status */
name|xfs_bulkstat_single
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* mount point for filesystem */
name|xfs_ino_t
modifier|*
name|lastinop
parameter_list|,
comment|/* inode to return */
name|char
name|__user
modifier|*
name|buffer
parameter_list|,
comment|/* buffer with inode stats */
name|int
modifier|*
name|done
parameter_list|)
comment|/* 1 if there are more stats to get */
block|{
name|int
name|count
decl_stmt|;
comment|/* count value for bulkstat call */
name|int
name|error
decl_stmt|;
comment|/* return value */
name|xfs_ino_t
name|ino
decl_stmt|;
comment|/* filesystem inode number */
name|int
name|res
decl_stmt|;
comment|/* result from bs1 */
comment|/* 	 * note that requesting valid inode numbers which are not allocated 	 * to inodes will most likely cause xfs_itobp to generate warning 	 * messages about bad magic numbers. This is ok. The fact that 	 * the inode isn't actually an inode is handled by the 	 * error check below. Done this way to make the usual case faster 	 * at the expense of the error case. 	 */
name|ino
operator|=
operator|(
name|xfs_ino_t
operator|)
operator|*
name|lastinop
expr_stmt|;
name|error
operator|=
name|xfs_bulkstat_one
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_bstat_t
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * Special case way failed, do it the "long" way 		 * to see if that works. 		 */
operator|(
operator|*
name|lastinop
operator|)
operator|--
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|xfs_bulkstat
argument_list|(
name|mp
argument_list|,
name|lastinop
argument_list|,
operator|&
name|count
argument_list|,
name|xfs_bulkstat_one
argument_list|,
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_bstat_t
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|BULKSTAT_FG_IGET
argument_list|,
name|done
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|count
operator|==
literal|0
operator|||
operator|(
name|xfs_ino_t
operator|)
operator|*
name|lastinop
operator|!=
name|ino
condition|)
return|return
name|error
operator|==
name|EFSCORRUPTED
condition|?
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
else|:
name|error
return|;
else|else
return|return
literal|0
return|;
block|}
operator|*
name|done
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return inode number table for the filesystem.  */
end_comment

begin_function
name|int
comment|/* error status */
name|xfs_inumbers
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* mount point for filesystem */
name|xfs_ino_t
modifier|*
name|lastino
parameter_list|,
comment|/* last inode returned */
name|int
modifier|*
name|count
parameter_list|,
comment|/* size of buffer/count returned */
name|xfs_inogrp_t
name|__user
modifier|*
name|ubuffer
parameter_list|)
comment|/* buffer with inode descriptions */
block|{
name|xfs_buf_t
modifier|*
name|agbp
decl_stmt|;
name|xfs_agino_t
name|agino
decl_stmt|;
name|xfs_agnumber_t
name|agno
decl_stmt|;
name|int
name|bcount
decl_stmt|;
name|xfs_inogrp_t
modifier|*
name|buffer
decl_stmt|;
name|int
name|bufidx
decl_stmt|;
name|xfs_btree_cur_t
modifier|*
name|cur
decl_stmt|;
name|int
name|error
decl_stmt|;
name|__int32_t
name|gcnt
decl_stmt|;
name|xfs_inofree_t
name|gfree
decl_stmt|;
name|xfs_agino_t
name|gino
decl_stmt|;
name|int
name|i
decl_stmt|;
name|xfs_ino_t
name|ino
decl_stmt|;
name|int
name|left
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|ino
operator|=
operator|(
name|xfs_ino_t
operator|)
operator|*
name|lastino
expr_stmt|;
name|agno
operator|=
name|XFS_INO_TO_AGNO
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|agino
operator|=
name|XFS_INO_TO_AGINO
argument_list|(
name|mp
argument_list|,
name|ino
argument_list|)
expr_stmt|;
name|left
operator|=
operator|*
name|count
expr_stmt|;
operator|*
name|count
operator|=
literal|0
expr_stmt|;
name|bcount
operator|=
name|MIN
argument_list|(
name|left
argument_list|,
call|(
name|int
call|)
argument_list|(
name|NBPP
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|buffer
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|kmem_alloc
argument_list|(
name|bcount
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|buffer
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|error
operator|=
name|bufidx
operator|=
literal|0
expr_stmt|;
name|cur
operator|=
name|NULL
expr_stmt|;
name|agbp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
operator|&&
name|agno
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_agcount
condition|)
block|{
if|if
condition|(
name|agbp
operator|==
name|NULL
condition|)
block|{
name|down_read
argument_list|(
operator|&
name|mp
operator|->
name|m_peraglock
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_ialloc_read_agi
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|agno
argument_list|,
operator|&
name|agbp
argument_list|)
expr_stmt|;
name|up_read
argument_list|(
operator|&
name|mp
operator|->
name|m_peraglock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 				 * If we can't read the AGI of this ag, 				 * then just skip to the next one. 				 */
name|ASSERT
argument_list|(
name|cur
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|agbp
operator|=
name|NULL
expr_stmt|;
name|agno
operator|++
expr_stmt|;
name|agino
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|cur
operator|=
name|xfs_btree_init_cursor
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|agbp
argument_list|,
name|agno
argument_list|,
name|XFS_BTNUM_INO
argument_list|,
operator|(
name|xfs_inode_t
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_inobt_lookup_ge
argument_list|(
name|cur
argument_list|,
name|agino
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_btree_del_cursor
argument_list|(
name|cur
argument_list|,
name|XFS_BTREE_ERROR
argument_list|)
expr_stmt|;
name|cur
operator|=
name|NULL
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|agbp
argument_list|)
expr_stmt|;
name|agbp
operator|=
name|NULL
expr_stmt|;
comment|/* 				 * Move up the the last inode in the current 				 * chunk.  The lookup_ge will always get 				 * us the first inode in the next chunk. 				 */
name|agino
operator|+=
name|XFS_INODES_PER_CHUNK
operator|-
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_inobt_get_rec
argument_list|(
name|cur
argument_list|,
operator|&
name|gino
argument_list|,
operator|&
name|gcnt
argument_list|,
operator|&
name|gfree
argument_list|,
operator|&
name|i
argument_list|)
operator|)
operator|||
name|i
operator|==
literal|0
condition|)
block|{
name|xfs_buf_relse
argument_list|(
name|agbp
argument_list|)
expr_stmt|;
name|agbp
operator|=
name|NULL
expr_stmt|;
name|xfs_btree_del_cursor
argument_list|(
name|cur
argument_list|,
name|XFS_BTREE_NOERROR
argument_list|)
expr_stmt|;
name|cur
operator|=
name|NULL
expr_stmt|;
name|agno
operator|++
expr_stmt|;
name|agino
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|agino
operator|=
name|gino
operator|+
name|XFS_INODES_PER_CHUNK
operator|-
literal|1
expr_stmt|;
name|buffer
index|[
name|bufidx
index|]
operator|.
name|xi_startino
operator|=
name|XFS_AGINO_TO_INO
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|gino
argument_list|)
expr_stmt|;
name|buffer
index|[
name|bufidx
index|]
operator|.
name|xi_alloccount
operator|=
name|XFS_INODES_PER_CHUNK
operator|-
name|gcnt
expr_stmt|;
name|buffer
index|[
name|bufidx
index|]
operator|.
name|xi_allocmask
operator|=
operator|~
name|gfree
expr_stmt|;
name|bufidx
operator|++
expr_stmt|;
name|left
operator|--
expr_stmt|;
if|if
condition|(
name|bufidx
operator|==
name|bcount
condition|)
block|{
if|if
condition|(
name|copy_to_user
argument_list|(
name|ubuffer
argument_list|,
name|buffer
argument_list|,
name|bufidx
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|buffer
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
break|break;
block|}
name|ubuffer
operator|+=
name|bufidx
expr_stmt|;
operator|*
name|count
operator|+=
name|bufidx
expr_stmt|;
name|bufidx
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|left
condition|)
block|{
name|error
operator|=
name|xfs_inobt_increment
argument_list|(
name|cur
argument_list|,
literal|0
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_btree_del_cursor
argument_list|(
name|cur
argument_list|,
name|XFS_BTREE_ERROR
argument_list|)
expr_stmt|;
name|cur
operator|=
name|NULL
expr_stmt|;
name|xfs_buf_relse
argument_list|(
name|agbp
argument_list|)
expr_stmt|;
name|agbp
operator|=
name|NULL
expr_stmt|;
comment|/* 				 * The agino value has already been bumped. 				 * Just try to skip up to it. 				 */
name|agino
operator|+=
name|XFS_INODES_PER_CHUNK
expr_stmt|;
continue|continue;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
if|if
condition|(
name|bufidx
condition|)
block|{
if|if
condition|(
name|copy_to_user
argument_list|(
name|ubuffer
argument_list|,
name|buffer
argument_list|,
name|bufidx
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|buffer
argument_list|)
argument_list|)
condition|)
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
else|else
operator|*
name|count
operator|+=
name|bufidx
expr_stmt|;
block|}
operator|*
name|lastino
operator|=
name|XFS_AGINO_TO_INO
argument_list|(
name|mp
argument_list|,
name|agno
argument_list|,
name|agino
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|buffer
argument_list|,
name|bcount
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
condition|)
name|xfs_btree_del_cursor
argument_list|(
name|cur
argument_list|,
operator|(
name|error
condition|?
name|XFS_BTREE_ERROR
else|:
name|XFS_BTREE_NOERROR
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|agbp
condition|)
name|xfs_buf_relse
argument_list|(
name|agbp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

end_unit

