begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000,2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans_priv.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode_item.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|XFS_TRANS_DEBUG
end_ifdef

begin_function_decl
name|STATIC
name|void
name|xfs_trans_inode_broot_debug
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|xfs_trans_inode_broot_debug
parameter_list|(
name|ip
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Get and lock the inode for the caller if it is not already  * locked within the given transaction.  If it is already locked  * within the transaction, just increment its lock recursion count  * and return a pointer to it.  *  * For an inode to be locked in a transaction, the inode lock, as  * opposed to the io lock, must be taken exclusively.  This ensures  * that the inode can be involved in only 1 transaction at a time.  * Lock recursion is handled on the io lock, but only for lock modes  * of equal or lesser strength.  That is, you can recur on the io lock  * held EXCL with a SHARED request but not vice versa.  Also, if  * the inode is already a part of the transaction then you cannot  * go from not holding the io lock to having it EXCL or SHARED.  *  * Use the inode cache routine xfs_inode_incore() to find the inode  * if it is already owned by this transaction.  *  * If we don't already own the inode, use xfs_iget() to get it.  * Since the inode log item structure is embedded in the incore  * inode structure and is initialized when the inode is brought  * into memory, there is nothing to do with it here.  *  * If the given transaction pointer is NULL, just call xfs_iget().  * This simplifies code which must handle both cases.  */
end_comment

begin_function
name|int
name|xfs_trans_iget
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_ino_t
name|ino
parameter_list|,
name|uint
name|flags
parameter_list|,
name|uint
name|lock_flags
parameter_list|,
name|xfs_inode_t
modifier|*
modifier|*
name|ipp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|xfs_inode_log_item_t
modifier|*
name|iip
decl_stmt|;
comment|/* 	 * If the transaction pointer is NULL, just call the normal 	 * xfs_iget(). 	 */
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return
name|xfs_iget
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|ino
argument_list|,
name|flags
argument_list|,
name|lock_flags
argument_list|,
name|ipp
argument_list|,
literal|0
argument_list|)
return|;
comment|/* 	 * If we find the inode in core with this transaction 	 * pointer in its i_transp field, then we know we already 	 * have it locked.  In this case we just increment the lock 	 * recursion count and return the inode to the caller. 	 * Assert that the inode is already locked in the mode requested 	 * by the caller.  We cannot do lock promotions yet, so 	 * die if someone gets this wrong. 	 */
if|if
condition|(
operator|(
name|ip
operator|=
name|xfs_inode_incore
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|,
name|ino
argument_list|,
name|tp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Make sure that the inode lock is held EXCL and 		 * that the io lock is never upgraded when the inode 		 * is already a part of the transaction. 		 */
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_itemp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lock_flags
operator|&
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|,
name|MR_UPDATE
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|!
operator|(
name|lock_flags
operator|&
name|XFS_IOLOCK_EXCL
operator|)
operator|)
operator|||
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|,
name|MR_UPDATE
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|!
operator|(
name|lock_flags
operator|&
name|XFS_IOLOCK_EXCL
operator|)
operator|)
operator|||
operator|(
name|ip
operator|->
name|i_itemp
operator|->
name|ili_flags
operator|&
name|XFS_ILI_IOLOCKED_EXCL
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|!
operator|(
name|lock_flags
operator|&
name|XFS_IOLOCK_SHARED
operator|)
operator|)
operator|||
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_iolock
argument_list|,
operator|(
name|MR_UPDATE
operator||
name|MR_ACCESS
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|!
operator|(
name|lock_flags
operator|&
name|XFS_IOLOCK_SHARED
operator|)
operator|)
operator|||
operator|(
name|ip
operator|->
name|i_itemp
operator|->
name|ili_flags
operator|&
name|XFS_ILI_IOLOCKED_ANY
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_flags
operator|&
operator|(
name|XFS_IOLOCK_SHARED
operator||
name|XFS_IOLOCK_EXCL
operator|)
condition|)
block|{
name|ip
operator|->
name|i_itemp
operator|->
name|ili_iolock_recur
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lock_flags
operator|&
name|XFS_ILOCK_EXCL
condition|)
block|{
name|ip
operator|->
name|i_itemp
operator|->
name|ili_ilock_recur
operator|++
expr_stmt|;
block|}
operator|*
name|ipp
operator|=
name|ip
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ASSERT
argument_list|(
name|lock_flags
operator|&
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_iget
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|,
name|tp
argument_list|,
name|ino
argument_list|,
name|flags
argument_list|,
name|lock_flags
argument_list|,
operator|&
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|ASSERT
argument_list|(
name|ip
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Get a log_item_desc to point at the new item. 	 */
if|if
condition|(
name|ip
operator|->
name|i_itemp
operator|==
name|NULL
condition|)
name|xfs_inode_item_init
argument_list|(
name|ip
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|iip
operator|=
name|ip
operator|->
name|i_itemp
expr_stmt|;
operator|(
name|void
operator|)
name|xfs_trans_add_item
argument_list|(
name|tp
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
operator|(
name|iip
operator|)
argument_list|)
expr_stmt|;
name|xfs_trans_inode_broot_debug
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* 	 * If the IO lock has been acquired, mark that in 	 * the inode log item so we'll know to unlock it 	 * when the transaction commits. 	 */
name|ASSERT
argument_list|(
name|iip
operator|->
name|ili_flags
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_flags
operator|&
name|XFS_IOLOCK_EXCL
condition|)
block|{
name|iip
operator|->
name|ili_flags
operator||=
name|XFS_ILI_IOLOCKED_EXCL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lock_flags
operator|&
name|XFS_IOLOCK_SHARED
condition|)
block|{
name|iip
operator|->
name|ili_flags
operator||=
name|XFS_ILI_IOLOCKED_SHARED
expr_stmt|;
block|}
comment|/* 	 * Initialize i_transp so we can find it with xfs_inode_incore() 	 * above. 	 */
name|ip
operator|->
name|i_transp
operator|=
name|tp
expr_stmt|;
operator|*
name|ipp
operator|=
name|ip
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Add the locked inode to the transaction.  * The inode must be locked, and it cannot be associated with any  * transaction.  The caller must specify the locks already held  * on the inode.  */
end_comment

begin_function
name|void
name|xfs_trans_ijoin
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|uint
name|lock_flags
parameter_list|)
block|{
name|xfs_inode_log_item_t
modifier|*
name|iip
decl_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_transp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|,
name|MR_UPDATE
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lock_flags
operator|&
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|i_itemp
operator|==
name|NULL
condition|)
name|xfs_inode_item_init
argument_list|(
name|ip
argument_list|,
name|ip
operator|->
name|i_mount
argument_list|)
expr_stmt|;
name|iip
operator|=
name|ip
operator|->
name|i_itemp
expr_stmt|;
name|ASSERT
argument_list|(
name|iip
operator|->
name|ili_flags
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|iip
operator|->
name|ili_ilock_recur
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|iip
operator|->
name|ili_iolock_recur
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Get a log_item_desc to point at the new item. 	 */
operator|(
name|void
operator|)
name|xfs_trans_add_item
argument_list|(
name|tp
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
operator|(
name|iip
operator|)
argument_list|)
expr_stmt|;
name|xfs_trans_inode_broot_debug
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* 	 * If the IO lock is already held, mark that in the inode log item. 	 */
if|if
condition|(
name|lock_flags
operator|&
name|XFS_IOLOCK_EXCL
condition|)
block|{
name|iip
operator|->
name|ili_flags
operator||=
name|XFS_ILI_IOLOCKED_EXCL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lock_flags
operator|&
name|XFS_IOLOCK_SHARED
condition|)
block|{
name|iip
operator|->
name|ili_flags
operator||=
name|XFS_ILI_IOLOCKED_SHARED
expr_stmt|;
block|}
comment|/* 	 * Initialize i_transp so we can find it with xfs_inode_incore() 	 * in xfs_trans_iget() above. 	 */
name|ip
operator|->
name|i_transp
operator|=
name|tp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mark the inode as not needing to be unlocked when the inode item's  * IOP_UNLOCK() routine is called.  The inode must already be locked  * and associated with the given transaction.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|xfs_trans_ihold
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_transp
operator|==
name|tp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_itemp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|,
name|MR_UPDATE
argument_list|)
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_itemp
operator|->
name|ili_flags
operator||=
name|XFS_ILI_HOLD
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called to mark the fields indicated in fieldmask as needing  * to be logged when the transaction is committed.  The inode must  * already be associated with the given transaction.  *  * The values for fieldmask are defined in xfs_inode_item.h.  We always  * log all of the core inode if any of it has changed, and we always log  * all of the inline data/extents/b-tree root if any of them has changed.  */
end_comment

begin_function
name|void
name|xfs_trans_log_inode
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_inode_t
modifier|*
name|ip
parameter_list|,
name|uint
name|flags
parameter_list|)
block|{
name|xfs_log_item_desc_t
modifier|*
name|lidp
decl_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_transp
operator|==
name|tp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_itemp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ismrlocked
argument_list|(
operator|&
name|ip
operator|->
name|i_lock
argument_list|,
name|MR_UPDATE
argument_list|)
argument_list|)
expr_stmt|;
name|lidp
operator|=
name|xfs_trans_find_item
argument_list|(
name|tp
argument_list|,
operator|(
name|xfs_log_item_t
operator|*
operator|)
operator|(
name|ip
operator|->
name|i_itemp
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lidp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|XFS_TRANS_DIRTY
expr_stmt|;
name|lidp
operator|->
name|lid_flags
operator||=
name|XFS_LID_DIRTY
expr_stmt|;
comment|/* 	 * Always OR in the bits from the ili_last_fields field. 	 * This is to coordinate with the xfs_iflush() and xfs_iflush_done() 	 * routines in the eventual clearing of the ilf_fields bits. 	 * See the big comment in xfs_iflush() for an explanation of 	 * this coordination mechanism. 	 */
name|flags
operator||=
name|ip
operator|->
name|i_itemp
operator|->
name|ili_last_fields
expr_stmt|;
name|ip
operator|->
name|i_itemp
operator|->
name|ili_format
operator|.
name|ilf_fields
operator||=
name|flags
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|XFS_TRANS_DEBUG
end_ifdef

begin_comment
comment|/*  * Keep track of the state of the inode btree root to make sure we  * log it properly.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_trans_inode_broot_debug
parameter_list|(
name|xfs_inode_t
modifier|*
name|ip
parameter_list|)
block|{
name|xfs_inode_log_item_t
modifier|*
name|iip
decl_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_itemp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|iip
operator|=
name|ip
operator|->
name|i_itemp
expr_stmt|;
if|if
condition|(
name|iip
operator|->
name|ili_root_size
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|iip
operator|->
name|ili_orig_root
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|iip
operator|->
name|ili_orig_root
argument_list|,
name|iip
operator|->
name|ili_root_size
argument_list|)
expr_stmt|;
name|iip
operator|->
name|ili_root_size
operator|=
literal|0
expr_stmt|;
name|iip
operator|->
name|ili_orig_root
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_format
operator|==
name|XFS_DINODE_FMT_BTREE
condition|)
block|{
name|ASSERT
argument_list|(
operator|(
name|ip
operator|->
name|i_df
operator|.
name|if_broot
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_df
operator|.
name|if_broot_bytes
operator|>
literal|0
operator|)
argument_list|)
expr_stmt|;
name|iip
operator|->
name|ili_root_size
operator|=
name|ip
operator|->
name|i_df
operator|.
name|if_broot_bytes
expr_stmt|;
name|iip
operator|->
name|ili_orig_root
operator|=
operator|(
name|char
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|iip
operator|->
name|ili_root_size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|iip
operator|->
name|ili_orig_root
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|ip
operator|->
name|i_df
operator|.
name|if_broot
operator|)
argument_list|,
name|iip
operator|->
name|ili_root_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

