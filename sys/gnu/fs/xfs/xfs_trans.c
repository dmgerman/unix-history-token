begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2003,2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_da_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_quota.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans_priv.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans_space.h"
end_include

begin_function_decl
name|STATIC
name|void
name|xfs_trans_apply_sb_deltas
parameter_list|(
name|xfs_trans_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|uint
name|xfs_trans_count_vecs
parameter_list|(
name|xfs_trans_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_trans_fill_vecs
parameter_list|(
name|xfs_trans_t
modifier|*
parameter_list|,
name|xfs_log_iovec_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_trans_uncommit
parameter_list|(
name|xfs_trans_t
modifier|*
parameter_list|,
name|uint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_trans_committed
parameter_list|(
name|xfs_trans_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_trans_chunk_committed
parameter_list|(
name|xfs_log_item_chunk_t
modifier|*
parameter_list|,
name|xfs_lsn_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|xfs_trans_free
parameter_list|(
name|xfs_trans_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|kmem_zone_t
modifier|*
name|xfs_trans_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Reservation functions here avoid a huge stack in xfs_trans_init  * due to register overflow from temporaries in the calculations.  */
end_comment

begin_function
name|STATIC
name|uint
name|xfs_calc_write_reservation
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
return|return
name|XFS_CALC_WRITE_LOG_RES
argument_list|(
name|mp
argument_list|)
operator|+
name|XFS_DQUOT_LOGRES
argument_list|(
name|mp
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|uint
name|xfs_calc_itruncate_reservation
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
return|return
name|XFS_CALC_ITRUNCATE_LOG_RES
argument_list|(
name|mp
argument_list|)
operator|+
name|XFS_DQUOT_LOGRES
argument_list|(
name|mp
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|uint
name|xfs_calc_rename_reservation
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
return|return
name|XFS_CALC_RENAME_LOG_RES
argument_list|(
name|mp
argument_list|)
operator|+
name|XFS_DQUOT_LOGRES
argument_list|(
name|mp
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|uint
name|xfs_calc_link_reservation
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
return|return
name|XFS_CALC_LINK_LOG_RES
argument_list|(
name|mp
argument_list|)
operator|+
name|XFS_DQUOT_LOGRES
argument_list|(
name|mp
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|uint
name|xfs_calc_remove_reservation
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
return|return
name|XFS_CALC_REMOVE_LOG_RES
argument_list|(
name|mp
argument_list|)
operator|+
name|XFS_DQUOT_LOGRES
argument_list|(
name|mp
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|uint
name|xfs_calc_symlink_reservation
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
return|return
name|XFS_CALC_SYMLINK_LOG_RES
argument_list|(
name|mp
argument_list|)
operator|+
name|XFS_DQUOT_LOGRES
argument_list|(
name|mp
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|uint
name|xfs_calc_create_reservation
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
return|return
name|XFS_CALC_CREATE_LOG_RES
argument_list|(
name|mp
argument_list|)
operator|+
name|XFS_DQUOT_LOGRES
argument_list|(
name|mp
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|uint
name|xfs_calc_mkdir_reservation
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
return|return
name|XFS_CALC_MKDIR_LOG_RES
argument_list|(
name|mp
argument_list|)
operator|+
name|XFS_DQUOT_LOGRES
argument_list|(
name|mp
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|uint
name|xfs_calc_ifree_reservation
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
return|return
name|XFS_CALC_IFREE_LOG_RES
argument_list|(
name|mp
argument_list|)
operator|+
name|XFS_DQUOT_LOGRES
argument_list|(
name|mp
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|uint
name|xfs_calc_ichange_reservation
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
return|return
name|XFS_CALC_ICHANGE_LOG_RES
argument_list|(
name|mp
argument_list|)
operator|+
name|XFS_DQUOT_LOGRES
argument_list|(
name|mp
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|uint
name|xfs_calc_growdata_reservation
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
return|return
name|XFS_CALC_GROWDATA_LOG_RES
argument_list|(
name|mp
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|uint
name|xfs_calc_growrtalloc_reservation
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
return|return
name|XFS_CALC_GROWRTALLOC_LOG_RES
argument_list|(
name|mp
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|uint
name|xfs_calc_growrtzero_reservation
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
return|return
name|XFS_CALC_GROWRTZERO_LOG_RES
argument_list|(
name|mp
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|uint
name|xfs_calc_growrtfree_reservation
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
return|return
name|XFS_CALC_GROWRTFREE_LOG_RES
argument_list|(
name|mp
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|uint
name|xfs_calc_swrite_reservation
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
return|return
name|XFS_CALC_SWRITE_LOG_RES
argument_list|(
name|mp
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|uint
name|xfs_calc_writeid_reservation
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
return|return
name|XFS_CALC_WRITEID_LOG_RES
argument_list|(
name|mp
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|uint
name|xfs_calc_addafork_reservation
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
return|return
name|XFS_CALC_ADDAFORK_LOG_RES
argument_list|(
name|mp
argument_list|)
operator|+
name|XFS_DQUOT_LOGRES
argument_list|(
name|mp
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|uint
name|xfs_calc_attrinval_reservation
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
return|return
name|XFS_CALC_ATTRINVAL_LOG_RES
argument_list|(
name|mp
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|uint
name|xfs_calc_attrset_reservation
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
return|return
name|XFS_CALC_ATTRSET_LOG_RES
argument_list|(
name|mp
argument_list|)
operator|+
name|XFS_DQUOT_LOGRES
argument_list|(
name|mp
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|uint
name|xfs_calc_attrrm_reservation
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
return|return
name|XFS_CALC_ATTRRM_LOG_RES
argument_list|(
name|mp
argument_list|)
operator|+
name|XFS_DQUOT_LOGRES
argument_list|(
name|mp
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|uint
name|xfs_calc_clear_agi_bucket_reservation
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
return|return
name|XFS_CALC_CLEAR_AGI_BUCKET_LOG_RES
argument_list|(
name|mp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the precomputed transaction reservation values  * in the mount structure.  */
end_comment

begin_function
name|void
name|xfs_trans_init
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|xfs_trans_reservations_t
modifier|*
name|resp
decl_stmt|;
name|resp
operator|=
operator|&
operator|(
name|mp
operator|->
name|m_reservations
operator|)
expr_stmt|;
name|resp
operator|->
name|tr_write
operator|=
name|xfs_calc_write_reservation
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_itruncate
operator|=
name|xfs_calc_itruncate_reservation
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_rename
operator|=
name|xfs_calc_rename_reservation
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_link
operator|=
name|xfs_calc_link_reservation
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_remove
operator|=
name|xfs_calc_remove_reservation
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_symlink
operator|=
name|xfs_calc_symlink_reservation
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_create
operator|=
name|xfs_calc_create_reservation
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_mkdir
operator|=
name|xfs_calc_mkdir_reservation
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_ifree
operator|=
name|xfs_calc_ifree_reservation
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_ichange
operator|=
name|xfs_calc_ichange_reservation
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_growdata
operator|=
name|xfs_calc_growdata_reservation
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_swrite
operator|=
name|xfs_calc_swrite_reservation
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_writeid
operator|=
name|xfs_calc_writeid_reservation
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_addafork
operator|=
name|xfs_calc_addafork_reservation
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_attrinval
operator|=
name|xfs_calc_attrinval_reservation
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_attrset
operator|=
name|xfs_calc_attrset_reservation
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_attrrm
operator|=
name|xfs_calc_attrrm_reservation
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_clearagi
operator|=
name|xfs_calc_clear_agi_bucket_reservation
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_growrtalloc
operator|=
name|xfs_calc_growrtalloc_reservation
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_growrtzero
operator|=
name|xfs_calc_growrtzero_reservation
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|resp
operator|->
name|tr_growrtfree
operator|=
name|xfs_calc_growrtfree_reservation
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine is called to allocate a transaction structure.  * The type parameter indicates the type of the transaction.  These  * are enumerated in xfs_trans.h.  *  * Dynamically allocate the transaction structure from the transaction  * zone, initialize it, and return it to the caller.  */
end_comment

begin_function
name|xfs_trans_t
modifier|*
name|xfs_trans_alloc
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|uint
name|type
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RMC
name|fs_check_frozen
argument_list|(
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
argument_list|,
name|SB_FREEZE_TRANS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|atomic_inc
argument_list|(
operator|&
name|mp
operator|->
name|m_active_trans
argument_list|)
expr_stmt|;
return|return
operator|(
name|_xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|xfs_trans_t
modifier|*
name|_xfs_trans_alloc
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|uint
name|type
parameter_list|)
block|{
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|ASSERT
argument_list|(
name|xfs_trans_zone
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tp
operator|=
name|kmem_zone_zalloc
argument_list|(
name|xfs_trans_zone
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the transaction structure. 	 */
name|tp
operator|->
name|t_magic
operator|=
name|XFS_TRANS_MAGIC
expr_stmt|;
name|tp
operator|->
name|t_type
operator|=
name|type
expr_stmt|;
name|tp
operator|->
name|t_mountp
operator|=
name|mp
expr_stmt|;
name|tp
operator|->
name|t_items_free
operator|=
name|XFS_LIC_NUM_SLOTS
expr_stmt|;
name|tp
operator|->
name|t_busy_free
operator|=
name|XFS_LBC_NUM_SLOTS
expr_stmt|;
name|XFS_LIC_INIT
argument_list|(
operator|&
operator|(
name|tp
operator|->
name|t_items
operator|)
argument_list|)
expr_stmt|;
name|XFS_LBC_INIT
argument_list|(
operator|&
operator|(
name|tp
operator|->
name|t_busy
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is called to create a new transaction which will share the  * permanent log reservation of the given transaction.  The remaining  * unused block and rt extent reservations are also inherited.  This  * implies that the original transaction is no longer allowed to allocate  * blocks.  Locks and log items, however, are no inherited.  They must  * be added to the new transaction explicitly.  */
end_comment

begin_function
name|xfs_trans_t
modifier|*
name|xfs_trans_dup
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|)
block|{
name|xfs_trans_t
modifier|*
name|ntp
decl_stmt|;
name|ntp
operator|=
name|kmem_zone_zalloc
argument_list|(
name|xfs_trans_zone
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the new transaction structure. 	 */
name|ntp
operator|->
name|t_magic
operator|=
name|XFS_TRANS_MAGIC
expr_stmt|;
name|ntp
operator|->
name|t_type
operator|=
name|tp
operator|->
name|t_type
expr_stmt|;
name|ntp
operator|->
name|t_mountp
operator|=
name|tp
operator|->
name|t_mountp
expr_stmt|;
name|ntp
operator|->
name|t_items_free
operator|=
name|XFS_LIC_NUM_SLOTS
expr_stmt|;
name|ntp
operator|->
name|t_busy_free
operator|=
name|XFS_LBC_NUM_SLOTS
expr_stmt|;
name|XFS_LIC_INIT
argument_list|(
operator|&
operator|(
name|ntp
operator|->
name|t_items
operator|)
argument_list|)
expr_stmt|;
name|XFS_LBC_INIT
argument_list|(
operator|&
operator|(
name|ntp
operator|->
name|t_busy
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tp
operator|->
name|t_flags
operator|&
name|XFS_TRANS_PERM_LOG_RES
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tp
operator|->
name|t_ticket
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ntp
operator|->
name|t_flags
operator|=
name|XFS_TRANS_PERM_LOG_RES
operator||
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|XFS_TRANS_RESERVE
operator|)
expr_stmt|;
name|ntp
operator|->
name|t_ticket
operator|=
name|tp
operator|->
name|t_ticket
expr_stmt|;
name|ntp
operator|->
name|t_blk_res
operator|=
name|tp
operator|->
name|t_blk_res
operator|-
name|tp
operator|->
name|t_blk_res_used
expr_stmt|;
name|tp
operator|->
name|t_blk_res
operator|=
name|tp
operator|->
name|t_blk_res_used
expr_stmt|;
name|ntp
operator|->
name|t_rtx_res
operator|=
name|tp
operator|->
name|t_rtx_res
operator|-
name|tp
operator|->
name|t_rtx_res_used
expr_stmt|;
name|tp
operator|->
name|t_rtx_res
operator|=
name|tp
operator|->
name|t_rtx_res_used
expr_stmt|;
name|PFLAGS_DUP
argument_list|(
operator|&
name|tp
operator|->
name|t_pflags
argument_list|,
operator|&
name|ntp
operator|->
name|t_pflags
argument_list|)
expr_stmt|;
name|XFS_TRANS_DUP_DQINFO
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|,
name|tp
argument_list|,
name|ntp
argument_list|)
expr_stmt|;
name|atomic_inc
argument_list|(
operator|&
name|tp
operator|->
name|t_mountp
operator|->
name|m_active_trans
argument_list|)
expr_stmt|;
return|return
name|ntp
return|;
block|}
end_function

begin_comment
comment|/*  * This is called to reserve free disk blocks and log space for the  * given transaction.  This must be done before allocating any resources  * within the transaction.  *  * This will return ENOSPC if there are not enough blocks available.  * It will sleep waiting for available log space.  * The only valid value for the flags parameter is XFS_RES_LOG_PERM, which  * is used by long running transactions.  If any one of the reservations  * fails then they will all be backed out.  *  * This does not do quota reservations. That typically is done by the  * caller afterwards.  */
end_comment

begin_function
name|int
name|xfs_trans_reserve
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|uint
name|blocks
parameter_list|,
name|uint
name|logspace
parameter_list|,
name|uint
name|rtextents
parameter_list|,
name|uint
name|flags
parameter_list|,
name|uint
name|logcount
parameter_list|)
block|{
name|int
name|log_flags
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|rsvd
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|rsvd
operator|=
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|XFS_TRANS_RESERVE
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* Mark this thread as being in a transaction */
name|PFLAGS_SET_FSTRANS
argument_list|(
operator|&
name|tp
operator|->
name|t_pflags
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to reserve the needed disk blocks by decrementing 	 * the number needed from the number available.  This will 	 * fail if the count would go below zero. 	 */
if|if
condition|(
name|blocks
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|xfs_mod_incore_sb
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|,
name|XFS_SBS_FDBLOCKS
argument_list|,
operator|-
name|blocks
argument_list|,
name|rsvd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|PFLAGS_RESTORE_FSTRANS
argument_list|(
operator|&
name|tp
operator|->
name|t_pflags
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
operator|)
return|;
block|}
name|tp
operator|->
name|t_blk_res
operator|+=
name|blocks
expr_stmt|;
block|}
comment|/* 	 * Reserve the log space needed for this transaction. 	 */
if|if
condition|(
name|logspace
operator|>
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
operator|(
name|tp
operator|->
name|t_log_res
operator|==
literal|0
operator|)
operator|||
operator|(
name|tp
operator|->
name|t_log_res
operator|==
name|logspace
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|tp
operator|->
name|t_log_count
operator|==
literal|0
operator|)
operator|||
operator|(
name|tp
operator|->
name|t_log_count
operator|==
name|logcount
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|XFS_TRANS_PERM_LOG_RES
condition|)
block|{
name|log_flags
operator|=
name|XFS_LOG_PERM_RESERV
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|XFS_TRANS_PERM_LOG_RES
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|tp
operator|->
name|t_ticket
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|XFS_TRANS_PERM_LOG_RES
operator|)
argument_list|)
expr_stmt|;
name|log_flags
operator|=
literal|0
expr_stmt|;
block|}
name|error
operator|=
name|xfs_log_reserve
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|,
name|logspace
argument_list|,
name|logcount
argument_list|,
operator|&
name|tp
operator|->
name|t_ticket
argument_list|,
name|XFS_TRANSACTION
argument_list|,
name|log_flags
argument_list|,
name|tp
operator|->
name|t_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|undo_blocks
goto|;
block|}
name|tp
operator|->
name|t_log_res
operator|=
name|logspace
expr_stmt|;
name|tp
operator|->
name|t_log_count
operator|=
name|logcount
expr_stmt|;
block|}
comment|/* 	 * Attempt to reserve the needed realtime extents by decrementing 	 * the number needed from the number available.  This will 	 * fail if the count would go below zero. 	 */
if|if
condition|(
name|rtextents
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|xfs_mod_incore_sb
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|,
name|XFS_SBS_FREXTENTS
argument_list|,
operator|-
name|rtextents
argument_list|,
name|rsvd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|error
operator|=
name|XFS_ERROR
argument_list|(
name|ENOSPC
argument_list|)
expr_stmt|;
goto|goto
name|undo_log
goto|;
block|}
name|tp
operator|->
name|t_rtx_res
operator|+=
name|rtextents
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* 	 * Error cases jump to one of these labels to undo any 	 * reservations which have already been performed. 	 */
name|undo_log
label|:
if|if
condition|(
name|logspace
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|XFS_TRANS_PERM_LOG_RES
condition|)
block|{
name|log_flags
operator|=
name|XFS_LOG_REL_PERM_RESERV
expr_stmt|;
block|}
else|else
block|{
name|log_flags
operator|=
literal|0
expr_stmt|;
block|}
name|xfs_log_done
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|,
name|tp
operator|->
name|t_ticket
argument_list|,
name|NULL
argument_list|,
name|log_flags
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_ticket
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_log_res
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|XFS_TRANS_PERM_LOG_RES
expr_stmt|;
block|}
name|undo_blocks
label|:
if|if
condition|(
name|blocks
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|xfs_mod_incore_sb
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|,
name|XFS_SBS_FDBLOCKS
argument_list|,
name|blocks
argument_list|,
name|rsvd
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_blk_res
operator|=
literal|0
expr_stmt|;
block|}
name|PFLAGS_RESTORE_FSTRANS
argument_list|(
operator|&
name|tp
operator|->
name|t_pflags
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Record the indicated change to the given field for application  * to the file system's superblock when the transaction commits.  * For now, just store the change in the transaction structure.  *  * Mark the transaction structure to indicate that the superblock  * needs to be updated before committing.  */
end_comment

begin_function
name|void
name|xfs_trans_mod_sb
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|uint
name|field
parameter_list|,
name|long
name|delta
parameter_list|)
block|{
switch|switch
condition|(
name|field
condition|)
block|{
case|case
name|XFS_TRANS_SB_ICOUNT
case|:
name|tp
operator|->
name|t_icount_delta
operator|+=
name|delta
expr_stmt|;
break|break;
case|case
name|XFS_TRANS_SB_IFREE
case|:
name|tp
operator|->
name|t_ifree_delta
operator|+=
name|delta
expr_stmt|;
break|break;
case|case
name|XFS_TRANS_SB_FDBLOCKS
case|:
comment|/* 		 * Track the number of blocks allocated in the 		 * transaction.  Make sure it does not exceed the 		 * number reserved. 		 */
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
block|{
name|tp
operator|->
name|t_blk_res_used
operator|+=
operator|(
name|uint
operator|)
operator|-
name|delta
expr_stmt|;
name|ASSERT
argument_list|(
name|tp
operator|->
name|t_blk_res_used
operator|<=
name|tp
operator|->
name|t_blk_res
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_fdblocks_delta
operator|+=
name|delta
expr_stmt|;
break|break;
case|case
name|XFS_TRANS_SB_RES_FDBLOCKS
case|:
comment|/* 		 * The allocation has already been applied to the 		 * in-core superblock's counter.  This should only 		 * be applied to the on-disk superblock. 		 */
name|ASSERT
argument_list|(
name|delta
operator|<
literal|0
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_res_fdblocks_delta
operator|+=
name|delta
expr_stmt|;
break|break;
case|case
name|XFS_TRANS_SB_FREXTENTS
case|:
comment|/* 		 * Track the number of blocks allocated in the 		 * transaction.  Make sure it does not exceed the 		 * number reserved. 		 */
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
block|{
name|tp
operator|->
name|t_rtx_res_used
operator|+=
operator|(
name|uint
operator|)
operator|-
name|delta
expr_stmt|;
name|ASSERT
argument_list|(
name|tp
operator|->
name|t_rtx_res_used
operator|<=
name|tp
operator|->
name|t_rtx_res
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_frextents_delta
operator|+=
name|delta
expr_stmt|;
break|break;
case|case
name|XFS_TRANS_SB_RES_FREXTENTS
case|:
comment|/* 		 * The allocation has already been applied to the 		 * in-core superblock's counter.  This should only 		 * be applied to the on-disk superblock. 		 */
name|ASSERT
argument_list|(
name|delta
operator|<
literal|0
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_res_frextents_delta
operator|+=
name|delta
expr_stmt|;
break|break;
case|case
name|XFS_TRANS_SB_DBLOCKS
case|:
name|ASSERT
argument_list|(
name|delta
operator|>
literal|0
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_dblocks_delta
operator|+=
name|delta
expr_stmt|;
break|break;
case|case
name|XFS_TRANS_SB_AGCOUNT
case|:
name|ASSERT
argument_list|(
name|delta
operator|>
literal|0
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_agcount_delta
operator|+=
name|delta
expr_stmt|;
break|break;
case|case
name|XFS_TRANS_SB_IMAXPCT
case|:
name|tp
operator|->
name|t_imaxpct_delta
operator|+=
name|delta
expr_stmt|;
break|break;
case|case
name|XFS_TRANS_SB_REXTSIZE
case|:
name|tp
operator|->
name|t_rextsize_delta
operator|+=
name|delta
expr_stmt|;
break|break;
case|case
name|XFS_TRANS_SB_RBMBLOCKS
case|:
name|tp
operator|->
name|t_rbmblocks_delta
operator|+=
name|delta
expr_stmt|;
break|break;
case|case
name|XFS_TRANS_SB_RBLOCKS
case|:
name|tp
operator|->
name|t_rblocks_delta
operator|+=
name|delta
expr_stmt|;
break|break;
case|case
name|XFS_TRANS_SB_REXTENTS
case|:
name|tp
operator|->
name|t_rextents_delta
operator|+=
name|delta
expr_stmt|;
break|break;
case|case
name|XFS_TRANS_SB_REXTSLOG
case|:
name|tp
operator|->
name|t_rextslog_delta
operator|+=
name|delta
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|tp
operator|->
name|t_flags
operator||=
operator|(
name|XFS_TRANS_SB_DIRTY
operator||
name|XFS_TRANS_DIRTY
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * xfs_trans_apply_sb_deltas() is called from the commit code  * to bring the superblock buffer into the current transaction  * and modify it as requested by earlier calls to xfs_trans_mod_sb().  *  * For now we just look at each field allowed to change and change  * it if necessary.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_trans_apply_sb_deltas
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|)
block|{
name|xfs_sb_t
modifier|*
name|sbp
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|int
name|whole
init|=
literal|0
decl_stmt|;
name|bp
operator|=
name|xfs_trans_getsb
argument_list|(
name|tp
argument_list|,
name|tp
operator|->
name|t_mountp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sbp
operator|=
name|XFS_BUF_TO_SBP
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Check that superblock mods match the mods made to AGF counters. 	 */
name|ASSERT
argument_list|(
operator|(
name|tp
operator|->
name|t_fdblocks_delta
operator|+
name|tp
operator|->
name|t_res_fdblocks_delta
operator|)
operator|==
operator|(
name|tp
operator|->
name|t_ag_freeblks_delta
operator|+
name|tp
operator|->
name|t_ag_flist_delta
operator|+
name|tp
operator|->
name|t_ag_btree_delta
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_icount_delta
operator|!=
literal|0
condition|)
block|{
name|INT_MOD
argument_list|(
name|sbp
operator|->
name|sb_icount
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|tp
operator|->
name|t_icount_delta
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_ifree_delta
operator|!=
literal|0
condition|)
block|{
name|INT_MOD
argument_list|(
name|sbp
operator|->
name|sb_ifree
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|tp
operator|->
name|t_ifree_delta
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_fdblocks_delta
operator|!=
literal|0
condition|)
block|{
name|INT_MOD
argument_list|(
name|sbp
operator|->
name|sb_fdblocks
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|tp
operator|->
name|t_fdblocks_delta
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_res_fdblocks_delta
operator|!=
literal|0
condition|)
block|{
name|INT_MOD
argument_list|(
name|sbp
operator|->
name|sb_fdblocks
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|tp
operator|->
name|t_res_fdblocks_delta
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_frextents_delta
operator|!=
literal|0
condition|)
block|{
name|INT_MOD
argument_list|(
name|sbp
operator|->
name|sb_frextents
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|tp
operator|->
name|t_frextents_delta
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_res_frextents_delta
operator|!=
literal|0
condition|)
block|{
name|INT_MOD
argument_list|(
name|sbp
operator|->
name|sb_frextents
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|tp
operator|->
name|t_res_frextents_delta
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_dblocks_delta
operator|!=
literal|0
condition|)
block|{
name|INT_MOD
argument_list|(
name|sbp
operator|->
name|sb_dblocks
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|tp
operator|->
name|t_dblocks_delta
argument_list|)
expr_stmt|;
name|whole
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_agcount_delta
operator|!=
literal|0
condition|)
block|{
name|INT_MOD
argument_list|(
name|sbp
operator|->
name|sb_agcount
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|tp
operator|->
name|t_agcount_delta
argument_list|)
expr_stmt|;
name|whole
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_imaxpct_delta
operator|!=
literal|0
condition|)
block|{
name|INT_MOD
argument_list|(
name|sbp
operator|->
name|sb_imax_pct
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|tp
operator|->
name|t_imaxpct_delta
argument_list|)
expr_stmt|;
name|whole
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_rextsize_delta
operator|!=
literal|0
condition|)
block|{
name|INT_MOD
argument_list|(
name|sbp
operator|->
name|sb_rextsize
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|tp
operator|->
name|t_rextsize_delta
argument_list|)
expr_stmt|;
name|whole
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_rbmblocks_delta
operator|!=
literal|0
condition|)
block|{
name|INT_MOD
argument_list|(
name|sbp
operator|->
name|sb_rbmblocks
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|tp
operator|->
name|t_rbmblocks_delta
argument_list|)
expr_stmt|;
name|whole
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_rblocks_delta
operator|!=
literal|0
condition|)
block|{
name|INT_MOD
argument_list|(
name|sbp
operator|->
name|sb_rblocks
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|tp
operator|->
name|t_rblocks_delta
argument_list|)
expr_stmt|;
name|whole
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_rextents_delta
operator|!=
literal|0
condition|)
block|{
name|INT_MOD
argument_list|(
name|sbp
operator|->
name|sb_rextents
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|tp
operator|->
name|t_rextents_delta
argument_list|)
expr_stmt|;
name|whole
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_rextslog_delta
operator|!=
literal|0
condition|)
block|{
name|INT_MOD
argument_list|(
name|sbp
operator|->
name|sb_rextslog
argument_list|,
name|ARCH_CONVERT
argument_list|,
name|tp
operator|->
name|t_rextslog_delta
argument_list|)
expr_stmt|;
name|whole
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|whole
condition|)
comment|/* 		 * Log the whole thing, the fields are noncontiguous. 		 */
name|xfs_trans_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_sb_t
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
comment|/* 		 * Since all the modifiable fields are contiguous, we 		 * can get away with this. 		 */
name|xfs_trans_log_buf
argument_list|(
name|tp
argument_list|,
name|bp
argument_list|,
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_icount
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|xfs_sb_t
argument_list|,
name|sb_frextents
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|sbp
operator|->
name|sb_frextents
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XXXKAN
name|XFS_MTOVFS
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|)
operator|->
name|vfs_super
operator|->
name|s_dirt
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * xfs_trans_unreserve_and_mod_sb() is called to release unused  * reservations and apply superblock counter changes to the in-core  * superblock.  *  * This is done efficiently with a single call to xfs_mod_incore_sb_batch().  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_trans_unreserve_and_mod_sb
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|)
block|{
name|xfs_mod_sb_t
name|msb
index|[
literal|14
index|]
decl_stmt|;
comment|/* If you add cases, add entries */
name|xfs_mod_sb_t
modifier|*
name|msbp
decl_stmt|;
comment|/* REFERENCED */
name|int
name|error
decl_stmt|;
name|int
name|rsvd
decl_stmt|;
name|msbp
operator|=
name|msb
expr_stmt|;
name|rsvd
operator|=
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|XFS_TRANS_RESERVE
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* 	 * Release any reserved blocks.  Any that were allocated 	 * will be taken back again by fdblocks_delta below. 	 */
if|if
condition|(
name|tp
operator|->
name|t_blk_res
operator|>
literal|0
condition|)
block|{
name|msbp
operator|->
name|msb_field
operator|=
name|XFS_SBS_FDBLOCKS
expr_stmt|;
name|msbp
operator|->
name|msb_delta
operator|=
name|tp
operator|->
name|t_blk_res
expr_stmt|;
name|msbp
operator|++
expr_stmt|;
block|}
comment|/* 	 * Release any reserved real time extents .  Any that were 	 * allocated will be taken back again by frextents_delta below. 	 */
if|if
condition|(
name|tp
operator|->
name|t_rtx_res
operator|>
literal|0
condition|)
block|{
name|msbp
operator|->
name|msb_field
operator|=
name|XFS_SBS_FREXTENTS
expr_stmt|;
name|msbp
operator|->
name|msb_delta
operator|=
name|tp
operator|->
name|t_rtx_res
expr_stmt|;
name|msbp
operator|++
expr_stmt|;
block|}
comment|/* 	 * Apply any superblock modifications to the in-core version. 	 * The t_res_fdblocks_delta and t_res_frextents_delta fields are 	 * explicitly NOT applied to the in-core superblock. 	 * The idea is that that has already been done. 	 */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|XFS_TRANS_SB_DIRTY
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_icount_delta
operator|!=
literal|0
condition|)
block|{
name|msbp
operator|->
name|msb_field
operator|=
name|XFS_SBS_ICOUNT
expr_stmt|;
name|msbp
operator|->
name|msb_delta
operator|=
operator|(
name|int
operator|)
name|tp
operator|->
name|t_icount_delta
expr_stmt|;
name|msbp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_ifree_delta
operator|!=
literal|0
condition|)
block|{
name|msbp
operator|->
name|msb_field
operator|=
name|XFS_SBS_IFREE
expr_stmt|;
name|msbp
operator|->
name|msb_delta
operator|=
operator|(
name|int
operator|)
name|tp
operator|->
name|t_ifree_delta
expr_stmt|;
name|msbp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_fdblocks_delta
operator|!=
literal|0
condition|)
block|{
name|msbp
operator|->
name|msb_field
operator|=
name|XFS_SBS_FDBLOCKS
expr_stmt|;
name|msbp
operator|->
name|msb_delta
operator|=
operator|(
name|int
operator|)
name|tp
operator|->
name|t_fdblocks_delta
expr_stmt|;
name|msbp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_frextents_delta
operator|!=
literal|0
condition|)
block|{
name|msbp
operator|->
name|msb_field
operator|=
name|XFS_SBS_FREXTENTS
expr_stmt|;
name|msbp
operator|->
name|msb_delta
operator|=
operator|(
name|int
operator|)
name|tp
operator|->
name|t_frextents_delta
expr_stmt|;
name|msbp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_dblocks_delta
operator|!=
literal|0
condition|)
block|{
name|msbp
operator|->
name|msb_field
operator|=
name|XFS_SBS_DBLOCKS
expr_stmt|;
name|msbp
operator|->
name|msb_delta
operator|=
operator|(
name|int
operator|)
name|tp
operator|->
name|t_dblocks_delta
expr_stmt|;
name|msbp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_agcount_delta
operator|!=
literal|0
condition|)
block|{
name|msbp
operator|->
name|msb_field
operator|=
name|XFS_SBS_AGCOUNT
expr_stmt|;
name|msbp
operator|->
name|msb_delta
operator|=
operator|(
name|int
operator|)
name|tp
operator|->
name|t_agcount_delta
expr_stmt|;
name|msbp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_imaxpct_delta
operator|!=
literal|0
condition|)
block|{
name|msbp
operator|->
name|msb_field
operator|=
name|XFS_SBS_IMAX_PCT
expr_stmt|;
name|msbp
operator|->
name|msb_delta
operator|=
operator|(
name|int
operator|)
name|tp
operator|->
name|t_imaxpct_delta
expr_stmt|;
name|msbp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_rextsize_delta
operator|!=
literal|0
condition|)
block|{
name|msbp
operator|->
name|msb_field
operator|=
name|XFS_SBS_REXTSIZE
expr_stmt|;
name|msbp
operator|->
name|msb_delta
operator|=
operator|(
name|int
operator|)
name|tp
operator|->
name|t_rextsize_delta
expr_stmt|;
name|msbp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_rbmblocks_delta
operator|!=
literal|0
condition|)
block|{
name|msbp
operator|->
name|msb_field
operator|=
name|XFS_SBS_RBMBLOCKS
expr_stmt|;
name|msbp
operator|->
name|msb_delta
operator|=
operator|(
name|int
operator|)
name|tp
operator|->
name|t_rbmblocks_delta
expr_stmt|;
name|msbp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_rblocks_delta
operator|!=
literal|0
condition|)
block|{
name|msbp
operator|->
name|msb_field
operator|=
name|XFS_SBS_RBLOCKS
expr_stmt|;
name|msbp
operator|->
name|msb_delta
operator|=
operator|(
name|int
operator|)
name|tp
operator|->
name|t_rblocks_delta
expr_stmt|;
name|msbp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_rextents_delta
operator|!=
literal|0
condition|)
block|{
name|msbp
operator|->
name|msb_field
operator|=
name|XFS_SBS_REXTENTS
expr_stmt|;
name|msbp
operator|->
name|msb_delta
operator|=
operator|(
name|int
operator|)
name|tp
operator|->
name|t_rextents_delta
expr_stmt|;
name|msbp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_rextslog_delta
operator|!=
literal|0
condition|)
block|{
name|msbp
operator|->
name|msb_field
operator|=
name|XFS_SBS_REXTSLOG
expr_stmt|;
name|msbp
operator|->
name|msb_delta
operator|=
operator|(
name|int
operator|)
name|tp
operator|->
name|t_rextslog_delta
expr_stmt|;
name|msbp
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * If we need to change anything, do it. 	 */
if|if
condition|(
name|msbp
operator|>
name|msb
condition|)
block|{
name|error
operator|=
name|xfs_mod_incore_sb_batch
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|,
name|msb
argument_list|,
call|(
name|uint
call|)
argument_list|(
name|msbp
operator|-
name|msb
argument_list|)
argument_list|,
name|rsvd
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * xfs_trans_commit  *  * Commit the given transaction to the log a/synchronously.  *  * XFS disk error handling mechanism is not based on a typical  * transaction abort mechanism. Logically after the filesystem  * gets marked 'SHUTDOWN', we can't let any new transactions  * be durable - ie. committed to disk - because some metadata might  * be inconsistent. In such cases, this returns an error, and the  * caller may assume that all locked objects joined to the transaction  * have already been unlocked as if the commit had succeeded.  * Do not reference the transaction structure after this call.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|_xfs_trans_commit
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|uint
name|flags
parameter_list|,
name|xfs_lsn_t
modifier|*
name|commit_lsn_p
parameter_list|,
name|int
modifier|*
name|log_flushed
parameter_list|)
block|{
name|xfs_log_iovec_t
modifier|*
name|log_vector
decl_stmt|;
name|int
name|nvec
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_lsn_t
name|commit_lsn
decl_stmt|;
comment|/* REFERENCED */
name|int
name|error
decl_stmt|;
name|int
name|log_flags
decl_stmt|;
name|int
name|sync
decl_stmt|;
define|#
directive|define
name|XFS_TRANS_LOGVEC_COUNT
value|16
name|xfs_log_iovec_t
name|log_vector_fast
index|[
name|XFS_TRANS_LOGVEC_COUNT
index|]
decl_stmt|;
name|void
modifier|*
name|commit_iclog
decl_stmt|;
name|int
name|shutdown
decl_stmt|;
name|commit_lsn
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Determine whether this commit is releasing a permanent 	 * log reservation or not. 	 */
if|if
condition|(
name|flags
operator|&
name|XFS_TRANS_RELEASE_LOG_RES
condition|)
block|{
name|ASSERT
argument_list|(
name|tp
operator|->
name|t_flags
operator|&
name|XFS_TRANS_PERM_LOG_RES
argument_list|)
expr_stmt|;
name|log_flags
operator|=
name|XFS_LOG_REL_PERM_RESERV
expr_stmt|;
block|}
else|else
block|{
name|log_flags
operator|=
literal|0
expr_stmt|;
block|}
name|mp
operator|=
name|tp
operator|->
name|t_mountp
expr_stmt|;
comment|/* 	 * If there is nothing to be logged by the transaction, 	 * then unlock all of the items associated with the 	 * transaction and free the transaction structure. 	 * Also make sure to return any reserved blocks to 	 * the free pool. 	 */
name|shut_us_down
label|:
name|shutdown
operator|=
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|?
name|EIO
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|XFS_TRANS_DIRTY
operator|)
operator|||
name|shutdown
condition|)
block|{
name|xfs_trans_unreserve_and_mod_sb
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* 		 * It is indeed possible for the transaction to be 		 * not dirty but the dqinfo portion to be. All that 		 * means is that we have some (non-persistent) quota 		 * reservations that need to be unreserved. 		 */
name|XFS_TRANS_UNRESERVE_AND_MOD_DQUOTS
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_ticket
condition|)
block|{
name|commit_lsn
operator|=
name|xfs_log_done
argument_list|(
name|mp
argument_list|,
name|tp
operator|->
name|t_ticket
argument_list|,
name|NULL
argument_list|,
name|log_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit_lsn
operator|==
operator|-
literal|1
operator|&&
operator|!
name|shutdown
condition|)
name|shutdown
operator|=
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
block|}
name|PFLAGS_RESTORE_FSTRANS
argument_list|(
operator|&
name|tp
operator|->
name|t_pflags
argument_list|)
expr_stmt|;
name|xfs_trans_free_items
argument_list|(
name|tp
argument_list|,
name|shutdown
condition|?
name|XFS_TRANS_ABORT
else|:
literal|0
argument_list|)
expr_stmt|;
name|xfs_trans_free_busy
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|xfs_trans_free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|XFS_STATS_INC
argument_list|(
name|xs_trans_empty
argument_list|)
expr_stmt|;
if|if
condition|(
name|commit_lsn_p
condition|)
operator|*
name|commit_lsn_p
operator|=
name|commit_lsn
expr_stmt|;
return|return
operator|(
name|shutdown
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|tp
operator|->
name|t_ticket
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * If we need to update the superblock, then do it now. 	 */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|XFS_TRANS_SB_DIRTY
condition|)
block|{
name|xfs_trans_apply_sb_deltas
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|XFS_TRANS_APPLY_DQUOT_DELTAS
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* 	 * Ask each log item how many log_vector entries it will 	 * need so we can figure out how many to allocate. 	 * Try to avoid the kmem_alloc() call in the common case 	 * by using a vector from the stack when it fits. 	 */
name|nvec
operator|=
name|xfs_trans_count_vecs
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvec
operator|==
literal|0
condition|)
block|{
name|xfs_force_shutdown
argument_list|(
name|mp
argument_list|,
name|XFS_LOG_IO_ERROR
argument_list|)
expr_stmt|;
goto|goto
name|shut_us_down
goto|;
block|}
elseif|else
if|if
condition|(
name|nvec
operator|<=
name|XFS_TRANS_LOGVEC_COUNT
condition|)
block|{
name|log_vector
operator|=
name|log_vector_fast
expr_stmt|;
block|}
else|else
block|{
name|log_vector
operator|=
operator|(
name|xfs_log_iovec_t
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|nvec
operator|*
sizeof|sizeof
argument_list|(
name|xfs_log_iovec_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fill in the log_vector and pin the logged items, and 	 * then write the transaction to the log. 	 */
name|xfs_trans_fill_vecs
argument_list|(
name|tp
argument_list|,
name|log_vector
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_log_write
argument_list|(
name|mp
argument_list|,
name|log_vector
argument_list|,
name|nvec
argument_list|,
name|tp
operator|->
name|t_ticket
argument_list|,
operator|&
operator|(
name|tp
operator|->
name|t_lsn
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * The transaction is committed incore here, and can go out to disk 	 * at any time after this call.  However, all the items associated 	 * with the transaction are still locked and pinned in memory. 	 */
name|commit_lsn
operator|=
name|xfs_log_done
argument_list|(
name|mp
argument_list|,
name|tp
operator|->
name|t_ticket
argument_list|,
operator|&
name|commit_iclog
argument_list|,
name|log_flags
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_commit_lsn
operator|=
name|commit_lsn
expr_stmt|;
if|if
condition|(
name|nvec
operator|>
name|XFS_TRANS_LOGVEC_COUNT
condition|)
block|{
name|kmem_free
argument_list|(
name|log_vector
argument_list|,
name|nvec
operator|*
sizeof|sizeof
argument_list|(
name|xfs_log_iovec_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|commit_lsn_p
condition|)
operator|*
name|commit_lsn_p
operator|=
name|commit_lsn
expr_stmt|;
comment|/* 	 * If we got a log write error. Unpin the logitems that we 	 * had pinned, clean up, free trans structure, and return error. 	 */
if|if
condition|(
name|error
operator|||
name|commit_lsn
operator|==
operator|-
literal|1
condition|)
block|{
name|PFLAGS_RESTORE_FSTRANS
argument_list|(
operator|&
name|tp
operator|->
name|t_pflags
argument_list|)
expr_stmt|;
name|xfs_trans_uncommit
argument_list|(
name|tp
argument_list|,
name|flags
operator||
name|XFS_TRANS_ABORT
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
comment|/* 	 * Once the transaction has committed, unused 	 * reservations need to be released and changes to 	 * the superblock need to be reflected in the in-core 	 * version.  Do that now. 	 */
name|xfs_trans_unreserve_and_mod_sb
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|sync
operator|=
name|tp
operator|->
name|t_flags
operator|&
name|XFS_TRANS_SYNC
expr_stmt|;
comment|/* 	 * Tell the LM to call the transaction completion routine 	 * when the log write with LSN commit_lsn completes (e.g. 	 * when the transaction commit really hits the on-disk log). 	 * After this call we cannot reference tp, because the call 	 * can happen at any time and the call will free the transaction 	 * structure pointed to by tp.  The only case where we call 	 * the completion routine (xfs_trans_committed) directly is 	 * if the log is turned off on a debug kernel or we're 	 * running in simulation mode (the log is explicitly turned 	 * off). 	 */
name|tp
operator|->
name|t_logcb
operator|.
name|cb_func
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|int
argument_list|)
operator|)
name|xfs_trans_committed
expr_stmt|;
name|tp
operator|->
name|t_logcb
operator|.
name|cb_arg
operator|=
name|tp
expr_stmt|;
comment|/* 	 * We need to pass the iclog buffer which was used for the 	 * transaction commit record into this function, and attach 	 * the callback to it. The callback must be attached before 	 * the items are unlocked to avoid racing with other threads 	 * waiting for an item to unlock. 	 */
name|shutdown
operator|=
name|xfs_log_notify
argument_list|(
name|mp
argument_list|,
name|commit_iclog
argument_list|,
operator|&
operator|(
name|tp
operator|->
name|t_logcb
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Mark this thread as no longer being in a transaction 	 */
name|PFLAGS_RESTORE_FSTRANS
argument_list|(
operator|&
name|tp
operator|->
name|t_pflags
argument_list|)
expr_stmt|;
comment|/* 	 * Once all the items of the transaction have been copied 	 * to the in core log and the callback is attached, the 	 * items can be unlocked. 	 * 	 * This will free descriptors pointing to items which were 	 * not logged since there is nothing more to do with them. 	 * For items which were logged, we will keep pointers to them 	 * so they can be unpinned after the transaction commits to disk. 	 * This will also stamp each modified meta-data item with 	 * the commit lsn of this transaction for dependency tracking 	 * purposes. 	 */
name|xfs_trans_unlock_items
argument_list|(
name|tp
argument_list|,
name|commit_lsn
argument_list|)
expr_stmt|;
comment|/* 	 * If we detected a log error earlier, finish committing 	 * the transaction now (unpin log items, etc). 	 * 	 * Order is critical here, to avoid using the transaction 	 * pointer after its been freed (by xfs_trans_committed 	 * either here now, or as a callback).  We cannot do this 	 * step inside xfs_log_notify as was done earlier because 	 * of this issue. 	 */
if|if
condition|(
name|shutdown
condition|)
name|xfs_trans_committed
argument_list|(
name|tp
argument_list|,
name|XFS_LI_ABORTED
argument_list|)
expr_stmt|;
comment|/* 	 * Now that the xfs_trans_committed callback has been attached, 	 * and the items are released we can finally allow the iclog to 	 * go to disk. 	 */
name|error
operator|=
name|xfs_log_release_iclog
argument_list|(
name|mp
argument_list|,
name|commit_iclog
argument_list|)
expr_stmt|;
comment|/* 	 * If the transaction needs to be synchronous, then force the 	 * log out now and wait for it. 	 */
if|if
condition|(
name|sync
condition|)
block|{
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|_xfs_log_force
argument_list|(
name|mp
argument_list|,
name|commit_lsn
argument_list|,
name|XFS_LOG_FORCE
operator||
name|XFS_LOG_SYNC
argument_list|,
name|log_flushed
argument_list|)
expr_stmt|;
block|}
name|XFS_STATS_INC
argument_list|(
name|xs_trans_sync
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XFS_STATS_INC
argument_list|(
name|xs_trans_async
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Total up the number of log iovecs needed to commit this  * transaction.  The transaction itself needs one for the  * transaction header.  Ask each dirty item in turn how many  * it needs to get the total.  */
end_comment

begin_function
name|STATIC
name|uint
name|xfs_trans_count_vecs
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|)
block|{
name|int
name|nvecs
decl_stmt|;
name|xfs_log_item_desc_t
modifier|*
name|lidp
decl_stmt|;
name|nvecs
operator|=
literal|1
expr_stmt|;
name|lidp
operator|=
name|xfs_trans_first_item
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lidp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* In the non-debug case we need to start bailing out if we 	 * didn't find a log_item here, return zero and let trans_commit 	 * deal with it. 	 */
if|if
condition|(
name|lidp
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|lidp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Skip items which aren't dirty in this transaction. 		 */
if|if
condition|(
operator|!
operator|(
name|lidp
operator|->
name|lid_flags
operator|&
name|XFS_LID_DIRTY
operator|)
condition|)
block|{
name|lidp
operator|=
name|xfs_trans_next_item
argument_list|(
name|tp
argument_list|,
name|lidp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|lidp
operator|->
name|lid_size
operator|=
name|IOP_SIZE
argument_list|(
name|lidp
operator|->
name|lid_item
argument_list|)
expr_stmt|;
name|nvecs
operator|+=
name|lidp
operator|->
name|lid_size
expr_stmt|;
name|lidp
operator|=
name|xfs_trans_next_item
argument_list|(
name|tp
argument_list|,
name|lidp
argument_list|)
expr_stmt|;
block|}
return|return
name|nvecs
return|;
block|}
end_function

begin_comment
comment|/*  * Called from the trans_commit code when we notice that  * the filesystem is in the middle of a forced shutdown.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_trans_uncommit
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|uint
name|flags
parameter_list|)
block|{
name|xfs_log_item_desc_t
modifier|*
name|lidp
decl_stmt|;
for|for
control|(
name|lidp
operator|=
name|xfs_trans_first_item
argument_list|(
name|tp
argument_list|)
init|;
name|lidp
operator|!=
name|NULL
condition|;
name|lidp
operator|=
name|xfs_trans_next_item
argument_list|(
name|tp
argument_list|,
name|lidp
argument_list|)
control|)
block|{
comment|/* 		 * Unpin all but those that aren't dirty. 		 */
if|if
condition|(
name|lidp
operator|->
name|lid_flags
operator|&
name|XFS_LID_DIRTY
condition|)
name|IOP_UNPIN_REMOVE
argument_list|(
name|lidp
operator|->
name|lid_item
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
name|xfs_trans_unreserve_and_mod_sb
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|XFS_TRANS_UNRESERVE_AND_MOD_DQUOTS
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|xfs_trans_free_items
argument_list|(
name|tp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|xfs_trans_free_busy
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|xfs_trans_free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fill in the vector with pointers to data to be logged  * by this transaction.  The transaction header takes  * the first vector, and then each dirty item takes the  * number of vectors it indicated it needed in xfs_trans_count_vecs().  *  * As each item fills in the entries it needs, also pin the item  * so that it cannot be flushed out until the log write completes.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_trans_fill_vecs
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|xfs_log_iovec_t
modifier|*
name|log_vector
parameter_list|)
block|{
name|xfs_log_item_desc_t
modifier|*
name|lidp
decl_stmt|;
name|xfs_log_iovec_t
modifier|*
name|vecp
decl_stmt|;
name|uint
name|nitems
decl_stmt|;
comment|/* 	 * Skip over the entry for the transaction header, we'll 	 * fill that in at the end. 	 */
name|vecp
operator|=
name|log_vector
operator|+
literal|1
expr_stmt|;
comment|/* pointer arithmetic */
name|nitems
operator|=
literal|0
expr_stmt|;
name|lidp
operator|=
name|xfs_trans_first_item
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lidp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|lidp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Skip items which aren't dirty in this transaction. 		 */
if|if
condition|(
operator|!
operator|(
name|lidp
operator|->
name|lid_flags
operator|&
name|XFS_LID_DIRTY
operator|)
condition|)
block|{
name|lidp
operator|=
name|xfs_trans_next_item
argument_list|(
name|tp
argument_list|,
name|lidp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * The item may be marked dirty but not log anything. 		 * This can be used to get called when a transaction 		 * is committed. 		 */
if|if
condition|(
name|lidp
operator|->
name|lid_size
condition|)
block|{
name|nitems
operator|++
expr_stmt|;
block|}
name|IOP_FORMAT
argument_list|(
name|lidp
operator|->
name|lid_item
argument_list|,
name|vecp
argument_list|)
expr_stmt|;
name|vecp
operator|+=
name|lidp
operator|->
name|lid_size
expr_stmt|;
comment|/* pointer arithmetic */
name|IOP_PIN
argument_list|(
name|lidp
operator|->
name|lid_item
argument_list|)
expr_stmt|;
name|lidp
operator|=
name|xfs_trans_next_item
argument_list|(
name|tp
argument_list|,
name|lidp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now that we've counted the number of items in this 	 * transaction, fill in the transaction header. 	 */
name|tp
operator|->
name|t_header
operator|.
name|th_magic
operator|=
name|XFS_TRANS_HEADER_MAGIC
expr_stmt|;
name|tp
operator|->
name|t_header
operator|.
name|th_type
operator|=
name|tp
operator|->
name|t_type
expr_stmt|;
name|tp
operator|->
name|t_header
operator|.
name|th_num_items
operator|=
name|nitems
expr_stmt|;
name|log_vector
operator|->
name|i_addr
operator|=
operator|(
name|xfs_caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_header
expr_stmt|;
name|log_vector
operator|->
name|i_len
operator|=
sizeof|sizeof
argument_list|(
name|xfs_trans_header_t
argument_list|)
expr_stmt|;
name|XLOG_VEC_SET_TYPE
argument_list|(
name|log_vector
argument_list|,
name|XLOG_REG_TYPE_TRANSHDR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unlock all of the transaction's items and free the transaction.  * The transaction must not have modified any of its items, because  * there is no way to restore them to their previous state.  *  * If the transaction has made a log reservation, make sure to release  * it as well.  */
end_comment

begin_function
name|void
name|xfs_trans_cancel
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|log_flags
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|xfs_log_item_chunk_t
modifier|*
name|licp
decl_stmt|;
name|xfs_log_item_desc_t
modifier|*
name|lidp
decl_stmt|;
name|xfs_log_item_t
modifier|*
name|lip
decl_stmt|;
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|xfs_mount_t
modifier|*
name|mp
init|=
name|tp
operator|->
name|t_mountp
decl_stmt|;
comment|/* 	 * See if the caller is being too lazy to figure out if 	 * the transaction really needs an abort. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|XFS_TRANS_ABORT
operator|)
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|XFS_TRANS_DIRTY
operator|)
condition|)
name|flags
operator|&=
operator|~
name|XFS_TRANS_ABORT
expr_stmt|;
comment|/* 	 * See if the caller is relying on us to shut down the 	 * filesystem.  This happens in paths where we detect 	 * corruption and decide to give up. 	 */
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|XFS_TRANS_DIRTY
operator|)
operator|&&
operator|!
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|XFS_ERROR_REPORT
argument_list|(
literal|"xfs_trans_cancel"
argument_list|,
name|XFS_ERRLEVEL_LOW
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|xfs_force_shutdown
argument_list|(
name|mp
argument_list|,
name|XFS_CORRUPT_INCORE
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|XFS_TRANS_ABORT
operator|)
condition|)
block|{
name|licp
operator|=
operator|&
operator|(
name|tp
operator|->
name|t_items
operator|)
expr_stmt|;
while|while
condition|(
name|licp
operator|!=
name|NULL
condition|)
block|{
name|lidp
operator|=
name|licp
operator|->
name|lic_descs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|licp
operator|->
name|lic_unused
condition|;
name|i
operator|++
operator|,
name|lidp
operator|++
control|)
block|{
if|if
condition|(
name|XFS_LIC_ISFREE
argument_list|(
name|licp
argument_list|,
name|i
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|lip
operator|=
name|lidp
operator|->
name|lid_item
expr_stmt|;
if|if
condition|(
operator|!
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
name|ASSERT
argument_list|(
operator|!
operator|(
name|lip
operator|->
name|li_type
operator|==
name|XFS_LI_EFD
operator|)
argument_list|)
expr_stmt|;
block|}
name|licp
operator|=
name|licp
operator|->
name|lic_next
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|xfs_trans_unreserve_and_mod_sb
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|XFS_TRANS_UNRESERVE_AND_MOD_DQUOTS
argument_list|(
name|mp
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_ticket
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|XFS_TRANS_RELEASE_LOG_RES
condition|)
block|{
name|ASSERT
argument_list|(
name|tp
operator|->
name|t_flags
operator|&
name|XFS_TRANS_PERM_LOG_RES
argument_list|)
expr_stmt|;
name|log_flags
operator|=
name|XFS_LOG_REL_PERM_RESERV
expr_stmt|;
block|}
else|else
block|{
name|log_flags
operator|=
literal|0
expr_stmt|;
block|}
name|xfs_log_done
argument_list|(
name|mp
argument_list|,
name|tp
operator|->
name|t_ticket
argument_list|,
name|NULL
argument_list|,
name|log_flags
argument_list|)
expr_stmt|;
block|}
comment|/* mark this thread as no longer being in a transaction */
name|PFLAGS_RESTORE_FSTRANS
argument_list|(
operator|&
name|tp
operator|->
name|t_pflags
argument_list|)
expr_stmt|;
name|xfs_trans_free_items
argument_list|(
name|tp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|xfs_trans_free_busy
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|xfs_trans_free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free the transaction structure.  If there is more clean up  * to do when the structure is freed, add it here.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_trans_free
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|)
block|{
name|atomic_dec
argument_list|(
operator|&
name|tp
operator|->
name|t_mountp
operator|->
name|m_active_trans
argument_list|)
expr_stmt|;
name|XFS_TRANS_FREE_DQINFO
argument_list|(
name|tp
operator|->
name|t_mountp
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|kmem_zone_free
argument_list|(
name|xfs_trans_zone
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * THIS SHOULD BE REWRITTEN TO USE xfs_trans_next_item().  *  * This is typically called by the LM when a transaction has been fully  * committed to disk.  It needs to unpin the items which have  * been logged by the transaction and update their positions  * in the AIL if necessary.  * This also gets called when the transactions didn't get written out  * because of an I/O error. Abortflag& XFS_LI_ABORTED is set then.  *  * Call xfs_trans_chunk_committed() to process the items in  * each chunk.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_trans_committed
parameter_list|(
name|xfs_trans_t
modifier|*
name|tp
parameter_list|,
name|int
name|abortflag
parameter_list|)
block|{
name|xfs_log_item_chunk_t
modifier|*
name|licp
decl_stmt|;
name|xfs_log_item_chunk_t
modifier|*
name|next_licp
decl_stmt|;
name|xfs_log_busy_chunk_t
modifier|*
name|lbcp
decl_stmt|;
name|xfs_log_busy_slot_t
modifier|*
name|lbsp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Call the transaction's completion callback if there 	 * is one. 	 */
if|if
condition|(
name|tp
operator|->
name|t_callback
operator|!=
name|NULL
condition|)
block|{
name|tp
operator|->
name|t_callback
argument_list|(
name|tp
argument_list|,
name|tp
operator|->
name|t_callarg
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Special case the chunk embedded in the transaction. 	 */
name|licp
operator|=
operator|&
operator|(
name|tp
operator|->
name|t_items
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|XFS_LIC_ARE_ALL_FREE
argument_list|(
name|licp
argument_list|)
operator|)
condition|)
block|{
name|xfs_trans_chunk_committed
argument_list|(
name|licp
argument_list|,
name|tp
operator|->
name|t_lsn
argument_list|,
name|abortflag
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Process the items in each chunk in turn. 	 */
name|licp
operator|=
name|licp
operator|->
name|lic_next
expr_stmt|;
while|while
condition|(
name|licp
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|XFS_LIC_ARE_ALL_FREE
argument_list|(
name|licp
argument_list|)
argument_list|)
expr_stmt|;
name|xfs_trans_chunk_committed
argument_list|(
name|licp
argument_list|,
name|tp
operator|->
name|t_lsn
argument_list|,
name|abortflag
argument_list|)
expr_stmt|;
name|next_licp
operator|=
name|licp
operator|->
name|lic_next
expr_stmt|;
name|kmem_free
argument_list|(
name|licp
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_log_item_chunk_t
argument_list|)
argument_list|)
expr_stmt|;
name|licp
operator|=
name|next_licp
expr_stmt|;
block|}
comment|/* 	 * Clear all the per-AG busy list items listed in this transaction 	 */
name|lbcp
operator|=
operator|&
name|tp
operator|->
name|t_busy
expr_stmt|;
while|while
condition|(
name|lbcp
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|lbsp
operator|=
name|lbcp
operator|->
name|lbc_busy
init|;
name|i
operator|<
name|lbcp
operator|->
name|lbc_unused
condition|;
name|i
operator|++
operator|,
name|lbsp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|XFS_LBC_ISFREE
argument_list|(
name|lbcp
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|xfs_alloc_clear_busy
argument_list|(
name|tp
argument_list|,
name|lbsp
operator|->
name|lbc_ag
argument_list|,
name|lbsp
operator|->
name|lbc_idx
argument_list|)
expr_stmt|;
block|}
block|}
name|lbcp
operator|=
name|lbcp
operator|->
name|lbc_next
expr_stmt|;
block|}
name|xfs_trans_free_busy
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* 	 * That's it for the transaction structure.  Free it. 	 */
name|xfs_trans_free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called to perform the commit processing for each  * item described by the given chunk.  *  * The commit processing consists of unlocking items which were  * held locked with the SYNC_UNLOCK attribute, calling the committed  * routine of each logged item, updating the item's position in the AIL  * if necessary, and unpinning each item.  If the committed routine  * returns -1, then do nothing further with the item because it  * may have been freed.  *  * Since items are unlocked when they are copied to the incore  * log, it is possible for two transactions to be completing  * and manipulating the same item simultaneously.  The AIL lock  * will protect the lsn field of each item.  The value of this  * field can never go backwards.  *  * We unpin the items after repositioning them in the AIL, because  * otherwise they could be immediately flushed and we'd have to race  * with the flusher trying to pull the item from the AIL as we add it.  */
end_comment

begin_function
name|STATIC
name|void
name|xfs_trans_chunk_committed
parameter_list|(
name|xfs_log_item_chunk_t
modifier|*
name|licp
parameter_list|,
name|xfs_lsn_t
name|lsn
parameter_list|,
name|int
name|aborted
parameter_list|)
block|{
name|xfs_log_item_desc_t
modifier|*
name|lidp
decl_stmt|;
name|xfs_log_item_t
modifier|*
name|lip
decl_stmt|;
name|xfs_lsn_t
name|item_lsn
decl_stmt|;
name|struct
name|xfs_mount
modifier|*
name|mp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SPLDECL
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|lidp
operator|=
name|licp
operator|->
name|lic_descs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|licp
operator|->
name|lic_unused
condition|;
name|i
operator|++
operator|,
name|lidp
operator|++
control|)
block|{
if|if
condition|(
name|XFS_LIC_ISFREE
argument_list|(
name|licp
argument_list|,
name|i
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|lip
operator|=
name|lidp
operator|->
name|lid_item
expr_stmt|;
if|if
condition|(
name|aborted
condition|)
name|lip
operator|->
name|li_flags
operator||=
name|XFS_LI_ABORTED
expr_stmt|;
comment|/* 		 * Send in the ABORTED flag to the COMMITTED routine 		 * so that it knows whether the transaction was aborted 		 * or not. 		 */
name|item_lsn
operator|=
name|IOP_COMMITTED
argument_list|(
name|lip
argument_list|,
name|lsn
argument_list|)
expr_stmt|;
comment|/* 		 * If the committed routine returns -1, make 		 * no more references to the item. 		 */
if|if
condition|(
name|XFS_LSN_CMP
argument_list|(
name|item_lsn
argument_list|,
operator|(
name|xfs_lsn_t
operator|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* 		 * If the returned lsn is greater than what it 		 * contained before, update the location of the 		 * item in the AIL.  If it is not, then do nothing. 		 * Items can never move backwards in the AIL. 		 * 		 * While the new lsn should usually be greater, it 		 * is possible that a later transaction completing 		 * simultaneously with an earlier one using the 		 * same item could complete first with a higher lsn. 		 * This would cause the earlier transaction to fail 		 * the test below. 		 */
name|mp
operator|=
name|lip
operator|->
name|li_mountp
expr_stmt|;
name|AIL_LOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_LSN_CMP
argument_list|(
name|item_lsn
argument_list|,
name|lip
operator|->
name|li_lsn
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* 			 * This will set the item's lsn to item_lsn 			 * and update the position of the item in 			 * the AIL. 			 * 			 * xfs_trans_update_ail() drops the AIL lock. 			 */
name|xfs_trans_update_ail
argument_list|(
name|mp
argument_list|,
name|lip
argument_list|,
name|item_lsn
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|AIL_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Now that we've repositioned the item in the AIL, 		 * unpin it so it can be flushed. Pass information 		 * about buffer stale state down from the log item 		 * flags, if anyone else stales the buffer we do not 		 * want to pay any attention to it. 		 */
name|IOP_UNPIN
argument_list|(
name|lip
argument_list|,
name|lidp
operator|->
name|lid_flags
operator|&
name|XFS_LID_BUF_STALE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

