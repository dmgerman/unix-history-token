begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2000-2005 Silicon Graphics, Inc.  * All Rights Reserved.  *  * This program is free software; you can redistribute it and/or  * modify it under the terms of the GNU General Public License as  * published by the Free Software Foundation.  *  * This program is distributed in the hope that it would be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write the Free Software Foundation,  * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA  */
end_comment

begin_include
include|#
directive|include
file|"xfs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fs.h"
end_include

begin_include
include|#
directive|include
file|"xfs_types.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bit.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inum.h"
end_include

begin_include
include|#
directive|include
file|"xfs_trans.h"
end_include

begin_include
include|#
directive|include
file|"xfs_sb.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ag.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dmapi.h"
end_include

begin_include
include|#
directive|include
file|"xfs_mount.h"
end_include

begin_include
include|#
directive|include
file|"xfs_da_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr_sf.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dinode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode.h"
end_include

begin_include
include|#
directive|include
file|"xfs_inode_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_btree.h"
end_include

begin_include
include|#
directive|include
file|"xfs_alloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_ialloc.h"
end_include

begin_include
include|#
directive|include
file|"xfs_quota.h"
end_include

begin_include
include|#
directive|include
file|"xfs_error.h"
end_include

begin_include
include|#
directive|include
file|"xfs_bmap.h"
end_include

begin_include
include|#
directive|include
file|"xfs_rw.h"
end_include

begin_include
include|#
directive|include
file|"xfs_refcache.h"
end_include

begin_include
include|#
directive|include
file|"xfs_buf_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_log_priv.h"
end_include

begin_include
include|#
directive|include
file|"xfs_dir2_trace.h"
end_include

begin_include
include|#
directive|include
file|"xfs_extfree_item.h"
end_include

begin_include
include|#
directive|include
file|"xfs_acl.h"
end_include

begin_include
include|#
directive|include
file|"xfs_attr.h"
end_include

begin_include
include|#
directive|include
file|"xfs_clnt.h"
end_include

begin_include
include|#
directive|include
file|"xfs_fsops.h"
end_include

begin_include
include|#
directive|include
file|"xfs_vnode.h"
end_include

begin_function_decl
name|STATIC
name|int
name|xfs_sync
parameter_list|(
name|bhv_desc_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|cred_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|kmem_zone_t
modifier|*
name|xfs_bmap_free_item_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|kmem_zone_t
modifier|*
name|xfs_btree_cur_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|kmem_zone_t
modifier|*
name|xfs_trans_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|kmem_zone_t
modifier|*
name|xfs_dabuf_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|kmem_zone_t
modifier|*
name|xfs_buf_item_zone
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|XFS_DABUF_DEBUG
end_ifdef

begin_decl_stmt
specifier|extern
name|lock_t
name|xfs_dabuf_global_lock
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|xfs_init
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
literal|0
block|extern kmem_zone_t	*xfs_bmap_free_item_zone; 	extern kmem_zone_t	*xfs_btree_cur_zone; 	extern kmem_zone_t	*xfs_trans_zone; 	extern kmem_zone_t	*xfs_buf_item_zone; 	extern kmem_zone_t	*xfs_dabuf_zone;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XFS_DABUF_DEBUG
name|spinlock_init
argument_list|(
operator|&
name|xfs_dabuf_global_lock
argument_list|,
literal|"xfsda"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Initialize all of the zone allocators we use. 	 */
name|xfs_bmap_free_item_zone
operator|=
name|kmem_zone_init
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_bmap_free_item_t
argument_list|)
argument_list|,
literal|"xfs_bmap_free_item"
argument_list|)
expr_stmt|;
name|xfs_btree_cur_zone
operator|=
name|kmem_zone_init
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_btree_cur_t
argument_list|)
argument_list|,
literal|"xfs_btree_cur"
argument_list|)
expr_stmt|;
name|xfs_trans_zone
operator|=
name|kmem_zone_init
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_trans_t
argument_list|)
argument_list|,
literal|"xfs_trans"
argument_list|)
expr_stmt|;
name|xfs_da_state_zone
operator|=
name|kmem_zone_init
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_da_state_t
argument_list|)
argument_list|,
literal|"xfs_da_state"
argument_list|)
expr_stmt|;
name|xfs_dabuf_zone
operator|=
name|kmem_zone_init
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_dabuf_t
argument_list|)
argument_list|,
literal|"xfs_dabuf"
argument_list|)
expr_stmt|;
name|xfs_ifork_zone
operator|=
name|kmem_zone_init
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_ifork_t
argument_list|)
argument_list|,
literal|"xfs_ifork"
argument_list|)
expr_stmt|;
name|xfs_acl_zone_init
argument_list|(
name|xfs_acl_zone
argument_list|,
literal|"xfs_acl"
argument_list|)
expr_stmt|;
comment|/* 	 * The size of the zone allocated buf log item is the maximum 	 * size possible under XFS.  This wastes a little bit of memory, 	 * but it is much faster. 	 */
name|xfs_buf_item_zone
operator|=
name|kmem_zone_init
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|xfs_buf_log_item_t
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|XFS_MAX_BLOCKSIZE
operator|/
name|XFS_BLI_CHUNK
operator|)
operator|/
name|NBWORD
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|)
argument_list|,
literal|"xfs_buf_item"
argument_list|)
expr_stmt|;
name|xfs_efd_zone
operator|=
name|kmem_zone_init
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|xfs_efd_log_item_t
argument_list|)
operator|+
operator|(
operator|(
name|XFS_EFD_MAX_FAST_EXTENTS
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_extent_t
argument_list|)
operator|)
operator|)
argument_list|,
literal|"xfs_efd_item"
argument_list|)
expr_stmt|;
name|xfs_efi_zone
operator|=
name|kmem_zone_init
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|xfs_efi_log_item_t
argument_list|)
operator|+
operator|(
operator|(
name|XFS_EFI_MAX_FAST_EXTENTS
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|xfs_extent_t
argument_list|)
operator|)
operator|)
argument_list|,
literal|"xfs_efi_item"
argument_list|)
expr_stmt|;
comment|/* 	 * These zones warrant special memory allocator hints 	 */
name|xfs_inode_zone
operator|=
name|kmem_zone_init_flags
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_inode_t
argument_list|)
argument_list|,
literal|"xfs_inode"
argument_list|,
name|KM_ZONE_HWALIGN
operator||
name|KM_ZONE_RECLAIM
operator||
name|KM_ZONE_SPREAD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfs_ili_zone
operator|=
name|kmem_zone_init_flags
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_inode_log_item_t
argument_list|)
argument_list|,
literal|"xfs_ili"
argument_list|,
name|KM_ZONE_SPREAD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfs_chashlist_zone
operator|=
name|kmem_zone_init_flags
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_chashlist_t
argument_list|)
argument_list|,
literal|"xfs_chashlist"
argument_list|,
name|KM_ZONE_SPREAD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate global trace buffers. 	 */
ifdef|#
directive|ifdef
name|XFS_ALLOC_TRACE
name|xfs_alloc_trace_buf
operator|=
name|ktrace_alloc
argument_list|(
name|XFS_ALLOC_TRACE_SIZE
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XFS_BMAP_TRACE
name|xfs_bmap_trace_buf
operator|=
name|ktrace_alloc
argument_list|(
name|XFS_BMAP_TRACE_SIZE
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XFS_BMBT_TRACE
name|xfs_bmbt_trace_buf
operator|=
name|ktrace_alloc
argument_list|(
name|XFS_BMBT_TRACE_SIZE
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XFS_DIR_TRACE
name|xfs_dir_trace_buf
operator|=
name|ktrace_alloc
argument_list|(
name|XFS_DIR_TRACE_SIZE
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XFS_ATTR_TRACE
name|xfs_attr_trace_buf
operator|=
name|ktrace_alloc
argument_list|(
name|XFS_ATTR_TRACE_SIZE
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XFS_DIR2_TRACE
name|xfs_dir2_trace_buf
operator|=
name|ktrace_alloc
argument_list|(
name|XFS_DIR2_GTRACE_SIZE
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xfs_dir_startup
argument_list|()
expr_stmt|;
if|#
directive|if
operator|(
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|INDUCE_IO_ERROR
argument_list|)
operator|)
name|xfs_error_test_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG || INDUCE_IO_ERROR */
name|xfs_refcache_init
argument_list|()
expr_stmt|;
name|xfs_init_procfs
argument_list|()
expr_stmt|;
name|xfs_sysctl_register
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|xfs_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
literal|0
block|extern kmem_zone_t	*xfs_bmap_free_item_zone; 	extern kmem_zone_t	*xfs_btree_cur_zone; 	extern kmem_zone_t	*xfs_inode_zone; 	extern kmem_zone_t	*xfs_trans_zone; 	extern kmem_zone_t	*xfs_da_state_zone; 	extern kmem_zone_t	*xfs_dabuf_zone; 	extern kmem_zone_t	*xfs_efd_zone; 	extern kmem_zone_t	*xfs_efi_zone; 	extern kmem_zone_t	*xfs_buf_item_zone; 	extern kmem_zone_t	*xfs_chashlist_zone;
endif|#
directive|endif
name|xfs_cleanup_procfs
argument_list|()
expr_stmt|;
name|xfs_sysctl_unregister
argument_list|()
expr_stmt|;
name|xfs_refcache_destroy
argument_list|()
expr_stmt|;
name|xfs_acl_zone_destroy
argument_list|(
name|xfs_acl_zone
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|XFS_DIR2_TRACE
name|ktrace_free
argument_list|(
name|xfs_dir2_trace_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XFS_ATTR_TRACE
name|ktrace_free
argument_list|(
name|xfs_attr_trace_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XFS_DIR_TRACE
name|ktrace_free
argument_list|(
name|xfs_dir_trace_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XFS_BMBT_TRACE
name|ktrace_free
argument_list|(
name|xfs_bmbt_trace_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XFS_BMAP_TRACE
name|ktrace_free
argument_list|(
name|xfs_bmap_trace_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|XFS_ALLOC_TRACE
name|ktrace_free
argument_list|(
name|xfs_alloc_trace_buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kmem_zone_destroy
argument_list|(
name|xfs_bmap_free_item_zone
argument_list|)
expr_stmt|;
name|kmem_zone_destroy
argument_list|(
name|xfs_btree_cur_zone
argument_list|)
expr_stmt|;
name|kmem_zone_destroy
argument_list|(
name|xfs_inode_zone
argument_list|)
expr_stmt|;
name|kmem_zone_destroy
argument_list|(
name|xfs_trans_zone
argument_list|)
expr_stmt|;
name|kmem_zone_destroy
argument_list|(
name|xfs_da_state_zone
argument_list|)
expr_stmt|;
name|kmem_zone_destroy
argument_list|(
name|xfs_dabuf_zone
argument_list|)
expr_stmt|;
name|kmem_zone_destroy
argument_list|(
name|xfs_buf_item_zone
argument_list|)
expr_stmt|;
name|kmem_zone_destroy
argument_list|(
name|xfs_efd_zone
argument_list|)
expr_stmt|;
name|kmem_zone_destroy
argument_list|(
name|xfs_efi_zone
argument_list|)
expr_stmt|;
name|kmem_zone_destroy
argument_list|(
name|xfs_ifork_zone
argument_list|)
expr_stmt|;
name|kmem_zone_destroy
argument_list|(
name|xfs_ili_zone
argument_list|)
expr_stmt|;
name|kmem_zone_destroy
argument_list|(
name|xfs_chashlist_zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * xfs_start_flags  *  * This function fills in xfs_mount_t fields based on mount args.  * Note: the superblock has _not_ yet been read in.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_start_flags
parameter_list|(
name|struct
name|xfs_vfs
modifier|*
name|vfs
parameter_list|,
name|struct
name|xfs_mount_args
modifier|*
name|ap
parameter_list|,
name|struct
name|xfs_mount
modifier|*
name|mp
parameter_list|)
block|{
comment|/* Values are in BBs */
if|if
condition|(
operator|(
name|ap
operator|->
name|flags
operator|&
name|XFSMNT_NOALIGN
operator|)
operator|!=
name|XFSMNT_NOALIGN
condition|)
block|{
comment|/* 		 * At this point the superblock has not been read 		 * in, therefore we do not know the block size. 		 * Before the mount call ends we will convert 		 * these to FSBs. 		 */
name|mp
operator|->
name|m_dalign
operator|=
name|ap
operator|->
name|sunit
expr_stmt|;
name|mp
operator|->
name|m_swidth
operator|=
name|ap
operator|->
name|swidth
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|logbufs
operator|!=
operator|-
literal|1
operator|&&
name|ap
operator|->
name|logbufs
operator|!=
literal|0
operator|&&
operator|(
name|ap
operator|->
name|logbufs
operator|<
name|XLOG_MIN_ICLOGS
operator|||
name|ap
operator|->
name|logbufs
operator|>
name|XLOG_MAX_ICLOGS
operator|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: invalid logbufs value: %d [not %d-%d]"
argument_list|,
name|ap
operator|->
name|logbufs
argument_list|,
name|XLOG_MIN_ICLOGS
argument_list|,
name|XLOG_MAX_ICLOGS
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|mp
operator|->
name|m_logbufs
operator|=
name|ap
operator|->
name|logbufs
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|logbufsize
operator|!=
operator|-
literal|1
operator|&&
name|ap
operator|->
name|logbufsize
operator|!=
literal|0
operator|&&
name|ap
operator|->
name|logbufsize
operator|!=
literal|16
operator|*
literal|1024
operator|&&
name|ap
operator|->
name|logbufsize
operator|!=
literal|32
operator|*
literal|1024
operator|&&
name|ap
operator|->
name|logbufsize
operator|!=
literal|64
operator|*
literal|1024
operator|&&
name|ap
operator|->
name|logbufsize
operator|!=
literal|128
operator|*
literal|1024
operator|&&
name|ap
operator|->
name|logbufsize
operator|!=
literal|256
operator|*
literal|1024
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: invalid logbufsize: %d [not 16k,32k,64k,128k or 256k]"
argument_list|,
name|ap
operator|->
name|logbufsize
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|mp
operator|->
name|m_ihsize
operator|=
name|ap
operator|->
name|ihashsize
expr_stmt|;
name|mp
operator|->
name|m_logbsize
operator|=
name|ap
operator|->
name|logbufsize
expr_stmt|;
name|mp
operator|->
name|m_fsname_len
operator|=
name|strlen
argument_list|(
name|ap
operator|->
name|fsname
argument_list|)
operator|+
literal|1
expr_stmt|;
name|mp
operator|->
name|m_fsname
operator|=
name|kmem_alloc
argument_list|(
name|mp
operator|->
name|m_fsname_len
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mp
operator|->
name|m_fsname
argument_list|,
name|ap
operator|->
name|fsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|rtname
index|[
literal|0
index|]
condition|)
block|{
name|mp
operator|->
name|m_rtname
operator|=
name|kmem_alloc
argument_list|(
name|strlen
argument_list|(
name|ap
operator|->
name|rtname
argument_list|)
operator|+
literal|1
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mp
operator|->
name|m_rtname
argument_list|,
name|ap
operator|->
name|rtname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|logname
index|[
literal|0
index|]
condition|)
block|{
name|mp
operator|->
name|m_logname
operator|=
name|kmem_alloc
argument_list|(
name|strlen
argument_list|(
name|ap
operator|->
name|logname
argument_list|)
operator|+
literal|1
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mp
operator|->
name|m_logname
argument_list|,
name|ap
operator|->
name|logname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|XFSMNT_WSYNC
condition|)
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_WSYNC
expr_stmt|;
if|#
directive|if
name|XFS_BIG_INUMS
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|XFSMNT_INO64
condition|)
block|{
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_INO64
expr_stmt|;
name|mp
operator|->
name|m_inoadd
operator|=
name|XFS_INO64_OFFSET
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|XFSMNT_RETERR
condition|)
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_RETERR
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|XFSMNT_NOALIGN
condition|)
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_NOALIGN
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|XFSMNT_SWALLOC
condition|)
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_SWALLOC
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|XFSMNT_OSYNCISOSYNC
condition|)
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_OSYNCISOSYNC
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|XFSMNT_32BITINODES
condition|)
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_32BITINODES
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|XFSMNT_IOSIZE
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|iosizelog
operator|>
name|XFS_MAX_IO_LOG
operator|||
name|ap
operator|->
name|iosizelog
operator|<
name|XFS_MIN_IO_LOG
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: invalid log iosize: %d [not %d-%d]"
argument_list|,
name|ap
operator|->
name|iosizelog
argument_list|,
name|XFS_MIN_IO_LOG
argument_list|,
name|XFS_MAX_IO_LOG
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_DFLT_IOSIZE
expr_stmt|;
name|mp
operator|->
name|m_readio_log
operator|=
name|mp
operator|->
name|m_writeio_log
operator|=
name|ap
operator|->
name|iosizelog
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|XFSMNT_IHASHSIZE
condition|)
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_IHASHSIZE
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|XFSMNT_IDELETE
condition|)
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_IDELETE
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|XFSMNT_DIRSYNC
condition|)
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_DIRSYNC
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|XFSMNT_ATTR2
condition|)
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_ATTR2
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|flags2
operator|&
name|XFSMNT2_COMPAT_IOSIZE
condition|)
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_COMPAT_IOSIZE
expr_stmt|;
comment|/* 	 * no recovery flag requires a read-only mount 	 */
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|XFSMNT_NORECOVERY
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|vfs
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
operator|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: tried to mount a FS read-write without recovery!"
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_NORECOVERY
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|XFSMNT_NOUUID
condition|)
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_NOUUID
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|XFSMNT_BARRIER
condition|)
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_BARRIER
expr_stmt|;
else|else
name|mp
operator|->
name|m_flags
operator|&=
operator|~
name|XFS_MOUNT_BARRIER
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * This function fills in xfs_mount_t fields based on mount args.  * Note: the superblock _has_ now been read in.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_finish_flags
parameter_list|(
name|struct
name|xfs_vfs
modifier|*
name|vfs
parameter_list|,
name|struct
name|xfs_mount_args
modifier|*
name|ap
parameter_list|,
name|struct
name|xfs_mount
modifier|*
name|mp
parameter_list|)
block|{
name|int
name|ronly
init|=
operator|(
name|vfs
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
operator|)
decl_stmt|;
comment|/* Fail a mount where the logbuf is smaller then the log stripe */
if|if
condition|(
name|XFS_SB_VERSION_HASLOGV2
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|ap
operator|->
name|logbufsize
operator|<=
literal|0
operator|)
operator|&&
operator|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_logsunit
operator|>
name|XLOG_BIG_RECORD_BSIZE
operator|)
condition|)
block|{
name|mp
operator|->
name|m_logbsize
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_logsunit
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ap
operator|->
name|logbufsize
operator|>
literal|0
operator|&&
name|ap
operator|->
name|logbufsize
operator|<
name|mp
operator|->
name|m_sb
operator|.
name|sb_logsunit
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: logbuf size must be greater than or equal to log stripe size"
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|/* Fail a mount if the logbuf is larger than 32K */
if|if
condition|(
name|ap
operator|->
name|logbufsize
operator|>
name|XLOG_BIG_RECORD_BSIZE
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: logbuf size for version 1 logs must be 16K or 32K"
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|XFS_SB_VERSION_HASATTR2
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
condition|)
block|{
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_ATTR2
expr_stmt|;
block|}
comment|/* 	 * prohibit r/w mounts of read-only filesystems 	 */
if|if
condition|(
operator|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_flags
operator|&
name|XFS_SBF_READONLY
operator|)
operator|&&
operator|!
name|ronly
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: cannot mount a read-only filesystem as read-write"
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EROFS
argument_list|)
return|;
block|}
comment|/* 	 * check for shared mount. 	 */
if|if
condition|(
name|ap
operator|->
name|flags
operator|&
name|XFSMNT_SHARED
condition|)
block|{
if|if
condition|(
operator|!
name|XFS_SB_VERSION_HASSHARED
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
comment|/* 		 * For IRIX 6.5, shared mounts must have the shared 		 * version bit set, have the persistent readonly 		 * field set, must be version 0 and can only be mounted 		 * read-only. 		 */
if|if
condition|(
operator|!
name|ronly
operator|||
operator|!
operator|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_flags
operator|&
name|XFS_SBF_READONLY
operator|)
operator|||
operator|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_shared_vn
operator|!=
literal|0
operator|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_SHARED
expr_stmt|;
comment|/* 		 * Shared XFS V0 can't deal with DMI.  Return EINVAL. 		 */
if|if
condition|(
name|mp
operator|->
name|m_sb
operator|.
name|sb_shared_vn
operator|==
literal|0
operator|&&
operator|(
name|ap
operator|->
name|flags
operator|&
name|XFSMNT_DMAPI
operator|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * xfs_mount  *  * The file system configurations are:  *	(1) device (partition) with data and internal log  *	(2) logical volume with data and log subvolumes.  *	(3) logical volume with data, log, and realtime subvolumes.  *  * We only have to handle opening the log and realtime volumes here if  * they are present.  The data subvolume has already been opened by  * get_sb_bdev() and is stored in vfsp->vfs_super->s_bdev.  */
end_comment

begin_function
name|STATIC
name|int
name|xfs_mount
parameter_list|(
name|struct
name|bhv_desc
modifier|*
name|bhvp
parameter_list|,
name|struct
name|xfs_mount_args
modifier|*
name|args
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|)
block|{
name|struct
name|xfs_vfs
modifier|*
name|vfsp
init|=
name|bhvtovfs
argument_list|(
name|bhvp
argument_list|)
decl_stmt|;
name|struct
name|bhv_desc
modifier|*
name|p
decl_stmt|;
name|struct
name|xfs_mount
modifier|*
name|mp
init|=
name|XFS_BHVTOM
argument_list|(
name|bhvp
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|ddev
decl_stmt|,
modifier|*
name|logdev
decl_stmt|,
modifier|*
name|rtdev
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|,
name|error
decl_stmt|;
name|ddev
operator|=
name|logdev
operator|=
name|rtdev
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|xfs_blkdev_get
argument_list|(
name|mp
argument_list|,
name|args
operator|->
name|fsname
argument_list|,
operator|&
name|ddev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* 	 * Setup xfs_mount function vectors from available behaviors 	 */
name|p
operator|=
name|vfs_bhv_lookup
argument_list|(
name|vfsp
argument_list|,
name|VFS_POSITION_DM
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_dm_ops
operator|=
name|p
condition|?
operator|*
operator|(
name|xfs_dmops_t
operator|*
operator|)
name|vfs_bhv_custom
argument_list|(
name|p
argument_list|)
else|:
name|xfs_dmcore_stub
expr_stmt|;
name|p
operator|=
name|vfs_bhv_lookup
argument_list|(
name|vfsp
argument_list|,
name|VFS_POSITION_QM
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_qm_ops
operator|=
name|p
condition|?
operator|*
operator|(
name|xfs_qmops_t
operator|*
operator|)
name|vfs_bhv_custom
argument_list|(
name|p
argument_list|)
else|:
name|xfs_qmcore_stub
expr_stmt|;
name|p
operator|=
name|vfs_bhv_lookup
argument_list|(
name|vfsp
argument_list|,
name|VFS_POSITION_IO
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_io_ops
operator|=
name|p
condition|?
operator|*
operator|(
name|xfs_ioops_t
operator|*
operator|)
name|vfs_bhv_custom
argument_list|(
name|p
argument_list|)
else|:
name|xfs_iocore_xfs
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|flags
operator|&
name|XFSMNT_QUIET
condition|)
name|flags
operator||=
name|XFS_MFSI_QUIET
expr_stmt|;
comment|/* 	 * Open real time and log devices - order is important. 	 */
if|if
condition|(
name|args
operator|->
name|logname
index|[
literal|0
index|]
condition|)
block|{
name|error
operator|=
name|xfs_blkdev_get
argument_list|(
name|mp
argument_list|,
name|args
operator|->
name|logname
argument_list|,
operator|&
name|logdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_blkdev_put
argument_list|(
name|ddev
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
if|if
condition|(
name|args
operator|->
name|rtname
index|[
literal|0
index|]
condition|)
block|{
name|error
operator|=
name|xfs_blkdev_get
argument_list|(
name|mp
argument_list|,
name|args
operator|->
name|rtname
argument_list|,
operator|&
name|rtdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|xfs_blkdev_put
argument_list|(
name|logdev
argument_list|)
expr_stmt|;
name|xfs_blkdev_put
argument_list|(
name|ddev
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|rtdev
operator|==
name|ddev
operator|||
name|rtdev
operator|==
name|logdev
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"XFS: Cannot mount filesystem with identical rtdev and ddev/logdev."
argument_list|)
expr_stmt|;
name|xfs_blkdev_put
argument_list|(
name|logdev
argument_list|)
expr_stmt|;
name|xfs_blkdev_put
argument_list|(
name|rtdev
argument_list|)
expr_stmt|;
name|xfs_blkdev_put
argument_list|(
name|ddev
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
comment|/* 	 * Setup xfs_mount buffer target pointers 	 */
name|error
operator|=
name|ENOMEM
expr_stmt|;
name|mp
operator|->
name|m_ddev_targp
operator|=
name|xfs_alloc_buftarg
argument_list|(
name|ddev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mp
operator|->
name|m_ddev_targp
condition|)
block|{
name|xfs_blkdev_put
argument_list|(
name|logdev
argument_list|)
expr_stmt|;
name|xfs_blkdev_put
argument_list|(
name|rtdev
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|rtdev
condition|)
block|{
name|mp
operator|->
name|m_rtdev_targp
operator|=
name|xfs_alloc_buftarg
argument_list|(
name|rtdev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mp
operator|->
name|m_rtdev_targp
condition|)
goto|goto
name|error0
goto|;
block|}
name|mp
operator|->
name|m_logdev_targp
operator|=
operator|(
name|logdev
operator|&&
name|logdev
operator|!=
name|ddev
operator|)
condition|?
name|xfs_alloc_buftarg
argument_list|(
name|logdev
argument_list|,
literal|1
argument_list|)
else|:
name|mp
operator|->
name|m_ddev_targp
expr_stmt|;
if|if
condition|(
operator|!
name|mp
operator|->
name|m_logdev_targp
condition|)
goto|goto
name|error0
goto|;
comment|/* 	 * Setup flags based on mount(2) options and then the superblock 	 */
name|error
operator|=
name|xfs_start_flags
argument_list|(
name|vfsp
argument_list|,
name|args
argument_list|,
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error1
goto|;
name|error
operator|=
name|xfs_readsb
argument_list|(
name|mp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error1
goto|;
name|error
operator|=
name|xfs_finish_flags
argument_list|(
name|vfsp
argument_list|,
name|args
argument_list|,
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error2
goto|;
comment|/* 	 * Setup xfs_mount buffer target pointers based on superblock 	 */
name|error
operator|=
name|xfs_setsize_buftarg
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_sectsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|logdev
operator|&&
name|logdev
operator|!=
name|ddev
condition|)
block|{
name|unsigned
name|int
name|log_sector_size
init|=
name|BBSIZE
decl_stmt|;
if|if
condition|(
name|XFS_SB_VERSION_HASSECTOR
argument_list|(
operator|&
name|mp
operator|->
name|m_sb
argument_list|)
condition|)
name|log_sector_size
operator|=
name|mp
operator|->
name|m_sb
operator|.
name|sb_logsectsize
expr_stmt|;
name|error
operator|=
name|xfs_setsize_buftarg
argument_list|(
name|mp
operator|->
name|m_logdev_targp
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
argument_list|,
name|log_sector_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
operator|&&
name|rtdev
condition|)
name|error
operator|=
name|xfs_setsize_buftarg
argument_list|(
name|mp
operator|->
name|m_rtdev_targp
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_blocksize
argument_list|,
name|mp
operator|->
name|m_sb
operator|.
name|sb_sectsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error2
goto|;
if|if
condition|(
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_BARRIER
operator|)
operator|&&
operator|!
operator|(
name|vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
operator|)
condition|)
name|xfs_mountfs_check_barriers
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|error
operator|=
name|XFS_IOINIT
argument_list|(
name|vfsp
argument_list|,
name|args
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error2
goto|;
return|return
literal|0
return|;
name|error2
label|:
if|if
condition|(
name|mp
operator|->
name|m_sb_bp
condition|)
name|xfs_freesb
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|error1
label|:
name|xfs_binval
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|)
expr_stmt|;
if|if
condition|(
name|logdev
operator|&&
name|logdev
operator|!=
name|ddev
condition|)
name|xfs_binval
argument_list|(
name|mp
operator|->
name|m_logdev_targp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtdev
condition|)
name|xfs_binval
argument_list|(
name|mp
operator|->
name|m_rtdev_targp
argument_list|)
expr_stmt|;
name|error0
label|:
name|xfs_unmountfs_close
argument_list|(
name|mp
argument_list|,
name|credp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_unmount
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|)
block|{
name|struct
name|xfs_vfs
modifier|*
name|vfsp
init|=
name|bhvtovfs
argument_list|(
name|bdp
argument_list|)
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
init|=
name|XFS_BHVTOM
argument_list|(
name|bdp
argument_list|)
decl_stmt|;
name|xfs_inode_t
modifier|*
name|rip
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|rvp
decl_stmt|;
name|int
name|unmount_event_wanted
init|=
literal|0
decl_stmt|;
name|int
name|unmount_event_flags
init|=
literal|0
decl_stmt|;
name|int
name|xfs_unmountfs_needed
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|rip
operator|=
name|mp
operator|->
name|m_rootip
expr_stmt|;
name|rvp
operator|=
name|XFS_ITOV
argument_list|(
name|rip
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_DMI
condition|)
block|{
name|error
operator|=
name|XFS_SEND_PREUNMOUNT
argument_list|(
name|mp
argument_list|,
name|vfsp
argument_list|,
name|rvp
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|rvp
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
name|mp
operator|->
name|m_dmevmask
operator|&
operator|(
literal|1
operator|<<
name|DM_EVENT_PREUNMOUNT
operator|)
operator|)
condition|?
literal|0
else|:
name|DM_FLAGS_UNWANTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|error
argument_list|)
return|;
name|unmount_event_wanted
operator|=
literal|1
expr_stmt|;
name|unmount_event_flags
operator|=
operator|(
name|mp
operator|->
name|m_dmevmask
operator|&
operator|(
literal|1
operator|<<
name|DM_EVENT_UNMOUNT
operator|)
operator|)
condition|?
literal|0
else|:
name|DM_FLAGS_UNWANTED
expr_stmt|;
block|}
comment|/* 	 * Linux (& presumably Irix) do not reach this code if 	 * any of this FS vnodes have active references. FreeBSD 	 * relies on FS to clean after itself. 	 */
name|xfs_iflush_all
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* 	 * First blow any referenced inode from this file system 	 * out of the reference cache, and delete the timer. 	 */
name|xfs_refcache_purge_mp
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|XFS_bflush
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_unmount_flush
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|ASSERT
argument_list|(
name|vn_count
argument_list|(
name|rvp
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Drop the reference count 	 */
name|VN_RELE
argument_list|(
name|rvp
argument_list|)
expr_stmt|;
comment|/* 	 * If we're forcing a shutdown, typically because of a media error, 	 * we want to make sure we invalidate dirty pages that belong to 	 * referenced vnodes as well. 	 */
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|error
operator|=
name|xfs_sync
argument_list|(
operator|&
name|mp
operator|->
name|m_bhv
argument_list|,
operator|(
name|SYNC_WAIT
operator||
name|SYNC_CLOSE
operator|)
argument_list|,
name|credp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|!=
name|EFSCORRUPTED
argument_list|)
expr_stmt|;
block|}
name|xfs_unmountfs_needed
operator|=
literal|1
expr_stmt|;
name|out
label|:
comment|/*	Send DMAPI event, if required. 	 *	Then do xfs_unmountfs() if needed. 	 *	Then return error (or zero). 	 */
if|if
condition|(
name|unmount_event_wanted
condition|)
block|{
comment|/* Note: mp structure must still exist for 		 * XFS_SEND_UNMOUNT() call. 		 */
name|XFS_SEND_UNMOUNT
argument_list|(
name|mp
argument_list|,
name|vfsp
argument_list|,
name|error
operator|==
literal|0
condition|?
name|rvp
else|:
name|NULL
argument_list|,
name|DM_RIGHT_NULL
argument_list|,
literal|0
argument_list|,
name|error
argument_list|,
name|unmount_event_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xfs_unmountfs_needed
condition|)
block|{
comment|/* 		 * Call common unmount function to flush to disk 		 * and free the super block buffer& mount structures. 		 */
name|xfs_unmountfs
argument_list|(
name|mp
argument_list|,
name|credp
argument_list|)
expr_stmt|;
block|}
return|return
name|XFS_ERROR
argument_list|(
name|error
argument_list|)
return|;
block|}
end_function

begin_function
name|STATIC
name|int
name|xfs_quiesce_fs
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|,
name|pincount
decl_stmt|;
name|xfs_refcache_purge_mp
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|xfs_flush_buftarg
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xfs_finish_reclaim_all
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This loop must run at least twice. 	 * The first instance of the loop will flush 	 * most meta data but that will generate more 	 * meta data (typically directory updates). 	 * Which then must be flushed and logged before 	 * we can write the unmount record. 	 */
do|do
block|{
name|xfs_syncsub
argument_list|(
name|mp
argument_list|,
name|SYNC_REMOUNT
operator||
name|SYNC_ATTR
operator||
name|SYNC_WAIT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pincount
operator|=
name|xfs_flush_buftarg
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pincount
condition|)
block|{
name|delay
argument_list|(
literal|50
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|count
operator|<
literal|2
condition|)
do|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* XXXKAN */
end_comment

begin_define
define|#
directive|define
name|pagebuf_delwri_flush
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
define|\
value|do {						\ 		printf("pagebuf_delwri_flush NI\n");	\ 		if (c) *((int *)(c)) = 0;		\ 	} while(0)
end_define

begin_function
name|STATIC
name|int
name|xfs_mntupdate
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|int
modifier|*
name|flags
parameter_list|,
name|struct
name|xfs_mount_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|xfs_vfs
modifier|*
name|vfsp
init|=
name|bhvtovfs
argument_list|(
name|bdp
argument_list|)
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
init|=
name|XFS_BHVTOM
argument_list|(
name|bdp
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|RMC
if|if
condition|(
operator|!
operator|(
operator|*
name|flags
operator|&
name|MS_RDONLY
operator|)
condition|)
block|{
comment|/* rw/ro -> rw */
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
operator|*
name|flags
operator|&
name|VFS_RDONLY
operator|)
condition|)
block|{
comment|/* rw/ro -> rw */
if|if
condition|(
name|vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
condition|)
name|vfsp
operator|->
name|vfs_flag
operator|&=
operator|~
name|VFS_RDONLY
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|flags
operator|&
name|XFSMNT_BARRIER
condition|)
block|{
name|mp
operator|->
name|m_flags
operator||=
name|XFS_MOUNT_BARRIER
expr_stmt|;
name|xfs_mountfs_check_barriers
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|m_flags
operator|&=
operator|~
name|XFS_MOUNT_BARRIER
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
operator|)
condition|)
block|{
comment|/* rw -> ro */
name|XVFS_SYNC
argument_list|(
name|vfsp
argument_list|,
name|SYNC_FSDATA
operator||
name|SYNC_BDFLUSH
operator||
name|SYNC_ATTR
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|xfs_quiesce_fs
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|xfs_log_unmount_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|xfs_unmountfs_writesb
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|vfsp
operator|->
name|vfs_flag
operator||=
name|VFS_RDONLY
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/*  * xfs_unmount_flush implements a set of flush operation on special  * inodes, which are needed as a separate set of operations so that  * they can be called as part of relocation process.  */
name|int
name|xfs_unmount_flush
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
comment|/* Mount structure we are getting 					   rid of. */
name|int
name|relocation
parameter_list|)
comment|/* Called from vfs relocation. */
block|{
name|xfs_inode_t
modifier|*
name|rip
init|=
name|mp
operator|->
name|m_rootip
decl_stmt|;
name|xfs_inode_t
modifier|*
name|rbmip
decl_stmt|;
name|xfs_inode_t
modifier|*
name|rsumip
init|=
name|NULL
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|rvp
init|=
name|XFS_ITOV_NULL
argument_list|(
name|rip
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|rvp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|xfs_ilock
argument_list|(
name|rip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_iflock
argument_list|(
name|rip
argument_list|)
expr_stmt|;
comment|/* 	 * Flush out the real time inodes. 	 */
if|if
condition|(
operator|(
name|rbmip
operator|=
name|mp
operator|->
name|m_rbmip
operator|)
operator|!=
name|NULL
condition|)
block|{
name|xfs_ilock
argument_list|(
name|rbmip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_iflock
argument_list|(
name|rbmip
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_iflush
argument_list|(
name|rbmip
argument_list|,
name|XFS_IFLUSH_SYNC
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|rbmip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFSCORRUPTED
condition|)
goto|goto
name|fscorrupt_out
goto|;
name|ASSERT
argument_list|(
name|vn_count
argument_list|(
name|XFS_ITOV
argument_list|(
name|rbmip
argument_list|)
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|rsumip
operator|=
name|mp
operator|->
name|m_rsumip
expr_stmt|;
name|xfs_ilock
argument_list|(
name|rsumip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_iflock
argument_list|(
name|rsumip
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_iflush
argument_list|(
name|rsumip
argument_list|,
name|XFS_IFLUSH_SYNC
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|rsumip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFSCORRUPTED
condition|)
goto|goto
name|fscorrupt_out
goto|;
name|ASSERT
argument_list|(
name|vn_count
argument_list|(
name|XFS_ITOV
argument_list|(
name|rsumip
argument_list|)
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Synchronously flush root inode to disk 	 */
name|error
operator|=
name|xfs_iflush
argument_list|(
name|rip
argument_list|,
name|XFS_IFLUSH_SYNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFSCORRUPTED
condition|)
goto|goto
name|fscorrupt_out2
goto|;
if|if
condition|(
name|vn_count
argument_list|(
name|rvp
argument_list|)
operator|!=
literal|1
operator|&&
operator|!
name|relocation
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|rip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EBUSY
argument_list|)
return|;
block|}
comment|/* 	 * Release dquot that rootinode, rbmino and rsumino might be holding, 	 * flush and purge the quota inodes. 	 */
name|error
operator|=
name|XFS_QM_UNMOUNT
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFSCORRUPTED
condition|)
goto|goto
name|fscorrupt_out2
goto|;
if|if
condition|(
name|rbmip
condition|)
block|{
name|VN_RELE
argument_list|(
name|XFS_ITOV
argument_list|(
name|rbmip
argument_list|)
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|XFS_ITOV
argument_list|(
name|rsumip
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|xfs_iunlock
argument_list|(
name|rip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|fscorrupt_out
label|:
name|xfs_ifunlock
argument_list|(
name|rip
argument_list|)
expr_stmt|;
name|fscorrupt_out2
label|:
name|xfs_iunlock
argument_list|(
name|rip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EFSCORRUPTED
argument_list|)
return|;
block|}
comment|/*  * xfs_root extracts the root vnode from a vfs.  *  * vfsp -- the vfs struct for the desired file system  * vpp  -- address of the caller's vnode pointer which should be  *         set to the desired fs root vnode  */
name|STATIC
name|int
name|xfs_root
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|xfs_vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|xfs_vnode_t
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|XFS_ITOV
argument_list|(
operator|(
name|XFS_BHVTOM
argument_list|(
name|bdp
argument_list|)
operator|)
operator|->
name|m_rootip
argument_list|)
expr_stmt|;
name|VN_HOLD
argument_list|(
name|vp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  * xfs_statvfs  *  * Fill in the statvfs structure for the given file system.  We use  * the superblock lock in the mount structure to ensure a consistent  * snapshot of the counters returned.  */
name|STATIC
name|int
name|xfs_statvfs
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|xfs_statfs_t
modifier|*
name|statp
parameter_list|,
name|xfs_vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|__uint64_t
name|fakeinos
decl_stmt|;
name|xfs_extlen_t
name|lsize
decl_stmt|;
name|xfs_mount_t
modifier|*
name|mp
decl_stmt|;
name|xfs_sb_t
modifier|*
name|sbp
decl_stmt|;
name|unsigned
name|long
name|s
decl_stmt|;
name|mp
operator|=
name|XFS_BHVTOM
argument_list|(
name|bdp
argument_list|)
expr_stmt|;
name|sbp
operator|=
operator|&
operator|(
name|mp
operator|->
name|m_sb
operator|)
expr_stmt|;
name|statp
operator|->
name|f_type
operator|=
name|XFS_SB_MAGIC
expr_stmt|;
name|xfs_icsb_sync_counters_lazy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|s
operator|=
name|XFS_SB_LOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|statp
operator|->
name|f_bsize
operator|=
name|sbp
operator|->
name|sb_blocksize
expr_stmt|;
name|lsize
operator|=
name|sbp
operator|->
name|sb_logstart
condition|?
name|sbp
operator|->
name|sb_logblocks
else|:
literal|0
expr_stmt|;
name|statp
operator|->
name|f_blocks
operator|=
name|sbp
operator|->
name|sb_dblocks
operator|-
name|lsize
expr_stmt|;
name|statp
operator|->
name|f_bfree
operator|=
name|statp
operator|->
name|f_bavail
operator|=
name|sbp
operator|->
name|sb_fdblocks
expr_stmt|;
name|fakeinos
operator|=
name|statp
operator|->
name|f_bfree
operator|<<
name|sbp
operator|->
name|sb_inopblog
expr_stmt|;
if|#
directive|if
name|XFS_BIG_INUMS
name|fakeinos
operator|+=
name|mp
operator|->
name|m_inoadd
expr_stmt|;
endif|#
directive|endif
name|statp
operator|->
name|f_files
operator|=
name|MIN
argument_list|(
name|sbp
operator|->
name|sb_icount
operator|+
name|fakeinos
argument_list|,
operator|(
name|__uint64_t
operator|)
name|XFS_MAXINUMBER
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_maxicount
condition|)
if|#
directive|if
name|XFS_BIG_INUMS
if|if
condition|(
operator|!
name|mp
operator|->
name|m_inoadd
condition|)
endif|#
directive|endif
name|statp
operator|->
name|f_files
operator|=
name|min_t
argument_list|(
name|typeof
argument_list|(
name|statp
operator|->
name|f_files
argument_list|)
argument_list|,
name|statp
operator|->
name|f_files
argument_list|,
name|mp
operator|->
name|m_maxicount
argument_list|)
expr_stmt|;
name|statp
operator|->
name|f_ffree
operator|=
name|statp
operator|->
name|f_files
operator|-
operator|(
name|sbp
operator|->
name|sb_icount
operator|-
name|sbp
operator|->
name|sb_ifree
operator|)
expr_stmt|;
name|XFS_SB_UNLOCK
argument_list|(
name|mp
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|xfs_statvfs_fsid
argument_list|(
name|statp
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  * xfs_sync flushes any pending I/O to file system vfsp.  *  * This routine is called by vfs_sync() to make sure that things make it  * out to disk eventually, on sync() system calls to flush out everything,  * and when the file system is unmounted.  For the vfs_sync() case, all  * we really need to do is sync out the log to make all of our meta-data  * updates permanent (except for timestamps).  For calls from pflushd(),  * dirty pages are kept moving by calling pdflush() on the inodes  * containing them.  We also flush the inodes that we can lock without  * sleeping and the superblock if we can lock it without sleeping from  * vfs_sync() so that items at the tail of the log are always moving out.  *  * Flags:  *      SYNC_BDFLUSH - We're being called from vfs_sync() so we don't want  *		       to sleep if we can help it.  All we really need  *		       to do is ensure that the log is synced at least  *		       periodically.  We also push the inodes and  *		       superblock if we can lock them without sleeping  *			and they are not pinned.  *      SYNC_ATTR    - We need to flush the inodes.  If SYNC_BDFLUSH is not  *		       set, then we really want to lock each inode and flush  *		       it.  *      SYNC_WAIT    - All the flushes that take place in this call should  *		       be synchronous.  *      SYNC_DELWRI  - This tells us to push dirty pages associated with  *		       inodes.  SYNC_WAIT and SYNC_BDFLUSH are used to  *		       determine if they should be flushed sync, async, or  *		       delwri.  *      SYNC_CLOSE   - This flag is passed when the system is being  *		       unmounted.  We should sync and invalidate everything.  *      SYNC_FSDATA  - This indicates that the caller would like to make  *		       sure the superblock is safe on disk.  We can ensure  *		       this by simply making sure the log gets flushed  *		       if SYNC_BDFLUSH is set, and by actually writing it  *		       out otherwise.  *  */
comment|/*ARGSUSED*/
name|STATIC
name|int
name|xfs_sync
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|credp
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
init|=
name|XFS_BHVTOM
argument_list|(
name|bdp
argument_list|)
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|flags
operator|==
name|SYNC_QUIESCE
argument_list|)
condition|)
return|return
name|xfs_quiesce_fs
argument_list|(
name|mp
argument_list|)
return|;
else|else
return|return
name|xfs_syncsub
argument_list|(
name|mp
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
block|}
comment|/*  * xfs sync routine for internal use  *  * This routine supports all of the flags defined for the generic VFS_SYNC  * interface as explained above under xfs_sync.  In the interests of not  * changing interfaces within the 6.5 family, additional internally-  * required functions are specified within a separate xflags parameter,  * only available by calling this routine.  *  */
name|int
name|xfs_sync_inodes
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|xflags
parameter_list|,
name|int
modifier|*
name|bypassed
parameter_list|)
block|{
name|xfs_inode_t
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip_next
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_vnode_t
modifier|*
name|vp
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|last_error
decl_stmt|;
name|uint64_t
name|fflag
decl_stmt|;
name|uint
name|lock_flags
decl_stmt|;
name|uint
name|base_lock_flags
decl_stmt|;
name|boolean_t
name|mount_locked
decl_stmt|;
name|boolean_t
name|vnode_refed
decl_stmt|;
name|int
name|preempt
decl_stmt|;
name|xfs_dinode_t
modifier|*
name|dip
decl_stmt|;
name|xfs_iptr_t
modifier|*
name|ipointer
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|boolean_t
name|ipointer_in
init|=
name|B_FALSE
decl_stmt|;
define|#
directive|define
name|IPOINTER_SET
value|ipointer_in = B_TRUE
define|#
directive|define
name|IPOINTER_CLR
value|ipointer_in = B_FALSE
else|#
directive|else
define|#
directive|define
name|IPOINTER_SET
define|#
directive|define
name|IPOINTER_CLR
endif|#
directive|endif
comment|/* Insert a marker record into the inode list after inode ip. The list  * must be locked when this is called. After the call the list will no  * longer be locked.  */
define|#
directive|define
name|IPOINTER_INSERT
parameter_list|(
name|ip
parameter_list|,
name|mp
parameter_list|)
value|{ \ 		ASSERT(ipointer_in == B_FALSE); \ 		ipointer->ip_mnext = ip->i_mnext; \ 		ipointer->ip_mprev = ip; \ 		ip->i_mnext = (xfs_inode_t *)ipointer; \ 		ipointer->ip_mnext->i_mprev = (xfs_inode_t *)ipointer; \ 		preempt = 0; \ 		XFS_MOUNT_IUNLOCK(mp); \ 		mount_locked = B_FALSE; \ 		IPOINTER_SET; \ 	}
comment|/* Remove the marker from the inode list. If the marker was the only item  * in the list then there are no remaining inodes and we should zero out  * the whole list. If we are the current head of the list then move the head  * past us.  */
define|#
directive|define
name|IPOINTER_REMOVE
parameter_list|(
name|ip
parameter_list|,
name|mp
parameter_list|)
value|{ \ 		ASSERT(ipointer_in == B_TRUE); \ 		if (ipointer->ip_mnext != (xfs_inode_t *)ipointer) { \ 			ip = ipointer->ip_mnext; \ 			ip->i_mprev = ipointer->ip_mprev; \ 			ipointer->ip_mprev->i_mnext = ip; \ 			if (mp->m_inodes == (xfs_inode_t *)ipointer) { \ 				mp->m_inodes = ip; \ 			} \ 		} else { \ 			ASSERT(mp->m_inodes == (xfs_inode_t *)ipointer); \ 			mp->m_inodes = NULL; \ 			ip = NULL; \ 		} \ 		IPOINTER_CLR; \ 	}
define|#
directive|define
name|XFS_PREEMPT_MASK
value|0x7f
if|if
condition|(
name|bypassed
condition|)
operator|*
name|bypassed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
condition|)
return|return
literal|0
return|;
name|error
operator|=
literal|0
expr_stmt|;
name|last_error
operator|=
literal|0
expr_stmt|;
name|preempt
operator|=
literal|0
expr_stmt|;
comment|/* Allocate a reference marker */
name|ipointer
operator|=
operator|(
name|xfs_iptr_t
operator|*
operator|)
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|xfs_iptr_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|fflag
operator|=
name|XFS_B_ASYNC
expr_stmt|;
comment|/* default is don't wait */
if|if
condition|(
name|flags
operator|&
operator|(
name|SYNC_BDFLUSH
operator||
name|SYNC_DELWRI
operator|)
condition|)
name|fflag
operator|=
name|XFS_B_DELWRI
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SYNC_WAIT
condition|)
name|fflag
operator|=
literal|0
expr_stmt|;
comment|/* synchronous overrides all */
name|base_lock_flags
operator|=
name|XFS_ILOCK_SHARED
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|SYNC_DELWRI
operator||
name|SYNC_CLOSE
operator|)
condition|)
block|{
comment|/* 		 * We need the I/O lock if we're going to call any of 		 * the flush/inval routines. 		 */
name|base_lock_flags
operator||=
name|XFS_IOLOCK_SHARED
expr_stmt|;
block|}
name|XFS_MOUNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ip
operator|=
name|mp
operator|->
name|m_inodes
expr_stmt|;
name|mount_locked
operator|=
name|B_TRUE
expr_stmt|;
name|vnode_refed
operator|=
name|B_FALSE
expr_stmt|;
name|IPOINTER_CLR
expr_stmt|;
do|do
block|{
name|ASSERT
argument_list|(
name|ipointer_in
operator|==
name|B_FALSE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vnode_refed
operator|==
name|B_FALSE
argument_list|)
expr_stmt|;
name|lock_flags
operator|=
name|base_lock_flags
expr_stmt|;
comment|/* 		 * There were no inodes in the list, just break out 		 * of the loop. 		 */
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
comment|/* 		 * We found another sync thread marker - skip it 		 */
if|if
condition|(
name|ip
operator|->
name|i_mount
operator|==
name|NULL
condition|)
block|{
name|ip
operator|=
name|ip
operator|->
name|i_mnext
expr_stmt|;
continue|continue;
block|}
name|vp
operator|=
name|XFS_ITOV_NULL
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* 		 * If the vnode is gone then this is being torn down, 		 * call reclaim if it is flushed, else let regular flush 		 * code deal with it later in the loop. 		 */
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
comment|/* Skip ones already in reclaim */
if|if
condition|(
name|ip
operator|->
name|i_flags
operator|&
name|XFS_IRECLAIM
condition|)
block|{
name|ip
operator|=
name|ip
operator|->
name|i_mnext
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|xfs_ilock_nowait
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ip
operator|=
name|ip
operator|->
name|i_mnext
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|xfs_ipincount
argument_list|(
name|ip
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|xfs_iflock_nowait
argument_list|(
name|ip
argument_list|)
condition|)
block|{
name|IPOINTER_INSERT
argument_list|(
name|ip
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|xfs_finish_reclaim
argument_list|(
name|ip
argument_list|,
literal|1
argument_list|,
name|XFS_IFLUSH_DELWRI_ELSE_ASYNC
argument_list|)
expr_stmt|;
name|XFS_MOUNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mount_locked
operator|=
name|B_TRUE
expr_stmt|;
name|IPOINTER_REMOVE
argument_list|(
name|ip
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|ip
operator|=
name|ip
operator|->
name|i_mnext
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|VN_BAD
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|ip
operator|=
name|ip
operator|->
name|i_mnext
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|SYNC_CLOSE
operator|)
condition|)
block|{
name|XFS_MOUNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ipointer
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_iptr_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 		 * If this is just vfs_sync() or pflushd() calling 		 * then we can skip inodes for which it looks like 		 * there is nothing to do.  Since we don't have the 		 * inode locked this is racy, but these are periodic 		 * calls so it doesn't matter.  For the others we want 		 * to know for sure, so we at least try to lock them. 		 */
if|if
condition|(
name|flags
operator|&
name|SYNC_BDFLUSH
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|ip
operator|->
name|i_itemp
operator|==
name|NULL
operator|)
operator|||
operator|!
operator|(
name|ip
operator|->
name|i_itemp
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|&
name|XFS_ILOG_ALL
operator|)
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_update_core
operator|==
literal|0
operator|)
condition|)
block|{
name|ip
operator|=
name|ip
operator|->
name|i_mnext
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 		 * Try to lock without sleeping.  We're out of order with 		 * the inode list lock here, so if we fail we need to drop 		 * the mount lock and try again.  If we're called from 		 * bdflush() here, then don't bother. 		 * 		 * The inode lock here actually coordinates with the 		 * almost spurious inode lock in xfs_ireclaim() to prevent 		 * the vnode we handle here without a reference from 		 * being freed while we reference it.  If we lock the inode 		 * while it's on the mount list here, then the spurious inode 		 * lock in xfs_ireclaim() after the inode is pulled from 		 * the mount list will sleep until we release it here. 		 * This keeps the vnode from being freed while we reference 		 * it. 		 */
if|if
condition|(
name|xfs_ilock_nowait
argument_list|(
name|ip
argument_list|,
name|lock_flags
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|SYNC_BDFLUSH
operator|)
operator|||
operator|(
name|vp
operator|==
name|NULL
operator|)
condition|)
block|{
name|ip
operator|=
name|ip
operator|->
name|i_mnext
expr_stmt|;
continue|continue;
block|}
name|vp
operator|=
name|vn_grab
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|ip
operator|=
name|ip
operator|->
name|i_mnext
expr_stmt|;
continue|continue;
block|}
name|IPOINTER_INSERT
argument_list|(
name|ip
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vp
operator|==
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_mount
operator|==
name|mp
argument_list|)
expr_stmt|;
name|vnode_refed
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* From here on in the loop we may have a marker record 		 * in the inode list. 		 */
if|if
condition|(
operator|(
name|flags
operator|&
name|SYNC_CLOSE
operator|)
operator|&&
operator|(
name|vp
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* 			 * This is the shutdown case.  We just need to 			 * flush and invalidate all the pages associated 			 * with the inode.  Drop the inode lock since 			 * we can't hold it across calls to the buffer 			 * cache. 			 * 			 * We don't set the VREMAPPING bit in the vnode 			 * here, because we don't hold the vnode lock 			 * exclusively.  It doesn't really matter, though, 			 * because we only come here when we're shutting 			 * down anyway. 			 */
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
if|if
condition|(
name|XFS_FORCED_SHUTDOWN
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|XVOP_TOSS_PAGES
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|FI_REMAPF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|XVOP_FLUSHINVAL_PAGES
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|FI_REMAPF
argument_list|)
expr_stmt|;
block|}
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|SYNC_DELWRI
operator|)
operator|&&
operator|(
name|vp
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|VN_DIRTY
argument_list|(
name|vp
argument_list|)
condition|)
block|{
comment|/* We need to have dropped the lock here, 				 * so insert a marker if we have not already 				 * done so. 				 */
if|if
condition|(
name|mount_locked
condition|)
block|{
name|IPOINTER_INSERT
argument_list|(
name|ip
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * Drop the inode lock since we can't hold it 				 * across calls to the buffer cache. 				 */
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
name|XVOP_FLUSH_PAGES
argument_list|(
name|vp
argument_list|,
operator|(
name|xfs_off_t
operator|)
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
name|fflag
argument_list|,
name|FI_NONE
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|SYNC_BDFLUSH
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|SYNC_ATTR
operator|)
operator|&&
operator|(
operator|(
name|ip
operator|->
name|i_update_core
operator|)
operator|||
operator|(
operator|(
name|ip
operator|->
name|i_itemp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_itemp
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|!=
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Insert marker and drop lock if not already 				 * done. 				 */
if|if
condition|(
name|mount_locked
condition|)
block|{
name|IPOINTER_INSERT
argument_list|(
name|ip
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * We don't want the periodic flushing of the 				 * inodes by vfs_sync() to interfere with 				 * I/O to the file, especially read I/O 				 * where it is only the access time stamp 				 * that is being flushed out.  To prevent 				 * long periods where we have both inode 				 * locks held shared here while reading the 				 * inode's buffer in from disk, we drop the 				 * inode lock while reading in the inode 				 * buffer.  We have to release the buffer 				 * and reacquire the inode lock so that they 				 * are acquired in the proper order (inode 				 * locks first).  The buffer will go at the 				 * end of the lru chain, though, so we can 				 * expect it to still be there when we go 				 * for it again in xfs_iflush(). 				 */
if|if
condition|(
operator|(
name|xfs_ipincount
argument_list|(
name|ip
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|xfs_iflock_nowait
argument_list|(
name|ip
argument_list|)
condition|)
block|{
name|xfs_ifunlock
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_itobp
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|ip
argument_list|,
operator|&
name|dip
argument_list|,
operator|&
name|bp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Bailing out, remove the 						 * marker and free it. 						 */
name|XFS_MOUNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|IPOINTER_REMOVE
argument_list|(
name|ip
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|XFS_MOUNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|lock_flags
operator|&
name|XFS_IOLOCK_SHARED
operator|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ipointer
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_iptr_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 					 * Since we dropped the inode lock, 					 * the inode may have been reclaimed. 					 * Therefore, we reacquire the mount 					 * lock and check to see if we were the 					 * inode reclaimed. If this happened 					 * then the ipointer marker will no 					 * longer point back at us. In this 					 * case, move ip along to the inode 					 * after the marker, remove the marker 					 * and continue. 					 */
name|XFS_MOUNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mount_locked
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|ip
operator|!=
name|ipointer
operator|->
name|ip_mprev
condition|)
block|{
name|IPOINTER_REMOVE
argument_list|(
name|ip
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|vnode_refed
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|lock_flags
operator|&
name|XFS_IOLOCK_SHARED
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_mount
operator|==
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfs_ilock_nowait
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_mount
operator|==
name|mp
argument_list|)
expr_stmt|;
comment|/* 						 * We failed to reacquire 						 * the inode lock without 						 * sleeping, so just skip 						 * the inode for now.  We 						 * clear the ILOCK bit from 						 * the lock_flags so that we 						 * won't try to drop a lock 						 * we don't hold below. 						 */
name|lock_flags
operator|&=
operator|~
name|XFS_ILOCK_SHARED
expr_stmt|;
name|IPOINTER_REMOVE
argument_list|(
name|ip_next
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|xfs_ipincount
argument_list|(
name|ip
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|xfs_iflock_nowait
argument_list|(
name|ip
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_mount
operator|==
name|mp
argument_list|)
expr_stmt|;
comment|/* 						 * Since this is vfs_sync() 						 * calling we only flush the 						 * inode out if we can lock 						 * it without sleeping and 						 * it is not pinned.  Drop 						 * the mount lock here so 						 * that we don't hold it for 						 * too long. We already have 						 * a marker in the list here. 						 */
name|XFS_MOUNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mount_locked
operator|=
name|B_FALSE
expr_stmt|;
name|error
operator|=
name|xfs_iflush
argument_list|(
name|ip
argument_list|,
name|XFS_IFLUSH_DELWRI
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|ip
operator|->
name|i_mount
operator|==
name|mp
argument_list|)
expr_stmt|;
name|IPOINTER_REMOVE
argument_list|(
name|ip_next
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|SYNC_ATTR
operator|)
operator|&&
operator|(
operator|(
name|ip
operator|->
name|i_update_core
operator|)
operator|||
operator|(
operator|(
name|ip
operator|->
name|i_itemp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ip
operator|->
name|i_itemp
operator|->
name|ili_format
operator|.
name|ilf_fields
operator|!=
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|mount_locked
condition|)
block|{
name|IPOINTER_INSERT
argument_list|(
name|ip
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|SYNC_WAIT
condition|)
block|{
name|xfs_iflock
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_iflush
argument_list|(
name|ip
argument_list|,
name|XFS_IFLUSH_SYNC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * If we can't acquire the flush 					 * lock, then the inode is already 					 * being flushed so don't bother 					 * waiting.  If we can lock it then 					 * do a delwri flush so we can 					 * combine multiple inode flushes 					 * in each disk write. 					 */
if|if
condition|(
name|xfs_iflock_nowait
argument_list|(
name|ip
argument_list|)
condition|)
block|{
name|error
operator|=
name|xfs_iflush
argument_list|(
name|ip
argument_list|,
name|XFS_IFLUSH_DELWRI
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bypassed
condition|)
operator|(
operator|*
name|bypassed
operator|)
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|lock_flags
operator|!=
literal|0
condition|)
block|{
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|lock_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vnode_refed
condition|)
block|{
comment|/* 			 * If we had to take a reference on the vnode 			 * above, then wait until after we've unlocked 			 * the inode to release the reference.  This is 			 * because we can be already holding the inode 			 * lock when VN_RELE() calls xfs_inactive(). 			 * 			 * Make sure to drop the mount lock before calling 			 * VN_RELE() so that we don't trip over ourselves if 			 * we have to go for the mount lock again in the 			 * inactive code. 			 */
if|if
condition|(
name|mount_locked
condition|)
block|{
name|IPOINTER_INSERT
argument_list|(
name|ip
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vnode_refed
operator|=
name|B_FALSE
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|last_error
operator|=
name|error
expr_stmt|;
block|}
comment|/* 		 * bail out if the filesystem is corrupted. 		 */
if|if
condition|(
name|error
operator|==
name|EFSCORRUPTED
condition|)
block|{
if|if
condition|(
operator|!
name|mount_locked
condition|)
block|{
name|XFS_MOUNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|IPOINTER_REMOVE
argument_list|(
name|ip
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
name|XFS_MOUNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ipointer_in
operator|==
name|B_FALSE
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ipointer
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_iptr_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|error
argument_list|)
return|;
block|}
comment|/* Let other threads have a chance at the mount lock 		 * if we have looped many times without dropping the 		 * lock. 		 */
if|if
condition|(
operator|(
operator|++
name|preempt
operator|&
name|XFS_PREEMPT_MASK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mount_locked
condition|)
block|{
name|IPOINTER_INSERT
argument_list|(
name|ip
argument_list|,
name|mp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mount_locked
operator|==
name|B_FALSE
condition|)
block|{
name|XFS_MOUNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mount_locked
operator|=
name|B_TRUE
expr_stmt|;
name|IPOINTER_REMOVE
argument_list|(
name|ip
argument_list|,
name|mp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ASSERT
argument_list|(
name|ipointer_in
operator|==
name|B_FALSE
argument_list|)
expr_stmt|;
name|ip
operator|=
name|ip
operator|->
name|i_mnext
expr_stmt|;
block|}
do|while
condition|(
name|ip
operator|!=
name|mp
operator|->
name|m_inodes
condition|)
do|;
name|XFS_MOUNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ipointer_in
operator|==
name|B_FALSE
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ipointer
argument_list|,
sizeof|sizeof
argument_list|(
name|xfs_iptr_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|last_error
argument_list|)
return|;
block|}
comment|/*  * xfs sync routine for internal use  *  * This routine supports all of the flags defined for the generic VFS_SYNC  * interface as explained above under xfs_sync.  In the interests of not  * changing interfaces within the 6.5 family, additional internally-  * required functions are specified within a separate xflags parameter,  * only available by calling this routine.  *  */
name|int
name|xfs_syncsub
parameter_list|(
name|xfs_mount_t
modifier|*
name|mp
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|xflags
parameter_list|,
name|int
modifier|*
name|bypassed
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|last_error
init|=
literal|0
decl_stmt|;
name|uint
name|log_flags
init|=
name|XFS_LOG_FORCE
decl_stmt|;
name|xfs_buf_t
modifier|*
name|bp
decl_stmt|;
name|xfs_buf_log_item_t
modifier|*
name|bip
decl_stmt|;
comment|/* 	 * Sync out the log.  This ensures that the log is periodically 	 * flushed even if there is not enough activity to fill it up. 	 */
if|if
condition|(
name|flags
operator|&
name|SYNC_WAIT
condition|)
name|log_flags
operator||=
name|XFS_LOG_SYNC
expr_stmt|;
name|xfs_log_force
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_lsn_t
operator|)
literal|0
argument_list|,
name|log_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|SYNC_ATTR
operator||
name|SYNC_DELWRI
operator|)
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|SYNC_BDFLUSH
condition|)
name|xfs_finish_reclaim_all
argument_list|(
name|mp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|xfs_sync_inodes
argument_list|(
name|mp
argument_list|,
name|flags
argument_list|,
name|xflags
argument_list|,
name|bypassed
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Flushing out dirty data above probably generated more 	 * log activity, so if this isn't vfs_sync() then flush 	 * the log again. 	 */
if|if
condition|(
name|flags
operator|&
name|SYNC_DELWRI
condition|)
block|{
name|xfs_log_force
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_lsn_t
operator|)
literal|0
argument_list|,
name|log_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|SYNC_FSDATA
condition|)
block|{
comment|/* 		 * If this is vfs_sync() then only sync the superblock 		 * if we can lock it without sleeping and it is not pinned. 		 */
if|if
condition|(
name|flags
operator|&
name|SYNC_BDFLUSH
condition|)
block|{
name|bp
operator|=
name|xfs_getsb
argument_list|(
name|mp
argument_list|,
name|XFS_BUF_TRYLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|bip
operator|=
name|XFS_BUF_FSPRIVATE
argument_list|(
name|bp
argument_list|,
name|xfs_buf_log_item_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bip
operator|!=
name|NULL
operator|)
operator|&&
name|xfs_buf_item_dirty
argument_list|(
name|bip
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|XFS_BUF_ISPINNED
argument_list|(
name|bp
argument_list|)
operator|)
condition|)
block|{
name|XFS_BUF_ASYNC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_bwrite
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|xfs_buf_relse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|bp
operator|=
name|xfs_getsb
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * If the buffer is pinned then push on the log so 			 * we won't get stuck waiting in the write for 			 * someone, maybe ourselves, to flush the log. 			 * Even though we just pushed the log above, we 			 * did not have the superblock buffer locked at 			 * that point so it can become pinned in between 			 * there and here. 			 */
if|if
condition|(
name|XFS_BUF_ISPINNED
argument_list|(
name|bp
argument_list|)
condition|)
name|xfs_log_force
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_lsn_t
operator|)
literal|0
argument_list|,
name|XFS_LOG_FORCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SYNC_WAIT
condition|)
name|XFS_BUF_UNASYNC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
name|XFS_BUF_ASYNC
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_bwrite
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|last_error
operator|=
name|error
expr_stmt|;
block|}
block|}
comment|/* 	 * If this is the periodic sync, then kick some entries out of 	 * the reference cache.  This ensures that idle entries are 	 * eventually kicked out of the cache. 	 */
if|if
condition|(
name|flags
operator|&
name|SYNC_REFCACHE
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|SYNC_WAIT
condition|)
name|xfs_refcache_purge_mp
argument_list|(
name|mp
argument_list|)
expr_stmt|;
else|else
name|xfs_refcache_purge_some
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now check to see if the log needs a "dummy" transaction. 	 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SYNC_REMOUNT
operator|)
operator|&&
name|xfs_log_need_covered
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|xfs_trans_t
modifier|*
name|tp
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
comment|/* 		 * Put a dummy transaction in the log to tell 		 * recovery that all others are OK. 		 */
name|tp
operator|=
name|xfs_trans_alloc
argument_list|(
name|mp
argument_list|,
name|XFS_TRANS_DUMMY1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|xfs_trans_reserve
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|XFS_ICHANGE_LOG_RES
argument_list|(
name|mp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|xfs_trans_cancel
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|ip
operator|=
name|mp
operator|->
name|m_rootip
expr_stmt|;
name|xfs_ilock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ijoin
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_trans_ihold
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|xfs_trans_log_inode
argument_list|(
name|tp
argument_list|,
name|ip
argument_list|,
name|XFS_ILOG_CORE
argument_list|)
expr_stmt|;
name|error
operator|=
name|xfs_trans_commit
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_EXCL
argument_list|)
expr_stmt|;
name|xfs_log_force
argument_list|(
name|mp
argument_list|,
operator|(
name|xfs_lsn_t
operator|)
literal|0
argument_list|,
name|log_flags
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * When shutting down, we need to insure that the AIL is pushed 	 * to disk or the filesystem can appear corrupt from the PROM. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|SYNC_CLOSE
operator||
name|SYNC_WAIT
operator|)
operator|)
operator|==
operator|(
name|SYNC_CLOSE
operator||
name|SYNC_WAIT
operator|)
condition|)
block|{
name|XFS_bflush
argument_list|(
name|mp
operator|->
name|m_ddev_targp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_rtdev_targp
condition|)
block|{
name|XFS_bflush
argument_list|(
name|mp
operator|->
name|m_rtdev_targp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|XFS_ERROR
argument_list|(
name|last_error
argument_list|)
return|;
block|}
comment|/*  * xfs_vget - called by DMAPI and NFSD to get vnode from file handle  */
name|STATIC
name|int
name|xfs_vget
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|,
name|xfs_vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|fid_t
modifier|*
name|fidp
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
init|=
name|XFS_BHVTOM
argument_list|(
name|bdp
argument_list|)
decl_stmt|;
name|xfs_fid_t
modifier|*
name|xfid
init|=
operator|(
expr|struct
name|xfs_fid
operator|*
operator|)
name|fidp
decl_stmt|;
name|xfs_inode_t
modifier|*
name|ip
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xfs_ino_t
name|ino
decl_stmt|;
name|unsigned
name|int
name|igen
decl_stmt|;
comment|/* 	 * Invalid.  Since handles can be created in user space and passed in 	 * via gethandle(), this is not cause for a panic. 	 */
if|if
condition|(
name|xfid
operator|->
name|xfs_fid_len
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|xfid
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|xfid
operator|->
name|xfs_fid_len
argument_list|)
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|ino
operator|=
name|xfid
operator|->
name|xfs_fid_ino
expr_stmt|;
name|igen
operator|=
name|xfid
operator|->
name|xfs_fid_gen
expr_stmt|;
comment|/* 	 * NFS can sometimes send requests for ino 0.  Fail them gracefully. 	 */
if|if
condition|(
name|ino
operator|==
literal|0
condition|)
return|return
name|XFS_ERROR
argument_list|(
name|ESTALE
argument_list|)
return|;
name|error
operator|=
name|xfs_iget
argument_list|(
name|mp
argument_list|,
name|NULL
argument_list|,
name|ino
argument_list|,
literal|0
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|,
operator|&
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
block|{
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|EIO
argument_list|)
return|;
block|}
if|if
condition|(
name|ip
operator|->
name|i_d
operator|.
name|di_mode
operator|==
literal|0
operator|||
name|ip
operator|->
name|i_d
operator|.
name|di_gen
operator|!=
name|igen
condition|)
block|{
name|xfs_iput_new
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
return|return
name|XFS_ERROR
argument_list|(
name|ENOENT
argument_list|)
return|;
block|}
operator|*
name|vpp
operator|=
name|XFS_ITOV
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|xfs_iunlock
argument_list|(
name|ip
argument_list|,
name|XFS_ILOCK_SHARED
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
define|#
directive|define
name|MNTOPT_LOGBUFS
value|"logbufs"
comment|/* number of XFS log buffers */
define|#
directive|define
name|MNTOPT_LOGBSIZE
value|"logbsize"
comment|/* size of XFS log buffers */
define|#
directive|define
name|MNTOPT_LOGDEV
value|"logdev"
comment|/* log device */
define|#
directive|define
name|MNTOPT_RTDEV
value|"rtdev"
comment|/* realtime I/O device */
define|#
directive|define
name|MNTOPT_BIOSIZE
value|"biosize"
comment|/* log2 of preferred buffered io size */
define|#
directive|define
name|MNTOPT_WSYNC
value|"wsync"
comment|/* safe-mode nfs compatible mount */
define|#
directive|define
name|MNTOPT_INO64
value|"ino64"
comment|/* force inodes into 64-bit range */
define|#
directive|define
name|MNTOPT_NOALIGN
value|"noalign"
comment|/* turn off stripe alignment */
define|#
directive|define
name|MNTOPT_SWALLOC
value|"swalloc"
comment|/* turn on stripe width allocation */
define|#
directive|define
name|MNTOPT_SUNIT
value|"sunit"
comment|/* data volume stripe unit */
define|#
directive|define
name|MNTOPT_SWIDTH
value|"swidth"
comment|/* data volume stripe width */
define|#
directive|define
name|MNTOPT_NOUUID
value|"nouuid"
comment|/* ignore filesystem UUID */
define|#
directive|define
name|MNTOPT_MTPT
value|"mtpt"
comment|/* filesystem mount point */
define|#
directive|define
name|MNTOPT_GRPID
value|"grpid"
comment|/* group-ID from parent directory */
define|#
directive|define
name|MNTOPT_NOGRPID
value|"nogrpid"
comment|/* group-ID from current process */
define|#
directive|define
name|MNTOPT_BSDGROUPS
value|"bsdgroups"
comment|/* group-ID from parent directory */
define|#
directive|define
name|MNTOPT_SYSVGROUPS
value|"sysvgroups"
comment|/* group-ID from current process */
define|#
directive|define
name|MNTOPT_ALLOCSIZE
value|"allocsize"
comment|/* preferred allocation size */
define|#
directive|define
name|MNTOPT_IHASHSIZE
value|"ihashsize"
comment|/* size of inode hash table */
define|#
directive|define
name|MNTOPT_NORECOVERY
value|"norecovery"
comment|/* don't run XFS recovery */
define|#
directive|define
name|MNTOPT_BARRIER
value|"barrier"
comment|/* use writer barriers for log write and 					 * unwritten extent conversion */
define|#
directive|define
name|MNTOPT_NOBARRIER
value|"nobarrier"
comment|/* .. disable */
define|#
directive|define
name|MNTOPT_OSYNCISOSYNC
value|"osyncisosync"
comment|/* o_sync is REALLY o_sync */
define|#
directive|define
name|MNTOPT_64BITINODE
value|"inode64"
comment|/* inodes can be allocated anywhere */
define|#
directive|define
name|MNTOPT_IKEEP
value|"ikeep"
comment|/* do not free empty inode clusters */
define|#
directive|define
name|MNTOPT_NOIKEEP
value|"noikeep"
comment|/* free empty inode clusters */
define|#
directive|define
name|MNTOPT_LARGEIO
value|"largeio"
comment|/* report large I/O sizes in stat() */
define|#
directive|define
name|MNTOPT_NOLARGEIO
value|"nolargeio"
comment|/* do not report large I/O sizes 					 * in stat(). */
define|#
directive|define
name|MNTOPT_ATTR2
value|"attr2"
comment|/* do use attr2 attribute format */
define|#
directive|define
name|MNTOPT_NOATTR2
value|"noattr2"
comment|/* do not use attr2 attribute format */
define|#
directive|define
name|simple_strtoul
value|strtoul
name|STATIC
name|unsigned
name|long
name|suffix_strtoul
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|char
modifier|*
modifier|*
name|endp
parameter_list|,
name|unsigned
name|int
name|base
parameter_list|)
block|{
name|int
name|last
decl_stmt|,
name|shift_left_factor
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|value
init|=
operator|(
name|char
operator|*
operator|)
name|cp
decl_stmt|;
name|last
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|value
index|[
name|last
index|]
operator|==
literal|'K'
operator|||
name|value
index|[
name|last
index|]
operator|==
literal|'k'
condition|)
block|{
name|shift_left_factor
operator|=
literal|10
expr_stmt|;
name|value
index|[
name|last
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|value
index|[
name|last
index|]
operator|==
literal|'M'
operator|||
name|value
index|[
name|last
index|]
operator|==
literal|'m'
condition|)
block|{
name|shift_left_factor
operator|=
literal|20
expr_stmt|;
name|value
index|[
name|last
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|value
index|[
name|last
index|]
operator|==
literal|'G'
operator|||
name|value
index|[
name|last
index|]
operator|==
literal|'g'
condition|)
block|{
name|shift_left_factor
operator|=
literal|30
expr_stmt|;
name|value
index|[
name|last
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|simple_strtoul
argument_list|(
name|cp
argument_list|,
name|endp
argument_list|,
name|base
argument_list|)
operator|<<
name|shift_left_factor
return|;
block|}
name|STATIC
name|int
name|xfs_parseargs
parameter_list|(
name|struct
name|bhv_desc
modifier|*
name|bhv
parameter_list|,
name|char
modifier|*
name|options
parameter_list|,
name|struct
name|xfs_mount_args
modifier|*
name|args
parameter_list|,
name|int
name|update
parameter_list|)
block|{
name|struct
name|xfs_vfs
modifier|*
name|vfsp
init|=
name|bhvtovfs
argument_list|(
name|bhv
argument_list|)
decl_stmt|;
name|char
modifier|*
name|this_char
decl_stmt|,
modifier|*
name|value
decl_stmt|,
modifier|*
name|eov
decl_stmt|;
name|int
name|dsunit
decl_stmt|,
name|dswidth
decl_stmt|,
name|vol_dsunit
decl_stmt|,
name|vol_dswidth
decl_stmt|;
name|int
name|iosize
decl_stmt|;
name|args
operator|->
name|flags
operator||=
name|XFSMNT_IDELETE
expr_stmt|;
name|args
operator|->
name|flags
operator||=
name|XFSMNT_BARRIER
expr_stmt|;
name|args
operator|->
name|flags2
operator||=
name|XFSMNT2_COMPAT_IOSIZE
expr_stmt|;
if|if
condition|(
operator|!
name|options
condition|)
goto|goto
name|done
goto|;
name|iosize
operator|=
name|dsunit
operator|=
name|dswidth
operator|=
name|vol_dsunit
operator|=
name|vol_dswidth
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|this_char
operator|=
name|strsep
argument_list|(
operator|&
name|options
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|this_char
condition|)
continue|continue;
if|if
condition|(
operator|(
name|value
operator|=
name|index
argument_list|(
name|this_char
argument_list|,
literal|'='
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|value
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_LOGBUFS
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
operator|||
operator|!
operator|*
name|value
condition|)
block|{
name|printf
argument_list|(
literal|"XFS: %s option requires an argument\n"
argument_list|,
name|this_char
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|args
operator|->
name|logbufs
operator|=
name|simple_strtoul
argument_list|(
name|value
argument_list|,
operator|&
name|eov
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_LOGBSIZE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
operator|||
operator|!
operator|*
name|value
condition|)
block|{
name|printf
argument_list|(
literal|"XFS: %s option requires an argument\n"
argument_list|,
name|this_char
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|args
operator|->
name|logbufsize
operator|=
name|suffix_strtoul
argument_list|(
name|value
argument_list|,
operator|&
name|eov
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_LOGDEV
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
operator|||
operator|!
operator|*
name|value
condition|)
block|{
name|printf
argument_list|(
literal|"XFS: %s option requires an argument\n"
argument_list|,
name|this_char
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|strncpy
argument_list|(
name|args
operator|->
name|logname
argument_list|,
name|value
argument_list|,
name|MAXNAMELEN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_MTPT
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
operator|||
operator|!
operator|*
name|value
condition|)
block|{
name|printf
argument_list|(
literal|"XFS: %s option requires an argument\n"
argument_list|,
name|this_char
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|strncpy
argument_list|(
name|args
operator|->
name|mtpt
argument_list|,
name|value
argument_list|,
name|MAXNAMELEN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_RTDEV
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
operator|||
operator|!
operator|*
name|value
condition|)
block|{
name|printf
argument_list|(
literal|"XFS: %s option requires an argument\n"
argument_list|,
name|this_char
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|strncpy
argument_list|(
name|args
operator|->
name|rtname
argument_list|,
name|value
argument_list|,
name|MAXNAMELEN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_BIOSIZE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
operator|||
operator|!
operator|*
name|value
condition|)
block|{
name|printf
argument_list|(
literal|"XFS: %s option requires an argument\n"
argument_list|,
name|this_char
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|iosize
operator|=
name|simple_strtoul
argument_list|(
name|value
argument_list|,
operator|&
name|eov
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|args
operator|->
name|flags
operator||=
name|XFSMNT_IOSIZE
expr_stmt|;
name|args
operator|->
name|iosizelog
operator|=
operator|(
name|uint8_t
operator|)
name|iosize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_ALLOCSIZE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
operator|||
operator|!
operator|*
name|value
condition|)
block|{
name|printk
argument_list|(
literal|"XFS: %s option requires an argument\n"
argument_list|,
name|this_char
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|iosize
operator|=
name|suffix_strtoul
argument_list|(
name|value
argument_list|,
operator|&
name|eov
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|args
operator|->
name|flags
operator||=
name|XFSMNT_IOSIZE
expr_stmt|;
name|args
operator|->
name|iosizelog
operator|=
name|ffs
argument_list|(
name|iosize
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_IHASHSIZE
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
operator|||
operator|!
operator|*
name|value
condition|)
block|{
name|printk
argument_list|(
literal|"XFS: %s option requires an argument\n"
argument_list|,
name|this_char
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|args
operator|->
name|flags
operator||=
name|XFSMNT_IHASHSIZE
expr_stmt|;
name|args
operator|->
name|ihashsize
operator|=
name|simple_strtoul
argument_list|(
name|value
argument_list|,
operator|&
name|eov
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_GRPID
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_BSDGROUPS
argument_list|)
condition|)
block|{
name|vfsp
operator|->
name|vfs_flag
operator||=
name|VFS_GRPID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_NOGRPID
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_SYSVGROUPS
argument_list|)
condition|)
block|{
name|vfsp
operator|->
name|vfs_flag
operator|&=
operator|~
name|VFS_GRPID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_WSYNC
argument_list|)
condition|)
block|{
name|args
operator|->
name|flags
operator||=
name|XFSMNT_WSYNC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_OSYNCISOSYNC
argument_list|)
condition|)
block|{
name|args
operator|->
name|flags
operator||=
name|XFSMNT_OSYNCISOSYNC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_NORECOVERY
argument_list|)
condition|)
block|{
name|args
operator|->
name|flags
operator||=
name|XFSMNT_NORECOVERY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_INO64
argument_list|)
condition|)
block|{
name|args
operator|->
name|flags
operator||=
name|XFSMNT_INO64
expr_stmt|;
if|#
directive|if
operator|!
name|XFS_BIG_INUMS
name|printf
argument_list|(
literal|"XFS: %s option not allowed on this system\n"
argument_list|,
name|this_char
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_NOALIGN
argument_list|)
condition|)
block|{
name|args
operator|->
name|flags
operator||=
name|XFSMNT_NOALIGN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_SWALLOC
argument_list|)
condition|)
block|{
name|args
operator|->
name|flags
operator||=
name|XFSMNT_SWALLOC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_SUNIT
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
operator|||
operator|!
operator|*
name|value
condition|)
block|{
name|printf
argument_list|(
literal|"XFS: %s option requires an argument\n"
argument_list|,
name|this_char
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|dsunit
operator|=
name|simple_strtoul
argument_list|(
name|value
argument_list|,
operator|&
name|eov
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_SWIDTH
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|value
operator|||
operator|!
operator|*
name|value
condition|)
block|{
name|printf
argument_list|(
literal|"XFS: %s option requires an argument\n"
argument_list|,
name|this_char
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|dswidth
operator|=
name|simple_strtoul
argument_list|(
name|value
argument_list|,
operator|&
name|eov
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_64BITINODE
argument_list|)
condition|)
block|{
name|args
operator|->
name|flags
operator|&=
operator|~
name|XFSMNT_32BITINODES
expr_stmt|;
if|#
directive|if
operator|!
name|XFS_BIG_INUMS
name|printf
argument_list|(
literal|"XFS: %s option not allowed on this system\n"
argument_list|,
name|this_char
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_NOUUID
argument_list|)
condition|)
block|{
name|args
operator|->
name|flags
operator||=
name|XFSMNT_NOUUID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_BARRIER
argument_list|)
condition|)
block|{
name|args
operator|->
name|flags
operator||=
name|XFSMNT_BARRIER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_NOBARRIER
argument_list|)
condition|)
block|{
name|args
operator|->
name|flags
operator|&=
operator|~
name|XFSMNT_BARRIER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_IKEEP
argument_list|)
condition|)
block|{
name|args
operator|->
name|flags
operator|&=
operator|~
name|XFSMNT_IDELETE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_NOIKEEP
argument_list|)
condition|)
block|{
name|args
operator|->
name|flags
operator||=
name|XFSMNT_IDELETE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_LARGEIO
argument_list|)
condition|)
block|{
name|args
operator|->
name|flags2
operator|&=
operator|~
name|XFSMNT2_COMPAT_IOSIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_NOLARGEIO
argument_list|)
condition|)
block|{
name|args
operator|->
name|flags2
operator||=
name|XFSMNT2_COMPAT_IOSIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_ATTR2
argument_list|)
condition|)
block|{
name|args
operator|->
name|flags
operator||=
name|XFSMNT_ATTR2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
name|MNTOPT_NOATTR2
argument_list|)
condition|)
block|{
name|args
operator|->
name|flags
operator|&=
operator|~
name|XFSMNT_ATTR2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
literal|"osyncisdsync"
argument_list|)
condition|)
block|{
comment|/* no-op, this is now the default */
name|printf
argument_list|(
literal|"XFS: osyncisdsync is now the default, option is deprecated.\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|this_char
argument_list|,
literal|"irixsgid"
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"XFS: irixsgid is now a sysctl(2) variable, option is deprecated.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"XFS: unknown mount option [%s].\n"
argument_list|,
name|this_char
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
if|if
condition|(
name|args
operator|->
name|flags
operator|&
name|XFSMNT_NORECOVERY
condition|)
block|{
if|if
condition|(
operator|(
name|vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
operator|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"XFS: no-recovery mounts must be read-only.\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
if|if
condition|(
operator|(
name|args
operator|->
name|flags
operator|&
name|XFSMNT_NOALIGN
operator|)
operator|&&
operator|(
name|dsunit
operator|||
name|dswidth
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"XFS: sunit and swidth options incompatible with the noalign option\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
operator|(
name|dsunit
operator|&&
operator|!
name|dswidth
operator|)
operator|||
operator|(
operator|!
name|dsunit
operator|&&
name|dswidth
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"XFS: sunit and swidth must be specified together\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|dsunit
operator|&&
operator|(
name|dswidth
operator|%
name|dsunit
operator|!=
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"XFS: stripe width (%d) must be a multiple of the stripe unit (%d)\n"
argument_list|,
name|dswidth
argument_list|,
name|dsunit
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
operator|(
name|args
operator|->
name|flags
operator|&
name|XFSMNT_NOALIGN
operator|)
operator|!=
name|XFSMNT_NOALIGN
condition|)
block|{
if|if
condition|(
name|dsunit
condition|)
block|{
name|args
operator|->
name|sunit
operator|=
name|dsunit
expr_stmt|;
name|args
operator|->
name|flags
operator||=
name|XFSMNT_RETERR
expr_stmt|;
block|}
else|else
block|{
name|args
operator|->
name|sunit
operator|=
name|vol_dsunit
expr_stmt|;
block|}
name|dswidth
condition|?
operator|(
name|args
operator|->
name|swidth
operator|=
name|dswidth
operator|)
else|:
operator|(
name|args
operator|->
name|swidth
operator|=
name|vol_dswidth
operator|)
expr_stmt|;
block|}
else|else
block|{
name|args
operator|->
name|sunit
operator|=
name|args
operator|->
name|swidth
operator|=
literal|0
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|args
operator|->
name|flags
operator|&
name|XFSMNT_32BITINODES
condition|)
name|vfsp
operator|->
name|vfs_flag
operator||=
name|VFS_32BITINODES
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|flags2
condition|)
name|args
operator|->
name|flags
operator||=
name|XFSMNT_FLAGS2
expr_stmt|;
return|return
literal|0
return|;
block|}
define|#
directive|define
name|seq_printf
value|sbuf_printf
name|STATIC
name|int
name|xfs_showargs
parameter_list|(
name|struct
name|bhv_desc
modifier|*
name|bhv
parameter_list|,
name|struct
name|sbuf
modifier|*
name|m
parameter_list|)
block|{
specifier|static
struct|struct
name|proc_xfs_info
block|{
name|int
name|flag
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|}
name|xfs_info
index|[]
init|=
block|{
comment|/* the few simple ones we can get from the mount struct */
block|{
name|XFS_MOUNT_WSYNC
block|,
literal|","
name|MNTOPT_WSYNC
block|}
block|,
block|{
name|XFS_MOUNT_INO64
block|,
literal|","
name|MNTOPT_INO64
block|}
block|,
block|{
name|XFS_MOUNT_NOALIGN
block|,
literal|","
name|MNTOPT_NOALIGN
block|}
block|,
block|{
name|XFS_MOUNT_SWALLOC
block|,
literal|","
name|MNTOPT_SWALLOC
block|}
block|,
block|{
name|XFS_MOUNT_NOUUID
block|,
literal|","
name|MNTOPT_NOUUID
block|}
block|,
block|{
name|XFS_MOUNT_NORECOVERY
block|,
literal|","
name|MNTOPT_NORECOVERY
block|}
block|,
block|{
name|XFS_MOUNT_OSYNCISOSYNC
block|,
literal|","
name|MNTOPT_OSYNCISOSYNC
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
struct|;
name|struct
name|proc_xfs_info
modifier|*
name|xfs_infop
decl_stmt|;
name|struct
name|xfs_mount
modifier|*
name|mp
init|=
name|XFS_BHVTOM
argument_list|(
name|bhv
argument_list|)
decl_stmt|;
name|struct
name|xfs_vfs
modifier|*
name|vfsp
init|=
name|XFS_MTOVFS
argument_list|(
name|mp
argument_list|)
decl_stmt|;
for|for
control|(
name|xfs_infop
operator|=
name|xfs_info
init|;
name|xfs_infop
operator|->
name|flag
condition|;
name|xfs_infop
operator|++
control|)
block|{
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|xfs_infop
operator|->
name|flag
condition|)
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|"%s"
argument_list|,
name|xfs_infop
operator|->
name|str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_IHASHSIZE
condition|)
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|","
name|MNTOPT_IHASHSIZE
literal|"=%d"
argument_list|,
name|mp
operator|->
name|m_ihsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_DFLT_IOSIZE
condition|)
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|","
name|MNTOPT_ALLOCSIZE
literal|"=%dk"
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|1
operator|<<
name|mp
operator|->
name|m_writeio_log
argument_list|)
operator|>>
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_logbufs
operator|>
literal|0
condition|)
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|","
name|MNTOPT_LOGBUFS
literal|"=%d"
argument_list|,
name|mp
operator|->
name|m_logbufs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_logbsize
operator|>
literal|0
condition|)
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|","
name|MNTOPT_LOGBSIZE
literal|"=%dk"
argument_list|,
name|mp
operator|->
name|m_logbsize
operator|>>
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_logname
condition|)
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|","
name|MNTOPT_LOGDEV
literal|"=%s"
argument_list|,
name|mp
operator|->
name|m_logname
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_rtname
condition|)
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|","
name|MNTOPT_RTDEV
literal|"=%s"
argument_list|,
name|mp
operator|->
name|m_rtname
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_dalign
operator|>
literal|0
condition|)
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|","
name|MNTOPT_SUNIT
literal|"=%d"
argument_list|,
operator|(
name|int
operator|)
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_dalign
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_swidth
operator|>
literal|0
condition|)
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|","
name|MNTOPT_SWIDTH
literal|"=%d"
argument_list|,
operator|(
name|int
operator|)
name|XFS_FSB_TO_BB
argument_list|(
name|mp
argument_list|,
name|mp
operator|->
name|m_swidth
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_IDELETE
operator|)
condition|)
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|","
name|MNTOPT_IKEEP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mp
operator|->
name|m_flags
operator|&
name|XFS_MOUNT_COMPAT_IOSIZE
operator|)
condition|)
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|","
name|MNTOPT_LARGEIO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_32BITINODES
operator|)
condition|)
name|sbuf_printf
argument_list|(
name|m
argument_list|,
literal|","
name|MNTOPT_64BITINODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_GRPID
condition|)
name|seq_printf
argument_list|(
name|m
argument_list|,
literal|","
name|MNTOPT_GRPID
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|STATIC
name|void
name|xfs_freeze
parameter_list|(
name|bhv_desc_t
modifier|*
name|bdp
parameter_list|)
block|{
name|xfs_mount_t
modifier|*
name|mp
init|=
name|XFS_BHVTOM
argument_list|(
name|bdp
argument_list|)
decl_stmt|;
while|while
condition|(
name|atomic_read
argument_list|(
operator|&
name|mp
operator|->
name|m_active_trans
argument_list|)
operator|>
literal|0
condition|)
name|delay
argument_list|(
literal|100
argument_list|)
expr_stmt|;
comment|/* Push the superblock and write an unmount record */
name|xfs_log_unmount_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|xfs_unmountfs_writesb
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|xfs_fs_log_dummy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
name|xvfsops_t
name|xfs_vfsops
init|=
block|{
name|BHV_IDENTITY_INIT
argument_list|(
name|VFS_BHV_XFS
argument_list|,
name|VFS_POSITION_XFS
argument_list|)
block|,
operator|.
name|xvfs_parseargs
operator|=
name|xfs_parseargs
block|,
operator|.
name|xvfs_showargs
operator|=
name|xfs_showargs
block|,
operator|.
name|xvfs_mount
operator|=
name|xfs_mount
block|,
operator|.
name|xvfs_unmount
operator|=
name|xfs_unmount
block|,
operator|.
name|xvfs_mntupdate
operator|=
name|xfs_mntupdate
block|,
operator|.
name|xvfs_root
operator|=
name|xfs_root
block|,
operator|.
name|xvfs_statvfs
operator|=
name|xfs_statvfs
block|,
operator|.
name|xvfs_sync
operator|=
name|xfs_sync
block|,
operator|.
name|xvfs_vget
operator|=
name|xfs_vget
block|,
operator|.
name|xvfs_dmapiops
operator|=
operator|(
name|xvfs_dmapiops_t
operator|)
name|fs_nosys
block|,
operator|.
name|xvfs_quotactl
operator|=
operator|(
name|xvfs_quotactl_t
operator|)
name|fs_nosys
block|,
operator|.
name|xvfs_get_inode
operator|=
operator|(
name|xvfs_get_inode_t
operator|)
name|fs_nosys
block|,
operator|.
name|xvfs_init_vnode
operator|=
name|xfs_initialize_vnode
block|,
operator|.
name|xvfs_force_shutdown
operator|=
name|xfs_do_force_shutdown
block|,
operator|.
name|xvfs_freeze
operator|=
name|xfs_freeze
block|, }
decl_stmt|;
end_function

end_unit

