begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_ALPHA_BITOPS_H
end_ifndef

begin_define
define|#
directive|define
name|_ALPHA_BITOPS_H
end_define

begin_comment
comment|/*  * Copyright 1994, Linus Torvalds.  */
end_comment

begin_comment
comment|/*  * These have to be done with inline assembly: that way the bit-setting  * is guaranteed to be atomic. All bit operations return 0 if the bit  * was cleared before the operation and != 0 if it was not.  *  * To get proper branch prediction for the main line, we must branch  * forward to code at the end of this object's .text section, then  * branch back to restart the operation.  *  * bit 0 is the LSB of addr; bit 64 is the LSB of (addr+1).  */
end_comment

begin_function_decl
specifier|static
name|__inline
name|unsigned
name|int
name|set_bit
parameter_list|(
name|unsigned
name|long
parameter_list|,
specifier|volatile
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|unsigned
name|int
name|clear_bit
parameter_list|(
name|unsigned
name|long
parameter_list|,
specifier|volatile
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|unsigned
name|int
name|change_bit
parameter_list|(
name|unsigned
name|long
parameter_list|,
specifier|volatile
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|unsigned
name|int
name|test_bit
parameter_list|(
name|int
parameter_list|,
specifier|volatile
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|unsigned
name|long
name|ffz_b
parameter_list|(
name|unsigned
name|long
name|x
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|unsigned
name|long
name|ffz
parameter_list|(
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* static __inline int ffs(int); */
end_comment

begin_function_decl
specifier|static
name|__inline
name|void
modifier|*
name|memscan
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|__alpha_cix__
end_ifdef

begin_function_decl
specifier|static
name|__inline
name|unsigned
name|long
name|hweight64
parameter_list|(
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|__inline
name|unsigned
name|long
name|find_next_zero_bit
parameter_list|(
name|void
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|unsigned
name|int
name|set_bit
parameter_list|(
name|unsigned
name|long
name|nr
parameter_list|,
specifier|volatile
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|unsigned
name|long
name|oldbit
decl_stmt|;
name|unsigned
name|long
name|temp
decl_stmt|;
specifier|volatile
name|unsigned
name|int
modifier|*
name|m
init|=
operator|(
operator|(
specifier|volatile
name|unsigned
name|int
operator|*
operator|)
name|addr
operator|)
operator|+
operator|(
name|nr
operator|>>
literal|5
operator|)
decl_stmt|;
asm|__asm__
specifier|__volatile__
asm|( 	"1:	ldl_l %0,%1\n" 	"	and %0,%3,%2\n" 	"	bne %2,2f\n" 	"	xor %0,%3,%0\n" 	"	stl_c %0,%1\n" 	"	beq %0,3f\n" 	"2:\n" 	".section .text2,\"ax\"\n" 	"3:	br 1b\n" 	".previous" 	:"=&r" (temp), "=m" (*m), "=&r" (oldbit) 	:"Ir" (1UL<< (nr& 31)), "m" (*m));
return|return
name|oldbit
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|unsigned
name|int
name|clear_bit
parameter_list|(
name|unsigned
name|long
name|nr
parameter_list|,
specifier|volatile
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|unsigned
name|long
name|oldbit
decl_stmt|;
name|unsigned
name|long
name|temp
decl_stmt|;
specifier|volatile
name|unsigned
name|int
modifier|*
name|m
init|=
operator|(
operator|(
specifier|volatile
name|unsigned
name|int
operator|*
operator|)
name|addr
operator|)
operator|+
operator|(
name|nr
operator|>>
literal|5
operator|)
decl_stmt|;
asm|__asm__
specifier|__volatile__
asm|( 	"1:	ldl_l %0,%1\n" 	"	and %0,%3,%2\n" 	"	beq %2,2f\n" 	"	xor %0,%3,%0\n" 	"	stl_c %0,%1\n" 	"	beq %0,3f\n" 	"2:\n" 	".section .text2,\"ax\"\n" 	"3:	br 1b\n" 	".previous" 	:"=&r" (temp), "=m" (*m), "=&r" (oldbit) 	:"Ir" (1UL<< (nr& 31)), "m" (*m));
return|return
name|oldbit
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|unsigned
name|int
name|change_bit
parameter_list|(
name|unsigned
name|long
name|nr
parameter_list|,
specifier|volatile
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|unsigned
name|long
name|oldbit
decl_stmt|;
name|unsigned
name|long
name|temp
decl_stmt|;
specifier|volatile
name|unsigned
name|int
modifier|*
name|m
init|=
operator|(
operator|(
specifier|volatile
name|unsigned
name|int
operator|*
operator|)
name|addr
operator|)
operator|+
operator|(
name|nr
operator|>>
literal|5
operator|)
decl_stmt|;
asm|__asm__
specifier|__volatile__
asm|( 	"1:	ldl_l %0,%1\n" 	"	xor %0,%2,%0\n" 	"	stl_c %0,%1\n" 	"	beq %0,3f\n" 	".section .text2,\"ax\"\n" 	"3:	br 1b\n" 	".previous" 	:"=&r" (temp), "=m" (*m), "=&r" (oldbit) 	:"Ir" (1UL<< (nr& 31)), "m" (*m));
return|return
name|oldbit
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|unsigned
name|int
name|test_bit
parameter_list|(
name|int
name|nr
parameter_list|,
specifier|volatile
name|void
modifier|*
name|addr
parameter_list|)
block|{
return|return
literal|1UL
operator|&
operator|(
operator|(
operator|(
specifier|volatile
name|int
operator|*
operator|)
name|addr
operator|)
index|[
name|nr
operator|>>
literal|5
index|]
operator|>>
operator|(
name|nr
operator|&
literal|31
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ffz = Find First Zero in word. Undefined if no zero exists,  * so code should check against ~0UL first..  *  * Do a binary search on the bits.  Due to the nature of large  * constants on the alpha, it is worthwhile to split the search.  */
end_comment

begin_function
specifier|static
name|__inline
name|unsigned
name|long
name|ffz_b
parameter_list|(
name|unsigned
name|long
name|x
parameter_list|)
block|{
name|unsigned
name|long
name|sum
init|=
literal|0
decl_stmt|;
name|x
operator|=
operator|~
name|x
operator|&
operator|-
operator|~
name|x
expr_stmt|;
comment|/* set first 0 bit, clear others */
if|if
condition|(
name|x
operator|&
literal|0xF0
condition|)
name|sum
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|x
operator|&
literal|0xCC
condition|)
name|sum
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|x
operator|&
literal|0xAA
condition|)
name|sum
operator|+=
literal|1
expr_stmt|;
return|return
name|sum
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|unsigned
name|long
name|ffz
parameter_list|(
name|unsigned
name|long
name|word
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__alpha_cix__
comment|/* Whee.  EV6 can calculate it directly.  */
name|unsigned
name|long
name|result
decl_stmt|;
asm|__asm__("ctlz %1,%0" : "=r"(result) : "r"(~word));
return|return
name|result
return|;
else|#
directive|else
name|unsigned
name|long
name|bits
decl_stmt|,
name|qofs
decl_stmt|,
name|bofs
decl_stmt|;
asm|__asm__("cmpbge %1,%2,%0" : "=r"(bits) : "r"(word), "r"(~0UL));
name|qofs
operator|=
name|ffz_b
argument_list|(
name|bits
argument_list|)
expr_stmt|;
asm|__asm__("extbl %1,%2,%0" : "=r"(bits) : "r"(word), "r"(qofs));
name|bofs
operator|=
name|ffz_b
argument_list|(
name|bits
argument_list|)
expr_stmt|;
return|return
name|qofs
operator|*
literal|8
operator|+
name|bofs
return|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__KERNEL__
end_ifdef

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * ffs: find first bit set. This is defined the same way as  * the libc and compiler builtin ffs routines, therefore  * differs in spirit from the above ffz (man ffs).  */
end_comment

begin_endif
unit|static __inline int ffs(int word) { 	int result = ffz(~word); 	return word ? result+1 : 0; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * hweightN: returns the hamming weight (i.e. the number  * of bits set) of a N-bit word  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__alpha_cix__
end_ifdef

begin_comment
comment|/* Whee.  EV6 can calculate it directly.  */
end_comment

begin_function
specifier|static
name|__inline
name|unsigned
name|long
name|hweight64
parameter_list|(
name|unsigned
name|long
name|w
parameter_list|)
block|{
name|unsigned
name|long
name|result
decl_stmt|;
asm|__asm__("ctpop %1,%0" : "=r"(result) : "r"(w));
return|return
name|result
return|;
block|}
end_function

begin_define
define|#
directive|define
name|hweight32
parameter_list|(
name|x
parameter_list|)
value|hweight64((x)& 0xfffffffful)
end_define

begin_define
define|#
directive|define
name|hweight16
parameter_list|(
name|x
parameter_list|)
value|hweight64((x)& 0xfffful)
end_define

begin_define
define|#
directive|define
name|hweight8
parameter_list|(
name|x
parameter_list|)
value|hweight64((x)& 0xfful)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|hweight32
parameter_list|(
name|x
parameter_list|)
value|generic_hweight32(x)
end_define

begin_define
define|#
directive|define
name|hweight16
parameter_list|(
name|x
parameter_list|)
value|generic_hweight16(x)
end_define

begin_define
define|#
directive|define
name|hweight8
parameter_list|(
name|x
parameter_list|)
value|generic_hweight8(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __alpha_cix__ */
end_comment

begin_comment
comment|/* from lib/string.c */
end_comment

begin_function
specifier|static
name|__inline
name|void
modifier|*
name|memscan
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|c
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|addr
decl_stmt|;
while|while
condition|(
name|size
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
name|c
condition|)
return|return
operator|(
name|void
operator|*
operator|)
name|p
return|;
name|p
operator|++
expr_stmt|;
name|size
operator|--
expr_stmt|;
block|}
return|return
operator|(
name|void
operator|*
operator|)
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * Find next zero bit in a bitmap reasonably efficiently..  */
end_comment

begin_function
specifier|static
name|__inline
name|unsigned
name|long
name|find_next_zero_bit
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|)
block|{
name|unsigned
name|long
modifier|*
name|p
init|=
operator|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|addr
operator|)
operator|+
operator|(
name|offset
operator|>>
literal|6
operator|)
decl_stmt|;
name|unsigned
name|long
name|result
init|=
name|offset
operator|&
operator|~
literal|63UL
decl_stmt|;
name|unsigned
name|long
name|tmp
decl_stmt|;
if|if
condition|(
name|offset
operator|>=
name|size
condition|)
return|return
name|size
return|;
name|size
operator|-=
name|result
expr_stmt|;
name|offset
operator|&=
literal|63UL
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
name|tmp
operator|=
operator|*
operator|(
name|p
operator|++
operator|)
expr_stmt|;
name|tmp
operator||=
operator|~
literal|0UL
operator|>>
operator|(
literal|64
operator|-
name|offset
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|64
condition|)
goto|goto
name|found_first
goto|;
if|if
condition|(
operator|~
name|tmp
condition|)
goto|goto
name|found_middle
goto|;
name|size
operator|-=
literal|64
expr_stmt|;
name|result
operator|+=
literal|64
expr_stmt|;
block|}
while|while
condition|(
name|size
operator|&
operator|~
literal|63UL
condition|)
block|{
if|if
condition|(
operator|~
operator|(
name|tmp
operator|=
operator|*
operator|(
name|p
operator|++
operator|)
operator|)
condition|)
goto|goto
name|found_middle
goto|;
name|result
operator|+=
literal|64
expr_stmt|;
name|size
operator|-=
literal|64
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|size
condition|)
return|return
name|result
return|;
name|tmp
operator|=
operator|*
name|p
expr_stmt|;
name|found_first
label|:
name|tmp
operator||=
operator|~
literal|0UL
operator|<<
name|size
expr_stmt|;
name|found_middle
label|:
return|return
name|result
operator|+
name|ffz
argument_list|(
name|tmp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * The optimizer actually does good code for this case..  */
end_comment

begin_define
define|#
directive|define
name|find_first_zero_bit
parameter_list|(
name|addr
parameter_list|,
name|size
parameter_list|)
define|\
value|find_next_zero_bit((addr), (size), 0)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__KERNEL__
end_ifdef

begin_define
define|#
directive|define
name|ext2_set_bit
value|test_and_set_bit
end_define

begin_define
define|#
directive|define
name|ext2_clear_bit
value|test_and_clear_bit
end_define

begin_define
define|#
directive|define
name|ext2_test_bit
value|test_bit
end_define

begin_define
define|#
directive|define
name|ext2_find_first_zero_bit
value|find_first_zero_bit
end_define

begin_define
define|#
directive|define
name|ext2_find_next_zero_bit
value|find_next_zero_bit
end_define

begin_comment
comment|/* Bitmap functions for the minix filesystem.  */
end_comment

begin_define
define|#
directive|define
name|minix_set_bit
parameter_list|(
name|nr
parameter_list|,
name|addr
parameter_list|)
value|test_and_set_bit(nr,addr)
end_define

begin_define
define|#
directive|define
name|minix_clear_bit
parameter_list|(
name|nr
parameter_list|,
name|addr
parameter_list|)
value|test_and_clear_bit(nr,addr)
end_define

begin_define
define|#
directive|define
name|minix_test_bit
parameter_list|(
name|nr
parameter_list|,
name|addr
parameter_list|)
value|test_bit(nr,addr)
end_define

begin_define
define|#
directive|define
name|minix_find_first_zero_bit
parameter_list|(
name|addr
parameter_list|,
name|size
parameter_list|)
value|find_first_zero_bit(addr,size)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __KERNEL__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _ALPHA_BITOPS_H */
end_comment

end_unit

