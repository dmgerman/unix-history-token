begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  modified for Lites 1.1  *  *  Aug 1995, Godmar Back (gback@cs.utah.edu)  *  University of Utah, Department of Computer Science  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)ext2_alloc.c	8.8 (Berkeley) 2/21/94  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_quota.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/extattr.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/quota.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/inode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufsmount.h>
end_include

begin_include
include|#
directive|include
file|<gnu/ext2fs/ext2_fs.h>
end_include

begin_include
include|#
directive|include
file|<gnu/ext2fs/ext2_fs_sb.h>
end_include

begin_include
include|#
directive|include
file|<gnu/ext2fs/fs.h>
end_include

begin_include
include|#
directive|include
file|<gnu/ext2fs/ext2_extern.h>
end_include

begin_decl_stmt
specifier|static
name|void
name|ext2_fserr
name|__P
argument_list|(
operator|(
expr|struct
name|ext2_sb_info
operator|*
operator|,
name|u_int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Linux calls this functions at the following locations:  * (1) the inode is freed  * (2) a preallocation miss occurs  * (3) truncate is called  * (4) release_file is called and f_mode& 2  *  * I call it in ext2_inactive, ext2_truncate, ext2_vfree and in (2)  * the call in vfree might be redundant  */
end_comment

begin_function
name|void
name|ext2_discard_prealloc
parameter_list|(
name|ip
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|EXT2_PREALLOCATE
if|if
condition|(
name|ip
operator|->
name|i_prealloc_count
condition|)
block|{
name|int
name|i
init|=
name|ip
operator|->
name|i_prealloc_count
decl_stmt|;
name|ip
operator|->
name|i_prealloc_count
operator|=
literal|0
expr_stmt|;
name|ext2_free_blocks
argument_list|(
name|ITOV
argument_list|(
name|ip
argument_list|)
operator|->
name|v_mount
argument_list|,
name|ip
operator|->
name|i_prealloc_block
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Allocate a block in the file system.  *   * this takes the framework from ffs_alloc. To implement the  * actual allocation, it calls ext2_new_block, the ported version  * of the same Linux routine.  *  * we note that this is always called in connection with ext2_blkpref  *  * preallocation is done as Linux does it  */
end_comment

begin_function
name|int
name|ext2_alloc
parameter_list|(
name|ip
parameter_list|,
name|lbn
parameter_list|,
name|bpref
parameter_list|,
name|size
parameter_list|,
name|cred
parameter_list|,
name|bnp
parameter_list|)
specifier|register
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|daddr_t
name|lbn
decl_stmt|,
name|bpref
decl_stmt|;
name|int
name|size
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|daddr_t
modifier|*
name|bnp
decl_stmt|;
block|{
specifier|register
name|struct
name|ext2_sb_info
modifier|*
name|fs
decl_stmt|;
name|daddr_t
name|bno
decl_stmt|;
if|#
directive|if
name|QUOTA
name|int
name|error
decl_stmt|;
endif|#
directive|endif
operator|*
name|bnp
operator|=
literal|0
expr_stmt|;
name|fs
operator|=
name|ip
operator|->
name|i_e2fs
expr_stmt|;
if|#
directive|if
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|u_int
operator|)
name|size
operator|>
name|fs
operator|->
name|s_blocksize
operator|||
name|blkoff
argument_list|(
name|fs
argument_list|,
name|size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"dev = %s, bsize = %lu, size = %d, fs = %s\n"
argument_list|,
name|devtoname
argument_list|(
name|ip
operator|->
name|i_dev
argument_list|)
argument_list|,
name|fs
operator|->
name|s_blocksize
argument_list|,
name|size
argument_list|,
name|fs
operator|->
name|fs_fsmnt
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"ext2_alloc: bad size"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cred
operator|==
name|NOCRED
condition|)
name|panic
argument_list|(
literal|"ext2_alloc: missing credential"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DIAGNOSTIC */
if|if
condition|(
name|size
operator|==
name|fs
operator|->
name|s_blocksize
operator|&&
name|fs
operator|->
name|s_es
operator|->
name|s_free_blocks_count
operator|==
literal|0
condition|)
goto|goto
name|nospace
goto|;
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|!=
literal|0
operator|&&
name|fs
operator|->
name|s_es
operator|->
name|s_free_blocks_count
operator|<
name|fs
operator|->
name|s_es
operator|->
name|s_r_blocks_count
condition|)
goto|goto
name|nospace
goto|;
if|#
directive|if
name|QUOTA
if|if
condition|(
operator|(
name|error
operator|=
name|chkdq
argument_list|(
name|ip
argument_list|,
operator|(
name|long
operator|)
name|btodb
argument_list|(
name|size
argument_list|)
argument_list|,
name|cred
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
name|bpref
operator|>=
name|fs
operator|->
name|s_es
operator|->
name|s_blocks_count
condition|)
name|bpref
operator|=
literal|0
expr_stmt|;
comment|/* call the Linux code */
ifdef|#
directive|ifdef
name|EXT2_PREALLOCATE
comment|/* To have a preallocation hit, we must 	 * - have at least one block preallocated 	 * - and our preferred block must have that block number or one below 	 */
if|if
condition|(
name|ip
operator|->
name|i_prealloc_count
operator|&&
operator|(
name|bpref
operator|==
name|ip
operator|->
name|i_prealloc_block
operator|||
name|bpref
operator|+
literal|1
operator|==
name|ip
operator|->
name|i_prealloc_block
operator|)
condition|)
block|{
name|bno
operator|=
name|ip
operator|->
name|i_prealloc_block
operator|++
expr_stmt|;
name|ip
operator|->
name|i_prealloc_count
operator|--
expr_stmt|;
comment|/* ext2_debug ("preallocation hit (%lu/%lu).\n",                             ++alloc_hits, ++alloc_attempts); */
comment|/* Linux gets, clears, and releases the buffer at this 		   point - we don't have to that; we leave it to the caller 		 */
block|}
else|else
block|{
name|ext2_discard_prealloc
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* ext2_debug ("preallocation miss (%lu/%lu).\n",                             alloc_hits, ++alloc_attempts); */
if|if
condition|(
name|S_ISREG
argument_list|(
name|ip
operator|->
name|i_mode
argument_list|)
condition|)
name|bno
operator|=
name|ext2_new_block
argument_list|(
name|ITOV
argument_list|(
name|ip
argument_list|)
operator|->
name|v_mount
argument_list|,
name|bpref
argument_list|,
operator|&
name|ip
operator|->
name|i_prealloc_count
argument_list|,
operator|&
name|ip
operator|->
name|i_prealloc_block
argument_list|)
expr_stmt|;
else|else
name|bno
operator|=
operator|(
name|daddr_t
operator|)
name|ext2_new_block
argument_list|(
name|ITOV
argument_list|(
name|ip
argument_list|)
operator|->
name|v_mount
argument_list|,
name|bpref
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|bno
operator|=
operator|(
name|daddr_t
operator|)
name|ext2_new_block
argument_list|(
name|ITOV
argument_list|(
name|ip
argument_list|)
operator|->
name|v_mount
argument_list|,
name|bpref
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bno
operator|>
literal|0
condition|)
block|{
comment|/* set next_alloc fields as done in block_getblk */
name|ip
operator|->
name|i_next_alloc_block
operator|=
name|lbn
expr_stmt|;
name|ip
operator|->
name|i_next_alloc_goal
operator|=
name|bno
expr_stmt|;
name|ip
operator|->
name|i_blocks
operator|+=
name|btodb
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
operator|*
name|bnp
operator|=
name|bno
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|#
directive|if
name|QUOTA
comment|/* 	 * Restore user's disk quota because allocation failed. 	 */
operator|(
name|void
operator|)
name|chkdq
argument_list|(
name|ip
argument_list|,
operator|(
name|long
operator|)
operator|-
name|btodb
argument_list|(
name|size
argument_list|)
argument_list|,
name|cred
argument_list|,
name|FORCE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nospace
label|:
name|ext2_fserr
argument_list|(
name|fs
argument_list|,
name|cred
operator|->
name|cr_uid
argument_list|,
literal|"file system full"
argument_list|)
expr_stmt|;
name|uprintf
argument_list|(
literal|"\n%s: write failed, file system is full\n"
argument_list|,
name|fs
operator|->
name|fs_fsmnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reallocate a sequence of blocks into a contiguous sequence of blocks.  *  * The vnode and an array of buffer pointers for a range of sequential  * logical blocks to be made contiguous is given. The allocator attempts  * to find a range of sequential blocks starting as close as possible to  * an fs_rotdelay offset from the end of the allocation for the logical  * block immediately preceeding the current range. If successful, the  * physical block numbers in the buffer pointers and in the inode are  * changed to reflect the new allocation. If unsuccessful, the allocation  * is left unchanged. The success in doing the reallocation is returned.  * Note that the error return is not reflected back to the user. Rather  * the previous block allocation will be used.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FANCY_REALLOC
end_ifdef

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|doasyncfree
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|OPT_DEBUG
end_ifdef

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
literal|14
argument_list|,
name|doasyncfree
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|doasyncfree
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OPT_DEBUG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|ext2_reallocblks
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_reallocblks_args
comment|/* { 		struct vnode *a_vp; 		struct cluster_save *a_buflist; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|FANCY_REALLOC
comment|/* printf("ext2_reallocblks not implemented\n"); */
return|return
name|ENOSPC
return|;
else|#
directive|else
name|struct
name|ext2_sb_info
modifier|*
name|fs
decl_stmt|;
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|buf
modifier|*
name|sbp
decl_stmt|,
modifier|*
name|ebp
decl_stmt|;
name|daddr_t
modifier|*
name|bap
decl_stmt|,
modifier|*
name|sbap
decl_stmt|,
modifier|*
name|ebap
decl_stmt|;
name|struct
name|cluster_save
modifier|*
name|buflist
decl_stmt|;
name|daddr_t
name|start_lbn
decl_stmt|,
name|end_lbn
decl_stmt|,
name|soff
decl_stmt|,
name|eoff
decl_stmt|,
name|newblk
decl_stmt|,
name|blkno
decl_stmt|;
name|struct
name|indir
name|start_ap
index|[
name|NIADDR
operator|+
literal|1
index|]
decl_stmt|,
name|end_ap
index|[
name|NIADDR
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|idp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|start_lvl
decl_stmt|,
name|end_lvl
decl_stmt|,
name|pref
decl_stmt|,
name|ssize
decl_stmt|;
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
name|ip
operator|=
name|VTOI
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|fs
operator|=
name|ip
operator|->
name|i_e2fs
expr_stmt|;
ifdef|#
directive|ifdef
name|UNKLAR
if|if
condition|(
name|fs
operator|->
name|fs_contigsumsize
operator|<=
literal|0
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
endif|#
directive|endif
name|buflist
operator|=
name|ap
operator|->
name|a_buflist
expr_stmt|;
name|len
operator|=
name|buflist
operator|->
name|bs_nchildren
expr_stmt|;
name|start_lbn
operator|=
name|buflist
operator|->
name|bs_children
index|[
literal|0
index|]
operator|->
name|b_lblkno
expr_stmt|;
name|end_lbn
operator|=
name|start_lbn
operator|+
name|len
operator|-
literal|1
expr_stmt|;
if|#
directive|if
name|DIAGNOSTIC
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|buflist
operator|->
name|bs_children
index|[
name|i
index|]
operator|->
name|b_lblkno
operator|!=
name|start_lbn
operator|+
name|i
condition|)
name|panic
argument_list|(
literal|"ext2_reallocblks: non-cluster"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If the latest allocation is in a new cylinder group, assume that 	 * the filesystem has decided to move and do not force it back to 	 * the previous cylinder group. 	 */
if|if
condition|(
name|dtog
argument_list|(
name|fs
argument_list|,
name|dbtofsb
argument_list|(
name|fs
argument_list|,
name|buflist
operator|->
name|bs_children
index|[
literal|0
index|]
operator|->
name|b_blkno
argument_list|)
argument_list|)
operator|!=
name|dtog
argument_list|(
name|fs
argument_list|,
name|dbtofsb
argument_list|(
name|fs
argument_list|,
name|buflist
operator|->
name|bs_children
index|[
name|len
operator|-
literal|1
index|]
operator|->
name|b_blkno
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
if|if
condition|(
name|ufs_getlbns
argument_list|(
name|vp
argument_list|,
name|start_lbn
argument_list|,
name|start_ap
argument_list|,
operator|&
name|start_lvl
argument_list|)
operator|||
name|ufs_getlbns
argument_list|(
name|vp
argument_list|,
name|end_lbn
argument_list|,
name|end_ap
argument_list|,
operator|&
name|end_lvl
argument_list|)
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* 	 * Get the starting offset and block map for the first block. 	 */
if|if
condition|(
name|start_lvl
operator|==
literal|0
condition|)
block|{
name|sbap
operator|=
operator|&
name|ip
operator|->
name|i_db
index|[
literal|0
index|]
expr_stmt|;
name|soff
operator|=
name|start_lbn
expr_stmt|;
block|}
else|else
block|{
name|idp
operator|=
operator|&
name|start_ap
index|[
name|start_lvl
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|bread
argument_list|(
name|vp
argument_list|,
name|idp
operator|->
name|in_lbn
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|s_blocksize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|sbp
argument_list|)
condition|)
block|{
name|brelse
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|sbap
operator|=
operator|(
name|daddr_t
operator|*
operator|)
name|sbp
operator|->
name|b_data
expr_stmt|;
name|soff
operator|=
name|idp
operator|->
name|in_off
expr_stmt|;
block|}
comment|/* 	 * Find the preferred location for the cluster. 	 */
name|pref
operator|=
name|ext2_blkpref
argument_list|(
name|ip
argument_list|,
name|start_lbn
argument_list|,
name|soff
argument_list|,
name|sbap
argument_list|)
expr_stmt|;
comment|/* 	 * If the block range spans two block maps, get the second map. 	 */
if|if
condition|(
name|end_lvl
operator|==
literal|0
operator|||
operator|(
name|idp
operator|=
operator|&
name|end_ap
index|[
name|end_lvl
operator|-
literal|1
index|]
operator|)
operator|->
name|in_off
operator|+
literal|1
operator|>=
name|len
condition|)
block|{
name|ssize
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|DIAGNOSTIC
if|if
condition|(
name|start_ap
index|[
name|start_lvl
operator|-
literal|1
index|]
operator|.
name|in_lbn
operator|==
name|idp
operator|->
name|in_lbn
condition|)
name|panic
argument_list|(
literal|"ext2_reallocblk: start == end"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ssize
operator|=
name|len
operator|-
operator|(
name|idp
operator|->
name|in_off
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|bread
argument_list|(
name|vp
argument_list|,
name|idp
operator|->
name|in_lbn
argument_list|,
operator|(
name|int
operator|)
name|fs
operator|->
name|s_blocksize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|ebp
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|ebap
operator|=
operator|(
name|daddr_t
operator|*
operator|)
name|ebp
operator|->
name|b_data
expr_stmt|;
block|}
comment|/* 	 * Search the block map looking for an allocation of the desired size. 	 */
if|if
condition|(
operator|(
name|newblk
operator|=
operator|(
name|daddr_t
operator|)
name|ext2_hashalloc
argument_list|(
name|ip
argument_list|,
name|dtog
argument_list|(
name|fs
argument_list|,
name|pref
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|pref
argument_list|,
name|len
argument_list|,
operator|(
name|u_long
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|ext2_clusteralloc
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * We have found a new contiguous block. 	 * 	 * First we have to replace the old block pointers with the new 	 * block pointers in the inode and indirect blocks associated 	 * with the file. 	 */
name|blkno
operator|=
name|newblk
expr_stmt|;
for|for
control|(
name|bap
operator|=
operator|&
name|sbap
index|[
name|soff
index|]
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|blkno
operator|+=
name|fs
operator|->
name|s_frags_per_block
control|)
block|{
if|if
condition|(
name|i
operator|==
name|ssize
condition|)
name|bap
operator|=
name|ebap
expr_stmt|;
if|#
directive|if
name|DIAGNOSTIC
if|if
condition|(
name|buflist
operator|->
name|bs_children
index|[
name|i
index|]
operator|->
name|b_blkno
operator|!=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
operator|*
name|bap
argument_list|)
condition|)
name|panic
argument_list|(
literal|"ext2_reallocblks: alloc mismatch"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|bap
operator|++
operator|=
name|blkno
expr_stmt|;
block|}
comment|/* 	 * Next we must write out the modified inode and indirect blocks. 	 * For strict correctness, the writes should be synchronous since 	 * the old block values may have been written to disk. In practise 	 * they are almost never written, but if we are concerned about  	 * strict correctness, the `doasyncfree' flag should be set to zero. 	 * 	 * The test on `doasyncfree' should be changed to test a flag 	 * that shows whether the associated buffers and inodes have 	 * been written. The flag should be set when the cluster is 	 * started and cleared whenever the buffer or inode is flushed. 	 * We can then check below to see if it is set, and do the 	 * synchronous write only when it has been cleared. 	 */
if|if
condition|(
name|sbap
operator|!=
operator|&
name|ip
operator|->
name|i_db
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|doasyncfree
condition|)
name|bdwrite
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
else|else
name|bwrite
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|->
name|i_flag
operator||=
name|IN_CHANGE
operator||
name|IN_UPDATE
expr_stmt|;
if|if
condition|(
operator|!
name|doasyncfree
condition|)
name|UFS_UPDATE
argument_list|(
name|vp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ssize
operator|<
name|len
condition|)
if|if
condition|(
name|doasyncfree
condition|)
name|bdwrite
argument_list|(
name|ebp
argument_list|)
expr_stmt|;
else|else
name|bwrite
argument_list|(
name|ebp
argument_list|)
expr_stmt|;
comment|/* 	 * Last, free the old blocks and assign the new blocks to the buffers. 	 */
for|for
control|(
name|blkno
operator|=
name|newblk
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|blkno
operator|+=
name|fs
operator|->
name|s_frags_per_block
control|)
block|{
name|ext2_blkfree
argument_list|(
name|ip
argument_list|,
name|dbtofsb
argument_list|(
name|fs
argument_list|,
name|buflist
operator|->
name|bs_children
index|[
name|i
index|]
operator|->
name|b_blkno
argument_list|)
argument_list|,
name|fs
operator|->
name|s_blocksize
argument_list|)
expr_stmt|;
name|buflist
operator|->
name|bs_children
index|[
name|i
index|]
operator|->
name|b_blkno
operator|=
name|fsbtodb
argument_list|(
name|fs
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|ssize
operator|<
name|len
condition|)
name|brelse
argument_list|(
name|ebp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbap
operator|!=
operator|&
name|ip
operator|->
name|i_db
index|[
literal|0
index|]
condition|)
name|brelse
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
endif|#
directive|endif
comment|/* FANCY_REALLOC */
block|}
end_function

begin_comment
comment|/*  * Allocate an inode in the file system.  *   * we leave the actual allocation strategy to the (modified)  * ext2_new_inode(), to make sure we get the policies right  */
end_comment

begin_function
name|int
name|ext2_valloc
parameter_list|(
name|pvp
parameter_list|,
name|mode
parameter_list|,
name|cred
parameter_list|,
name|vpp
parameter_list|)
name|struct
name|vnode
modifier|*
name|pvp
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
decl_stmt|;
block|{
specifier|register
name|struct
name|inode
modifier|*
name|pip
decl_stmt|;
specifier|register
name|struct
name|ext2_sb_info
modifier|*
name|fs
decl_stmt|;
specifier|register
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
name|pip
operator|=
name|VTOI
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
name|fs
operator|=
name|pip
operator|->
name|i_e2fs
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|s_es
operator|->
name|s_free_inodes_count
operator|==
literal|0
condition|)
goto|goto
name|noinodes
goto|;
comment|/* call the Linux routine - it returns the inode number only */
name|ino
operator|=
name|ext2_new_inode
argument_list|(
name|pip
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|ino
operator|==
literal|0
condition|)
goto|goto
name|noinodes
goto|;
name|error
operator|=
name|VFS_VGET
argument_list|(
name|pvp
operator|->
name|v_mount
argument_list|,
name|ino
argument_list|,
name|vpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|UFS_VFREE
argument_list|(
name|pvp
argument_list|,
name|ino
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ip
operator|=
name|VTOI
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
comment|/*  	  the question is whether using VGET was such good idea at all - 	  Linux doesn't read the old inode in when it's allocating a 	  new one. I will set at least i_size& i_blocks the zero.  	*/
name|ip
operator|->
name|i_mode
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_size
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_blocks
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_flags
operator|=
literal|0
expr_stmt|;
comment|/* now we want to make sure that the block pointers are zeroed out */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NDADDR
condition|;
name|i
operator|++
control|)
name|ip
operator|->
name|i_db
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NIADDR
condition|;
name|i
operator|++
control|)
name|ip
operator|->
name|i_ib
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set up a new generation number for this inode. 	 * XXX check if this makes sense in ext2 	 */
if|if
condition|(
name|ip
operator|->
name|i_gen
operator|==
literal|0
operator|||
operator|++
name|ip
operator|->
name|i_gen
operator|==
literal|0
condition|)
name|ip
operator|->
name|i_gen
operator|=
name|random
argument_list|()
operator|/
literal|2
operator|+
literal|1
expr_stmt|;
comment|/* printf("ext2_valloc: allocated inode %d\n", ino); */
return|return
operator|(
literal|0
operator|)
return|;
name|noinodes
label|:
name|ext2_fserr
argument_list|(
name|fs
argument_list|,
name|cred
operator|->
name|cr_uid
argument_list|,
literal|"out of inodes"
argument_list|)
expr_stmt|;
name|uprintf
argument_list|(
literal|"\n%s: create/symlink failed, no inodes free\n"
argument_list|,
name|fs
operator|->
name|fs_fsmnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Select the desired position for the next block in a file.    *  * we try to mimic what Remy does in inode_getblk/block_getblk  *  * we note: blocknr == 0 means that we're about to allocate either  * a direct block or a pointer block at the first level of indirection  * (In other words, stuff that will go in i_db[] or i_ib[])  *  * blocknr != 0 means that we're allocating a block that is none  * of the above. Then, blocknr tells us the number of the block  * that will hold the pointer  */
end_comment

begin_function
name|daddr_t
name|ext2_blkpref
parameter_list|(
name|ip
parameter_list|,
name|lbn
parameter_list|,
name|indx
parameter_list|,
name|bap
parameter_list|,
name|blocknr
parameter_list|)
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|daddr_t
name|lbn
decl_stmt|;
name|int
name|indx
decl_stmt|;
name|daddr_t
modifier|*
name|bap
decl_stmt|;
name|daddr_t
name|blocknr
decl_stmt|;
block|{
name|int
name|tmp
decl_stmt|;
comment|/* if the next block is actually what we thought it is, 	   then set the goal to what we thought it should be 	*/
if|if
condition|(
name|ip
operator|->
name|i_next_alloc_block
operator|==
name|lbn
condition|)
return|return
name|ip
operator|->
name|i_next_alloc_goal
return|;
comment|/* now check whether we were provided with an array that basically 	   tells us previous blocks to which we want to stay closeby 	*/
if|if
condition|(
name|bap
condition|)
for|for
control|(
name|tmp
operator|=
name|indx
operator|-
literal|1
init|;
name|tmp
operator|>=
literal|0
condition|;
name|tmp
operator|--
control|)
if|if
condition|(
name|bap
index|[
name|tmp
index|]
condition|)
return|return
name|bap
index|[
name|tmp
index|]
return|;
comment|/* else let's fall back to the blocknr, or, if there is none, 	   follow the rule that a block should be allocated near its inode 	*/
return|return
name|blocknr
condition|?
name|blocknr
else|:
call|(
name|daddr_t
call|)
argument_list|(
name|ip
operator|->
name|i_block_group
operator|*
name|EXT2_BLOCKS_PER_GROUP
argument_list|(
name|ip
operator|->
name|i_e2fs
argument_list|)
argument_list|)
operator|+
name|ip
operator|->
name|i_e2fs
operator|->
name|s_es
operator|->
name|s_first_data_block
return|;
block|}
end_function

begin_comment
comment|/*  * Free a block or fragment.  *  * pass on to the Linux code  */
end_comment

begin_function
name|void
name|ext2_blkfree
parameter_list|(
name|ip
parameter_list|,
name|bno
parameter_list|,
name|size
parameter_list|)
specifier|register
name|struct
name|inode
modifier|*
name|ip
decl_stmt|;
name|daddr_t
name|bno
decl_stmt|;
name|long
name|size
decl_stmt|;
block|{
specifier|register
name|struct
name|ext2_sb_info
modifier|*
name|fs
decl_stmt|;
name|fs
operator|=
name|ip
operator|->
name|i_e2fs
expr_stmt|;
comment|/* 	 *	call Linux code with mount *, block number, count 	 */
name|ext2_free_blocks
argument_list|(
name|ITOV
argument_list|(
name|ip
argument_list|)
operator|->
name|v_mount
argument_list|,
name|bno
argument_list|,
name|size
operator|/
name|fs
operator|->
name|s_frag_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free an inode.  *  * the maintenance of the actual bitmaps is again up to the linux code  */
end_comment

begin_function
name|int
name|ext2_vfree
parameter_list|(
name|pvp
parameter_list|,
name|ino
parameter_list|,
name|mode
parameter_list|)
name|struct
name|vnode
modifier|*
name|pvp
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
specifier|register
name|struct
name|ext2_sb_info
modifier|*
name|fs
decl_stmt|;
specifier|register
name|struct
name|inode
modifier|*
name|pip
decl_stmt|;
specifier|register
name|mode_t
name|save_i_mode
decl_stmt|;
name|pip
operator|=
name|VTOI
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
name|fs
operator|=
name|pip
operator|->
name|i_e2fs
expr_stmt|;
if|if
condition|(
operator|(
name|u_int
operator|)
name|ino
operator|>=
name|fs
operator|->
name|s_inodes_per_group
operator|*
name|fs
operator|->
name|s_groups_count
condition|)
name|panic
argument_list|(
literal|"ext2_vfree: range: dev = (%d, %d), ino = %d, fs = %s"
argument_list|,
name|major
argument_list|(
name|pip
operator|->
name|i_dev
argument_list|)
argument_list|,
name|minor
argument_list|(
name|pip
operator|->
name|i_dev
argument_list|)
argument_list|,
name|ino
argument_list|,
name|fs
operator|->
name|fs_fsmnt
argument_list|)
expr_stmt|;
comment|/* ext2_debug("ext2_vfree (%d, %d) called\n", pip->i_number, mode);  */
name|ext2_discard_prealloc
argument_list|(
name|pip
argument_list|)
expr_stmt|;
comment|/* we need to make sure that ext2_free_inode can adjust the 	   used_dir_counts in the group summary information - I'd 	   really like to know what the rationale behind this 	   'set i_mode to zero to denote an unused inode' is 	 */
name|save_i_mode
operator|=
name|pip
operator|->
name|i_mode
expr_stmt|;
name|pip
operator|->
name|i_mode
operator|=
name|mode
expr_stmt|;
name|ext2_free_inode
argument_list|(
name|pip
argument_list|)
expr_stmt|;
name|pip
operator|->
name|i_mode
operator|=
name|save_i_mode
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fserr prints the name of a file system with an error diagnostic.  *   * The form of the error message is:  *	fs: error message  */
end_comment

begin_function
specifier|static
name|void
name|ext2_fserr
parameter_list|(
name|fs
parameter_list|,
name|uid
parameter_list|,
name|cp
parameter_list|)
name|struct
name|ext2_sb_info
modifier|*
name|fs
decl_stmt|;
name|u_int
name|uid
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"uid %d on %s: %s\n"
argument_list|,
name|uid
argument_list|,
name|fs
operator|->
name|fs_fsmnt
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

