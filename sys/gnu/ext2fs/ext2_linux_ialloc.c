begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  linux/fs/ext2/ialloc.c  *  * Copyright (C) 1992, 1993, 1994, 1995  * Remy Card (card@masi.ibp.fr)  * Laboratoire MASI - Institut Blaise Pascal  * Universite Pierre et Marie Curie (Paris VI)  *  *  BSD ufs-inspired inode and directory allocation by   *  Stephen Tweedie (sct@dcs.ed.ac.uk), 1993  *  Big-endian to little-endian byte-swapping/bitmaps by  *        David S. Miller (davem@caip.rutgers.edu), 1995  */
end_comment

begin_include
include|#
directive|include
file|<linux/fs.h>
end_include

begin_include
include|#
directive|include
file|<linux/locks.h>
end_include

begin_include
include|#
directive|include
file|<linux/quotaops.h>
end_include

begin_comment
comment|/*  * ialloc.c contains the inodes allocation and deallocation routines  */
end_comment

begin_comment
comment|/*  * The free inodes are managed by bitmaps.  A file system contains several  * blocks groups.  Each group contains 1 bitmap block for blocks, 1 bitmap  * block for inodes, N blocks for the inode table and data blocks.  *  * The file system contains group descriptors which are located after the  * super block.  Each descriptor contains the number of the bitmap block and  * the free blocks count in the block.  The descriptors are loaded in memory  * when a file system is mounted (see ext2_read_super).  */
end_comment

begin_comment
comment|/*  * Read the inode allocation bitmap for a given block_group, reading  * into the specified slot in the superblock's bitmap cache.  *  * Return>=0 on success or a -ve error code.  */
end_comment

begin_function
specifier|static
name|int
name|read_inode_bitmap
parameter_list|(
name|struct
name|super_block
modifier|*
name|sb
parameter_list|,
name|unsigned
name|long
name|block_group
parameter_list|,
name|unsigned
name|int
name|bitmap_nr
parameter_list|)
block|{
name|struct
name|ext2_group_desc
modifier|*
name|gdp
decl_stmt|;
name|struct
name|buffer_head
modifier|*
name|bh
init|=
name|NULL
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|gdp
operator|=
name|ext2_get_group_desc
argument_list|(
name|sb
argument_list|,
name|block_group
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gdp
condition|)
block|{
name|retval
operator|=
operator|-
name|EIO
expr_stmt|;
goto|goto
name|error_out
goto|;
block|}
name|bh
operator|=
name|bread
argument_list|(
name|sb
operator|->
name|s_dev
argument_list|,
name|le32_to_cpu
argument_list|(
name|gdp
operator|->
name|bg_inode_bitmap
argument_list|)
argument_list|,
name|sb
operator|->
name|s_blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bh
condition|)
block|{
name|ext2_error
argument_list|(
name|sb
argument_list|,
literal|"read_inode_bitmap"
argument_list|,
literal|"Cannot read inode bitmap - "
literal|"block_group = %lu, inode_bitmap = %lu"
argument_list|,
name|block_group
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|gdp
operator|->
name|bg_inode_bitmap
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|-
name|EIO
expr_stmt|;
block|}
comment|/* 	 * On IO error, just leave a zero in the superblock's block pointer for 	 * this group.  The IO will be retried next time. 	 */
name|error_out
label|:
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap_number
index|[
name|bitmap_nr
index|]
operator|=
name|block_group
expr_stmt|;
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap
index|[
name|bitmap_nr
index|]
operator|=
name|bh
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * load_inode_bitmap loads the inode bitmap for a blocks group  *  * It maintains a cache for the last bitmaps loaded.  This cache is managed  * with a LRU algorithm.  *  * Notes:  * 1/ There is one cache per mounted file system.  * 2/ If the file system contains less than EXT2_MAX_GROUP_LOADED groups,  *    this function reads the bitmap without maintaining a LRU cache.  *   * Return the slot used to store the bitmap, or a -ve error code.  */
end_comment

begin_function
specifier|static
name|int
name|load_inode_bitmap
parameter_list|(
name|struct
name|super_block
modifier|*
name|sb
parameter_list|,
name|unsigned
name|int
name|block_group
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|retval
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|inode_bitmap_number
decl_stmt|;
name|struct
name|buffer_head
modifier|*
name|inode_bitmap
decl_stmt|;
if|if
condition|(
name|block_group
operator|>=
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_groups_count
condition|)
name|ext2_panic
argument_list|(
name|sb
argument_list|,
literal|"load_inode_bitmap"
argument_list|,
literal|"block_group>= groups_count - "
literal|"block_group = %d, groups_count = %lu"
argument_list|,
name|block_group
argument_list|,
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_groups_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_loaded_inode_bitmaps
operator|>
literal|0
operator|&&
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap_number
index|[
literal|0
index|]
operator|==
name|block_group
operator|&&
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_groups_count
operator|<=
name|EXT2_MAX_GROUP_LOADED
condition|)
block|{
if|if
condition|(
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap
index|[
name|block_group
index|]
condition|)
block|{
if|if
condition|(
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap_number
index|[
name|block_group
index|]
operator|!=
name|block_group
condition|)
name|ext2_panic
argument_list|(
name|sb
argument_list|,
literal|"load_inode_bitmap"
argument_list|,
literal|"block_group != inode_bitmap_number"
argument_list|)
expr_stmt|;
else|else
return|return
name|block_group
return|;
block|}
else|else
block|{
name|retval
operator|=
name|read_inode_bitmap
argument_list|(
name|sb
argument_list|,
name|block_group
argument_list|,
name|block_group
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
return|return
name|retval
return|;
return|return
name|block_group
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_loaded_inode_bitmaps
operator|&&
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap_number
index|[
name|i
index|]
operator|!=
name|block_group
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|<
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_loaded_inode_bitmaps
operator|&&
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap_number
index|[
name|i
index|]
operator|==
name|block_group
condition|)
block|{
name|inode_bitmap_number
operator|=
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap_number
index|[
name|i
index|]
expr_stmt|;
name|inode_bitmap
operator|=
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap_number
index|[
name|j
index|]
operator|=
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap_number
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap
index|[
name|j
index|]
operator|=
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap_number
index|[
literal|0
index|]
operator|=
name|inode_bitmap_number
expr_stmt|;
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap
index|[
literal|0
index|]
operator|=
name|inode_bitmap
expr_stmt|;
comment|/* 		 * There's still one special case here --- if inode_bitmap == 0 		 * then our last attempt to read the bitmap failed and we have 		 * just ended up caching that failure.  Try again to read it. 		 */
if|if
condition|(
operator|!
name|inode_bitmap
condition|)
name|retval
operator|=
name|read_inode_bitmap
argument_list|(
name|sb
argument_list|,
name|block_group
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_loaded_inode_bitmaps
operator|<
name|EXT2_MAX_GROUP_LOADED
condition|)
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_loaded_inode_bitmaps
operator|++
expr_stmt|;
else|else
name|brelse
argument_list|(
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap
index|[
name|EXT2_MAX_GROUP_LOADED
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_loaded_inode_bitmaps
operator|-
literal|1
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap_number
index|[
name|j
index|]
operator|=
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap_number
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap
index|[
name|j
index|]
operator|=
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|retval
operator|=
name|read_inode_bitmap
argument_list|(
name|sb
argument_list|,
name|block_group
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * NOTE! When we get the inode, we're the only people  * that have access to it, and as such there are no  * race conditions we have to worry about. The inode  * is not on the hash-lists, and it cannot be reached  * through the filesystem because the directory entry  * has been deleted earlier.  *  * HOWEVER: we must make sure that we get no aliases,  * which means that we have to call "clear_inode()"  * _before_ we mark the inode not in use in the inode  * bitmaps. Otherwise a newly created file might use  * the same inode number (not actually the same pointer  * though), and then we'd have two inodes sharing the  * same inode number and space on the harddisk.  */
end_comment

begin_function
name|void
name|ext2_free_inode
parameter_list|(
name|struct
name|inode
modifier|*
name|inode
parameter_list|)
block|{
name|struct
name|super_block
modifier|*
name|sb
init|=
name|inode
operator|->
name|i_sb
decl_stmt|;
name|int
name|is_directory
decl_stmt|;
name|unsigned
name|long
name|ino
decl_stmt|;
name|struct
name|buffer_head
modifier|*
name|bh
decl_stmt|;
name|struct
name|buffer_head
modifier|*
name|bh2
decl_stmt|;
name|unsigned
name|long
name|block_group
decl_stmt|;
name|unsigned
name|long
name|bit
decl_stmt|;
name|int
name|bitmap_nr
decl_stmt|;
name|struct
name|ext2_group_desc
modifier|*
name|gdp
decl_stmt|;
name|struct
name|ext2_super_block
modifier|*
name|es
decl_stmt|;
if|if
condition|(
operator|!
name|inode
operator|->
name|i_dev
condition|)
block|{
name|printk
argument_list|(
literal|"ext2_free_inode: inode has no device\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inode
operator|->
name|i_count
operator|>
literal|1
condition|)
block|{
name|printk
argument_list|(
literal|"ext2_free_inode: inode has count=%d\n"
argument_list|,
name|inode
operator|->
name|i_count
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inode
operator|->
name|i_nlink
condition|)
block|{
name|printk
argument_list|(
literal|"ext2_free_inode: inode has nlink=%d\n"
argument_list|,
name|inode
operator|->
name|i_nlink
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|sb
condition|)
block|{
name|printk
argument_list|(
literal|"ext2_free_inode: inode on nonexistent device\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ino
operator|=
name|inode
operator|->
name|i_ino
expr_stmt|;
name|ext2_debug
argument_list|(
literal|"freeing inode %lu\n"
argument_list|,
name|ino
argument_list|)
expr_stmt|;
comment|/* 	 * Note: we must free any quota before locking the superblock, 	 * as writing the quota to disk may need the lock as well. 	 */
name|DQUOT_FREE_INODE
argument_list|(
name|sb
argument_list|,
name|inode
argument_list|)
expr_stmt|;
name|DQUOT_DROP
argument_list|(
name|inode
argument_list|)
expr_stmt|;
name|lock_super
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|es
operator|=
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_es
expr_stmt|;
if|if
condition|(
name|ino
operator|<
name|EXT2_FIRST_INO
argument_list|(
name|sb
argument_list|)
operator|||
name|ino
operator|>
name|le32_to_cpu
argument_list|(
name|es
operator|->
name|s_inodes_count
argument_list|)
condition|)
block|{
name|ext2_error
argument_list|(
name|sb
argument_list|,
literal|"free_inode"
argument_list|,
literal|"reserved inode or nonexistent inode"
argument_list|)
expr_stmt|;
goto|goto
name|error_return
goto|;
block|}
name|block_group
operator|=
operator|(
name|ino
operator|-
literal|1
operator|)
operator|/
name|EXT2_INODES_PER_GROUP
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|bit
operator|=
operator|(
name|ino
operator|-
literal|1
operator|)
operator|%
name|EXT2_INODES_PER_GROUP
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|bitmap_nr
operator|=
name|load_inode_bitmap
argument_list|(
name|sb
argument_list|,
name|block_group
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_nr
operator|<
literal|0
condition|)
goto|goto
name|error_return
goto|;
name|bh
operator|=
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap
index|[
name|bitmap_nr
index|]
expr_stmt|;
name|is_directory
operator|=
name|S_ISDIR
argument_list|(
name|inode
operator|->
name|i_mode
argument_list|)
expr_stmt|;
comment|/* Do this BEFORE marking the inode not in use */
name|clear_inode
argument_list|(
name|inode
argument_list|)
expr_stmt|;
comment|/* Ok, now we can actually update the inode bitmaps.. */
if|if
condition|(
operator|!
name|ext2_clear_bit
argument_list|(
name|bit
argument_list|,
name|bh
operator|->
name|b_data
argument_list|)
condition|)
name|ext2_warning
argument_list|(
name|sb
argument_list|,
literal|"ext2_free_inode"
argument_list|,
literal|"bit already cleared for inode %lu"
argument_list|,
name|ino
argument_list|)
expr_stmt|;
else|else
block|{
name|gdp
operator|=
name|ext2_get_group_desc
argument_list|(
name|sb
argument_list|,
name|block_group
argument_list|,
operator|&
name|bh2
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdp
condition|)
block|{
name|gdp
operator|->
name|bg_free_inodes_count
operator|=
name|cpu_to_le16
argument_list|(
name|le16_to_cpu
argument_list|(
name|gdp
operator|->
name|bg_free_inodes_count
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_directory
condition|)
name|gdp
operator|->
name|bg_used_dirs_count
operator|=
name|cpu_to_le16
argument_list|(
name|le16_to_cpu
argument_list|(
name|gdp
operator|->
name|bg_used_dirs_count
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|mark_buffer_dirty
argument_list|(
name|bh2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|es
operator|->
name|s_free_inodes_count
operator|=
name|cpu_to_le32
argument_list|(
name|le32_to_cpu
argument_list|(
name|es
operator|->
name|s_free_inodes_count
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mark_buffer_dirty
argument_list|(
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_sbh
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|mark_buffer_dirty
argument_list|(
name|bh
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|s_flags
operator|&
name|MS_SYNCHRONOUS
condition|)
block|{
name|ll_rw_block
argument_list|(
name|WRITE
argument_list|,
literal|1
argument_list|,
operator|&
name|bh
argument_list|)
expr_stmt|;
name|wait_on_buffer
argument_list|(
name|bh
argument_list|)
expr_stmt|;
block|}
name|sb
operator|->
name|s_dirt
operator|=
literal|1
expr_stmt|;
name|error_return
label|:
name|unlock_super
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * There are two policies for allocating an inode.  If the new inode is  * a directory, then a forward search is made for a block group with both  * free space and a low directory-to-inode ratio; if that fails, then of  * the groups with above-average free space, that group with the fewest  * directories already is chosen.  *  * For other inodes, search forward from the parent directory\'s block  * group to find a free inode.  */
end_comment

begin_function
name|struct
name|inode
modifier|*
name|ext2_new_inode
parameter_list|(
specifier|const
name|struct
name|inode
modifier|*
name|dir
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
name|struct
name|super_block
modifier|*
name|sb
decl_stmt|;
name|struct
name|buffer_head
modifier|*
name|bh
decl_stmt|;
name|struct
name|buffer_head
modifier|*
name|bh2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|avefreei
decl_stmt|;
name|struct
name|inode
modifier|*
name|inode
decl_stmt|;
name|int
name|bitmap_nr
decl_stmt|;
name|struct
name|ext2_group_desc
modifier|*
name|gdp
decl_stmt|;
name|struct
name|ext2_group_desc
modifier|*
name|tmp
decl_stmt|;
name|struct
name|ext2_super_block
modifier|*
name|es
decl_stmt|;
comment|/* Cannot create files in a deleted directory */
if|if
condition|(
operator|!
name|dir
operator|||
operator|!
name|dir
operator|->
name|i_nlink
condition|)
block|{
operator|*
name|err
operator|=
operator|-
name|EPERM
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|inode
operator|=
name|get_empty_inode
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|inode
condition|)
block|{
operator|*
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|sb
operator|=
name|dir
operator|->
name|i_sb
expr_stmt|;
name|inode
operator|->
name|i_sb
operator|=
name|sb
expr_stmt|;
name|inode
operator|->
name|i_flags
operator|=
literal|0
expr_stmt|;
name|lock_super
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|es
operator|=
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_es
expr_stmt|;
name|repeat
label|:
name|gdp
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
operator|*
name|err
operator|=
operator|-
name|ENOSPC
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|avefreei
operator|=
name|le32_to_cpu
argument_list|(
name|es
operator|->
name|s_free_inodes_count
argument_list|)
operator|/
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_groups_count
expr_stmt|;
comment|/* I am not yet convinced that this next bit is necessary. 		i = dir->u.ext2_i.i_block_group; 		for (j = 0; j< sb->u.ext2_sb.s_groups_count; j++) { 			tmp = ext2_get_group_desc (sb, i,&bh2); 			if (tmp&& 			    (le16_to_cpu(tmp->bg_used_dirs_count)<< 8)<  			     le16_to_cpu(tmp->bg_free_inodes_count)) { 				gdp = tmp; 				break; 			} 			else 			i = ++i % sb->u.ext2_sb.s_groups_count; 		} */
if|if
condition|(
operator|!
name|gdp
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_groups_count
condition|;
name|j
operator|++
control|)
block|{
name|tmp
operator|=
name|ext2_get_group_desc
argument_list|(
name|sb
argument_list|,
name|j
argument_list|,
operator|&
name|bh2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&&
name|le16_to_cpu
argument_list|(
name|tmp
operator|->
name|bg_free_inodes_count
argument_list|)
operator|&&
name|le16_to_cpu
argument_list|(
name|tmp
operator|->
name|bg_free_inodes_count
argument_list|)
operator|>=
name|avefreei
condition|)
block|{
if|if
condition|(
operator|!
name|gdp
operator|||
operator|(
name|le16_to_cpu
argument_list|(
name|tmp
operator|->
name|bg_free_blocks_count
argument_list|)
operator|>
name|le16_to_cpu
argument_list|(
name|gdp
operator|->
name|bg_free_blocks_count
argument_list|)
operator|)
condition|)
block|{
name|i
operator|=
name|j
expr_stmt|;
name|gdp
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * Try to place the inode in its parent directory 		 */
name|i
operator|=
name|dir
operator|->
name|u
operator|.
name|ext2_i
operator|.
name|i_block_group
expr_stmt|;
name|tmp
operator|=
name|ext2_get_group_desc
argument_list|(
name|sb
argument_list|,
name|i
argument_list|,
operator|&
name|bh2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&&
name|le16_to_cpu
argument_list|(
name|tmp
operator|->
name|bg_free_inodes_count
argument_list|)
condition|)
name|gdp
operator|=
name|tmp
expr_stmt|;
else|else
block|{
comment|/* 			 * Use a quadratic hash to find a group with a 			 * free inode 			 */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_groups_count
condition|;
name|j
operator|<<=
literal|1
control|)
block|{
name|i
operator|+=
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_groups_count
condition|)
name|i
operator|-=
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_groups_count
expr_stmt|;
name|tmp
operator|=
name|ext2_get_group_desc
argument_list|(
name|sb
argument_list|,
name|i
argument_list|,
operator|&
name|bh2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&&
name|le16_to_cpu
argument_list|(
name|tmp
operator|->
name|bg_free_inodes_count
argument_list|)
condition|)
block|{
name|gdp
operator|=
name|tmp
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|gdp
condition|)
block|{
comment|/* 			 * That failed: try linear search for a free inode 			 */
name|i
operator|=
name|dir
operator|->
name|u
operator|.
name|ext2_i
operator|.
name|i_block_group
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|2
init|;
name|j
operator|<
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_groups_count
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|++
name|i
operator|>=
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_groups_count
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|ext2_get_group_desc
argument_list|(
name|sb
argument_list|,
name|i
argument_list|,
operator|&
name|bh2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|&&
name|le16_to_cpu
argument_list|(
name|tmp
operator|->
name|bg_free_inodes_count
argument_list|)
condition|)
block|{
name|gdp
operator|=
name|tmp
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|gdp
condition|)
block|{
name|unlock_super
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|iput
argument_list|(
name|inode
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bitmap_nr
operator|=
name|load_inode_bitmap
argument_list|(
name|sb
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_nr
operator|<
literal|0
condition|)
block|{
name|unlock_super
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|iput
argument_list|(
name|inode
argument_list|)
expr_stmt|;
operator|*
name|err
operator|=
operator|-
name|EIO
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bh
operator|=
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap
index|[
name|bitmap_nr
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|=
name|ext2_find_first_zero_bit
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|bh
operator|->
name|b_data
argument_list|,
name|EXT2_INODES_PER_GROUP
argument_list|(
name|sb
argument_list|)
argument_list|)
operator|)
operator|<
name|EXT2_INODES_PER_GROUP
argument_list|(
name|sb
argument_list|)
condition|)
block|{
if|if
condition|(
name|ext2_set_bit
argument_list|(
name|j
argument_list|,
name|bh
operator|->
name|b_data
argument_list|)
condition|)
block|{
name|ext2_warning
argument_list|(
name|sb
argument_list|,
literal|"ext2_new_inode"
argument_list|,
literal|"bit already set for inode %d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
name|mark_buffer_dirty
argument_list|(
name|bh
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|s_flags
operator|&
name|MS_SYNCHRONOUS
condition|)
block|{
name|ll_rw_block
argument_list|(
name|WRITE
argument_list|,
literal|1
argument_list|,
operator|&
name|bh
argument_list|)
expr_stmt|;
name|wait_on_buffer
argument_list|(
name|bh
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|le16_to_cpu
argument_list|(
name|gdp
operator|->
name|bg_free_inodes_count
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ext2_error
argument_list|(
name|sb
argument_list|,
literal|"ext2_new_inode"
argument_list|,
literal|"Free inodes count corrupted in group %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|unlock_super
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|iput
argument_list|(
name|inode
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
goto|goto
name|repeat
goto|;
block|}
name|j
operator|+=
name|i
operator|*
name|EXT2_INODES_PER_GROUP
argument_list|(
name|sb
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|EXT2_FIRST_INO
argument_list|(
name|sb
argument_list|)
operator|||
name|j
operator|>
name|le32_to_cpu
argument_list|(
name|es
operator|->
name|s_inodes_count
argument_list|)
condition|)
block|{
name|ext2_error
argument_list|(
name|sb
argument_list|,
literal|"ext2_new_inode"
argument_list|,
literal|"reserved inode or inode> inodes count - "
literal|"block_group = %d,inode=%d"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|unlock_super
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|iput
argument_list|(
name|inode
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|gdp
operator|->
name|bg_free_inodes_count
operator|=
name|cpu_to_le16
argument_list|(
name|le16_to_cpu
argument_list|(
name|gdp
operator|->
name|bg_free_inodes_count
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|)
name|gdp
operator|->
name|bg_used_dirs_count
operator|=
name|cpu_to_le16
argument_list|(
name|le16_to_cpu
argument_list|(
name|gdp
operator|->
name|bg_used_dirs_count
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mark_buffer_dirty
argument_list|(
name|bh2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|es
operator|->
name|s_free_inodes_count
operator|=
name|cpu_to_le32
argument_list|(
name|le32_to_cpu
argument_list|(
name|es
operator|->
name|s_free_inodes_count
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mark_buffer_dirty
argument_list|(
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_sbh
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sb
operator|->
name|s_dirt
operator|=
literal|1
expr_stmt|;
name|inode
operator|->
name|i_mode
operator|=
name|mode
expr_stmt|;
name|inode
operator|->
name|i_sb
operator|=
name|sb
expr_stmt|;
name|inode
operator|->
name|i_nlink
operator|=
literal|1
expr_stmt|;
name|inode
operator|->
name|i_dev
operator|=
name|sb
operator|->
name|s_dev
expr_stmt|;
name|inode
operator|->
name|i_uid
operator|=
name|current
operator|->
name|fsuid
expr_stmt|;
if|if
condition|(
name|test_opt
argument_list|(
name|sb
argument_list|,
name|GRPID
argument_list|)
condition|)
name|inode
operator|->
name|i_gid
operator|=
name|dir
operator|->
name|i_gid
expr_stmt|;
elseif|else
if|if
condition|(
name|dir
operator|->
name|i_mode
operator|&
name|S_ISGID
condition|)
block|{
name|inode
operator|->
name|i_gid
operator|=
name|dir
operator|->
name|i_gid
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|)
name|mode
operator||=
name|S_ISGID
expr_stmt|;
block|}
else|else
name|inode
operator|->
name|i_gid
operator|=
name|current
operator|->
name|fsgid
expr_stmt|;
name|inode
operator|->
name|i_ino
operator|=
name|j
expr_stmt|;
name|inode
operator|->
name|i_blksize
operator|=
name|PAGE_SIZE
expr_stmt|;
comment|/* This is the optimal IO size (for stat), not the fs block size */
name|inode
operator|->
name|i_blocks
operator|=
literal|0
expr_stmt|;
name|inode
operator|->
name|i_mtime
operator|=
name|inode
operator|->
name|i_atime
operator|=
name|inode
operator|->
name|i_ctime
operator|=
name|CURRENT_TIME
expr_stmt|;
name|inode
operator|->
name|u
operator|.
name|ext2_i
operator|.
name|i_new_inode
operator|=
literal|1
expr_stmt|;
name|inode
operator|->
name|u
operator|.
name|ext2_i
operator|.
name|i_flags
operator|=
name|dir
operator|->
name|u
operator|.
name|ext2_i
operator|.
name|i_flags
expr_stmt|;
if|if
condition|(
name|S_ISLNK
argument_list|(
name|mode
argument_list|)
condition|)
name|inode
operator|->
name|u
operator|.
name|ext2_i
operator|.
name|i_flags
operator|&=
operator|~
operator|(
name|EXT2_IMMUTABLE_FL
operator||
name|EXT2_APPEND_FL
operator|)
expr_stmt|;
name|inode
operator|->
name|u
operator|.
name|ext2_i
operator|.
name|i_faddr
operator|=
literal|0
expr_stmt|;
name|inode
operator|->
name|u
operator|.
name|ext2_i
operator|.
name|i_frag_no
operator|=
literal|0
expr_stmt|;
name|inode
operator|->
name|u
operator|.
name|ext2_i
operator|.
name|i_frag_size
operator|=
literal|0
expr_stmt|;
name|inode
operator|->
name|u
operator|.
name|ext2_i
operator|.
name|i_file_acl
operator|=
literal|0
expr_stmt|;
name|inode
operator|->
name|u
operator|.
name|ext2_i
operator|.
name|i_dir_acl
operator|=
literal|0
expr_stmt|;
name|inode
operator|->
name|u
operator|.
name|ext2_i
operator|.
name|i_dtime
operator|=
literal|0
expr_stmt|;
name|inode
operator|->
name|u
operator|.
name|ext2_i
operator|.
name|i_block_group
operator|=
name|i
expr_stmt|;
name|inode
operator|->
name|i_op
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|inode
operator|->
name|u
operator|.
name|ext2_i
operator|.
name|i_flags
operator|&
name|EXT2_SYNC_FL
condition|)
name|inode
operator|->
name|i_flags
operator||=
name|MS_SYNCHRONOUS
expr_stmt|;
name|insert_inode_hash
argument_list|(
name|inode
argument_list|)
expr_stmt|;
name|inode
operator|->
name|i_generation
operator|=
name|event
operator|++
expr_stmt|;
name|mark_inode_dirty
argument_list|(
name|inode
argument_list|)
expr_stmt|;
name|unlock_super
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|DQUOT_ALLOC_INODE
argument_list|(
name|sb
argument_list|,
name|inode
argument_list|)
condition|)
block|{
name|sb
operator|->
name|dq_op
operator|->
name|drop
argument_list|(
name|inode
argument_list|)
expr_stmt|;
name|inode
operator|->
name|i_nlink
operator|=
literal|0
expr_stmt|;
name|iput
argument_list|(
name|inode
argument_list|)
expr_stmt|;
operator|*
name|err
operator|=
operator|-
name|EDQUOT
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ext2_debug
argument_list|(
literal|"allocating inode %lu\n"
argument_list|,
name|inode
operator|->
name|i_ino
argument_list|)
expr_stmt|;
operator|*
name|err
operator|=
literal|0
expr_stmt|;
return|return
name|inode
return|;
block|}
end_function

begin_function
name|unsigned
name|long
name|ext2_count_free_inodes
parameter_list|(
name|struct
name|super_block
modifier|*
name|sb
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|EXT2FS_DEBUG
name|struct
name|ext2_super_block
modifier|*
name|es
decl_stmt|;
name|unsigned
name|long
name|desc_count
decl_stmt|,
name|bitmap_count
decl_stmt|,
name|x
decl_stmt|;
name|int
name|bitmap_nr
decl_stmt|;
name|struct
name|ext2_group_desc
modifier|*
name|gdp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lock_super
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|es
operator|=
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_es
expr_stmt|;
name|desc_count
operator|=
literal|0
expr_stmt|;
name|bitmap_count
operator|=
literal|0
expr_stmt|;
name|gdp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_groups_count
condition|;
name|i
operator|++
control|)
block|{
name|gdp
operator|=
name|ext2_get_group_desc
argument_list|(
name|sb
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gdp
condition|)
continue|continue;
name|desc_count
operator|+=
name|le16_to_cpu
argument_list|(
name|gdp
operator|->
name|bg_free_inodes_count
argument_list|)
expr_stmt|;
name|bitmap_nr
operator|=
name|load_inode_bitmap
argument_list|(
name|sb
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_nr
operator|<
literal|0
condition|)
continue|continue;
name|x
operator|=
name|ext2_count_free
argument_list|(
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap
index|[
name|bitmap_nr
index|]
argument_list|,
name|EXT2_INODES_PER_GROUP
argument_list|(
name|sb
argument_list|)
operator|/
literal|8
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"group %d: stored = %d, counted = %lu\n"
argument_list|,
name|i
argument_list|,
name|le16_to_cpu
argument_list|(
name|gdp
operator|->
name|bg_free_inodes_count
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|bitmap_count
operator|+=
name|x
expr_stmt|;
block|}
name|printk
argument_list|(
literal|"ext2_count_free_inodes: stored = %lu, computed = %lu, %lu\n"
argument_list|,
name|le32_to_cpu
argument_list|(
name|es
operator|->
name|s_free_inodes_count
argument_list|)
argument_list|,
name|desc_count
argument_list|,
name|bitmap_count
argument_list|)
expr_stmt|;
name|unlock_super
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
name|desc_count
return|;
else|#
directive|else
return|return
name|le32_to_cpu
argument_list|(
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_es
operator|->
name|s_free_inodes_count
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|ext2_check_inodes_bitmap
parameter_list|(
name|struct
name|super_block
modifier|*
name|sb
parameter_list|)
block|{
name|struct
name|ext2_super_block
modifier|*
name|es
decl_stmt|;
name|unsigned
name|long
name|desc_count
decl_stmt|,
name|bitmap_count
decl_stmt|,
name|x
decl_stmt|;
name|int
name|bitmap_nr
decl_stmt|;
name|struct
name|ext2_group_desc
modifier|*
name|gdp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lock_super
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|es
operator|=
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_es
expr_stmt|;
name|desc_count
operator|=
literal|0
expr_stmt|;
name|bitmap_count
operator|=
literal|0
expr_stmt|;
name|gdp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_groups_count
condition|;
name|i
operator|++
control|)
block|{
name|gdp
operator|=
name|ext2_get_group_desc
argument_list|(
name|sb
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gdp
condition|)
continue|continue;
name|desc_count
operator|+=
name|le16_to_cpu
argument_list|(
name|gdp
operator|->
name|bg_free_inodes_count
argument_list|)
expr_stmt|;
name|bitmap_nr
operator|=
name|load_inode_bitmap
argument_list|(
name|sb
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_nr
operator|<
literal|0
condition|)
continue|continue;
name|x
operator|=
name|ext2_count_free
argument_list|(
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap
index|[
name|bitmap_nr
index|]
argument_list|,
name|EXT2_INODES_PER_GROUP
argument_list|(
name|sb
argument_list|)
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|le16_to_cpu
argument_list|(
name|gdp
operator|->
name|bg_free_inodes_count
argument_list|)
operator|!=
name|x
condition|)
name|ext2_error
argument_list|(
name|sb
argument_list|,
literal|"ext2_check_inodes_bitmap"
argument_list|,
literal|"Wrong free inodes count in group %d, "
literal|"stored = %d, counted = %lu"
argument_list|,
name|i
argument_list|,
name|le16_to_cpu
argument_list|(
name|gdp
operator|->
name|bg_free_inodes_count
argument_list|)
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|bitmap_count
operator|+=
name|x
expr_stmt|;
block|}
if|if
condition|(
name|le32_to_cpu
argument_list|(
name|es
operator|->
name|s_free_inodes_count
argument_list|)
operator|!=
name|bitmap_count
condition|)
name|ext2_error
argument_list|(
name|sb
argument_list|,
literal|"ext2_check_inodes_bitmap"
argument_list|,
literal|"Wrong free inodes count in super block, "
literal|"stored = %lu, counted = %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|le32_to_cpu
argument_list|(
name|es
operator|->
name|s_free_inodes_count
argument_list|)
argument_list|,
name|bitmap_count
argument_list|)
expr_stmt|;
name|unlock_super
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

