begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  modified for Lites 1.1  *  *  Aug 1995, Godmar Back (gback@cs.utah.edu)  *  University of Utah, Department of Computer Science  */
end_comment

begin_comment
comment|/*  *  linux/fs/ext2/ialloc.c  *  * Copyright (C) 1992, 1993, 1994, 1995  * Remy Card (card@masi.ibp.fr)  * Laboratoire MASI - Institut Blaise Pascal  * Universite Pierre et Marie Curie (Paris VI)  *  *  BSD ufs-inspired inode and directory allocation by   *  Stephen Tweedie (sct@dcs.ed.ac.uk), 1993  */
end_comment

begin_comment
comment|/*  * The free inodes are managed by bitmaps.  A file system contains several  * blocks groups.  Each group contains 1 bitmap block for blocks, 1 bitmap  * block for inodes, N blocks for the inode table and data blocks.  *  * The file system contains group descriptors which are located after the  * super block.  Each descriptor contains the number of the bitmap block and  * the free blocks count in the block.  The descriptors are loaded in memory  * when a file system is mounted (see ext2_read_super).  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/quota.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/inode.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/ufsmount.h>
end_include

begin_include
include|#
directive|include
file|<gnu/ext2fs/ext2_extern.h>
end_include

begin_include
include|#
directive|include
file|<gnu/ext2fs/ext2_fs.h>
end_include

begin_include
include|#
directive|include
file|<gnu/ext2fs/ext2_fs_sb.h>
end_include

begin_include
include|#
directive|include
file|<gnu/ext2fs/fs.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_include
include|#
directive|include
file|<gnu/ext2fs/i386-bitops.h>
end_include

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|please provide bit operation functions
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* this is supposed to mark a buffer dirty on ready for delayed writing  */
end_comment

begin_function
name|void
name|mark_buffer_dirty
parameter_list|(
name|struct
name|buf
modifier|*
name|bh
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|bh
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
condition|)
block|{
name|numdirtybuffers
operator|++
expr_stmt|;
name|bh
operator|->
name|b_flags
operator||=
name|B_DELWRI
expr_stmt|;
block|}
name|bh
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_READ
operator||
name|B_ERROR
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*     this should write a buffer immediately w/o releasing it  */
end_comment

begin_function
name|int
name|ll_w_block
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
name|waitfor
parameter_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
condition|)
block|{
operator|--
name|numdirtybuffers
expr_stmt|;
if|if
condition|(
name|needsbuffer
condition|)
name|vfs_bio_need_satisfy
argument_list|()
expr_stmt|;
block|}
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_READ
operator||
name|B_DONE
operator||
name|B_ERROR
operator||
name|B_DELWRI
operator|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_WRITEINPROG
expr_stmt|;
name|bp
operator|->
name|b_vp
operator|->
name|v_numoutput
operator|++
expr_stmt|;
name|vfs_busy_pages
argument_list|(
name|bp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VOP_STRATEGY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|waitfor
condition|?
name|biowait
argument_list|(
name|bp
argument_list|)
else|:
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|ext2_group_desc
modifier|*
name|get_group_desc
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|unsigned
name|int
name|block_group
parameter_list|,
name|struct
name|buffer_head
modifier|*
modifier|*
name|bh
parameter_list|)
block|{
name|struct
name|ext2_sb_info
modifier|*
name|sb
init|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
operator|->
name|um_e2fs
decl_stmt|;
name|unsigned
name|long
name|group_desc
decl_stmt|;
name|unsigned
name|long
name|desc
decl_stmt|;
name|struct
name|ext2_group_desc
modifier|*
name|gdp
decl_stmt|;
if|if
condition|(
name|block_group
operator|>=
name|sb
operator|->
name|s_groups_count
condition|)
name|panic
argument_list|(
literal|"get_group_desc: "
literal|"block_group>= groups_count - "
literal|"block_group = %d, groups_count = %lu"
argument_list|,
name|block_group
argument_list|,
name|sb
operator|->
name|s_groups_count
argument_list|)
expr_stmt|;
name|group_desc
operator|=
name|block_group
operator|/
name|EXT2_DESC_PER_BLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|desc
operator|=
name|block_group
operator|%
name|EXT2_DESC_PER_BLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sb
operator|->
name|s_group_desc
index|[
name|group_desc
index|]
condition|)
name|panic
argument_list|(
literal|"get_group_desc:"
literal|"Group descriptor not loaded - "
literal|"block_group = %d, group_desc = %lu, desc = %lu"
argument_list|,
name|block_group
argument_list|,
name|group_desc
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|gdp
operator|=
operator|(
expr|struct
name|ext2_group_desc
operator|*
operator|)
name|sb
operator|->
name|s_group_desc
index|[
name|group_desc
index|]
operator|->
name|b_data
expr_stmt|;
if|if
condition|(
name|bh
condition|)
operator|*
name|bh
operator|=
name|sb
operator|->
name|s_group_desc
index|[
name|group_desc
index|]
expr_stmt|;
return|return
name|gdp
operator|+
name|desc
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_inode_bitmap
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|unsigned
name|long
name|block_group
parameter_list|,
name|unsigned
name|int
name|bitmap_nr
parameter_list|)
block|{
name|struct
name|ext2_sb_info
modifier|*
name|sb
init|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
operator|->
name|um_e2fs
decl_stmt|;
name|struct
name|ext2_group_desc
modifier|*
name|gdp
decl_stmt|;
name|struct
name|buffer_head
modifier|*
name|bh
decl_stmt|;
name|int
name|error
decl_stmt|;
name|gdp
operator|=
name|get_group_desc
argument_list|(
name|mp
argument_list|,
name|block_group
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|bread
argument_list|(
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
operator|->
name|um_devvp
argument_list|,
name|fsbtodb
argument_list|(
name|sb
argument_list|,
name|gdp
operator|->
name|bg_inode_bitmap
argument_list|)
argument_list|,
name|sb
operator|->
name|s_blocksize
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|bh
argument_list|)
condition|)
name|panic
argument_list|(
literal|"read_inode_bitmap:"
literal|"Cannot read inode bitmap - "
literal|"block_group = %lu, inode_bitmap = %lu"
argument_list|,
name|block_group
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|gdp
operator|->
name|bg_inode_bitmap
argument_list|)
expr_stmt|;
name|sb
operator|->
name|s_inode_bitmap_number
index|[
name|bitmap_nr
index|]
operator|=
name|block_group
expr_stmt|;
name|sb
operator|->
name|s_inode_bitmap
index|[
name|bitmap_nr
index|]
operator|=
name|bh
expr_stmt|;
name|LCK_BUF
argument_list|(
argument|bh
argument_list|)
block|}
end_function

begin_comment
comment|/*  * load_inode_bitmap loads the inode bitmap for a blocks group  *  * It maintains a cache for the last bitmaps loaded.  This cache is managed  * with a LRU algorithm.  *  * Notes:  * 1/ There is one cache per mounted file system.  * 2/ If the file system contains less than EXT2_MAX_GROUP_LOADED groups,  *    this function reads the bitmap without maintaining a LRU cache.  */
end_comment

begin_function
specifier|static
name|int
name|load_inode_bitmap
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|unsigned
name|int
name|block_group
parameter_list|)
block|{
name|struct
name|ext2_sb_info
modifier|*
name|sb
init|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
operator|->
name|um_e2fs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|long
name|inode_bitmap_number
decl_stmt|;
name|struct
name|buffer_head
modifier|*
name|inode_bitmap
decl_stmt|;
if|if
condition|(
name|block_group
operator|>=
name|sb
operator|->
name|s_groups_count
condition|)
name|panic
argument_list|(
literal|"load_inode_bitmap:"
literal|"block_group>= groups_count - "
literal|"block_group = %d, groups_count = %lu"
argument_list|,
name|block_group
argument_list|,
name|sb
operator|->
name|s_groups_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|s_loaded_inode_bitmaps
operator|>
literal|0
operator|&&
name|sb
operator|->
name|s_inode_bitmap_number
index|[
literal|0
index|]
operator|==
name|block_group
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sb
operator|->
name|s_groups_count
operator|<=
name|EXT2_MAX_GROUP_LOADED
condition|)
block|{
if|if
condition|(
name|sb
operator|->
name|s_inode_bitmap
index|[
name|block_group
index|]
condition|)
block|{
if|if
condition|(
name|sb
operator|->
name|s_inode_bitmap_number
index|[
name|block_group
index|]
operator|!=
name|block_group
condition|)
name|panic
argument_list|(
literal|"load_inode_bitmap:"
literal|"block_group != inode_bitmap_number"
argument_list|)
expr_stmt|;
else|else
return|return
name|block_group
return|;
block|}
else|else
block|{
name|read_inode_bitmap
argument_list|(
name|mp
argument_list|,
name|block_group
argument_list|,
name|block_group
argument_list|)
expr_stmt|;
return|return
name|block_group
return|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sb
operator|->
name|s_loaded_inode_bitmaps
operator|&&
name|sb
operator|->
name|s_inode_bitmap_number
index|[
name|i
index|]
operator|!=
name|block_group
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|<
name|sb
operator|->
name|s_loaded_inode_bitmaps
operator|&&
name|sb
operator|->
name|s_inode_bitmap_number
index|[
name|i
index|]
operator|==
name|block_group
condition|)
block|{
name|inode_bitmap_number
operator|=
name|sb
operator|->
name|s_inode_bitmap_number
index|[
name|i
index|]
expr_stmt|;
name|inode_bitmap
operator|=
name|sb
operator|->
name|s_inode_bitmap
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|sb
operator|->
name|s_inode_bitmap_number
index|[
name|j
index|]
operator|=
name|sb
operator|->
name|s_inode_bitmap_number
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|sb
operator|->
name|s_inode_bitmap
index|[
name|j
index|]
operator|=
name|sb
operator|->
name|s_inode_bitmap
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|sb
operator|->
name|s_inode_bitmap_number
index|[
literal|0
index|]
operator|=
name|inode_bitmap_number
expr_stmt|;
name|sb
operator|->
name|s_inode_bitmap
index|[
literal|0
index|]
operator|=
name|inode_bitmap
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sb
operator|->
name|s_loaded_inode_bitmaps
operator|<
name|EXT2_MAX_GROUP_LOADED
condition|)
name|sb
operator|->
name|s_loaded_inode_bitmaps
operator|++
expr_stmt|;
else|else
name|ULCK_BUF
argument_list|(
argument|sb->s_inode_bitmap[EXT2_MAX_GROUP_LOADED -
literal|1
argument|]
argument_list|)
for|for
control|(
name|j
operator|=
name|sb
operator|->
name|s_loaded_inode_bitmaps
operator|-
literal|1
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|sb
operator|->
name|s_inode_bitmap_number
index|[
name|j
index|]
operator|=
name|sb
operator|->
name|s_inode_bitmap_number
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
name|sb
operator|->
name|s_inode_bitmap
index|[
name|j
index|]
operator|=
name|sb
operator|->
name|s_inode_bitmap
index|[
name|j
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|read_inode_bitmap
argument_list|(
name|mp
argument_list|,
name|block_group
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ext2_free_inode
parameter_list|(
name|struct
name|inode
modifier|*
name|inode
parameter_list|)
block|{
name|struct
name|ext2_sb_info
modifier|*
name|sb
decl_stmt|;
name|struct
name|buffer_head
modifier|*
name|bh
decl_stmt|;
name|struct
name|buffer_head
modifier|*
name|bh2
decl_stmt|;
name|unsigned
name|long
name|block_group
decl_stmt|;
name|unsigned
name|long
name|bit
decl_stmt|;
name|int
name|bitmap_nr
decl_stmt|;
name|struct
name|ext2_group_desc
modifier|*
name|gdp
decl_stmt|;
name|struct
name|ext2_super_block
modifier|*
name|es
decl_stmt|;
if|if
condition|(
operator|!
name|inode
condition|)
return|return;
if|if
condition|(
name|inode
operator|->
name|i_nlink
condition|)
block|{
name|printf
argument_list|(
literal|"ext2_free_inode: inode has nlink=%d\n"
argument_list|,
name|inode
operator|->
name|i_nlink
argument_list|)
expr_stmt|;
return|return;
block|}
name|ext2_debug
argument_list|(
literal|"freeing inode %lu\n"
argument_list|,
name|inode
operator|->
name|i_number
argument_list|)
expr_stmt|;
name|sb
operator|=
name|inode
operator|->
name|i_e2fs
expr_stmt|;
name|lock_super
argument_list|(
name|DEVVP
argument_list|(
name|inode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inode
operator|->
name|i_number
operator|<
name|EXT2_FIRST_INO
operator|||
name|inode
operator|->
name|i_number
operator|>
name|sb
operator|->
name|s_es
operator|->
name|s_inodes_count
condition|)
block|{
name|printf
argument_list|(
literal|"free_inode reserved inode or nonexistent inode"
argument_list|)
expr_stmt|;
name|unlock_super
argument_list|(
name|DEVVP
argument_list|(
name|inode
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|es
operator|=
name|sb
operator|->
name|s_es
expr_stmt|;
name|block_group
operator|=
operator|(
name|inode
operator|->
name|i_number
operator|-
literal|1
operator|)
operator|/
name|EXT2_INODES_PER_GROUP
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|bit
operator|=
operator|(
name|inode
operator|->
name|i_number
operator|-
literal|1
operator|)
operator|%
name|EXT2_INODES_PER_GROUP
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|bitmap_nr
operator|=
name|load_inode_bitmap
argument_list|(
name|ITOV
argument_list|(
name|inode
argument_list|)
operator|->
name|v_mount
argument_list|,
name|block_group
argument_list|)
expr_stmt|;
name|bh
operator|=
name|sb
operator|->
name|s_inode_bitmap
index|[
name|bitmap_nr
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|clear_bit
argument_list|(
name|bit
argument_list|,
name|bh
operator|->
name|b_data
argument_list|)
condition|)
name|printf
argument_list|(
literal|"ext2_free_inode:"
literal|"bit already cleared for inode %lu"
argument_list|,
name|inode
operator|->
name|i_number
argument_list|)
expr_stmt|;
else|else
block|{
name|gdp
operator|=
name|get_group_desc
argument_list|(
name|ITOV
argument_list|(
name|inode
argument_list|)
operator|->
name|v_mount
argument_list|,
name|block_group
argument_list|,
operator|&
name|bh2
argument_list|)
expr_stmt|;
name|gdp
operator|->
name|bg_free_inodes_count
operator|++
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|inode
operator|->
name|i_mode
argument_list|)
condition|)
name|gdp
operator|->
name|bg_used_dirs_count
operator|--
expr_stmt|;
name|mark_buffer_dirty
argument_list|(
name|bh2
argument_list|)
expr_stmt|;
name|es
operator|->
name|s_free_inodes_count
operator|++
expr_stmt|;
block|}
name|mark_buffer_dirty
argument_list|(
name|bh
argument_list|)
expr_stmt|;
comment|/*** XXX 	if (sb->s_flags& MS_SYNCHRONOUS) { 		ll_rw_block (WRITE, 1,&bh); 		wait_on_buffer (bh); 	} ***/
name|sb
operator|->
name|s_dirt
operator|=
literal|1
expr_stmt|;
name|unlock_super
argument_list|(
name|DEVVP
argument_list|(
name|inode
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|linux
end_if

begin_comment
comment|/*  * This function increments the inode version number  *  * This may be used one day by the NFS server  */
end_comment

begin_function
specifier|static
name|void
name|inc_inode_version
parameter_list|(
name|struct
name|inode
modifier|*
name|inode
parameter_list|,
name|struct
name|ext2_group_desc
modifier|*
name|gdp
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|unsigned
name|long
name|inode_block
decl_stmt|;
name|struct
name|buffer_head
modifier|*
name|bh
decl_stmt|;
name|struct
name|ext2_inode
modifier|*
name|raw_inode
decl_stmt|;
name|inode_block
operator|=
name|gdp
operator|->
name|bg_inode_table
operator|+
operator|(
operator|(
operator|(
name|inode
operator|->
name|i_number
operator|-
literal|1
operator|)
operator|%
name|EXT2_INODES_PER_GROUP
argument_list|(
name|inode
operator|->
name|i_sb
argument_list|)
operator|)
operator|/
name|EXT2_INODES_PER_BLOCK
argument_list|(
name|inode
operator|->
name|i_sb
argument_list|)
operator|)
expr_stmt|;
name|bh
operator|=
name|bread
argument_list|(
name|inode
operator|->
name|i_sb
operator|->
name|s_dev
argument_list|,
name|inode_block
argument_list|,
name|inode
operator|->
name|i_sb
operator|->
name|s_blocksize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bh
condition|)
block|{
name|printf
argument_list|(
literal|"inc_inode_version Cannot load inode table block - "
literal|"inode=%lu, inode_block=%lu\n"
argument_list|,
name|inode
operator|->
name|i_number
argument_list|,
name|inode_block
argument_list|)
expr_stmt|;
name|inode
operator|->
name|u
operator|.
name|ext2_i
operator|.
name|i_version
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|raw_inode
operator|=
operator|(
operator|(
expr|struct
name|ext2_inode
operator|*
operator|)
name|bh
operator|->
name|b_data
operator|)
operator|+
operator|(
operator|(
operator|(
name|inode
operator|->
name|i_number
operator|-
literal|1
operator|)
operator|%
name|EXT2_INODES_PER_GROUP
argument_list|(
name|inode
operator|->
name|i_sb
argument_list|)
operator|)
operator|%
name|EXT2_INODES_PER_BLOCK
argument_list|(
name|inode
operator|->
name|i_sb
argument_list|)
operator|)
expr_stmt|;
name|raw_inode
operator|->
name|i_version
operator|++
expr_stmt|;
name|inode
operator|->
name|u
operator|.
name|ext2_i
operator|.
name|i_version
operator|=
name|raw_inode
operator|->
name|i_version
expr_stmt|;
name|mark_buffer_dirty
argument_list|(
name|bh
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bh
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* linux */
end_comment

begin_comment
comment|/*  * There are two policies for allocating an inode.  If the new inode is  * a directory, then a forward search is made for a block group with both  * free space and a low directory-to-inode ratio; if that fails, then of  * the groups with above-average free space, that group with the fewest  * directories already is chosen.  *  * For other inodes, search forward from the parent directory\'s block  * group to find a free inode.  */
end_comment

begin_comment
comment|/*  * this functino has been reduced to the actual 'find the inode number' part  */
end_comment

begin_function
name|ino_t
name|ext2_new_inode
parameter_list|(
specifier|const
name|struct
name|inode
modifier|*
name|dir
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|ext2_sb_info
modifier|*
name|sb
decl_stmt|;
name|struct
name|buffer_head
modifier|*
name|bh
decl_stmt|;
name|struct
name|buffer_head
modifier|*
name|bh2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|avefreei
decl_stmt|;
name|int
name|bitmap_nr
decl_stmt|;
name|struct
name|ext2_group_desc
modifier|*
name|gdp
decl_stmt|;
name|struct
name|ext2_group_desc
modifier|*
name|tmp
decl_stmt|;
name|struct
name|ext2_super_block
modifier|*
name|es
decl_stmt|;
if|if
condition|(
operator|!
name|dir
condition|)
return|return
literal|0
return|;
name|sb
operator|=
name|dir
operator|->
name|i_e2fs
expr_stmt|;
name|lock_super
argument_list|(
name|DEVVP
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
name|es
operator|=
name|sb
operator|->
name|s_es
expr_stmt|;
name|repeat
label|:
name|gdp
operator|=
name|NULL
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|avefreei
operator|=
name|es
operator|->
name|s_free_inodes_count
operator|/
name|sb
operator|->
name|s_groups_count
expr_stmt|;
comment|/* I am not yet convinced that this next bit is necessary. 		i = dir->u.ext2_i.i_block_group; 		for (j = 0; j< sb->u.ext2_sb.s_groups_count; j++) { 			tmp = get_group_desc (sb, i,&bh2); 			if ((tmp->bg_used_dirs_count<< 8)<  			    tmp->bg_free_inodes_count) { 				gdp = tmp; 				break; 			} 			else 			i = ++i % sb->u.ext2_sb.s_groups_count; 		} */
if|if
condition|(
operator|!
name|gdp
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|sb
operator|->
name|s_groups_count
condition|;
name|j
operator|++
control|)
block|{
name|tmp
operator|=
name|get_group_desc
argument_list|(
name|ITOV
argument_list|(
name|dir
argument_list|)
operator|->
name|v_mount
argument_list|,
name|j
argument_list|,
operator|&
name|bh2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|bg_free_inodes_count
operator|&&
name|tmp
operator|->
name|bg_free_inodes_count
operator|>=
name|avefreei
condition|)
block|{
if|if
condition|(
operator|!
name|gdp
operator|||
operator|(
name|tmp
operator|->
name|bg_free_blocks_count
operator|>
name|gdp
operator|->
name|bg_free_blocks_count
operator|)
condition|)
block|{
name|i
operator|=
name|j
expr_stmt|;
name|gdp
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * Try to place the inode in its parent directory 		 */
name|i
operator|=
name|dir
operator|->
name|i_block_group
expr_stmt|;
name|tmp
operator|=
name|get_group_desc
argument_list|(
name|ITOV
argument_list|(
name|dir
argument_list|)
operator|->
name|v_mount
argument_list|,
name|i
argument_list|,
operator|&
name|bh2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|bg_free_inodes_count
condition|)
name|gdp
operator|=
name|tmp
expr_stmt|;
else|else
block|{
comment|/* 			 * Use a quadratic hash to find a group with a 			 * free inode 			 */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|sb
operator|->
name|s_groups_count
condition|;
name|j
operator|<<=
literal|1
control|)
block|{
name|i
operator|+=
name|j
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|sb
operator|->
name|s_groups_count
condition|)
name|i
operator|-=
name|sb
operator|->
name|s_groups_count
expr_stmt|;
name|tmp
operator|=
name|get_group_desc
argument_list|(
name|ITOV
argument_list|(
name|dir
argument_list|)
operator|->
name|v_mount
argument_list|,
name|i
argument_list|,
operator|&
name|bh2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|bg_free_inodes_count
condition|)
block|{
name|gdp
operator|=
name|tmp
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|gdp
condition|)
block|{
comment|/* 			 * That failed: try linear search for a free inode 			 */
name|i
operator|=
name|dir
operator|->
name|i_block_group
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|2
init|;
name|j
operator|<
name|sb
operator|->
name|s_groups_count
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|++
name|i
operator|>=
name|sb
operator|->
name|s_groups_count
condition|)
name|i
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|get_group_desc
argument_list|(
name|ITOV
argument_list|(
name|dir
argument_list|)
operator|->
name|v_mount
argument_list|,
name|i
argument_list|,
operator|&
name|bh2
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|bg_free_inodes_count
condition|)
block|{
name|gdp
operator|=
name|tmp
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|gdp
condition|)
block|{
name|unlock_super
argument_list|(
name|DEVVP
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bitmap_nr
operator|=
name|load_inode_bitmap
argument_list|(
name|ITOV
argument_list|(
name|dir
argument_list|)
operator|->
name|v_mount
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bh
operator|=
name|sb
operator|->
name|s_inode_bitmap
index|[
name|bitmap_nr
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|=
name|find_first_zero_bit
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|bh
operator|->
name|b_data
argument_list|,
name|EXT2_INODES_PER_GROUP
argument_list|(
name|sb
argument_list|)
argument_list|)
operator|)
operator|<
name|EXT2_INODES_PER_GROUP
argument_list|(
name|sb
argument_list|)
condition|)
block|{
if|if
condition|(
name|set_bit
argument_list|(
name|j
argument_list|,
name|bh
operator|->
name|b_data
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"ext2_new_inode:"
literal|"bit already set for inode %d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
comment|/* Linux now does the following: 		mark_buffer_dirty(bh); 		if (sb->s_flags& MS_SYNCHRONOUS) { 			ll_rw_block (WRITE, 1,&bh); 			wait_on_buffer (bh); 		} */
name|mark_buffer_dirty
argument_list|(
name|bh
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|gdp
operator|->
name|bg_free_inodes_count
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ext2_new_inode:"
literal|"Free inodes count corrupted in group %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|unlock_super
argument_list|(
name|DEVVP
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
goto|goto
name|repeat
goto|;
block|}
name|j
operator|+=
name|i
operator|*
name|EXT2_INODES_PER_GROUP
argument_list|(
name|sb
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|EXT2_FIRST_INO
operator|||
name|j
operator|>
name|es
operator|->
name|s_inodes_count
condition|)
block|{
name|printf
argument_list|(
literal|"ext2_new_inode:"
literal|"reserved inode or inode> inodes count - "
literal|"block_group = %d,inode=%d"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|unlock_super
argument_list|(
name|DEVVP
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|gdp
operator|->
name|bg_free_inodes_count
operator|--
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|)
name|gdp
operator|->
name|bg_used_dirs_count
operator|++
expr_stmt|;
name|mark_buffer_dirty
argument_list|(
name|bh2
argument_list|)
expr_stmt|;
name|es
operator|->
name|s_free_inodes_count
operator|--
expr_stmt|;
comment|/* mark_buffer_dirty(sb->u.ext2_sb.s_sbh, 1); */
name|sb
operator|->
name|s_dirt
operator|=
literal|1
expr_stmt|;
name|unlock_super
argument_list|(
name|DEVVP
argument_list|(
name|dir
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|j
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|unused
end_ifdef

begin_function
specifier|static
name|unsigned
name|long
name|ext2_count_free_inodes
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|EXT2FS_DEBUG
name|struct
name|ext2_sb_info
modifier|*
name|sb
init|=
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
operator|->
name|um_e2fs
decl_stmt|;
name|struct
name|ext2_super_block
modifier|*
name|es
decl_stmt|;
name|unsigned
name|long
name|desc_count
decl_stmt|,
name|bitmap_count
decl_stmt|,
name|x
decl_stmt|;
name|int
name|bitmap_nr
decl_stmt|;
name|struct
name|ext2_group_desc
modifier|*
name|gdp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lock_super
argument_list|(
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
operator|->
name|um_devvp
argument_list|)
expr_stmt|;
name|es
operator|=
name|sb
operator|->
name|s_es
expr_stmt|;
name|desc_count
operator|=
literal|0
expr_stmt|;
name|bitmap_count
operator|=
literal|0
expr_stmt|;
name|gdp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sb
operator|->
name|s_groups_count
condition|;
name|i
operator|++
control|)
block|{
name|gdp
operator|=
name|get_group_desc
argument_list|(
name|mp
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|desc_count
operator|+=
name|gdp
operator|->
name|bg_free_inodes_count
expr_stmt|;
name|bitmap_nr
operator|=
name|load_inode_bitmap
argument_list|(
name|mp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|x
operator|=
name|ext2_count_free
argument_list|(
name|sb
operator|->
name|s_inode_bitmap
index|[
name|bitmap_nr
index|]
argument_list|,
name|EXT2_INODES_PER_GROUP
argument_list|(
name|sb
argument_list|)
operator|/
literal|8
argument_list|)
expr_stmt|;
name|ext2_debug
argument_list|(
literal|"group %d: stored = %d, counted = %lu\n"
argument_list|,
name|i
argument_list|,
name|gdp
operator|->
name|bg_free_inodes_count
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|bitmap_count
operator|+=
name|x
expr_stmt|;
block|}
name|ext2_debug
argument_list|(
literal|"stored = %lu, computed = %lu, %lu\n"
argument_list|,
name|es
operator|->
name|s_free_inodes_count
argument_list|,
name|desc_count
argument_list|,
name|bitmap_count
argument_list|)
expr_stmt|;
name|unlock_super
argument_list|(
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
operator|->
name|um_devvp
argument_list|)
expr_stmt|;
return|return
name|desc_count
return|;
else|#
directive|else
return|return
name|VFSTOUFS
argument_list|(
name|mp
argument_list|)
operator|->
name|um_e2fsb
operator|->
name|s_free_inodes_count
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* unused */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LATER
end_ifdef

begin_function
name|void
name|ext2_check_inodes_bitmap
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|ext2_super_block
modifier|*
name|es
decl_stmt|;
name|unsigned
name|long
name|desc_count
decl_stmt|,
name|bitmap_count
decl_stmt|,
name|x
decl_stmt|;
name|int
name|bitmap_nr
decl_stmt|;
name|struct
name|ext2_group_desc
modifier|*
name|gdp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lock_super
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|es
operator|=
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_es
expr_stmt|;
name|desc_count
operator|=
literal|0
expr_stmt|;
name|bitmap_count
operator|=
literal|0
expr_stmt|;
name|gdp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_groups_count
condition|;
name|i
operator|++
control|)
block|{
name|gdp
operator|=
name|get_group_desc
argument_list|(
name|sb
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|desc_count
operator|+=
name|gdp
operator|->
name|bg_free_inodes_count
expr_stmt|;
name|bitmap_nr
operator|=
name|load_inode_bitmap
argument_list|(
name|sb
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|x
operator|=
name|ext2_count_free
argument_list|(
name|sb
operator|->
name|u
operator|.
name|ext2_sb
operator|.
name|s_inode_bitmap
index|[
name|bitmap_nr
index|]
argument_list|,
name|EXT2_INODES_PER_GROUP
argument_list|(
name|sb
argument_list|)
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdp
operator|->
name|bg_free_inodes_count
operator|!=
name|x
condition|)
name|printf
argument_list|(
literal|"ext2_check_inodes_bitmap:"
literal|"Wrong free inodes count in group %d, "
literal|"stored = %d, counted = %lu"
argument_list|,
name|i
argument_list|,
name|gdp
operator|->
name|bg_free_inodes_count
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|bitmap_count
operator|+=
name|x
expr_stmt|;
block|}
if|if
condition|(
name|es
operator|->
name|s_free_inodes_count
operator|!=
name|bitmap_count
condition|)
name|printf
argument_list|(
literal|"ext2_check_inodes_bitmap:"
literal|"Wrong free inodes count in super block, "
literal|"stored = %lu, counted = %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|es
operator|->
name|s_free_inodes_count
argument_list|,
name|bitmap_count
argument_list|)
expr_stmt|;
name|unlock_super
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

