begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * $Id: bitops.h,v 1.31 2000/09/23 02:09:21 davem Exp $  * bitops.h: Bit string operations on the V9.  *  * Copyright 1996, 1997 David S. Miller (davem@caip.rutgers.edu)  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SPARC64_BITOPS_H
end_ifndef

begin_define
define|#
directive|define
name|_SPARC64_BITOPS_H
end_define

begin_include
include|#
directive|include
file|<asm/byteorder.h>
end_include

begin_function_decl
specifier|extern
name|long
name|__test_and_set_bit
parameter_list|(
name|unsigned
name|long
name|nr
parameter_list|,
specifier|volatile
name|void
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|__test_and_clear_bit
parameter_list|(
name|unsigned
name|long
name|nr
parameter_list|,
specifier|volatile
name|void
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|__test_and_change_bit
parameter_list|(
name|unsigned
name|long
name|nr
parameter_list|,
specifier|volatile
name|void
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|test_and_set_bit
parameter_list|(
name|nr
parameter_list|,
name|addr
parameter_list|)
value|(__test_and_set_bit(nr,addr)!=0)
end_define

begin_define
define|#
directive|define
name|test_and_clear_bit
parameter_list|(
name|nr
parameter_list|,
name|addr
parameter_list|)
value|(__test_and_clear_bit(nr,addr)!=0)
end_define

begin_define
define|#
directive|define
name|test_and_change_bit
parameter_list|(
name|nr
parameter_list|,
name|addr
parameter_list|)
value|(__test_and_change_bit(nr,addr)!=0)
end_define

begin_define
define|#
directive|define
name|set_bit
parameter_list|(
name|nr
parameter_list|,
name|addr
parameter_list|)
value|((void)__test_and_set_bit(nr,addr))
end_define

begin_define
define|#
directive|define
name|clear_bit
parameter_list|(
name|nr
parameter_list|,
name|addr
parameter_list|)
value|((void)__test_and_clear_bit(nr,addr))
end_define

begin_define
define|#
directive|define
name|change_bit
parameter_list|(
name|nr
parameter_list|,
name|addr
parameter_list|)
value|((void)__test_and_change_bit(nr,addr))
end_define

begin_define
define|#
directive|define
name|smp_mb__before_clear_bit
parameter_list|()
value|do { } while(0)
end_define

begin_define
define|#
directive|define
name|smp_mb__after_clear_bit
parameter_list|()
value|do { } while(0)
end_define

begin_function
specifier|extern
name|__inline__
name|int
name|test_bit
parameter_list|(
name|int
name|nr
parameter_list|,
name|__const__
name|void
modifier|*
name|addr
parameter_list|)
block|{
return|return
operator|(
literal|1UL
operator|&
operator|(
operator|(
operator|(
name|__const__
name|long
operator|*
operator|)
name|addr
operator|)
index|[
name|nr
operator|>>
literal|6
index|]
operator|>>
operator|(
name|nr
operator|&
literal|63
operator|)
operator|)
operator|)
operator|!=
literal|0UL
return|;
block|}
end_function

begin_comment
comment|/* The easy/cheese version for now. */
end_comment

begin_function
specifier|extern
name|__inline__
name|unsigned
name|long
name|ffz
parameter_list|(
name|unsigned
name|long
name|word
parameter_list|)
block|{
name|unsigned
name|long
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|ULTRA_HAS_POPULATION_COUNT
comment|/* Thanks for nothing Sun... */
asm|__asm__
specifier|__volatile__
asm|(" 	brz,pn	%0, 1f 	 neg	%0, %%g1 	xnor	%0, %%g1, %%g2 	popc	%%g2, %0 1:	" : "=&r" (result) 	  : "0" (word) 	  : "g1", "g2");
else|#
directive|else
if|#
directive|if
literal|1
comment|/* def EASY_CHEESE_VERSION */
name|result
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|word
operator|&
literal|1
condition|)
block|{
name|result
operator|++
expr_stmt|;
name|word
operator|>>=
literal|1
expr_stmt|;
block|}
else|#
directive|else
name|unsigned
name|long
name|tmp
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
operator|~
name|word
operator|&
operator|-
operator|~
name|word
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|unsigned
operator|)
name|tmp
condition|)
block|{
name|tmp
operator|>>=
literal|32
expr_stmt|;
name|result
operator|=
literal|32
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|unsigned
name|short
operator|)
name|tmp
condition|)
block|{
name|tmp
operator|>>=
literal|16
expr_stmt|;
name|result
operator|+=
literal|16
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|unsigned
name|char
operator|)
name|tmp
condition|)
block|{
name|tmp
operator|>>=
literal|8
expr_stmt|;
name|result
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|tmp
operator|&
literal|0xf0
condition|)
name|result
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
literal|0xcc
condition|)
name|result
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|tmp
operator|&
literal|0xaa
condition|)
name|result
operator|++
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
name|result
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__KERNEL__
end_ifdef

begin_comment
comment|/*  * ffs: find first bit set. This is defined the same way as  * the libc and compiler builtin ffs routines, therefore  * differs in spirit from the above ffz (man ffs).  */
end_comment

begin_define
define|#
directive|define
name|ffs
parameter_list|(
name|x
parameter_list|)
value|generic_ffs(x)
end_define

begin_comment
comment|/*  * hweightN: returns the hamming weight (i.e. the number  * of bits set) of a N-bit word  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ULTRA_HAS_POPULATION_COUNT
end_ifdef

begin_function
specifier|extern
name|__inline__
name|unsigned
name|int
name|hweight32
parameter_list|(
name|unsigned
name|int
name|w
parameter_list|)
block|{
name|unsigned
name|int
name|res
decl_stmt|;
asm|__asm__ ("popc %1,%0" : "=r" (res) : "r" (w& 0xffffffff));
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|extern
name|__inline__
name|unsigned
name|int
name|hweight16
parameter_list|(
name|unsigned
name|int
name|w
parameter_list|)
block|{
name|unsigned
name|int
name|res
decl_stmt|;
asm|__asm__ ("popc %1,%0" : "=r" (res) : "r" (w& 0xffff));
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|extern
name|__inline__
name|unsigned
name|int
name|hweight8
parameter_list|(
name|unsigned
name|int
name|w
parameter_list|)
block|{
name|unsigned
name|int
name|res
decl_stmt|;
asm|__asm__ ("popc %1,%0" : "=r" (res) : "r" (w& 0xff));
return|return
name|res
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|hweight32
parameter_list|(
name|x
parameter_list|)
value|generic_hweight32(x)
end_define

begin_define
define|#
directive|define
name|hweight16
parameter_list|(
name|x
parameter_list|)
value|generic_hweight16(x)
end_define

begin_define
define|#
directive|define
name|hweight8
parameter_list|(
name|x
parameter_list|)
value|generic_hweight8(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __KERNEL__ */
end_comment

begin_comment
comment|/* find_next_zero_bit() finds the first zero bit in a bit string of length  * 'size' bits, starting the search at bit 'offset'. This is largely based  * on Linus's ALPHA routines, which are pretty portable BTW.  */
end_comment

begin_function
specifier|extern
name|__inline__
name|unsigned
name|long
name|find_next_zero_bit
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|)
block|{
name|unsigned
name|long
modifier|*
name|p
init|=
operator|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|addr
operator|)
operator|+
operator|(
name|offset
operator|>>
literal|6
operator|)
decl_stmt|;
name|unsigned
name|long
name|result
init|=
name|offset
operator|&
operator|~
literal|63UL
decl_stmt|;
name|unsigned
name|long
name|tmp
decl_stmt|;
if|if
condition|(
name|offset
operator|>=
name|size
condition|)
return|return
name|size
return|;
name|size
operator|-=
name|result
expr_stmt|;
name|offset
operator|&=
literal|63UL
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
name|tmp
operator|=
operator|*
operator|(
name|p
operator|++
operator|)
expr_stmt|;
name|tmp
operator||=
operator|~
literal|0UL
operator|>>
operator|(
literal|64
operator|-
name|offset
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|64
condition|)
goto|goto
name|found_first
goto|;
if|if
condition|(
operator|~
name|tmp
condition|)
goto|goto
name|found_middle
goto|;
name|size
operator|-=
literal|64
expr_stmt|;
name|result
operator|+=
literal|64
expr_stmt|;
block|}
while|while
condition|(
name|size
operator|&
operator|~
literal|63UL
condition|)
block|{
if|if
condition|(
operator|~
operator|(
name|tmp
operator|=
operator|*
operator|(
name|p
operator|++
operator|)
operator|)
condition|)
goto|goto
name|found_middle
goto|;
name|result
operator|+=
literal|64
expr_stmt|;
name|size
operator|-=
literal|64
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|size
condition|)
return|return
name|result
return|;
name|tmp
operator|=
operator|*
name|p
expr_stmt|;
name|found_first
label|:
name|tmp
operator||=
operator|~
literal|0UL
operator|<<
name|size
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
operator|~
literal|0UL
condition|)
comment|/* Are any bits zero? */
return|return
name|result
operator|+
name|size
return|;
comment|/* Nope. */
name|found_middle
label|:
return|return
name|result
operator|+
name|ffz
argument_list|(
name|tmp
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|find_first_zero_bit
parameter_list|(
name|addr
parameter_list|,
name|size
parameter_list|)
define|\
value|find_next_zero_bit((addr), (size), 0)
end_define

begin_function_decl
specifier|extern
name|long
name|__test_and_set_le_bit
parameter_list|(
name|int
name|nr
parameter_list|,
specifier|volatile
name|void
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|long
name|__test_and_clear_le_bit
parameter_list|(
name|int
name|nr
parameter_list|,
specifier|volatile
name|void
modifier|*
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|test_and_set_le_bit
parameter_list|(
name|nr
parameter_list|,
name|addr
parameter_list|)
value|(__test_and_set_le_bit(nr,addr)!=0)
end_define

begin_define
define|#
directive|define
name|test_and_clear_le_bit
parameter_list|(
name|nr
parameter_list|,
name|addr
parameter_list|)
value|(__test_and_clear_le_bit(nr,addr)!=0)
end_define

begin_define
define|#
directive|define
name|set_le_bit
parameter_list|(
name|nr
parameter_list|,
name|addr
parameter_list|)
value|((void)__test_and_set_le_bit(nr,addr))
end_define

begin_define
define|#
directive|define
name|clear_le_bit
parameter_list|(
name|nr
parameter_list|,
name|addr
parameter_list|)
value|((void)__test_and_clear_le_bit(nr,addr))
end_define

begin_function
specifier|extern
name|__inline__
name|int
name|test_le_bit
parameter_list|(
name|int
name|nr
parameter_list|,
name|__const__
name|void
modifier|*
name|addr
parameter_list|)
block|{
name|int
name|mask
decl_stmt|;
name|__const__
name|unsigned
name|char
modifier|*
name|ADDR
init|=
operator|(
name|__const__
name|unsigned
name|char
operator|*
operator|)
name|addr
decl_stmt|;
name|ADDR
operator|+=
name|nr
operator|>>
literal|3
expr_stmt|;
name|mask
operator|=
literal|1
operator|<<
operator|(
name|nr
operator|&
literal|0x07
operator|)
expr_stmt|;
return|return
operator|(
operator|(
name|mask
operator|&
operator|*
name|ADDR
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|find_first_zero_le_bit
parameter_list|(
name|addr
parameter_list|,
name|size
parameter_list|)
define|\
value|find_next_zero_le_bit((addr), (size), 0)
end_define

begin_function
specifier|extern
name|__inline__
name|unsigned
name|long
name|find_next_zero_le_bit
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|unsigned
name|long
name|offset
parameter_list|)
block|{
name|unsigned
name|long
modifier|*
name|p
init|=
operator|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|addr
operator|)
operator|+
operator|(
name|offset
operator|>>
literal|6
operator|)
decl_stmt|;
name|unsigned
name|long
name|result
init|=
name|offset
operator|&
operator|~
literal|63UL
decl_stmt|;
name|unsigned
name|long
name|tmp
decl_stmt|;
if|if
condition|(
name|offset
operator|>=
name|size
condition|)
return|return
name|size
return|;
name|size
operator|-=
name|result
expr_stmt|;
name|offset
operator|&=
literal|63UL
expr_stmt|;
if|if
condition|(
name|offset
condition|)
block|{
name|tmp
operator|=
name|__swab64p
argument_list|(
name|p
operator|++
argument_list|)
expr_stmt|;
name|tmp
operator||=
operator|(
operator|~
literal|0UL
operator|>>
operator|(
literal|64
operator|-
name|offset
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|64
condition|)
goto|goto
name|found_first
goto|;
if|if
condition|(
operator|~
name|tmp
condition|)
goto|goto
name|found_middle
goto|;
name|size
operator|-=
literal|64
expr_stmt|;
name|result
operator|+=
literal|64
expr_stmt|;
block|}
while|while
condition|(
name|size
operator|&
operator|~
literal|63
condition|)
block|{
if|if
condition|(
operator|~
operator|(
name|tmp
operator|=
name|__swab64p
argument_list|(
name|p
operator|++
argument_list|)
operator|)
condition|)
goto|goto
name|found_middle
goto|;
name|result
operator|+=
literal|64
expr_stmt|;
name|size
operator|-=
literal|64
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|size
condition|)
return|return
name|result
return|;
name|tmp
operator|=
name|__swab64p
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|found_first
label|:
name|tmp
operator||=
operator|(
operator|~
literal|0UL
operator|<<
name|size
operator|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
operator|~
literal|0UL
condition|)
comment|/* Are any bits zero? */
return|return
name|result
operator|+
name|size
return|;
comment|/* Nope. */
name|found_middle
label|:
return|return
name|result
operator|+
name|ffz
argument_list|(
name|tmp
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__KERNEL__
end_ifdef

begin_define
define|#
directive|define
name|ext2_set_bit
value|test_and_set_le_bit
end_define

begin_define
define|#
directive|define
name|ext2_clear_bit
value|test_and_clear_le_bit
end_define

begin_define
define|#
directive|define
name|ext2_test_bit
value|test_le_bit
end_define

begin_define
define|#
directive|define
name|ext2_find_first_zero_bit
value|find_first_zero_le_bit
end_define

begin_define
define|#
directive|define
name|ext2_find_next_zero_bit
value|find_next_zero_le_bit
end_define

begin_comment
comment|/* Bitmap functions for the minix filesystem.  */
end_comment

begin_define
define|#
directive|define
name|minix_test_and_set_bit
parameter_list|(
name|nr
parameter_list|,
name|addr
parameter_list|)
value|test_and_set_bit(nr,addr)
end_define

begin_define
define|#
directive|define
name|minix_set_bit
parameter_list|(
name|nr
parameter_list|,
name|addr
parameter_list|)
value|set_bit(nr,addr)
end_define

begin_define
define|#
directive|define
name|minix_test_and_clear_bit
parameter_list|(
name|nr
parameter_list|,
name|addr
parameter_list|)
value|test_and_clear_bit(nr,addr)
end_define

begin_define
define|#
directive|define
name|minix_test_bit
parameter_list|(
name|nr
parameter_list|,
name|addr
parameter_list|)
value|test_bit(nr,addr)
end_define

begin_define
define|#
directive|define
name|minix_find_first_zero_bit
parameter_list|(
name|addr
parameter_list|,
name|size
parameter_list|)
value|find_first_zero_bit(addr,size)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __KERNEL__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(_SPARC64_BITOPS_H) */
end_comment

end_unit

