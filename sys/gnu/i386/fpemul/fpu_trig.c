begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  fpu_trig.c  *  * Implementation of the FPU "transcendental" functions.  *  *  * Copyright (C) 1992,1993,1994  *                       W. Metzenthen, 22 Parker St, Ormond, Vic 3163,  *                       Australia.  E-mail   billm@vaxc.cc.monash.edu.au  * All rights reserved.  *  * This copyright notice covers the redistribution and use of the  * FPU emulator developed by W. Metzenthen. It covers only its use  * in the 386BSD, FreeBSD and NetBSD operating systems. Any other  * use is not permitted under this copyright.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must include information specifying  *    that source code for the emulator is freely available and include  *    either:  *      a) an offer to provide the source code for a nominal distribution  *         fee, or  *      b) list at least two alternative methods whereby the source  *         can be obtained, e.g. a publically accessible bulletin board  *         and an anonymous ftp site from which the software can be  *         downloaded.  * 3. All advertising materials specifically mentioning features or use of  *    this emulator must acknowledge that it was developed by W. Metzenthen.  * 4. The name of W. Metzenthen may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL  * W. METZENTHEN BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *  * The purpose of this copyright, based upon the Berkeley copyright, is to  * ensure that the covered software remains freely available to everyone.  *  * The software (with necessary differences) is also available, but under  * the terms of the GNU copyleft, for the Linux operating system and for  * the djgpp ms-dos extender.  *  * W. Metzenthen   June 1994.  *  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_comment
comment|/* for printf() in EXCEPTION() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/fpemul/fpu_emu.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/fpemul/fpu_system.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/fpemul/exception.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/fpemul/status_w.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/fpemul/reg_constant.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/fpemul/control_w.h>
end_include

begin_function_decl
specifier|static
name|void
name|convert_l2reg
parameter_list|(
name|long
modifier|*
name|arg
parameter_list|,
name|FPU_REG
modifier|*
name|dest
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|trig_arg
parameter_list|(
name|FPU_REG
modifier|*
name|X
parameter_list|)
block|{
name|FPU_REG
name|tmp
decl_stmt|,
name|quot
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|long
name|long
name|q
decl_stmt|;
name|int
name|old_cw
init|=
name|control_word
decl_stmt|;
name|control_word
operator|&=
operator|~
name|CW_RC
expr_stmt|;
name|control_word
operator||=
name|RC_CHOP
expr_stmt|;
name|reg_move
argument_list|(
name|X
argument_list|,
operator|&
name|quot
argument_list|)
expr_stmt|;
name|reg_div
argument_list|(
operator|&
name|quot
argument_list|,
operator|&
name|CONST_PI2
argument_list|,
operator|&
name|quot
argument_list|,
name|FULL_PRECISION
argument_list|)
expr_stmt|;
name|reg_move
argument_list|(
operator|&
name|quot
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|round_to_int
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|sigh
operator|&
literal|0x80000000
condition|)
return|return
operator|-
literal|1
return|;
comment|/* |Arg| is>= 2^63 */
name|tmp
operator|.
name|exp
operator|=
name|EXP_BIAS
operator|+
literal|63
expr_stmt|;
name|q
operator|=
operator|*
operator|(
name|long
name|long
operator|*
operator|)
operator|&
operator|(
name|tmp
operator|.
name|sigl
operator|)
expr_stmt|;
name|normalize
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|reg_sub
argument_list|(
operator|&
name|quot
argument_list|,
operator|&
name|tmp
argument_list|,
name|X
argument_list|,
name|FULL_PRECISION
argument_list|)
expr_stmt|;
name|rv
operator|=
name|q
operator|&
literal|7
expr_stmt|;
name|control_word
operator|=
name|old_cw
expr_stmt|;
return|return
name|rv
return|;
empty_stmt|;
block|}
end_function

begin_comment
comment|/* Convert a long to register */
end_comment

begin_function
specifier|static
name|void
name|convert_l2reg
parameter_list|(
name|long
modifier|*
name|arg
parameter_list|,
name|FPU_REG
modifier|*
name|dest
parameter_list|)
block|{
name|long
name|num
init|=
operator|*
name|arg
decl_stmt|;
if|if
condition|(
name|num
operator|==
literal|0
condition|)
block|{
name|reg_move
argument_list|(
operator|&
name|CONST_Z
argument_list|,
name|dest
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|num
operator|>
literal|0
condition|)
name|dest
operator|->
name|sign
operator|=
name|SIGN_POS
expr_stmt|;
else|else
block|{
name|num
operator|=
operator|-
name|num
expr_stmt|;
name|dest
operator|->
name|sign
operator|=
name|SIGN_NEG
expr_stmt|;
block|}
name|dest
operator|->
name|sigh
operator|=
name|num
expr_stmt|;
name|dest
operator|->
name|sigl
operator|=
literal|0
expr_stmt|;
name|dest
operator|->
name|exp
operator|=
name|EXP_BIAS
operator|+
literal|31
expr_stmt|;
name|dest
operator|->
name|tag
operator|=
name|TW_Valid
expr_stmt|;
name|normalize
argument_list|(
name|dest
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|single_arg_error
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|FPU_st0_tag
condition|)
block|{
case|case
name|TW_NaN
case|:
if|if
condition|(
operator|!
operator|(
name|FPU_st0_ptr
operator|->
name|sigh
operator|&
literal|0x40000000
operator|)
condition|)
block|{
comment|/* Signaling ? */
name|EXCEPTION
argument_list|(
name|EX_Invalid
argument_list|)
expr_stmt|;
comment|/* Convert to a QNaN */
name|FPU_st0_ptr
operator|->
name|sigh
operator||=
literal|0x40000000
expr_stmt|;
block|}
break|break;
comment|/* return with a NaN in st(0) */
case|case
name|TW_Empty
case|:
name|stack_underflow
argument_list|()
expr_stmt|;
comment|/* Puts a QNaN in st(0) */
break|break;
ifdef|#
directive|ifdef
name|PARANOID
default|default:
name|EXCEPTION
argument_list|(
name|EX_INTERNAL
operator||
literal|0x0112
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PARANOID */
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|f2xm1
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|FPU_st0_tag
condition|)
block|{
case|case
name|TW_Valid
case|:
block|{
name|FPU_REG
name|rv
decl_stmt|,
name|tmp
decl_stmt|;
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|sign
operator|==
name|SIGN_POS
condition|)
block|{
comment|/* poly_2xm1(x) requires 0< x< 1. */
if|if
condition|(
name|poly_2xm1
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|rv
argument_list|)
condition|)
return|return;
comment|/* error */
name|reg_mul
argument_list|(
operator|&
name|rv
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|FULL_PRECISION
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* **** Should change poly_2xm1() to at least handle numbers near 0 */
comment|/* poly_2xm1(x) doesn't handle negative 				 * numbers. */
comment|/* So we compute (poly_2xm1(x+1)-1)/2, for -1 				 *< x< 0 */
name|reg_add
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|CONST_1
argument_list|,
operator|&
name|tmp
argument_list|,
name|FULL_PRECISION
argument_list|)
expr_stmt|;
name|poly_2xm1
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|rv
argument_list|)
expr_stmt|;
name|reg_mul
argument_list|(
operator|&
name|rv
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|tmp
argument_list|,
name|FULL_PRECISION
argument_list|)
expr_stmt|;
name|reg_sub
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|CONST_1
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|FULL_PRECISION
argument_list|)
expr_stmt|;
name|FPU_st0_ptr
operator|->
name|exp
operator|--
expr_stmt|;
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
condition|)
name|arith_underflow
argument_list|(
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
case|case
name|TW_Zero
case|:
return|return;
case|case
name|TW_Infinity
case|:
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|sign
operator|==
name|SIGN_NEG
condition|)
block|{
comment|/* -infinity gives -1 (p16-10) */
name|reg_move
argument_list|(
operator|&
name|CONST_1
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
name|FPU_st0_ptr
operator|->
name|sign
operator|=
name|SIGN_NEG
expr_stmt|;
block|}
return|return;
default|default:
name|single_arg_error
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fptan
parameter_list|(
name|void
parameter_list|)
block|{
name|FPU_REG
modifier|*
name|st_new_ptr
decl_stmt|;
name|int
name|q
decl_stmt|;
name|char
name|arg_sign
init|=
name|FPU_st0_ptr
operator|->
name|sign
decl_stmt|;
if|if
condition|(
name|STACK_OVERFLOW
condition|)
block|{
name|stack_overflow
argument_list|()
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|FPU_st0_tag
condition|)
block|{
case|case
name|TW_Valid
case|:
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
name|FPU_st0_ptr
operator|->
name|sign
operator|=
name|SIGN_POS
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|=
name|trig_arg
argument_list|(
name|FPU_st0_ptr
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|q
operator|&
literal|1
condition|)
name|reg_sub
argument_list|(
operator|&
name|CONST_1
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|FULL_PRECISION
argument_list|)
expr_stmt|;
name|poly_tan
argument_list|(
name|FPU_st0_ptr
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
name|FPU_st0_ptr
operator|->
name|sign
operator|=
operator|(
name|q
operator|&
literal|1
operator|)
operator|^
name|arg_sign
expr_stmt|;
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
condition|)
name|arith_underflow
argument_list|(
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
name|push
argument_list|()
expr_stmt|;
name|reg_move
argument_list|(
operator|&
name|CONST_1
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
name|setcc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Operand is out of range */
name|setcc
argument_list|(
name|SW_C2
argument_list|)
expr_stmt|;
name|FPU_st0_ptr
operator|->
name|sign
operator|=
name|arg_sign
expr_stmt|;
comment|/* restore st(0) */
return|return;
block|}
break|break;
case|case
name|TW_Infinity
case|:
comment|/* Operand is out of range */
name|setcc
argument_list|(
name|SW_C2
argument_list|)
expr_stmt|;
name|FPU_st0_ptr
operator|->
name|sign
operator|=
name|arg_sign
expr_stmt|;
comment|/* restore st(0) */
return|return;
case|case
name|TW_Zero
case|:
name|push
argument_list|()
expr_stmt|;
name|reg_move
argument_list|(
operator|&
name|CONST_1
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
name|setcc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|single_arg_error
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fxtract
parameter_list|(
name|void
parameter_list|)
block|{
name|FPU_REG
modifier|*
name|st_new_ptr
decl_stmt|;
specifier|register
name|FPU_REG
modifier|*
name|st1_ptr
init|=
name|FPU_st0_ptr
decl_stmt|;
comment|/* anticipate */
if|if
condition|(
name|STACK_OVERFLOW
condition|)
block|{
name|stack_overflow
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|FPU_st0_tag
operator|^
name|TW_Valid
operator|)
condition|)
block|{
name|long
name|e
decl_stmt|;
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
name|push
argument_list|()
expr_stmt|;
name|reg_move
argument_list|(
name|st1_ptr
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
name|FPU_st0_ptr
operator|->
name|exp
operator|=
name|EXP_BIAS
expr_stmt|;
name|e
operator|=
name|st1_ptr
operator|->
name|exp
operator|-
name|EXP_BIAS
expr_stmt|;
name|convert_l2reg
argument_list|(
operator|&
name|e
argument_list|,
name|st1_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Zero
condition|)
block|{
name|char
name|sign
init|=
name|FPU_st0_ptr
operator|->
name|sign
decl_stmt|;
name|divide_by_zero
argument_list|(
name|SIGN_NEG
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
name|push
argument_list|()
expr_stmt|;
name|reg_move
argument_list|(
operator|&
name|CONST_Z
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
name|FPU_st0_ptr
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Infinity
condition|)
block|{
name|char
name|sign
init|=
name|FPU_st0_ptr
operator|->
name|sign
decl_stmt|;
name|FPU_st0_ptr
operator|->
name|sign
operator|=
name|SIGN_POS
expr_stmt|;
name|push
argument_list|()
expr_stmt|;
name|reg_move
argument_list|(
operator|&
name|CONST_INF
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
name|FPU_st0_ptr
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_NaN
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|FPU_st0_ptr
operator|->
name|sigh
operator|&
literal|0x40000000
operator|)
condition|)
block|{
comment|/* Signaling ? */
name|EXCEPTION
argument_list|(
name|EX_Invalid
argument_list|)
expr_stmt|;
comment|/* Convert to a QNaN */
name|FPU_st0_ptr
operator|->
name|sigh
operator||=
literal|0x40000000
expr_stmt|;
block|}
name|push
argument_list|()
expr_stmt|;
name|reg_move
argument_list|(
name|st1_ptr
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Empty
condition|)
block|{
comment|/* Is this the correct 						 * behaviour? */
if|if
condition|(
name|control_word
operator|&
name|EX_Invalid
condition|)
block|{
name|stack_underflow
argument_list|()
expr_stmt|;
name|push
argument_list|()
expr_stmt|;
name|stack_underflow
argument_list|()
expr_stmt|;
block|}
else|else
name|EXCEPTION
argument_list|(
name|EX_StackUnder
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PARANOID
else|else
name|EXCEPTION
argument_list|(
name|EX_INTERNAL
operator||
literal|0x119
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PARANOID */
block|}
end_function

begin_function
specifier|static
name|void
name|fdecstp
parameter_list|(
name|void
parameter_list|)
block|{
name|top
operator|--
expr_stmt|;
comment|/* FPU_st0_ptr will be fixed in math_emulate() 				 * before the next instr */
block|}
end_function

begin_function
specifier|static
name|void
name|fincstp
parameter_list|(
name|void
parameter_list|)
block|{
name|top
operator|++
expr_stmt|;
comment|/* FPU_st0_ptr will be fixed in math_emulate() 				 * before the next instr */
block|}
end_function

begin_function
specifier|static
name|void
name|fsqrt_
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|FPU_st0_tag
operator|^
name|TW_Valid
operator|)
condition|)
block|{
name|int
name|expon
decl_stmt|;
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|sign
operator|==
name|SIGN_NEG
condition|)
block|{
name|arith_invalid
argument_list|(
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
comment|/* sqrt(negative) is 							 * invalid */
return|return;
block|}
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
name|expon
operator|=
name|FPU_st0_ptr
operator|->
name|exp
operator|-
name|EXP_BIAS
expr_stmt|;
name|FPU_st0_ptr
operator|->
name|exp
operator|=
name|EXP_BIAS
operator|+
operator|(
name|expon
operator|&
literal|1
operator|)
expr_stmt|;
comment|/* make st(0) in  [1.0 								 * .. 4.0) */
name|wm_sqrt
argument_list|(
name|FPU_st0_ptr
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
comment|/* Do the computation */
name|FPU_st0_ptr
operator|->
name|exp
operator|+=
name|expon
operator|>>
literal|1
expr_stmt|;
name|FPU_st0_ptr
operator|->
name|sign
operator|=
name|SIGN_POS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Zero
condition|)
return|return;
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Infinity
condition|)
block|{
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|sign
operator|==
name|SIGN_NEG
condition|)
name|arith_invalid
argument_list|(
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
comment|/* sqrt(-Infinity) is 									 * invalid */
return|return;
block|}
else|else
block|{
name|single_arg_error
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|frndint_
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|FPU_st0_tag
operator|^
name|TW_Valid
operator|)
condition|)
block|{
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|exp
operator|>
name|EXP_BIAS
operator|+
literal|63
condition|)
return|return;
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
name|round_to_int
argument_list|(
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
comment|/* Fortunately, this can't 						 * overflow to 2^64 */
name|FPU_st0_ptr
operator|->
name|exp
operator|=
name|EXP_BIAS
operator|+
literal|63
expr_stmt|;
name|normalize
argument_list|(
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|FPU_st0_tag
operator|==
name|TW_Zero
operator|)
operator|||
operator|(
name|FPU_st0_tag
operator|==
name|TW_Infinity
operator|)
condition|)
return|return;
else|else
name|single_arg_error
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fsin
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|arg_sign
init|=
name|FPU_st0_ptr
operator|->
name|sign
decl_stmt|;
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Valid
condition|)
block|{
name|int
name|q
decl_stmt|;
name|FPU_st0_ptr
operator|->
name|sign
operator|=
name|SIGN_POS
expr_stmt|;
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
if|if
condition|(
operator|(
name|q
operator|=
name|trig_arg
argument_list|(
name|FPU_st0_ptr
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|FPU_REG
name|rv
decl_stmt|;
if|if
condition|(
name|q
operator|&
literal|1
condition|)
name|reg_sub
argument_list|(
operator|&
name|CONST_1
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|FULL_PRECISION
argument_list|)
expr_stmt|;
name|poly_sine
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|rv
argument_list|)
expr_stmt|;
name|setcc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|&
literal|2
condition|)
name|rv
operator|.
name|sign
operator|^=
name|SIGN_POS
operator|^
name|SIGN_NEG
expr_stmt|;
name|rv
operator|.
name|sign
operator|^=
name|arg_sign
expr_stmt|;
name|reg_move
argument_list|(
operator|&
name|rv
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
condition|)
name|arith_underflow
argument_list|(
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
name|set_precision_flag_up
argument_list|()
expr_stmt|;
comment|/* We do not really know 							 * if up or down */
return|return;
block|}
else|else
block|{
comment|/* Operand is out of range */
name|setcc
argument_list|(
name|SW_C2
argument_list|)
expr_stmt|;
name|FPU_st0_ptr
operator|->
name|sign
operator|=
name|arg_sign
expr_stmt|;
comment|/* restore st(0) */
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Zero
condition|)
block|{
name|setcc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Infinity
condition|)
block|{
comment|/* Operand is out of range */
name|setcc
argument_list|(
name|SW_C2
argument_list|)
expr_stmt|;
name|FPU_st0_ptr
operator|->
name|sign
operator|=
name|arg_sign
expr_stmt|;
comment|/* restore st(0) */
return|return;
block|}
else|else
name|single_arg_error
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|f_cos
parameter_list|(
name|FPU_REG
modifier|*
name|arg
parameter_list|)
block|{
name|char
name|arg_sign
init|=
name|arg
operator|->
name|sign
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|tag
operator|==
name|TW_Valid
condition|)
block|{
name|int
name|q
decl_stmt|;
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
name|arg
operator|->
name|sign
operator|=
name|SIGN_POS
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|=
name|trig_arg
argument_list|(
name|arg
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|FPU_REG
name|rv
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|q
operator|&
literal|1
operator|)
condition|)
name|reg_sub
argument_list|(
operator|&
name|CONST_1
argument_list|,
name|arg
argument_list|,
name|arg
argument_list|,
name|FULL_PRECISION
argument_list|)
expr_stmt|;
name|poly_sine
argument_list|(
name|arg
argument_list|,
operator|&
name|rv
argument_list|)
expr_stmt|;
name|setcc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|+
literal|1
operator|)
operator|&
literal|2
condition|)
name|rv
operator|.
name|sign
operator|^=
name|SIGN_POS
operator|^
name|SIGN_NEG
expr_stmt|;
name|reg_move
argument_list|(
operator|&
name|rv
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|set_precision_flag_up
argument_list|()
expr_stmt|;
comment|/* We do not really know 							 * if up or down */
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* Operand is out of range */
name|setcc
argument_list|(
name|SW_C2
argument_list|)
expr_stmt|;
name|arg
operator|->
name|sign
operator|=
name|arg_sign
expr_stmt|;
comment|/* restore st(0) */
return|return
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|arg
operator|->
name|tag
operator|==
name|TW_Zero
condition|)
block|{
name|reg_move
argument_list|(
operator|&
name|CONST_1
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|setcc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Infinity
condition|)
block|{
comment|/* Operand is out of range */
name|setcc
argument_list|(
name|SW_C2
argument_list|)
expr_stmt|;
name|arg
operator|->
name|sign
operator|=
name|arg_sign
expr_stmt|;
comment|/* restore st(0) */
return|return
literal|1
return|;
block|}
else|else
block|{
name|single_arg_error
argument_list|()
expr_stmt|;
comment|/* requires arg == 							 *&st(0) */
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fcos
parameter_list|(
name|void
parameter_list|)
block|{
name|f_cos
argument_list|(
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fsincos
parameter_list|(
name|void
parameter_list|)
block|{
name|FPU_REG
modifier|*
name|st_new_ptr
decl_stmt|;
name|FPU_REG
name|arg
decl_stmt|;
if|if
condition|(
name|STACK_OVERFLOW
condition|)
block|{
name|stack_overflow
argument_list|()
expr_stmt|;
return|return;
block|}
name|reg_move
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|f_cos
argument_list|(
operator|&
name|arg
argument_list|)
condition|)
block|{
name|fsin
argument_list|()
expr_stmt|;
name|push
argument_list|()
expr_stmt|;
name|reg_move
argument_list|(
operator|&
name|arg
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* The following all require two arguments: st(0) and st(1) */
end_comment

begin_comment
comment|/* remainder of st(0) / st(1) */
end_comment

begin_comment
comment|/* Assumes that st(0) and st(1) are both TW_Valid */
end_comment

begin_function
specifier|static
name|void
name|fprem_kernel
parameter_list|(
name|int
name|round
parameter_list|)
block|{
name|FPU_REG
modifier|*
name|st1_ptr
init|=
operator|&
name|st
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|char
name|st1_tag
init|=
name|st1_ptr
operator|->
name|tag
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|FPU_st0_tag
operator|^
name|TW_Valid
operator|)
operator||
operator|(
name|st1_tag
operator|^
name|TW_Valid
operator|)
operator|)
condition|)
block|{
name|FPU_REG
name|tmp
decl_stmt|;
name|int
name|old_cw
init|=
name|control_word
decl_stmt|;
name|int
name|expdif
init|=
name|FPU_st0_ptr
operator|->
name|exp
operator|-
operator|(
name|st1_ptr
operator|)
operator|->
name|exp
decl_stmt|;
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|||
operator|(
name|st1_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
name|control_word
operator|&=
operator|~
name|CW_RC
expr_stmt|;
name|control_word
operator||=
name|round
expr_stmt|;
if|if
condition|(
name|expdif
operator|<
literal|64
condition|)
block|{
comment|/* This should be the most common case */
name|long
name|long
name|q
decl_stmt|;
name|int
name|c
init|=
literal|0
decl_stmt|;
name|reg_div
argument_list|(
name|FPU_st0_ptr
argument_list|,
name|st1_ptr
argument_list|,
operator|&
name|tmp
argument_list|,
name|FULL_PRECISION
argument_list|)
expr_stmt|;
name|round_to_int
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
comment|/* Fortunately, this can't 						 * overflow to 2^64 */
name|tmp
operator|.
name|exp
operator|=
name|EXP_BIAS
operator|+
literal|63
expr_stmt|;
name|q
operator|=
operator|*
operator|(
name|long
name|long
operator|*
operator|)
operator|&
operator|(
name|tmp
operator|.
name|sigl
operator|)
expr_stmt|;
name|normalize
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|reg_mul
argument_list|(
name|st1_ptr
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|tmp
argument_list|,
name|FULL_PRECISION
argument_list|)
expr_stmt|;
name|reg_sub
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|tmp
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|FULL_PRECISION
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|&
literal|4
condition|)
name|c
operator||=
name|SW_C3
expr_stmt|;
if|if
condition|(
name|q
operator|&
literal|2
condition|)
name|c
operator||=
name|SW_C1
expr_stmt|;
if|if
condition|(
name|q
operator|&
literal|1
condition|)
name|c
operator||=
name|SW_C0
expr_stmt|;
name|setcc
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* There is a large exponent difference (>= 64 ) */
name|int
name|N_exp
decl_stmt|;
name|reg_div
argument_list|(
name|FPU_st0_ptr
argument_list|,
name|st1_ptr
argument_list|,
operator|&
name|tmp
argument_list|,
name|FULL_PRECISION
argument_list|)
expr_stmt|;
comment|/* N is 'a number between 32 and 63' (p26-113) */
name|N_exp
operator|=
operator|(
name|tmp
operator|.
name|exp
operator|&
literal|31
operator|)
operator|+
literal|32
expr_stmt|;
name|tmp
operator|.
name|exp
operator|=
name|EXP_BIAS
operator|+
name|N_exp
expr_stmt|;
name|round_to_int
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
comment|/* Fortunately, this can't 						 * overflow to 2^64 */
name|tmp
operator|.
name|exp
operator|=
name|EXP_BIAS
operator|+
literal|63
expr_stmt|;
name|normalize
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|exp
operator|=
name|EXP_BIAS
operator|+
name|expdif
operator|-
name|N_exp
expr_stmt|;
name|reg_mul
argument_list|(
name|st1_ptr
argument_list|,
operator|&
name|tmp
argument_list|,
operator|&
name|tmp
argument_list|,
name|FULL_PRECISION
argument_list|)
expr_stmt|;
name|reg_sub
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|tmp
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|FULL_PRECISION
argument_list|)
expr_stmt|;
name|setcc
argument_list|(
name|SW_C2
argument_list|)
expr_stmt|;
block|}
name|control_word
operator|=
name|old_cw
expr_stmt|;
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
condition|)
name|arith_underflow
argument_list|(
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|FPU_st0_tag
operator|==
name|TW_Empty
operator|)
operator||
operator|(
name|st1_tag
operator|==
name|TW_Empty
operator|)
condition|)
block|{
name|stack_underflow
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Zero
condition|)
block|{
if|if
condition|(
name|st1_tag
operator|==
name|TW_Valid
condition|)
block|{
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|st1_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
name|setcc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|st1_tag
operator|==
name|TW_Zero
condition|)
block|{
name|arith_invalid
argument_list|(
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* fprem(?,0) always invalid */
elseif|else
if|if
condition|(
name|st1_tag
operator|==
name|TW_Infinity
condition|)
block|{
name|setcc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Valid
condition|)
block|{
if|if
condition|(
name|st1_tag
operator|==
name|TW_Zero
condition|)
block|{
name|arith_invalid
argument_list|(
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
comment|/* fprem(Valid,Zero) is 										 * invalid */
return|return;
block|}
elseif|else
if|if
condition|(
name|st1_tag
operator|!=
name|TW_NaN
condition|)
block|{
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
if|if
condition|(
name|st1_tag
operator|==
name|TW_Infinity
condition|)
block|{
comment|/* fprem(Valid, 								 * Infinity) 								 * is o.k. */
name|setcc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Infinity
condition|)
block|{
if|if
condition|(
name|st1_tag
operator|!=
name|TW_NaN
condition|)
block|{
name|arith_invalid
argument_list|(
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
comment|/* fprem(Infinity,?) is 											 * invalid */
return|return;
block|}
block|}
comment|/* One of the registers must contain a NaN is we got here. */
ifdef|#
directive|ifdef
name|PARANOID
if|if
condition|(
operator|(
name|FPU_st0_tag
operator|!=
name|TW_NaN
operator|)
operator|&&
operator|(
name|st1_tag
operator|!=
name|TW_NaN
operator|)
condition|)
name|EXCEPTION
argument_list|(
name|EX_INTERNAL
operator||
literal|0x118
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PARANOID */
name|real_2op_NaN
argument_list|(
name|FPU_st0_ptr
argument_list|,
name|st1_ptr
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ST(1)<- ST(1) * log ST;  pop ST */
end_comment

begin_function
specifier|static
name|void
name|fyl2x
parameter_list|(
name|void
parameter_list|)
block|{
name|FPU_REG
modifier|*
name|st1_ptr
init|=
operator|&
name|st
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|char
name|st1_tag
init|=
name|st1_ptr
operator|->
name|tag
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|FPU_st0_tag
operator|^
name|TW_Valid
operator|)
operator||
operator|(
name|st1_tag
operator|^
name|TW_Valid
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|sign
operator|==
name|SIGN_POS
condition|)
block|{
name|int
name|saved_control
decl_stmt|,
name|saved_status
decl_stmt|;
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|||
operator|(
name|st1_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
comment|/* We use the general purpose arithmetic, so we need 			 * to save these. */
name|saved_status
operator|=
name|status_word
expr_stmt|;
name|saved_control
operator|=
name|control_word
expr_stmt|;
name|control_word
operator|=
name|FULL_PRECISION
expr_stmt|;
name|poly_l2
argument_list|(
name|FPU_st0_ptr
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
comment|/* Enough of the basic arithmetic is done now */
name|control_word
operator|=
name|saved_control
expr_stmt|;
name|status_word
operator|=
name|saved_status
expr_stmt|;
comment|/* Let the multiply set the flags */
name|reg_mul
argument_list|(
name|FPU_st0_ptr
argument_list|,
name|st1_ptr
argument_list|,
name|st1_ptr
argument_list|,
name|FULL_PRECISION
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|FPU_st0_ptr
operator|=
operator|&
name|st
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* negative	 */
name|pop
argument_list|()
expr_stmt|;
name|FPU_st0_ptr
operator|=
operator|&
name|st
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|arith_invalid
argument_list|(
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
comment|/* st(0) cannot be 							 * negative */
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|FPU_st0_tag
operator|==
name|TW_Empty
operator|)
operator|||
operator|(
name|st1_tag
operator|==
name|TW_Empty
operator|)
condition|)
block|{
name|stack_underflow_pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|FPU_st0_tag
operator|==
name|TW_NaN
operator|)
operator|||
operator|(
name|st1_tag
operator|==
name|TW_NaN
operator|)
condition|)
block|{
name|real_2op_NaN
argument_list|(
name|FPU_st0_ptr
argument_list|,
name|st1_ptr
argument_list|,
name|st1_ptr
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|FPU_st0_tag
operator|<=
name|TW_Zero
operator|)
operator|&&
operator|(
name|st1_tag
operator|<=
name|TW_Zero
operator|)
condition|)
block|{
comment|/* one of the args is zero, the other 					 * valid, or both zero */
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Zero
condition|)
block|{
name|pop
argument_list|()
expr_stmt|;
name|FPU_st0_ptr
operator|=
operator|&
name|st
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|tag
operator|==
name|TW_Zero
condition|)
name|arith_invalid
argument_list|(
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
comment|/* Both args zero is 											 * invalid */
ifdef|#
directive|ifdef
name|PECULIAR_486
comment|/* This case is not 						 * specifically covered in the 						 * manual, but divide-by-zero 						 * would seem to be the best 						 * response. However, a real 						 * 80486 does it this way... */
elseif|else
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|tag
operator|==
name|TW_Infinity
condition|)
block|{
name|reg_move
argument_list|(
operator|&
name|CONST_INF
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* PECULIAR_486 */
else|else
name|divide_by_zero
argument_list|(
name|st1_ptr
operator|->
name|sign
operator|^
name|SIGN_NEG
operator|^
name|SIGN_POS
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* st(1) contains zero, st(0) 						 * valid<> 0 */
comment|/* Zero is the valid answer */
name|char
name|sign
init|=
name|st1_ptr
operator|->
name|sign
decl_stmt|;
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|sign
operator|==
name|SIGN_NEG
condition|)
block|{
name|pop
argument_list|()
expr_stmt|;
name|FPU_st0_ptr
operator|=
operator|&
name|st
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|arith_invalid
argument_list|(
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
comment|/* log(negative) */
return|return;
block|}
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<
name|EXP_BIAS
condition|)
name|sign
operator|^=
name|SIGN_NEG
operator|^
name|SIGN_POS
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
name|FPU_st0_ptr
operator|=
operator|&
name|st
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|reg_move
argument_list|(
operator|&
name|CONST_Z
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
name|FPU_st0_ptr
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
return|return;
block|}
block|}
comment|/* One or both arg must be an infinity */
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Infinity
condition|)
block|{
if|if
condition|(
operator|(
name|FPU_st0_ptr
operator|->
name|sign
operator|==
name|SIGN_NEG
operator|)
operator|||
operator|(
name|st1_tag
operator|==
name|TW_Zero
operator|)
condition|)
block|{
name|pop
argument_list|()
expr_stmt|;
name|FPU_st0_ptr
operator|=
operator|&
name|st
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|arith_invalid
argument_list|(
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
comment|/* log(-infinity) or 											 * 0*log(infinity) */
return|return;
block|}
else|else
block|{
name|char
name|sign
init|=
name|st1_ptr
operator|->
name|sign
decl_stmt|;
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|st1_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
name|pop
argument_list|()
expr_stmt|;
name|FPU_st0_ptr
operator|=
operator|&
name|st
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|reg_move
argument_list|(
operator|&
name|CONST_INF
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
name|FPU_st0_ptr
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
return|return;
block|}
block|}
comment|/* st(1) must be infinity here */
elseif|else
if|if
condition|(
operator|(
name|FPU_st0_tag
operator|==
name|TW_Valid
operator|)
operator|&&
operator|(
name|FPU_st0_ptr
operator|->
name|sign
operator|==
name|SIGN_POS
operator|)
condition|)
block|{
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|exp
operator|>=
name|EXP_BIAS
condition|)
block|{
if|if
condition|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|==
name|EXP_BIAS
operator|)
operator|&&
operator|(
name|FPU_st0_ptr
operator|->
name|sigh
operator|==
literal|0x80000000
operator|)
operator|&&
operator|(
name|FPU_st0_ptr
operator|->
name|sigl
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* st(0 									 * ) 									 * hold 									 * s 									 * 1.0 */
name|pop
argument_list|()
expr_stmt|;
name|FPU_st0_ptr
operator|=
operator|&
name|st
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|arith_invalid
argument_list|(
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
comment|/* infinity*log(1) */
return|return;
block|}
comment|/* st(0) is 								 * positive 								 * and> 1.0 */
name|pop
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* st(0) is 								 * positive 								 * and< 1.0 */
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
name|st1_ptr
operator|->
name|sign
operator|^=
name|SIGN_NEG
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
else|else
block|{
comment|/* st(0) must be zero 							 * or negative */
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|tag
operator|==
name|TW_Zero
condition|)
block|{
name|pop
argument_list|()
expr_stmt|;
name|FPU_st0_ptr
operator|=
name|st1_ptr
expr_stmt|;
name|st1_ptr
operator|->
name|sign
operator|^=
name|SIGN_NEG
operator|^
name|SIGN_POS
expr_stmt|;
comment|/* This should 								 * be invalid, 								 * but a real 								 * 80486 is 								 * happy with 								 * it. */
ifndef|#
directive|ifndef
name|PECULIAR_486
name|divide_by_zero
argument_list|(
name|st1_ptr
operator|->
name|sign
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PECULIAR_486 */
block|}
else|else
block|{
name|pop
argument_list|()
expr_stmt|;
name|FPU_st0_ptr
operator|=
name|st1_ptr
expr_stmt|;
name|arith_invalid
argument_list|(
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
comment|/* log(negative) */
block|}
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fpatan
parameter_list|(
name|void
parameter_list|)
block|{
name|FPU_REG
modifier|*
name|st1_ptr
init|=
operator|&
name|st
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|char
name|st1_tag
init|=
name|st1_ptr
operator|->
name|tag
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|FPU_st0_tag
operator|^
name|TW_Valid
operator|)
operator||
operator|(
name|st1_tag
operator|^
name|TW_Valid
operator|)
operator|)
condition|)
block|{
name|int
name|saved_control
decl_stmt|,
name|saved_status
decl_stmt|;
name|FPU_REG
name|sum
decl_stmt|;
name|int
name|quadrant
init|=
name|st1_ptr
operator|->
name|sign
operator||
operator|(
operator|(
name|FPU_st0_ptr
operator|->
name|sign
operator|)
operator|<<
literal|1
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|||
operator|(
name|st1_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
comment|/* We use the general purpose arithmetic so we need to save 		 * these. */
name|saved_status
operator|=
name|status_word
expr_stmt|;
name|saved_control
operator|=
name|control_word
expr_stmt|;
name|control_word
operator|=
name|FULL_PRECISION
expr_stmt|;
name|st1_ptr
operator|->
name|sign
operator|=
name|FPU_st0_ptr
operator|->
name|sign
operator|=
name|SIGN_POS
expr_stmt|;
if|if
condition|(
name|compare
argument_list|(
name|st1_ptr
argument_list|)
operator|==
name|COMP_A_lt_B
condition|)
block|{
name|quadrant
operator||=
literal|4
expr_stmt|;
name|reg_div
argument_list|(
name|FPU_st0_ptr
argument_list|,
name|st1_ptr
argument_list|,
operator|&
name|sum
argument_list|,
name|FULL_PRECISION
argument_list|)
expr_stmt|;
block|}
else|else
name|reg_div
argument_list|(
name|st1_ptr
argument_list|,
name|FPU_st0_ptr
argument_list|,
operator|&
name|sum
argument_list|,
name|FULL_PRECISION
argument_list|)
expr_stmt|;
name|poly_atan
argument_list|(
operator|&
name|sum
argument_list|)
expr_stmt|;
if|if
condition|(
name|quadrant
operator|&
literal|4
condition|)
block|{
name|reg_sub
argument_list|(
operator|&
name|CONST_PI2
argument_list|,
operator|&
name|sum
argument_list|,
operator|&
name|sum
argument_list|,
name|FULL_PRECISION
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|quadrant
operator|&
literal|2
condition|)
block|{
name|reg_sub
argument_list|(
operator|&
name|CONST_PI
argument_list|,
operator|&
name|sum
argument_list|,
operator|&
name|sum
argument_list|,
name|FULL_PRECISION
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|quadrant
operator|&
literal|1
condition|)
name|sum
operator|.
name|sign
operator|^=
name|SIGN_POS
operator|^
name|SIGN_NEG
expr_stmt|;
comment|/* All of the basic arithmetic is done now */
name|control_word
operator|=
name|saved_control
expr_stmt|;
name|status_word
operator|=
name|saved_status
expr_stmt|;
name|reg_move
argument_list|(
operator|&
name|sum
argument_list|,
name|st1_ptr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|FPU_st0_tag
operator|==
name|TW_Empty
operator|)
operator|||
operator|(
name|st1_tag
operator|==
name|TW_Empty
operator|)
condition|)
block|{
name|stack_underflow_pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|FPU_st0_tag
operator|==
name|TW_NaN
operator|)
operator|||
operator|(
name|st1_tag
operator|==
name|TW_NaN
operator|)
condition|)
block|{
name|real_2op_NaN
argument_list|(
name|FPU_st0_ptr
argument_list|,
name|st1_ptr
argument_list|,
name|st1_ptr
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|FPU_st0_tag
operator|==
name|TW_Infinity
operator|)
operator|||
operator|(
name|st1_tag
operator|==
name|TW_Infinity
operator|)
condition|)
block|{
name|char
name|sign
init|=
name|st1_ptr
operator|->
name|sign
decl_stmt|;
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Infinity
condition|)
block|{
if|if
condition|(
name|st1_tag
operator|==
name|TW_Infinity
condition|)
block|{
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|sign
operator|==
name|SIGN_POS
condition|)
block|{
name|reg_move
argument_list|(
operator|&
name|CONST_PI4
argument_list|,
name|st1_ptr
argument_list|)
expr_stmt|;
block|}
else|else
name|reg_add
argument_list|(
operator|&
name|CONST_PI4
argument_list|,
operator|&
name|CONST_PI2
argument_list|,
name|st1_ptr
argument_list|,
name|FULL_PRECISION
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|st1_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|sign
operator|==
name|SIGN_POS
condition|)
block|{
name|reg_move
argument_list|(
operator|&
name|CONST_Z
argument_list|,
name|st1_ptr
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
name|reg_move
argument_list|(
operator|&
name|CONST_PI
argument_list|,
name|st1_ptr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* st(1) is infinity, st(0) 						 * not infinity */
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
name|reg_move
argument_list|(
operator|&
name|CONST_PI2
argument_list|,
name|st1_ptr
argument_list|)
expr_stmt|;
block|}
name|st1_ptr
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|st1_tag
operator|==
name|TW_Zero
condition|)
block|{
comment|/* st(0) must be valid or zero */
name|char
name|sign
init|=
name|st1_ptr
operator|->
name|sign
decl_stmt|;
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|sign
operator|==
name|SIGN_POS
condition|)
block|{
name|reg_move
argument_list|(
operator|&
name|CONST_Z
argument_list|,
name|st1_ptr
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
name|reg_move
argument_list|(
operator|&
name|CONST_PI
argument_list|,
name|st1_ptr
argument_list|)
expr_stmt|;
name|st1_ptr
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Zero
condition|)
block|{
comment|/* st(1) must be 							 * TW_Valid here */
name|char
name|sign
init|=
name|st1_ptr
operator|->
name|sign
decl_stmt|;
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|st1_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
name|reg_move
argument_list|(
operator|&
name|CONST_PI2
argument_list|,
name|st1_ptr
argument_list|)
expr_stmt|;
name|st1_ptr
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PARANOID
else|else
name|EXCEPTION
argument_list|(
name|EX_INTERNAL
operator||
literal|0x220
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PARANOID */
name|pop
argument_list|()
expr_stmt|;
name|set_precision_flag_up
argument_list|()
expr_stmt|;
comment|/* We do not really know if up or down */
block|}
end_function

begin_function
specifier|static
name|void
name|fprem
parameter_list|(
name|void
parameter_list|)
block|{
name|fprem_kernel
argument_list|(
name|RC_CHOP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fprem1
parameter_list|(
name|void
parameter_list|)
block|{
name|fprem_kernel
argument_list|(
name|RC_RND
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fyl2xp1
parameter_list|(
name|void
parameter_list|)
block|{
name|FPU_REG
modifier|*
name|st1_ptr
init|=
operator|&
name|st
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|char
name|st1_tag
init|=
name|st1_ptr
operator|->
name|tag
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|FPU_st0_tag
operator|^
name|TW_Valid
operator|)
operator||
operator|(
name|st1_tag
operator|^
name|TW_Valid
operator|)
operator|)
condition|)
block|{
name|int
name|saved_control
decl_stmt|,
name|saved_status
decl_stmt|;
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|||
operator|(
name|st1_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
comment|/* We use the general purpose arithmetic so we need to save 		 * these. */
name|saved_status
operator|=
name|status_word
expr_stmt|;
name|saved_control
operator|=
name|control_word
expr_stmt|;
name|control_word
operator|=
name|FULL_PRECISION
expr_stmt|;
if|if
condition|(
name|poly_l2p1
argument_list|(
name|FPU_st0_ptr
argument_list|,
name|FPU_st0_ptr
argument_list|)
condition|)
block|{
name|arith_invalid
argument_list|(
name|st1_ptr
argument_list|)
expr_stmt|;
comment|/* poly_l2p1() returned 						 * invalid */
name|pop
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Enough of the basic arithmetic is done now */
name|control_word
operator|=
name|saved_control
expr_stmt|;
name|status_word
operator|=
name|saved_status
expr_stmt|;
comment|/* Let the multiply set the flags */
name|reg_mul
argument_list|(
name|FPU_st0_ptr
argument_list|,
name|st1_ptr
argument_list|,
name|st1_ptr
argument_list|,
name|FULL_PRECISION
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|FPU_st0_tag
operator|==
name|TW_Empty
operator|)
operator||
operator|(
name|st1_tag
operator|==
name|TW_Empty
operator|)
condition|)
block|{
name|stack_underflow_pop
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Zero
condition|)
block|{
if|if
condition|(
name|st1_tag
operator|<=
name|TW_Zero
condition|)
block|{
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|st1_tag
operator|==
name|TW_Valid
operator|)
operator|&&
operator|(
name|st1_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
name|st1_ptr
operator|->
name|sign
operator|^=
name|FPU_st0_ptr
operator|->
name|sign
expr_stmt|;
name|reg_move
argument_list|(
name|FPU_st0_ptr
argument_list|,
name|st1_ptr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|st1_tag
operator|==
name|TW_Infinity
condition|)
block|{
name|arith_invalid
argument_list|(
name|st1_ptr
argument_list|)
expr_stmt|;
comment|/* Infinity*log(1) */
name|pop
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|st1_tag
operator|==
name|TW_NaN
condition|)
block|{
name|real_2op_NaN
argument_list|(
name|FPU_st0_ptr
argument_list|,
name|st1_ptr
argument_list|,
name|st1_ptr
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|PARANOID
else|else
block|{
name|EXCEPTION
argument_list|(
name|EX_INTERNAL
operator||
literal|0x116
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* PARANOID */
name|pop
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Valid
condition|)
block|{
if|if
condition|(
name|st1_tag
operator|==
name|TW_Zero
condition|)
block|{
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|sign
operator|==
name|SIGN_NEG
condition|)
block|{
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|exp
operator|>=
name|EXP_BIAS
condition|)
block|{
comment|/* st(0) holds 								 *<= -1.0 */
name|arith_invalid
argument_list|(
name|st1_ptr
argument_list|)
expr_stmt|;
comment|/* infinity*log(1) */
name|pop
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
name|st1_ptr
operator|->
name|sign
operator|^=
name|SIGN_POS
operator|^
name|SIGN_NEG
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
name|pop
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|st1_tag
operator|==
name|TW_Infinity
condition|)
block|{
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|sign
operator|==
name|SIGN_NEG
condition|)
block|{
if|if
condition|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|>=
name|EXP_BIAS
operator|)
operator|&&
operator|!
operator|(
operator|(
name|FPU_st0_ptr
operator|->
name|sigh
operator|==
literal|0x80000000
operator|)
operator|&&
operator|(
name|FPU_st0_ptr
operator|->
name|sigl
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* st(0) holds 								 *< -1.0 */
name|arith_invalid
argument_list|(
name|st1_ptr
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
name|st1_ptr
operator|->
name|sign
operator|^=
name|SIGN_POS
operator|^
name|SIGN_NEG
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
name|pop
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|st1_tag
operator|==
name|TW_NaN
condition|)
block|{
name|real_2op_NaN
argument_list|(
name|FPU_st0_ptr
argument_list|,
name|st1_ptr
argument_list|,
name|st1_ptr
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_NaN
condition|)
block|{
name|real_2op_NaN
argument_list|(
name|FPU_st0_ptr
argument_list|,
name|st1_ptr
argument_list|,
name|st1_ptr
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Infinity
condition|)
block|{
if|if
condition|(
name|st1_tag
operator|==
name|TW_NaN
condition|)
block|{
name|real_2op_NaN
argument_list|(
name|FPU_st0_ptr
argument_list|,
name|st1_ptr
argument_list|,
name|st1_ptr
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|FPU_st0_ptr
operator|->
name|sign
operator|==
name|SIGN_NEG
operator|)
operator|||
operator|(
name|st1_tag
operator|==
name|TW_Zero
operator|)
condition|)
block|{
name|arith_invalid
argument_list|(
name|st1_ptr
argument_list|)
expr_stmt|;
comment|/* log(infinity) */
name|pop
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* st(1) must be valid 							 * here. */
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|st1_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
comment|/* The Manual says 							 * that log(Infinity) 							 * is invalid, but a 							 * real 80486 sensibly 							 * says that it is 							 * o.k. */
block|{
name|char
name|sign
init|=
name|st1_ptr
operator|->
name|sign
decl_stmt|;
name|reg_move
argument_list|(
operator|&
name|CONST_INF
argument_list|,
name|st1_ptr
argument_list|)
expr_stmt|;
name|st1_ptr
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
block|}
name|pop
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|PARANOID
else|else
block|{
name|EXCEPTION
argument_list|(
name|EX_INTERNAL
operator||
literal|0x117
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PARANOID */
block|}
end_function

begin_function
specifier|static
name|void
name|emu_fscale
parameter_list|(
name|void
parameter_list|)
block|{
name|FPU_REG
modifier|*
name|st1_ptr
init|=
operator|&
name|st
argument_list|(
literal|1
argument_list|)
decl_stmt|;
name|char
name|st1_tag
init|=
name|st1_ptr
operator|->
name|tag
decl_stmt|;
name|int
name|old_cw
init|=
name|control_word
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|FPU_st0_tag
operator|^
name|TW_Valid
operator|)
operator||
operator|(
name|st1_tag
operator|^
name|TW_Valid
operator|)
operator|)
condition|)
block|{
name|long
name|scale
decl_stmt|;
name|FPU_REG
name|tmp
decl_stmt|;
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|||
operator|(
name|st1_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
if|if
condition|(
name|st1_ptr
operator|->
name|exp
operator|>
name|EXP_BIAS
operator|+
literal|30
condition|)
block|{
comment|/* 2^31 is far too large, would require 2^(2^30) or 			 * 2^(-2^30) */
name|char
name|sign
decl_stmt|;
if|if
condition|(
name|st1_ptr
operator|->
name|sign
operator|==
name|SIGN_POS
condition|)
block|{
name|EXCEPTION
argument_list|(
name|EX_Overflow
argument_list|)
expr_stmt|;
name|sign
operator|=
name|FPU_st0_ptr
operator|->
name|sign
expr_stmt|;
name|reg_move
argument_list|(
operator|&
name|CONST_INF
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
name|FPU_st0_ptr
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
block|}
else|else
block|{
name|EXCEPTION
argument_list|(
name|EX_Underflow
argument_list|)
expr_stmt|;
name|sign
operator|=
name|FPU_st0_ptr
operator|->
name|sign
expr_stmt|;
name|reg_move
argument_list|(
operator|&
name|CONST_Z
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
name|FPU_st0_ptr
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
block|}
return|return;
block|}
name|control_word
operator|&=
operator|~
name|CW_RC
expr_stmt|;
name|control_word
operator||=
name|RC_CHOP
expr_stmt|;
name|reg_move
argument_list|(
name|st1_ptr
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|round_to_int
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
comment|/* This can never overflow here */
name|control_word
operator|=
name|old_cw
expr_stmt|;
name|scale
operator|=
name|st1_ptr
operator|->
name|sign
condition|?
operator|-
name|tmp
operator|.
name|sigl
else|:
name|tmp
operator|.
name|sigl
expr_stmt|;
name|scale
operator|+=
name|FPU_st0_ptr
operator|->
name|exp
expr_stmt|;
name|FPU_st0_ptr
operator|->
name|exp
operator|=
name|scale
expr_stmt|;
comment|/* Use round_reg() to properly detect under/overflow etc */
name|round_reg
argument_list|(
name|FPU_st0_ptr
argument_list|,
literal|0
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Valid
condition|)
block|{
if|if
condition|(
name|st1_tag
operator|==
name|TW_Zero
condition|)
block|{
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
return|return;
block|}
if|if
condition|(
name|st1_tag
operator|==
name|TW_Infinity
condition|)
block|{
name|char
name|sign
init|=
name|st1_ptr
operator|->
name|sign
decl_stmt|;
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|FPU_st0_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
if|if
condition|(
name|sign
operator|==
name|SIGN_POS
condition|)
block|{
name|reg_move
argument_list|(
operator|&
name|CONST_INF
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
block|}
else|else
name|reg_move
argument_list|(
operator|&
name|CONST_Z
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
name|FPU_st0_ptr
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|st1_tag
operator|==
name|TW_NaN
condition|)
block|{
name|real_2op_NaN
argument_list|(
name|FPU_st0_ptr
argument_list|,
name|st1_ptr
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Zero
condition|)
block|{
if|if
condition|(
name|st1_tag
operator|==
name|TW_Valid
condition|)
block|{
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|st1_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
return|return;
block|}
elseif|else
if|if
condition|(
name|st1_tag
operator|==
name|TW_Zero
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|st1_tag
operator|==
name|TW_Infinity
condition|)
block|{
if|if
condition|(
name|st1_ptr
operator|->
name|sign
operator|==
name|SIGN_NEG
condition|)
return|return;
else|else
block|{
name|arith_invalid
argument_list|(
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
comment|/* Zero scaled by 												 * +Infinity */
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|st1_tag
operator|==
name|TW_NaN
condition|)
block|{
name|real_2op_NaN
argument_list|(
name|FPU_st0_ptr
argument_list|,
name|st1_ptr
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Infinity
condition|)
block|{
if|if
condition|(
name|st1_tag
operator|==
name|TW_Valid
condition|)
block|{
ifdef|#
directive|ifdef
name|DENORM_OPERAND
if|if
condition|(
operator|(
name|st1_ptr
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|)
operator|&&
operator|(
name|denormal_operand
argument_list|()
operator|)
condition|)
return|return;
endif|#
directive|endif
comment|/* DENORM_OPERAND */
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|st1_tag
operator|==
name|TW_Infinity
operator|)
operator|&&
operator|(
name|st1_ptr
operator|->
name|sign
operator|==
name|SIGN_POS
operator|)
operator|)
operator|||
operator|(
name|st1_tag
operator|==
name|TW_Zero
operator|)
condition|)
return|return;
elseif|else
if|if
condition|(
name|st1_tag
operator|==
name|TW_Infinity
condition|)
block|{
name|arith_invalid
argument_list|(
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
comment|/* Infinity scaled by 											 * -Infinity */
return|return;
block|}
elseif|else
if|if
condition|(
name|st1_tag
operator|==
name|TW_NaN
condition|)
block|{
name|real_2op_NaN
argument_list|(
name|FPU_st0_ptr
argument_list|,
name|st1_ptr
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_NaN
condition|)
block|{
if|if
condition|(
name|st1_tag
operator|!=
name|TW_Empty
condition|)
block|{
name|real_2op_NaN
argument_list|(
name|FPU_st0_ptr
argument_list|,
name|st1_ptr
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|PARANOID
if|if
condition|(
operator|!
operator|(
operator|(
name|FPU_st0_tag
operator|==
name|TW_Empty
operator|)
operator|||
operator|(
name|st1_tag
operator|==
name|TW_Empty
operator|)
operator|)
condition|)
block|{
name|EXCEPTION
argument_list|(
name|EX_INTERNAL
operator||
literal|0x115
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* At least one of st(0), st(1) must be empty */
name|stack_underflow
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*---------------------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|FUNC
name|trig_table_a
index|[]
init|=
block|{
name|f2xm1
block|,
name|fyl2x
block|,
name|fptan
block|,
name|fpatan
block|,
name|fxtract
block|,
name|fprem1
block|,
name|fdecstp
block|,
name|fincstp
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|trig_a
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|trig_table_a
index|[
name|FPU_rm
index|]
operator|)
operator|(
operator|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|FUNC
name|trig_table_b
index|[]
init|=
block|{
name|fprem
block|,
name|fyl2xp1
block|,
name|fsqrt_
block|,
name|fsincos
block|,
name|frndint_
block|,
name|emu_fscale
block|,
name|fsin
block|,
name|fcos
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|trig_b
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|trig_table_b
index|[
name|FPU_rm
index|]
operator|)
operator|(
operator|)
expr_stmt|;
block|}
end_function

end_unit

