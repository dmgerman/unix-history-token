begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  fpu_arith.c  *  * Code to implement the FPU register/register arithmetic instructions  *  *  * Copyright (C) 1992,1993,1994  *                       W. Metzenthen, 22 Parker St, Ormond, Vic 3163,  *                       Australia.  E-mail   billm@vaxc.cc.monash.edu.au  * All rights reserved.  *  * This copyright notice covers the redistribution and use of the  * FPU emulator developed by W. Metzenthen. It covers only its use  * in the 386BSD, FreeBSD and NetBSD operating systems. Any other  * use is not permitted under this copyright.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must include information specifying  *    that source code for the emulator is freely available and include  *    either:  *      a) an offer to provide the source code for a nominal distribution  *         fee, or  *      b) list at least two alternative methods whereby the source  *         can be obtained, e.g. a publically accessible bulletin board  *         and an anonymous ftp site from which the software can be  *         downloaded.  * 3. All advertising materials specifically mentioning features or use of  *    this emulator must acknowledge that it was developed by W. Metzenthen.  * 4. The name of W. Metzenthen may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL  * W. METZENTHEN BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *  * The purpose of this copyright, based upon the Berkeley copyright, is to  * ensure that the covered software remains freely available to everyone.  *  * The software (with necessary differences) is also available, but under  * the terms of the GNU copyleft, for the Linux operating system and for  * the djgpp ms-dos extender.  *  * W. Metzenthen   June 1994.  *  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/fpemul/fpu_emu.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/fpemul/fpu_system.h>
end_include

begin_function
name|void
name|fadd__
parameter_list|()
block|{
comment|/* fadd st,st(i) */
name|reg_add
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fmul__
parameter_list|()
block|{
comment|/* fmul st,st(i) */
name|reg_mul
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fsub__
parameter_list|()
block|{
comment|/* fsub st,st(i) */
name|reg_sub
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fsubr_
parameter_list|()
block|{
comment|/* fsubr st,st(i) */
name|reg_sub
argument_list|(
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fdiv__
parameter_list|()
block|{
comment|/* fdiv st,st(i) */
name|reg_div
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fdivr_
parameter_list|()
block|{
comment|/* fdivr st,st(i) */
name|reg_div
argument_list|(
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fadd_i
parameter_list|()
block|{
comment|/* fadd st(i),st */
name|reg_add
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fmul_i
parameter_list|()
block|{
comment|/* fmul st(i),st */
name|reg_mul
argument_list|(
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|FPU_st0_ptr
argument_list|,
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fsubri
parameter_list|()
block|{
comment|/* fsubr st(i),st */
comment|/* This is the sense of the 80486 manual reg_sub(&st(FPU_rm), 	 * FPU_st0_ptr,&st(FPU_rm), control_word); */
name|reg_sub
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fsub_i
parameter_list|()
block|{
comment|/* fsub st(i),st */
comment|/* This is the sense of the 80486 manual reg_sub(FPU_st0_ptr, 	 *&st(FPU_rm),&st(FPU_rm), control_word); */
name|reg_sub
argument_list|(
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|FPU_st0_ptr
argument_list|,
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fdivri
parameter_list|()
block|{
comment|/* fdivr st(i),st */
name|reg_div
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fdiv_i
parameter_list|()
block|{
comment|/* fdiv st(i),st */
name|reg_div
argument_list|(
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|FPU_st0_ptr
argument_list|,
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|faddp_
parameter_list|()
block|{
comment|/* faddp st(i),st */
name|reg_add
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fmulp_
parameter_list|()
block|{
comment|/* fmulp st(i),st */
name|reg_mul
argument_list|(
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|FPU_st0_ptr
argument_list|,
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fsubrp
parameter_list|()
block|{
comment|/* fsubrp st(i),st */
comment|/* This is the sense of the 80486 manual reg_sub(&st(FPU_rm), 	 * FPU_st0_ptr,&st(FPU_rm), control_word); */
name|reg_sub
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fsubp_
parameter_list|()
block|{
comment|/* fsubp st(i),st */
comment|/* This is the sense of the 80486 manual reg_sub(FPU_st0_ptr, 	 *&st(FPU_rm),&st(FPU_rm), control_word); */
name|reg_sub
argument_list|(
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|FPU_st0_ptr
argument_list|,
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fdivrp
parameter_list|()
block|{
comment|/* fdivrp st(i),st */
name|reg_div
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fdivp_
parameter_list|()
block|{
comment|/* fdivp st(i),st */
name|reg_div
argument_list|(
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|FPU_st0_ptr
argument_list|,
operator|&
name|st
argument_list|(
name|FPU_rm
argument_list|)
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

