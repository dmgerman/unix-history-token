begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  errors.c  *  *  The error handling functions for wm-FPU-emu  *  *  * Copyright (C) 1992,1993,1994  *                       W. Metzenthen, 22 Parker St, Ormond, Vic 3163,  *                       Australia.  E-mail   billm@vaxc.cc.monash.edu.au  * All rights reserved.  *  * This copyright notice covers the redistribution and use of the  * FPU emulator developed by W. Metzenthen. It covers only its use  * in the 386BSD, FreeBSD and NetBSD operating systems. Any other  * use is not permitted under this copyright.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must include information specifying  *    that source code for the emulator is freely available and include  *    either:  *      a) an offer to provide the source code for a nominal distribution  *         fee, or  *      b) list at least two alternative methods whereby the source  *         can be obtained, e.g. a publically accessible bulletin board  *         and an anonymous ftp site from which the software can be  *         downloaded.  * 3. All advertising materials specifically mentioning features or use of  *    this emulator must acknowledge that it was developed by W. Metzenthen.  * 4. The name of W. Metzenthen may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL  * W. METZENTHEN BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *  * The purpose of this copyright, based upon the Berkeley copyright, is to  * ensure that the covered software remains freely available to everyone.  *  * The software (with necessary differences) is also available, but under  * the terms of the GNU copyleft, for the Linux operating system and for  * the djgpp ms-dos extender.  *  * W. Metzenthen   June 1994.  *  *  *    $Id: errors.c,v 1.4 1995/03/16 18:11:10 bde Exp $  *  */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------+  | Note:                                                                     |  |    The file contains code which accesses user memory.                     |  |    Emulator static data may change when user memory is accessed, due to   |  |    other processes using the emulator while swapping is in progress.      |  +---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/fpemul/fpu_emu.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/fpemul/fpu_system.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/fpemul/exception.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/fpemul/status_w.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/fpemul/control_w.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/fpemul/reg_constant.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/fpemul/version.h>
end_include

begin_comment
comment|/* */
end_comment

begin_undef
undef|#
directive|undef
name|PRINT_MESSAGES
end_undef

begin_comment
comment|/* */
end_comment

begin_function
name|void
name|Un_impl
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
name|byte1
decl_stmt|,
name|FPU_modrm
decl_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|byte1
operator|=
name|fubyte
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|FPU_ORIG_EIP
argument_list|)
expr_stmt|;
name|FPU_modrm
operator|=
name|fubyte
argument_list|(
literal|1
operator|+
operator|(
name|unsigned
name|char
operator|*
operator|)
name|FPU_ORIG_EIP
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Unimplemented FPU Opcode at eip=%p : %02x "
argument_list|,
name|FPU_ORIG_EIP
argument_list|,
name|byte1
argument_list|)
expr_stmt|;
if|if
condition|(
name|FPU_modrm
operator|>=
literal|0300
condition|)
name|printf
argument_list|(
literal|"%02x (%02x+%d)\n"
argument_list|,
name|FPU_modrm
argument_list|,
name|FPU_modrm
operator|&
literal|0xf8
argument_list|,
name|FPU_modrm
operator|&
literal|7
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"/%d\n"
argument_list|,
operator|(
name|FPU_modrm
operator|>>
literal|3
operator|)
operator|&
literal|7
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
name|EXCEPTION
argument_list|(
name|EX_Invalid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|emu_printall
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
specifier|static
name|char
modifier|*
name|tag_desc
index|[]
init|=
block|{
literal|"Valid"
block|,
literal|"Zero"
block|,
literal|"ERROR"
block|,
literal|"ERROR"
block|,
literal|"DeNorm"
block|,
literal|"Inf"
block|,
literal|"NaN"
block|,
literal|"Empty"
block|}
decl_stmt|;
name|unsigned
name|char
name|byte1
decl_stmt|,
name|FPU_modrm
decl_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|byte1
operator|=
name|fubyte
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|FPU_ORIG_EIP
argument_list|)
expr_stmt|;
name|FPU_modrm
operator|=
name|fubyte
argument_list|(
literal|1
operator|+
operator|(
name|unsigned
name|char
operator|*
operator|)
name|FPU_ORIG_EIP
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|status_word
operator|&
name|SW_Backward
condition|)
name|printf
argument_list|(
literal|"SW: backward compatibility\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_word
operator|&
name|SW_C3
condition|)
name|printf
argument_list|(
literal|"SW: condition bit 3\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_word
operator|&
name|SW_C2
condition|)
name|printf
argument_list|(
literal|"SW: condition bit 2\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_word
operator|&
name|SW_C1
condition|)
name|printf
argument_list|(
literal|"SW: condition bit 1\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_word
operator|&
name|SW_C0
condition|)
name|printf
argument_list|(
literal|"SW: condition bit 0\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_word
operator|&
name|SW_Summary
condition|)
name|printf
argument_list|(
literal|"SW: exception summary\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_word
operator|&
name|SW_Stack_Fault
condition|)
name|printf
argument_list|(
literal|"SW: stack fault\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_word
operator|&
name|SW_Precision
condition|)
name|printf
argument_list|(
literal|"SW: loss of precision\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_word
operator|&
name|SW_Underflow
condition|)
name|printf
argument_list|(
literal|"SW: underflow\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_word
operator|&
name|SW_Overflow
condition|)
name|printf
argument_list|(
literal|"SW: overflow\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_word
operator|&
name|SW_Zero_Div
condition|)
name|printf
argument_list|(
literal|"SW: divide by zero\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_word
operator|&
name|SW_Denorm_Op
condition|)
name|printf
argument_list|(
literal|"SW: denormalized operand\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_word
operator|&
name|SW_Invalid
condition|)
name|printf
argument_list|(
literal|"SW: invalid operation\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUGGING */
name|status_word
operator|=
name|status_word
operator|&
operator|~
name|SW_Top
expr_stmt|;
name|status_word
operator||=
operator|(
name|top
operator|&
literal|7
operator|)
operator|<<
name|SW_Top_Shift
expr_stmt|;
name|printf
argument_list|(
literal|"At %p: %02x "
argument_list|,
name|FPU_ORIG_EIP
argument_list|,
name|byte1
argument_list|)
expr_stmt|;
if|if
condition|(
name|FPU_modrm
operator|>=
literal|0300
condition|)
name|printf
argument_list|(
literal|"%02x (%02x+%d)\n"
argument_list|,
name|FPU_modrm
argument_list|,
name|FPU_modrm
operator|&
literal|0xf8
argument_list|,
name|FPU_modrm
operator|&
literal|7
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"/%d, mod=%d rm=%d\n"
argument_list|,
operator|(
name|FPU_modrm
operator|>>
literal|3
operator|)
operator|&
literal|7
argument_list|,
operator|(
name|FPU_modrm
operator|>>
literal|6
operator|)
operator|&
literal|3
argument_list|,
name|FPU_modrm
operator|&
literal|7
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" SW: b=%d st=%d es=%d sf=%d cc=%d%d%d%d ef=%d%d%d%d%d%d\n"
argument_list|,
name|status_word
operator|&
literal|0x8000
condition|?
literal|1
else|:
literal|0
argument_list|,
comment|/* busy */
operator|(
name|status_word
operator|&
literal|0x3800
operator|)
operator|>>
literal|11
argument_list|,
comment|/* stack top pointer */
name|status_word
operator|&
literal|0x80
condition|?
literal|1
else|:
literal|0
argument_list|,
comment|/* Error summary status */
name|status_word
operator|&
literal|0x40
condition|?
literal|1
else|:
literal|0
argument_list|,
comment|/* Stack flag */
name|status_word
operator|&
name|SW_C3
condition|?
literal|1
else|:
literal|0
argument_list|,
name|status_word
operator|&
name|SW_C2
condition|?
literal|1
else|:
literal|0
argument_list|,
comment|/* cc */
name|status_word
operator|&
name|SW_C1
condition|?
literal|1
else|:
literal|0
argument_list|,
name|status_word
operator|&
name|SW_C0
condition|?
literal|1
else|:
literal|0
argument_list|,
comment|/* cc */
name|status_word
operator|&
name|SW_Precision
condition|?
literal|1
else|:
literal|0
argument_list|,
name|status_word
operator|&
name|SW_Underflow
condition|?
literal|1
else|:
literal|0
argument_list|,
name|status_word
operator|&
name|SW_Overflow
condition|?
literal|1
else|:
literal|0
argument_list|,
name|status_word
operator|&
name|SW_Zero_Div
condition|?
literal|1
else|:
literal|0
argument_list|,
name|status_word
operator|&
name|SW_Denorm_Op
condition|?
literal|1
else|:
literal|0
argument_list|,
name|status_word
operator|&
name|SW_Invalid
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" CW: ic=%d rc=%d%d pc=%d%d iem=%d     ef=%d%d%d%d%d%d\n"
argument_list|,
name|control_word
operator|&
literal|0x1000
condition|?
literal|1
else|:
literal|0
argument_list|,
operator|(
name|control_word
operator|&
literal|0x800
operator|)
operator|>>
literal|11
argument_list|,
operator|(
name|control_word
operator|&
literal|0x400
operator|)
operator|>>
literal|10
argument_list|,
operator|(
name|control_word
operator|&
literal|0x200
operator|)
operator|>>
literal|9
argument_list|,
operator|(
name|control_word
operator|&
literal|0x100
operator|)
operator|>>
literal|8
argument_list|,
name|control_word
operator|&
literal|0x80
condition|?
literal|1
else|:
literal|0
argument_list|,
name|control_word
operator|&
name|SW_Precision
condition|?
literal|1
else|:
literal|0
argument_list|,
name|control_word
operator|&
name|SW_Underflow
condition|?
literal|1
else|:
literal|0
argument_list|,
name|control_word
operator|&
name|SW_Overflow
condition|?
literal|1
else|:
literal|0
argument_list|,
name|control_word
operator|&
name|SW_Zero_Div
condition|?
literal|1
else|:
literal|0
argument_list|,
name|control_word
operator|&
name|SW_Denorm_Op
condition|?
literal|1
else|:
literal|0
argument_list|,
name|control_word
operator|&
name|SW_Invalid
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|FPU_REG
modifier|*
name|r
init|=
operator|&
name|st
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|r
operator|->
name|tag
condition|)
block|{
case|case
name|TW_Empty
case|:
continue|continue;
break|break;
case|case
name|TW_Zero
case|:
name|printf
argument_list|(
literal|"st(%d)  %c .0000 0000 0000 0000         "
argument_list|,
name|i
argument_list|,
name|r
operator|->
name|sign
condition|?
literal|'-'
else|:
literal|'+'
argument_list|)
expr_stmt|;
break|break;
case|case
name|TW_Valid
case|:
case|case
name|TW_NaN
case|:
case|case
name|TW_Denormal
case|:
case|case
name|TW_Infinity
case|:
name|printf
argument_list|(
literal|"st(%d)  %c .%04x %04x %04x %04x e%+-6d "
argument_list|,
name|i
argument_list|,
name|r
operator|->
name|sign
condition|?
literal|'-'
else|:
literal|'+'
argument_list|,
call|(
name|long
call|)
argument_list|(
name|r
operator|->
name|sigh
operator|>>
literal|16
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|r
operator|->
name|sigh
operator|&
literal|0xFFFF
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|r
operator|->
name|sigl
operator|>>
literal|16
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|r
operator|->
name|sigl
operator|&
literal|0xFFFF
argument_list|)
argument_list|,
name|r
operator|->
name|exp
operator|-
name|EXP_BIAS
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Whoops! Error in errors.c      "
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tag_desc
index|[
operator|(
name|int
operator|)
operator|(
name|unsigned
operator|)
name|r
operator|->
name|tag
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"[data] %c .%04x %04x %04x %04x e%+-6d "
argument_list|,
name|FPU_loaded_data
operator|.
name|sign
condition|?
literal|'-'
else|:
literal|'+'
argument_list|,
call|(
name|long
call|)
argument_list|(
name|FPU_loaded_data
operator|.
name|sigh
operator|>>
literal|16
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|FPU_loaded_data
operator|.
name|sigh
operator|&
literal|0xFFFF
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|FPU_loaded_data
operator|.
name|sigl
operator|>>
literal|16
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|FPU_loaded_data
operator|.
name|sigl
operator|&
literal|0xFFFF
argument_list|)
argument_list|,
name|FPU_loaded_data
operator|.
name|exp
operator|-
name|EXP_BIAS
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|tag_desc
index|[
operator|(
name|int
operator|)
operator|(
name|unsigned
operator|)
name|FPU_loaded_data
operator|.
name|tag
index|]
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
specifier|static
struct|struct
block|{
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|exception_names
index|[]
init|=
block|{
block|{
name|EX_StackOver
block|,
literal|"stack overflow"
block|}
block|,
block|{
name|EX_StackUnder
block|,
literal|"stack underflow"
block|}
block|,
block|{
name|EX_Precision
block|,
literal|"loss of precision"
block|}
block|,
block|{
name|EX_Underflow
block|,
literal|"underflow"
block|}
block|,
block|{
name|EX_Overflow
block|,
literal|"overflow"
block|}
block|,
block|{
name|EX_ZeroDiv
block|,
literal|"divide by zero"
block|}
block|,
block|{
name|EX_Denormal
block|,
literal|"denormalized operand"
block|}
block|,
block|{
name|EX_Invalid
block|,
literal|"invalid operation"
block|}
block|,
block|{
name|EX_INTERNAL
block|,
literal|"INTERNAL BUG in "
name|FPU_VERSION
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  EX_INTERNAL is always given with a code which indicates where the  error was detected.   Internal error types:        0x14   in e14.c        0x1nn  in a *.c file:               0x101  in reg_add_sub.c               0x102  in reg_mul.c               0x103  in poly_sin.c               0x104  in poly_tan.c               0x105  in reg_mul.c 	      0x106  in reg_mov.c               0x107  in fpu_trig.c 	      0x108  in reg_compare.c 	      0x109  in reg_compare.c 	      0x110  in reg_add_sub.c 	      0x111  in interface.c 	      0x112  in fpu_trig.c 	      0x113  in reg_add_sub.c 	      0x114  in reg_ld_str.c 	      0x115  in fpu_trig.c 	      0x116  in fpu_trig.c 	      0x117  in fpu_trig.c 	      0x118  in fpu_trig.c 	      0x119  in fpu_trig.c 	      0x120  in poly_atan.c 	      0x121  in reg_compare.c 	      0x122  in reg_compare.c 	      0x123  in reg_compare.c        0x2nn  in an *.s file:               0x201  in reg_u_add.S               0x202  in reg_u_div.S               0x203  in reg_u_div.S               0x204  in reg_u_div.S               0x205  in reg_u_mul.S               0x206  in reg_u_sub.S               0x207  in wm_sqrt.S 	      0x208  in reg_div.S               0x209  in reg_u_sub.S               0x210  in reg_u_sub.S               0x211  in reg_u_sub.S               0x212  in reg_u_sub.S 	      0x213  in wm_sqrt.S 	      0x214  in wm_sqrt.S 	      0x215  in wm_sqrt.S 	      0x216  in reg_round.S 	      0x217  in reg_round.S 	      0x218  in reg_round.S  */
end_comment

begin_function
name|void
name|exception
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|int_type
decl_stmt|;
name|int_type
operator|=
literal|0
expr_stmt|;
comment|/* Needed only to stop compiler warnings */
if|if
condition|(
name|n
operator|&
name|EX_INTERNAL
condition|)
block|{
name|int_type
operator|=
name|n
operator|-
name|EX_INTERNAL
expr_stmt|;
name|n
operator|=
name|EX_INTERNAL
expr_stmt|;
comment|/* Set lots of exception bits! */
name|status_word
operator||=
operator|(
name|SW_Exc_Mask
operator||
name|SW_Summary
operator||
name|FPU_BUSY
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Extract only the bits which we use to set the status word */
name|n
operator|&=
operator|(
name|SW_Exc_Mask
operator|)
expr_stmt|;
comment|/* Set the corresponding exception bit */
name|status_word
operator||=
name|n
expr_stmt|;
if|if
condition|(
name|status_word
operator|&
operator|~
name|control_word
operator|&
name|CW_Exceptions
condition|)
name|status_word
operator||=
name|SW_Summary
expr_stmt|;
if|if
condition|(
name|n
operator|&
operator|(
name|SW_Stack_Fault
operator||
name|EX_Precision
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|n
operator|&
name|SW_C1
operator|)
condition|)
comment|/* This bit distinguishes over- from underflow 				 * for a stack fault, and roundup from 				 * round-down for precision loss. */
name|status_word
operator|&=
operator|~
name|SW_C1
expr_stmt|;
block|}
block|}
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|~
name|control_word
operator|&
name|n
operator|&
name|CW_Exceptions
operator|)
operator|||
operator|(
name|n
operator|==
name|EX_INTERNAL
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PRINT_MESSAGES
comment|/* My message from the sponsor */
name|printf
argument_list|(
name|FPU_VERSION
literal|" "
name|__DATE__
literal|" (C) W. Metzenthen.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PRINT_MESSAGES */
comment|/* Get a name string for error reporting */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|exception_names
index|[
name|i
index|]
operator|.
name|type
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|exception_names
index|[
name|i
index|]
operator|.
name|type
operator|&
name|n
operator|)
operator|==
name|exception_names
index|[
name|i
index|]
operator|.
name|type
condition|)
break|break;
if|if
condition|(
name|exception_names
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|PRINT_MESSAGES
name|printf
argument_list|(
literal|"FP Exception: %s!\n"
argument_list|,
name|exception_names
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PRINT_MESSAGES */
block|}
else|else
name|printf
argument_list|(
literal|"FP emulator: Unknown Exception: 0x%04x!\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|EX_INTERNAL
condition|)
block|{
name|printf
argument_list|(
literal|"FP emulator: Internal error type 0x%04x\n"
argument_list|,
name|int_type
argument_list|)
expr_stmt|;
name|emu_printall
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PRINT_MESSAGES
else|else
name|emu_printall
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* PRINT_MESSAGES */
comment|/* The 80486 generates an interrupt on the next non-control 		 * FPU instruction. So we need some means of flagging it. We 		 * use the ES (Error Summary) bit for this, assuming that this 		 * is the way a real FPU does it (until I can check it out), 		 * if not, then some method such as the following kludge might 		 * be needed. */
comment|/*      regs[0].tag |= TW_FPU_Interrupt; */
block|}
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__DEBUG__
name|math_abort
argument_list|(
name|SIGFPE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __DEBUG__ */
block|}
end_function

begin_comment
comment|/* Real operation attempted on two operands, one a NaN */
end_comment

begin_function
name|void
name|real_2op_NaN
parameter_list|(
name|FPU_REG
modifier|*
name|a
parameter_list|,
name|FPU_REG
modifier|*
name|b
parameter_list|,
name|FPU_REG
modifier|*
name|dest
parameter_list|)
block|{
name|FPU_REG
modifier|*
name|x
decl_stmt|;
name|int
name|signalling
decl_stmt|;
name|x
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|tag
operator|==
name|TW_NaN
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|tag
operator|==
name|TW_NaN
condition|)
block|{
name|signalling
operator|=
operator|!
operator|(
name|a
operator|->
name|sigh
operator|&
name|b
operator|->
name|sigh
operator|&
literal|0x40000000
operator|)
expr_stmt|;
comment|/* find the "larger" */
if|if
condition|(
operator|*
operator|(
name|long
name|long
operator|*
operator|)
operator|&
operator|(
name|a
operator|->
name|sigl
operator|)
operator|<
operator|*
operator|(
name|long
name|long
operator|*
operator|)
operator|&
operator|(
name|b
operator|->
name|sigl
operator|)
condition|)
name|x
operator|=
name|b
expr_stmt|;
block|}
else|else
block|{
comment|/* return the quiet version of the NaN in a */
name|signalling
operator|=
operator|!
operator|(
name|a
operator|->
name|sigh
operator|&
literal|0x40000000
operator|)
expr_stmt|;
block|}
block|}
elseif|else
ifdef|#
directive|ifdef
name|PARANOID
if|if
condition|(
name|b
operator|->
name|tag
operator|==
name|TW_NaN
condition|)
endif|#
directive|endif
comment|/* PARANOID */
block|{
name|signalling
operator|=
operator|!
operator|(
name|b
operator|->
name|sigh
operator|&
literal|0x40000000
operator|)
expr_stmt|;
name|x
operator|=
name|b
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PARANOID
else|else
block|{
name|signalling
operator|=
literal|0
expr_stmt|;
name|EXCEPTION
argument_list|(
name|EX_INTERNAL
operator||
literal|0x113
argument_list|)
expr_stmt|;
name|x
operator|=
operator|&
name|CONST_QNaN
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PARANOID */
if|if
condition|(
operator|!
name|signalling
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|x
operator|->
name|sigh
operator|&
literal|0x80000000
operator|)
condition|)
comment|/* pseudo-NaN ? */
name|x
operator|=
operator|&
name|CONST_QNaN
expr_stmt|;
name|reg_move
argument_list|(
name|x
argument_list|,
name|dest
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|control_word
operator|&
name|CW_Invalid
condition|)
block|{
comment|/* The masked response */
if|if
condition|(
operator|!
operator|(
name|x
operator|->
name|sigh
operator|&
literal|0x80000000
operator|)
condition|)
comment|/* pseudo-NaN ? */
name|x
operator|=
operator|&
name|CONST_QNaN
expr_stmt|;
name|reg_move
argument_list|(
name|x
argument_list|,
name|dest
argument_list|)
expr_stmt|;
comment|/* ensure a Quiet NaN */
name|dest
operator|->
name|sigh
operator||=
literal|0x40000000
expr_stmt|;
block|}
name|EXCEPTION
argument_list|(
name|EX_Invalid
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Invalid arith operation on Valid registers */
end_comment

begin_function
name|void
name|arith_invalid
parameter_list|(
name|FPU_REG
modifier|*
name|dest
parameter_list|)
block|{
if|if
condition|(
name|control_word
operator|&
name|CW_Invalid
condition|)
block|{
comment|/* The masked response */
name|reg_move
argument_list|(
operator|&
name|CONST_QNaN
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
name|EXCEPTION
argument_list|(
name|EX_Invalid
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Divide a finite number by zero */
end_comment

begin_function
name|void
name|divide_by_zero
parameter_list|(
name|int
name|sign
parameter_list|,
name|FPU_REG
modifier|*
name|dest
parameter_list|)
block|{
if|if
condition|(
name|control_word
operator|&
name|CW_ZeroDiv
condition|)
block|{
comment|/* The masked response */
name|reg_move
argument_list|(
operator|&
name|CONST_INF
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|dest
operator|->
name|sign
operator|=
operator|(
name|unsigned
name|char
operator|)
name|sign
expr_stmt|;
block|}
name|EXCEPTION
argument_list|(
name|EX_ZeroDiv
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* This may be called often, so keep it lean */
end_comment

begin_function
name|void
name|set_precision_flag_up
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|control_word
operator|&
name|CW_Precision
condition|)
name|status_word
operator||=
operator|(
name|SW_Precision
operator||
name|SW_C1
operator|)
expr_stmt|;
comment|/* The masked response */
else|else
name|exception
argument_list|(
name|EX_Precision
operator||
name|SW_C1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This may be called often, so keep it lean */
end_comment

begin_function
name|void
name|set_precision_flag_down
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|control_word
operator|&
name|CW_Precision
condition|)
block|{
comment|/* The masked response */
name|status_word
operator|&=
operator|~
name|SW_C1
expr_stmt|;
name|status_word
operator||=
name|SW_Precision
expr_stmt|;
block|}
else|else
name|exception
argument_list|(
name|EX_Precision
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|denormal_operand
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|control_word
operator|&
name|CW_Denormal
condition|)
block|{
comment|/* The masked response */
name|status_word
operator||=
name|SW_Denorm_Op
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|exception
argument_list|(
name|EX_Denormal
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
name|void
name|arith_overflow
parameter_list|(
name|FPU_REG
modifier|*
name|dest
parameter_list|)
block|{
if|if
condition|(
name|control_word
operator|&
name|CW_Overflow
condition|)
block|{
name|char
name|sign
decl_stmt|;
comment|/* The masked response */
comment|/* **** The response here depends upon the rounding mode */
name|sign
operator|=
name|dest
operator|->
name|sign
expr_stmt|;
name|reg_move
argument_list|(
operator|&
name|CONST_INF
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|dest
operator|->
name|sign
operator|=
name|sign
expr_stmt|;
block|}
else|else
block|{
comment|/* Subtract the magic number from the exponent */
name|dest
operator|->
name|exp
operator|-=
operator|(
literal|3
operator|*
operator|(
literal|1
operator|<<
literal|13
operator|)
operator|)
expr_stmt|;
block|}
comment|/* By definition, precision is lost. It appears that the roundup bit 	 * (C1) is also set by convention. */
name|EXCEPTION
argument_list|(
name|EX_Overflow
operator||
name|EX_Precision
operator||
name|SW_C1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|arith_underflow
parameter_list|(
name|FPU_REG
modifier|*
name|dest
parameter_list|)
block|{
if|if
condition|(
name|control_word
operator|&
name|CW_Underflow
condition|)
block|{
comment|/* The masked response */
if|if
condition|(
name|dest
operator|->
name|exp
operator|<=
name|EXP_UNDER
operator|-
literal|63
condition|)
name|reg_move
argument_list|(
operator|&
name|CONST_Z
argument_list|,
name|dest
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add the magic number to the exponent */
name|dest
operator|->
name|exp
operator|+=
operator|(
literal|3
operator|*
operator|(
literal|1
operator|<<
literal|13
operator|)
operator|)
expr_stmt|;
block|}
name|EXCEPTION
argument_list|(
name|EX_Underflow
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|stack_overflow
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|control_word
operator|&
name|CW_Invalid
condition|)
block|{
comment|/* The masked response */
name|top
operator|--
expr_stmt|;
name|reg_move
argument_list|(
operator|&
name|CONST_QNaN
argument_list|,
name|FPU_st0_ptr
operator|=
operator|&
name|st
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|EXCEPTION
argument_list|(
name|EX_StackOver
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|stack_underflow
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|control_word
operator|&
name|CW_Invalid
condition|)
block|{
comment|/* The masked response */
name|reg_move
argument_list|(
operator|&
name|CONST_QNaN
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
block|}
name|EXCEPTION
argument_list|(
name|EX_StackUnder
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|stack_underflow_i
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|control_word
operator|&
name|CW_Invalid
condition|)
block|{
comment|/* The masked response */
name|reg_move
argument_list|(
operator|&
name|CONST_QNaN
argument_list|,
operator|&
operator|(
name|st
argument_list|(
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|EXCEPTION
argument_list|(
name|EX_StackUnder
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|stack_underflow_pop
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|control_word
operator|&
name|CW_Invalid
condition|)
block|{
comment|/* The masked response */
name|reg_move
argument_list|(
operator|&
name|CONST_QNaN
argument_list|,
operator|&
operator|(
name|st
argument_list|(
name|i
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
block|}
name|EXCEPTION
argument_list|(
name|EX_StackUnder
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

