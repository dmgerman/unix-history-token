begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  fpu_entry.c  *  * The entry function for wm-FPU-emu  *  *  * Copyright (C) 1992,1993,1994  *                       W. Metzenthen, 22 Parker St, Ormond, Vic 3163,  *                       Australia.  E-mail   billm@vaxc.cc.monash.edu.au  * All rights reserved.  *  * This copyright notice covers the redistribution and use of the  * FPU emulator developed by W. Metzenthen. It covers only its use  * in the 386BSD, FreeBSD and NetBSD operating systems. Any other  * use is not permitted under this copyright.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must include information specifying  *    that source code for the emulator is freely available and include  *    either:  *      a) an offer to provide the source code for a nominal distribution  *         fee, or  *      b) list at least two alternative methods whereby the source  *         can be obtained, e.g. a publically accessible bulletin board  *         and an anonymous ftp site from which the software can be  *         downloaded.  * 3. All advertising materials specifically mentioning features or use of  *    this emulator must acknowledge that it was developed by W. Metzenthen.  * 4. The name of W. Metzenthen may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL  * W. METZENTHEN BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *  * The purpose of this copyright, based upon the Berkeley copyright, is to  * ensure that the covered software remains freely available to everyone.  *  * The software (with necessary differences) is also available, but under  * the terms of the GNU copyleft, for the Linux operating system and for  * the djgpp ms-dos extender.  *  * W. Metzenthen   June 1994.  *  * $FreeBSD$  *  */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------+  | Note:                                                                     |  |    The file contains code which accesses user memory.                     |  |    Emulator static data may change when user memory is accessed, due to   |  |    other processes using the emulator while swapping is in progress.      |  +---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------+  | math_emulate() is the sole entry point for wm-FPU-emu                     |  +---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/fpemul/fpu_emu.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/fpemul/fpu_system.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/fpemul/exception.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/fpemul/status_w.h>
end_include

begin_define
define|#
directive|define
name|__BAD__
value|Un_impl
end_define

begin_comment
comment|/* Not implemented */
end_comment

begin_define
define|#
directive|define
name|FPU_LOOKAHEAD
value|1
end_define

begin_comment
comment|/* For performance boost */
end_comment

begin_if
if|#
directive|if
name|FPU_LOOKAHEAD
operator|!=
literal|0
end_if

begin_comment
comment|/* I think thet we have to limit the */
end_comment

begin_define
define|#
directive|define
name|LOOKAHEAD_LIMIT
value|7
end_define

begin_comment
comment|/* Max number of lookahead instructions*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Or else a prog consisting of a million */
end_comment

begin_comment
comment|/* fnops will spend all its time in kernel*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_UNDOC_CODE
end_ifndef

begin_comment
comment|/* Un-documented FPU op-codes supported by 				 * default. */
end_comment

begin_comment
comment|/* WARNING: These codes are not documented by Intel in their 80486 manual    and may not work on FPU clones or later Intel FPUs. */
end_comment

begin_comment
comment|/* Changes to support the un-doc codes provided by Linus Torvalds. */
end_comment

begin_define
define|#
directive|define
name|_d9_d8_
value|fstp_i
end_define

begin_comment
comment|/* unofficial code (19) */
end_comment

begin_define
define|#
directive|define
name|_dc_d0_
value|fcom_st
end_define

begin_comment
comment|/* unofficial code (14) */
end_comment

begin_define
define|#
directive|define
name|_dc_d8_
value|fcompst
end_define

begin_comment
comment|/* unofficial code (1c) */
end_comment

begin_define
define|#
directive|define
name|_dd_c8_
value|fxch_i
end_define

begin_comment
comment|/* unofficial code (0d) */
end_comment

begin_define
define|#
directive|define
name|_de_d0_
value|fcompst
end_define

begin_comment
comment|/* unofficial code (16) */
end_comment

begin_define
define|#
directive|define
name|_df_c0_
value|ffreep
end_define

begin_comment
comment|/* unofficial code (07) ffree + pop */
end_comment

begin_define
define|#
directive|define
name|_df_c8_
value|fxch_i
end_define

begin_comment
comment|/* unofficial code (0f) */
end_comment

begin_define
define|#
directive|define
name|_df_d0_
value|fstp_i
end_define

begin_comment
comment|/* unofficial code (17) */
end_comment

begin_define
define|#
directive|define
name|_df_d8_
value|fstp_i
end_define

begin_comment
comment|/* unofficial code (1f) */
end_comment

begin_decl_stmt
specifier|static
name|FUNC
name|st_instr_table
index|[
literal|64
index|]
init|=
block|{
name|fadd__
block|,
name|fld_i_
block|,
name|__BAD__
block|,
name|__BAD__
block|,
name|fadd_i
block|,
name|ffree_
block|,
name|faddp_
block|,
name|_df_c0_
block|,
name|fmul__
block|,
name|fxch_i
block|,
name|__BAD__
block|,
name|__BAD__
block|,
name|fmul_i
block|,
name|_dd_c8_
block|,
name|fmulp_
block|,
name|_df_c8_
block|,
name|fcom_st
block|,
name|fp_nop
block|,
name|__BAD__
block|,
name|__BAD__
block|,
name|_dc_d0_
block|,
name|fst_i_
block|,
name|_de_d0_
block|,
name|_df_d0_
block|,
name|fcompst
block|,
name|_d9_d8_
block|,
name|__BAD__
block|,
name|__BAD__
block|,
name|_dc_d8_
block|,
name|fstp_i
block|,
name|fcompp
block|,
name|_df_d8_
block|,
name|fsub__
block|,
name|fp_etc
block|,
name|__BAD__
block|,
name|finit_
block|,
name|fsubri
block|,
name|fucom_
block|,
name|fsubrp
block|,
name|fstsw_
block|,
name|fsubr_
block|,
name|fconst
block|,
name|fucompp
block|,
name|__BAD__
block|,
name|fsub_i
block|,
name|fucomp
block|,
name|fsubp_
block|,
name|__BAD__
block|,
name|fdiv__
block|,
name|trig_a
block|,
name|__BAD__
block|,
name|__BAD__
block|,
name|fdivri
block|,
name|__BAD__
block|,
name|fdivrp
block|,
name|__BAD__
block|,
name|fdivr_
block|,
name|trig_b
block|,
name|__BAD__
block|,
name|__BAD__
block|,
name|fdiv_i
block|,
name|__BAD__
block|,
name|fdivp_
block|,
name|__BAD__
block|, }
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Support only documented FPU op-codes */
end_comment

begin_decl_stmt
specifier|static
name|FUNC
name|st_instr_table
index|[
literal|64
index|]
init|=
block|{
name|fadd__
block|,
name|fld_i_
block|,
name|__BAD__
block|,
name|__BAD__
block|,
name|fadd_i
block|,
name|ffree_
block|,
name|faddp_
block|,
name|__BAD__
block|,
name|fmul__
block|,
name|fxch_i
block|,
name|__BAD__
block|,
name|__BAD__
block|,
name|fmul_i
block|,
name|__BAD__
block|,
name|fmulp_
block|,
name|__BAD__
block|,
name|fcom_st
block|,
name|fp_nop
block|,
name|__BAD__
block|,
name|__BAD__
block|,
name|__BAD__
block|,
name|fst_i_
block|,
name|__BAD__
block|,
name|__BAD__
block|,
name|fcompst
block|,
name|__BAD__
block|,
name|__BAD__
block|,
name|__BAD__
block|,
name|__BAD__
block|,
name|fstp_i
block|,
name|fcompp
block|,
name|__BAD__
block|,
name|fsub__
block|,
name|fp_etc
block|,
name|__BAD__
block|,
name|finit_
block|,
name|fsubri
block|,
name|fucom_
block|,
name|fsubrp
block|,
name|fstsw_
block|,
name|fsubr_
block|,
name|fconst
block|,
name|fucompp
block|,
name|__BAD__
block|,
name|fsub_i
block|,
name|fucomp
block|,
name|fsubp_
block|,
name|__BAD__
block|,
name|fdiv__
block|,
name|trig_a
block|,
name|__BAD__
block|,
name|__BAD__
block|,
name|fdivri
block|,
name|__BAD__
block|,
name|fdivrp
block|,
name|__BAD__
block|,
name|fdivr_
block|,
name|trig_b
block|,
name|__BAD__
block|,
name|__BAD__
block|,
name|fdiv_i
block|,
name|__BAD__
block|,
name|fdivp_
block|,
name|__BAD__
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_UNDOC_CODE */
end_comment

begin_define
define|#
directive|define
name|_NONE_
value|0
end_define

begin_comment
comment|/* Take no special action */
end_comment

begin_define
define|#
directive|define
name|_REG0_
value|1
end_define

begin_comment
comment|/* Need to check for not empty st(0) */
end_comment

begin_define
define|#
directive|define
name|_REGI_
value|2
end_define

begin_comment
comment|/* Need to check for not empty st(0) and 				 * st(rm) */
end_comment

begin_define
define|#
directive|define
name|_REGi_
value|0
end_define

begin_comment
comment|/* Uses st(rm) */
end_comment

begin_define
define|#
directive|define
name|_PUSH_
value|3
end_define

begin_comment
comment|/* Need to check for space to push onto stack */
end_comment

begin_define
define|#
directive|define
name|_null_
value|4
end_define

begin_comment
comment|/* Function illegal or not implemented */
end_comment

begin_define
define|#
directive|define
name|_REGIi
value|5
end_define

begin_comment
comment|/* Uses st(0) and st(rm), result to st(rm) */
end_comment

begin_define
define|#
directive|define
name|_REGIp
value|6
end_define

begin_comment
comment|/* Uses st(0) and st(rm), result to st(rm) 				 * then pop */
end_comment

begin_define
define|#
directive|define
name|_REGIc
value|0
end_define

begin_comment
comment|/* Compare st(0) and st(rm) */
end_comment

begin_define
define|#
directive|define
name|_REGIn
value|0
end_define

begin_comment
comment|/* Uses st(0) and st(rm), but handle checks 				 * later */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_UNDOC_CODE
end_ifndef

begin_comment
comment|/* Un-documented FPU op-codes supported by default. (see above) */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|type_table
index|[
literal|64
index|]
init|=
block|{
name|_REGI_
block|,
name|_NONE_
block|,
name|_null_
block|,
name|_null_
block|,
name|_REGIi
block|,
name|_REGi_
block|,
name|_REGIp
block|,
name|_REGi_
block|,
name|_REGI_
block|,
name|_REGIn
block|,
name|_null_
block|,
name|_null_
block|,
name|_REGIi
block|,
name|_REGI_
block|,
name|_REGIp
block|,
name|_REGI_
block|,
name|_REGIc
block|,
name|_NONE_
block|,
name|_null_
block|,
name|_null_
block|,
name|_REGIc
block|,
name|_REG0_
block|,
name|_REGIc
block|,
name|_REG0_
block|,
name|_REGIc
block|,
name|_REG0_
block|,
name|_null_
block|,
name|_null_
block|,
name|_REGIc
block|,
name|_REG0_
block|,
name|_REGIc
block|,
name|_REG0_
block|,
name|_REGI_
block|,
name|_NONE_
block|,
name|_null_
block|,
name|_NONE_
block|,
name|_REGIi
block|,
name|_REGIc
block|,
name|_REGIp
block|,
name|_NONE_
block|,
name|_REGI_
block|,
name|_NONE_
block|,
name|_REGIc
block|,
name|_null_
block|,
name|_REGIi
block|,
name|_REGIc
block|,
name|_REGIp
block|,
name|_null_
block|,
name|_REGI_
block|,
name|_NONE_
block|,
name|_null_
block|,
name|_null_
block|,
name|_REGIi
block|,
name|_null_
block|,
name|_REGIp
block|,
name|_null_
block|,
name|_REGI_
block|,
name|_NONE_
block|,
name|_null_
block|,
name|_null_
block|,
name|_REGIi
block|,
name|_null_
block|,
name|_REGIp
block|,
name|_null_
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Support only documented FPU op-codes */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|type_table
index|[
literal|64
index|]
init|=
block|{
name|_REGI_
block|,
name|_NONE_
block|,
name|_null_
block|,
name|_null_
block|,
name|_REGIi
block|,
name|_REGi_
block|,
name|_REGIp
block|,
name|_null_
block|,
name|_REGI_
block|,
name|_REGIn
block|,
name|_null_
block|,
name|_null_
block|,
name|_REGIi
block|,
name|_null_
block|,
name|_REGIp
block|,
name|_null_
block|,
name|_REGIc
block|,
name|_NONE_
block|,
name|_null_
block|,
name|_null_
block|,
name|_null_
block|,
name|_REG0_
block|,
name|_null_
block|,
name|_null_
block|,
name|_REGIc
block|,
name|_null_
block|,
name|_null_
block|,
name|_null_
block|,
name|_null_
block|,
name|_REG0_
block|,
name|_REGIc
block|,
name|_null_
block|,
name|_REGI_
block|,
name|_NONE_
block|,
name|_null_
block|,
name|_NONE_
block|,
name|_REGIi
block|,
name|_REGIc
block|,
name|_REGIp
block|,
name|_NONE_
block|,
name|_REGI_
block|,
name|_NONE_
block|,
name|_REGIc
block|,
name|_null_
block|,
name|_REGIi
block|,
name|_REGIc
block|,
name|_REGIp
block|,
name|_null_
block|,
name|_REGI_
block|,
name|_NONE_
block|,
name|_null_
block|,
name|_null_
block|,
name|_REGIi
block|,
name|_null_
block|,
name|_REGIp
block|,
name|_null_
block|,
name|_REGI_
block|,
name|_NONE_
block|,
name|_null_
block|,
name|_null_
block|,
name|_REGIi
block|,
name|_null_
block|,
name|_REGIp
block|,
name|_null_
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_UNDOC_CODE */
end_comment

begin_comment
comment|/* Be careful when using any of these global variables...    they might change if swapping is triggered */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|FPU_rm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|FPU_st0_tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FPU_REG
modifier|*
name|FPU_st0_ptr
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PARANOID
end_ifdef

begin_decl_stmt
name|char
name|emulating
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PARANOID */
end_comment

begin_define
define|#
directive|define
name|bswapw
parameter_list|(
name|x
parameter_list|)
value|__asm__("xchgb %%al,%%ah":"=a" (x):"0" ((short)x))
end_define

begin_define
define|#
directive|define
name|math_abort
parameter_list|(
name|signo
parameter_list|)
define|\
value|FPU_EIP = FPU_ORIG_EIP;REENTRANT_CHECK(OFF);return(signo);
end_define

begin_function
specifier|static
name|int
name|math_emulate
parameter_list|(
name|struct
name|trapframe
modifier|*
name|tframe
parameter_list|)
block|{
name|unsigned
name|char
name|FPU_modrm
decl_stmt|;
name|unsigned
name|short
name|code
decl_stmt|;
ifdef|#
directive|ifdef
name|LOOKAHEAD_LIMIT
name|int
name|lookahead_limit
init|=
name|LOOKAHEAD_LIMIT
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PARANOID
if|if
condition|(
name|emulating
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: wm-FPU-emu is not RE-ENTRANT!\n"
argument_list|)
expr_stmt|;
block|}
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PARANOID */
if|if
condition|(
operator|(
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|curproc
operator|->
name|p_addr
operator|)
operator|->
name|pcb_flags
operator|&
name|FP_SOFTFP
operator|)
operator|==
literal|0
condition|)
block|{
name|finit
argument_list|()
expr_stmt|;
name|control_word
operator|=
name|__INITIAL_NPXCW__
expr_stmt|;
operator|(
operator|(
expr|struct
name|pcb
operator|*
operator|)
name|curproc
operator|->
name|p_addr
operator|)
operator|->
name|pcb_flags
operator||=
name|FP_SOFTFP
expr_stmt|;
block|}
name|FPU_info
operator|=
name|tframe
expr_stmt|;
name|FPU_ORIG_EIP
operator|=
name|FPU_EIP
expr_stmt|;
comment|/* --pink-- */
if|if
condition|(
name|FPU_CS
operator|!=
literal|0x001f
condition|)
block|{
name|printf
argument_list|(
literal|"math_emulate: %x : %x\n"
argument_list|,
name|FPU_CS
argument_list|,
name|FPU_EIP
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"FPU emulation in kernel"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notyet
comment|/* We cannot handle emulation in v86-mode */
if|if
condition|(
name|FPU_EFLAGS
operator|&
literal|0x00020000
condition|)
block|{
name|FPU_ORIG_EIP
operator|=
name|FPU_EIP
expr_stmt|;
name|math_abort
argument_list|(
name|FPU_info
argument_list|,
name|SIGILL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|FPU_lookahead
operator|=
name|FPU_LOOKAHEAD
expr_stmt|;
if|if
condition|(
name|curproc
operator|->
name|p_flag
operator|&
name|P_TRACED
condition|)
name|FPU_lookahead
operator|=
literal|0
expr_stmt|;
name|do_another_FPU_instruction
label|:
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|code
operator|=
name|fuword
argument_list|(
operator|(
name|u_int
operator|*
operator|)
name|FPU_EIP
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|0xff
operator|)
operator|==
literal|0x9b
condition|)
block|{
comment|/* fwait */
if|if
condition|(
name|status_word
operator|&
name|SW_Summary
condition|)
goto|goto
name|do_the_FPU_interrupt
goto|;
else|else
block|{
name|FPU_EIP
operator|++
expr_stmt|;
goto|goto
name|FPU_instruction_done
goto|;
block|}
block|}
if|if
condition|(
name|status_word
operator|&
name|SW_Summary
condition|)
block|{
comment|/* Ignore the error for now if the current instruction is a 		 * no-wait control instruction */
comment|/* The 80486 manual contradicts itself on this topic, so I use 		 * the following list of such instructions until I can check 		 * on a real 80486: fninit, fnstenv, fnsave, fnstsw, fnstenv, 		 * fnclex. */
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
operator|(
name|code
operator|&
literal|0xf803
operator|)
operator|==
literal|0xe003
operator|)
operator|||
comment|/* fnclex, fninit, 							 * fnstsw */
operator|(
operator|(
operator|(
name|code
operator|&
literal|0x3003
operator|)
operator|==
literal|0x3001
operator|)
operator|&&
comment|/* fnsave, fnstcw, 								 * fnstenv, fnstsw */
operator|(
operator|(
name|code
operator|&
literal|0xc000
operator|)
operator|!=
literal|0xc000
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* This is a guess about what a real FPU might do to 			 * this bit: */
comment|/*	  status_word&= ~SW_Summary; ****/
comment|/* We need to simulate the action of the kernel to FPU 			 * interrupts here. Currently, the "real FPU" part of 			 * the kernel (0.99.10) clears the exception flags, 			 * sets the registers to empty, and passes information 			 * back to the interrupted process via the cs selector 			 * and operand selector, so we do the same. */
name|do_the_FPU_interrupt
label|:
name|cs_selector
operator|&=
literal|0xffff0000
expr_stmt|;
name|cs_selector
operator||=
operator|(
name|status_word
operator|&
operator|~
name|SW_Top
operator|)
operator||
operator|(
operator|(
name|top
operator|&
literal|7
operator|)
operator|<<
name|SW_Top_Shift
operator|)
expr_stmt|;
name|operand_selector
operator|=
name|tag_word
argument_list|()
expr_stmt|;
name|status_word
operator|=
literal|0
expr_stmt|;
name|top
operator|=
literal|0
expr_stmt|;
block|{
name|int
name|r
decl_stmt|;
for|for
control|(
name|r
operator|=
literal|0
init|;
name|r
operator|<
literal|8
condition|;
name|r
operator|++
control|)
block|{
name|regs
index|[
name|r
index|]
operator|.
name|tag
operator|=
name|TW_Empty
expr_stmt|;
block|}
block|}
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|math_abort
argument_list|(
name|SIGFPE
argument_list|)
expr_stmt|;
block|}
block|}
name|FPU_entry_eip
operator|=
name|FPU_ORIG_EIP
operator|=
name|FPU_EIP
expr_stmt|;
if|if
condition|(
operator|(
name|code
operator|&
literal|0xff
operator|)
operator|==
literal|0x66
condition|)
block|{
comment|/* size prefix */
name|FPU_EIP
operator|++
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|code
operator|=
name|fuword
argument_list|(
operator|(
name|u_int
operator|*
operator|)
name|FPU_EIP
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
block|}
name|FPU_EIP
operator|+=
literal|2
expr_stmt|;
name|FPU_modrm
operator|=
name|code
operator|>>
literal|8
expr_stmt|;
name|FPU_rm
operator|=
name|FPU_modrm
operator|&
literal|7
expr_stmt|;
if|if
condition|(
name|FPU_modrm
operator|<
literal|0300
condition|)
block|{
comment|/* All of these instructions use the mod/rm byte to get a data 		 * address */
name|get_address
argument_list|(
name|FPU_modrm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|code
operator|&
literal|1
operator|)
condition|)
block|{
name|unsigned
name|short
name|status1
init|=
name|status_word
decl_stmt|;
name|FPU_st0_ptr
operator|=
operator|&
name|st
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|FPU_st0_tag
operator|=
name|FPU_st0_ptr
operator|->
name|tag
expr_stmt|;
comment|/* Stack underflow has priority */
if|if
condition|(
name|NOT_EMPTY_0
condition|)
block|{
switch|switch
condition|(
operator|(
name|code
operator|>>
literal|1
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|reg_load_single
argument_list|()
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|reg_load_int32
argument_list|()
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|reg_load_double
argument_list|()
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|reg_load_int16
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* No more access to user memory, it is safe 				 * to use static data now */
name|FPU_st0_ptr
operator|=
operator|&
name|st
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|FPU_st0_tag
operator|=
name|FPU_st0_ptr
operator|->
name|tag
expr_stmt|;
comment|/* NaN operands have the next priority. */
comment|/* We have to delay looking at st(0) until 				 * after loading the data, because that data 				 * might contain an SNaN */
if|if
condition|(
operator|(
name|FPU_st0_tag
operator|==
name|TW_NaN
operator|)
operator|||
operator|(
name|FPU_loaded_data
operator|.
name|tag
operator|==
name|TW_NaN
operator|)
condition|)
block|{
comment|/* Restore the status word; we might 					 * have loaded a denormal. */
name|status_word
operator|=
name|status1
expr_stmt|;
if|if
condition|(
operator|(
name|FPU_modrm
operator|&
literal|0x30
operator|)
operator|==
literal|0x10
condition|)
block|{
comment|/* fcom or fcomp */
name|EXCEPTION
argument_list|(
name|EX_Invalid
argument_list|)
expr_stmt|;
name|setcc
argument_list|(
name|SW_C3
operator||
name|SW_C2
operator||
name|SW_C0
argument_list|)
expr_stmt|;
if|if
condition|(
name|FPU_modrm
operator|&
literal|0x08
condition|)
name|pop
argument_list|()
expr_stmt|;
comment|/* fcomp, so we pop. */
block|}
else|else
name|real_2op_NaN
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|FPU_loaded_data
argument_list|,
name|FPU_st0_ptr
argument_list|)
expr_stmt|;
goto|goto
name|reg_mem_instr_done
goto|;
block|}
switch|switch
condition|(
operator|(
name|FPU_modrm
operator|>>
literal|3
operator|)
operator|&
literal|7
condition|)
block|{
case|case
literal|0
case|:
comment|/* fadd */
name|reg_add
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|FPU_loaded_data
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* fmul */
name|reg_mul
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|FPU_loaded_data
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* fcom */
name|compare_st_data
argument_list|()
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* fcomp */
name|compare_st_data
argument_list|()
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* fsub */
name|reg_sub
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|FPU_loaded_data
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* fsubr */
name|reg_sub
argument_list|(
operator|&
name|FPU_loaded_data
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* fdiv */
name|reg_div
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|FPU_loaded_data
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* fdivr */
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Zero
condition|)
name|status_word
operator|=
name|status1
expr_stmt|;
comment|/* Undo any denorm tag, 									 * zero-divide has 									 * priority. */
name|reg_div
argument_list|(
operator|&
name|FPU_loaded_data
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|FPU_st0_ptr
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|FPU_modrm
operator|&
literal|0x30
operator|)
operator|==
literal|0x10
condition|)
block|{
comment|/* The instruction is fcom or fcomp */
name|EXCEPTION
argument_list|(
name|EX_StackUnder
argument_list|)
expr_stmt|;
name|setcc
argument_list|(
name|SW_C3
operator||
name|SW_C2
operator||
name|SW_C0
argument_list|)
expr_stmt|;
if|if
condition|(
name|FPU_modrm
operator|&
literal|0x08
condition|)
name|pop
argument_list|()
expr_stmt|;
comment|/* fcomp, Empty or not, 							 * we pop. */
block|}
else|else
name|stack_underflow
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|load_store_instr
argument_list|(
operator|(
operator|(
name|FPU_modrm
operator|&
literal|0x38
operator|)
operator||
operator|(
name|code
operator|&
literal|6
operator|)
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
block|}
name|reg_mem_instr_done
label|:
name|data_operand_offset
operator|=
operator|(
name|intptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|FPU_data_address
expr_stmt|;
block|}
else|else
block|{
comment|/* None of these instructions access user memory */
name|unsigned
name|char
name|instr_index
init|=
operator|(
name|FPU_modrm
operator|&
literal|0x38
operator|)
operator||
operator|(
name|code
operator|&
literal|7
operator|)
decl_stmt|;
name|FPU_st0_ptr
operator|=
operator|&
name|st
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|FPU_st0_tag
operator|=
name|FPU_st0_ptr
operator|->
name|tag
expr_stmt|;
switch|switch
condition|(
name|type_table
index|[
operator|(
name|int
operator|)
name|instr_index
index|]
condition|)
block|{
case|case
name|_NONE_
case|:
comment|/* also _REGIc: _REGIn */
break|break;
case|case
name|_REG0_
case|:
if|if
condition|(
operator|!
name|NOT_EMPTY_0
condition|)
block|{
name|stack_underflow
argument_list|()
expr_stmt|;
goto|goto
name|FPU_instruction_done
goto|;
block|}
break|break;
case|case
name|_REGIi
case|:
if|if
condition|(
operator|!
name|NOT_EMPTY_0
operator|||
operator|!
name|NOT_EMPTY
argument_list|(
name|FPU_rm
argument_list|)
condition|)
block|{
name|stack_underflow_i
argument_list|(
name|FPU_rm
argument_list|)
expr_stmt|;
goto|goto
name|FPU_instruction_done
goto|;
block|}
break|break;
case|case
name|_REGIp
case|:
if|if
condition|(
operator|!
name|NOT_EMPTY_0
operator|||
operator|!
name|NOT_EMPTY
argument_list|(
name|FPU_rm
argument_list|)
condition|)
block|{
name|stack_underflow_i
argument_list|(
name|FPU_rm
argument_list|)
expr_stmt|;
name|pop
argument_list|()
expr_stmt|;
goto|goto
name|FPU_instruction_done
goto|;
block|}
break|break;
case|case
name|_REGI_
case|:
if|if
condition|(
operator|!
name|NOT_EMPTY_0
operator|||
operator|!
name|NOT_EMPTY
argument_list|(
name|FPU_rm
argument_list|)
condition|)
block|{
name|stack_underflow
argument_list|()
expr_stmt|;
goto|goto
name|FPU_instruction_done
goto|;
block|}
break|break;
case|case
name|_PUSH_
case|:
comment|/* Only used by the fld st(i) instruction */
break|break;
case|case
name|_null_
case|:
name|Un_impl
argument_list|()
expr_stmt|;
goto|goto
name|FPU_instruction_done
goto|;
default|default:
name|EXCEPTION
argument_list|(
name|EX_INTERNAL
operator||
literal|0x111
argument_list|)
expr_stmt|;
goto|goto
name|FPU_instruction_done
goto|;
block|}
call|(
modifier|*
name|st_instr_table
index|[
operator|(
name|int
operator|)
name|instr_index
index|]
call|)
argument_list|()
expr_stmt|;
block|}
name|FPU_instruction_done
label|:
name|ip_offset
operator|=
name|FPU_entry_eip
expr_stmt|;
name|bswapw
argument_list|(
name|code
argument_list|)
expr_stmt|;
operator|*
operator|(
literal|1
operator|+
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|&
name|cs_selector
operator|)
operator|=
name|code
operator|&
literal|0x7ff
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|emu_printall
argument_list|()
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
ifdef|#
directive|ifdef
name|LOOKAHEAD_LIMIT
if|if
condition|(
operator|--
name|lookahead_limit
condition|)
endif|#
directive|endif
if|if
condition|(
name|FPU_lookahead
condition|)
block|{
name|unsigned
name|char
name|next
decl_stmt|;
comment|/* (This test should generate no machine code) */
while|while
condition|(
literal|1
condition|)
block|{
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|next
operator|=
name|fubyte
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|FPU_EIP
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|next
operator|&
literal|0xf8
operator|)
operator|==
literal|0xd8
operator|)
operator|||
operator|(
name|next
operator|==
literal|0x9b
operator|)
condition|)
block|{
comment|/* fwait */
goto|goto
name|do_another_FPU_instruction
goto|;
block|}
elseif|else
if|if
condition|(
name|next
operator|==
literal|0x66
condition|)
block|{
comment|/* size prefix */
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|next
operator|=
name|fubyte
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|(
name|FPU_EIP
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|next
operator|&
literal|0xf8
operator|)
operator|==
literal|0xd8
condition|)
block|{
name|FPU_EIP
operator|++
expr_stmt|;
goto|goto
name|do_another_FPU_instruction
goto|;
block|}
block|}
break|break;
block|}
block|}
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* --pink-- */
block|}
end_function

begin_function
specifier|static
name|int
name|gnufpu_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
if|if
condition|(
name|pmath_emulate
condition|)
block|{
name|printf
argument_list|(
literal|"Another Math emulator already present\n"
argument_list|)
expr_stmt|;
return|return
name|EACCES
return|;
block|}
name|pmath_emulate
operator|=
name|math_emulate
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"GPL Math emulator present\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
if|if
condition|(
name|pmath_emulate
operator|!=
name|math_emulate
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot unload another math emulator\n"
argument_list|)
expr_stmt|;
return|return
name|EACCES
return|;
block|}
name|pmath_emulate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"GPL Math emulator unloaded\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|gnufpumod
init|=
block|{
literal|"gnufpu"
block|,
name|gnufpu_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|gnufpu
argument_list|,
name|gnufpumod
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

