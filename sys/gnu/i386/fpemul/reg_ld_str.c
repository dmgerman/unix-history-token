begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  reg_ld_str.c  *  * All of the functions which transfer data between user memory and FPU_REGs.  *  *  * Copyright (C) 1992,1993,1994  *                       W. Metzenthen, 22 Parker St, Ormond, Vic 3163,  *                       Australia.  E-mail   billm@vaxc.cc.monash.edu.au  * All rights reserved.  *  * This copyright notice covers the redistribution and use of the  * FPU emulator developed by W. Metzenthen. It covers only its use  * in the 386BSD, FreeBSD and NetBSD operating systems. Any other  * use is not permitted under this copyright.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must include information specifying  *    that source code for the emulator is freely available and include  *    either:  *      a) an offer to provide the source code for a nominal distribution  *         fee, or  *      b) list at least two alternative methods whereby the source  *         can be obtained, e.g. a publically accessible bulletin board  *         and an anonymous ftp site from which the software can be  *         downloaded.  * 3. All advertising materials specifically mentioning features or use of  *    this emulator must acknowledge that it was developed by W. Metzenthen.  * 4. The name of W. Metzenthen may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,  * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL  * W. METZENTHEN BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *  * The purpose of this copyright, based upon the Berkeley copyright, is to  * ensure that the covered software remains freely available to everyone.  *  * The software (with necessary differences) is also available, but under  * the terms of the GNU copyleft, for the Linux operating system and for  * the djgpp ms-dos extender.  *  * W. Metzenthen   June 1994.  *  *  *     $Id: reg_ld_str.c,v 1.3 1994/06/10 07:44:52 rich Exp $  *  */
end_comment

begin_comment
comment|/*---------------------------------------------------------------------------+  | Note:                                                                     |  |    The file contains code which accesses user memory.                     |  |    Emulator static data may change when user memory is accessed, due to   |  |    other processes using the emulator while swapping is in progress.      |  +---------------------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"machine/cpu.h"
end_include

begin_include
include|#
directive|include
file|"machine/pcb.h"
end_include

begin_include
include|#
directive|include
file|"fpu_emu.h"
end_include

begin_include
include|#
directive|include
file|"fpu_system.h"
end_include

begin_include
include|#
directive|include
file|"exception.h"
end_include

begin_include
include|#
directive|include
file|"reg_constant.h"
end_include

begin_include
include|#
directive|include
file|"control_w.h"
end_include

begin_include
include|#
directive|include
file|"status_w.h"
end_include

begin_define
define|#
directive|define
name|EXTENDED_Emax
value|0x3fff
end_define

begin_comment
comment|/* largest valid exponent */
end_comment

begin_define
define|#
directive|define
name|EXTENDED_Ebias
value|0x3fff
end_define

begin_define
define|#
directive|define
name|EXTENDED_Emin
value|(-0x3ffe)
end_define

begin_comment
comment|/* smallest valid exponent */
end_comment

begin_define
define|#
directive|define
name|DOUBLE_Emax
value|1023
end_define

begin_comment
comment|/* largest valid exponent */
end_comment

begin_define
define|#
directive|define
name|DOUBLE_Ebias
value|1023
end_define

begin_define
define|#
directive|define
name|DOUBLE_Emin
value|(-1022)
end_define

begin_comment
comment|/* smallest valid exponent */
end_comment

begin_define
define|#
directive|define
name|SINGLE_Emax
value|127
end_define

begin_comment
comment|/* largest valid exponent */
end_comment

begin_define
define|#
directive|define
name|SINGLE_Ebias
value|127
end_define

begin_define
define|#
directive|define
name|SINGLE_Emin
value|(-126)
end_define

begin_comment
comment|/* smallest valid exponent */
end_comment

begin_define
define|#
directive|define
name|LOST_UP
value|(EX_Precision | SW_C1)
end_define

begin_define
define|#
directive|define
name|LOST_DOWN
value|EX_Precision
end_define

begin_decl_stmt
name|FPU_REG
name|FPU_loaded_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Get a long double from user memory */
end_comment

begin_function
name|void
name|reg_load_extended
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|double
modifier|*
name|s
init|=
operator|(
name|long
name|double
operator|*
operator|)
name|FPU_data_address
decl_stmt|;
name|unsigned
name|long
name|sigl
decl_stmt|,
name|sigh
decl_stmt|,
name|exp
decl_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
comment|/* Use temporary variables here because FPU_loaded data is static and 	 * hence re-entrancy problems can arise */
name|sigl
operator|=
name|fuword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
name|sigh
operator|=
name|fuword
argument_list|(
literal|1
operator|+
operator|(
name|unsigned
name|long
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
name|exp
operator|=
name|fuword
argument_list|(
literal|4
operator|+
operator|(
name|unsigned
name|short
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sigl
operator|=
name|sigl
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sigh
operator|=
name|sigh
expr_stmt|;
name|FPU_loaded_data
operator|.
name|exp
operator|=
name|exp
expr_stmt|;
if|if
condition|(
name|FPU_loaded_data
operator|.
name|exp
operator|&
literal|0x8000
condition|)
name|FPU_loaded_data
operator|.
name|sign
operator|=
name|SIGN_NEG
expr_stmt|;
else|else
name|FPU_loaded_data
operator|.
name|sign
operator|=
name|SIGN_POS
expr_stmt|;
if|if
condition|(
operator|(
name|FPU_loaded_data
operator|.
name|exp
operator|&=
literal|0x7fff
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|FPU_loaded_data
operator|.
name|sigl
operator||
name|FPU_loaded_data
operator|.
name|sigh
operator|)
condition|)
block|{
name|FPU_loaded_data
operator|.
name|tag
operator|=
name|TW_Zero
expr_stmt|;
return|return;
block|}
comment|/* The number is a de-normal or pseudodenormal. */
comment|/* The 80486 doesn't regard pseudodenormals as denormals here. */
if|if
condition|(
operator|!
operator|(
name|FPU_loaded_data
operator|.
name|sigh
operator|&
literal|0x80000000
operator|)
condition|)
name|EXCEPTION
argument_list|(
name|EX_Denormal
argument_list|)
expr_stmt|;
name|FPU_loaded_data
operator|.
name|exp
operator|++
expr_stmt|;
comment|/* The default behaviour will now take care of it. */
block|}
elseif|else
if|if
condition|(
name|FPU_loaded_data
operator|.
name|exp
operator|==
literal|0x7fff
condition|)
block|{
name|FPU_loaded_data
operator|.
name|exp
operator|=
name|EXTENDED_Emax
expr_stmt|;
if|if
condition|(
operator|(
name|FPU_loaded_data
operator|.
name|sigh
operator|==
literal|0x80000000
operator|)
operator|&&
operator|(
name|FPU_loaded_data
operator|.
name|sigl
operator|==
literal|0
operator|)
condition|)
block|{
name|FPU_loaded_data
operator|.
name|tag
operator|=
name|TW_Infinity
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|FPU_loaded_data
operator|.
name|sigh
operator|&
literal|0x80000000
operator|)
condition|)
block|{
comment|/* Unsupported NaN data type */
name|EXCEPTION
argument_list|(
name|EX_Invalid
argument_list|)
expr_stmt|;
name|FPU_loaded_data
operator|.
name|tag
operator|=
name|TW_NaN
expr_stmt|;
return|return;
block|}
name|FPU_loaded_data
operator|.
name|tag
operator|=
name|TW_NaN
expr_stmt|;
return|return;
block|}
name|FPU_loaded_data
operator|.
name|exp
operator|=
operator|(
name|FPU_loaded_data
operator|.
name|exp
operator|&
literal|0x7fff
operator|)
operator|-
name|EXTENDED_Ebias
operator|+
name|EXP_BIAS
expr_stmt|;
name|FPU_loaded_data
operator|.
name|tag
operator|=
name|TW_Valid
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sigh
operator|&
literal|0x80000000
operator|)
condition|)
block|{
comment|/* Unsupported data type */
name|EXCEPTION
argument_list|(
name|EX_Invalid
argument_list|)
expr_stmt|;
name|normalize_nuo
argument_list|(
operator|&
name|FPU_loaded_data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get a double from user memory */
end_comment

begin_function
name|void
name|reg_load_double
parameter_list|(
name|void
parameter_list|)
block|{
name|double
modifier|*
name|dfloat
init|=
operator|(
name|double
operator|*
operator|)
name|FPU_data_address
decl_stmt|;
name|int
name|exp
decl_stmt|;
name|unsigned
name|m64
decl_stmt|,
name|l64
decl_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|m64
operator|=
name|fuword
argument_list|(
literal|1
operator|+
operator|(
name|unsigned
name|long
operator|*
operator|)
name|dfloat
argument_list|)
expr_stmt|;
name|l64
operator|=
name|fuword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|dfloat
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
if|if
condition|(
name|m64
operator|&
literal|0x80000000
condition|)
name|FPU_loaded_data
operator|.
name|sign
operator|=
name|SIGN_NEG
expr_stmt|;
else|else
name|FPU_loaded_data
operator|.
name|sign
operator|=
name|SIGN_POS
expr_stmt|;
name|exp
operator|=
operator|(
operator|(
name|m64
operator|&
literal|0x7ff00000
operator|)
operator|>>
literal|20
operator|)
operator|-
name|DOUBLE_Ebias
expr_stmt|;
name|m64
operator|&=
literal|0xfffff
expr_stmt|;
if|if
condition|(
name|exp
operator|>
name|DOUBLE_Emax
condition|)
block|{
comment|/* Infinity or NaN */
if|if
condition|(
operator|(
name|m64
operator|==
literal|0
operator|)
operator|&&
operator|(
name|l64
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* +- infinity */
name|FPU_loaded_data
operator|.
name|exp
operator|=
name|EXTENDED_Emax
expr_stmt|;
name|FPU_loaded_data
operator|.
name|tag
operator|=
name|TW_Infinity
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Must be a signaling or quiet NaN */
name|FPU_loaded_data
operator|.
name|exp
operator|=
name|EXTENDED_Emax
expr_stmt|;
name|FPU_loaded_data
operator|.
name|tag
operator|=
name|TW_NaN
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sigh
operator|=
operator|(
name|m64
operator|<<
literal|11
operator|)
operator||
literal|0x80000000
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sigh
operator||=
name|l64
operator|>>
literal|21
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sigl
operator|=
name|l64
operator|<<
literal|11
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|exp
operator|<
name|DOUBLE_Emin
condition|)
block|{
comment|/* Zero or de-normal */
if|if
condition|(
operator|(
name|m64
operator|==
literal|0
operator|)
operator|&&
operator|(
name|l64
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Zero */
name|int
name|c
init|=
name|FPU_loaded_data
operator|.
name|sign
decl_stmt|;
name|reg_move
argument_list|(
operator|&
name|CONST_Z
argument_list|,
operator|&
name|FPU_loaded_data
argument_list|)
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sign
operator|=
name|c
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* De-normal */
name|EXCEPTION
argument_list|(
name|EX_Denormal
argument_list|)
expr_stmt|;
name|FPU_loaded_data
operator|.
name|exp
operator|=
name|DOUBLE_Emin
operator|+
name|EXP_BIAS
expr_stmt|;
name|FPU_loaded_data
operator|.
name|tag
operator|=
name|TW_Valid
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sigh
operator|=
name|m64
operator|<<
literal|11
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sigh
operator||=
name|l64
operator|>>
literal|21
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sigl
operator|=
name|l64
operator|<<
literal|11
expr_stmt|;
name|normalize_nuo
argument_list|(
operator|&
name|FPU_loaded_data
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|FPU_loaded_data
operator|.
name|exp
operator|=
name|exp
operator|+
name|EXP_BIAS
expr_stmt|;
name|FPU_loaded_data
operator|.
name|tag
operator|=
name|TW_Valid
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sigh
operator|=
operator|(
name|m64
operator|<<
literal|11
operator|)
operator||
literal|0x80000000
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sigh
operator||=
name|l64
operator|>>
literal|21
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sigl
operator|=
name|l64
operator|<<
literal|11
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Get a float from user memory */
end_comment

begin_function
name|void
name|reg_load_single
parameter_list|(
name|void
parameter_list|)
block|{
name|float
modifier|*
name|single
init|=
operator|(
name|float
operator|*
operator|)
name|FPU_data_address
decl_stmt|;
name|unsigned
name|m32
decl_stmt|;
name|int
name|exp
decl_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|m32
operator|=
name|fuword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|single
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
if|if
condition|(
name|m32
operator|&
literal|0x80000000
condition|)
name|FPU_loaded_data
operator|.
name|sign
operator|=
name|SIGN_NEG
expr_stmt|;
else|else
name|FPU_loaded_data
operator|.
name|sign
operator|=
name|SIGN_POS
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|m32
operator|&
literal|0x7fffffff
operator|)
condition|)
block|{
comment|/* Zero */
name|int
name|c
init|=
name|FPU_loaded_data
operator|.
name|sign
decl_stmt|;
name|reg_move
argument_list|(
operator|&
name|CONST_Z
argument_list|,
operator|&
name|FPU_loaded_data
argument_list|)
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sign
operator|=
name|c
expr_stmt|;
return|return;
block|}
name|exp
operator|=
operator|(
operator|(
name|m32
operator|&
literal|0x7f800000
operator|)
operator|>>
literal|23
operator|)
operator|-
name|SINGLE_Ebias
expr_stmt|;
name|m32
operator|=
operator|(
name|m32
operator|&
literal|0x7fffff
operator|)
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|exp
operator|<
name|SINGLE_Emin
condition|)
block|{
comment|/* De-normals */
name|EXCEPTION
argument_list|(
name|EX_Denormal
argument_list|)
expr_stmt|;
name|FPU_loaded_data
operator|.
name|exp
operator|=
name|SINGLE_Emin
operator|+
name|EXP_BIAS
expr_stmt|;
name|FPU_loaded_data
operator|.
name|tag
operator|=
name|TW_Valid
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sigh
operator|=
name|m32
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sigl
operator|=
literal|0
expr_stmt|;
name|normalize_nuo
argument_list|(
operator|&
name|FPU_loaded_data
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|exp
operator|>
name|SINGLE_Emax
condition|)
block|{
comment|/* Infinity or NaN */
if|if
condition|(
name|m32
operator|==
literal|0
condition|)
block|{
comment|/* +- infinity */
name|FPU_loaded_data
operator|.
name|exp
operator|=
name|EXTENDED_Emax
expr_stmt|;
name|FPU_loaded_data
operator|.
name|tag
operator|=
name|TW_Infinity
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Must be a signaling or quiet NaN */
name|FPU_loaded_data
operator|.
name|exp
operator|=
name|EXTENDED_Emax
expr_stmt|;
name|FPU_loaded_data
operator|.
name|tag
operator|=
name|TW_NaN
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sigh
operator|=
name|m32
operator||
literal|0x80000000
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sigl
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|FPU_loaded_data
operator|.
name|exp
operator|=
name|exp
operator|+
name|EXP_BIAS
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sigh
operator|=
name|m32
operator||
literal|0x80000000
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sigl
operator|=
literal|0
expr_stmt|;
name|FPU_loaded_data
operator|.
name|tag
operator|=
name|TW_Valid
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get a long long from user memory */
end_comment

begin_function
name|void
name|reg_load_int64
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|long
modifier|*
name|_s
init|=
operator|(
name|long
name|long
operator|*
operator|)
name|FPU_data_address
decl_stmt|;
name|int
name|e
decl_stmt|;
name|long
name|long
name|s
decl_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
operator|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|&
name|s
operator|)
index|[
literal|0
index|]
operator|=
name|fuword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|_s
argument_list|)
expr_stmt|;
operator|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|&
name|s
operator|)
index|[
literal|1
index|]
operator|=
name|fuword
argument_list|(
literal|1
operator|+
operator|(
name|unsigned
name|long
operator|*
operator|)
name|_s
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
name|reg_move
argument_list|(
operator|&
name|CONST_Z
argument_list|,
operator|&
name|FPU_loaded_data
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|s
operator|>
literal|0
condition|)
name|FPU_loaded_data
operator|.
name|sign
operator|=
name|SIGN_POS
expr_stmt|;
else|else
block|{
name|s
operator|=
operator|-
name|s
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sign
operator|=
name|SIGN_NEG
expr_stmt|;
block|}
name|e
operator|=
name|EXP_BIAS
operator|+
literal|63
expr_stmt|;
operator|*
operator|(
operator|(
name|long
name|long
operator|*
operator|)
operator|&
name|FPU_loaded_data
operator|.
name|sigl
operator|)
operator|=
name|s
expr_stmt|;
name|FPU_loaded_data
operator|.
name|exp
operator|=
name|e
expr_stmt|;
name|FPU_loaded_data
operator|.
name|tag
operator|=
name|TW_Valid
expr_stmt|;
name|normalize_nuo
argument_list|(
operator|&
name|FPU_loaded_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get a long from user memory */
end_comment

begin_function
name|void
name|reg_load_int32
parameter_list|(
name|void
parameter_list|)
block|{
name|long
modifier|*
name|_s
init|=
operator|(
name|long
operator|*
operator|)
name|FPU_data_address
decl_stmt|;
name|long
name|s
decl_stmt|;
name|int
name|e
decl_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|long
operator|)
name|fuword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|_s
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
name|reg_move
argument_list|(
operator|&
name|CONST_Z
argument_list|,
operator|&
name|FPU_loaded_data
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|s
operator|>
literal|0
condition|)
name|FPU_loaded_data
operator|.
name|sign
operator|=
name|SIGN_POS
expr_stmt|;
else|else
block|{
name|s
operator|=
operator|-
name|s
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sign
operator|=
name|SIGN_NEG
expr_stmt|;
block|}
name|e
operator|=
name|EXP_BIAS
operator|+
literal|31
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sigh
operator|=
name|s
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sigl
operator|=
literal|0
expr_stmt|;
name|FPU_loaded_data
operator|.
name|exp
operator|=
name|e
expr_stmt|;
name|FPU_loaded_data
operator|.
name|tag
operator|=
name|TW_Valid
expr_stmt|;
name|normalize_nuo
argument_list|(
operator|&
name|FPU_loaded_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get a short from user memory */
end_comment

begin_function
name|void
name|reg_load_int16
parameter_list|(
name|void
parameter_list|)
block|{
name|short
modifier|*
name|_s
init|=
operator|(
name|short
operator|*
operator|)
name|FPU_data_address
decl_stmt|;
name|int
name|s
decl_stmt|,
name|e
decl_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
comment|/* Cast as short to get the sign extended. */
name|s
operator|=
operator|(
name|short
operator|)
name|fuword
argument_list|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|_s
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
name|reg_move
argument_list|(
operator|&
name|CONST_Z
argument_list|,
operator|&
name|FPU_loaded_data
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|s
operator|>
literal|0
condition|)
name|FPU_loaded_data
operator|.
name|sign
operator|=
name|SIGN_POS
expr_stmt|;
else|else
block|{
name|s
operator|=
operator|-
name|s
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sign
operator|=
name|SIGN_NEG
expr_stmt|;
block|}
name|e
operator|=
name|EXP_BIAS
operator|+
literal|15
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sigh
operator|=
name|s
operator|<<
literal|16
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sigl
operator|=
literal|0
expr_stmt|;
name|FPU_loaded_data
operator|.
name|exp
operator|=
name|e
expr_stmt|;
name|FPU_loaded_data
operator|.
name|tag
operator|=
name|TW_Valid
expr_stmt|;
name|normalize_nuo
argument_list|(
operator|&
name|FPU_loaded_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get a packed bcd array from user memory */
end_comment

begin_function
name|void
name|reg_load_bcd
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|FPU_data_address
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|unsigned
name|char
name|bcd
decl_stmt|;
name|long
name|long
name|l
init|=
literal|0
decl_stmt|;
for|for
control|(
name|pos
operator|=
literal|8
init|;
name|pos
operator|>=
literal|0
condition|;
name|pos
operator|--
control|)
block|{
name|l
operator|*=
literal|10
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|bcd
operator|=
operator|(
name|unsigned
name|char
operator|)
name|fubyte
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|+
name|pos
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
name|l
operator|+=
name|bcd
operator|>>
literal|4
expr_stmt|;
name|l
operator|*=
literal|10
expr_stmt|;
name|l
operator|+=
name|bcd
operator|&
literal|0x0f
expr_stmt|;
block|}
comment|/* Finish all access to user memory before putting stuff into the 	 * static FPU_loaded_data */
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sign
operator|=
operator|(
operator|(
name|unsigned
name|char
operator|)
name|fubyte
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|s
operator|+
literal|9
argument_list|)
operator|)
operator|&
literal|0x80
condition|?
name|SIGN_NEG
else|:
name|SIGN_POS
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
name|char
name|sign
init|=
name|FPU_loaded_data
operator|.
name|sign
decl_stmt|;
name|reg_move
argument_list|(
operator|&
name|CONST_Z
argument_list|,
operator|&
name|FPU_loaded_data
argument_list|)
expr_stmt|;
name|FPU_loaded_data
operator|.
name|sign
operator|=
name|sign
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
operator|(
name|long
name|long
operator|*
operator|)
operator|&
name|FPU_loaded_data
operator|.
name|sigl
operator|)
operator|=
name|l
expr_stmt|;
name|FPU_loaded_data
operator|.
name|exp
operator|=
name|EXP_BIAS
operator|+
literal|63
expr_stmt|;
name|FPU_loaded_data
operator|.
name|tag
operator|=
name|TW_Valid
expr_stmt|;
name|normalize_nuo
argument_list|(
operator|&
name|FPU_loaded_data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*===========================================================================*/
end_comment

begin_comment
comment|/* Put a long double into user memory */
end_comment

begin_function
name|int
name|reg_store_extended
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|double
modifier|*
name|d
init|=
operator|(
name|long
name|double
operator|*
operator|)
name|FPU_data_address
decl_stmt|;
name|long
name|e
init|=
name|FPU_st0_ptr
operator|->
name|exp
operator|-
name|EXP_BIAS
operator|+
name|EXTENDED_Ebias
decl_stmt|;
name|unsigned
name|short
name|sign
init|=
name|FPU_st0_ptr
operator|->
name|sign
operator|*
literal|0x8000
decl_stmt|;
name|unsigned
name|long
name|ls
decl_stmt|,
name|ms
decl_stmt|;
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Valid
condition|)
block|{
if|if
condition|(
name|e
operator|>=
literal|0x7fff
condition|)
block|{
name|EXCEPTION
argument_list|(
name|EX_Overflow
argument_list|)
expr_stmt|;
comment|/* Overflow */
comment|/* This is a special case: see sec 16.2.5.1 of the 			 * 80486 book */
if|if
condition|(
name|control_word
operator|&
name|EX_Overflow
condition|)
block|{
comment|/* Overflow to infinity */
name|ls
operator|=
literal|0
expr_stmt|;
name|ms
operator|=
literal|0x80000000
expr_stmt|;
name|e
operator|=
literal|0x7fff
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|e
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|>
operator|-
literal|63
condition|)
block|{
comment|/* Correctly format the de-normal */
name|int
name|precision_loss
decl_stmt|;
name|FPU_REG
name|tmp
decl_stmt|;
name|EXCEPTION
argument_list|(
name|EX_Denormal
argument_list|)
expr_stmt|;
name|reg_move
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|exp
operator|+=
operator|-
name|EXTENDED_Emin
operator|+
literal|63
expr_stmt|;
comment|/* largest exp to be 62 */
if|if
condition|(
operator|(
name|precision_loss
operator|=
name|round_to_int
argument_list|(
operator|&
name|tmp
argument_list|)
operator|)
condition|)
block|{
name|EXCEPTION
argument_list|(
name|EX_Underflow
operator||
name|precision_loss
argument_list|)
expr_stmt|;
comment|/* This is a special case: see 						 * sec 16.2.5.1 of the 80486 						 * book */
if|if
condition|(
operator|!
operator|(
name|control_word
operator|&
name|EX_Underflow
operator|)
condition|)
return|return
literal|0
return|;
block|}
name|e
operator|=
literal|0
expr_stmt|;
name|ls
operator|=
name|tmp
operator|.
name|sigl
expr_stmt|;
name|ms
operator|=
name|tmp
operator|.
name|sigh
expr_stmt|;
block|}
else|else
block|{
comment|/* ****** ??? This should not be 					 * possible */
name|EXCEPTION
argument_list|(
name|EX_Underflow
argument_list|)
expr_stmt|;
comment|/* Underflow */
comment|/* This is a special case: see sec 					 * 16.2.5.1 of the 80486 book */
if|if
condition|(
name|control_word
operator|&
name|EX_Underflow
condition|)
block|{
comment|/* Underflow to zero */
name|ls
operator|=
literal|0
expr_stmt|;
name|ms
operator|=
literal|0
expr_stmt|;
name|e
operator|=
name|FPU_st0_ptr
operator|->
name|sign
operator|==
name|SIGN_POS
condition|?
literal|0x7fff
else|:
literal|0xffff
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
name|ls
operator|=
name|FPU_st0_ptr
operator|->
name|sigl
expr_stmt|;
name|ms
operator|=
name|FPU_st0_ptr
operator|->
name|sigh
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Zero
condition|)
block|{
name|ls
operator|=
name|ms
operator|=
literal|0
expr_stmt|;
name|e
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Infinity
condition|)
block|{
name|ls
operator|=
literal|0
expr_stmt|;
name|ms
operator|=
literal|0x80000000
expr_stmt|;
name|e
operator|=
literal|0x7fff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_NaN
condition|)
block|{
name|ls
operator|=
name|FPU_st0_ptr
operator|->
name|sigl
expr_stmt|;
name|ms
operator|=
name|FPU_st0_ptr
operator|->
name|sigh
expr_stmt|;
name|e
operator|=
literal|0x7fff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Empty
condition|)
block|{
comment|/* Empty register (stack 						 * underflow) */
name|EXCEPTION
argument_list|(
name|EX_StackUnder
argument_list|)
expr_stmt|;
if|if
condition|(
name|control_word
operator|&
name|EX_Invalid
condition|)
block|{
comment|/* The masked response */
comment|/* Put out the QNaN 							 * indefinite */
name|ls
operator|=
literal|0
expr_stmt|;
name|ms
operator|=
literal|0xc0000000
expr_stmt|;
name|e
operator|=
literal|0xffff
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* We don't use TW_Denormal 						 * yet ... perhaps never! */
name|EXCEPTION
argument_list|(
name|EX_Invalid
argument_list|)
expr_stmt|;
comment|/* Store a NaN */
name|e
operator|=
literal|0x7fff
expr_stmt|;
name|ls
operator|=
literal|1
expr_stmt|;
name|ms
operator|=
literal|0x80000000
expr_stmt|;
block|}
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
comment|/*	    verify_area(VERIFY_WRITE, d, 10); */
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|d
argument_list|,
name|ls
argument_list|)
expr_stmt|;
name|suword
argument_list|(
literal|1
operator|+
operator|(
name|unsigned
name|long
operator|*
operator|)
name|d
argument_list|,
name|ms
argument_list|)
expr_stmt|;
name|suword
argument_list|(
literal|4
operator|+
operator|(
name|short
operator|*
operator|)
name|d
argument_list|,
operator|(
name|unsigned
name|short
operator|)
name|e
operator||
name|sign
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Put a double into user memory */
end_comment

begin_function
name|int
name|reg_store_double
parameter_list|(
name|void
parameter_list|)
block|{
name|double
modifier|*
name|dfloat
init|=
operator|(
name|double
operator|*
operator|)
name|FPU_data_address
decl_stmt|;
name|unsigned
name|long
name|l
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Valid
condition|)
block|{
name|int
name|exp
decl_stmt|;
name|FPU_REG
name|tmp
decl_stmt|;
name|reg_move
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|exp
operator|=
name|tmp
operator|.
name|exp
operator|-
name|EXP_BIAS
expr_stmt|;
if|if
condition|(
name|exp
operator|<
name|DOUBLE_Emin
condition|)
block|{
comment|/* It may be a denormal */
comment|/* Make a de-normal */
name|int
name|precision_loss
decl_stmt|;
if|if
condition|(
name|exp
operator|<=
operator|-
name|EXTENDED_Ebias
condition|)
name|EXCEPTION
argument_list|(
name|EX_Denormal
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|exp
operator|+=
operator|-
name|DOUBLE_Emin
operator|+
literal|52
expr_stmt|;
comment|/* largest exp to be 51 */
if|if
condition|(
operator|(
name|precision_loss
operator|=
name|round_to_int
argument_list|(
operator|&
name|tmp
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PECULIAR_486
comment|/* Did it round to a non-denormal ? */
comment|/* This behaviour might be regarded as 				 * peculiar, it appears that the 80486 rounds 				 * to the dest precision, then converts to 				 * decide underflow. */
if|if
condition|(
operator|(
name|tmp
operator|.
name|sigh
operator|==
literal|0x00100000
operator|)
operator|&&
operator|(
name|tmp
operator|.
name|sigl
operator|==
literal|0
operator|)
operator|&&
operator|(
name|FPU_st0_ptr
operator|->
name|sigl
operator|&
literal|0x000007ff
operator|)
condition|)
name|EXCEPTION
argument_list|(
name|precision_loss
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* PECULIAR_486 */
block|{
name|EXCEPTION
argument_list|(
name|EX_Underflow
operator||
name|precision_loss
argument_list|)
expr_stmt|;
comment|/* This is a special case: see sec 					 * 16.2.5.1 of the 80486 book */
if|if
condition|(
operator|!
operator|(
name|control_word
operator|&
name|EX_Underflow
operator|)
condition|)
return|return
literal|0
return|;
block|}
block|}
name|l
index|[
literal|0
index|]
operator|=
name|tmp
operator|.
name|sigl
expr_stmt|;
name|l
index|[
literal|1
index|]
operator|=
name|tmp
operator|.
name|sigh
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tmp
operator|.
name|sigl
operator|&
literal|0x000007ff
condition|)
block|{
name|unsigned
name|long
name|increment
init|=
literal|0
decl_stmt|;
comment|/* avoid gcc warnings */
switch|switch
condition|(
name|control_word
operator|&
name|CW_RC
condition|)
block|{
case|case
name|RC_RND
case|:
comment|/* Rounding can get a little messy.. */
name|increment
operator|=
operator|(
operator|(
name|tmp
operator|.
name|sigl
operator|&
literal|0x7ff
operator|)
operator|>
literal|0x400
operator|)
operator||
comment|/* nearest */
operator|(
operator|(
name|tmp
operator|.
name|sigl
operator|&
literal|0xc00
operator|)
operator|==
literal|0xc00
operator|)
expr_stmt|;
comment|/* odd -> even */
break|break;
case|case
name|RC_DOWN
case|:
comment|/* towards -infinity */
name|increment
operator|=
operator|(
name|tmp
operator|.
name|sign
operator|==
name|SIGN_POS
operator|)
condition|?
literal|0
else|:
name|tmp
operator|.
name|sigl
operator|&
literal|0x7ff
expr_stmt|;
break|break;
case|case
name|RC_UP
case|:
comment|/* towards +infinity */
name|increment
operator|=
operator|(
name|tmp
operator|.
name|sign
operator|==
name|SIGN_POS
operator|)
condition|?
name|tmp
operator|.
name|sigl
operator|&
literal|0x7ff
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|RC_CHOP
case|:
name|increment
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Truncate the mantissa */
name|tmp
operator|.
name|sigl
operator|&=
literal|0xfffff800
expr_stmt|;
if|if
condition|(
name|increment
condition|)
block|{
name|set_precision_flag_up
argument_list|()
expr_stmt|;
if|if
condition|(
name|tmp
operator|.
name|sigl
operator|>=
literal|0xfffff800
condition|)
block|{
comment|/* the sigl part overflows */
if|if
condition|(
name|tmp
operator|.
name|sigh
operator|==
literal|0xffffffff
condition|)
block|{
comment|/* The sigh part 							 * overflows */
name|tmp
operator|.
name|sigh
operator|=
literal|0x80000000
expr_stmt|;
name|exp
operator|++
expr_stmt|;
if|if
condition|(
name|exp
operator|>=
name|EXP_OVER
condition|)
goto|goto
name|overflow
goto|;
block|}
else|else
block|{
name|tmp
operator|.
name|sigh
operator|++
expr_stmt|;
block|}
name|tmp
operator|.
name|sigl
operator|=
literal|0x00000000
expr_stmt|;
block|}
else|else
block|{
comment|/* We only need to increment 						 * sigl */
name|tmp
operator|.
name|sigl
operator|+=
literal|0x00000800
expr_stmt|;
block|}
block|}
else|else
name|set_precision_flag_down
argument_list|()
expr_stmt|;
block|}
name|l
index|[
literal|0
index|]
operator|=
operator|(
name|tmp
operator|.
name|sigl
operator|>>
literal|11
operator|)
operator||
operator|(
name|tmp
operator|.
name|sigh
operator|<<
literal|21
operator|)
expr_stmt|;
name|l
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|tmp
operator|.
name|sigh
operator|>>
literal|11
operator|)
operator|&
literal|0xfffff
operator|)
expr_stmt|;
if|if
condition|(
name|exp
operator|>
name|DOUBLE_Emax
condition|)
block|{
name|overflow
label|:
name|EXCEPTION
argument_list|(
name|EX_Overflow
argument_list|)
expr_stmt|;
comment|/* This is a special case: see sec 16.2.5.1 of 				 * the 80486 book */
if|if
condition|(
name|control_word
operator|&
name|EX_Overflow
condition|)
block|{
comment|/* Overflow to infinity */
name|l
index|[
literal|0
index|]
operator|=
literal|0x00000000
expr_stmt|;
comment|/* Set to */
name|l
index|[
literal|1
index|]
operator|=
literal|0x7ff00000
expr_stmt|;
comment|/* + INF */
block|}
else|else
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* Add the exponent */
name|l
index|[
literal|1
index|]
operator||=
operator|(
operator|(
operator|(
name|exp
operator|+
name|DOUBLE_Ebias
operator|)
operator|&
literal|0x7ff
operator|)
operator|<<
literal|20
operator|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Zero
condition|)
block|{
comment|/* Number is zero */
name|l
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|l
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Infinity
condition|)
block|{
name|l
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|l
index|[
literal|1
index|]
operator|=
literal|0x7ff00000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_NaN
condition|)
block|{
comment|/* See if we can get a valid NaN from 					 * the FPU_REG */
name|l
index|[
literal|0
index|]
operator|=
operator|(
name|FPU_st0_ptr
operator|->
name|sigl
operator|>>
literal|11
operator|)
operator||
operator|(
name|FPU_st0_ptr
operator|->
name|sigh
operator|<<
literal|21
operator|)
expr_stmt|;
name|l
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|FPU_st0_ptr
operator|->
name|sigh
operator|>>
literal|11
operator|)
operator|&
literal|0xfffff
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|l
index|[
literal|0
index|]
operator||
name|l
index|[
literal|1
index|]
operator|)
condition|)
block|{
comment|/* This case does not seem to 						 * be handled by the 80486 						 * specs */
name|EXCEPTION
argument_list|(
name|EX_Invalid
argument_list|)
expr_stmt|;
comment|/* Make the quiet NaN "real 						 * indefinite" */
goto|goto
name|put_indefinite
goto|;
block|}
name|l
index|[
literal|1
index|]
operator||=
literal|0x7ff00000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Empty
condition|)
block|{
comment|/* Empty register (stack 						 * underflow) */
name|EXCEPTION
argument_list|(
name|EX_StackUnder
argument_list|)
expr_stmt|;
if|if
condition|(
name|control_word
operator|&
name|EX_Invalid
condition|)
block|{
comment|/* The masked response */
comment|/* Put out the QNaN 							 * indefinite */
name|put_indefinite
label|:
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
comment|/* verify_area(VERIFY_W 							 * RITE, (void *) 							 * dfloat, 8); */
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|dfloat
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|suword
argument_list|(
literal|1
operator|+
operator|(
name|unsigned
name|long
operator|*
operator|)
name|dfloat
argument_list|,
literal|0xfff80000
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
if|#
directive|if
literal|0
comment|/* TW_Denormal is not used yet, and probably 				 * won't be */
block|else 						if (FPU_st0_tag == TW_Denormal) {
comment|/* Extended real -> 							 * double real will 							 * always underflow */
block|l[0] = l[1] = 0; 							EXCEPTION(EX_Underflow); 						}
endif|#
directive|endif
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|sign
condition|)
name|l
index|[
literal|1
index|]
operator||=
literal|0x80000000
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
comment|/*	    verify_area(VERIFY_WRITE, (void *) dfloat, 8);*/
name|suword
argument_list|(
operator|(
name|u_long
operator|*
operator|)
name|dfloat
argument_list|,
name|l
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|u_long
operator|*
operator|)
name|dfloat
operator|+
literal|1
argument_list|,
name|l
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* 	suword(l[0], (unsigned long *) dfloat); 	suword(l[1], 1 + (unsigned long *) dfloat);*/
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Put a float into user memory */
end_comment

begin_function
name|int
name|reg_store_single
parameter_list|(
name|void
parameter_list|)
block|{
name|float
modifier|*
name|single
init|=
operator|(
name|float
operator|*
operator|)
name|FPU_data_address
decl_stmt|;
name|long
name|templ
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Valid
condition|)
block|{
name|int
name|exp
decl_stmt|;
name|FPU_REG
name|tmp
decl_stmt|;
name|reg_move
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|exp
operator|=
name|tmp
operator|.
name|exp
operator|-
name|EXP_BIAS
expr_stmt|;
if|if
condition|(
name|exp
operator|<
name|SINGLE_Emin
condition|)
block|{
comment|/* Make a de-normal */
name|int
name|precision_loss
decl_stmt|;
if|if
condition|(
name|exp
operator|<=
operator|-
name|EXTENDED_Ebias
condition|)
name|EXCEPTION
argument_list|(
name|EX_Denormal
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|exp
operator|+=
operator|-
name|SINGLE_Emin
operator|+
literal|23
expr_stmt|;
comment|/* largest exp to be 22 */
if|if
condition|(
operator|(
name|precision_loss
operator|=
name|round_to_int
argument_list|(
operator|&
name|tmp
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PECULIAR_486
comment|/* Did it round to a non-denormal ? */
comment|/* This behaviour might be regarded as 				 * peculiar, it appears that the 80486 rounds 				 * to the dest precision, then converts to 				 * decide underflow. */
if|if
condition|(
operator|(
name|tmp
operator|.
name|sigl
operator|==
literal|0x00800000
operator|)
operator|&&
operator|(
operator|(
name|FPU_st0_ptr
operator|->
name|sigh
operator|&
literal|0x000000ff
operator|)
operator|||
name|FPU_st0_ptr
operator|->
name|sigl
operator|)
condition|)
name|EXCEPTION
argument_list|(
name|precision_loss
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* PECULIAR_486 */
block|{
name|EXCEPTION
argument_list|(
name|EX_Underflow
operator||
name|precision_loss
argument_list|)
expr_stmt|;
comment|/* This is a special case: see sec 					 * 16.2.5.1 of the 80486 book */
if|if
condition|(
operator|!
operator|(
name|control_word
operator|&
name|EX_Underflow
operator|)
condition|)
return|return
literal|0
return|;
block|}
block|}
name|templ
operator|=
name|tmp
operator|.
name|sigl
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|tmp
operator|.
name|sigl
operator||
operator|(
name|tmp
operator|.
name|sigh
operator|&
literal|0x000000ff
operator|)
condition|)
block|{
name|unsigned
name|long
name|increment
init|=
literal|0
decl_stmt|;
comment|/* avoid gcc warnings */
name|unsigned
name|long
name|sigh
init|=
name|tmp
operator|.
name|sigh
decl_stmt|;
name|unsigned
name|long
name|sigl
init|=
name|tmp
operator|.
name|sigl
decl_stmt|;
switch|switch
condition|(
name|control_word
operator|&
name|CW_RC
condition|)
block|{
case|case
name|RC_RND
case|:
name|increment
operator|=
operator|(
operator|(
name|sigh
operator|&
literal|0xff
operator|)
operator|>
literal|0x80
operator|)
comment|/* more than half */
operator|||
operator|(
operator|(
operator|(
name|sigh
operator|&
literal|0xff
operator|)
operator|==
literal|0x80
operator|)
operator|&&
name|sigl
operator|)
comment|/* more than half */
operator|||
operator|(
operator|(
name|sigh
operator|&
literal|0x180
operator|)
operator|==
literal|0x180
operator|)
expr_stmt|;
comment|/* round to even */
break|break;
case|case
name|RC_DOWN
case|:
comment|/* towards -infinity */
name|increment
operator|=
operator|(
name|tmp
operator|.
name|sign
operator|==
name|SIGN_POS
operator|)
condition|?
literal|0
else|:
operator|(
name|sigl
operator||
operator|(
name|sigh
operator|&
literal|0xff
operator|)
operator|)
expr_stmt|;
break|break;
case|case
name|RC_UP
case|:
comment|/* towards +infinity */
name|increment
operator|=
operator|(
name|tmp
operator|.
name|sign
operator|==
name|SIGN_POS
operator|)
condition|?
operator|(
name|sigl
operator||
operator|(
name|sigh
operator|&
literal|0xff
operator|)
operator|)
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|RC_CHOP
case|:
name|increment
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Truncate part of the mantissa */
name|tmp
operator|.
name|sigl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|increment
condition|)
block|{
name|set_precision_flag_up
argument_list|()
expr_stmt|;
if|if
condition|(
name|sigh
operator|>=
literal|0xffffff00
condition|)
block|{
comment|/* The sigh part overflows */
name|tmp
operator|.
name|sigh
operator|=
literal|0x80000000
expr_stmt|;
name|exp
operator|++
expr_stmt|;
if|if
condition|(
name|exp
operator|>=
name|EXP_OVER
condition|)
goto|goto
name|overflow
goto|;
block|}
else|else
block|{
name|tmp
operator|.
name|sigh
operator|&=
literal|0xffffff00
expr_stmt|;
name|tmp
operator|.
name|sigh
operator|+=
literal|0x100
expr_stmt|;
block|}
block|}
else|else
block|{
name|set_precision_flag_down
argument_list|()
expr_stmt|;
name|tmp
operator|.
name|sigh
operator|&=
literal|0xffffff00
expr_stmt|;
comment|/* Finish the truncation */
block|}
block|}
name|templ
operator|=
operator|(
name|tmp
operator|.
name|sigh
operator|>>
literal|8
operator|)
operator|&
literal|0x007fffff
expr_stmt|;
if|if
condition|(
name|exp
operator|>
name|SINGLE_Emax
condition|)
block|{
name|overflow
label|:
name|EXCEPTION
argument_list|(
name|EX_Overflow
argument_list|)
expr_stmt|;
comment|/* This is a special case: see sec 16.2.5.1 of 				 * the 80486 book */
if|if
condition|(
name|control_word
operator|&
name|EX_Overflow
condition|)
block|{
comment|/* Overflow to infinity */
name|templ
operator|=
literal|0x7f800000
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
else|else
name|templ
operator||=
operator|(
operator|(
name|exp
operator|+
name|SINGLE_Ebias
operator|)
operator|&
literal|0xff
operator|)
operator|<<
literal|23
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Zero
condition|)
block|{
name|templ
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Infinity
condition|)
block|{
name|templ
operator|=
literal|0x7f800000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_NaN
condition|)
block|{
comment|/* See if we can get a valid NaN from 					 * the FPU_REG */
name|templ
operator|=
name|FPU_st0_ptr
operator|->
name|sigh
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|templ
operator|&
literal|0x3fffff
operator|)
condition|)
block|{
comment|/* This case does not seem to 						 * be handled by the 80486 						 * specs */
name|EXCEPTION
argument_list|(
name|EX_Invalid
argument_list|)
expr_stmt|;
comment|/* Make the quiet NaN "real 						 * indefinite" */
goto|goto
name|put_indefinite
goto|;
block|}
name|templ
operator||=
literal|0x7f800000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Empty
condition|)
block|{
comment|/* Empty register (stack 						 * underflow) */
name|EXCEPTION
argument_list|(
name|EX_StackUnder
argument_list|)
expr_stmt|;
if|if
condition|(
name|control_word
operator|&
name|EX_Invalid
condition|)
block|{
comment|/* The masked response */
comment|/* Put out the QNaN 							 * indefinite */
name|put_indefinite
label|:
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
comment|/*							    verify_area(VERIFY_WRITE, (void *) single, 4); */
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|single
argument_list|,
literal|0xffc00000
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
if|#
directive|if
literal|0
comment|/* TW_Denormal is not used yet, and probably 				 * won't be */
if|else 						if (FPU_st0_tag == TW_Denormal) {
comment|/* Extended real -> 							 * real will always 							 * underflow */
if|templ = 0; 							EXCEPTION(EX_Underflow); 						}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PARANOID
else|else
block|{
name|EXCEPTION
argument_list|(
name|EX_INTERNAL
operator||
literal|0x106
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|FPU_st0_ptr
operator|->
name|sign
condition|)
name|templ
operator||=
literal|0x80000000
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
comment|/*	    verify_area(VERIFY_WRITE, (void *) single, 4); */
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|single
argument_list|,
name|templ
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Put a long long into user memory */
end_comment

begin_function
name|int
name|reg_store_int64
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|long
modifier|*
name|d
init|=
operator|(
name|long
name|long
operator|*
operator|)
name|FPU_data_address
decl_stmt|;
name|FPU_REG
name|t
decl_stmt|;
name|long
name|long
name|tll
decl_stmt|;
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Empty
condition|)
block|{
comment|/* Empty register (stack underflow) */
name|EXCEPTION
argument_list|(
name|EX_StackUnder
argument_list|)
expr_stmt|;
if|if
condition|(
name|control_word
operator|&
name|EX_Invalid
condition|)
block|{
comment|/* The masked response */
comment|/* Put out the QNaN indefinite */
goto|goto
name|put_indefinite
goto|;
block|}
else|else
return|return
literal|0
return|;
block|}
name|reg_move
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|round_to_int
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
operator|(
operator|(
name|long
operator|*
operator|)
operator|&
name|tll
operator|)
index|[
literal|0
index|]
operator|=
name|t
operator|.
name|sigl
expr_stmt|;
operator|(
operator|(
name|long
operator|*
operator|)
operator|&
name|tll
operator|)
index|[
literal|1
index|]
operator|=
name|t
operator|.
name|sigh
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|.
name|sigh
operator|&
literal|0x80000000
operator|)
operator|&&
operator|!
operator|(
operator|(
name|t
operator|.
name|sigh
operator|==
literal|0x80000000
operator|)
operator|&&
operator|(
name|t
operator|.
name|sigl
operator|==
literal|0
operator|)
operator|&&
operator|(
name|t
operator|.
name|sign
operator|==
name|SIGN_NEG
operator|)
operator|)
condition|)
block|{
name|EXCEPTION
argument_list|(
name|EX_Invalid
argument_list|)
expr_stmt|;
comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
if|if
condition|(
name|control_word
operator|&
name|EX_Invalid
condition|)
block|{
comment|/* Produce "indefinite" */
name|put_indefinite
label|:
operator|(
operator|(
name|long
operator|*
operator|)
operator|&
name|tll
operator|)
index|[
literal|1
index|]
operator|=
literal|0x80000000
expr_stmt|;
operator|(
operator|(
name|long
operator|*
operator|)
operator|&
name|tll
operator|)
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|t
operator|.
name|sign
condition|)
name|tll
operator|=
operator|-
name|tll
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
comment|/*	    verify_area(VERIFY_WRITE, (void *) d, 8); */
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|d
argument_list|,
operator|(
operator|(
name|long
operator|*
operator|)
operator|&
name|tll
operator|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|suword
argument_list|(
literal|1
operator|+
operator|(
name|unsigned
name|long
operator|*
operator|)
name|d
argument_list|,
operator|(
operator|(
name|long
operator|*
operator|)
operator|&
name|tll
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Put a long into user memory */
end_comment

begin_function
name|int
name|reg_store_int32
parameter_list|(
name|void
parameter_list|)
block|{
name|long
modifier|*
name|d
init|=
operator|(
name|long
operator|*
operator|)
name|FPU_data_address
decl_stmt|;
name|FPU_REG
name|t
decl_stmt|;
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Empty
condition|)
block|{
comment|/* Empty register (stack underflow) */
name|EXCEPTION
argument_list|(
name|EX_StackUnder
argument_list|)
expr_stmt|;
if|if
condition|(
name|control_word
operator|&
name|EX_Invalid
condition|)
block|{
comment|/* The masked response */
comment|/* Put out the QNaN indefinite */
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
comment|/*			    verify_area(VERIFY_WRITE, d, 4);*/
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|d
argument_list|,
literal|0x80000000
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
name|reg_move
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|round_to_int
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|sigh
operator|||
operator|(
operator|(
name|t
operator|.
name|sigl
operator|&
literal|0x80000000
operator|)
operator|&&
operator|!
operator|(
operator|(
name|t
operator|.
name|sigl
operator|==
literal|0x80000000
operator|)
operator|&&
operator|(
name|t
operator|.
name|sign
operator|==
name|SIGN_NEG
operator|)
operator|)
operator|)
condition|)
block|{
name|EXCEPTION
argument_list|(
name|EX_Invalid
argument_list|)
expr_stmt|;
comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
if|if
condition|(
name|control_word
operator|&
name|EX_Invalid
condition|)
block|{
comment|/* Produce "indefinite" */
name|t
operator|.
name|sigl
operator|=
literal|0x80000000
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|t
operator|.
name|sign
condition|)
name|t
operator|.
name|sigl
operator|=
operator|-
operator|(
name|long
operator|)
name|t
operator|.
name|sigl
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
comment|/*	    verify_area(VERIFY_WRITE, d, 4); */
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|d
argument_list|,
name|t
operator|.
name|sigl
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Put a short into user memory */
end_comment

begin_function
name|int
name|reg_store_int16
parameter_list|(
name|void
parameter_list|)
block|{
name|short
modifier|*
name|d
init|=
operator|(
name|short
operator|*
operator|)
name|FPU_data_address
decl_stmt|;
name|FPU_REG
name|t
decl_stmt|;
name|short
name|ts
decl_stmt|;
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Empty
condition|)
block|{
comment|/* Empty register (stack underflow) */
name|EXCEPTION
argument_list|(
name|EX_StackUnder
argument_list|)
expr_stmt|;
if|if
condition|(
name|control_word
operator|&
name|EX_Invalid
condition|)
block|{
comment|/* The masked response */
comment|/* Put out the QNaN indefinite */
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
comment|/*			    verify_area(VERIFY_WRITE, d, 2);*/
name|suword
argument_list|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|d
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
name|reg_move
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|round_to_int
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|.
name|sigh
operator|||
operator|(
operator|(
name|t
operator|.
name|sigl
operator|&
literal|0xffff8000
operator|)
operator|&&
operator|!
operator|(
operator|(
name|t
operator|.
name|sigl
operator|==
literal|0x8000
operator|)
operator|&&
operator|(
name|t
operator|.
name|sign
operator|==
name|SIGN_NEG
operator|)
operator|)
operator|)
condition|)
block|{
name|EXCEPTION
argument_list|(
name|EX_Invalid
argument_list|)
expr_stmt|;
comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
if|if
condition|(
name|control_word
operator|&
name|EX_Invalid
condition|)
block|{
comment|/* Produce "indefinite" */
name|ts
operator|=
literal|0x8000
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|t
operator|.
name|sign
condition|)
name|t
operator|.
name|sigl
operator|=
operator|-
name|t
operator|.
name|sigl
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
comment|/*	    verify_area(VERIFY_WRITE, d, 2); */
name|suword
argument_list|(
operator|(
name|short
operator|*
operator|)
name|d
argument_list|,
operator|(
name|short
operator|)
name|t
operator|.
name|sigl
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Put a packed bcd array into user memory */
end_comment

begin_function
name|int
name|reg_store_bcd
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|d
init|=
operator|(
name|char
operator|*
operator|)
name|FPU_data_address
decl_stmt|;
name|FPU_REG
name|t
decl_stmt|;
name|long
name|long
name|ll
decl_stmt|;
name|unsigned
name|char
name|b
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|sign
init|=
operator|(
name|FPU_st0_ptr
operator|->
name|sign
operator|==
name|SIGN_NEG
operator|)
condition|?
literal|0x80
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|FPU_st0_tag
operator|==
name|TW_Empty
condition|)
block|{
comment|/* Empty register (stack underflow) */
name|EXCEPTION
argument_list|(
name|EX_StackUnder
argument_list|)
expr_stmt|;
if|if
condition|(
name|control_word
operator|&
name|EX_Invalid
condition|)
block|{
comment|/* The masked response */
comment|/* Put out the QNaN indefinite */
goto|goto
name|put_indefinite
goto|;
block|}
else|else
return|return
literal|0
return|;
block|}
name|reg_move
argument_list|(
name|FPU_st0_ptr
argument_list|,
operator|&
name|t
argument_list|)
expr_stmt|;
name|round_to_int
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|ll
operator|=
operator|*
operator|(
name|long
name|long
operator|*
operator|)
operator|(
operator|&
name|t
operator|.
name|sigl
operator|)
expr_stmt|;
comment|/* Check for overflow, by comparing with 999999999999999999 decimal. */
if|if
condition|(
operator|(
name|t
operator|.
name|sigh
operator|>
literal|0x0de0b6b3
operator|)
operator|||
operator|(
operator|(
name|t
operator|.
name|sigh
operator|==
literal|0x0de0b6b3
operator|)
operator|&&
operator|(
name|t
operator|.
name|sigl
operator|>
literal|0xa763ffff
operator|)
operator|)
condition|)
block|{
name|EXCEPTION
argument_list|(
name|EX_Invalid
argument_list|)
expr_stmt|;
comment|/* This is a special case: see sec 16.2.5.1 of the 80486 book */
if|if
condition|(
name|control_word
operator|&
name|EX_Invalid
condition|)
block|{
name|put_indefinite
label|:
comment|/* Produce "indefinite" */
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
comment|/*			    verify_area(VERIFY_WRITE, d, 10);*/
name|subyte
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|d
operator|+
literal|7
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|subyte
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|d
operator|+
literal|8
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|subyte
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|d
operator|+
literal|9
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
comment|/*	verify_area(VERIFY_WRITE, d, 10);*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|9
condition|;
name|i
operator|++
control|)
block|{
name|b
operator|=
name|div_small
argument_list|(
operator|&
name|ll
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|b
operator||=
operator|(
name|div_small
argument_list|(
operator|&
name|ll
argument_list|,
literal|10
argument_list|)
operator|)
operator|<<
literal|4
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|subyte
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|d
operator|+
name|i
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
block|}
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|subyte
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|d
operator|+
literal|9
argument_list|,
name|sign
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*===========================================================================*/
end_comment

begin_comment
comment|/* r gets mangled such that sig is int, sign:    it is NOT normalized */
end_comment

begin_comment
comment|/* The return value (in eax) is zero if the result is exact,    if bits are changed due to rounding, truncation, etc, then    a non-zero value is returned */
end_comment

begin_comment
comment|/* Overflow is signalled by a non-zero return value (in eax).    In the case of overflow, the returned significand always has the    the largest possible value */
end_comment

begin_comment
comment|/* The value returned in eax is never actually needed :-) */
end_comment

begin_function
name|int
name|round_to_int
parameter_list|(
name|FPU_REG
modifier|*
name|r
parameter_list|)
block|{
name|char
name|very_big
decl_stmt|;
name|unsigned
name|eax
decl_stmt|;
if|if
condition|(
name|r
operator|->
name|tag
operator|==
name|TW_Zero
condition|)
block|{
comment|/* Make sure that zero is returned */
operator|*
operator|(
name|long
name|long
operator|*
operator|)
operator|&
name|r
operator|->
name|sigl
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
comment|/* o.k. */
block|}
if|if
condition|(
name|r
operator|->
name|exp
operator|>
name|EXP_BIAS
operator|+
literal|63
condition|)
block|{
name|r
operator|->
name|sigl
operator|=
name|r
operator|->
name|sigh
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* The largest representable number */
return|return
literal|1
return|;
comment|/* overflow */
block|}
name|eax
operator|=
name|shrxs
argument_list|(
operator|&
name|r
operator|->
name|sigl
argument_list|,
name|EXP_BIAS
operator|+
literal|63
operator|-
name|r
operator|->
name|exp
argument_list|)
expr_stmt|;
name|very_big
operator|=
operator|!
operator|(
operator|~
operator|(
name|r
operator|->
name|sigh
operator|)
operator||
operator|~
operator|(
name|r
operator|->
name|sigl
operator|)
operator|)
expr_stmt|;
comment|/* test for 0xfff...fff */
define|#
directive|define
name|half_or_more
value|(eax& 0x80000000)
define|#
directive|define
name|frac_part
value|(eax)
define|#
directive|define
name|more_than_half
value|((eax& 0x80000001) == 0x80000001)
switch|switch
condition|(
name|control_word
operator|&
name|CW_RC
condition|)
block|{
case|case
name|RC_RND
case|:
if|if
condition|(
name|more_than_half
comment|/* nearest */
operator|||
operator|(
name|half_or_more
operator|&&
operator|(
name|r
operator|->
name|sigl
operator|&
literal|1
operator|)
operator|)
condition|)
block|{
comment|/* odd -> even */
if|if
condition|(
name|very_big
condition|)
return|return
literal|1
return|;
comment|/* overflow */
operator|(
operator|*
operator|(
name|long
name|long
operator|*
operator|)
operator|(
operator|&
name|r
operator|->
name|sigl
operator|)
operator|)
operator|++
expr_stmt|;
return|return
name|LOST_UP
return|;
block|}
break|break;
case|case
name|RC_DOWN
case|:
if|if
condition|(
name|frac_part
operator|&&
name|r
operator|->
name|sign
condition|)
block|{
if|if
condition|(
name|very_big
condition|)
return|return
literal|1
return|;
comment|/* overflow */
operator|(
operator|*
operator|(
name|long
name|long
operator|*
operator|)
operator|(
operator|&
name|r
operator|->
name|sigl
operator|)
operator|)
operator|++
expr_stmt|;
return|return
name|LOST_UP
return|;
block|}
break|break;
case|case
name|RC_UP
case|:
if|if
condition|(
name|frac_part
operator|&&
operator|!
name|r
operator|->
name|sign
condition|)
block|{
if|if
condition|(
name|very_big
condition|)
return|return
literal|1
return|;
comment|/* overflow */
operator|(
operator|*
operator|(
name|long
name|long
operator|*
operator|)
operator|(
operator|&
name|r
operator|->
name|sigl
operator|)
operator|)
operator|++
expr_stmt|;
return|return
name|LOST_UP
return|;
block|}
break|break;
case|case
name|RC_CHOP
case|:
break|break;
block|}
return|return
name|eax
condition|?
name|LOST_DOWN
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/*===========================================================================*/
end_comment

begin_function
name|char
modifier|*
name|fldenv
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|FPU_data_address
decl_stmt|;
name|unsigned
name|short
name|tag_word
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|tag
decl_stmt|;
name|int
name|i
decl_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|control_word
operator|=
name|fuword
argument_list|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|s
argument_list|)
expr_stmt|;
name|status_word
operator|=
name|fuword
argument_list|(
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|s
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
name|tag_word
operator|=
name|fuword
argument_list|(
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|s
operator|+
literal|8
operator|)
argument_list|)
expr_stmt|;
name|ip_offset
operator|=
name|fuword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|s
operator|+
literal|0x0c
operator|)
argument_list|)
expr_stmt|;
name|cs_selector
operator|=
name|fuword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|s
operator|+
literal|0x10
operator|)
argument_list|)
expr_stmt|;
name|data_operand_offset
operator|=
name|fuword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|s
operator|+
literal|0x14
operator|)
argument_list|)
expr_stmt|;
name|operand_selector
operator|=
name|fuword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|s
operator|+
literal|0x18
operator|)
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
name|top
operator|=
operator|(
name|status_word
operator|>>
name|SW_Top_Shift
operator|)
operator|&
literal|7
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|tag
operator|=
name|tag_word
operator|&
literal|3
expr_stmt|;
name|tag_word
operator|>>=
literal|2
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
literal|0
case|:
name|regs
index|[
name|i
index|]
operator|.
name|tag
operator|=
name|TW_Valid
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|regs
index|[
name|i
index|]
operator|.
name|tag
operator|=
name|TW_Zero
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|regs
index|[
name|i
index|]
operator|.
name|tag
operator|=
name|TW_NaN
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|regs
index|[
name|i
index|]
operator|.
name|tag
operator|=
name|TW_Empty
expr_stmt|;
break|break;
block|}
block|}
name|FPU_data_address
operator|=
operator|(
name|void
operator|*
operator|)
name|data_operand_offset
expr_stmt|;
comment|/* We want no net effect */
name|FPU_entry_eip
operator|=
name|ip_offset
expr_stmt|;
comment|/* We want no net effect */
return|return
name|s
operator|+
literal|0x1c
return|;
block|}
end_function

begin_function
name|void
name|frstor
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|stnr
decl_stmt|;
name|unsigned
name|char
name|tag
decl_stmt|;
name|unsigned
name|short
name|saved_status
decl_stmt|,
name|saved_control
decl_stmt|;
name|char
modifier|*
name|s
init|=
operator|(
name|char
operator|*
operator|)
name|fldenv
argument_list|()
decl_stmt|;
name|saved_status
operator|=
name|status_word
expr_stmt|;
name|saved_control
operator|=
name|control_word
expr_stmt|;
name|control_word
operator|=
literal|0x037f
expr_stmt|;
comment|/* Mask all interrupts while we load. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
comment|/* load each register */
name|FPU_data_address
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|s
operator|+
name|i
operator|*
literal|10
operator|)
expr_stmt|;
name|reg_load_extended
argument_list|()
expr_stmt|;
name|stnr
operator|=
operator|(
name|i
operator|+
name|top
operator|)
operator|&
literal|7
expr_stmt|;
name|tag
operator|=
name|regs
index|[
name|stnr
index|]
operator|.
name|tag
expr_stmt|;
comment|/* derived from the loaded tag word */
name|reg_move
argument_list|(
operator|&
name|FPU_loaded_data
argument_list|,
operator|&
name|regs
index|[
name|stnr
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|TW_NaN
condition|)
block|{
comment|/* The current data is a special, i.e. NaN, 			 * unsupported, infinity, or denormal */
name|unsigned
name|char
name|t
init|=
name|regs
index|[
name|stnr
index|]
operator|.
name|tag
decl_stmt|;
comment|/* derived from the new 								 * data */
if|if
condition|(
comment|/* (t == TW_Valid) || *** */
operator|(
name|t
operator|==
name|TW_Zero
operator|)
condition|)
name|regs
index|[
name|stnr
index|]
operator|.
name|tag
operator|=
name|TW_NaN
expr_stmt|;
block|}
else|else
name|regs
index|[
name|stnr
index|]
operator|.
name|tag
operator|=
name|tag
expr_stmt|;
block|}
name|control_word
operator|=
name|saved_control
expr_stmt|;
name|status_word
operator|=
name|saved_status
expr_stmt|;
name|FPU_data_address
operator|=
operator|(
name|void
operator|*
operator|)
name|data_operand_offset
expr_stmt|;
comment|/* We want no net effect */
block|}
end_function

begin_function
name|unsigned
name|short
name|tag_word
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|short
name|word
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|tag
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|tag
operator|=
name|regs
index|[
name|i
index|]
operator|.
name|tag
condition|)
block|{
if|#
directive|if
literal|0
comment|/* TW_Denormal is not used yet, and probably 				 * won't be */
block|case TW_Denormal:
endif|#
directive|endif
case|case
name|TW_Valid
case|:
if|if
condition|(
name|regs
index|[
name|i
index|]
operator|.
name|exp
operator|<=
operator|(
name|EXP_BIAS
operator|-
name|EXTENDED_Ebias
operator|)
condition|)
name|tag
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|TW_Infinity
case|:
case|case
name|TW_NaN
case|:
name|tag
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|TW_Empty
case|:
name|tag
operator|=
literal|3
expr_stmt|;
break|break;
comment|/* TW_Valid and TW_Zero already have the correct value */
block|}
name|word
operator|<<=
literal|2
expr_stmt|;
name|word
operator||=
name|tag
expr_stmt|;
block|}
return|return
name|word
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|fstenv
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|d
init|=
operator|(
name|char
operator|*
operator|)
name|FPU_data_address
decl_stmt|;
comment|/*	verify_area(VERIFY_WRITE, d, 28);*/
if|#
directive|if
literal|0
comment|/****/
block|*(unsigned short *)&cs_selector = fpu_cs; 	*(unsigned short *)&operand_selector = fpu_os;
endif|#
directive|endif
comment|/****/
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|short
operator|*
operator|)
name|d
argument_list|,
name|control_word
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|d
operator|+
literal|4
operator|)
argument_list|,
operator|(
name|status_word
operator|&
operator|~
name|SW_Top
operator|)
operator||
operator|(
operator|(
name|top
operator|&
literal|7
operator|)
operator|<<
name|SW_Top_Shift
operator|)
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|d
operator|+
literal|8
operator|)
argument_list|,
name|tag_word
argument_list|()
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|d
operator|+
literal|0x0c
operator|)
argument_list|,
name|ip_offset
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|d
operator|+
literal|0x10
operator|)
argument_list|,
name|cs_selector
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|d
operator|+
literal|0x14
operator|)
argument_list|,
name|data_operand_offset
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|d
operator|+
literal|0x18
operator|)
argument_list|,
name|operand_selector
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
return|return
name|d
operator|+
literal|0x1c
return|;
block|}
end_function

begin_function
name|void
name|fsave
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|d
decl_stmt|;
name|FPU_REG
name|tmp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|short
name|e
decl_stmt|;
name|d
operator|=
name|fstenv
argument_list|()
expr_stmt|;
comment|/*	verify_area(VERIFY_WRITE, d, 80);*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
comment|/* Store each register in the order: st(0), st(1), ... */
name|rp
operator|=
operator|&
name|regs
index|[
operator|(
name|top
operator|+
name|i
operator|)
operator|&
literal|7
index|]
expr_stmt|;
name|e
operator|=
name|rp
operator|->
name|exp
operator|-
name|EXP_BIAS
operator|+
name|EXTENDED_Ebias
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|tag
operator|==
name|TW_Valid
condition|)
block|{
if|if
condition|(
name|e
operator|>=
literal|0x7fff
condition|)
block|{
comment|/* Overflow to infinity */
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|d
operator|+
name|i
operator|*
literal|10
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|d
operator|+
name|i
operator|*
literal|10
operator|+
literal|4
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
name|e
operator|=
literal|0x7fff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|e
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|>
operator|-
literal|63
condition|)
block|{
comment|/* Make a de-normal */
name|reg_move
argument_list|(
name|rp
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|.
name|exp
operator|+=
operator|-
name|EXTENDED_Emin
operator|+
literal|63
expr_stmt|;
comment|/* largest exp to be 62 */
name|round_to_int
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|d
operator|+
name|i
operator|*
literal|10
operator|)
argument_list|,
name|tmp
operator|.
name|sigl
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|d
operator|+
name|i
operator|*
literal|10
operator|+
literal|4
operator|)
argument_list|,
name|tmp
operator|.
name|sigh
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Underflow to zero */
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|d
operator|+
name|i
operator|*
literal|10
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|d
operator|+
name|i
operator|*
literal|10
operator|+
literal|4
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|d
operator|+
name|i
operator|*
literal|10
operator|)
argument_list|,
name|rp
operator|->
name|sigl
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|d
operator|+
name|i
operator|*
literal|10
operator|+
literal|4
operator|)
argument_list|,
name|rp
operator|->
name|sigh
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rp
operator|->
name|tag
operator|==
name|TW_Zero
condition|)
block|{
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|d
operator|+
name|i
operator|*
literal|10
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|d
operator|+
name|i
operator|*
literal|10
operator|+
literal|4
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
name|e
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rp
operator|->
name|tag
operator|==
name|TW_Infinity
condition|)
block|{
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|d
operator|+
name|i
operator|*
literal|10
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|d
operator|+
name|i
operator|*
literal|10
operator|+
literal|4
operator|)
argument_list|,
literal|0x80000000
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
name|e
operator|=
literal|0x7fff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rp
operator|->
name|tag
operator|==
name|TW_NaN
condition|)
block|{
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|d
operator|+
name|i
operator|*
literal|10
operator|)
argument_list|,
name|rp
operator|->
name|sigl
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|d
operator|+
name|i
operator|*
literal|10
operator|+
literal|4
operator|)
argument_list|,
name|rp
operator|->
name|sigh
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
name|e
operator|=
literal|0x7fff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rp
operator|->
name|tag
operator|==
name|TW_Empty
condition|)
block|{
comment|/* just copy the reg */
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|d
operator|+
name|i
operator|*
literal|10
operator|)
argument_list|,
name|rp
operator|->
name|sigl
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|d
operator|+
name|i
operator|*
literal|10
operator|+
literal|4
operator|)
argument_list|,
name|rp
operator|->
name|sigh
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
block|}
name|e
operator||=
name|rp
operator|->
name|sign
operator|==
name|SIGN_POS
condition|?
literal|0
else|:
literal|0x8000
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|OFF
argument_list|)
expr_stmt|;
name|suword
argument_list|(
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|(
name|d
operator|+
name|i
operator|*
literal|10
operator|+
literal|8
operator|)
argument_list|,
name|e
argument_list|)
expr_stmt|;
name|REENTRANT_CHECK
argument_list|(
name|ON
argument_list|)
expr_stmt|;
block|}
name|finit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*===========================================================================*/
end_comment

end_unit

