begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  *  dgb.c $Id: dgb.c,v 1.15 1995/12/29 13:21:10 bde Exp $  *  *  Digiboard driver.  *  *  Stage 1. "Better than nothing".  *  *  Based on sio driver by Bruce Evans and on Linux driver by Troy   *  De Jongh<troyd@digibd.com> or<troyd@skypoint.com>   *  which is under GNU General Public License version 2 so this driver   *  is forced to be under GPL 2 too.  *  *  Written by Serge Babkin,  *      Joint Stock Commercial Bank "Chelindbank"  *      (Chelyabinsk, Russia)  *      babkin@hq.icb.chel.su  */
end_comment

begin_include
include|#
directive|include
file|"dgb.h"
end_include

begin_if
if|#
directive|if
name|NDGB
operator|>
literal|0
end_if

begin_comment
comment|/* the overall number of ports controlled by this driver */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NDGBPORTS
end_ifndef

begin_define
define|#
directive|define
name|NDGBPORTS
value|(NDGB*16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/devconf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEVFS*/
end_comment

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa.h>
end_include

begin_include
include|#
directive|include
file|<i386/isa/isa_device.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/isa/dgbios.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/isa/dgfep.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/isa/dgreg.h>
end_include

begin_define
define|#
directive|define
name|CALLOUT_MASK
value|0x80
end_define

begin_define
define|#
directive|define
name|CONTROL_MASK
value|0x60
end_define

begin_define
define|#
directive|define
name|CONTROL_INIT_STATE
value|0x20
end_define

begin_define
define|#
directive|define
name|CONTROL_LOCK_STATE
value|0x40
end_define

begin_define
define|#
directive|define
name|UNIT_MASK
value|0x30000
end_define

begin_define
define|#
directive|define
name|PORT_MASK
value|0x1F
end_define

begin_define
define|#
directive|define
name|DEV_TO_UNIT
parameter_list|(
name|dev
parameter_list|)
value|(MINOR_TO_UNIT(minor(dev)))
end_define

begin_define
define|#
directive|define
name|MINOR_MAGIC_MASK
value|(CALLOUT_MASK | CONTROL_MASK)
end_define

begin_define
define|#
directive|define
name|MINOR_TO_UNIT
parameter_list|(
name|mynor
parameter_list|)
value|(((mynor)& UNIT_MASK)>>16)
end_define

begin_define
define|#
directive|define
name|MINOR_TO_PORT
parameter_list|(
name|mynor
parameter_list|)
value|((mynor)& PORT_MASK)
end_define

begin_comment
comment|/* types.  XXX - should be elsewhere */
end_comment

begin_typedef
typedef|typedef
name|u_char
name|bool_t
typedef|;
end_typedef

begin_comment
comment|/* boolean */
end_comment

begin_comment
comment|/* digiboard port structure */
end_comment

begin_struct
struct|struct
name|dgb_p
block|{
name|bool_t
name|status
decl_stmt|;
name|u_char
name|unit
decl_stmt|;
comment|/* board unit number */
name|u_char
name|pnum
decl_stmt|;
comment|/* port number */
name|u_char
name|omodem
decl_stmt|;
comment|/* FEP output modem status     */
name|u_char
name|imodem
decl_stmt|;
comment|/* FEP input modem status      */
name|u_char
name|modemfake
decl_stmt|;
comment|/* Modem values to be forced   */
name|u_char
name|modem
decl_stmt|;
comment|/* Force values                */
name|u_char
name|hflow
decl_stmt|;
name|u_char
name|dsr
decl_stmt|;
name|u_char
name|dcd
decl_stmt|;
name|u_char
name|stopc
decl_stmt|;
name|u_char
name|startc
decl_stmt|;
name|u_char
name|stopca
decl_stmt|;
name|u_char
name|startca
decl_stmt|;
name|u_char
name|fepstopc
decl_stmt|;
name|u_char
name|fepstartc
decl_stmt|;
name|u_char
name|fepstopca
decl_stmt|;
name|u_char
name|fepstartca
decl_stmt|;
name|u_char
name|txwin
decl_stmt|;
name|u_char
name|rxwin
decl_stmt|;
name|ushort
name|fepiflag
decl_stmt|;
name|ushort
name|fepcflag
decl_stmt|;
name|ushort
name|fepoflag
decl_stmt|;
name|ushort
name|txbufhead
decl_stmt|;
name|ushort
name|txbufsize
decl_stmt|;
name|ushort
name|rxbufhead
decl_stmt|;
name|ushort
name|rxbufsize
decl_stmt|;
name|int
name|close_delay
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|blocked_open
decl_stmt|;
name|int
name|event
decl_stmt|;
name|int
name|asyncflags
decl_stmt|;
name|u_long
name|statusflags
decl_stmt|;
name|u_char
modifier|*
name|txptr
decl_stmt|;
name|u_char
modifier|*
name|rxptr
decl_stmt|;
name|struct
name|board_chan
modifier|*
name|brdchan
decl_stmt|;
name|struct
name|tty
modifier|*
name|tty
decl_stmt|;
name|bool_t
name|active_out
decl_stmt|;
comment|/* nonzero if the callout device is open */
name|u_int
name|wopeners
decl_stmt|;
comment|/* # processes waiting for DCD in open() */
comment|/* Initial state. */
name|struct
name|termios
name|it_in
decl_stmt|;
comment|/* should be in struct tty */
name|struct
name|termios
name|it_out
decl_stmt|;
comment|/* Lock state. */
name|struct
name|termios
name|lt_in
decl_stmt|;
comment|/* should be in struct tty */
name|struct
name|termios
name|lt_out
decl_stmt|;
comment|/* flags of state, are used in sleep() too */
name|u_char
name|closing
decl_stmt|;
comment|/* port is being closed now */
name|u_char
name|draining
decl_stmt|;
comment|/* port is being drained now */
name|u_char
name|used
decl_stmt|;
comment|/* port is being used now */
name|u_char
name|mustdrain
decl_stmt|;
comment|/* data must be waited to drain in dgbparam() */
ifdef|#
directive|ifdef
name|DEVFS
struct|struct
block|{
name|void
modifier|*
name|tty
decl_stmt|;
name|void
modifier|*
name|init
decl_stmt|;
name|void
modifier|*
name|lock
decl_stmt|;
name|void
modifier|*
name|cua
decl_stmt|;
block|}
name|devfs_token
struct|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/* Digiboard per-board structure */
end_comment

begin_struct
struct|struct
name|dgb_softc
block|{
comment|/* struct board_info */
name|u_char
name|status
decl_stmt|;
comment|/* status: DISABLED/ENABLED */
name|u_char
name|unit
decl_stmt|;
comment|/* unit number */
name|u_char
name|type
decl_stmt|;
comment|/* type of card: PCXE, PCXI, PCXEVE */
name|u_char
name|altpin
decl_stmt|;
comment|/* do we need alternate pin setting ? */
name|ushort
name|numports
decl_stmt|;
comment|/* number of ports on card */
name|ushort
name|port
decl_stmt|;
comment|/* I/O port */
name|u_char
modifier|*
name|vmem
decl_stmt|;
comment|/* virtual memory address */
name|long
name|pmem
decl_stmt|;
comment|/* physical memory address */
name|int
name|mem_seg
decl_stmt|;
comment|/* internal memory segment */
name|struct
name|dgb_p
modifier|*
name|ports
decl_stmt|;
comment|/* pointer to array of port descriptors */
name|struct
name|tty
modifier|*
name|ttys
decl_stmt|;
comment|/* pointer to array of TTY structures */
specifier|volatile
name|struct
name|global_data
modifier|*
name|mailbox
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|dgb_softc
name|dgb_softc
index|[
name|NDGB
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dgb_p
name|dgb_ports
index|[
name|NDGBPORTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|tty
name|dgb_tty
index|[
name|NDGBPORTS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The public functions in the com module ought to be declared in a com-driver  * system header.  */
end_comment

begin_comment
comment|/* Interrupt handling entry points. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|dgbintr
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dgbpoll
name|__P
argument_list|(
operator|(
name|void
operator|*
name|unit_c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Device switch entry points. */
end_comment

begin_define
define|#
directive|define
name|dgbreset
value|noreset
end_define

begin_define
define|#
directive|define
name|dgbmmap
value|nommap
end_define

begin_define
define|#
directive|define
name|dgbstrategy
value|nostrategy
end_define

begin_decl_stmt
specifier|static
name|int
name|dgbattach
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dgbprobe
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dgbregisterdev
name|__P
argument_list|(
operator|(
expr|struct
name|isa_device
operator|*
name|id
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|fepcmd
parameter_list|(
name|struct
name|dgb_p
modifier|*
name|port
parameter_list|,
name|int
name|cmd
parameter_list|,
name|int
name|op1
parameter_list|,
name|int
name|op2
parameter_list|,
name|int
name|ncmds
parameter_list|,
name|int
name|bytecmd
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|dgbstart
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dgbparam
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|,
expr|struct
name|termios
operator|*
name|t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dgbhardclose
name|__P
argument_list|(
operator|(
expr|struct
name|dgb_p
operator|*
name|port
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dgb_drain_or_flush
name|__P
argument_list|(
operator|(
expr|struct
name|dgb_p
operator|*
name|port
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dgbdrain
name|__P
argument_list|(
operator|(
expr|struct
name|dgb_p
operator|*
name|port
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dgb_pause
name|__P
argument_list|(
operator|(
name|void
operator|*
name|chan
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|wakeflush
name|__P
argument_list|(
operator|(
name|void
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|dgbdriver
init|=
block|{
name|dgbprobe
block|,
name|dgbattach
block|,
literal|"dgb"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|dgbopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|dgbclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|dgbread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|dgbwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|dgbioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_stop_t
name|dgbstop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_devtotty_t
name|dgbdevtotty
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|58
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|dgb_cdevsw
init|=
block|{
name|dgbopen
block|,
name|dgbclose
block|,
name|dgbread
block|,
name|dgbwrite
block|,
comment|/*58*/
name|dgbioctl
block|,
name|dgbstop
block|,
name|noreset
block|,
name|dgbdevtotty
block|,
comment|/* dgb */
name|ttselect
block|,
name|nommap
block|,
name|NULL
block|,
literal|"dgb"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|speed_t
name|dgbdefaultrate
init|=
name|TTYDEF_SPEED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|dgb_events
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input chars + weighted output completions */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dgbmajor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|speedtab
name|dgbspeedtab
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
comment|/* old (sysV-like) Bx codes */
literal|50
block|,
literal|1
block|,
literal|75
block|,
literal|2
block|,
literal|110
block|,
literal|3
block|,
literal|134
block|,
literal|4
block|,
literal|150
block|,
literal|5
block|,
literal|200
block|,
literal|6
block|,
literal|300
block|,
literal|7
block|,
literal|600
block|,
literal|8
block|,
literal|1200
block|,
literal|9
block|,
literal|1800
block|,
literal|10
block|,
literal|2400
block|,
literal|11
block|,
literal|4800
block|,
literal|12
block|,
literal|9600
block|,
literal|13
block|,
literal|19200
block|,
literal|14
block|,
literal|38400
block|,
literal|15
block|,
literal|57600
block|,
operator|(
literal|02000
operator||
literal|1
operator|)
block|,
comment|/* B50& fast baud table */
literal|115200
block|,
operator|(
literal|02000
operator||
literal|2
operator|)
block|,
comment|/* B100& fast baud table */
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dgbdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|dgb_debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|dgbdebug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|polltimeout
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setwin
name|__P
argument_list|(
operator|(
expr|struct
name|dgb_softc
operator|*
name|sc
operator|,
name|unsigned
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|setinitwin
name|__P
argument_list|(
operator|(
expr|struct
name|dgb_softc
operator|*
name|sc
operator|,
name|unsigned
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hidewin
name|__P
argument_list|(
operator|(
expr|struct
name|dgb_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|towin
name|__P
argument_list|(
operator|(
expr|struct
name|dgb_softc
operator|*
name|sc
operator|,
name|int
name|win
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|int
name|setwin
parameter_list|(
name|sc
parameter_list|,
name|addr
parameter_list|)
name|struct
name|dgb_softc
modifier|*
name|sc
decl_stmt|;
name|unsigned
name|int
name|addr
decl_stmt|;
block|{
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXEVE
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|1
argument_list|,
name|FEPWIN
operator||
operator|(
name|addr
operator|>>
literal|13
operator|)
argument_list|)
expr_stmt|;
name|DPRINT3
argument_list|(
literal|"dgb%d: switched to window 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|addr
operator|>>
literal|13
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|&
literal|0x1FFF
operator|)
return|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPMEM
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|setinitwin
parameter_list|(
name|sc
parameter_list|,
name|addr
parameter_list|)
name|struct
name|dgb_softc
modifier|*
name|sc
decl_stmt|;
name|unsigned
name|int
name|addr
decl_stmt|;
block|{
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXEVE
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|1
argument_list|,
name|FEPWIN
operator||
operator|(
name|addr
operator|>>
literal|13
operator|)
argument_list|)
expr_stmt|;
name|DPRINT3
argument_list|(
literal|"dgb%d: switched to window 0x%x\n"
argument_list|,
name|sc
operator|->
name|unit
argument_list|,
name|addr
operator|>>
literal|13
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|&
literal|0x1FFF
operator|)
return|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
operator||
name|FEPMEM
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|hidewin
parameter_list|(
name|sc
parameter_list|)
name|struct
name|dgb_softc
modifier|*
name|sc
decl_stmt|;
block|{
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXEVE
condition|)
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|towin
parameter_list|(
name|sc
parameter_list|,
name|win
parameter_list|)
name|struct
name|dgb_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|win
decl_stmt|;
block|{
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXEVE
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|1
argument_list|,
name|win
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPMEM
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|dgbprobe
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
name|struct
name|dgb_softc
modifier|*
name|sc
init|=
operator|&
name|dgb_softc
index|[
name|dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|v
decl_stmt|,
name|t
decl_stmt|;
name|u_long
name|win_size
decl_stmt|;
comment|/* size of vizible memory window */
name|u_char
modifier|*
name|mem
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|sc
operator|->
name|unit
operator|=
name|dev
operator|->
name|id_unit
expr_stmt|;
name|sc
operator|->
name|port
operator|=
name|dev
operator|->
name|id_iobase
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_flags
operator|&
name|DGBFLAG_ALTPIN
condition|)
name|sc
operator|->
name|altpin
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|altpin
operator|=
literal|0
expr_stmt|;
comment|/* left 24 bits only (ISA address) */
name|sc
operator|->
name|pmem
operator|=
operator|(
operator|(
name|long
operator|)
name|dev
operator|->
name|id_maddr
operator|&
literal|0xFFFFFF
operator|)
expr_stmt|;
name|DPRINT4
argument_list|(
literal|"dgb%d: port 0x%x mem 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|port
argument_list|,
name|sc
operator|->
name|pmem
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPRST
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
name|i
operator|++
control|)
block|{
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
operator|&
name|FEPMASK
operator|)
operator|==
name|FEPRST
condition|)
block|{
name|sc
operator|->
name|status
operator|=
name|ENABLED
expr_stmt|;
name|DPRINT3
argument_list|(
literal|"dgb%d: got reset after %d us\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|status
operator|!=
name|ENABLED
condition|)
block|{
name|DPRINT2
argument_list|(
literal|"dgb%d: failed to respond\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* check type of card and get internal memory characteristics */
name|v
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
literal|0x1
condition|)
block|{
switch|switch
condition|(
name|v
operator|&
literal|0x30
condition|)
block|{
case|case
literal|0
case|:
name|sc
operator|->
name|mem_seg
operator|=
literal|0xF000
expr_stmt|;
name|win_size
operator|=
literal|0x10000
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: PC/Xi 64K\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x10
case|:
name|sc
operator|->
name|mem_seg
operator|=
literal|0xE000
expr_stmt|;
name|win_size
operator|=
literal|0x20000
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: PC/Xi 128K\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x20
case|:
name|sc
operator|->
name|mem_seg
operator|=
literal|0xC000
expr_stmt|;
name|win_size
operator|=
literal|0x40000
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: PC/Xi 256K\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* case 0x30: */
name|sc
operator|->
name|mem_seg
operator|=
literal|0x8000
expr_stmt|;
name|win_size
operator|=
literal|0x80000
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: PC/Xi 512K\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|type
operator|=
name|PCXI
expr_stmt|;
block|}
else|else
block|{
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|v
operator|=
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|&
literal|0x1
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: PC/Xm isn't supported\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sc
operator|->
name|mem_seg
operator|=
literal|0xF000
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|id_flags
operator|==
name|DGBFLAG_NOWIN
operator|||
operator|(
name|v
operator|&
literal|0xC0
operator|)
operator|==
literal|0
condition|)
block|{
name|win_size
operator|=
literal|0x10000
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: PC/Xe 64K\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|type
operator|=
name|PCXE
expr_stmt|;
block|}
else|else
block|{
name|win_size
operator|=
literal|0x2000
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: PC/Xe 64/8K (windowed)\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|type
operator|=
name|PCXEVE
expr_stmt|;
if|if
condition|(
operator|(
name|u_long
operator|)
name|sc
operator|->
name|pmem
operator|&
operator|~
literal|0xFFE000
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: warning: address 0x%x truncated to 0x%x\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
name|sc
operator|->
name|pmem
argument_list|,
operator|(
name|long
operator|)
name|sc
operator|->
name|pmem
operator|&
literal|0xFFE000
argument_list|)
expr_stmt|;
name|dev
operator|->
name|id_maddr
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|(
name|long
operator|)
name|sc
operator|->
name|pmem
operator|&
literal|0xFFE000
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* save size of vizible memory segment */
name|dev
operator|->
name|id_msize
operator|=
name|win_size
expr_stmt|;
comment|/* map memory */
name|dev
operator|->
name|id_maddr
operator|=
name|sc
operator|->
name|vmem
operator|=
name|pmap_mapdev
argument_list|(
name|sc
operator|->
name|pmem
argument_list|,
name|dev
operator|->
name|id_msize
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPCLR
argument_list|)
expr_stmt|;
comment|/* drop RESET */
return|return
literal|4
return|;
comment|/* we need I/O space of 4 ports */
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|kern_devconf
name|kdc_dgb
index|[
name|NDGB
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kern_devconf
name|kdc_dgb_init
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* filled in by dev_attach */
literal|"dgb"
block|,
literal|0
block|,
block|{
name|MDDT_ISA
block|,
literal|0
block|,
literal|"tty"
block|}
block|,
name|isa_generic_externalize
block|,
literal|0
block|,
literal|0
block|,
name|ISA_EXTERNALLEN
block|,
operator|&
name|kdc_isa0
block|,
comment|/* parent */
literal|0
block|,
comment|/* parentdata */
name|DC_UNCONFIGURED
block|,
literal|"DigiBoard multiport card"
block|,
name|DC_CLS_SERIAL
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dgbregisterdev
parameter_list|(
name|id
parameter_list|)
name|struct
name|isa_device
modifier|*
name|id
decl_stmt|;
block|{
name|int
name|unit
decl_stmt|;
name|unit
operator|=
name|id
operator|->
name|id_unit
expr_stmt|;
name|kdc_dgb
index|[
name|unit
index|]
operator|=
name|kdc_dgb_init
expr_stmt|;
name|kdc_dgb
index|[
name|unit
index|]
operator|.
name|kdc_unit
operator|=
name|unit
expr_stmt|;
name|kdc_dgb
index|[
name|unit
index|]
operator|.
name|kdc_isa
operator|=
name|id
expr_stmt|;
comment|/* no ports are open yet */
name|kdc_dgb
index|[
name|unit
index|]
operator|.
name|kdc_state
operator|=
name|DC_IDLE
expr_stmt|;
name|dev_attach
argument_list|(
operator|&
name|kdc_dgb
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dgbattach
parameter_list|(
name|dev
parameter_list|)
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
block|{
name|int
name|unit
init|=
name|dev
operator|->
name|id_unit
decl_stmt|;
name|struct
name|dgb_softc
modifier|*
name|sc
init|=
operator|&
name|dgb_softc
index|[
name|dev
operator|->
name|id_unit
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|t
decl_stmt|;
name|u_char
modifier|*
name|mem
decl_stmt|;
name|u_char
modifier|*
name|ptr
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|struct
name|dgb_p
modifier|*
name|port
decl_stmt|;
name|struct
name|board_chan
modifier|*
name|bc
decl_stmt|;
name|struct
name|global_data
modifier|*
name|gd
decl_stmt|;
name|int
name|shrinkmem
decl_stmt|;
name|int
name|nfails
decl_stmt|;
name|ushort
modifier|*
name|pstat
decl_stmt|;
name|int
name|lowwater
decl_stmt|;
name|int
name|nports
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|status
operator|!=
name|ENABLED
condition|)
block|{
name|DPRINT2
argument_list|(
literal|"dbg%d: try to attach a disabled card\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mem
operator|=
name|sc
operator|->
name|vmem
expr_stmt|;
name|DPRINT3
argument_list|(
literal|"dgb%d: internal memory segment 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|mem_seg
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPRST
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
operator|&
name|FEPMASK
operator|)
operator|!=
name|FEPRST
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|10000
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: 1st reset failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DPRINT3
argument_list|(
literal|"dgb%d: got reset after %d us\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* for PCXEVE set up interrupt and base address */
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXEVE
condition|)
block|{
name|t
operator|=
operator|(
operator|(
operator|(
name|u_long
operator|)
name|sc
operator|->
name|pmem
operator|>>
literal|8
operator|)
operator|&
literal|0xFFE0
operator|)
operator||
literal|0x10
comment|/* enable windowing */
expr_stmt|;
comment|/* IRQ isn't used */
if|#
directive|if
literal|0
block|switch(dev->id_irq) { 		case IRQ3: 			t|=0x1; 			break; 		case IRQ5: 			t|=2; 			break; 		case IRQ7: 			t|=3; 			break; 		case IRQ10: 			t|=4; 			break; 		case IRQ11: 			t|=5; 			break; 		case IRQ12: 			t|=6; 			break; 		case IRQ15: 			t|=7; 			break; 		default: 			printf("dgb%d: wrong IRQ mask 0x%x\n",dev->id_unit,dev->id_irq); 			sc->status=DISABLED; 			return 0; 		}
endif|#
directive|endif
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|2
argument_list|,
name|t
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|3
argument_list|,
name|t
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXE
condition|)
block|{
name|t
operator|=
operator|(
operator|(
operator|(
name|u_long
operator|)
name|sc
operator|->
name|pmem
operator|>>
literal|8
operator|)
operator|&
literal|0xFFE0
operator|)
comment|/* disable windowing */
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|2
argument_list|,
name|t
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|3
argument_list|,
name|t
operator|>>
literal|8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXI
operator|||
name|sc
operator|->
name|type
operator|==
name|PCXE
condition|)
block|{
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPRST
operator||
name|FEPMEM
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
operator|&
name|FEPMASK
operator|)
operator|!=
operator|(
name|FEPRST
operator||
name|FEPMEM
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|10000
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: 2nd reset failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DPRINT3
argument_list|(
literal|"dgb%d: got memory after %d us\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|mem
operator|=
name|sc
operator|->
name|vmem
expr_stmt|;
comment|/* very short memory test */
name|addr
operator|=
name|setinitwin
argument_list|(
name|sc
argument_list|,
name|BOTWIN
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|=
literal|0xA55A3CC3
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|!=
literal|0xA55A3CC3
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: 1st memory test failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|addr
operator|=
name|setinitwin
argument_list|(
name|sc
argument_list|,
name|TOPWIN
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|=
literal|0x5AA5C33C
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|!=
literal|0x5AA5C33C
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: 2nd memory test failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|addr
operator|=
name|setinitwin
argument_list|(
name|sc
argument_list|,
name|BIOSCODE
operator|+
operator|(
operator|(
literal|0xF000
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|<<
literal|4
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|=
literal|0x5AA5C33C
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|!=
literal|0x5AA5C33C
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: 3rd (BIOS) memory test failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|setinitwin
argument_list|(
name|sc
argument_list|,
name|MISCGLOBAL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|mem
index|[
name|addr
operator|+
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXI
operator|||
name|sc
operator|->
name|type
operator|==
name|PCXE
condition|)
block|{
name|addr
operator|=
name|BIOSCODE
operator|+
operator|(
operator|(
literal|0xF000
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|DPRINT3
argument_list|(
literal|"dgb%d: BIOS local address=0x%x\n"
argument_list|,
name|unit
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|mem
operator|+
name|addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcxx_nbios
condition|;
name|i
operator|++
operator|,
name|ptr
operator|++
control|)
operator|*
name|ptr
operator|=
name|pcxx_bios
index|[
name|i
index|]
expr_stmt|;
name|ptr
operator|=
name|mem
operator|+
name|addr
expr_stmt|;
name|nfails
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcxx_nbios
condition|;
name|i
operator|++
operator|,
name|ptr
operator|++
control|)
if|if
condition|(
operator|*
name|ptr
operator|!=
name|pcxx_bios
index|[
name|i
index|]
condition|)
block|{
name|DPRINT5
argument_list|(
literal|"dgb%d: wrong code in BIOS at addr 0x%x : \ 0x%x instead of 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|ptr
operator|-
operator|(
name|mem
operator|+
name|addr
operator|)
argument_list|,
operator|*
name|ptr
argument_list|,
name|pcxx_bios
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|nfails
operator|>=
literal|5
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: 4th memory test (BIOS load) fails\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPMEM
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
operator|&
name|FEPMASK
operator|)
operator|!=
name|FEPMEM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|10000
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: BIOS start failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DPRINT3
argument_list|(
literal|"dgb%d: reset dropped after %d us\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|200000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|MISCGLOBAL
operator|)
operator|)
operator|==
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
literal|"GD"
operator|)
condition|)
goto|goto
name|load_fep
goto|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"dgb%d: BIOS download failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|DPRINT4
argument_list|(
literal|"dgb%d: code=0x%x must be 0x%x\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|MISCGLOBAL
operator|)
operator|)
argument_list|,
operator|*
operator|(
operator|(
name|ushort
operator|*
operator|)
literal|"GD"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|type
operator|==
name|PCXEVE
condition|)
block|{
comment|/* set window 7 */
name|outb
argument_list|(
name|sc
operator|->
name|port
operator|+
literal|1
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|mem
operator|+
operator|(
name|BIOSCODE
operator|&
literal|0x1FFF
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcxx_nbios
condition|;
name|i
operator|++
control|)
operator|*
name|ptr
operator|++
operator|=
name|pcxx_bios
index|[
name|i
index|]
expr_stmt|;
name|ptr
operator|=
name|mem
operator|+
operator|(
name|BIOSCODE
operator|&
literal|0x1FFF
operator|)
expr_stmt|;
name|nfails
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcxx_nbios
condition|;
name|i
operator|++
operator|,
name|ptr
operator|++
control|)
if|if
condition|(
operator|*
name|ptr
operator|!=
name|pcxx_bios
index|[
name|i
index|]
condition|)
block|{
name|DPRINT5
argument_list|(
literal|"dgb%d: wrong code in BIOS at addr 0x%x : \ 0x%x instead of 0x%x\n"
argument_list|,
name|unit
argument_list|,
name|ptr
operator|-
operator|(
name|mem
operator|+
name|addr
operator|)
argument_list|,
operator|*
name|ptr
argument_list|,
name|pcxx_bios
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|nfails
operator|>=
literal|5
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: 4th memory test (BIOS load) fails\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPCLR
argument_list|)
expr_stmt|;
name|setwin
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|inb
argument_list|(
name|sc
operator|->
name|port
argument_list|)
operator|&
name|FEPMASK
operator|)
operator|!=
name|FEPCLR
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|10000
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: BIOS start failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|DPRINT3
argument_list|(
literal|"dgb%d: reset dropped after %d us\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|MISCGLOBAL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|200000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|==
operator|*
operator|(
name|ushort
operator|*
operator|)
literal|"GD"
condition|)
goto|goto
name|load_fep
goto|;
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"dgb%d: BIOS download failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|DPRINT5
argument_list|(
literal|"dgb%d: Error#(0x%x,0x%x) code=0x%x\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|,
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
literal|0xC12
operator|)
argument_list|,
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
literal|0xC14
operator|)
argument_list|,
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|MISCGLOBAL
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|load_fep
label|:
name|DPRINT2
argument_list|(
literal|"dgb%d: BIOS loaded\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|FEPCODE
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|mem
operator|+
name|addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcxx_ncook
condition|;
name|i
operator|++
control|)
operator|*
name|ptr
operator|++
operator|=
name|pcxx_cook
index|[
name|i
index|]
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|MBOX
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|0
operator|)
operator|=
literal|2
expr_stmt|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|2
operator|)
operator|=
name|sc
operator|->
name|mem_seg
operator|+
name|FEPCODESEG
expr_stmt|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|4
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|6
operator|)
operator|=
name|FEPCODESEG
expr_stmt|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|8
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|10
operator|)
operator|=
name|pcxx_ncook
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPMEM
operator||
name|FEPINT
argument_list|)
expr_stmt|;
comment|/* send interrupt to BIOS */
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPMEM
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|200000
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: FEP code download failed\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|DPRINT3
argument_list|(
literal|"dgb%d: code=0x%x must be 0\n"
argument_list|,
name|unit
argument_list|,
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|DPRINT2
argument_list|(
literal|"dgb%d: FEP code loaded\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|setwin
argument_list|(
name|sc
argument_list|,
name|FEPSTAT
argument_list|)
operator|)
operator|=
literal|0
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|MBOX
argument_list|)
expr_stmt|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|0
operator|)
operator|=
literal|1
expr_stmt|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|2
operator|)
operator|=
name|FEPCODESEG
expr_stmt|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|+
literal|4
operator|)
operator|=
literal|0x4
expr_stmt|;
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPINT
argument_list|)
expr_stmt|;
comment|/* send interrupt to BIOS */
name|outb
argument_list|(
name|sc
operator|->
name|port
argument_list|,
name|FEPCLR
argument_list|)
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|FEPSTAT
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
operator|!=
operator|*
operator|(
name|ushort
operator|*
operator|)
literal|"OS"
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|200000
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: FEP/OS start failed\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|DPRINT2
argument_list|(
literal|"dgb%d: FEP/OS started\n"
argument_list|,
name|dev
operator|->
name|id_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|numports
operator|=
operator|*
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|setwin
argument_list|(
name|sc
argument_list|,
name|NPORT
argument_list|)
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: %d ports\n"
argument_list|,
name|unit
argument_list|,
name|sc
operator|->
name|numports
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|numports
operator|>
name|MAX_DGB_PORTS
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: too many ports\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|status
operator|=
name|DISABLED
expr_stmt|;
name|hidewin
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|nports
operator|+
name|sc
operator|->
name|numports
operator|>
name|NDGBPORTS
condition|)
block|{
name|printf
argument_list|(
literal|"dgb%d: only %d ports are usable\n"
argument_list|,
name|unit
argument_list|,
name|NDGBPORTS
operator|-
name|nports
argument_list|)
expr_stmt|;
name|sc
operator|->
name|numports
operator|=
name|NDGBPORTS
operator|-
name|nports
expr_stmt|;
block|}
comment|/* allocate port and tty structures */
name|sc
operator|->
name|ports
operator|=
operator|&
name|dgb_ports
index|[
name|nports
index|]
expr_stmt|;
name|sc
operator|->
name|ttys
operator|=
operator|&
name|dgb_tty
index|[
name|nports
index|]
expr_stmt|;
name|nports
operator|+=
name|sc
operator|->
name|numports
expr_stmt|;
name|addr
operator|=
name|setwin
argument_list|(
name|sc
argument_list|,
name|PORTBASE
argument_list|)
expr_stmt|;
name|pstat
operator|=
operator|(
name|ushort
operator|*
operator|)
operator|(
name|mem
operator|+
name|addr
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|numports
operator|&&
name|pstat
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pstat
index|[
name|i
index|]
condition|)
name|sc
operator|->
name|ports
index|[
name|i
index|]
operator|.
name|status
operator|=
name|ENABLED
expr_stmt|;
else|else
block|{
name|sc
operator|->
name|ports
index|[
name|i
index|]
operator|.
name|status
operator|=
name|DISABLED
expr_stmt|;
name|printf
argument_list|(
literal|"dgb%d: port %d is broken\n"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* We should now init per-port structures */
name|bc
operator|=
operator|(
expr|struct
name|board_chan
operator|*
operator|)
operator|(
name|mem
operator|+
name|CHANSTRUCT
operator|)
expr_stmt|;
name|sc
operator|->
name|mailbox
operator|=
operator|(
expr|struct
name|global_data
operator|*
operator|)
operator|(
name|mem
operator|+
name|FEP_GLOBAL
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|numports
operator|<
literal|3
condition|)
name|shrinkmem
operator|=
literal|1
expr_stmt|;
else|else
name|shrinkmem
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|numports
condition|;
name|i
operator|++
operator|,
name|bc
operator|++
control|)
block|{
name|port
operator|=
operator|&
name|sc
operator|->
name|ports
index|[
name|i
index|]
expr_stmt|;
name|port
operator|->
name|tty
operator|=
operator|&
name|sc
operator|->
name|ttys
index|[
name|i
index|]
expr_stmt|;
name|port
operator|->
name|unit
operator|=
name|unit
expr_stmt|;
name|port
operator|->
name|brdchan
operator|=
name|bc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|altpin
condition|)
block|{
name|port
operator|->
name|dsr
operator|=
name|CD
expr_stmt|;
name|port
operator|->
name|dcd
operator|=
name|DSR
expr_stmt|;
block|}
else|else
block|{
name|port
operator|->
name|dcd
operator|=
name|CD
expr_stmt|;
name|port
operator|->
name|dsr
operator|=
name|DSR
expr_stmt|;
block|}
name|port
operator|->
name|pnum
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|shrinkmem
condition|)
block|{
name|DPRINT2
argument_list|(
literal|"dgb%d: shrinking memory\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SETBUFFER
argument_list|,
literal|32
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|shrinkmem
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|type
operator|!=
name|PCXEVE
condition|)
block|{
name|port
operator|->
name|txptr
operator|=
name|mem
operator|+
operator|(
operator|(
name|bc
operator|->
name|tseg
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|port
operator|->
name|rxptr
operator|=
name|mem
operator|+
operator|(
operator|(
name|bc
operator|->
name|rseg
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
name|port
operator|->
name|txwin
operator|=
name|port
operator|->
name|rxwin
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|port
operator|->
name|txptr
operator|=
name|mem
operator|+
operator|(
operator|(
operator|(
name|bc
operator|->
name|tseg
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|<<
literal|4
operator|)
operator|&
literal|0x1FFF
operator|)
expr_stmt|;
name|port
operator|->
name|rxptr
operator|=
name|mem
operator|+
operator|(
operator|(
operator|(
name|bc
operator|->
name|rseg
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|<<
literal|4
operator|)
operator|&
literal|0x1FFF
operator|)
expr_stmt|;
name|port
operator|->
name|txwin
operator|=
name|FEPWIN
operator||
operator|(
operator|(
name|bc
operator|->
name|tseg
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|>>
literal|9
operator|)
expr_stmt|;
name|port
operator|->
name|rxwin
operator|=
name|FEPWIN
operator||
operator|(
operator|(
name|bc
operator|->
name|rseg
operator|-
name|sc
operator|->
name|mem_seg
operator|)
operator|>>
literal|9
operator|)
expr_stmt|;
block|}
name|port
operator|->
name|txbufhead
operator|=
literal|0
expr_stmt|;
name|port
operator|->
name|rxbufhead
operator|=
literal|0
expr_stmt|;
name|port
operator|->
name|txbufsize
operator|=
name|bc
operator|->
name|tmax
operator|+
literal|1
expr_stmt|;
name|port
operator|->
name|rxbufsize
operator|=
name|bc
operator|->
name|rmax
operator|+
literal|1
expr_stmt|;
name|lowwater
operator|=
operator|(
name|port
operator|->
name|txbufsize
operator|>=
literal|2000
operator|)
condition|?
literal|1024
else|:
operator|(
name|port
operator|->
name|txbufsize
operator|/
literal|2
operator|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|STXLWATER
argument_list|,
name|lowwater
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SRXLWATER
argument_list|,
name|port
operator|->
name|rxbufsize
operator|/
literal|4
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fepcmd
argument_list|(
name|port
argument_list|,
name|SRXHWATER
argument_list|,
literal|3
operator|*
name|port
operator|->
name|rxbufsize
operator|/
literal|4
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bc
operator|->
name|edelay
operator|=
literal|100
expr_stmt|;
name|bc
operator|->
name|idata
operator|=
literal|1
expr_stmt|;
name|port
operator|->
name|startc
operator|=
name|bc
operator|->
name|startc
expr_stmt|;
name|port
operator|->
name|startca
operator|=
name|bc
operator|->
name|startca
expr_stmt|;
name|port
operator|->
name|stopc
operator|=
name|bc
operator|->
name|stopc
expr_stmt|;
name|port
operator|->
name|stopca
operator|=
name|bc
operator|->
name|stopca
expr_stmt|;
name|port
operator|->
name|close_delay
operator|=
literal|50
expr_stmt|;
comment|/* 		 * We don't use all the flags from<sys/ttydefaults.h> since they 		 * are only relevant for logins.  It's important to have echo off 		 * initially so that the line doesn't start blathering before the 		 * echo flag can be turned off. 		 */
name|port
operator|->
name|it_in
operator|.
name|c_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|port
operator|->
name|it_in
operator|.
name|c_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|port
operator|->
name|it_in
operator|.
name|c_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|port
operator|->
name|it_in
operator|.
name|c_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|termioschars
argument_list|(
operator|&
name|port
operator|->
name|it_in
argument_list|)
expr_stmt|;
name|port
operator|->
name|it_in
operator|.
name|c_ispeed
operator|=
name|port
operator|->
name|it_in
operator|.
name|c_ospeed
operator|=
name|dgbdefaultrate
expr_stmt|;
name|port
operator|->
name|it_out
operator|=
name|port
operator|->
name|it_in
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
comment|/*XXX*/
comment|/* fix the minor numbers */
name|port
operator|->
name|devfs_token
operator|.
name|tty
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|dgb_cdevsw
argument_list|,
operator|(
name|unit
operator|*
literal|32
operator|)
operator|+
name|i
argument_list|,
comment|/*mytical number*/
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|,
literal|"dgb%d.%d"
argument_list|,
name|unit
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|port
operator|->
name|devfs_token
operator|.
name|tty
operator|=
name|devfs_add_devswf
argument_list|(
argument|&dgb_cdevsw
argument_list|,
argument|(unit*
literal|32
argument|)+i+
literal|64
argument_list|,
comment|/*mytical number*/
argument|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|,
argument|idgb%d.%d
literal|", unit,  					 i);  		port->devfs_token.tty =  			devfs_add_devswf(&dgb_cdevsw, 					 (unit*32)+i+128,/*mytical number*/ 					 DV_CHR, 0, 0, 0600, "
argument|ldgb%d.%d
literal|", unit, 					 i);  		port->devfs_token.tty =  			devfs_add_devswf(&dgb_cdevsw, 					 (unit*32)+i+192,/*mytical number*/ 					 DV_CHR, 0, 0, 0600, "
argument|dgbcua%d.%d
literal|", 					 unit, i); #endif 	}  	hidewin(sc);  	dgbregisterdev(dev);  	/* register the polling function */ 	timeout(dgbpoll, (void *)unit, hz/25);  	return 1; }  /* ARGSUSED */ static	int dgbopen(dev, flag, mode, p) 	dev_t		dev; 	int		flag; 	int		mode; 	struct proc	*p; { 	struct dgb_softc *sc; 	struct tty *tp; 	int unit; 	int mynor; 	int pnum; 	struct dgb_p *port; 	int s; 	int error; 	struct board_chan *bc;  	error=0;  	mynor=minor(dev); 	unit=MINOR_TO_UNIT(mynor); 	pnum=MINOR_TO_PORT(mynor);  	if(unit>= NDGB) { 		DPRINT2("
argument|dgb%d: try to open a nonexisting card\n
literal|",unit); 		return ENXIO; 	}  	sc=&dgb_softc[unit];  	if(sc->status!=ENABLED) { 		DPRINT2("
argument|dgb%d: try to open a disabled card\n
literal|",unit); 		return ENXIO; 	}  	if(pnum>=sc->numports) { 		DPRINT3("
argument|dgb%d: try to open non-existing port %d\n
literal|",unit,pnum); 		return ENXIO; 	}  	if(mynor& CONTROL_MASK) 		return 0;  	tp=&sc->ttys[pnum]; 	port=&sc->ports[pnum]; 	bc=port->brdchan;  open_top: 	 	s=spltty();  	while(port->closing) { 		error=tsleep(&port->closing, TTOPRI|PCATCH, "
argument|dgocl
literal|", 0);  		if(error) { 			DPRINT4("
argument|dgb%d: port %d: tsleep(dgocl) error=%d\n
literal|",unit,pnum,error); 			goto out; 		} 	}  	if (tp->t_state& TS_ISOPEN) { 		/* 		 * The device is open, so everything has been initialized. 		 * Handle conflicts. 		 */ 		if (mynor& CALLOUT_MASK) { 			if (!port->active_out) { 				error = EBUSY; 				DPRINT4("
argument|dgb%d: port %d: BUSY error=%d\n
literal|",unit,pnum,error); 				goto out; 			} 		} else { 			if (port->active_out) { 				if (flag& O_NONBLOCK) { 					error = EBUSY; 					DPRINT4("
argument|dgb%d: port %d: BUSY error=%d\n
literal|",unit,pnum,error); 					goto out; 				} 				error =	tsleep(&port->active_out, 					       TTIPRI | PCATCH, "
argument|dgbi
literal|", 0); 				if (error != 0) { 					DPRINT4("
argument|dgb%d: port %d: tsleep(dgbi) error=%d\n
literal|", 						unit,pnum,error); 					goto out; 				} 				splx(s); 				goto open_top; 			} 		} 		if (tp->t_state& TS_XCLUDE&& p->p_ucred->cr_uid != 0) { 			error = EBUSY; 			goto out; 		} 	} else { 		/* 		 * The device isn't open, so there are no conflicts. 		 * Initialize it.  Initialization is done twice in many 		 * cases: to preempt sleeping callin opens if we are 		 * callout, and to complete a callin open after DCD rises. 		 */ 		tp->t_oproc=dgbstart; 		tp->t_param=dgbparam; 		tp->t_dev=dev; 		tp->t_termios= (mynor& CALLOUT_MASK) ? 							port->it_out : 							port->it_in;  		setwin(sc,0); 		port->imodem=bc->mstat; 		bc->rout=bc->rin; /* clear input queue */ 		bc->idata=1;  		hidewin(sc);  		port->wopeners++; 		error=dgbparam(tp,&tp->t_termios); 		port->wopeners--;  		if(error!=0) { 			DPRINT4("
argument|dgb%d: port %d: dgbparam error=%d\n
literal|",unit,pnum,error); 			goto out; 		}  		ttsetwater(tp);  		/* handle fake DCD for callout devices */ 		/* and initial DCD */  		if( (port->imodem& port->dcd) || mynor& CALLOUT_MASK ) 			linesw[tp->t_line].l_modem(tp,1);  	}  	/* 	 * Wait for DCD if necessary. 	 */ 	if (!(tp->t_state& TS_CARR_ON)&& !(mynor& CALLOUT_MASK)&& !(tp->t_cflag& CLOCAL)&& !(flag& O_NONBLOCK)) { 		++port->wopeners; 		error = tsleep(TSA_CARR_ON(tp), TTIPRI | PCATCH, "
argument|dgdcd
literal|", 0); 		--port->wopeners; 		if (error != 0) { 			DPRINT4("
argument|dgb%d: port %d: tsleep(dgdcd) error=%d\n
literal|",unit,pnum,error); 			goto out; 		} 		splx(s); 		goto open_top; 	} 	error =	linesw[tp->t_line].l_open(dev, tp); 	DPRINT4("
argument|dgb%d: port %d: l_open error=%d\n
literal|",unit,pnum,error);  	if (tp->t_state& TS_ISOPEN&& mynor& CALLOUT_MASK) 		port->active_out = TRUE;  	port->used=1;  	/* If any port is open (i.e. the open() call is completed for it)  	 * the device is busy 	 */  	kdc_dgb[unit].kdc_state = DC_BUSY; 	 out: 	splx(s);  	if( !(tp->t_state& TS_ISOPEN)&& port->wopeners==0 ) 		dgbhardclose(port);  	DPRINT4("
argument|dgb%d: port %d: open() returns %d\n
literal|",unit,pnum,error);  	return error; }  /*ARGSUSED*/ static	int dgbclose(dev, flag, mode, p) 	dev_t		dev; 	int		flag; 	int		mode; 	struct proc	*p; { 	int		mynor; 	struct tty	*tp; 	int unit, pnum; 	struct dgb_softc *sc; 	struct dgb_p *port; 	int s; 	int i;  	mynor=minor(dev); 	unit=MINOR_TO_UNIT(mynor); 	pnum=MINOR_TO_PORT(mynor);  	sc=&dgb_softc[unit]; 	tp=&sc->ttys[pnum]; 	port=sc->ports+pnum;  	if(mynor& CONTROL_MASK) 		return 0;  	DPRINT3("
argument|dgb%d: port %d: closing\n
literal|",unit,pnum);  	s=spltty();  	port->closing=1; 	linesw[tp->t_line].l_close(tp,flag); 	dgb_drain_or_flush(port); 	dgbhardclose(port); 	ttyclose(tp); 	port->closing=0; wakeup(&port->closing); 	port->used=0;  	/* mark the card idle when all ports are closed */  	for(i=0; i<sc->numports; i++) 		if(sc->ports[i].used) 			break;  	if(i>= sc->numports) 		kdc_dgb[unit].kdc_state = DC_IDLE;  	splx(s);  	wakeup(TSA_CARR_ON(tp)); 	wakeup(&port->active_out); 	port->active_out=0;  	return 0; }  static void dgbhardclose(port) 	struct dgb_p *port; { 	struct dgb_softc *sc=&dgb_softc[port->unit]; 	struct board_chan *bc=port->brdchan; 	int s;  	setwin(sc,0);  	bc->idata=0; bc->iempty=0; bc->ilow=0; 	if(port->tty->t_cflag& HUPCL) { 		port->omodem&= ~(RTS|DTR); 		fepcmd(port, SETMODEM, 0, DTR|RTS, 0, 1); 	}  	hidewin(sc);  	timeout(dgb_pause,&port->brdchan, hz/2); 	tsleep(&port->brdchan, TTIPRI | PCATCH, "
argument|dgclo
literal|", 0); }  static void  dgb_pause(chan) 	void *chan; { wakeup((caddr_t)chan); }   static	int dgbread(dev, uio, flag) 	dev_t		dev; 	struct uio	*uio; 	int		flag; { 	int		mynor; 	struct tty	*tp; 	int error, unit, pnum;  	mynor=minor(dev); 	if (mynor& CONTROL_MASK) 		return (ENODEV); 	unit=MINOR_TO_UNIT(mynor); 	pnum=MINOR_TO_PORT(mynor);  	tp=&dgb_softc[unit].ttys[pnum];  	error=linesw[tp->t_line].l_read(tp, uio, flag); 	DPRINT4("
argument|dgb%d: port %d: read() returns %d\n
literal|",unit,pnum,error);  	return error; }  static	int dgbwrite(dev, uio, flag) 	dev_t		dev; 	struct uio	*uio; 	int		flag; { 	int		mynor; 	struct tty	*tp; 	int error, unit, pnum;  	mynor=minor(dev); 	if (mynor& CONTROL_MASK) 		return (ENODEV);  	unit=MINOR_TO_UNIT(mynor); 	pnum=MINOR_TO_PORT(mynor);  	tp=&dgb_softc[unit].ttys[pnum];  	error=linesw[tp->t_line].l_write(tp, uio, flag); 	DPRINT4("
argument|dgb%d: port %d: write() returns %d\n
literal|",unit,pnum,error);  	return error; }  static void dgbpoll(unit_c) 	void *unit_c; { 	int unit=(int)unit_c; 	int pnum; 	struct dgb_p *port; 	struct dgb_softc *sc=&dgb_softc[unit]; 	int head, tail; 	u_char *eventbuf; 	int event, mstat, lstat; 	struct board_chan *bc; 	struct tty *tp; 	int rhead, rtail; 	int whead, wtail; 	int wrapmask; 	int size; 	int c=0; 	u_char *ptr; 	int ocount;  	if(sc->status==DISABLED) { 		printf("
argument|dgb%d: polling of disabled board stopped\n
literal|",unit); 		return; 	} 	 	setwin(sc,0);  	head=sc->mailbox->ein; 	tail=sc->mailbox->eout;  	while(head!=tail) { 		if(head>= FEP_IMAX-FEP_ISTART  		|| tail>= FEP_IMAX-FEP_ISTART  		|| (head|tail)& 03 ) { 			printf("
argument|dgb%d: event queue
literal|'s head or tail is wrong!\n", unit); 			break; 		}  		eventbuf=sc->vmem+tail+FEP_ISTART; 		pnum=eventbuf[0]; 		event=eventbuf[1]; 		mstat=eventbuf[2]; 		lstat=eventbuf[3];  		port=&sc->ports[pnum]; 		tp=&sc->ttys[pnum];  		if(pnum>=sc->numports || port->status==DISABLED) { 			printf("dgb%d: port %d: got event on nonexisting port\n",unit,pnum); 		} else if(port->used || port->wopeners>0 ) {  			bc=port->brdchan;  			if( !(event& ALL_IND) )  				printf("dgb%d: port%d: ? event 0x%x mstat 0x%x lstat 0x%x\n", 					unit, pnum, event, mstat, lstat);  			if(event& DATA_IND) { 				DPRINT3("dgb%d: port %d: DATA_IND\n",unit,pnum);  				wrapmask=port->rxbufsize-1;  				rhead=bc->rin& wrapmask;  				rtail=bc->rout& wrapmask;  				if( !(tp->t_cflag& CREAD) || !port->used ) { 					bc->rout=rhead; 					goto end_of_data; 				}  				if(bc->orun) { 					printf("dgb%d: port%d: overrun\n", unit, pnum); 					bc->orun=0; 				}  				while(rhead!=rtail) { 					DPRINT5("dgb%d: port %d: p rx head=%d tail=%d\n", 						unit,pnum,rhead,rtail);  					if(rhead>rtail) 						size=rhead-rtail; 					else 						size=port->rxbufsize-rtail;  					ptr=port->rxptr+rtail;  					for(c=0; c<size; c++) { 						int chr;  						towin(sc,port->rxwin); 						chr= *ptr++;  #if 0 						if(chr>='
literal|'&& chr<127) 							DPRINT4("dgb%d: port %d: got char '
argument|%c
literal|'\n", 								unit,pnum,chr); 						else 							DPRINT4("dgb%d: port %d: got char 0x%x\n", 								unit,pnum,chr); #endif  						hidewin(sc); 						linesw[tp->t_line].l_rint(chr, tp); 					}  					setwin(sc,0); 					rtail= (rtail + size)& wrapmask; 					bc->rout=rtail; 					rhead=bc->rin& wrapmask;  				} 					 			end_of_data: 			}  			if(event& MODEMCHG_IND) { 				DPRINT3("dgb%d: port %d: MODEMCHG_IND\n",unit,pnum); 				port->imodem=mstat; 				if(mstat& port->dcd) { 					hidewin(sc); 					linesw[tp->t_line].l_modem(tp,1); 					setwin(sc,0); 					wakeup(TSA_CARR_ON(tp)); 				} else { 					hidewin(sc); 					linesw[tp->t_line].l_modem(tp,0); 					setwin(sc,0); 					if( port->draining) { 						port->draining=0; 						wakeup(&port->draining); 					} 				} 			}  			if(event& BREAK_IND) { 				DPRINT3("dgb%d: port %d: BREAK_IND\n",unit,pnum); 				hidewin(sc); 				linesw[tp->t_line].l_rint(TTY_BI, tp); 				setwin(sc,0); 			}  			if(event& (LOWTX_IND | EMPTYTX_IND) ) { 				DPRINT3("dgb%d: port %d: LOWTX_IND or EMPTYTX_IND\n",unit,pnum);  				if( (event& EMPTYTX_IND )&& tp->t_outq.c_cc==0&& port->draining) { 					port->draining=0; 					wakeup(&port->draining); 					bc->ilow=0; bc->iempty=0; 				}  				wrapmask=port->txbufsize;  				while( tp->t_outq.c_cc!=0 ) { #ifndef TS_ASLEEP	/* post 2.0.5 FreeBSD */ 					ttwwakeup(tp); #else 					if(tp->t_outq.c_cc<= tp->t_lowat) { 						if(tp->t_state& TS_ASLEEP) { 							tp->t_state&= ~TS_ASLEEP; 							wakeup(TSA_OLOWAT(tp)); 						} 						selwakeup(&tp->t_wsel); 					} #endif 					setwin(sc,0);  					whead=bc->tin& wrapmask; 					wtail=bc->tout& wrapmask;  					DPRINT5("dgb%d: port%d: p tx head=%d tail=%d\n", 						unit,pnum,whead,wtail);  					if(whead<wtail) 						size=wtail-whead-1; 					else { 						size=port->txbufsize-whead; 						if(wtail==0) 							size--; 					}  					if(size==0) { 						bc->iempty=1; bc->ilow=1; 						goto end_of_buffer; 					}  					towin(sc,port->txwin);  					ocount=q_to_b(&tp->t_outq, port->txptr+whead, size); 					whead+=ocount;  					setwin(sc,0); 					bc->tin=whead; 				} #ifndef TS_ASLEEP	/* post 2.0.5 FreeBSD */ 				ttwwakeup(tp); #else 				if(tp->t_state& TS_ASLEEP) { 					tp->t_state&= ~TS_ASLEEP; 					wakeup(TSA_OLOWAT(tp)); 				} 				tp->t_state&= ~TS_BUSY; #endif 			end_of_buffer: 			} 			bc->idata=1;   		} else { 			bc=port->brdchan; 			DPRINT4("dgb%d: port %d: got event 0x%x on closed port\n", 				unit,pnum,event); 			bc->rout=bc->rin; 			bc->idata=bc->iempty=bc->ilow=0; 		}  		tail= (tail+4)& (FEP_IMAX-FEP_ISTART-4); 	}  	sc->mailbox->eout=tail; 	hidewin(sc);  	timeout(dgbpoll, unit_c, hz/25); }  static void dgbintr(unit) 	int	unit; { }  static	int dgbioctl(dev, cmd, data, flag, p) 	dev_t		dev; 	int		cmd; 	caddr_t		data; 	int		flag; 	struct proc	*p; { 	struct dgb_softc *sc; 	int unit, pnum; 	struct dgb_p *port; 	int mynor; 	struct tty *tp; 	struct board_chan *bc; 	int error; 	int s; 	int tiocm_xxx;  	mynor=minor(dev); 	unit=MINOR_TO_UNIT(mynor); 	pnum=MINOR_TO_PORT(mynor);  	sc=&dgb_softc[unit]; 	port=&sc->ports[pnum]; 	tp=&sc->ttys[pnum]; 	bc=port->brdchan;  	if (mynor& CONTROL_MASK) { 		struct termios *ct;  		switch (mynor& CONTROL_MASK) { 		case CONTROL_INIT_STATE: 			ct = mynor& CALLOUT_MASK ?&port->it_out :&port->it_in; 			break; 		case CONTROL_LOCK_STATE: 			ct = mynor& CALLOUT_MASK ?&port->lt_out :&port->lt_in; 			break; 		default: 			return (ENODEV);	/* /dev/nodev */ 		} 		switch (cmd) { 		case TIOCSETA: 			error = suser(p->p_ucred,&p->p_acflag); 			if (error != 0) 				return (error); 			*ct = *(struct termios *)data; 			return (0); 		case TIOCGETA: 			*(struct termios *)data = *ct; 			return (0); 		case TIOCGETD: 			*(int *)data = TTYDISC; 			return (0); 		case TIOCGWINSZ: 			bzero(data, sizeof(struct winsize)); 			return (0); 		default: 			return (ENOTTY); 		} 	}  	if (cmd == TIOCSETA || cmd == TIOCSETAW || cmd == TIOCSETAF) { 		int	cc; 		struct termios *dt = (struct termios *)data; 		struct termios *lt = mynor& CALLOUT_MASK 				     ?&port->lt_out :&port->lt_in;  		dt->c_iflag = (tp->t_iflag& lt->c_iflag) 			      | (dt->c_iflag& ~lt->c_iflag); 		dt->c_oflag = (tp->t_oflag& lt->c_oflag) 			      | (dt->c_oflag& ~lt->c_oflag); 		dt->c_cflag = (tp->t_cflag& lt->c_cflag) 			      | (dt->c_cflag& ~lt->c_cflag); 		dt->c_lflag = (tp->t_lflag& lt->c_lflag) 			      | (dt->c_lflag& ~lt->c_lflag); 		for (cc = 0; cc< NCCS; ++cc) 			if (lt->c_cc[cc] != 0) 				dt->c_cc[cc] = tp->t_cc[cc]; 		if (lt->c_ispeed != 0) 			dt->c_ispeed = tp->t_ispeed; 		if (lt->c_ospeed != 0) 			dt->c_ospeed = tp->t_ospeed; 	}  	if(cmd==TIOCSTOP) { 		setwin(sc,0); 		fepcmd(port, PAUSETX, 0, 0, 0, 0); 		hidewin(sc); 		return 0; 	} else if(cmd==TIOCSTART) { 		setwin(sc,0); 		fepcmd(port, RESUMETX, 0, 0, 0, 0); 		hidewin(sc); 		return 0; 	}  	if(cmd==TIOCSETAW || cmd==TIOCSETAF) 		port->mustdrain=1;  	error = linesw[tp->t_line].l_ioctl(tp, cmd, data, flag, p);  	if (error>= 0) 		return error; 	error = ttioctl(tp, cmd, data, flag);  	port->mustdrain=0;  	if (error>= 0) 		return error; 	s = spltty(); 	switch (cmd) { 	case TIOCSBRK: 		error=dgbdrain(port);  		if(error!=0) { 			splx(s); 			return error; 		}  		setwin(sc,0); 	 		/* now it sends 250 millisecond break because I don'
argument|t know */
comment|/* how to send an infinite break */
argument|fepcmd(port, SENDBREAK,
literal|250
argument|,
literal|0
argument|,
literal|10
argument|,
literal|0
argument|); 		hidewin(sc); 		break; 	case TIOCCBRK:
comment|/* now it's empty */
argument|break; 	case TIOCSDTR: 		DPRINT3(
literal|"dgb%d: port %d: set DTR\n"
argument|,unit,pnum); 		port->omodem |= DTR; 		setwin(sc,
literal|0
argument|); 		fepcmd(port, SETMODEM, port->omodem, RTS,
literal|0
argument|,
literal|1
argument|);  		if( !(bc->mstat& DTR) ) { 			DPRINT3(
literal|"dgb%d: port %d: DTR is off\n"
argument|,unit,pnum); 		}  		hidewin(sc); 		break; 	case TIOCCDTR: 		DPRINT3(
literal|"dgb%d: port %d: reset DTR\n"
argument|,unit,pnum); 		port->omodem&= ~DTR; 		setwin(sc,
literal|0
argument|); 		fepcmd(port, SETMODEM, port->omodem, RTS|DTR,
literal|0
argument|,
literal|1
argument|);  		if( bc->mstat& DTR ) { 			DPRINT3(
literal|"dgb%d: port %d: DTR is on\n"
argument|,unit,pnum); 		}  		hidewin(sc); 		break; 	case TIOCMSET: 		if(*(int *)data& TIOCM_DTR) 			port->omodem |=DTR; 		else 			port->omodem&=~DTR;  		if(*(int *)data& TIOCM_RTS) 			port->omodem |=RTS; 		else 			port->omodem&=~RTS;  		setwin(sc,
literal|0
argument|); 		fepcmd(port, SETMODEM, port->omodem, RTS|DTR,
literal|0
argument|,
literal|1
argument|); 		hidewin(sc); 		break; 	case TIOCMBIS: 		if(*(int *)data& TIOCM_DTR) 			port->omodem |=DTR;  		if(*(int *)data& TIOCM_RTS) 			port->omodem |=RTS;  		setwin(sc,
literal|0
argument|); 		fepcmd(port, SETMODEM, port->omodem, RTS|DTR,
literal|0
argument|,
literal|1
argument|); 		hidewin(sc); 		break; 	case TIOCMBIC: 		if(*(int *)data& TIOCM_DTR) 			port->omodem&=~DTR;  		if(*(int *)data& TIOCM_RTS) 			port->omodem&=~RTS;  		setwin(sc,
literal|0
argument|); 		fepcmd(port, SETMODEM, port->omodem, RTS|DTR,
literal|0
argument|,
literal|1
argument|); 		hidewin(sc); 		break; 	case TIOCMGET: 		setwin(sc,
literal|0
argument|); 		port->imodem=bc->mstat; 		hidewin(sc);  		tiocm_xxx = TIOCM_LE;
comment|/* XXX - always enabled while open */
argument|DPRINT3(
literal|"dgb%d: port %d: modem stat -- "
argument|,unit,pnum);  		if (port->imodem& DTR) { 			DPRINT1(
literal|"DTR "
argument|); 			tiocm_xxx |= TIOCM_DTR; 		} 		if (port->imodem& RTS) { 			DPRINT1(
literal|"RTS "
argument|); 			tiocm_xxx |= TIOCM_RTS; 		} 		if (port->imodem& CTS) { 			DPRINT1(
literal|"CTS "
argument|); 			tiocm_xxx |= TIOCM_CTS; 		} 		if (port->imodem& port->dcd) { 			DPRINT1(
literal|"DCD "
argument|); 			tiocm_xxx |= TIOCM_CD; 		} 		if (port->imodem& port->dsr) { 			DPRINT1(
literal|"DSR "
argument|); 			tiocm_xxx |= TIOCM_DSR; 		} 		if (port->imodem& RI) { 			DPRINT1(
literal|"RI "
argument|); 			tiocm_xxx |= TIOCM_RI; 		} 		*(int *)data = tiocm_xxx; 		DPRINT1(
literal|"--\n"
argument|); 		break; 	default: 		splx(s); 		return ENOTTY; 	} 	splx(s); 	return
literal|0
argument|; }  static void  wakeflush(p) 	void *p; { 	struct dgb_p *port=p;  	wakeup(&port->draining); }
comment|/* wait for the output to drain */
argument|static int dgbdrain(port) 	struct dgb_p	*port; { 	struct tty *tp=port->tty; 	struct dgb_softc *sc=&dgb_softc[port->unit]; 	struct board_chan *bc=port->brdchan; 	int error; 	int head
argument_list|,
argument|tail;  	setwin(sc,
literal|0
argument|);  	bc->iempty=
literal|1
argument|; 	tail=bc->tout; 	head=bc->tin;  	while(tail!=head) { 		DPRINT5(
literal|"dgb%d: port %d: drain: head=%d tail=%d\n"
argument|, 			port->unit, port->pnum, head, tail);  		hidewin(sc); 		port->draining=
literal|1
argument|; 		timeout(wakeflush,port, hz); 		error=tsleep(&port->draining, TTIPRI | PCATCH,
literal|"dgdrn"
argument|,
literal|0
argument|); 		port->draining=
literal|0
argument|; 		setwin(sc,
literal|0
argument|);  		if (error !=
literal|0
argument|) { 			DPRINT4(
literal|"dgb%d: port %d: tsleep(dgdrn) error=%d\n"
argument|, 				port->unit,port->pnum,error);  			bc->iempty=
literal|0
argument|; 			hidewin(sc); 			return error; 		}  		tail=bc->tout; 		head=bc->tin; 	} 	DPRINT5(
literal|"dgb%d: port %d: drain: head=%d tail=%d\n"
argument|, 		port->unit, port->pnum, head, tail);  	return
literal|0
argument|; }
comment|/* wait for the output to drain */
comment|/* or simply clear the buffer it it's stopped */
argument|static void dgb_drain_or_flush(port) 	struct dgb_p	*port; { 	struct tty *tp=port->tty; 	struct dgb_softc *sc=&dgb_softc[port->unit]; 	struct board_chan *bc=port->brdchan; 	int error; 	int lasttail; 	int head
argument_list|,
argument|tail;  	setwin(sc,
literal|0
argument|);  	lasttail=-
literal|1
argument|; 	bc->iempty=
literal|1
argument|; 	tail=bc->tout; 	head=bc->tin;  	while(tail!=head
comment|/*&& tail!=lasttail */
argument|) { 		DPRINT5(
literal|"dgb%d: port %d: flush: head=%d tail=%d\n"
argument|, 			port->unit, port->pnum, head, tail);
comment|/* if there is no carrier simply clean the buffer */
argument|if( !(tp->t_state& TS_CARR_ON) ) { 			bc->tout=bc->tin=
literal|0
argument|; 			bc->iempty=
literal|0
argument|; 			hidewin(sc); 			return; 		}  		hidewin(sc); 		port->draining=
literal|1
argument|; 		timeout(wakeflush,port, hz); 		error=tsleep(&port->draining, TTIPRI | PCATCH,
literal|"dgfls"
argument|,
literal|0
argument|); 		port->draining=
literal|0
argument|; 		setwin(sc,
literal|0
argument|);  		if (error !=
literal|0
argument|) { 			DPRINT4(
literal|"dgb%d: port %d: tsleep(dgfls) error=%d\n"
argument|, 				port->unit,port->pnum,error);
comment|/* silently clean the buffer */
argument|bc->tout=bc->tin=
literal|0
argument|; 			bc->iempty=
literal|0
argument|; 			hidewin(sc); 			return; 		}  		lasttail=tail; 		tail=bc->tout; 		head=bc->tin; 	} 	DPRINT5(
literal|"dgb%d: port %d: flush: head=%d tail=%d\n"
argument|, 			port->unit, port->pnum, head, tail); }  static int dgbparam(tp, t) 	struct tty	*tp; 	struct termios	*t; { 	int dev=tp->t_dev; 	int mynor=minor(dev); 	int unit=MINOR_TO_UNIT(dev); 	int pnum=MINOR_TO_PORT(dev); 	struct dgb_softc *sc=&dgb_softc[unit]; 	struct dgb_p *port=&sc->ports[pnum]; 	struct board_chan *bc=port->brdchan; 	int cflag; 	int head; 	int mval; 	int iflag; 	int hflow; 	int s;  	DPRINT3(
literal|"dgb%d: port%d: setting parameters\n"
argument|,unit,pnum);  	if(port->mustdrain) { 		DPRINT3(
literal|"dgb%d: port%d: must call dgbdrain()\n"
argument|,unit,pnum); 		dgbdrain(port); 	}  	cflag=ttspeedtab(t->c_ospeed, dgbspeedtab);  	if (t->c_ispeed ==
literal|0
argument|) 		t->c_ispeed = t->c_ospeed;  	if (cflag<
literal|0
argument||| cflag>
literal|0
argument|&& t->c_ispeed != t->c_ospeed) 		return (EINVAL);  	s=spltty();  	setwin(sc,
literal|0
argument|);  	if(cflag==
literal|0
argument|) {
comment|/* hangup */
argument|DPRINT3(
literal|"dgb%d: port%d: hangup\n"
argument|,unit,pnum); 		head=bc->rin; 		bc->rout=head; 		head=bc->tin; 		fepcmd(port, STOUT, head,
literal|0
argument|,
literal|0
argument|,
literal|0
argument|); 		mval= port->omodem& ~(DTR|RTS); 	} else { 		DPRINT4(
literal|"dgb%d: port%d: CBAUD=%d\n"
argument|,unit,pnum,cflag);
comment|/* convert flags to sysV-style values */
argument|if(t->c_cflag& PARODD) 			cflag|=
literal|01000
argument|; 		if(t->c_cflag& PARENB) 			cflag|=
literal|00400
argument|; 		if(t->c_cflag& CSTOPB) 			cflag|=
literal|00100
argument|;  		cflag|= (t->c_cflag& CSIZE)>>
literal|4
argument|; 		DPRINT4(
literal|"dgb%d: port%d: CFLAG=0x%x\n"
argument|,unit,pnum,cflag);  		if(cflag!=port->fepcflag) { 			DPRINT3(
literal|"dgb%d: port%d: set cflag\n"
argument|,unit,pnum); 			port->fepcflag=cflag; 			fepcmd(port, SETCTRLFLAGS, (unsigned)cflag,
literal|0
argument|,
literal|0
argument|,
literal|0
argument|); 		} 		mval= port->omodem | (DTR|RTS) ; 	}  	iflag=t->c_iflag& (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK|ISTRIP); 	if(t->c_cflag& IXON) 		cflag|=
literal|002000
argument|; 	if(t->c_cflag& IXANY) 		cflag|=
literal|004000
argument|; 	if(t->c_cflag& IXOFF) 		cflag|=
literal|010000
argument|;  	if(iflag!=port->fepiflag) { 		DPRINT3(
literal|"dgb%d: port%d: set iflag\n"
argument|,unit,pnum); 		port->fepiflag=iflag; 		fepcmd(port, SETIFLAGS, (unsigned)iflag,
literal|0
argument|,
literal|0
argument|,
literal|0
argument|); 	}  	bc->mint=port->dcd;  	if(t->c_cflag& CRTSCTS) 		hflow=(CTS|RTS); 	else 		hflow=
literal|0
argument|;  	if(hflow!=port->hflow) { 		DPRINT3(
literal|"dgb%d: port%d: set hflow\n"
argument|,unit,pnum); 		port->hflow=hflow; 		fepcmd(port, SETHFLOW, (unsigned)hflow,
literal|0xff
argument|,
literal|0
argument|,
literal|1
argument|); 	} 	 	if(port->omodem != mval) { 		DPRINT4(
literal|"dgb%d: port %d: setting modem parameters 0x%x\n"
argument|, 			unit,pnum,mval); 		port->omodem=mval; 		fepcmd(port, SETMODEM, (unsigned)mval, RTS|DTR,
literal|0
argument|,
literal|1
argument|); 	}  	if(port->fepstartc!=t->c_cc[VSTART] || port->fepstopc!=t->c_cc[VSTOP]) { 		DPRINT3(
literal|"dgb%d: port%d: set startc, stopc\n"
argument|,unit,pnum); 		port->fepstartc=t->c_cc[VSTART]; 		port->fepstopc=t->c_cc[VSTOP]; 		fepcmd(port, SONOFFC, port->fepstartc, port->fepstopc,
literal|0
argument|,
literal|1
argument|); 	}  	hidewin(sc); 	splx(s);  	return
literal|0
argument|;  }  static void dgbstart(tp) 	struct tty	*tp; { 	int unit; 	int pnum; 	struct dgb_p *port; 	struct dgb_softc *sc; 	struct board_chan *bc; 	int head
argument_list|,
argument|tail; 	int size
argument_list|,
argument|ocount; 	int s; 	int wmask;  	unit=MINOR_TO_UNIT(minor(tp->t_dev)); 	pnum=MINOR_TO_PORT(minor(tp->t_dev)); 	sc=&dgb_softc[unit]; 	port=&sc->ports[pnum]; 	bc=port->brdchan;  	wmask=port->txbufsize-
literal|1
argument|;  	s=spltty();  	while( tp->t_outq.c_cc!=
literal|0
argument|) {
ifndef|#
directive|ifndef
name|TS_ASLEEP
comment|/* post 2.0.5 FreeBSD */
argument|ttwwakeup(tp);
else|#
directive|else
argument|if(tp->t_outq.c_cc<= tp->t_lowat) { 			if(tp->t_state& TS_ASLEEP) { 				tp->t_state&= ~TS_ASLEEP; 				wakeup(TSA_OLOWAT(tp)); 			} 			selwakeup(&tp->t_wsel); 		}
endif|#
directive|endif
argument|setwin(sc,
literal|0
argument|);  		head=bc->tin& wmask; 		tail=bc->tout& wmask;  		DPRINT5(
literal|"dgb%d: port%d: s tx head=%d tail=%d\n"
argument|,unit,pnum,head,tail);  		if(tail>head) 			size=tail-head-
literal|1
argument|; 		else { 			size=port->txbufsize-head; 			if(tail==
literal|0
argument|) 				size--; 		}  		if(size==
literal|0
argument|) { 			bc->iempty=
literal|1
argument|; bc->ilow=
literal|1
argument|; 			hidewin(sc); 			tp->t_state|=TS_BUSY; 			splx(s); 			return; 		}  		towin(sc,port->txwin);  		ocount=q_to_b(&tp->t_outq, port->txptr+head, size); 		head+=ocount; 		if(head>=port->txbufsize) 			head-=port->txbufsize;  		setwin(sc,
literal|0
argument|); 		bc->tin=head; 	}
ifndef|#
directive|ifndef
name|TS_ASLEEP
comment|/* post 2.0.5 FreeBSD */
argument|ttwwakeup(tp);
else|#
directive|else
argument|if(tp->t_state& TS_ASLEEP) { 		tp->t_state&= ~TS_ASLEEP; 		wakeup(TSA_OLOWAT(tp)); 	} 	tp->t_state&=~TS_BUSY;
endif|#
directive|endif
argument|hidewin(sc); 	splx(s); }  void dgbstop(tp, rw) 	struct tty	*tp; 	int		rw; { }  struct tty * dgbdevtotty(dev) 	dev_t	dev; { 	int mynor
argument_list|,
argument|pnum
argument_list|,
argument|unit; 	struct dgb_softc *sc;  	mynor = minor(dev); 	if (mynor& CONTROL_MASK) 		return (NULL); 	unit = MINOR_TO_UNIT(mynor); 	if ((u_int) unit>= NDGB) 		return (NULL); 	pnum = MINOR_TO_PORT(mynor); 	sc =&dgb_softc[unit]; 	if (pnum>= sc->numports) 		return (NULL); 	return (&sc->ttys[pnum]); }  static void  fepcmd(port, cmd, op1, op2, ncmds, bytecmd) 	struct dgb_p *port; 	int cmd
argument_list|,
argument|op1
argument_list|,
argument|op2
argument_list|,
argument|ncmds
argument_list|,
argument|bytecmd; { 	struct dgb_softc *sc=&dgb_softc[port->unit]; 	u_char *mem=sc->vmem; 	unsigned tail
argument_list|,
argument|head; 	int count
argument_list|,
argument|n;  	if(port->status==DISABLED) { 		printf(
literal|"dgb%d(%d): FEP command on disabled port\n"
argument|,  			port->unit, port->pnum); 		return; 	}  	setwin(sc,
literal|0
argument|); 	head=sc->mailbox->cin;  	if(head>=(FEP_CMAX-FEP_CSTART) || (head&
literal|3
argument|)) { 		printf(
literal|"dgb%d(%d): wrong pointer head of command queue : 0x%x\n"
argument|, 			port->unit, port->pnum, head); 		return; 	}  	if(bytecmd) { 		mem[head+FEP_CSTART+
literal|0
argument|]=cmd; 		mem[head+FEP_CSTART+
literal|1
argument|]=port->pnum; 		mem[head+FEP_CSTART+
literal|2
argument|]=op1; 		mem[head+FEP_CSTART+
literal|3
argument|]=op2; 	} else { 		mem[head+FEP_CSTART+
literal|0
argument|]=cmd; 		mem[head+FEP_CSTART+
literal|1
argument|]=port->pnum; 		*(ushort *)(mem+head+FEP_CSTART+
literal|2
argument|)=op1; 	}  	head=(head+
literal|4
argument|)& (FEP_CMAX-FEP_CSTART-
literal|4
argument|); 	sc->mailbox->cin=head;  	for(count=FEPTIMEOUT; count>
literal|0
argument|; count--) { 		head=sc->mailbox->cin; 		tail=sc->mailbox->cout; 		n=(head-tail)& (FEP_CMAX-FEP_CSTART-
literal|4
argument|);  		if(n<= ncmds *
literal|4
argument|) 			return; 	}  	printf(
literal|"dgb%d(%d): timeout on FEP command\n"
argument|, 			port->unit, port->pnum); }   static dgb_devsw_installed =
literal|0
argument|;  static void  dgb_drvinit(void *unused) { 	dev_t dev;  	if( ! dgb_devsw_installed ) { 		dev = makedev(CDEV_MAJOR,
literal|0
argument|); 		cdevsw_add(&dev,&dgb_cdevsw, NULL); 		dgb_devsw_installed =
literal|1
argument|;     	} }  SYSINIT(dgbdev,SI_SUB_DRIVERS,SI_ORDER_MIDDLE+CDEV_MAJOR,dgb_drvinit,NULL)
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NDGB> 0 */
end_comment

end_unit

