begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * sound/awe_wave.c  *  * The low level driver for the AWE32/Sound Blaster 32 wave table synth.  *   version 0.4.2c; Oct. 7, 1997  *  * Copyright (C) 1996,1997 Takashi Iwai  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License as published by  * the Free Software Foundation; either version 2 of the License, or  * (at your option) any later version.  *  * This program is distributed in the hope that it will be useful,  * but WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the  * GNU General Public License for more details.  *  * You should have received a copy of the GNU General Public License  * along with this program; if not, write to the Free Software  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<gnu/i386/isa/sound/awe_config.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"awe_config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*----------------------------------------------------------------*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_AWE32_SYNTH
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<gnu/i386/isa/sound/awe_hw.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/isa/sound/awe_version.h>
end_include

begin_include
include|#
directive|include
file|<gnu/i386/isa/sound/awe_voice.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"awe_hw.h"
end_include

begin_include
include|#
directive|include
file|"awe_version.h"
end_include

begin_include
include|#
directive|include
file|<linux/awe_voice.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|AWE_HAS_GUS_COMPATIBILITY
end_ifdef

begin_comment
comment|/* include finetune table */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|AWE_OBSOLETE_VOXWARE
end_ifdef

begin_define
define|#
directive|define
name|SEQUENCER_C
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<i386/isa/sound/tuning.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|AWE_OBSOLETE_VOXWARE
end_ifdef

begin_include
include|#
directive|include
file|"tuning.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"../tuning.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|linux
end_ifdef

begin_include
include|#
directive|include
file|<linux/ultrasound.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<machine/ultrasound.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AWE_HAS_GUS_COMPATIBILITY */
end_comment

begin_comment
comment|/*----------------------------------------------------------------  * debug message  *----------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|debug_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AWE_DEBUG_ON
end_ifdef

begin_define
define|#
directive|define
name|DEBUG
parameter_list|(
name|LVL
parameter_list|,
name|XXX
parameter_list|)
value|{if (debug_mode> LVL) { XXX; }}
end_define

begin_define
define|#
directive|define
name|ERRMSG
parameter_list|(
name|XXX
parameter_list|)
value|{if (debug_mode) { XXX; }}
end_define

begin_define
define|#
directive|define
name|FATALERR
parameter_list|(
name|XXX
parameter_list|)
value|XXX
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEBUG
parameter_list|(
name|LVL
parameter_list|,
name|XXX
parameter_list|)
end_define

begin_comment
comment|/**/
end_comment

begin_define
define|#
directive|define
name|ERRMSG
parameter_list|(
name|XXX
parameter_list|)
value|XXX
end_define

begin_define
define|#
directive|define
name|FATALERR
parameter_list|(
name|XXX
parameter_list|)
value|XXX
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*----------------------------------------------------------------  * bank and voice record  *----------------------------------------------------------------*/
end_comment

begin_comment
comment|/* soundfont record */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_sf_list
block|{
name|unsigned
name|short
name|sf_id
decl_stmt|;
name|unsigned
name|short
name|type
decl_stmt|;
name|int
name|num_info
decl_stmt|;
comment|/* current info table index */
name|int
name|num_sample
decl_stmt|;
comment|/* current sample table index */
name|int
name|mem_ptr
decl_stmt|;
comment|/* current word byte pointer */
name|int
name|infos
decl_stmt|;
name|int
name|samples
decl_stmt|;
comment|/*char name[AWE_PATCH_NAME_LEN];*/
block|}
name|sf_list
typedef|;
end_typedef

begin_comment
comment|/* bank record */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_awe_voice_list
block|{
name|int
name|next
decl_stmt|;
comment|/* linked list with same sf_id */
name|unsigned
name|char
name|bank
decl_stmt|,
name|instr
decl_stmt|;
comment|/* preset number information */
name|char
name|type
decl_stmt|,
name|disabled
decl_stmt|;
comment|/* type=normal/mapped, disabled=boolean */
name|awe_voice_info
name|v
decl_stmt|;
comment|/* voice information */
name|int
name|next_instr
decl_stmt|;
comment|/* preset table list */
name|int
name|next_bank
decl_stmt|;
comment|/* preset table list */
block|}
name|awe_voice_list
typedef|;
end_typedef

begin_comment
comment|/* voice list type */
end_comment

begin_define
define|#
directive|define
name|V_ST_NORMAL
value|0
end_define

begin_define
define|#
directive|define
name|V_ST_MAPPED
value|1
end_define

begin_typedef
typedef|typedef
struct|struct
name|_awe_sample_list
block|{
name|int
name|next
decl_stmt|;
comment|/* linked list with same sf_id */
name|awe_sample_info
name|v
decl_stmt|;
comment|/* sample information */
block|}
name|awe_sample_list
typedef|;
end_typedef

begin_comment
comment|/* sample and information table */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_sf_id
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|locked_sf_id
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_sfs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sf_list
modifier|*
name|sflists
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|awe_free_mem_ptr
parameter_list|()
value|(current_sf_id<= 0 ? 0 : sflists[current_sf_id-1].mem_ptr)
end_define

begin_define
define|#
directive|define
name|awe_free_info
parameter_list|()
value|(current_sf_id<= 0 ? 0 : sflists[current_sf_id-1].num_info)
end_define

begin_define
define|#
directive|define
name|awe_free_sample
parameter_list|()
value|(current_sf_id<= 0 ? 0 : sflists[current_sf_id-1].num_sample)
end_define

begin_decl_stmt
specifier|static
name|int
name|max_samples
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|awe_sample_list
modifier|*
name|samples
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|max_infos
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|awe_voice_list
modifier|*
name|infos
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|AWE_MAX_PRESETS
value|256
end_define

begin_define
define|#
directive|define
name|AWE_DEFAULT_PRESET
value|0
end_define

begin_define
define|#
directive|define
name|AWE_DEFAULT_BANK
value|0
end_define

begin_define
define|#
directive|define
name|AWE_DEFAULT_DRUM
value|0
end_define

begin_define
define|#
directive|define
name|AWE_DRUM_BANK
value|128
end_define

begin_define
define|#
directive|define
name|MAX_LAYERS
value|AWE_MAX_VOICES
end_define

begin_comment
comment|/* preset table index */
end_comment

begin_decl_stmt
specifier|static
name|int
name|preset_table
index|[
name|AWE_MAX_PRESETS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*----------------------------------------------------------------  * voice table  *----------------------------------------------------------------*/
end_comment

begin_comment
comment|/* effects table */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|FX_Rec
block|{
comment|/* channel effects */
name|unsigned
name|char
name|flags
index|[
name|AWE_FX_END
index|]
decl_stmt|;
name|short
name|val
index|[
name|AWE_FX_END
index|]
decl_stmt|;
block|}
name|FX_Rec
typedef|;
end_typedef

begin_comment
comment|/* channel parameters */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_awe_chan_info
block|{
name|int
name|channel
decl_stmt|;
comment|/* channel number */
name|int
name|bank
decl_stmt|;
comment|/* current tone bank */
name|int
name|instr
decl_stmt|;
comment|/* current program */
name|int
name|bender
decl_stmt|;
comment|/* midi pitchbend (-8192 - 8192) */
name|int
name|bender_range
decl_stmt|;
comment|/* midi bender range (x100) */
name|int
name|panning
decl_stmt|;
comment|/* panning (0-127) */
name|int
name|main_vol
decl_stmt|;
comment|/* channel volume (0-127) */
name|int
name|expression_vol
decl_stmt|;
comment|/* midi expression (0-127) */
name|int
name|chan_press
decl_stmt|;
comment|/* channel pressure */
name|int
name|vrec
decl_stmt|;
comment|/* instrument list */
name|int
name|def_vrec
decl_stmt|;
comment|/* default instrument list */
name|int
name|sustained
decl_stmt|;
comment|/* sustain status in MIDI */
name|FX_Rec
name|fx
decl_stmt|;
comment|/* effects */
name|FX_Rec
name|fx_layer
index|[
name|MAX_LAYERS
index|]
decl_stmt|;
comment|/* layer effects */
block|}
name|awe_chan_info
typedef|;
end_typedef

begin_comment
comment|/* voice parameters */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_voice_info
block|{
name|int
name|state
decl_stmt|;
define|#
directive|define
name|AWE_ST_OFF
value|(1<<0)
comment|/* no sound */
define|#
directive|define
name|AWE_ST_ON
value|(1<<1)
comment|/* playing */
define|#
directive|define
name|AWE_ST_STANDBY
value|(1<<2)
comment|/* stand by for playing */
define|#
directive|define
name|AWE_ST_SUSTAINED
value|(1<<3)
comment|/* sustained */
define|#
directive|define
name|AWE_ST_MARK
value|(1<<4)
comment|/* marked for allocation */
define|#
directive|define
name|AWE_ST_DRAM
value|(1<<5)
comment|/* DRAM read/write */
define|#
directive|define
name|AWE_ST_FM
value|(1<<6)
comment|/* reserved for FM */
define|#
directive|define
name|AWE_ST_RELEASED
value|(1<<7)
comment|/* released */
name|int
name|ch
decl_stmt|;
comment|/* midi channel */
name|int
name|key
decl_stmt|;
comment|/* internal key for search */
name|int
name|layer
decl_stmt|;
comment|/* layer number (for channel mode only) */
name|int
name|time
decl_stmt|;
comment|/* allocated time */
name|awe_chan_info
modifier|*
name|cinfo
decl_stmt|;
comment|/* channel info */
name|int
name|note
decl_stmt|;
comment|/* midi key (0-127) */
name|int
name|velocity
decl_stmt|;
comment|/* midi velocity (0-127) */
name|int
name|sostenuto
decl_stmt|;
comment|/* sostenuto on/off */
name|awe_voice_info
modifier|*
name|sample
decl_stmt|;
comment|/* assigned voice */
comment|/* EMU8000 parameters */
name|int
name|apitch
decl_stmt|;
comment|/* pitch parameter */
name|int
name|avol
decl_stmt|;
comment|/* volume parameter */
name|int
name|apan
decl_stmt|;
comment|/* panning parameter */
block|}
name|voice_info
typedef|;
end_typedef

begin_comment
comment|/* voice information */
end_comment

begin_decl_stmt
specifier|static
name|voice_info
modifier|*
name|voices
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IS_NO_SOUND
parameter_list|(
name|v
parameter_list|)
value|(voices[v].state& (AWE_ST_OFF|AWE_ST_RELEASED|AWE_ST_STANDBY|AWE_ST_SUSTAINED))
end_define

begin_define
define|#
directive|define
name|IS_NO_EFFECT
parameter_list|(
name|v
parameter_list|)
value|(voices[v].state != AWE_ST_ON)
end_define

begin_define
define|#
directive|define
name|IS_PLAYING
parameter_list|(
name|v
parameter_list|)
value|(voices[v].state& (AWE_ST_ON|AWE_ST_SUSTAINED|AWE_ST_RELEASED))
end_define

begin_define
define|#
directive|define
name|IS_EMPTY
parameter_list|(
name|v
parameter_list|)
value|(voices[v].state& (AWE_ST_OFF|AWE_ST_MARK|AWE_ST_DRAM|AWE_ST_FM))
end_define

begin_comment
comment|/* MIDI channel effects information (for hw control) */
end_comment

begin_decl_stmt
specifier|static
name|awe_chan_info
modifier|*
name|channels
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*----------------------------------------------------------------  * global variables  *----------------------------------------------------------------*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|AWE_DEFAULT_BASE_ADDR
end_ifndef

begin_define
define|#
directive|define
name|AWE_DEFAULT_BASE_ADDR
value|0
end_define

begin_comment
comment|/* autodetect */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|AWE_DEFAULT_MEM_SIZE
end_ifndef

begin_define
define|#
directive|define
name|AWE_DEFAULT_MEM_SIZE
value|0
end_define

begin_comment
comment|/* autodetect */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* awe32 base address (overwritten at initialization) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|awe_base
init|=
name|AWE_DEFAULT_BASE_ADDR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* memory byte size */
end_comment

begin_decl_stmt
specifier|static
name|int
name|awe_mem_size
init|=
name|AWE_DEFAULT_MEM_SIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DRAM start offset */
end_comment

begin_decl_stmt
specifier|static
name|int
name|awe_mem_start
init|=
name|AWE_DRAM_OFFSET
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum channels for playing */
end_comment

begin_decl_stmt
specifier|static
name|int
name|awe_max_voices
init|=
name|AWE_MAX_VOICES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|patch_opened
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sample already loaded? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|reverb_mode
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* reverb mode */
end_comment

begin_decl_stmt
specifier|static
name|int
name|chorus_mode
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* chorus mode */
end_comment

begin_decl_stmt
specifier|static
name|short
name|init_atten
init|=
name|AWE_DEFAULT_ATTENUATION
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 12dB below */
end_comment

begin_decl_stmt
specifier|static
name|int
name|awe_present
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* awe device present? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|awe_busy
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* awe device opened? */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_DRUM_FLAGS
value|((1<< 9) | (1<< 25))
end_define

begin_define
define|#
directive|define
name|IS_DRUM_CHANNEL
parameter_list|(
name|c
parameter_list|)
value|(drum_flags& (1<< (c)))
end_define

begin_define
define|#
directive|define
name|DRUM_CHANNEL_ON
parameter_list|(
name|c
parameter_list|)
value|(drum_flags |= (1<< (c)))
end_define

begin_define
define|#
directive|define
name|DRUM_CHANNEL_OFF
parameter_list|(
name|c
parameter_list|)
value|(drum_flags&= ~(1<< (c)))
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|drum_flags
init|=
name|DEFAULT_DRUM_FLAGS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* channel flags */
end_comment

begin_decl_stmt
specifier|static
name|int
name|playing_mode
init|=
name|AWE_PLAY_INDIRECT
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SINGLE_LAYER_MODE
parameter_list|()
value|(playing_mode == AWE_PLAY_INDIRECT || playing_mode == AWE_PLAY_DIRECT)
end_define

begin_define
define|#
directive|define
name|MULTI_LAYER_MODE
parameter_list|()
value|(playing_mode == AWE_PLAY_MULTI || playing_mode == AWE_PLAY_MULTI2)
end_define

begin_decl_stmt
specifier|static
name|int
name|current_alloc_time
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* voice allocation index for channel mode */
end_comment

begin_struct
specifier|static
struct|struct
name|MiscModeDef
block|{
name|int
name|value
decl_stmt|;
name|int
name|init_each_time
decl_stmt|;
block|}
name|misc_modes_default
index|[
name|AWE_MD_END
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/*<-- not used */
block|{
name|AWE_VERSION_NUMBER
block|,
name|FALSE
block|}
block|,
block|{
name|TRUE
block|,
name|TRUE
block|}
block|,
comment|/* exclusive */
block|{
name|TRUE
block|,
name|TRUE
block|}
block|,
comment|/* realpan */
block|{
name|AWE_DEFAULT_BANK
block|,
name|TRUE
block|}
block|,
comment|/* gusbank */
block|{
name|FALSE
block|,
name|TRUE
block|}
block|,
comment|/* keep effect */
block|{
name|AWE_DEFAULT_ATTENUATION
block|,
name|FALSE
block|}
block|,
comment|/* zero_atten */
block|{
name|FALSE
block|,
name|TRUE
block|}
block|,
comment|/* chn_prior */
block|{
name|AWE_DEFAULT_MOD_SENSE
block|,
name|TRUE
block|}
block|,
comment|/* modwheel sense */
block|{
name|AWE_DEFAULT_PRESET
block|,
name|TRUE
block|}
block|,
comment|/* def_preset */
block|{
name|AWE_DEFAULT_BANK
block|,
name|TRUE
block|}
block|,
comment|/* def_bank */
block|{
name|AWE_DEFAULT_DRUM
block|,
name|TRUE
block|}
block|,
comment|/* def_drum */
block|{
name|FALSE
block|,
name|TRUE
block|}
block|,
comment|/* toggle_drum_bank */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|misc_modes
index|[
name|AWE_MD_END
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|awe_bass_level
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|awe_treble_level
init|=
literal|9
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|synth_info
name|awe_info
init|=
block|{
literal|"AWE32 Synth"
block|,
comment|/* name */
literal|0
block|,
comment|/* device */
name|SYNTH_TYPE_SAMPLE
block|,
comment|/* synth_type */
name|SAMPLE_TYPE_AWE32
block|,
comment|/* synth_subtype */
literal|0
block|,
comment|/* perc_mode (obsolete) */
name|AWE_MAX_VOICES
block|,
comment|/* nr_voices */
literal|0
block|,
comment|/* nr_drums (obsolete) */
name|AWE_MAX_INFOS
comment|/* instr_bank_size */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|voice_alloc_info
modifier|*
name|voice_alloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set at initialization */
end_comment

begin_comment
comment|/*----------------------------------------------------------------  * function prototypes  *----------------------------------------------------------------*/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|linux
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|AWE_OBSOLETE_VOXWARE
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|awe_check_port
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_request_region
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_release_region
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|awe_reset_samples
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* emu8000 chip i/o access */
end_comment

begin_function_decl
specifier|static
name|void
name|awe_poke
parameter_list|(
name|unsigned
name|short
name|cmd
parameter_list|,
name|unsigned
name|short
name|port
parameter_list|,
name|unsigned
name|short
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_poke_dw
parameter_list|(
name|unsigned
name|short
name|cmd
parameter_list|,
name|unsigned
name|short
name|port
parameter_list|,
name|unsigned
name|int
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|short
name|awe_peek
parameter_list|(
name|unsigned
name|short
name|cmd
parameter_list|,
name|unsigned
name|short
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|awe_peek_dw
parameter_list|(
name|unsigned
name|short
name|cmd
parameter_list|,
name|unsigned
name|short
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_wait
parameter_list|(
name|unsigned
name|short
name|delay
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* initialize emu8000 chip */
end_comment

begin_function_decl
specifier|static
name|void
name|awe_initialize
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* set voice parameters */
end_comment

begin_function_decl
specifier|static
name|void
name|awe_init_misc_modes
parameter_list|(
name|int
name|init_all
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_init_voice_info
parameter_list|(
name|awe_voice_info
modifier|*
name|vp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_init_voice_parm
parameter_list|(
name|awe_voice_parm
modifier|*
name|pp
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|AWE_HAS_GUS_COMPATIBILITY
end_ifdef

begin_function_decl
specifier|static
name|int
name|freq_to_note
parameter_list|(
name|int
name|freq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|calc_rate_offset
parameter_list|(
name|int
name|Hz
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*static int calc_parm_delay(int msec);*/
end_comment

begin_function_decl
specifier|static
name|int
name|calc_parm_hold
parameter_list|(
name|int
name|msec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|calc_parm_attack
parameter_list|(
name|int
name|msec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|calc_parm_decay
parameter_list|(
name|int
name|msec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|calc_parm_search
parameter_list|(
name|int
name|msec
parameter_list|,
name|short
modifier|*
name|table
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* turn on/off note */
end_comment

begin_function_decl
specifier|static
name|void
name|awe_note_on
parameter_list|(
name|int
name|voice
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_note_off
parameter_list|(
name|int
name|voice
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_terminate
parameter_list|(
name|int
name|voice
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_exclusive_off
parameter_list|(
name|int
name|voice
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_note_off_all
parameter_list|(
name|int
name|do_sustain
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* calculate voice parameters */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|fx_affect_func
function_decl|)
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|static
name|void
name|awe_set_pitch
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_set_voice_pitch
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_set_volume
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_set_voice_vol
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_set_pan
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_fx_fmmod
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_fx_tremfrq
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_fx_fm2frq2
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_fx_filterQ
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_calc_pitch
parameter_list|(
name|int
name|voice
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|AWE_HAS_GUS_COMPATIBILITY
end_ifdef

begin_function_decl
specifier|static
name|void
name|awe_calc_pitch_from_freq
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|freq
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|awe_calc_volume
parameter_list|(
name|int
name|voice
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_voice_init
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|init_all
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_channel_init
parameter_list|(
name|int
name|ch
parameter_list|,
name|int
name|init_all
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_fx_init
parameter_list|(
name|int
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* sequencer interface */
end_comment

begin_function_decl
specifier|static
name|int
name|awe_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_close
parameter_list|(
name|int
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_kill_note
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|note
parameter_list|,
name|int
name|velocity
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_start_note
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|v
parameter_list|,
name|int
name|note_num
parameter_list|,
name|int
name|volume
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_set_instr
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|instr_no
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_set_instr_2
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|instr_no
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_reset
parameter_list|(
name|int
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_hw_control
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|char
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_load_patch
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|format
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|offs
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|pmgr_flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_aftertouch
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|pressure
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_controller
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|ctrl_num
parameter_list|,
name|int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_panning
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_volume_method
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|AWE_NO_PATCHMGR
end_ifndef

begin_function_decl
specifier|static
name|int
name|awe_patchmgr
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|patmgr_info
modifier|*
name|rec
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|awe_bender
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_alloc
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|chn
parameter_list|,
name|int
name|note
parameter_list|,
name|struct
name|voice_alloc_info
modifier|*
name|alloc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_setup_voice
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|chn
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* hardware controls */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AWE_HAS_GUS_COMPATIBILITY
end_ifdef

begin_function_decl
specifier|static
name|void
name|awe_hw_gus_control
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|unsigned
name|char
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|awe_hw_awe_control
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|unsigned
name|char
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_voice_change
parameter_list|(
name|int
name|voice
parameter_list|,
name|fx_affect_func
name|func
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_sostenuto_on
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_sustain_off
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_terminate_and_init
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* voice search */
end_comment

begin_function_decl
specifier|static
name|int
name|awe_search_instr
parameter_list|(
name|int
name|bank
parameter_list|,
name|int
name|preset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_search_multi_voices
parameter_list|(
name|int
name|rec
parameter_list|,
name|int
name|note
parameter_list|,
name|int
name|velocity
parameter_list|,
name|awe_voice_info
modifier|*
modifier|*
name|vlist
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_alloc_multi_voices
parameter_list|(
name|int
name|ch
parameter_list|,
name|int
name|note
parameter_list|,
name|int
name|velocity
parameter_list|,
name|int
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_alloc_one_voice
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|note
parameter_list|,
name|int
name|velocity
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_clear_voice
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* load / remove patches */
end_comment

begin_function_decl
specifier|static
name|int
name|awe_open_patch
parameter_list|(
name|awe_patch_info
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_close_patch
parameter_list|(
name|awe_patch_info
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_unload_patch
parameter_list|(
name|awe_patch_info
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_load_info
parameter_list|(
name|awe_patch_info
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_load_data
parameter_list|(
name|awe_patch_info
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_replace_data
parameter_list|(
name|awe_patch_info
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_load_map
parameter_list|(
name|awe_patch_info
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|AWE_HAS_GUS_COMPATIBILITY
end_ifdef

begin_function_decl
specifier|static
name|int
name|awe_load_guspatch
parameter_list|(
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|offs
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|pmgr_flag
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|check_patch_opened
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_write_wave_data
parameter_list|(
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|offset
parameter_list|,
name|awe_sample_info
modifier|*
name|sp
parameter_list|,
name|int
name|channels
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_sf_info
parameter_list|(
name|int
name|rec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_sf_sample
parameter_list|(
name|int
name|rec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|purge_old_list
parameter_list|(
name|int
name|rec
parameter_list|,
name|int
name|next
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_info_list
parameter_list|(
name|int
name|rec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_remove_samples
parameter_list|(
name|int
name|sf_id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rebuild_preset_list
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|short
name|awe_set_sample
parameter_list|(
name|awe_voice_info
modifier|*
name|vp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* lowlevel functions */
end_comment

begin_function_decl
specifier|static
name|void
name|awe_init_audio
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_init_dma
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_init_array
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_send_array
parameter_list|(
name|unsigned
name|short
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_tweak_voice
parameter_list|(
name|int
name|voice
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_tweak
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_init_fm
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_open_dram_for_write
parameter_list|(
name|int
name|offset
parameter_list|,
name|int
name|channels
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_open_dram_for_check
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_close_dram
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_write_dram
parameter_list|(
name|unsigned
name|short
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_detect_base
parameter_list|(
name|int
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_detect
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_check_dram
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_load_chorus_fx
parameter_list|(
name|awe_patch_info
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_set_chorus_mode
parameter_list|(
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|awe_load_reverb_fx
parameter_list|(
name|awe_patch_info
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_set_reverb_mode
parameter_list|(
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|awe_equalizer
parameter_list|(
name|int
name|bass
parameter_list|,
name|int
name|treble
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_AWE32_MIXER
end_ifdef

begin_function_decl
specifier|static
name|int
name|awe_mixer_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* define macros for compatibility */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<gnu/i386/isa/sound/awe_compat.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"awe_compat.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*----------------------------------------------------------------  * synth operation table  *----------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|synth_operations
name|awe_operations
init|=
block|{
ifdef|#
directive|ifdef
name|AWE_OSS38
literal|"EMU8K"
block|,
endif|#
directive|endif
operator|&
name|awe_info
block|,
literal|0
block|,
name|SYNTH_TYPE_SAMPLE
block|,
name|SAMPLE_TYPE_AWE32
block|,
name|awe_open
block|,
name|awe_close
block|,
name|awe_ioctl
block|,
name|awe_kill_note
block|,
name|awe_start_note
block|,
name|awe_set_instr_2
block|,
name|awe_reset
block|,
name|awe_hw_control
block|,
name|awe_load_patch
block|,
name|awe_aftertouch
block|,
name|awe_controller
block|,
name|awe_panning
block|,
name|awe_volume_method
block|,
ifndef|#
directive|ifndef
name|AWE_NO_PATCHMGR
name|awe_patchmgr
block|,
endif|#
directive|endif
name|awe_bender
block|,
name|awe_alloc
block|,
name|awe_setup_voice
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_AWE32_MIXER
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|mixer_operations
name|awe_mixer_operations
init|=
block|{
ifndef|#
directive|ifndef
name|__FreeBSD__
literal|"AWE32"
block|,
endif|#
directive|endif
literal|"AWE32 Equalizer"
block|,
name|awe_mixer_ioctl
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*================================================================  * attach / unload interface  *================================================================*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AWE_OBSOLETE_VOXWARE
end_ifdef

begin_define
define|#
directive|define
name|ATTACH_DECL
value|static
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ATTACH_DECL
end_define

begin_comment
comment|/**/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|AWE_OBSOLETE_VOXWARE
argument_list|)
end_if

begin_define
define|#
directive|define
name|ATTACH_RET
end_define

begin_decl_stmt
name|void
name|attach_awe
argument_list|(
expr|struct
name|address_info
operator|*
name|hw_config
argument_list|)
else|#
directive|else
define|#
directive|define
name|ATTACH_RET
value|ret
name|ATTACH_DECL
name|int
name|attach_awe
argument_list|(
name|void
argument_list|)
endif|#
directive|endif
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* check presence of AWE32 card */
if|if
condition|(
operator|!
name|awe_detect
argument_list|()
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32: not detected\n"
argument_list|)
expr_stmt|;
return|return
name|ATTACH_RET
return|;
block|}
comment|/* check AWE32 ports are available */
if|if
condition|(
name|awe_check_port
argument_list|()
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32: I/O area already used.\n"
argument_list|)
expr_stmt|;
return|return
name|ATTACH_RET
return|;
block|}
comment|/* set buffers to NULL */
name|voices
operator|=
name|NULL
expr_stmt|;
name|channels
operator|=
name|NULL
expr_stmt|;
name|sflists
operator|=
name|NULL
expr_stmt|;
name|samples
operator|=
name|NULL
expr_stmt|;
name|infos
operator|=
name|NULL
expr_stmt|;
comment|/* voice& channel info */
name|voices
operator|=
operator|(
name|voice_info
operator|*
operator|)
name|my_malloc
argument_list|(
name|AWE_MAX_VOICES
operator|*
sizeof|sizeof
argument_list|(
name|voice_info
argument_list|)
argument_list|)
expr_stmt|;
name|channels
operator|=
operator|(
name|awe_chan_info
operator|*
operator|)
name|my_malloc
argument_list|(
name|AWE_MAX_CHANNELS
operator|*
sizeof|sizeof
argument_list|(
name|awe_chan_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|voices
operator|==
name|NULL
operator|||
name|channels
operator|==
name|NULL
condition|)
block|{
name|my_free
argument_list|(
name|voices
argument_list|)
expr_stmt|;
name|my_free
argument_list|(
name|channels
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|"AWE32: can't allocate sample tables\n"
argument_list|)
expr_stmt|;
return|return
name|ATTACH_RET
return|;
block|}
comment|/* allocate sample tables */
name|INIT_TABLE
argument_list|(
name|sflists
argument_list|,
name|max_sfs
argument_list|,
name|AWE_MAX_SF_LISTS
argument_list|,
name|sf_list
argument_list|)
expr_stmt|;
name|INIT_TABLE
argument_list|(
name|samples
argument_list|,
name|max_samples
argument_list|,
name|AWE_MAX_SAMPLES
argument_list|,
name|awe_sample_list
argument_list|)
expr_stmt|;
name|INIT_TABLE
argument_list|(
name|infos
argument_list|,
name|max_infos
argument_list|,
name|AWE_MAX_INFOS
argument_list|,
name|awe_voice_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_synths
operator|>=
name|MAX_SYNTH_DEV
condition|)
name|printk
argument_list|(
literal|"AWE32 Error: too many synthesizers\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|voice_alloc
operator|=
operator|&
name|awe_operations
operator|.
name|alloc
expr_stmt|;
name|voice_alloc
operator|->
name|max_voice
operator|=
name|awe_max_voices
expr_stmt|;
name|synth_devs
index|[
name|num_synths
operator|++
index|]
operator|=
operator|&
name|awe_operations
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|CONFIG_AWE32_MIXER
if|if
condition|(
name|num_mixers
operator|<
name|MAX_MIXER_DEV
condition|)
block|{
name|mixer_devs
index|[
name|num_mixers
operator|++
index|]
operator|=
operator|&
name|awe_mixer_operations
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* reserve I/O ports for awedrv */
name|awe_request_region
argument_list|()
expr_stmt|;
comment|/* clear all samples */
name|awe_reset_samples
argument_list|()
expr_stmt|;
comment|/* intialize AWE32 hardware */
name|awe_initialize
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|awe_info
operator|.
name|name
argument_list|,
literal|"AWE32-%s (RAM%dk)"
argument_list|,
name|AWEDRV_VERSION
argument_list|,
name|awe_mem_size
operator|/
literal|1024
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|printk
argument_list|(
literal|"awe0:<SoundBlaster EMU8000 MIDI (RAM%dk)>"
argument_list|,
name|awe_mem_size
operator|/
literal|1024
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|AWE_DEBUG_ON
argument_list|)
name|printk
argument_list|(
literal|"%s\n"
argument_list|,
name|awe_info
operator|.
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* set default values */
name|awe_init_misc_modes
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
comment|/* set reverb& chorus modes */
name|awe_set_reverb_mode
argument_list|(
name|reverb_mode
argument_list|)
expr_stmt|;
name|awe_set_chorus_mode
argument_list|(
name|chorus_mode
argument_list|)
expr_stmt|;
name|awe_present
operator|=
name|TRUE
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
return|return
name|ATTACH_RET
return|;
block|}
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|AWE_DYNAMIC_BUFFER
end_ifdef

begin_function
specifier|static
name|void
name|free_tables
parameter_list|(
name|void
parameter_list|)
block|{
name|my_free
argument_list|(
name|sflists
argument_list|)
expr_stmt|;
name|sflists
operator|=
name|NULL
expr_stmt|;
name|max_sfs
operator|=
literal|0
expr_stmt|;
name|my_free
argument_list|(
name|samples
argument_list|)
expr_stmt|;
name|samples
operator|=
name|NULL
expr_stmt|;
name|max_samples
operator|=
literal|0
expr_stmt|;
name|my_free
argument_list|(
name|infos
argument_list|)
expr_stmt|;
name|infos
operator|=
name|NULL
expr_stmt|;
name|max_infos
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|free_buffers
parameter_list|()
end_define

begin_comment
comment|/**/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|linux
end_ifdef

begin_function
name|ATTACH_DECL
name|void
name|unload_awe
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|awe_present
condition|)
block|{
name|awe_reset_samples
argument_list|()
expr_stmt|;
name|awe_release_region
argument_list|()
expr_stmt|;
name|my_free
argument_list|(
name|voices
argument_list|)
expr_stmt|;
name|my_free
argument_list|(
name|channels
argument_list|)
expr_stmt|;
name|free_tables
argument_list|()
expr_stmt|;
name|awe_present
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*----------------------------------------------------------------  * old type interface  *----------------------------------------------------------------*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AWE_OBSOLETE_VOXWARE
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_decl_stmt
name|long
name|attach_awe_obsolete
argument_list|(
name|long
name|mem_start
argument_list|,
expr|struct
name|address_info
operator|*
name|hw_config
argument_list|)
else|#
directive|else
name|int
name|attach_awe_obsolete
argument_list|(
name|int
name|mem_start
argument_list|,
expr|struct
name|address_info
operator|*
name|hw_config
argument_list|)
endif|#
directive|endif
block|{
name|my_malloc_init
argument_list|(
name|mem_start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attach_awe
argument_list|()
condition|)
return|return
literal|0
return|;
return|return
name|my_malloc_memptr
argument_list|()
return|;
block|}
end_decl_stmt

begin_function
name|int
name|probe_awe_obsolete
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
return|return
literal|1
return|;
comment|/*return awe_detect();*/
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_function
name|int
name|probe_awe
parameter_list|(
name|struct
name|address_info
modifier|*
name|hw_config
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AWE_OBSOLETE_VOXWARE */
end_comment

begin_comment
comment|/*================================================================  * clear sample tables   *================================================================*/
end_comment

begin_function
specifier|static
name|void
name|awe_reset_samples
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* free all bank tables */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_MAX_PRESETS
condition|;
name|i
operator|++
control|)
name|preset_table
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|free_tables
argument_list|()
expr_stmt|;
name|current_sf_id
operator|=
literal|0
expr_stmt|;
name|locked_sf_id
operator|=
literal|0
expr_stmt|;
name|patch_opened
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*================================================================  * EMU register access  *================================================================*/
end_comment

begin_comment
comment|/* select a given AWE32 pointer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|awe_cur_cmd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|awe_set_cmd
parameter_list|(
name|cmd
parameter_list|)
define|\
value|if (awe_cur_cmd != cmd) { OUTW(cmd, awe_base + 0x802); awe_cur_cmd = cmd; }
end_define

begin_define
define|#
directive|define
name|awe_port
parameter_list|(
name|port
parameter_list|)
value|(awe_base - 0x620 + port)
end_define

begin_comment
comment|/* write 16bit data */
end_comment

begin_function
name|INLINE
specifier|static
name|void
name|awe_poke
parameter_list|(
name|unsigned
name|short
name|cmd
parameter_list|,
name|unsigned
name|short
name|port
parameter_list|,
name|unsigned
name|short
name|data
parameter_list|)
block|{
name|awe_set_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|OUTW
argument_list|(
name|data
argument_list|,
name|awe_port
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* write 32bit data */
end_comment

begin_function
name|INLINE
specifier|static
name|void
name|awe_poke_dw
parameter_list|(
name|unsigned
name|short
name|cmd
parameter_list|,
name|unsigned
name|short
name|port
parameter_list|,
name|unsigned
name|int
name|data
parameter_list|)
block|{
name|awe_set_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|OUTW
argument_list|(
name|data
argument_list|,
name|awe_port
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
comment|/* write lower 16 bits */
name|OUTW
argument_list|(
name|data
operator|>>
literal|16
argument_list|,
name|awe_port
argument_list|(
name|port
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* write higher 16 bits */
block|}
end_function

begin_comment
comment|/* read 16bit data */
end_comment

begin_function
name|INLINE
specifier|static
name|unsigned
name|short
name|awe_peek
parameter_list|(
name|unsigned
name|short
name|cmd
parameter_list|,
name|unsigned
name|short
name|port
parameter_list|)
block|{
name|unsigned
name|short
name|k
decl_stmt|;
name|awe_set_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|k
operator|=
name|inw
argument_list|(
name|awe_port
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|k
return|;
block|}
end_function

begin_comment
comment|/* read 32bit data */
end_comment

begin_function
name|INLINE
specifier|static
name|unsigned
name|int
name|awe_peek_dw
parameter_list|(
name|unsigned
name|short
name|cmd
parameter_list|,
name|unsigned
name|short
name|port
parameter_list|)
block|{
name|unsigned
name|int
name|k1
decl_stmt|,
name|k2
decl_stmt|;
name|awe_set_cmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|k1
operator|=
name|inw
argument_list|(
name|awe_port
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|k2
operator|=
name|inw
argument_list|(
name|awe_port
argument_list|(
name|port
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|k1
operator||=
name|k2
operator|<<
literal|16
expr_stmt|;
return|return
name|k1
return|;
block|}
end_function

begin_comment
comment|/* wait delay number of AWE32 44100Hz clocks */
end_comment

begin_function
specifier|static
name|void
name|awe_wait
parameter_list|(
name|unsigned
name|short
name|delay
parameter_list|)
block|{
name|unsigned
name|short
name|clock
decl_stmt|,
name|target
decl_stmt|;
name|unsigned
name|short
name|port
init|=
name|awe_port
argument_list|(
name|AWE_WC_Port
argument_list|)
decl_stmt|;
name|int
name|counter
decl_stmt|;
comment|/* sample counter */
name|awe_set_cmd
argument_list|(
name|AWE_WC_Cmd
argument_list|)
expr_stmt|;
name|clock
operator|=
operator|(
name|unsigned
name|short
operator|)
name|inw
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|target
operator|=
name|clock
operator|+
name|delay
expr_stmt|;
name|counter
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|target
operator|<
name|clock
condition|)
block|{
for|for
control|(
init|;
operator|(
name|unsigned
name|short
operator|)
name|inw
argument_list|(
name|port
argument_list|)
operator|>
name|target
condition|;
name|counter
operator|++
control|)
if|if
condition|(
name|counter
operator|>
literal|65536
condition|)
break|break;
block|}
for|for
control|(
init|;
operator|(
name|unsigned
name|short
operator|)
name|inw
argument_list|(
name|port
argument_list|)
operator|<
name|target
condition|;
name|counter
operator|++
control|)
if|if
condition|(
name|counter
operator|>
literal|65536
condition|)
break|break;
block|}
end_function

begin_comment
comment|/* write a word data */
end_comment

begin_function
name|INLINE
specifier|static
name|void
name|awe_write_dram
parameter_list|(
name|unsigned
name|short
name|c
parameter_list|)
block|{
name|awe_poke
argument_list|(
name|AWE_SMLD
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|linux
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|AWE_OBSOLETE_VOXWARE
argument_list|)
end_if

begin_comment
comment|/*================================================================  * port check / request  *  0x620-622, 0xA20-A22, 0xE20-E22  *================================================================*/
end_comment

begin_function
specifier|static
name|int
name|awe_check_port
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|check_region
argument_list|(
name|awe_port
argument_list|(
name|Data0
argument_list|)
argument_list|,
literal|4
argument_list|)
operator|||
name|check_region
argument_list|(
name|awe_port
argument_list|(
name|Data1
argument_list|)
argument_list|,
literal|4
argument_list|)
operator|||
name|check_region
argument_list|(
name|awe_port
argument_list|(
name|Data3
argument_list|)
argument_list|,
literal|4
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|awe_request_region
parameter_list|(
name|void
parameter_list|)
block|{
name|request_region
argument_list|(
name|awe_port
argument_list|(
name|Data0
argument_list|)
argument_list|,
literal|4
argument_list|,
literal|"sound driver (AWE32)"
argument_list|)
expr_stmt|;
name|request_region
argument_list|(
name|awe_port
argument_list|(
name|Data1
argument_list|)
argument_list|,
literal|4
argument_list|,
literal|"sound driver (AWE32)"
argument_list|)
expr_stmt|;
name|request_region
argument_list|(
name|awe_port
argument_list|(
name|Data3
argument_list|)
argument_list|,
literal|4
argument_list|,
literal|"sound driver (AWE32)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|awe_release_region
parameter_list|(
name|void
parameter_list|)
block|{
name|release_region
argument_list|(
name|awe_port
argument_list|(
name|Data0
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|release_region
argument_list|(
name|awe_port
argument_list|(
name|Data1
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|release_region
argument_list|(
name|awe_port
argument_list|(
name|Data3
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !AWE_OBSOLETE_VOXWARE */
end_comment

begin_comment
comment|/*================================================================  * AWE32 initialization  *================================================================*/
end_comment

begin_function
specifier|static
name|void
name|awe_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: initializing..\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* initialize hardware configuration */
name|awe_poke
argument_list|(
name|AWE_HWCF1
argument_list|,
literal|0x0059
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_HWCF2
argument_list|,
literal|0x0020
argument_list|)
expr_stmt|;
comment|/* disable audio; this seems to reduce a clicking noise a bit.. */
name|awe_poke
argument_list|(
name|AWE_HWCF3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* initialize audio channels */
name|awe_init_audio
argument_list|()
expr_stmt|;
comment|/* initialize DMA */
name|awe_init_dma
argument_list|()
expr_stmt|;
comment|/* initialize init array */
name|awe_init_array
argument_list|()
expr_stmt|;
comment|/* check DRAM memory size */
name|awe_mem_size
operator|=
name|awe_check_dram
argument_list|()
expr_stmt|;
comment|/* initialize the FM section of the AWE32 */
name|awe_init_fm
argument_list|()
expr_stmt|;
comment|/* set up voice envelopes */
name|awe_tweak
argument_list|()
expr_stmt|;
comment|/* enable audio */
name|awe_poke
argument_list|(
name|AWE_HWCF3
argument_list|,
literal|0x0004
argument_list|)
expr_stmt|;
comment|/* set equalizer */
name|awe_equalizer
argument_list|(
literal|5
argument_list|,
literal|9
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*================================================================  * AWE32 voice parameters  *================================================================*/
end_comment

begin_comment
comment|/* initialize voice_info record */
end_comment

begin_function
specifier|static
name|void
name|awe_init_voice_info
parameter_list|(
name|awe_voice_info
modifier|*
name|vp
parameter_list|)
block|{
name|vp
operator|->
name|sf_id
operator|=
literal|0
expr_stmt|;
comment|/* normal mode */
name|vp
operator|->
name|sample
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|rate_offset
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|start
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|end
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|loopstart
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|loopend
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|mode
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|root
operator|=
literal|60
expr_stmt|;
name|vp
operator|->
name|tune
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|low
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|high
operator|=
literal|127
expr_stmt|;
name|vp
operator|->
name|vellow
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|velhigh
operator|=
literal|127
expr_stmt|;
name|vp
operator|->
name|fixkey
operator|=
operator|-
literal|1
expr_stmt|;
name|vp
operator|->
name|fixvel
operator|=
operator|-
literal|1
expr_stmt|;
name|vp
operator|->
name|fixpan
operator|=
operator|-
literal|1
expr_stmt|;
name|vp
operator|->
name|pan
operator|=
operator|-
literal|1
expr_stmt|;
name|vp
operator|->
name|exclusiveClass
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|amplitude
operator|=
literal|127
expr_stmt|;
name|vp
operator|->
name|attenuation
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|scaleTuning
operator|=
literal|100
expr_stmt|;
name|awe_init_voice_parm
argument_list|(
operator|&
name|vp
operator|->
name|parm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* initialize voice_parm record:  * Env1/2: delay=0, attack=0, hold=0, sustain=0, decay=0, release=0.  * Vibrato and Tremolo effects are zero.  * Cutoff is maximum.  * Chorus and Reverb effects are zero.  */
end_comment

begin_function
specifier|static
name|void
name|awe_init_voice_parm
parameter_list|(
name|awe_voice_parm
modifier|*
name|pp
parameter_list|)
block|{
name|pp
operator|->
name|moddelay
operator|=
literal|0x8000
expr_stmt|;
name|pp
operator|->
name|modatkhld
operator|=
literal|0x7f7f
expr_stmt|;
name|pp
operator|->
name|moddcysus
operator|=
literal|0x7f7f
expr_stmt|;
name|pp
operator|->
name|modrelease
operator|=
literal|0x807f
expr_stmt|;
name|pp
operator|->
name|modkeyhold
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|modkeydecay
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|voldelay
operator|=
literal|0x8000
expr_stmt|;
name|pp
operator|->
name|volatkhld
operator|=
literal|0x7f7f
expr_stmt|;
name|pp
operator|->
name|voldcysus
operator|=
literal|0x7f7f
expr_stmt|;
name|pp
operator|->
name|volrelease
operator|=
literal|0x807f
expr_stmt|;
name|pp
operator|->
name|volkeyhold
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|volkeydecay
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|lfo1delay
operator|=
literal|0x8000
expr_stmt|;
name|pp
operator|->
name|lfo2delay
operator|=
literal|0x8000
expr_stmt|;
name|pp
operator|->
name|pefe
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|fmmod
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|tremfrq
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|fm2frq2
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|cutoff
operator|=
literal|0xff
expr_stmt|;
name|pp
operator|->
name|filterQ
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|chorus
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|reverb
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AWE_HAS_GUS_COMPATIBILITY
end_ifdef

begin_comment
comment|/* convert frequency mHz to abstract cents (= midi key * 100) */
end_comment

begin_function
specifier|static
name|int
name|freq_to_note
parameter_list|(
name|int
name|mHz
parameter_list|)
block|{
comment|/* abscents = log(mHz/8176) / log(2) * 1200 */
name|unsigned
name|int
name|max_val
init|=
operator|(
name|unsigned
name|int
operator|)
literal|0xffffffff
operator|/
literal|10000
decl_stmt|;
name|int
name|i
decl_stmt|,
name|times
decl_stmt|;
name|unsigned
name|int
name|base
decl_stmt|;
name|unsigned
name|int
name|freq
decl_stmt|;
name|int
name|note
decl_stmt|,
name|tune
decl_stmt|;
if|if
condition|(
name|mHz
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|mHz
operator|<
literal|0
condition|)
return|return
literal|12799
return|;
comment|/* maximum */
name|freq
operator|=
name|mHz
expr_stmt|;
name|note
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|base
operator|=
literal|8176
operator|*
literal|2
init|;
name|freq
operator|>=
name|base
condition|;
name|base
operator|*=
literal|2
control|)
block|{
name|note
operator|+=
literal|12
expr_stmt|;
if|if
condition|(
name|note
operator|>=
literal|128
condition|)
comment|/* over maximum */
return|return
literal|12799
return|;
block|}
name|base
operator|/=
literal|2
expr_stmt|;
comment|/* to avoid overflow... */
name|times
operator|=
literal|10000
expr_stmt|;
while|while
condition|(
name|freq
operator|>
name|max_val
condition|)
block|{
name|max_val
operator|*=
literal|10
expr_stmt|;
name|times
operator|/=
literal|10
expr_stmt|;
name|base
operator|/=
literal|10
expr_stmt|;
block|}
name|freq
operator|=
name|freq
operator|*
name|times
operator|/
name|base
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|freq
operator|<
name|semitone_tuning
index|[
name|i
operator|+
literal|1
index|]
condition|)
break|break;
name|note
operator|++
expr_stmt|;
block|}
name|tune
operator|=
literal|0
expr_stmt|;
name|freq
operator|=
name|freq
operator|*
literal|10000
operator|/
name|semitone_tuning
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|freq
operator|<
name|cent_tuning
index|[
name|i
operator|+
literal|1
index|]
condition|)
break|break;
name|tune
operator|++
expr_stmt|;
block|}
return|return
name|note
operator|*
literal|100
operator|+
name|tune
return|;
block|}
end_function

begin_comment
comment|/* convert Hz to AWE32 rate offset:  * sample pitch offset for the specified sample rate  * rate=44100 is no offset, each 4096 is 1 octave (twice).  * eg, when rate is 22050, this offset becomes -4096.  */
end_comment

begin_function
specifier|static
name|int
name|calc_rate_offset
parameter_list|(
name|int
name|Hz
parameter_list|)
block|{
comment|/* offset = log(Hz / 44100) / log(2) * 4096 */
name|int
name|freq
decl_stmt|,
name|base
decl_stmt|,
name|i
decl_stmt|;
comment|/* maybe smaller than max (44100Hz) */
if|if
condition|(
name|Hz
operator|<=
literal|0
operator|||
name|Hz
operator|>=
literal|44100
condition|)
return|return
literal|0
return|;
name|base
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|freq
operator|=
name|Hz
operator|*
literal|2
init|;
name|freq
operator|<
literal|44100
condition|;
name|freq
operator|*=
literal|2
control|)
name|base
operator|++
expr_stmt|;
name|base
operator|*=
literal|1200
expr_stmt|;
name|freq
operator|=
literal|44100
operator|*
literal|10000
operator|/
operator|(
name|freq
operator|/
literal|2
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|12
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|freq
operator|<
name|semitone_tuning
index|[
name|i
operator|+
literal|1
index|]
condition|)
break|break;
name|base
operator|+=
literal|100
expr_stmt|;
block|}
name|freq
operator|=
name|freq
operator|*
literal|10000
operator|/
name|semitone_tuning
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|freq
operator|<
name|cent_tuning
index|[
name|i
operator|+
literal|1
index|]
condition|)
break|break;
name|base
operator|++
expr_stmt|;
block|}
return|return
operator|-
name|base
operator|*
literal|4096
operator|/
literal|1200
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------  * convert envelope time parameter to AWE32 raw parameter  *----------------------------------------------------------------*/
end_comment

begin_comment
comment|/* attack& decay/release time table (msec) */
end_comment

begin_decl_stmt
specifier|static
name|short
name|attack_time_tbl
index|[
literal|128
index|]
init|=
block|{
literal|32767
block|,
literal|11878
block|,
literal|5939
block|,
literal|3959
block|,
literal|2969
block|,
literal|2375
block|,
literal|1979
block|,
literal|1696
block|,
literal|1484
block|,
literal|1319
block|,
literal|1187
block|,
literal|1079
block|,
literal|989
block|,
literal|913
block|,
literal|848
block|,
literal|791
block|,
literal|742
block|,
literal|698
block|,
literal|659
block|,
literal|625
block|,
literal|593
block|,
literal|565
block|,
literal|539
block|,
literal|516
block|,
literal|494
block|,
literal|475
block|,
literal|456
block|,
literal|439
block|,
literal|424
block|,
literal|409
block|,
literal|395
block|,
literal|383
block|,
literal|371
block|,
literal|359
block|,
literal|344
block|,
literal|330
block|,
literal|316
block|,
literal|302
block|,
literal|290
block|,
literal|277
block|,
literal|266
block|,
literal|255
block|,
literal|244
block|,
literal|233
block|,
literal|224
block|,
literal|214
block|,
literal|205
block|,
literal|196
block|,
literal|188
block|,
literal|180
block|,
literal|173
block|,
literal|165
block|,
literal|158
block|,
literal|152
block|,
literal|145
block|,
literal|139
block|,
literal|133
block|,
literal|127
block|,
literal|122
block|,
literal|117
block|,
literal|112
block|,
literal|107
block|,
literal|103
block|,
literal|98
block|,
literal|94
block|,
literal|90
block|,
literal|86
block|,
literal|83
block|,
literal|79
block|,
literal|76
block|,
literal|73
block|,
literal|69
block|,
literal|67
block|,
literal|64
block|,
literal|61
block|,
literal|58
block|,
literal|56
block|,
literal|54
block|,
literal|51
block|,
literal|49
block|,
literal|47
block|,
literal|45
block|,
literal|43
block|,
literal|41
block|,
literal|39
block|,
literal|38
block|,
literal|36
block|,
literal|35
block|,
literal|33
block|,
literal|32
block|,
literal|30
block|,
literal|29
block|,
literal|28
block|,
literal|27
block|,
literal|25
block|,
literal|24
block|,
literal|23
block|,
literal|22
block|,
literal|21
block|,
literal|20
block|,
literal|20
block|,
literal|19
block|,
literal|18
block|,
literal|17
block|,
literal|16
block|,
literal|16
block|,
literal|15
block|,
literal|14
block|,
literal|14
block|,
literal|13
block|,
literal|13
block|,
literal|12
block|,
literal|11
block|,
literal|11
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|9
block|,
literal|9
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|6
block|,
literal|6
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|short
name|decay_time_tbl
index|[
literal|128
index|]
init|=
block|{
literal|32767
block|,
literal|32766
block|,
literal|4589
block|,
literal|4400
block|,
literal|4219
block|,
literal|4045
block|,
literal|3879
block|,
literal|3719
block|,
literal|3566
block|,
literal|3419
block|,
literal|3279
block|,
literal|3144
block|,
literal|3014
block|,
literal|2890
block|,
literal|2771
block|,
literal|2657
block|,
literal|2548
block|,
literal|2443
block|,
literal|2343
block|,
literal|2246
block|,
literal|2154
block|,
literal|2065
block|,
literal|1980
block|,
literal|1899
block|,
literal|1820
block|,
literal|1746
block|,
literal|1674
block|,
literal|1605
block|,
literal|1539
block|,
literal|1475
block|,
literal|1415
block|,
literal|1356
block|,
literal|1301
block|,
literal|1247
block|,
literal|1196
block|,
literal|1146
block|,
literal|1099
block|,
literal|1054
block|,
literal|1011
block|,
literal|969
block|,
literal|929
block|,
literal|891
block|,
literal|854
block|,
literal|819
block|,
literal|785
block|,
literal|753
block|,
literal|722
block|,
literal|692
block|,
literal|664
block|,
literal|636
block|,
literal|610
block|,
literal|585
block|,
literal|561
block|,
literal|538
block|,
literal|516
block|,
literal|494
block|,
literal|474
block|,
literal|455
block|,
literal|436
block|,
literal|418
block|,
literal|401
block|,
literal|384
block|,
literal|368
block|,
literal|353
block|,
literal|339
block|,
literal|325
block|,
literal|311
block|,
literal|298
block|,
literal|286
block|,
literal|274
block|,
literal|263
block|,
literal|252
block|,
literal|242
block|,
literal|232
block|,
literal|222
block|,
literal|213
block|,
literal|204
block|,
literal|196
block|,
literal|188
block|,
literal|180
block|,
literal|173
block|,
literal|166
block|,
literal|159
block|,
literal|152
block|,
literal|146
block|,
literal|140
block|,
literal|134
block|,
literal|129
block|,
literal|123
block|,
literal|118
block|,
literal|113
block|,
literal|109
block|,
literal|104
block|,
literal|100
block|,
literal|96
block|,
literal|92
block|,
literal|88
block|,
literal|84
block|,
literal|81
block|,
literal|77
block|,
literal|74
block|,
literal|71
block|,
literal|68
block|,
literal|65
block|,
literal|63
block|,
literal|60
block|,
literal|58
block|,
literal|55
block|,
literal|53
block|,
literal|51
block|,
literal|49
block|,
literal|47
block|,
literal|45
block|,
literal|43
block|,
literal|41
block|,
literal|39
block|,
literal|38
block|,
literal|36
block|,
literal|35
block|,
literal|33
block|,
literal|32
block|,
literal|30
block|,
literal|29
block|,
literal|28
block|,
literal|27
block|,
literal|26
block|,
literal|25
block|,
literal|24
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static int calc_parm_delay(int msec) { 	return (0x8000 - msec * 1000 / 725); } */
end_comment

begin_comment
comment|/* delay time = 0x8000 - msec/92 */
end_comment

begin_function
specifier|static
name|int
name|calc_parm_hold
parameter_list|(
name|int
name|msec
parameter_list|)
block|{
name|int
name|val
init|=
operator|(
literal|0x7f
operator|*
literal|92
operator|-
name|msec
operator|)
operator|/
literal|92
decl_stmt|;
if|if
condition|(
name|val
operator|<
literal|1
condition|)
name|val
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|val
operator|>
literal|127
condition|)
name|val
operator|=
literal|127
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* attack time: search from time table */
end_comment

begin_function
specifier|static
name|int
name|calc_parm_attack
parameter_list|(
name|int
name|msec
parameter_list|)
block|{
return|return
name|calc_parm_search
argument_list|(
name|msec
argument_list|,
name|attack_time_tbl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* decay/release time: search from time table */
end_comment

begin_function
specifier|static
name|int
name|calc_parm_decay
parameter_list|(
name|int
name|msec
parameter_list|)
block|{
return|return
name|calc_parm_search
argument_list|(
name|msec
argument_list|,
name|decay_time_tbl
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* search an index for specified time from given time table */
end_comment

begin_function
specifier|static
name|int
name|calc_parm_search
parameter_list|(
name|int
name|msec
parameter_list|,
name|short
modifier|*
name|table
parameter_list|)
block|{
name|int
name|left
init|=
literal|1
decl_stmt|,
name|right
init|=
literal|127
decl_stmt|,
name|mid
decl_stmt|;
while|while
condition|(
name|left
operator|<
name|right
condition|)
block|{
name|mid
operator|=
operator|(
name|left
operator|+
name|right
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|msec
operator|<
operator|(
name|int
operator|)
name|table
index|[
name|mid
index|]
condition|)
name|left
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
name|right
operator|=
name|mid
expr_stmt|;
block|}
return|return
name|left
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AWE_HAS_GUS_COMPATIBILITY */
end_comment

begin_comment
comment|/*================================================================  * effects table  *================================================================*/
end_comment

begin_comment
comment|/* set an effect value */
end_comment

begin_define
define|#
directive|define
name|FX_FLAG_OFF
value|0
end_define

begin_define
define|#
directive|define
name|FX_FLAG_SET
value|1
end_define

begin_define
define|#
directive|define
name|FX_FLAG_ADD
value|2
end_define

begin_define
define|#
directive|define
name|FX_SET
parameter_list|(
name|rec
parameter_list|,
name|type
parameter_list|,
name|value
parameter_list|)
define|\
value|((rec)->flags[type] = FX_FLAG_SET, (rec)->val[type] = (value))
end_define

begin_define
define|#
directive|define
name|FX_ADD
parameter_list|(
name|rec
parameter_list|,
name|type
parameter_list|,
name|value
parameter_list|)
define|\
value|((rec)->flags[type] = FX_FLAG_ADD, (rec)->val[type] = (value))
end_define

begin_define
define|#
directive|define
name|FX_UNSET
parameter_list|(
name|rec
parameter_list|,
name|type
parameter_list|)
define|\
value|((rec)->flags[type] = FX_FLAG_OFF, (rec)->val[type] = 0)
end_define

begin_comment
comment|/* check the effect value is set */
end_comment

begin_define
define|#
directive|define
name|FX_ON
parameter_list|(
name|rec
parameter_list|,
name|type
parameter_list|)
value|((rec)->flags[type])
end_define

begin_define
define|#
directive|define
name|PARM_BYTE
value|0
end_define

begin_define
define|#
directive|define
name|PARM_WORD
value|1
end_define

begin_struct
specifier|static
struct|struct
name|PARM_DEFS
block|{
name|int
name|type
decl_stmt|;
comment|/* byte or word */
name|int
name|low
decl_stmt|,
name|high
decl_stmt|;
comment|/* value range */
name|fx_affect_func
name|realtime
decl_stmt|;
comment|/* realtime paramater change */
block|}
name|parm_defs
index|[]
init|=
block|{
block|{
name|PARM_WORD
block|,
literal|0
block|,
literal|0x8000
block|,
name|NULL
block|}
block|,
comment|/* env1 delay */
block|{
name|PARM_BYTE
block|,
literal|1
block|,
literal|0x7f
block|,
name|NULL
block|}
block|,
comment|/* env1 attack */
block|{
name|PARM_BYTE
block|,
literal|0
block|,
literal|0x7e
block|,
name|NULL
block|}
block|,
comment|/* env1 hold */
block|{
name|PARM_BYTE
block|,
literal|1
block|,
literal|0x7f
block|,
name|NULL
block|}
block|,
comment|/* env1 decay */
block|{
name|PARM_BYTE
block|,
literal|1
block|,
literal|0x7f
block|,
name|NULL
block|}
block|,
comment|/* env1 release */
block|{
name|PARM_BYTE
block|,
literal|0
block|,
literal|0x7f
block|,
name|NULL
block|}
block|,
comment|/* env1 sustain */
block|{
name|PARM_BYTE
block|,
literal|0
block|,
literal|0xff
block|,
name|NULL
block|}
block|,
comment|/* env1 pitch */
block|{
name|PARM_BYTE
block|,
literal|0
block|,
literal|0xff
block|,
name|NULL
block|}
block|,
comment|/* env1 cutoff */
block|{
name|PARM_WORD
block|,
literal|0
block|,
literal|0x8000
block|,
name|NULL
block|}
block|,
comment|/* env2 delay */
block|{
name|PARM_BYTE
block|,
literal|1
block|,
literal|0x7f
block|,
name|NULL
block|}
block|,
comment|/* env2 attack */
block|{
name|PARM_BYTE
block|,
literal|0
block|,
literal|0x7e
block|,
name|NULL
block|}
block|,
comment|/* env2 hold */
block|{
name|PARM_BYTE
block|,
literal|1
block|,
literal|0x7f
block|,
name|NULL
block|}
block|,
comment|/* env2 decay */
block|{
name|PARM_BYTE
block|,
literal|1
block|,
literal|0x7f
block|,
name|NULL
block|}
block|,
comment|/* env2 release */
block|{
name|PARM_BYTE
block|,
literal|0
block|,
literal|0x7f
block|,
name|NULL
block|}
block|,
comment|/* env2 sustain */
block|{
name|PARM_WORD
block|,
literal|0
block|,
literal|0x8000
block|,
name|NULL
block|}
block|,
comment|/* lfo1 delay */
block|{
name|PARM_BYTE
block|,
literal|0
block|,
literal|0xff
block|,
name|awe_fx_tremfrq
block|}
block|,
comment|/* lfo1 freq */
block|{
name|PARM_BYTE
block|,
literal|0
block|,
literal|0x7f
block|,
name|awe_fx_tremfrq
block|}
block|,
comment|/* lfo1 volume (positive only)*/
block|{
name|PARM_BYTE
block|,
literal|0
block|,
literal|0x7f
block|,
name|awe_fx_fmmod
block|}
block|,
comment|/* lfo1 pitch (positive only)*/
block|{
name|PARM_BYTE
block|,
literal|0
block|,
literal|0xff
block|,
name|awe_fx_fmmod
block|}
block|,
comment|/* lfo1 cutoff (positive only)*/
block|{
name|PARM_WORD
block|,
literal|0
block|,
literal|0x8000
block|,
name|NULL
block|}
block|,
comment|/* lfo2 delay */
block|{
name|PARM_BYTE
block|,
literal|0
block|,
literal|0xff
block|,
name|awe_fx_fm2frq2
block|}
block|,
comment|/* lfo2 freq */
block|{
name|PARM_BYTE
block|,
literal|0
block|,
literal|0x7f
block|,
name|awe_fx_fm2frq2
block|}
block|,
comment|/* lfo2 pitch (positive only)*/
block|{
name|PARM_WORD
block|,
literal|0
block|,
literal|0xffff
block|,
name|awe_set_voice_pitch
block|}
block|,
comment|/* initial pitch */
block|{
name|PARM_BYTE
block|,
literal|0
block|,
literal|0xff
block|,
name|NULL
block|}
block|,
comment|/* chorus */
block|{
name|PARM_BYTE
block|,
literal|0
block|,
literal|0xff
block|,
name|NULL
block|}
block|,
comment|/* reverb */
block|{
name|PARM_BYTE
block|,
literal|0
block|,
literal|0xff
block|,
name|awe_set_volume
block|}
block|,
comment|/* initial cutoff */
block|{
name|PARM_BYTE
block|,
literal|0
block|,
literal|15
block|,
name|awe_fx_filterQ
block|}
block|,
comment|/* initial resonance */
block|{
name|PARM_WORD
block|,
literal|0
block|,
literal|0xffff
block|,
name|NULL
block|}
block|,
comment|/* sample start */
block|{
name|PARM_WORD
block|,
literal|0
block|,
literal|0xffff
block|,
name|NULL
block|}
block|,
comment|/* loop start */
block|{
name|PARM_WORD
block|,
literal|0
block|,
literal|0xffff
block|,
name|NULL
block|}
block|,
comment|/* loop end */
block|{
name|PARM_WORD
block|,
literal|0
block|,
literal|0xffff
block|,
name|NULL
block|}
block|,
comment|/* coarse sample start */
block|{
name|PARM_WORD
block|,
literal|0
block|,
literal|0xffff
block|,
name|NULL
block|}
block|,
comment|/* coarse loop start */
block|{
name|PARM_WORD
block|,
literal|0
block|,
literal|0xffff
block|,
name|NULL
block|}
block|,
comment|/* coarse loop end */
block|{
name|PARM_BYTE
block|,
literal|0
block|,
literal|0xff
block|,
name|awe_set_volume
block|}
block|,
comment|/* initial attenuation */
block|}
struct|;
end_struct

begin_function
specifier|static
name|unsigned
name|char
name|FX_BYTE
parameter_list|(
name|FX_Rec
modifier|*
name|rec
parameter_list|,
name|FX_Rec
modifier|*
name|lay
parameter_list|,
name|int
name|type
parameter_list|,
name|unsigned
name|char
name|value
parameter_list|)
block|{
name|int
name|effect
init|=
literal|0
decl_stmt|;
name|int
name|on
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lay
operator|&&
operator|(
name|on
operator|=
name|FX_ON
argument_list|(
name|lay
argument_list|,
name|type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|effect
operator|=
name|lay
operator|->
name|val
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|on
operator|&&
operator|(
name|on
operator|=
name|FX_ON
argument_list|(
name|rec
argument_list|,
name|type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|effect
operator|=
name|rec
operator|->
name|val
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|on
operator|==
name|FX_FLAG_ADD
condition|)
name|effect
operator|+=
operator|(
name|int
operator|)
name|value
expr_stmt|;
if|if
condition|(
name|on
condition|)
block|{
if|if
condition|(
name|effect
operator|<
name|parm_defs
index|[
name|type
index|]
operator|.
name|low
condition|)
name|effect
operator|=
name|parm_defs
index|[
name|type
index|]
operator|.
name|low
expr_stmt|;
elseif|else
if|if
condition|(
name|effect
operator|>
name|parm_defs
index|[
name|type
index|]
operator|.
name|high
condition|)
name|effect
operator|=
name|parm_defs
index|[
name|type
index|]
operator|.
name|high
expr_stmt|;
return|return
operator|(
name|unsigned
name|char
operator|)
name|effect
return|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* get word effect value */
end_comment

begin_function
specifier|static
name|unsigned
name|short
name|FX_WORD
parameter_list|(
name|FX_Rec
modifier|*
name|rec
parameter_list|,
name|FX_Rec
modifier|*
name|lay
parameter_list|,
name|int
name|type
parameter_list|,
name|unsigned
name|short
name|value
parameter_list|)
block|{
name|int
name|effect
init|=
literal|0
decl_stmt|;
name|int
name|on
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lay
operator|&&
operator|(
name|on
operator|=
name|FX_ON
argument_list|(
name|lay
argument_list|,
name|type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|effect
operator|=
name|lay
operator|->
name|val
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|on
operator|&&
operator|(
name|on
operator|=
name|FX_ON
argument_list|(
name|rec
argument_list|,
name|type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|effect
operator|=
name|rec
operator|->
name|val
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|on
operator|==
name|FX_FLAG_ADD
condition|)
name|effect
operator|+=
operator|(
name|int
operator|)
name|value
expr_stmt|;
if|if
condition|(
name|on
condition|)
block|{
if|if
condition|(
name|effect
operator|<
name|parm_defs
index|[
name|type
index|]
operator|.
name|low
condition|)
name|effect
operator|=
name|parm_defs
index|[
name|type
index|]
operator|.
name|low
expr_stmt|;
elseif|else
if|if
condition|(
name|effect
operator|>
name|parm_defs
index|[
name|type
index|]
operator|.
name|high
condition|)
name|effect
operator|=
name|parm_defs
index|[
name|type
index|]
operator|.
name|high
expr_stmt|;
return|return
operator|(
name|unsigned
name|short
operator|)
name|effect
return|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/* get word (upper=type1/lower=type2) effect value */
end_comment

begin_function
specifier|static
name|unsigned
name|short
name|FX_COMB
parameter_list|(
name|FX_Rec
modifier|*
name|rec
parameter_list|,
name|FX_Rec
modifier|*
name|lay
parameter_list|,
name|int
name|type1
parameter_list|,
name|int
name|type2
parameter_list|,
name|unsigned
name|short
name|value
parameter_list|)
block|{
name|unsigned
name|short
name|tmp
decl_stmt|;
name|tmp
operator|=
name|FX_BYTE
argument_list|(
name|rec
argument_list|,
name|lay
argument_list|,
name|type1
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
name|value
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|<<=
literal|8
expr_stmt|;
name|tmp
operator||=
name|FX_BYTE
argument_list|(
name|rec
argument_list|,
name|lay
argument_list|,
name|type2
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
name|value
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_comment
comment|/* address offset */
end_comment

begin_function
specifier|static
name|int
name|FX_OFFSET
parameter_list|(
name|FX_Rec
modifier|*
name|rec
parameter_list|,
name|FX_Rec
modifier|*
name|lay
parameter_list|,
name|int
name|lo
parameter_list|,
name|int
name|hi
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|addr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lay
operator|&&
name|FX_ON
argument_list|(
name|lay
argument_list|,
name|hi
argument_list|)
condition|)
name|addr
operator|=
operator|(
name|short
operator|)
name|lay
operator|->
name|val
index|[
name|hi
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|FX_ON
argument_list|(
name|rec
argument_list|,
name|hi
argument_list|)
condition|)
name|addr
operator|=
operator|(
name|short
operator|)
name|rec
operator|->
name|val
index|[
name|hi
index|]
expr_stmt|;
name|addr
operator|=
name|addr
operator|<<
literal|15
expr_stmt|;
if|if
condition|(
name|lay
operator|&&
name|FX_ON
argument_list|(
name|lay
argument_list|,
name|lo
argument_list|)
condition|)
name|addr
operator|+=
operator|(
name|short
operator|)
name|lay
operator|->
name|val
index|[
name|lo
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|FX_ON
argument_list|(
name|rec
argument_list|,
name|lo
argument_list|)
condition|)
name|addr
operator|+=
operator|(
name|short
operator|)
name|rec
operator|->
name|val
index|[
name|lo
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mode
operator|&
name|AWE_SAMPLE_8BITS
operator|)
condition|)
name|addr
operator|/=
literal|2
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/*================================================================  * turn on/off sample  *================================================================*/
end_comment

begin_function
specifier|static
name|void
name|awe_note_on
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|unsigned
name|int
name|temp
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|awe_voice_info
modifier|*
name|vp
decl_stmt|;
name|FX_Rec
modifier|*
name|fx
init|=
operator|&
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
operator|->
name|fx
decl_stmt|;
name|FX_Rec
modifier|*
name|fx_lay
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|layer
operator|<
name|MAX_LAYERS
condition|)
name|fx_lay
operator|=
operator|&
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
operator|->
name|fx_layer
index|[
name|voices
index|[
name|voice
index|]
operator|.
name|layer
index|]
expr_stmt|;
comment|/* A voice sample must assigned before calling */
if|if
condition|(
operator|(
name|vp
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|)
operator|==
name|NULL
operator|||
name|vp
operator|->
name|index
operator|<
literal|0
condition|)
return|return;
comment|/* channel to be silent and idle */
name|awe_poke
argument_list|(
name|AWE_DCYSUSV
argument_list|(
name|voice
argument_list|)
argument_list|,
literal|0x0080
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_VTFT
argument_list|(
name|voice
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_CVCF
argument_list|(
name|voice
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_PTRX
argument_list|(
name|voice
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_CPF
argument_list|(
name|voice
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* modulation& volume envelope */
name|awe_poke
argument_list|(
name|AWE_ENVVAL
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_WORD
argument_list|(
name|fx
argument_list|,
name|fx_lay
argument_list|,
name|AWE_FX_ENV1_DELAY
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|moddelay
argument_list|)
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_ATKHLD
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_COMB
argument_list|(
name|fx
argument_list|,
name|fx_lay
argument_list|,
name|AWE_FX_ENV1_HOLD
argument_list|,
name|AWE_FX_ENV1_ATTACK
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|modatkhld
argument_list|)
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_DCYSUS
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_COMB
argument_list|(
name|fx
argument_list|,
name|fx_lay
argument_list|,
name|AWE_FX_ENV1_SUSTAIN
argument_list|,
name|AWE_FX_ENV1_DECAY
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|moddcysus
argument_list|)
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_ENVVOL
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_WORD
argument_list|(
name|fx
argument_list|,
name|fx_lay
argument_list|,
name|AWE_FX_ENV2_DELAY
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|voldelay
argument_list|)
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_ATKHLDV
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_COMB
argument_list|(
name|fx
argument_list|,
name|fx_lay
argument_list|,
name|AWE_FX_ENV2_HOLD
argument_list|,
name|AWE_FX_ENV2_ATTACK
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|volatkhld
argument_list|)
argument_list|)
expr_stmt|;
comment|/* decay/sustain parameter for volume envelope must be set at last */
comment|/* pitch offset */
name|awe_set_pitch
argument_list|(
name|voice
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* cutoff and volume */
name|awe_set_volume
argument_list|(
name|voice
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* modulation envelope heights */
name|awe_poke
argument_list|(
name|AWE_PEFE
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_COMB
argument_list|(
name|fx
argument_list|,
name|fx_lay
argument_list|,
name|AWE_FX_ENV1_PITCH
argument_list|,
name|AWE_FX_ENV1_CUTOFF
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|pefe
argument_list|)
argument_list|)
expr_stmt|;
comment|/* lfo1/2 delay */
name|awe_poke
argument_list|(
name|AWE_LFO1VAL
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_WORD
argument_list|(
name|fx
argument_list|,
name|fx_lay
argument_list|,
name|AWE_FX_LFO1_DELAY
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|lfo1delay
argument_list|)
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_LFO2VAL
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_WORD
argument_list|(
name|fx
argument_list|,
name|fx_lay
argument_list|,
name|AWE_FX_LFO2_DELAY
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|lfo2delay
argument_list|)
argument_list|)
expr_stmt|;
comment|/* lfo1 pitch& cutoff shift */
name|awe_fx_fmmod
argument_list|(
name|voice
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* lfo1 volume& freq */
name|awe_fx_tremfrq
argument_list|(
name|voice
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* lfo2 pitch& freq */
name|awe_fx_fm2frq2
argument_list|(
name|voice
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* pan& loop start */
name|awe_set_pan
argument_list|(
name|voice
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* chorus& loop end (chorus 8bit, MSB) */
name|addr
operator|=
name|vp
operator|->
name|loopend
operator|-
literal|1
expr_stmt|;
name|addr
operator|+=
name|FX_OFFSET
argument_list|(
name|fx
argument_list|,
name|fx_lay
argument_list|,
name|AWE_FX_LOOP_END
argument_list|,
name|AWE_FX_COARSE_LOOP_END
argument_list|,
name|vp
operator|->
name|mode
argument_list|)
expr_stmt|;
name|temp
operator|=
name|FX_BYTE
argument_list|(
name|fx
argument_list|,
name|fx_lay
argument_list|,
name|AWE_FX_CHORUS
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|chorus
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|temp
operator|<<
literal|24
operator|)
operator||
operator|(
name|unsigned
name|int
operator|)
name|addr
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CSL
argument_list|(
name|voice
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [-- loopend=%x/%x]\n"
argument_list|,
name|vp
operator|->
name|loopend
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Q& current address (Q 4bit value, MSB) */
name|addr
operator|=
name|vp
operator|->
name|start
operator|-
literal|1
expr_stmt|;
name|addr
operator|+=
name|FX_OFFSET
argument_list|(
name|fx
argument_list|,
name|fx_lay
argument_list|,
name|AWE_FX_SAMPLE_START
argument_list|,
name|AWE_FX_COARSE_SAMPLE_START
argument_list|,
name|vp
operator|->
name|mode
argument_list|)
expr_stmt|;
name|temp
operator|=
name|FX_BYTE
argument_list|(
name|fx
argument_list|,
name|fx_lay
argument_list|,
name|AWE_FX_FILTERQ
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|filterQ
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|temp
operator|<<
literal|28
operator|)
operator||
operator|(
name|unsigned
name|int
operator|)
name|addr
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
name|voice
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [-- startaddr=%x/%x]\n"
argument_list|,
name|vp
operator|->
name|start
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* reset volume */
name|awe_poke_dw
argument_list|(
name|AWE_VTFT
argument_list|(
name|voice
argument_list|)
argument_list|,
literal|0x0000FFFF
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CVCF
argument_list|(
name|voice
argument_list|)
argument_list|,
literal|0x0000FFFF
argument_list|)
expr_stmt|;
comment|/* turn on envelope */
name|awe_poke
argument_list|(
name|AWE_DCYSUSV
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_COMB
argument_list|(
name|fx
argument_list|,
name|fx_lay
argument_list|,
name|AWE_FX_ENV2_SUSTAIN
argument_list|,
name|AWE_FX_ENV2_DECAY
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|voldcysus
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set reverb */
name|temp
operator|=
name|FX_BYTE
argument_list|(
name|fx
argument_list|,
name|fx_lay
argument_list|,
name|AWE_FX_REVERB
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|reverb
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|awe_peek_dw
argument_list|(
name|AWE_PTRX
argument_list|(
name|voice
argument_list|)
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|temp
operator|<<
literal|8
operator|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PTRX
argument_list|(
name|voice
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CPF
argument_list|(
name|voice
argument_list|)
argument_list|,
literal|0x40000000
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|state
operator|=
name|AWE_ST_ON
expr_stmt|;
comment|/* clear voice position for the next note on this channel */
if|if
condition|(
name|SINGLE_LAYER_MODE
argument_list|()
condition|)
block|{
name|FX_UNSET
argument_list|(
name|fx
argument_list|,
name|AWE_FX_SAMPLE_START
argument_list|)
expr_stmt|;
name|FX_UNSET
argument_list|(
name|fx
argument_list|,
name|AWE_FX_COARSE_SAMPLE_START
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* turn off the voice */
end_comment

begin_function
specifier|static
name|void
name|awe_note_off
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|awe_voice_info
modifier|*
name|vp
decl_stmt|;
name|unsigned
name|short
name|tmp
decl_stmt|;
name|FX_Rec
modifier|*
name|fx
init|=
operator|&
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
operator|->
name|fx
decl_stmt|;
name|FX_Rec
modifier|*
name|fx_lay
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|layer
operator|<
name|MAX_LAYERS
condition|)
name|fx_lay
operator|=
operator|&
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
operator|->
name|fx_layer
index|[
name|voices
index|[
name|voice
index|]
operator|.
name|layer
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|)
operator|==
name|NULL
condition|)
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|state
operator|=
name|AWE_ST_OFF
expr_stmt|;
return|return;
block|}
name|tmp
operator|=
literal|0x8000
operator||
name|FX_BYTE
argument_list|(
name|fx
argument_list|,
name|fx_lay
argument_list|,
name|AWE_FX_ENV1_RELEASE
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|vp
operator|->
name|parm
operator|.
name|modrelease
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_DCYSUS
argument_list|(
name|voice
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
literal|0x8000
operator||
name|FX_BYTE
argument_list|(
name|fx
argument_list|,
name|fx_lay
argument_list|,
name|AWE_FX_ENV2_RELEASE
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|vp
operator|->
name|parm
operator|.
name|volrelease
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_DCYSUSV
argument_list|(
name|voice
argument_list|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|state
operator|=
name|AWE_ST_RELEASED
expr_stmt|;
block|}
end_function

begin_comment
comment|/* force to terminate the voice (no releasing echo) */
end_comment

begin_function
specifier|static
name|void
name|awe_terminate
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|awe_poke
argument_list|(
name|AWE_DCYSUSV
argument_list|(
name|voice
argument_list|)
argument_list|,
literal|0x807F
argument_list|)
expr_stmt|;
name|awe_tweak_voice
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|state
operator|=
name|AWE_ST_OFF
expr_stmt|;
block|}
end_function

begin_comment
comment|/* turn off other voices with the same exclusive class (for drums) */
end_comment

begin_function
specifier|static
name|void
name|awe_exclusive_off
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|exclass
decl_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|exclass
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|->
name|exclusiveClass
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* not exclusive */
comment|/* turn off voices with the same class */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|awe_max_voices
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|voice
operator|&&
name|IS_PLAYING
argument_list|(
name|i
argument_list|)
operator|&&
name|voices
index|[
name|i
index|]
operator|.
name|sample
operator|&&
name|voices
index|[
name|i
index|]
operator|.
name|ch
operator|==
name|voices
index|[
name|voice
index|]
operator|.
name|ch
operator|&&
name|voices
index|[
name|i
index|]
operator|.
name|sample
operator|->
name|exclusiveClass
operator|==
name|exclass
condition|)
block|{
name|DEBUG
argument_list|(
literal|4
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [exoff(%d)]\n"
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|awe_terminate
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|awe_voice_init
argument_list|(
name|i
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*================================================================  * change the parameters of an audible voice  *================================================================*/
end_comment

begin_comment
comment|/* change pitch */
end_comment

begin_function
specifier|static
name|void
name|awe_set_pitch
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
block|{
if|if
condition|(
name|IS_NO_EFFECT
argument_list|(
name|voice
argument_list|)
operator|&&
operator|!
name|forced
condition|)
return|return;
name|awe_poke
argument_list|(
name|AWE_IP
argument_list|(
name|voice
argument_list|)
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|apitch
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|3
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [-- pitch=%x]\n"
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|apitch
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* calculate& change pitch */
end_comment

begin_function
specifier|static
name|void
name|awe_set_voice_pitch
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
block|{
name|awe_calc_pitch
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|awe_set_pitch
argument_list|(
name|voice
argument_list|,
name|forced
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* change volume& cutoff */
end_comment

begin_function
specifier|static
name|void
name|awe_set_volume
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
block|{
name|awe_voice_info
modifier|*
name|vp
decl_stmt|;
name|unsigned
name|short
name|tmp2
decl_stmt|;
name|FX_Rec
modifier|*
name|fx
init|=
operator|&
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
operator|->
name|fx
decl_stmt|;
name|FX_Rec
modifier|*
name|fx_lay
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|layer
operator|<
name|MAX_LAYERS
condition|)
name|fx_lay
operator|=
operator|&
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
operator|->
name|fx_layer
index|[
name|voices
index|[
name|voice
index|]
operator|.
name|layer
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|IS_PLAYING
argument_list|(
name|voice
argument_list|)
operator|&&
operator|!
name|forced
condition|)
return|return;
if|if
condition|(
operator|(
name|vp
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|)
operator|==
name|NULL
operator|||
name|vp
operator|->
name|index
operator|<
literal|0
condition|)
return|return;
name|tmp2
operator|=
name|FX_BYTE
argument_list|(
name|fx
argument_list|,
name|fx_lay
argument_list|,
name|AWE_FX_CUTOFF
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|cutoff
argument_list|)
expr_stmt|;
name|tmp2
operator|=
operator|(
name|tmp2
operator|<<
literal|8
operator|)
expr_stmt|;
name|tmp2
operator||=
name|FX_BYTE
argument_list|(
name|fx
argument_list|,
name|fx_lay
argument_list|,
name|AWE_FX_ATTEN
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|voices
index|[
name|voice
index|]
operator|.
name|avol
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_IFATN
argument_list|(
name|voice
argument_list|)
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* calculate& change volume */
end_comment

begin_function
specifier|static
name|void
name|awe_set_voice_vol
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
block|{
if|if
condition|(
name|IS_EMPTY
argument_list|(
name|voice
argument_list|)
condition|)
return|return;
name|awe_calc_volume
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|awe_set_volume
argument_list|(
name|voice
argument_list|,
name|forced
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* change pan; this could make a click noise.. */
end_comment

begin_function
specifier|static
name|void
name|awe_set_pan
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
block|{
name|unsigned
name|int
name|temp
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|awe_voice_info
modifier|*
name|vp
decl_stmt|;
name|FX_Rec
modifier|*
name|fx
init|=
operator|&
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
operator|->
name|fx
decl_stmt|;
name|FX_Rec
modifier|*
name|fx_lay
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|layer
operator|<
name|MAX_LAYERS
condition|)
name|fx_lay
operator|=
operator|&
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
operator|->
name|fx_layer
index|[
name|voices
index|[
name|voice
index|]
operator|.
name|layer
index|]
expr_stmt|;
if|if
condition|(
name|IS_NO_EFFECT
argument_list|(
name|voice
argument_list|)
operator|&&
operator|!
name|forced
condition|)
return|return;
if|if
condition|(
operator|(
name|vp
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|)
operator|==
name|NULL
operator|||
name|vp
operator|->
name|index
operator|<
literal|0
condition|)
return|return;
comment|/* pan& loop start (pan 8bit, MSB, 0:right, 0xff:left) */
if|if
condition|(
name|vp
operator|->
name|fixpan
operator|>
literal|0
condition|)
comment|/* 0-127 */
name|temp
operator|=
literal|255
operator|-
operator|(
name|int
operator|)
name|vp
operator|->
name|fixpan
operator|*
literal|2
expr_stmt|;
else|else
block|{
name|int
name|pos
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|pan
operator|>=
literal|0
condition|)
comment|/* 0-127 */
name|pos
operator|=
operator|(
name|int
operator|)
name|vp
operator|->
name|pan
operator|*
literal|2
operator|-
literal|128
expr_stmt|;
name|pos
operator|+=
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
operator|->
name|panning
expr_stmt|;
comment|/* -128 - 127 */
name|pos
operator|=
literal|127
operator|-
name|pos
expr_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
name|temp
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|pos
operator|>
literal|255
condition|)
name|temp
operator|=
literal|255
expr_stmt|;
else|else
name|temp
operator|=
name|pos
expr_stmt|;
block|}
if|if
condition|(
name|forced
operator|||
name|temp
operator|!=
name|voices
index|[
name|voice
index|]
operator|.
name|apan
condition|)
block|{
name|addr
operator|=
name|vp
operator|->
name|loopstart
operator|-
literal|1
expr_stmt|;
name|addr
operator|+=
name|FX_OFFSET
argument_list|(
name|fx
argument_list|,
name|fx_lay
argument_list|,
name|AWE_FX_LOOP_START
argument_list|,
name|AWE_FX_COARSE_LOOP_START
argument_list|,
name|vp
operator|->
name|mode
argument_list|)
expr_stmt|;
name|temp
operator|=
operator|(
name|temp
operator|<<
literal|24
operator|)
operator||
operator|(
name|unsigned
name|int
operator|)
name|addr
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PSST
argument_list|(
name|voice
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|apan
operator|=
name|temp
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [-- loopstart=%x/%x]\n"
argument_list|,
name|vp
operator|->
name|loopstart
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* effects change during playing */
end_comment

begin_function
specifier|static
name|void
name|awe_fx_fmmod
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
block|{
name|awe_voice_info
modifier|*
name|vp
decl_stmt|;
name|FX_Rec
modifier|*
name|fx
init|=
operator|&
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
operator|->
name|fx
decl_stmt|;
name|FX_Rec
modifier|*
name|fx_lay
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|layer
operator|<
name|MAX_LAYERS
condition|)
name|fx_lay
operator|=
operator|&
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
operator|->
name|fx_layer
index|[
name|voices
index|[
name|voice
index|]
operator|.
name|layer
index|]
expr_stmt|;
if|if
condition|(
name|IS_NO_EFFECT
argument_list|(
name|voice
argument_list|)
operator|&&
operator|!
name|forced
condition|)
return|return;
if|if
condition|(
operator|(
name|vp
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|)
operator|==
name|NULL
operator|||
name|vp
operator|->
name|index
operator|<
literal|0
condition|)
return|return;
name|awe_poke
argument_list|(
name|AWE_FMMOD
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_COMB
argument_list|(
name|fx
argument_list|,
name|fx_lay
argument_list|,
name|AWE_FX_LFO1_PITCH
argument_list|,
name|AWE_FX_LFO1_CUTOFF
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|fmmod
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set tremolo (lfo1) volume& frequency */
end_comment

begin_function
specifier|static
name|void
name|awe_fx_tremfrq
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
block|{
name|awe_voice_info
modifier|*
name|vp
decl_stmt|;
name|FX_Rec
modifier|*
name|fx
init|=
operator|&
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
operator|->
name|fx
decl_stmt|;
name|FX_Rec
modifier|*
name|fx_lay
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|layer
operator|<
name|MAX_LAYERS
condition|)
name|fx_lay
operator|=
operator|&
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
operator|->
name|fx_layer
index|[
name|voices
index|[
name|voice
index|]
operator|.
name|layer
index|]
expr_stmt|;
if|if
condition|(
name|IS_NO_EFFECT
argument_list|(
name|voice
argument_list|)
operator|&&
operator|!
name|forced
condition|)
return|return;
if|if
condition|(
operator|(
name|vp
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|)
operator|==
name|NULL
operator|||
name|vp
operator|->
name|index
operator|<
literal|0
condition|)
return|return;
name|awe_poke
argument_list|(
name|AWE_TREMFRQ
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_COMB
argument_list|(
name|fx
argument_list|,
name|fx_lay
argument_list|,
name|AWE_FX_LFO1_VOLUME
argument_list|,
name|AWE_FX_LFO1_FREQ
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|tremfrq
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set lfo2 pitch& frequency */
end_comment

begin_function
specifier|static
name|void
name|awe_fx_fm2frq2
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
block|{
name|awe_voice_info
modifier|*
name|vp
decl_stmt|;
name|FX_Rec
modifier|*
name|fx
init|=
operator|&
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
operator|->
name|fx
decl_stmt|;
name|FX_Rec
modifier|*
name|fx_lay
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|layer
operator|<
name|MAX_LAYERS
condition|)
name|fx_lay
operator|=
operator|&
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
operator|->
name|fx_layer
index|[
name|voices
index|[
name|voice
index|]
operator|.
name|layer
index|]
expr_stmt|;
if|if
condition|(
name|IS_NO_EFFECT
argument_list|(
name|voice
argument_list|)
operator|&&
operator|!
name|forced
condition|)
return|return;
if|if
condition|(
operator|(
name|vp
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|)
operator|==
name|NULL
operator|||
name|vp
operator|->
name|index
operator|<
literal|0
condition|)
return|return;
name|awe_poke
argument_list|(
name|AWE_FM2FRQ2
argument_list|(
name|voice
argument_list|)
argument_list|,
name|FX_COMB
argument_list|(
name|fx
argument_list|,
name|fx_lay
argument_list|,
name|AWE_FX_LFO2_PITCH
argument_list|,
name|AWE_FX_LFO2_FREQ
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|fm2frq2
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Q& current address (Q 4bit value, MSB) */
end_comment

begin_function
specifier|static
name|void
name|awe_fx_filterQ
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
block|{
name|unsigned
name|int
name|addr
decl_stmt|;
name|awe_voice_info
modifier|*
name|vp
decl_stmt|;
name|FX_Rec
modifier|*
name|fx
init|=
operator|&
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
operator|->
name|fx
decl_stmt|;
name|FX_Rec
modifier|*
name|fx_lay
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|layer
operator|<
name|MAX_LAYERS
condition|)
name|fx_lay
operator|=
operator|&
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
operator|->
name|fx_layer
index|[
name|voices
index|[
name|voice
index|]
operator|.
name|layer
index|]
expr_stmt|;
if|if
condition|(
name|IS_NO_EFFECT
argument_list|(
name|voice
argument_list|)
operator|&&
operator|!
name|forced
condition|)
return|return;
if|if
condition|(
operator|(
name|vp
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|)
operator|==
name|NULL
operator|||
name|vp
operator|->
name|index
operator|<
literal|0
condition|)
return|return;
name|addr
operator|=
name|awe_peek_dw
argument_list|(
name|AWE_CCCA
argument_list|(
name|voice
argument_list|)
argument_list|)
operator|&
literal|0xffffff
expr_stmt|;
name|addr
operator||=
operator|(
name|FX_BYTE
argument_list|(
name|fx
argument_list|,
name|fx_lay
argument_list|,
name|AWE_FX_FILTERQ
argument_list|,
name|vp
operator|->
name|parm
operator|.
name|filterQ
argument_list|)
operator|<<
literal|28
operator|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
name|voice
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*================================================================  * calculate pitch offset  *----------------------------------------------------------------  * 0xE000 is no pitch offset at 44100Hz sample.  * Every 4096 is one octave.  *================================================================*/
end_comment

begin_function
specifier|static
name|void
name|awe_calc_pitch
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|voice_info
modifier|*
name|vp
init|=
operator|&
name|voices
index|[
name|voice
index|]
decl_stmt|;
name|awe_voice_info
modifier|*
name|ap
decl_stmt|;
name|awe_chan_info
modifier|*
name|cp
init|=
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
decl_stmt|;
name|int
name|offset
decl_stmt|;
comment|/* search voice information */
if|if
condition|(
operator|(
name|ap
operator|=
name|vp
operator|->
name|sample
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|ap
operator|->
name|index
operator|<
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
literal|3
argument_list|,
name|printk
argument_list|(
literal|"AWE32: set sample (%d)\n"
argument_list|,
name|ap
operator|->
name|sample
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|awe_set_sample
argument_list|(
name|ap
argument_list|)
operator|<
literal|0
condition|)
return|return;
block|}
comment|/* calculate offset */
if|if
condition|(
name|ap
operator|->
name|fixkey
operator|>=
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
literal|3
argument_list|,
name|printk
argument_list|(
literal|"AWE32: p-> fixkey(%d) tune(%d)\n"
argument_list|,
name|ap
operator|->
name|fixkey
argument_list|,
name|ap
operator|->
name|tune
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|ap
operator|->
name|fixkey
operator|-
name|ap
operator|->
name|root
operator|)
operator|*
literal|4096
operator|/
literal|12
expr_stmt|;
block|}
else|else
block|{
name|DEBUG
argument_list|(
literal|3
argument_list|,
name|printk
argument_list|(
literal|"AWE32: p(%d)-> root(%d) tune(%d)\n"
argument_list|,
name|vp
operator|->
name|note
argument_list|,
name|ap
operator|->
name|root
argument_list|,
name|ap
operator|->
name|tune
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|vp
operator|->
name|note
operator|-
name|ap
operator|->
name|root
operator|)
operator|*
literal|4096
operator|/
literal|12
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
name|printk
argument_list|(
literal|"AWE32: p-> ofs=%d\n"
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|offset
operator|=
operator|(
name|offset
operator|*
name|ap
operator|->
name|scaleTuning
operator|)
operator|/
literal|100
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
name|printk
argument_list|(
literal|"AWE32: p-> scale* ofs=%d\n"
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|ap
operator|->
name|tune
operator|*
literal|4096
operator|/
literal|1200
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
name|printk
argument_list|(
literal|"AWE32: p-> tune+ ofs=%d\n"
argument_list|,
name|offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|bender
operator|!=
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
literal|3
argument_list|,
name|printk
argument_list|(
literal|"AWE32: p-> bend(%d) %d\n"
argument_list|,
name|voice
argument_list|,
name|cp
operator|->
name|bender
argument_list|)
argument_list|)
expr_stmt|;
comment|/* (819200: 1 semitone) ==> (4096: 12 semitones) */
name|offset
operator|+=
name|cp
operator|->
name|bender
operator|*
name|cp
operator|->
name|bender_range
operator|/
literal|2400
expr_stmt|;
block|}
comment|/* add initial pitch correction */
if|if
condition|(
name|FX_ON
argument_list|(
operator|&
name|cp
operator|->
name|fx_layer
index|[
name|vp
operator|->
name|layer
index|]
argument_list|,
name|AWE_FX_INIT_PITCH
argument_list|)
condition|)
name|offset
operator|+=
name|cp
operator|->
name|fx_layer
index|[
name|vp
operator|->
name|layer
index|]
operator|.
name|val
index|[
name|AWE_FX_INIT_PITCH
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|FX_ON
argument_list|(
operator|&
name|cp
operator|->
name|fx
argument_list|,
name|AWE_FX_INIT_PITCH
argument_list|)
condition|)
name|offset
operator|+=
name|cp
operator|->
name|fx
operator|.
name|val
index|[
name|AWE_FX_INIT_PITCH
index|]
expr_stmt|;
comment|/* 0xe000: root pitch */
name|vp
operator|->
name|apitch
operator|=
literal|0xe000
operator|+
name|ap
operator|->
name|rate_offset
operator|+
name|offset
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
name|printk
argument_list|(
literal|"AWE32: p-> sum aofs=%x, rate_ofs=%d\n"
argument_list|,
name|vp
operator|->
name|apitch
argument_list|,
name|ap
operator|->
name|rate_offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|apitch
operator|>
literal|0xffff
condition|)
name|vp
operator|->
name|apitch
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|apitch
operator|<
literal|0
condition|)
name|vp
operator|->
name|apitch
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AWE_HAS_GUS_COMPATIBILITY
end_ifdef

begin_comment
comment|/* calculate MIDI key and semitone from the specified frequency */
end_comment

begin_function
specifier|static
name|void
name|awe_calc_pitch_from_freq
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|freq
parameter_list|)
block|{
name|voice_info
modifier|*
name|vp
init|=
operator|&
name|voices
index|[
name|voice
index|]
decl_stmt|;
name|awe_voice_info
modifier|*
name|ap
decl_stmt|;
name|FX_Rec
modifier|*
name|fx
init|=
operator|&
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
operator|->
name|fx
decl_stmt|;
name|FX_Rec
modifier|*
name|fx_lay
init|=
name|NULL
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|note
decl_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|layer
operator|<
name|MAX_LAYERS
condition|)
name|fx_lay
operator|=
operator|&
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
operator|->
name|fx_layer
index|[
name|voices
index|[
name|voice
index|]
operator|.
name|layer
index|]
expr_stmt|;
comment|/* search voice information */
if|if
condition|(
operator|(
name|ap
operator|=
name|vp
operator|->
name|sample
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|ap
operator|->
name|index
operator|<
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
literal|3
argument_list|,
name|printk
argument_list|(
literal|"AWE32: set sample (%d)\n"
argument_list|,
name|ap
operator|->
name|sample
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|awe_set_sample
argument_list|(
name|ap
argument_list|)
operator|<
literal|0
condition|)
return|return;
block|}
name|note
operator|=
name|freq_to_note
argument_list|(
name|freq
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|note
operator|-
name|ap
operator|->
name|root
operator|*
literal|100
operator|+
name|ap
operator|->
name|tune
operator|)
operator|*
literal|4096
operator|/
literal|1200
expr_stmt|;
name|offset
operator|=
operator|(
name|offset
operator|*
name|ap
operator|->
name|scaleTuning
operator|)
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|fx_lay
operator|&&
name|FX_ON
argument_list|(
name|fx_lay
argument_list|,
name|AWE_FX_INIT_PITCH
argument_list|)
condition|)
name|offset
operator|+=
name|fx_lay
operator|->
name|val
index|[
name|AWE_FX_INIT_PITCH
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|FX_ON
argument_list|(
name|fx
argument_list|,
name|AWE_FX_INIT_PITCH
argument_list|)
condition|)
name|offset
operator|+=
name|fx
operator|->
name|val
index|[
name|AWE_FX_INIT_PITCH
index|]
expr_stmt|;
name|vp
operator|->
name|apitch
operator|=
literal|0xe000
operator|+
name|ap
operator|->
name|rate_offset
operator|+
name|offset
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|apitch
operator|>
literal|0xffff
condition|)
name|vp
operator|->
name|apitch
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|apitch
operator|<
literal|0
condition|)
name|vp
operator|->
name|apitch
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AWE_HAS_GUS_COMPATIBILITY */
end_comment

begin_comment
comment|/*================================================================  * calculate volume attenuation  *----------------------------------------------------------------  * Voice volume is controlled by volume attenuation parameter.  * So volume becomes maximum when avol is 0 (no attenuation), and  * minimum when 255 (-96dB or silence).  *================================================================*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|vol_table
index|[
literal|128
index|]
init|=
block|{
literal|255
block|,
literal|111
block|,
literal|95
block|,
literal|86
block|,
literal|79
block|,
literal|74
block|,
literal|70
block|,
literal|66
block|,
literal|63
block|,
literal|61
block|,
literal|58
block|,
literal|56
block|,
literal|54
block|,
literal|52
block|,
literal|50
block|,
literal|49
block|,
literal|47
block|,
literal|46
block|,
literal|45
block|,
literal|43
block|,
literal|42
block|,
literal|41
block|,
literal|40
block|,
literal|39
block|,
literal|38
block|,
literal|37
block|,
literal|36
block|,
literal|35
block|,
literal|34
block|,
literal|34
block|,
literal|33
block|,
literal|32
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|29
block|,
literal|29
block|,
literal|28
block|,
literal|27
block|,
literal|27
block|,
literal|26
block|,
literal|26
block|,
literal|25
block|,
literal|24
block|,
literal|24
block|,
literal|23
block|,
literal|23
block|,
literal|22
block|,
literal|22
block|,
literal|21
block|,
literal|21
block|,
literal|21
block|,
literal|20
block|,
literal|20
block|,
literal|19
block|,
literal|19
block|,
literal|18
block|,
literal|18
block|,
literal|18
block|,
literal|17
block|,
literal|17
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|14
block|,
literal|14
block|,
literal|14
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|9
block|,
literal|9
block|,
literal|9
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|8
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|awe_calc_volume
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
name|voice_info
modifier|*
name|vp
init|=
operator|&
name|voices
index|[
name|voice
index|]
decl_stmt|;
name|awe_voice_info
modifier|*
name|ap
decl_stmt|;
name|awe_chan_info
modifier|*
name|cp
init|=
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
decl_stmt|;
name|int
name|vol
decl_stmt|;
comment|/* search voice information */
if|if
condition|(
operator|(
name|ap
operator|=
name|vp
operator|->
name|sample
operator|)
operator|==
name|NULL
condition|)
return|return;
name|ap
operator|=
name|vp
operator|->
name|sample
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|index
operator|<
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
literal|3
argument_list|,
name|printk
argument_list|(
literal|"AWE32: set sample (%d)\n"
argument_list|,
name|ap
operator|->
name|sample
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|awe_set_sample
argument_list|(
name|ap
argument_list|)
operator|<
literal|0
condition|)
return|return;
block|}
comment|/* 0 - 127 */
name|vol
operator|=
operator|(
name|vp
operator|->
name|velocity
operator|*
name|cp
operator|->
name|main_vol
operator|*
name|cp
operator|->
name|expression_vol
operator|)
operator|/
operator|(
literal|127
operator|*
literal|127
operator|)
expr_stmt|;
name|vol
operator|=
name|vol
operator|*
name|ap
operator|->
name|amplitude
operator|/
literal|127
expr_stmt|;
if|if
condition|(
name|vol
operator|<
literal|0
condition|)
name|vol
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vol
operator|>
literal|127
condition|)
name|vol
operator|=
literal|127
expr_stmt|;
comment|/* calc to attenuation */
name|vol
operator|=
name|vol_table
index|[
name|vol
index|]
expr_stmt|;
name|vol
operator|=
name|vol
operator|+
operator|(
name|int
operator|)
name|ap
operator|->
name|attenuation
operator|+
name|init_atten
expr_stmt|;
if|if
condition|(
name|vol
operator|>
literal|255
condition|)
name|vol
operator|=
literal|255
expr_stmt|;
name|vp
operator|->
name|avol
operator|=
name|vol
expr_stmt|;
name|DEBUG
argument_list|(
literal|3
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [-- voice(%d) vol=%x]\n"
argument_list|,
name|voice
argument_list|,
name|vol
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set sostenuto on */
end_comment

begin_function
specifier|static
name|void
name|awe_sostenuto_on
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
block|{
if|if
condition|(
name|IS_NO_EFFECT
argument_list|(
name|voice
argument_list|)
operator|&&
operator|!
name|forced
condition|)
return|return;
name|voices
index|[
name|voice
index|]
operator|.
name|sostenuto
operator|=
literal|127
expr_stmt|;
block|}
end_function

begin_comment
comment|/* drop sustain */
end_comment

begin_function
specifier|static
name|void
name|awe_sustain_off
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
block|{
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|state
operator|==
name|AWE_ST_SUSTAINED
condition|)
block|{
name|awe_note_off
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|awe_fx_init
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|ch
argument_list|)
expr_stmt|;
name|awe_voice_init
argument_list|(
name|voice
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* terminate and initialize voice */
end_comment

begin_function
specifier|static
name|void
name|awe_terminate_and_init
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|forced
parameter_list|)
block|{
name|awe_terminate
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|awe_fx_init
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|ch
argument_list|)
expr_stmt|;
name|awe_voice_init
argument_list|(
name|voice
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*================================================================  * synth operation routines  *================================================================*/
end_comment

begin_define
define|#
directive|define
name|AWE_VOICE_KEY
parameter_list|(
name|v
parameter_list|)
value|(0x8000 | (v))
end_define

begin_define
define|#
directive|define
name|AWE_CHAN_KEY
parameter_list|(
name|c
parameter_list|,
name|n
parameter_list|)
value|(((c)<< 8) | ((n) + 1))
end_define

begin_define
define|#
directive|define
name|KEY_CHAN_MATCH
parameter_list|(
name|key
parameter_list|,
name|c
parameter_list|)
value|(((key)>> 8) == (c))
end_define

begin_comment
comment|/* initialize the voice */
end_comment

begin_function
specifier|static
name|void
name|awe_voice_init
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|init_all
parameter_list|)
block|{
name|voice_info
modifier|*
name|vp
init|=
operator|&
name|voices
index|[
name|voice
index|]
decl_stmt|;
comment|/* reset voice search key */
if|if
condition|(
name|playing_mode
operator|==
name|AWE_PLAY_DIRECT
condition|)
name|vp
operator|->
name|key
operator|=
name|AWE_VOICE_KEY
argument_list|(
name|voice
argument_list|)
expr_stmt|;
else|else
name|vp
operator|->
name|key
operator|=
literal|0
expr_stmt|;
comment|/* clear voice mapping */
name|voice_alloc
operator|->
name|map
index|[
name|voice
index|]
operator|=
literal|0
expr_stmt|;
comment|/* touch the timing flag */
name|vp
operator|->
name|time
operator|=
name|current_alloc_time
expr_stmt|;
comment|/* initialize other parameters if necessary */
if|if
condition|(
name|init_all
condition|)
block|{
name|vp
operator|->
name|note
operator|=
operator|-
literal|1
expr_stmt|;
name|vp
operator|->
name|velocity
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|sostenuto
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|sample
operator|=
name|NULL
expr_stmt|;
name|vp
operator|->
name|cinfo
operator|=
operator|&
name|channels
index|[
name|voice
index|]
expr_stmt|;
name|vp
operator|->
name|ch
operator|=
name|voice
expr_stmt|;
name|vp
operator|->
name|state
operator|=
name|AWE_ST_OFF
expr_stmt|;
comment|/* emu8000 parameters */
name|vp
operator|->
name|apitch
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|avol
operator|=
literal|255
expr_stmt|;
name|vp
operator|->
name|apan
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* clear effects */
end_comment

begin_function
specifier|static
name|void
name|awe_fx_init
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
if|if
condition|(
name|SINGLE_LAYER_MODE
argument_list|()
operator|&&
operator|!
name|misc_modes
index|[
name|AWE_MD_KEEP_EFFECT
index|]
condition|)
block|{
name|BZERO
argument_list|(
operator|&
name|channels
index|[
name|ch
index|]
operator|.
name|fx
argument_list|,
sizeof|sizeof
argument_list|(
name|channels
index|[
name|ch
index|]
operator|.
name|fx
argument_list|)
argument_list|)
expr_stmt|;
name|BZERO
argument_list|(
operator|&
name|channels
index|[
name|ch
index|]
operator|.
name|fx_layer
argument_list|,
sizeof|sizeof
argument_list|(
operator|&
name|channels
index|[
name|ch
index|]
operator|.
name|fx_layer
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* initialize channel info */
end_comment

begin_function
specifier|static
name|void
name|awe_channel_init
parameter_list|(
name|int
name|ch
parameter_list|,
name|int
name|init_all
parameter_list|)
block|{
name|awe_chan_info
modifier|*
name|cp
init|=
operator|&
name|channels
index|[
name|ch
index|]
decl_stmt|;
name|cp
operator|->
name|channel
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|init_all
condition|)
block|{
name|cp
operator|->
name|panning
operator|=
literal|0
expr_stmt|;
comment|/* zero center */
name|cp
operator|->
name|bender_range
operator|=
literal|200
expr_stmt|;
comment|/* sense * 100 */
name|cp
operator|->
name|main_vol
operator|=
literal|127
expr_stmt|;
if|if
condition|(
name|MULTI_LAYER_MODE
argument_list|()
operator|&&
name|IS_DRUM_CHANNEL
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|cp
operator|->
name|instr
operator|=
name|misc_modes
index|[
name|AWE_MD_DEF_DRUM
index|]
expr_stmt|;
name|cp
operator|->
name|bank
operator|=
name|AWE_DRUM_BANK
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|->
name|instr
operator|=
name|misc_modes
index|[
name|AWE_MD_DEF_PRESET
index|]
expr_stmt|;
name|cp
operator|->
name|bank
operator|=
name|misc_modes
index|[
name|AWE_MD_DEF_BANK
index|]
expr_stmt|;
block|}
name|cp
operator|->
name|vrec
operator|=
operator|-
literal|1
expr_stmt|;
name|cp
operator|->
name|def_vrec
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|cp
operator|->
name|bender
operator|=
literal|0
expr_stmt|;
comment|/* zero tune skew */
name|cp
operator|->
name|expression_vol
operator|=
literal|127
expr_stmt|;
name|cp
operator|->
name|chan_press
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|sustained
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|misc_modes
index|[
name|AWE_MD_KEEP_EFFECT
index|]
condition|)
block|{
name|BZERO
argument_list|(
operator|&
name|cp
operator|->
name|fx
argument_list|,
sizeof|sizeof
argument_list|(
name|cp
operator|->
name|fx
argument_list|)
argument_list|)
expr_stmt|;
name|BZERO
argument_list|(
operator|&
name|cp
operator|->
name|fx_layer
argument_list|,
sizeof|sizeof
argument_list|(
name|cp
operator|->
name|fx_layer
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* change the voice parameters; voice = channel */
end_comment

begin_function
specifier|static
name|void
name|awe_voice_change
parameter_list|(
name|int
name|voice
parameter_list|,
name|fx_affect_func
name|func
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|playing_mode
condition|)
block|{
case|case
name|AWE_PLAY_DIRECT
case|:
name|func
argument_list|(
name|voice
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|AWE_PLAY_INDIRECT
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|awe_max_voices
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|voices
index|[
name|i
index|]
operator|.
name|key
operator|==
name|AWE_VOICE_KEY
argument_list|(
name|voice
argument_list|)
condition|)
name|func
argument_list|(
name|i
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
default|default:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|awe_max_voices
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|KEY_CHAN_MATCH
argument_list|(
name|voices
index|[
name|i
index|]
operator|.
name|key
argument_list|,
name|voice
argument_list|)
condition|)
name|func
argument_list|(
name|i
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------  * device open / close  *----------------------------------------------------------------*/
end_comment

begin_comment
comment|/* open device:  *   reset status of all voices, and clear sample position flag  */
end_comment

begin_function
specifier|static
name|int
name|awe_open
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
name|awe_busy
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EBUSY
argument_list|)
return|;
name|awe_busy
operator|=
name|TRUE
expr_stmt|;
comment|/* set default mode */
name|awe_init_misc_modes
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|init_atten
operator|=
name|misc_modes
index|[
name|AWE_MD_ZERO_ATTEN
index|]
expr_stmt|;
name|drum_flags
operator|=
name|DEFAULT_DRUM_FLAGS
expr_stmt|;
name|playing_mode
operator|=
name|AWE_PLAY_INDIRECT
expr_stmt|;
comment|/* reset voices& channels */
name|awe_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|patch_opened
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* close device:  *   reset all voices again (terminate sounds)  */
end_comment

begin_function
specifier|static
name|void
name|awe_close
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|awe_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|awe_busy
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set miscellaneous mode parameters  */
end_comment

begin_function
specifier|static
name|void
name|awe_init_misc_modes
parameter_list|(
name|int
name|init_all
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_MD_END
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|init_all
operator|||
name|misc_modes_default
index|[
name|i
index|]
operator|.
name|init_each_time
condition|)
name|misc_modes
index|[
name|i
index|]
operator|=
name|misc_modes_default
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* sequencer I/O control:  */
end_comment

begin_function
specifier|static
name|int
name|awe_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SNDCTL_SYNTH_INFO
case|:
if|if
condition|(
name|playing_mode
operator|==
name|AWE_PLAY_DIRECT
condition|)
name|awe_info
operator|.
name|nr_voices
operator|=
name|awe_max_voices
expr_stmt|;
else|else
name|awe_info
operator|.
name|nr_voices
operator|=
name|AWE_MAX_CHANNELS
expr_stmt|;
name|IOCTL_TO_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
literal|0
argument_list|,
operator|&
name|awe_info
argument_list|,
sizeof|sizeof
argument_list|(
name|awe_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SEQ_RESETSAMPLES
case|:
name|awe_reset_samples
argument_list|()
expr_stmt|;
name|awe_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SEQ_PERCMODE
case|:
comment|/* what's this? */
return|return
literal|0
return|;
break|break;
case|case
name|SNDCTL_SYNTH_MEMAVL
case|:
return|return
name|awe_mem_size
operator|-
name|awe_free_mem_ptr
argument_list|()
operator|*
literal|2
return|;
default|default:
name|printk
argument_list|(
literal|"AWE32: unsupported ioctl %d\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|voice_in_range
parameter_list|(
name|int
name|voice
parameter_list|)
block|{
if|if
condition|(
name|playing_mode
operator|==
name|AWE_PLAY_DIRECT
condition|)
block|{
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|awe_max_voices
condition|)
return|return
name|FALSE
return|;
block|}
else|else
block|{
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|AWE_MAX_CHANNELS
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|release_voice
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|do_sustain
parameter_list|)
block|{
if|if
condition|(
name|IS_NO_SOUND
argument_list|(
name|voice
argument_list|)
condition|)
return|return;
if|if
condition|(
name|do_sustain
operator|&&
operator|(
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
operator|->
name|sustained
operator|==
literal|127
operator|||
name|voices
index|[
name|voice
index|]
operator|.
name|sostenuto
operator|==
literal|127
operator|)
condition|)
name|voices
index|[
name|voice
index|]
operator|.
name|state
operator|=
name|AWE_ST_SUSTAINED
expr_stmt|;
else|else
block|{
name|awe_note_off
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|awe_fx_init
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|ch
argument_list|)
expr_stmt|;
name|awe_voice_init
argument_list|(
name|voice
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* release all notes */
end_comment

begin_function
specifier|static
name|void
name|awe_note_off_all
parameter_list|(
name|int
name|do_sustain
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|awe_max_voices
condition|;
name|i
operator|++
control|)
name|release_voice
argument_list|(
name|i
argument_list|,
name|do_sustain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* kill a voice:  *   not terminate, just release the voice.  */
end_comment

begin_function
specifier|static
name|int
name|awe_kill_note
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|note
parameter_list|,
name|int
name|velocity
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|v2
decl_stmt|,
name|key
decl_stmt|;
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [off(%d) nt=%d vl=%d]\n"
argument_list|,
name|voice
argument_list|,
name|note
argument_list|,
name|velocity
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|voice_in_range
argument_list|(
name|voice
argument_list|)
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
switch|switch
condition|(
name|playing_mode
condition|)
block|{
case|case
name|AWE_PLAY_DIRECT
case|:
case|case
name|AWE_PLAY_INDIRECT
case|:
name|key
operator|=
name|AWE_VOICE_KEY
argument_list|(
name|voice
argument_list|)
expr_stmt|;
break|break;
case|case
name|AWE_PLAY_MULTI2
case|:
name|v2
operator|=
name|voice_alloc
operator|->
name|map
index|[
name|voice
index|]
operator|>>
literal|8
expr_stmt|;
name|voice_alloc
operator|->
name|map
index|[
name|voice
index|]
operator|=
literal|0
expr_stmt|;
name|voice
operator|=
name|v2
expr_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|AWE_MAX_CHANNELS
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
comment|/* continue to below */
default|default:
name|key
operator|=
name|AWE_CHAN_KEY
argument_list|(
name|voice
argument_list|,
name|note
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|awe_max_voices
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|voices
index|[
name|i
index|]
operator|.
name|key
operator|==
name|key
condition|)
name|release_voice
argument_list|(
name|i
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_or_volume_change
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|velocity
parameter_list|)
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|velocity
operator|=
name|velocity
expr_stmt|;
name|awe_calc_volume
argument_list|(
name|voice
argument_list|)
expr_stmt|;
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|state
operator|==
name|AWE_ST_STANDBY
condition|)
name|awe_note_on
argument_list|(
name|voice
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|voices
index|[
name|voice
index|]
operator|.
name|state
operator|==
name|AWE_ST_ON
condition|)
name|awe_set_volume
argument_list|(
name|voice
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_and_start_voice
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|state
parameter_list|)
block|{
comment|/* calculate pitch& volume parameters */
name|voices
index|[
name|voice
index|]
operator|.
name|state
operator|=
name|state
expr_stmt|;
name|awe_calc_pitch
argument_list|(
name|voice
argument_list|)
expr_stmt|;
name|awe_calc_volume
argument_list|(
name|voice
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|AWE_ST_ON
condition|)
name|awe_note_on
argument_list|(
name|voice
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* start a voice:  *   if note is 255, identical with aftertouch function.  *   Otherwise, start a voice with specified not and volume.  */
end_comment

begin_function
specifier|static
name|int
name|awe_start_note
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|note
parameter_list|,
name|int
name|velocity
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|key
decl_stmt|,
name|state
decl_stmt|,
name|volonly
decl_stmt|;
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [on(%d) nt=%d vl=%d]\n"
argument_list|,
name|voice
argument_list|,
name|note
argument_list|,
name|velocity
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|voice_in_range
argument_list|(
name|voice
argument_list|)
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
if|if
condition|(
name|velocity
operator|==
literal|0
condition|)
name|state
operator|=
name|AWE_ST_STANDBY
expr_stmt|;
comment|/* stand by for playing */
else|else
name|state
operator|=
name|AWE_ST_ON
expr_stmt|;
comment|/* really play */
name|volonly
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|playing_mode
condition|)
block|{
case|case
name|AWE_PLAY_DIRECT
case|:
case|case
name|AWE_PLAY_INDIRECT
case|:
name|key
operator|=
name|AWE_VOICE_KEY
argument_list|(
name|voice
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|==
literal|255
condition|)
name|volonly
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|AWE_PLAY_MULTI2
case|:
name|voice
operator|=
name|voice_alloc
operator|->
name|map
index|[
name|voice
index|]
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|AWE_MAX_CHANNELS
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
comment|/* continue to below */
default|default:
if|if
condition|(
name|note
operator|>=
literal|128
condition|)
block|{
comment|/* key volume mode */
name|note
operator|-=
literal|128
expr_stmt|;
name|volonly
operator|=
name|TRUE
expr_stmt|;
block|}
name|key
operator|=
name|AWE_CHAN_KEY
argument_list|(
name|voice
argument_list|,
name|note
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* dynamic volume change */
if|if
condition|(
name|volonly
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|awe_max_voices
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|voices
index|[
name|i
index|]
operator|.
name|key
operator|==
name|key
condition|)
name|start_or_volume_change
argument_list|(
name|i
argument_list|,
name|velocity
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* if the same note still playing, stop it */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|awe_max_voices
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|voices
index|[
name|i
index|]
operator|.
name|key
operator|==
name|key
condition|)
block|{
if|if
condition|(
name|voices
index|[
name|i
index|]
operator|.
name|state
operator|==
name|AWE_ST_ON
condition|)
block|{
name|awe_note_off
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|awe_voice_init
argument_list|(
name|i
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|voices
index|[
name|i
index|]
operator|.
name|state
operator|==
name|AWE_ST_STANDBY
condition|)
name|awe_voice_init
argument_list|(
name|i
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
comment|/* allocate voices */
if|if
condition|(
name|playing_mode
operator|==
name|AWE_PLAY_DIRECT
condition|)
name|awe_alloc_one_voice
argument_list|(
name|voice
argument_list|,
name|note
argument_list|,
name|velocity
argument_list|)
expr_stmt|;
else|else
name|awe_alloc_multi_voices
argument_list|(
name|voice
argument_list|,
name|note
argument_list|,
name|velocity
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|/* turn off other voices exlusively (for drums) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|awe_max_voices
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|voices
index|[
name|i
index|]
operator|.
name|key
operator|==
name|key
condition|)
name|awe_exclusive_off
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* set up pitch and volume parameters */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|awe_max_voices
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|voices
index|[
name|i
index|]
operator|.
name|key
operator|==
name|key
operator|&&
name|voices
index|[
name|i
index|]
operator|.
name|state
operator|==
name|AWE_ST_OFF
condition|)
name|set_and_start_voice
argument_list|(
name|i
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* search instrument from preset table with the specified bank */
end_comment

begin_function
specifier|static
name|int
name|awe_search_instr
parameter_list|(
name|int
name|bank
parameter_list|,
name|int
name|preset
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|preset_table
index|[
name|preset
index|]
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|=
name|infos
index|[
name|i
index|]
operator|.
name|next_bank
control|)
block|{
if|if
condition|(
name|infos
index|[
name|i
index|]
operator|.
name|bank
operator|==
name|bank
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* assign the instrument to a voice */
end_comment

begin_function
specifier|static
name|int
name|awe_set_instr_2
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|instr_no
parameter_list|)
block|{
if|if
condition|(
name|playing_mode
operator|==
name|AWE_PLAY_MULTI2
condition|)
block|{
name|voice
operator|=
name|voice_alloc
operator|->
name|map
index|[
name|voice
index|]
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|AWE_MAX_CHANNELS
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
return|return
name|awe_set_instr
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|instr_no
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* assign the instrument to a channel; voice is the channel number */
end_comment

begin_function
specifier|static
name|int
name|awe_set_instr
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|instr_no
parameter_list|)
block|{
name|awe_chan_info
modifier|*
name|cinfo
decl_stmt|;
name|int
name|def_bank
decl_stmt|;
if|if
condition|(
operator|!
name|voice_in_range
argument_list|(
name|voice
argument_list|)
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
if|if
condition|(
name|instr_no
operator|<
literal|0
operator|||
name|instr_no
operator|>=
name|AWE_MAX_PRESETS
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|cinfo
operator|=
operator|&
name|channels
index|[
name|voice
index|]
expr_stmt|;
if|if
condition|(
name|MULTI_LAYER_MODE
argument_list|()
operator|&&
name|IS_DRUM_CHANNEL
argument_list|(
name|voice
argument_list|)
condition|)
name|def_bank
operator|=
name|AWE_DRUM_BANK
expr_stmt|;
comment|/* always search drumset */
else|else
name|def_bank
operator|=
name|cinfo
operator|->
name|bank
expr_stmt|;
name|cinfo
operator|->
name|vrec
operator|=
operator|-
literal|1
expr_stmt|;
name|cinfo
operator|->
name|def_vrec
operator|=
operator|-
literal|1
expr_stmt|;
name|cinfo
operator|->
name|vrec
operator|=
name|awe_search_instr
argument_list|(
name|def_bank
argument_list|,
name|instr_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|def_bank
operator|==
name|AWE_DRUM_BANK
condition|)
comment|/* search default drumset */
name|cinfo
operator|->
name|def_vrec
operator|=
name|awe_search_instr
argument_list|(
name|def_bank
argument_list|,
name|misc_modes
index|[
name|AWE_MD_DEF_DRUM
index|]
argument_list|)
expr_stmt|;
else|else
comment|/* search default preset */
name|cinfo
operator|->
name|def_vrec
operator|=
name|awe_search_instr
argument_list|(
name|misc_modes
index|[
name|AWE_MD_DEF_BANK
index|]
argument_list|,
name|instr_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|vrec
operator|<
literal|0
operator|&&
name|cinfo
operator|->
name|def_vrec
operator|<
literal|0
condition|)
block|{
name|DEBUG
argument_list|(
literal|1
argument_list|,
name|printk
argument_list|(
literal|"AWE32 Warning: can't find instrument %d\n"
argument_list|,
name|instr_no
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cinfo
operator|->
name|instr
operator|=
name|instr_no
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* reset all voices; terminate sounds and initialize parameters */
end_comment

begin_function
specifier|static
name|void
name|awe_reset
parameter_list|(
name|int
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|current_alloc_time
operator|=
literal|0
expr_stmt|;
comment|/* don't turn off voice 31 and 32.  they are used also for FM voices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|awe_max_voices
condition|;
name|i
operator|++
control|)
block|{
name|awe_terminate
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|awe_voice_init
argument_list|(
name|i
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_MAX_CHANNELS
condition|;
name|i
operator|++
control|)
name|awe_channel_init
argument_list|(
name|i
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|awe_operations
operator|.
name|chn_info
index|[
name|i
index|]
operator|.
name|controllers
index|[
name|CTL_MAIN_VOLUME
index|]
operator|=
literal|127
expr_stmt|;
name|awe_operations
operator|.
name|chn_info
index|[
name|i
index|]
operator|.
name|controllers
index|[
name|CTL_EXPRESSION
index|]
operator|=
literal|127
expr_stmt|;
block|}
name|awe_init_fm
argument_list|()
expr_stmt|;
name|awe_tweak
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* hardware specific control:  *   GUS specific and AWE32 specific controls are available.  */
end_comment

begin_function
specifier|static
name|void
name|awe_hw_control
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|char
modifier|*
name|event
parameter_list|)
block|{
name|int
name|cmd
init|=
name|event
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|cmd
operator|&
name|_AWE_MODE_FLAG
condition|)
name|awe_hw_awe_control
argument_list|(
name|dev
argument_list|,
name|cmd
operator|&
name|_AWE_MODE_VALUE_MASK
argument_list|,
name|event
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AWE_HAS_GUS_COMPATIBILITY
else|else
name|awe_hw_gus_control
argument_list|(
name|dev
argument_list|,
name|cmd
operator|&
name|_AWE_MODE_VALUE_MASK
argument_list|,
name|event
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|AWE_HAS_GUS_COMPATIBILITY
end_ifdef

begin_comment
comment|/* GUS compatible controls */
end_comment

begin_function
specifier|static
name|void
name|awe_hw_gus_control
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|unsigned
name|char
modifier|*
name|event
parameter_list|)
block|{
name|int
name|voice
decl_stmt|,
name|i
decl_stmt|,
name|key
decl_stmt|;
name|unsigned
name|short
name|p1
decl_stmt|;
name|short
name|p2
decl_stmt|;
name|int
name|plong
decl_stmt|;
if|if
condition|(
name|MULTI_LAYER_MODE
argument_list|()
condition|)
return|return;
if|if
condition|(
name|cmd
operator|==
name|_GUS_NUMVOICES
condition|)
return|return;
name|voice
operator|=
name|event
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|voice_in_range
argument_list|(
name|voice
argument_list|)
condition|)
return|return;
name|p1
operator|=
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|&
name|event
index|[
literal|4
index|]
expr_stmt|;
name|p2
operator|=
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|event
index|[
literal|6
index|]
expr_stmt|;
name|plong
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|event
index|[
literal|4
index|]
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|_GUS_VOICESAMPLE
case|:
name|awe_set_instr
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|p1
argument_list|)
expr_stmt|;
return|return;
case|case
name|_GUS_VOICEBALA
case|:
comment|/* 0 to 15 --> -128 to 127 */
name|awe_panning
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
operator|(
operator|(
name|int
operator|)
name|p1
operator|<<
literal|4
operator|)
operator|-
literal|128
argument_list|)
expr_stmt|;
return|return;
case|case
name|_GUS_VOICEVOL
case|:
case|case
name|_GUS_VOICEVOL2
case|:
comment|/* not supported yet */
return|return;
case|case
name|_GUS_RAMPRANGE
case|:
case|case
name|_GUS_RAMPRATE
case|:
case|case
name|_GUS_RAMPMODE
case|:
case|case
name|_GUS_RAMPON
case|:
case|case
name|_GUS_RAMPOFF
case|:
comment|/* volume ramping not supported */
return|return;
case|case
name|_GUS_VOLUME_SCALE
case|:
return|return;
case|case
name|_GUS_VOICE_POS
case|:
name|FX_SET
argument_list|(
operator|&
name|channels
index|[
name|voice
index|]
operator|.
name|fx
argument_list|,
name|AWE_FX_SAMPLE_START
argument_list|,
call|(
name|short
call|)
argument_list|(
name|plong
operator|&
literal|0x7fff
argument_list|)
argument_list|)
expr_stmt|;
name|FX_SET
argument_list|(
operator|&
name|channels
index|[
name|voice
index|]
operator|.
name|fx
argument_list|,
name|AWE_FX_COARSE_SAMPLE_START
argument_list|,
operator|(
name|plong
operator|>>
literal|15
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
return|return;
block|}
name|key
operator|=
name|AWE_VOICE_KEY
argument_list|(
name|voice
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|awe_max_voices
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|voices
index|[
name|i
index|]
operator|.
name|key
operator|==
name|key
condition|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|_GUS_VOICEON
case|:
name|awe_note_on
argument_list|(
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEOFF
case|:
name|awe_terminate
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|awe_fx_init
argument_list|(
name|voices
index|[
name|i
index|]
operator|.
name|ch
argument_list|)
expr_stmt|;
name|awe_voice_init
argument_list|(
name|i
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEFADE
case|:
name|awe_note_off
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|awe_fx_init
argument_list|(
name|voices
index|[
name|i
index|]
operator|.
name|ch
argument_list|)
expr_stmt|;
name|awe_voice_init
argument_list|(
name|i
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|_GUS_VOICEFREQ
case|:
name|awe_calc_pitch_from_freq
argument_list|(
name|i
argument_list|,
name|plong
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AWE32 specific controls */
end_comment

begin_function
specifier|static
name|void
name|awe_hw_awe_control
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|unsigned
name|char
modifier|*
name|event
parameter_list|)
block|{
name|int
name|voice
decl_stmt|;
name|unsigned
name|short
name|p1
decl_stmt|;
name|short
name|p2
decl_stmt|;
name|awe_chan_info
modifier|*
name|cinfo
decl_stmt|;
name|FX_Rec
modifier|*
name|fx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|voice
operator|=
name|event
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|voice_in_range
argument_list|(
name|voice
argument_list|)
condition|)
return|return;
if|if
condition|(
name|playing_mode
operator|==
name|AWE_PLAY_MULTI2
condition|)
block|{
name|voice
operator|=
name|voice_alloc
operator|->
name|map
index|[
name|voice
index|]
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|AWE_MAX_CHANNELS
condition|)
return|return;
block|}
name|p1
operator|=
operator|*
operator|(
name|unsigned
name|short
operator|*
operator|)
operator|&
name|event
index|[
literal|4
index|]
expr_stmt|;
name|p2
operator|=
operator|*
operator|(
name|short
operator|*
operator|)
operator|&
name|event
index|[
literal|6
index|]
expr_stmt|;
name|cinfo
operator|=
operator|&
name|channels
index|[
name|voice
index|]
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|_AWE_DEBUG_MODE
case|:
name|debug_mode
operator|=
name|p1
expr_stmt|;
name|printk
argument_list|(
literal|"AWE32: debug mode = %d\n"
argument_list|,
name|debug_mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|_AWE_REVERB_MODE
case|:
name|awe_set_reverb_mode
argument_list|(
name|p1
argument_list|)
expr_stmt|;
break|break;
case|case
name|_AWE_CHORUS_MODE
case|:
name|awe_set_chorus_mode
argument_list|(
name|p1
argument_list|)
expr_stmt|;
break|break;
case|case
name|_AWE_REMOVE_LAST_SAMPLES
case|:
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: remove last samples\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked_sf_id
operator|>
literal|0
condition|)
name|awe_remove_samples
argument_list|(
name|locked_sf_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|_AWE_INITIALIZE_CHIP
case|:
name|awe_initialize
argument_list|()
expr_stmt|;
break|break;
case|case
name|_AWE_SEND_EFFECT
case|:
name|fx
operator|=
operator|&
name|cinfo
operator|->
name|fx
expr_stmt|;
name|i
operator|=
name|FX_FLAG_SET
expr_stmt|;
if|if
condition|(
name|p1
operator|>=
literal|0x100
condition|)
block|{
name|int
name|layer
init|=
operator|(
name|p1
operator|>>
literal|8
operator|)
decl_stmt|;
if|if
condition|(
name|layer
operator|>=
literal|0
operator|&&
name|layer
operator|<
name|MAX_LAYERS
condition|)
name|fx
operator|=
operator|&
name|cinfo
operator|->
name|fx_layer
index|[
name|layer
index|]
expr_stmt|;
name|p1
operator|&=
literal|0xff
expr_stmt|;
block|}
if|if
condition|(
name|p1
operator|&
literal|0x40
condition|)
name|i
operator|=
name|FX_FLAG_OFF
expr_stmt|;
if|if
condition|(
name|p1
operator|&
literal|0x80
condition|)
name|i
operator|=
name|FX_FLAG_ADD
expr_stmt|;
name|p1
operator|&=
literal|0x3f
expr_stmt|;
if|if
condition|(
name|p1
operator|<
name|AWE_FX_END
condition|)
block|{
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: effects (%d) %d %d\n"
argument_list|,
name|voice
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|FX_FLAG_SET
condition|)
name|FX_SET
argument_list|(
name|fx
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|FX_FLAG_ADD
condition|)
name|FX_ADD
argument_list|(
name|fx
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
else|else
name|FX_UNSET
argument_list|(
name|fx
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|FX_FLAG_OFF
operator|&&
name|parm_defs
index|[
name|p1
index|]
operator|.
name|realtime
condition|)
block|{
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: fx_realtime (%d)\n"
argument_list|,
name|voice
argument_list|)
argument_list|)
expr_stmt|;
name|awe_voice_change
argument_list|(
name|voice
argument_list|,
name|parm_defs
index|[
name|p1
index|]
operator|.
name|realtime
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|_AWE_RESET_CHANNEL
case|:
name|awe_channel_init
argument_list|(
name|voice
argument_list|,
operator|!
name|p1
argument_list|)
expr_stmt|;
break|break;
case|case
name|_AWE_TERMINATE_ALL
case|:
name|awe_reset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|_AWE_TERMINATE_CHANNEL
case|:
name|awe_voice_change
argument_list|(
name|voice
argument_list|,
name|awe_terminate_and_init
argument_list|)
expr_stmt|;
break|break;
case|case
name|_AWE_RELEASE_ALL
case|:
name|awe_note_off_all
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
name|_AWE_NOTEOFF_ALL
case|:
name|awe_note_off_all
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|_AWE_INITIAL_VOLUME
case|:
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: init attenuation %d\n"
argument_list|,
name|p1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p2
operator|==
literal|0
condition|)
comment|/* absolute value */
name|init_atten
operator|=
operator|(
name|short
operator|)
name|p1
expr_stmt|;
else|else
comment|/* relative value */
name|init_atten
operator|=
name|misc_modes
index|[
name|AWE_MD_ZERO_ATTEN
index|]
operator|+
operator|(
name|short
operator|)
name|p1
expr_stmt|;
if|if
condition|(
name|init_atten
operator|<
literal|0
condition|)
name|init_atten
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|awe_max_voices
condition|;
name|i
operator|++
control|)
name|awe_set_voice_vol
argument_list|(
name|i
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|_AWE_CHN_PRESSURE
case|:
name|cinfo
operator|->
name|chan_press
operator|=
name|p1
expr_stmt|;
name|p1
operator|=
name|p1
operator|*
name|misc_modes
index|[
name|AWE_MD_MOD_SENSE
index|]
operator|/
literal|1200
expr_stmt|;
name|FX_ADD
argument_list|(
operator|&
name|cinfo
operator|->
name|fx
argument_list|,
name|AWE_FX_LFO1_PITCH
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|awe_voice_change
argument_list|(
name|voice
argument_list|,
name|awe_fx_fmmod
argument_list|)
expr_stmt|;
name|FX_ADD
argument_list|(
operator|&
name|cinfo
operator|->
name|fx
argument_list|,
name|AWE_FX_LFO2_PITCH
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|awe_voice_change
argument_list|(
name|voice
argument_list|,
name|awe_fx_fm2frq2
argument_list|)
expr_stmt|;
break|break;
case|case
name|_AWE_CHANNEL_MODE
case|:
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: channel mode = %d\n"
argument_list|,
name|p1
argument_list|)
argument_list|)
expr_stmt|;
name|playing_mode
operator|=
name|p1
expr_stmt|;
name|awe_reset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|_AWE_DRUM_CHANNELS
case|:
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: drum flags = %x\n"
argument_list|,
name|p1
argument_list|)
argument_list|)
expr_stmt|;
name|drum_flags
operator|=
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|&
name|event
index|[
literal|4
index|]
expr_stmt|;
break|break;
case|case
name|_AWE_MISC_MODE
case|:
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: misc mode = %d %d\n"
argument_list|,
name|p1
argument_list|,
name|p2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|>
name|AWE_MD_VERSION
operator|&&
name|p1
operator|<
name|AWE_MD_END
condition|)
name|misc_modes
index|[
name|p1
index|]
operator|=
name|p2
expr_stmt|;
break|break;
case|case
name|_AWE_EQUALIZER
case|:
name|awe_equalizer
argument_list|(
operator|(
name|int
operator|)
name|p1
argument_list|,
operator|(
name|int
operator|)
name|p2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: hw control cmd=%d voice=%d\n"
argument_list|,
name|cmd
argument_list|,
name|voice
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* voice pressure change */
end_comment

begin_function
specifier|static
name|void
name|awe_aftertouch
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|pressure
parameter_list|)
block|{
name|int
name|note
decl_stmt|;
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [after(%d) %d]\n"
argument_list|,
name|voice
argument_list|,
name|pressure
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|voice_in_range
argument_list|(
name|voice
argument_list|)
condition|)
return|return;
switch|switch
condition|(
name|playing_mode
condition|)
block|{
case|case
name|AWE_PLAY_DIRECT
case|:
case|case
name|AWE_PLAY_INDIRECT
case|:
name|awe_start_note
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
literal|255
argument_list|,
name|pressure
argument_list|)
expr_stmt|;
break|break;
case|case
name|AWE_PLAY_MULTI2
case|:
name|note
operator|=
operator|(
name|voice_alloc
operator|->
name|map
index|[
name|voice
index|]
operator|&
literal|0xff
operator|)
operator|-
literal|1
expr_stmt|;
name|awe_start_note
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|note
operator|+
literal|0x80
argument_list|,
name|pressure
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* voice control change */
end_comment

begin_function
specifier|static
name|void
name|awe_controller
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|ctrl_num
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|awe_chan_info
modifier|*
name|cinfo
decl_stmt|;
if|if
condition|(
operator|!
name|voice_in_range
argument_list|(
name|voice
argument_list|)
condition|)
return|return;
if|if
condition|(
name|playing_mode
operator|==
name|AWE_PLAY_MULTI2
condition|)
block|{
name|voice
operator|=
name|voice_alloc
operator|->
name|map
index|[
name|voice
index|]
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|AWE_MAX_CHANNELS
condition|)
return|return;
block|}
name|cinfo
operator|=
operator|&
name|channels
index|[
name|voice
index|]
expr_stmt|;
switch|switch
condition|(
name|ctrl_num
condition|)
block|{
case|case
name|CTL_BANK_SELECT
case|:
comment|/* MIDI control #0 */
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [bank(%d) %d]\n"
argument_list|,
name|voice
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MULTI_LAYER_MODE
argument_list|()
operator|&&
name|IS_DRUM_CHANNEL
argument_list|(
name|voice
argument_list|)
operator|&&
operator|!
name|misc_modes
index|[
name|AWE_MD_TOGGLE_DRUM_BANK
index|]
condition|)
break|break;
name|cinfo
operator|->
name|bank
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|cinfo
operator|->
name|bank
operator|==
name|AWE_DRUM_BANK
condition|)
name|DRUM_CHANNEL_ON
argument_list|(
name|cinfo
operator|->
name|channel
argument_list|)
expr_stmt|;
else|else
name|DRUM_CHANNEL_OFF
argument_list|(
name|cinfo
operator|->
name|channel
argument_list|)
expr_stmt|;
name|awe_set_instr
argument_list|(
name|dev
argument_list|,
name|voice
argument_list|,
name|cinfo
operator|->
name|instr
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_MODWHEEL
case|:
comment|/* MIDI control #1 */
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [modwheel(%d) %d]\n"
argument_list|,
name|voice
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|value
operator|*
name|misc_modes
index|[
name|AWE_MD_MOD_SENSE
index|]
operator|/
literal|1200
expr_stmt|;
name|FX_ADD
argument_list|(
operator|&
name|cinfo
operator|->
name|fx
argument_list|,
name|AWE_FX_LFO1_PITCH
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|awe_voice_change
argument_list|(
name|voice
argument_list|,
name|awe_fx_fmmod
argument_list|)
expr_stmt|;
name|FX_ADD
argument_list|(
operator|&
name|cinfo
operator|->
name|fx
argument_list|,
name|AWE_FX_LFO2_PITCH
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|awe_voice_change
argument_list|(
name|voice
argument_list|,
name|awe_fx_fm2frq2
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRL_PITCH_BENDER
case|:
comment|/* SEQ1 V2 contorl */
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [bend(%d) %d]\n"
argument_list|,
name|voice
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zero centered */
name|cinfo
operator|->
name|bender
operator|=
name|value
expr_stmt|;
name|awe_voice_change
argument_list|(
name|voice
argument_list|,
name|awe_set_voice_pitch
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTRL_PITCH_BENDER_RANGE
case|:
comment|/* SEQ1 V2 control */
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [range(%d) %d]\n"
argument_list|,
name|voice
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* value = sense x 100 */
name|cinfo
operator|->
name|bender_range
operator|=
name|value
expr_stmt|;
comment|/* no audible pitch change yet.. */
break|break;
case|case
name|CTL_EXPRESSION
case|:
comment|/* MIDI control #11 */
if|if
condition|(
name|SINGLE_LAYER_MODE
argument_list|()
condition|)
name|value
operator|/=
literal|128
expr_stmt|;
case|case
name|CTRL_EXPRESSION
case|:
comment|/* SEQ1 V2 control */
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [expr(%d) %d]\n"
argument_list|,
name|voice
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 0 - 127 */
name|cinfo
operator|->
name|expression_vol
operator|=
name|value
expr_stmt|;
name|awe_voice_change
argument_list|(
name|voice
argument_list|,
name|awe_set_voice_vol
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_PAN
case|:
comment|/* MIDI control #10 */
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [pan(%d) %d]\n"
argument_list|,
name|voice
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* (0-127) -> signed 8bit */
name|cinfo
operator|->
name|panning
operator|=
name|value
operator|*
literal|2
operator|-
literal|128
expr_stmt|;
if|if
condition|(
name|misc_modes
index|[
name|AWE_MD_REALTIME_PAN
index|]
condition|)
name|awe_voice_change
argument_list|(
name|voice
argument_list|,
name|awe_set_pan
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_MAIN_VOLUME
case|:
comment|/* MIDI control #7 */
if|if
condition|(
name|SINGLE_LAYER_MODE
argument_list|()
condition|)
name|value
operator|=
operator|(
name|value
operator|*
literal|100
operator|)
operator|/
literal|16383
expr_stmt|;
case|case
name|CTRL_MAIN_VOLUME
case|:
comment|/* SEQ1 V2 control */
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [mainvol(%d) %d]\n"
argument_list|,
name|voice
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 0 - 127 */
name|cinfo
operator|->
name|main_vol
operator|=
name|value
expr_stmt|;
name|awe_voice_change
argument_list|(
name|voice
argument_list|,
name|awe_set_voice_vol
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_EXT_EFF_DEPTH
case|:
comment|/* reverb effects: 0-127 */
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [reverb(%d) %d]\n"
argument_list|,
name|voice
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|FX_SET
argument_list|(
operator|&
name|cinfo
operator|->
name|fx
argument_list|,
name|AWE_FX_REVERB
argument_list|,
name|value
operator|*
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_CHORUS_DEPTH
case|:
comment|/* chorus effects: 0-127 */
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [chorus(%d) %d]\n"
argument_list|,
name|voice
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|FX_SET
argument_list|(
operator|&
name|cinfo
operator|->
name|fx
argument_list|,
name|AWE_FX_CHORUS
argument_list|,
name|value
operator|*
literal|2
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|AWE_ACCEPT_ALL_SOUNDS_CONTROLL
case|case
literal|120
case|:
comment|/* all sounds off */
name|awe_note_off_all
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|123
case|:
comment|/* all notes off */
name|awe_note_off_all
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|CTL_SUSTAIN
case|:
comment|/* MIDI control #64 */
name|cinfo
operator|->
name|sustained
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|value
operator|!=
literal|127
condition|)
name|awe_voice_change
argument_list|(
name|voice
argument_list|,
name|awe_sustain_off
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTL_SOSTENUTO
case|:
comment|/* MIDI control #66 */
if|if
condition|(
name|value
operator|==
literal|127
condition|)
name|awe_voice_change
argument_list|(
name|voice
argument_list|,
name|awe_sostenuto_on
argument_list|)
expr_stmt|;
else|else
name|awe_voice_change
argument_list|(
name|voice
argument_list|,
name|awe_sustain_off
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [control(%d) ctrl=%d val=%d]\n"
argument_list|,
name|voice
argument_list|,
name|ctrl_num
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* voice pan change (value = -128 - 127) */
end_comment

begin_function
specifier|static
name|void
name|awe_panning
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|awe_chan_info
modifier|*
name|cinfo
decl_stmt|;
if|if
condition|(
operator|!
name|voice_in_range
argument_list|(
name|voice
argument_list|)
condition|)
return|return;
if|if
condition|(
name|playing_mode
operator|==
name|AWE_PLAY_MULTI2
condition|)
block|{
name|voice
operator|=
name|voice_alloc
operator|->
name|map
index|[
name|voice
index|]
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|AWE_MAX_CHANNELS
condition|)
return|return;
block|}
name|cinfo
operator|=
operator|&
name|channels
index|[
name|voice
index|]
expr_stmt|;
name|cinfo
operator|->
name|panning
operator|=
name|value
expr_stmt|;
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [pan(%d) %d]\n"
argument_list|,
name|voice
argument_list|,
name|cinfo
operator|->
name|panning
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|misc_modes
index|[
name|AWE_MD_REALTIME_PAN
index|]
condition|)
name|awe_voice_change
argument_list|(
name|voice
argument_list|,
name|awe_set_pan
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* volume mode change */
end_comment

begin_function
specifier|static
name|void
name|awe_volume_method
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
comment|/* not impremented */
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [volmethod mode=%d]\n"
argument_list|,
name|mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|AWE_NO_PATCHMGR
end_ifndef

begin_comment
comment|/* patch manager */
end_comment

begin_function
specifier|static
name|int
name|awe_patchmgr
parameter_list|(
name|int
name|dev
parameter_list|,
name|struct
name|patmgr_info
modifier|*
name|rec
parameter_list|)
block|{
name|printk
argument_list|(
literal|"AWE32 Warning: patch manager control not supported\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* pitch wheel change: 0-16384 */
end_comment

begin_function
specifier|static
name|void
name|awe_bender
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|awe_chan_info
modifier|*
name|cinfo
decl_stmt|;
if|if
condition|(
operator|!
name|voice_in_range
argument_list|(
name|voice
argument_list|)
condition|)
return|return;
if|if
condition|(
name|playing_mode
operator|==
name|AWE_PLAY_MULTI2
condition|)
block|{
name|voice
operator|=
name|voice_alloc
operator|->
name|map
index|[
name|voice
index|]
operator|>>
literal|8
expr_stmt|;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|AWE_MAX_CHANNELS
condition|)
return|return;
block|}
comment|/* convert to zero centered value */
name|cinfo
operator|=
operator|&
name|channels
index|[
name|voice
index|]
expr_stmt|;
name|cinfo
operator|->
name|bender
operator|=
name|value
operator|-
literal|8192
expr_stmt|;
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [bend(%d) %d]\n"
argument_list|,
name|voice
argument_list|,
name|cinfo
operator|->
name|bender
argument_list|)
argument_list|)
expr_stmt|;
name|awe_voice_change
argument_list|(
name|voice
argument_list|,
name|awe_set_voice_pitch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------  * load a sound patch:  *   three types of patches are accepted: AWE, GUS, and SYSEX.  *----------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|awe_load_patch
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|format
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|offs
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|pmgr_flag
parameter_list|)
block|{
name|awe_patch_info
name|patch
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|AWE_HAS_GUS_COMPATIBILITY
if|if
condition|(
name|format
operator|==
name|GUS_PATCH
condition|)
block|{
return|return
name|awe_load_guspatch
argument_list|(
name|addr
argument_list|,
name|offs
argument_list|,
name|count
argument_list|,
name|pmgr_flag
argument_list|)
return|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|format
operator|==
name|SYSEX_PATCH
condition|)
block|{
comment|/* no system exclusive message supported yet */
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|format
operator|!=
name|AWE_PATCH
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32 Error: Invalid patch format (key) 0x%x\n"
argument_list|,
name|format
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|count
operator|<
name|AWE_PATCH_INFO_SIZE
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32 Error: Patch header too short\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|COPY_FROM_USER
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|patch
operator|)
operator|+
name|offs
argument_list|,
name|addr
argument_list|,
name|offs
argument_list|,
name|AWE_PATCH_INFO_SIZE
operator|-
name|offs
argument_list|)
expr_stmt|;
name|count
operator|-=
name|AWE_PATCH_INFO_SIZE
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|patch
operator|.
name|len
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32: sample: Patch record too short (%d<%d)\n"
argument_list|,
name|count
argument_list|,
name|patch
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
switch|switch
condition|(
name|patch
operator|.
name|type
condition|)
block|{
case|case
name|AWE_LOAD_INFO
case|:
name|rc
operator|=
name|awe_load_info
argument_list|(
operator|&
name|patch
argument_list|,
name|addr
argument_list|,
name|count
argument_list|)
expr_stmt|;
break|break;
case|case
name|AWE_LOAD_DATA
case|:
name|rc
operator|=
name|awe_load_data
argument_list|(
operator|&
name|patch
argument_list|,
name|addr
argument_list|,
name|count
argument_list|)
expr_stmt|;
break|break;
case|case
name|AWE_OPEN_PATCH
case|:
name|rc
operator|=
name|awe_open_patch
argument_list|(
operator|&
name|patch
argument_list|,
name|addr
argument_list|,
name|count
argument_list|)
expr_stmt|;
break|break;
case|case
name|AWE_CLOSE_PATCH
case|:
name|rc
operator|=
name|awe_close_patch
argument_list|(
operator|&
name|patch
argument_list|,
name|addr
argument_list|,
name|count
argument_list|)
expr_stmt|;
break|break;
case|case
name|AWE_UNLOAD_PATCH
case|:
name|rc
operator|=
name|awe_unload_patch
argument_list|(
operator|&
name|patch
argument_list|,
name|addr
argument_list|,
name|count
argument_list|)
expr_stmt|;
break|break;
case|case
name|AWE_REPLACE_DATA
case|:
name|rc
operator|=
name|awe_replace_data
argument_list|(
operator|&
name|patch
argument_list|,
name|addr
argument_list|,
name|count
argument_list|)
expr_stmt|;
break|break;
case|case
name|AWE_MAP_PRESET
case|:
name|rc
operator|=
name|awe_load_map
argument_list|(
operator|&
name|patch
argument_list|,
name|addr
argument_list|,
name|count
argument_list|)
expr_stmt|;
break|break;
case|case
name|AWE_LOAD_CHORUS_FX
case|:
name|rc
operator|=
name|awe_load_chorus_fx
argument_list|(
operator|&
name|patch
argument_list|,
name|addr
argument_list|,
name|count
argument_list|)
expr_stmt|;
break|break;
case|case
name|AWE_LOAD_REVERB_FX
case|:
name|rc
operator|=
name|awe_load_reverb_fx
argument_list|(
operator|&
name|patch
argument_list|,
name|addr
argument_list|,
name|count
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printk
argument_list|(
literal|"AWE32 Error: unknown patch format type %d\n"
argument_list|,
name|patch
operator|.
name|type
argument_list|)
expr_stmt|;
name|rc
operator|=
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/* create an sflist record */
end_comment

begin_function
specifier|static
name|int
name|awe_create_sf
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|sf_list
modifier|*
name|rec
decl_stmt|;
comment|/* terminate sounds */
name|awe_reset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_sf_id
operator|>=
name|max_sfs
condition|)
block|{
name|int
name|newsize
init|=
name|max_sfs
operator|+
name|AWE_MAX_SF_LISTS
decl_stmt|;
name|sf_list
modifier|*
name|newlist
init|=
name|my_realloc
argument_list|(
name|sflists
argument_list|,
sizeof|sizeof
argument_list|(
name|sf_list
argument_list|)
operator|*
name|max_sfs
argument_list|,
sizeof|sizeof
argument_list|(
name|sf_list
argument_list|)
operator|*
name|newsize
argument_list|)
decl_stmt|;
if|if
condition|(
name|newlist
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
name|sflists
operator|=
name|newlist
expr_stmt|;
name|max_sfs
operator|=
name|newsize
expr_stmt|;
block|}
name|rec
operator|=
operator|&
name|sflists
index|[
name|current_sf_id
index|]
expr_stmt|;
name|rec
operator|->
name|sf_id
operator|=
name|current_sf_id
operator|+
literal|1
expr_stmt|;
name|rec
operator|->
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|current_sf_id
operator|==
literal|0
operator|||
operator|(
name|type
operator|&
name|AWE_PAT_LOCKED
operator|)
operator|!=
literal|0
condition|)
name|locked_sf_id
operator|=
name|current_sf_id
operator|+
literal|1
expr_stmt|;
comment|/* 	if (name) 		MEMCPY(rec->name, name, AWE_PATCH_NAME_LEN); 	else 		BZERO(rec->name, AWE_PATCH_NAME_LEN); 	 */
name|rec
operator|->
name|num_info
operator|=
name|awe_free_info
argument_list|()
expr_stmt|;
name|rec
operator|->
name|num_sample
operator|=
name|awe_free_sample
argument_list|()
expr_stmt|;
name|rec
operator|->
name|mem_ptr
operator|=
name|awe_free_mem_ptr
argument_list|()
expr_stmt|;
name|rec
operator|->
name|infos
operator|=
operator|-
literal|1
expr_stmt|;
name|rec
operator|->
name|samples
operator|=
operator|-
literal|1
expr_stmt|;
name|current_sf_id
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* open patch; create sf list and set opened flag */
end_comment

begin_function
specifier|static
name|int
name|awe_open_patch
parameter_list|(
name|awe_patch_info
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|awe_open_parm
name|parm
decl_stmt|;
name|COPY_FROM_USER
argument_list|(
operator|&
name|parm
argument_list|,
name|addr
argument_list|,
name|AWE_PATCH_INFO_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|awe_create_sf
argument_list|(
name|parm
operator|.
name|type
argument_list|,
name|parm
operator|.
name|name
argument_list|)
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32: can't open: failed to alloc new list\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
name|patch_opened
operator|=
name|TRUE
expr_stmt|;
return|return
name|current_sf_id
return|;
block|}
end_function

begin_comment
comment|/* check if the patch is already opened */
end_comment

begin_function
specifier|static
name|int
name|check_patch_opened
parameter_list|(
name|int
name|type
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
operator|!
name|patch_opened
condition|)
block|{
if|if
condition|(
name|awe_create_sf
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32: failed to alloc new list\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
name|patch_opened
operator|=
name|TRUE
expr_stmt|;
return|return
name|current_sf_id
return|;
block|}
return|return
name|current_sf_id
return|;
block|}
end_function

begin_comment
comment|/* close the patch; if no voice is loaded, remove the patch */
end_comment

begin_function
specifier|static
name|int
name|awe_close_patch
parameter_list|(
name|awe_patch_info
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
if|if
condition|(
name|patch_opened
operator|&&
name|current_sf_id
operator|>
literal|0
condition|)
block|{
comment|/* if no voice is loaded, release the current patch */
if|if
condition|(
name|sflists
index|[
name|current_sf_id
operator|-
literal|1
index|]
operator|.
name|infos
operator|==
operator|-
literal|1
condition|)
name|awe_remove_samples
argument_list|(
name|current_sf_id
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|patch_opened
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* remove the latest patch */
end_comment

begin_function
specifier|static
name|int
name|awe_unload_patch
parameter_list|(
name|awe_patch_info
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
if|if
condition|(
name|current_sf_id
operator|>
literal|0
condition|)
name|awe_remove_samples
argument_list|(
name|current_sf_id
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* allocate voice info list records */
end_comment

begin_function
specifier|static
name|int
name|alloc_new_info
parameter_list|(
name|int
name|nvoices
parameter_list|)
block|{
name|int
name|newsize
decl_stmt|,
name|free_info
decl_stmt|;
name|awe_voice_list
modifier|*
name|newlist
decl_stmt|;
name|free_info
operator|=
name|awe_free_info
argument_list|()
expr_stmt|;
if|if
condition|(
name|free_info
operator|+
name|nvoices
operator|>=
name|max_infos
condition|)
block|{
do|do
block|{
name|newsize
operator|=
name|max_infos
operator|+
name|AWE_MAX_INFOS
expr_stmt|;
block|}
do|while
condition|(
name|free_info
operator|+
name|nvoices
operator|>=
name|newsize
condition|)
do|;
name|newlist
operator|=
name|my_realloc
argument_list|(
name|infos
argument_list|,
sizeof|sizeof
argument_list|(
name|awe_voice_list
argument_list|)
operator|*
name|max_infos
argument_list|,
sizeof|sizeof
argument_list|(
name|awe_voice_list
argument_list|)
operator|*
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlist
operator|==
name|NULL
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32: can't alloc info table\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
name|infos
operator|=
name|newlist
expr_stmt|;
name|max_infos
operator|=
name|newsize
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* allocate sample info list records */
end_comment

begin_function
specifier|static
name|int
name|alloc_new_sample
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|newsize
decl_stmt|,
name|free_sample
decl_stmt|;
name|awe_sample_list
modifier|*
name|newlist
decl_stmt|;
name|free_sample
operator|=
name|awe_free_sample
argument_list|()
expr_stmt|;
if|if
condition|(
name|free_sample
operator|>=
name|max_samples
condition|)
block|{
name|newsize
operator|=
name|max_samples
operator|+
name|AWE_MAX_SAMPLES
expr_stmt|;
name|newlist
operator|=
name|my_realloc
argument_list|(
name|samples
argument_list|,
sizeof|sizeof
argument_list|(
name|awe_sample_list
argument_list|)
operator|*
name|max_samples
argument_list|,
sizeof|sizeof
argument_list|(
name|awe_sample_list
argument_list|)
operator|*
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlist
operator|==
name|NULL
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32: can't alloc sample table\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
name|samples
operator|=
name|newlist
expr_stmt|;
name|max_samples
operator|=
name|newsize
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* load voice map */
end_comment

begin_function
specifier|static
name|int
name|awe_load_map
parameter_list|(
name|awe_patch_info
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|awe_voice_map
name|map
decl_stmt|;
name|awe_voice_list
modifier|*
name|rec
decl_stmt|;
name|int
name|free_info
decl_stmt|;
if|if
condition|(
name|check_patch_opened
argument_list|(
name|AWE_PAT_TYPE_MAP
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
if|if
condition|(
name|alloc_new_info
argument_list|(
literal|1
argument_list|)
operator|<
literal|0
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
name|COPY_FROM_USER
argument_list|(
operator|&
name|map
argument_list|,
name|addr
argument_list|,
name|AWE_PATCH_INFO_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|map
argument_list|)
argument_list|)
expr_stmt|;
name|free_info
operator|=
name|awe_free_info
argument_list|()
expr_stmt|;
name|rec
operator|=
operator|&
name|infos
index|[
name|free_info
index|]
expr_stmt|;
name|rec
operator|->
name|bank
operator|=
name|map
operator|.
name|map_bank
expr_stmt|;
name|rec
operator|->
name|instr
operator|=
name|map
operator|.
name|map_instr
expr_stmt|;
name|rec
operator|->
name|type
operator|=
name|V_ST_MAPPED
expr_stmt|;
name|rec
operator|->
name|disabled
operator|=
name|FALSE
expr_stmt|;
name|awe_init_voice_info
argument_list|(
operator|&
name|rec
operator|->
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
operator|.
name|map_key
operator|>=
literal|0
condition|)
block|{
name|rec
operator|->
name|v
operator|.
name|low
operator|=
name|map
operator|.
name|map_key
expr_stmt|;
name|rec
operator|->
name|v
operator|.
name|high
operator|=
name|map
operator|.
name|map_key
expr_stmt|;
block|}
name|rec
operator|->
name|v
operator|.
name|start
operator|=
name|map
operator|.
name|src_instr
expr_stmt|;
name|rec
operator|->
name|v
operator|.
name|end
operator|=
name|map
operator|.
name|src_bank
expr_stmt|;
name|rec
operator|->
name|v
operator|.
name|fixkey
operator|=
name|map
operator|.
name|src_key
expr_stmt|;
name|rec
operator|->
name|v
operator|.
name|sf_id
operator|=
name|current_sf_id
expr_stmt|;
name|add_info_list
argument_list|(
name|free_info
argument_list|)
expr_stmt|;
name|add_sf_info
argument_list|(
name|free_info
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* load voice information data */
end_comment

begin_function
specifier|static
name|int
name|awe_load_info
parameter_list|(
name|awe_patch_info
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|awe_voice_rec_hdr
name|hdr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|total_size
decl_stmt|;
if|if
condition|(
name|count
operator|<
name|AWE_VOICE_REC_SIZE
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32 Error: invalid patch info length\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|offset
operator|=
name|AWE_PATCH_INFO_SIZE
expr_stmt|;
name|COPY_FROM_USER
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hdr
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|,
name|AWE_VOICE_REC_SIZE
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|AWE_VOICE_REC_SIZE
expr_stmt|;
if|if
condition|(
name|hdr
operator|.
name|nvoices
operator|<=
literal|0
operator|||
name|hdr
operator|.
name|nvoices
operator|>=
literal|100
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32 Error: Illegal voice number %d\n"
argument_list|,
name|hdr
operator|.
name|nvoices
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|total_size
operator|=
name|AWE_VOICE_REC_SIZE
operator|+
name|AWE_VOICE_INFO_SIZE
operator|*
name|hdr
operator|.
name|nvoices
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|total_size
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32 Error: patch length(%d) is smaller than nvoices(%d)\n"
argument_list|,
name|count
argument_list|,
name|hdr
operator|.
name|nvoices
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|check_patch_opened
argument_list|(
name|AWE_PAT_TYPE_MISC
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
if|#
directive|if
literal|0
comment|/* it looks like not so useful.. */
comment|/* check if the same preset already exists in the info list */
block|for (i = sflists[current_sf_id-1].infos; i>= 0; i = infos[i].next) { 		if (infos[i].disabled) continue; 		if (infos[i].bank == hdr.bank&& infos[i].instr == hdr.instr) {
comment|/* in exclusive mode, do skip loading this */
block|if (hdr.write_mode == AWE_WR_EXCLUSIVE) 				return 0;
comment|/* in replace mode, disable the old data */
block|else if (hdr.write_mode == AWE_WR_REPLACE) 				infos[i].disabled = TRUE; 		} 	} 	if (hdr.write_mode == AWE_WR_REPLACE) 		rebuild_preset_list();
endif|#
directive|endif
if|if
condition|(
name|alloc_new_info
argument_list|(
name|hdr
operator|.
name|nvoices
argument_list|)
operator|<
literal|0
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|.
name|nvoices
condition|;
name|i
operator|++
control|)
block|{
name|int
name|rec
init|=
name|awe_free_info
argument_list|()
decl_stmt|;
name|infos
index|[
name|rec
index|]
operator|.
name|bank
operator|=
name|hdr
operator|.
name|bank
expr_stmt|;
name|infos
index|[
name|rec
index|]
operator|.
name|instr
operator|=
name|hdr
operator|.
name|instr
expr_stmt|;
name|infos
index|[
name|rec
index|]
operator|.
name|type
operator|=
name|V_ST_NORMAL
expr_stmt|;
name|infos
index|[
name|rec
index|]
operator|.
name|disabled
operator|=
name|FALSE
expr_stmt|;
comment|/* copy awe_voice_info parameters */
name|COPY_FROM_USER
argument_list|(
operator|&
name|infos
index|[
name|rec
index|]
operator|.
name|v
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|,
name|AWE_VOICE_INFO_SIZE
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|AWE_VOICE_INFO_SIZE
expr_stmt|;
name|infos
index|[
name|rec
index|]
operator|.
name|v
operator|.
name|sf_id
operator|=
name|current_sf_id
expr_stmt|;
if|if
condition|(
name|infos
index|[
name|rec
index|]
operator|.
name|v
operator|.
name|mode
operator|&
name|AWE_MODE_INIT_PARM
condition|)
name|awe_init_voice_parm
argument_list|(
operator|&
name|infos
index|[
name|rec
index|]
operator|.
name|v
operator|.
name|parm
argument_list|)
expr_stmt|;
name|awe_set_sample
argument_list|(
operator|&
name|infos
index|[
name|rec
index|]
operator|.
name|v
argument_list|)
expr_stmt|;
name|add_info_list
argument_list|(
name|rec
argument_list|)
expr_stmt|;
name|add_sf_info
argument_list|(
name|rec
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* load wave sample data */
end_comment

begin_function
specifier|static
name|int
name|awe_load_data
parameter_list|(
name|awe_patch_info
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|offset
decl_stmt|,
name|size
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|free_sample
decl_stmt|;
name|awe_sample_info
modifier|*
name|rec
decl_stmt|;
if|if
condition|(
name|check_patch_opened
argument_list|(
name|AWE_PAT_TYPE_MISC
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
if|if
condition|(
name|alloc_new_sample
argument_list|()
operator|<
literal|0
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
name|free_sample
operator|=
name|awe_free_sample
argument_list|()
expr_stmt|;
name|rec
operator|=
operator|&
name|samples
index|[
name|free_sample
index|]
operator|.
name|v
expr_stmt|;
name|size
operator|=
operator|(
name|count
operator|-
name|AWE_SAMPLE_INFO_SIZE
operator|)
operator|/
literal|2
expr_stmt|;
name|offset
operator|=
name|AWE_PATCH_INFO_SIZE
expr_stmt|;
name|COPY_FROM_USER
argument_list|(
name|rec
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|,
name|AWE_SAMPLE_INFO_SIZE
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|AWE_SAMPLE_INFO_SIZE
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|rec
operator|->
name|size
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32: load: sample size differed (%d != %d)\n"
argument_list|,
name|rec
operator|->
name|size
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|rec
operator|->
name|size
operator|>
literal|0
condition|)
if|if
condition|(
operator|(
name|rc
operator|=
name|awe_write_wave_data
argument_list|(
name|addr
argument_list|,
name|offset
argument_list|,
name|rec
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rc
return|;
name|rec
operator|->
name|sf_id
operator|=
name|current_sf_id
expr_stmt|;
name|add_sf_sample
argument_list|(
name|free_sample
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* replace wave sample data */
end_comment

begin_function
specifier|static
name|int
name|awe_replace_data
parameter_list|(
name|awe_patch_info
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|offset
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|int
name|channels
decl_stmt|;
name|awe_sample_info
name|cursmp
decl_stmt|;
name|int
name|save_mem_ptr
decl_stmt|;
if|if
condition|(
operator|!
name|patch_opened
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32: replace: patch not opened\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|size
operator|=
operator|(
name|count
operator|-
name|AWE_SAMPLE_INFO_SIZE
operator|)
operator|/
literal|2
expr_stmt|;
name|offset
operator|=
name|AWE_PATCH_INFO_SIZE
expr_stmt|;
name|COPY_FROM_USER
argument_list|(
operator|&
name|cursmp
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|,
name|AWE_SAMPLE_INFO_SIZE
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|AWE_SAMPLE_INFO_SIZE
expr_stmt|;
if|if
condition|(
name|cursmp
operator|.
name|size
operator|==
literal|0
operator|||
name|size
operator|!=
name|cursmp
operator|.
name|size
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32: replace: illegal sample size (%d!=%d)\n"
argument_list|,
name|cursmp
operator|.
name|size
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|channels
operator|=
name|patch
operator|->
name|optarg
expr_stmt|;
if|if
condition|(
name|channels
operator|<=
literal|0
operator|||
name|channels
operator|>
name|AWE_NORMAL_VOICES
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32: replace: illegal channels %d\n"
argument_list|,
name|channels
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
for|for
control|(
name|i
operator|=
name|sflists
index|[
name|current_sf_id
operator|-
literal|1
index|]
operator|.
name|samples
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|=
name|samples
index|[
name|i
index|]
operator|.
name|next
control|)
block|{
if|if
condition|(
name|samples
index|[
name|i
index|]
operator|.
name|v
operator|.
name|sample
operator|==
name|cursmp
operator|.
name|sample
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32: replace: cannot find existing sample data %d\n"
argument_list|,
name|cursmp
operator|.
name|sample
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|samples
index|[
name|i
index|]
operator|.
name|v
operator|.
name|size
operator|!=
name|cursmp
operator|.
name|size
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32: replace: exiting size differed (%d!=%d)\n"
argument_list|,
name|samples
index|[
name|i
index|]
operator|.
name|v
operator|.
name|size
argument_list|,
name|cursmp
operator|.
name|size
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|save_mem_ptr
operator|=
name|awe_free_mem_ptr
argument_list|()
expr_stmt|;
name|sflists
index|[
name|current_sf_id
operator|-
literal|1
index|]
operator|.
name|mem_ptr
operator|=
name|samples
index|[
name|i
index|]
operator|.
name|v
operator|.
name|start
operator|-
name|awe_mem_start
expr_stmt|;
name|MEMCPY
argument_list|(
operator|&
name|samples
index|[
name|i
index|]
operator|.
name|v
argument_list|,
operator|&
name|cursmp
argument_list|,
sizeof|sizeof
argument_list|(
name|cursmp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|awe_write_wave_data
argument_list|(
name|addr
argument_list|,
name|offset
argument_list|,
operator|&
name|samples
index|[
name|i
index|]
operator|.
name|v
argument_list|,
name|channels
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rc
return|;
name|sflists
index|[
name|current_sf_id
operator|-
literal|1
index|]
operator|.
name|mem_ptr
operator|=
name|save_mem_ptr
expr_stmt|;
name|samples
index|[
name|i
index|]
operator|.
name|v
operator|.
name|sf_id
operator|=
name|current_sf_id
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|readbuf_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readbuf_offs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readbuf_flags
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_decl_stmt
specifier|static
name|unsigned
name|short
modifier|*
name|readbuf_loop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readbuf_loopstart
decl_stmt|,
name|readbuf_loopend
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* initialize read buffer */
end_comment

begin_function
specifier|static
name|int
name|readbuf_init
parameter_list|(
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|offset
parameter_list|,
name|awe_sample_info
modifier|*
name|sp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|readbuf_loop
operator|=
name|NULL
expr_stmt|;
name|readbuf_loopstart
operator|=
name|sp
operator|->
name|loopstart
expr_stmt|;
name|readbuf_loopend
operator|=
name|sp
operator|->
name|loopend
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|mode_flags
operator|&
operator|(
name|AWE_SAMPLE_BIDIR_LOOP
operator||
name|AWE_SAMPLE_REVERSE_LOOP
operator|)
condition|)
block|{
name|int
name|looplen
init|=
name|sp
operator|->
name|loopend
operator|-
name|sp
operator|->
name|loopstart
decl_stmt|;
name|readbuf_loop
operator|=
name|my_malloc
argument_list|(
name|looplen
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|readbuf_loop
operator|==
name|NULL
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32: can't malloc temp buffer\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
block|}
endif|#
directive|endif
name|readbuf_addr
operator|=
name|addr
expr_stmt|;
name|readbuf_offs
operator|=
name|offset
expr_stmt|;
name|readbuf_flags
operator|=
name|sp
operator|->
name|mode_flags
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* read directly from user buffer */
end_comment

begin_function
specifier|static
name|unsigned
name|short
name|readbuf_word
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
name|unsigned
name|short
name|c
decl_stmt|;
comment|/* read from user buffer */
if|if
condition|(
name|readbuf_flags
operator|&
name|AWE_SAMPLE_8BITS
condition|)
block|{
name|unsigned
name|char
name|cc
decl_stmt|;
name|GET_BYTE_FROM_USER
argument_list|(
name|cc
argument_list|,
name|readbuf_addr
argument_list|,
name|readbuf_offs
operator|+
name|pos
argument_list|)
expr_stmt|;
name|c
operator|=
name|cc
operator|<<
literal|8
expr_stmt|;
comment|/* convert 8bit -> 16bit */
block|}
else|else
block|{
name|GET_SHORT_FROM_USER
argument_list|(
name|c
argument_list|,
name|readbuf_addr
argument_list|,
name|readbuf_offs
operator|+
name|pos
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|readbuf_flags
operator|&
name|AWE_SAMPLE_UNSIGNED
condition|)
name|c
operator|^=
literal|0x8000
expr_stmt|;
comment|/* unsigned -> signed */
ifdef|#
directive|ifdef
name|__FreeBSD__
comment|/* write on cache for reverse loop */
if|if
condition|(
name|readbuf_flags
operator|&
operator|(
name|AWE_SAMPLE_BIDIR_LOOP
operator||
name|AWE_SAMPLE_REVERSE_LOOP
operator|)
condition|)
block|{
if|if
condition|(
name|pos
operator|>=
name|readbuf_loopstart
operator|&&
name|pos
operator|<
name|readbuf_loopend
condition|)
name|readbuf_loop
index|[
name|pos
operator|-
name|readbuf_loopstart
index|]
operator|=
name|c
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|c
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_comment
comment|/* read from cache */
end_comment

begin_function
specifier|static
name|unsigned
name|short
name|readbuf_word_cache
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
if|if
condition|(
name|pos
operator|>=
name|readbuf_loopstart
operator|&&
name|pos
operator|<
name|readbuf_loopend
condition|)
return|return
name|readbuf_loop
index|[
name|pos
operator|-
name|readbuf_loopstart
index|]
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|readbuf_end
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|readbuf_loop
condition|)
block|{
name|my_free
argument_list|(
name|readbuf_loop
argument_list|)
expr_stmt|;
block|}
name|readbuf_loop
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|readbuf_word_cache
value|readbuf_word
end_define

begin_define
define|#
directive|define
name|readbuf_end
parameter_list|()
end_define

begin_comment
comment|/**/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*----------------------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|BLANK_LOOP_START
value|8
end_define

begin_define
define|#
directive|define
name|BLANK_LOOP_END
value|40
end_define

begin_define
define|#
directive|define
name|BLANK_LOOP_SIZE
value|48
end_define

begin_comment
comment|/* loading onto memory */
end_comment

begin_function
specifier|static
name|int
name|awe_write_wave_data
parameter_list|(
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|offset
parameter_list|,
name|awe_sample_info
modifier|*
name|sp
parameter_list|,
name|int
name|channels
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|truesize
decl_stmt|,
name|dram_offset
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* be sure loop points start< end */
if|if
condition|(
name|sp
operator|->
name|loopstart
operator|>
name|sp
operator|->
name|loopend
condition|)
block|{
name|int
name|tmp
init|=
name|sp
operator|->
name|loopstart
decl_stmt|;
name|sp
operator|->
name|loopstart
operator|=
name|sp
operator|->
name|loopend
expr_stmt|;
name|sp
operator|->
name|loopend
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* compute true data size to be loaded */
name|truesize
operator|=
name|sp
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|mode_flags
operator|&
name|AWE_SAMPLE_BIDIR_LOOP
condition|)
name|truesize
operator|+=
name|sp
operator|->
name|loopend
operator|-
name|sp
operator|->
name|loopstart
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|mode_flags
operator|&
name|AWE_SAMPLE_NO_BLANK
condition|)
name|truesize
operator|+=
name|BLANK_LOOP_SIZE
expr_stmt|;
if|if
condition|(
name|awe_free_mem_ptr
argument_list|()
operator|+
name|truesize
operator|>=
name|awe_mem_size
operator|/
literal|2
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32 Error: Sample memory full\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
comment|/* recalculate address offset */
name|sp
operator|->
name|end
operator|-=
name|sp
operator|->
name|start
expr_stmt|;
name|sp
operator|->
name|loopstart
operator|-=
name|sp
operator|->
name|start
expr_stmt|;
name|sp
operator|->
name|loopend
operator|-=
name|sp
operator|->
name|start
expr_stmt|;
name|dram_offset
operator|=
name|awe_free_mem_ptr
argument_list|()
operator|+
name|awe_mem_start
expr_stmt|;
name|sp
operator|->
name|start
operator|=
name|dram_offset
expr_stmt|;
name|sp
operator|->
name|end
operator|+=
name|dram_offset
expr_stmt|;
name|sp
operator|->
name|loopstart
operator|+=
name|dram_offset
expr_stmt|;
name|sp
operator|->
name|loopend
operator|+=
name|dram_offset
expr_stmt|;
comment|/* set the total size (store onto obsolete checksum value) */
if|if
condition|(
name|sp
operator|->
name|size
operator|==
literal|0
condition|)
name|sp
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
else|else
name|sp
operator|->
name|checksum
operator|=
name|truesize
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|awe_open_dram_for_write
argument_list|(
name|dram_offset
argument_list|,
name|channels
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rc
return|;
if|if
condition|(
name|readbuf_init
argument_list|(
name|addr
argument_list|,
name|offset
argument_list|,
name|sp
argument_list|)
operator|<
literal|0
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sp
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|short
name|c
decl_stmt|;
name|c
operator|=
name|readbuf_word
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|awe_write_dram
argument_list|(
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|sp
operator|->
name|loopend
operator|&&
operator|(
name|sp
operator|->
name|mode_flags
operator|&
operator|(
name|AWE_SAMPLE_BIDIR_LOOP
operator||
name|AWE_SAMPLE_REVERSE_LOOP
operator|)
operator|)
condition|)
block|{
name|int
name|looplen
init|=
name|sp
operator|->
name|loopend
operator|-
name|sp
operator|->
name|loopstart
decl_stmt|;
comment|/* copy reverse loop */
name|int
name|k
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
name|looplen
condition|;
name|k
operator|++
control|)
block|{
name|c
operator|=
name|readbuf_word_cache
argument_list|(
name|i
operator|-
name|k
argument_list|)
expr_stmt|;
name|awe_write_dram
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|mode_flags
operator|&
name|AWE_SAMPLE_BIDIR_LOOP
condition|)
block|{
name|sp
operator|->
name|end
operator|+=
name|looplen
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|start
operator|+=
name|looplen
expr_stmt|;
name|sp
operator|->
name|end
operator|+=
name|looplen
expr_stmt|;
block|}
block|}
block|}
name|readbuf_end
argument_list|()
expr_stmt|;
comment|/* if no blank loop is attached in the sample, add it */
if|if
condition|(
name|sp
operator|->
name|mode_flags
operator|&
name|AWE_SAMPLE_NO_BLANK
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLANK_LOOP_SIZE
condition|;
name|i
operator|++
control|)
name|awe_write_dram
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|mode_flags
operator|&
name|AWE_SAMPLE_SINGLESHOT
condition|)
block|{
name|sp
operator|->
name|loopstart
operator|=
name|sp
operator|->
name|end
operator|+
name|BLANK_LOOP_START
expr_stmt|;
name|sp
operator|->
name|loopend
operator|=
name|sp
operator|->
name|end
operator|+
name|BLANK_LOOP_END
expr_stmt|;
block|}
block|}
name|sflists
index|[
name|current_sf_id
operator|-
literal|1
index|]
operator|.
name|mem_ptr
operator|+=
name|truesize
expr_stmt|;
name|awe_close_dram
argument_list|()
expr_stmt|;
comment|/* initialize FM */
name|awe_init_fm
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|AWE_HAS_GUS_COMPATIBILITY
end_ifdef

begin_comment
comment|/* calculate GUS envelope time:  * is this correct?  i have no idea..  */
end_comment

begin_function
specifier|static
name|int
name|calc_gus_envelope_time
parameter_list|(
name|int
name|rate
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|p
decl_stmt|,
name|t
decl_stmt|;
name|r
operator|=
operator|(
literal|3
operator|-
operator|(
operator|(
name|rate
operator|>>
literal|6
operator|)
operator|&
literal|3
operator|)
operator|)
operator|*
literal|3
expr_stmt|;
name|p
operator|=
name|rate
operator|&
literal|0x3f
expr_stmt|;
name|t
operator|=
name|end
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|0
condition|)
name|t
operator|=
operator|-
name|t
expr_stmt|;
if|if
condition|(
literal|13
operator|>
name|r
condition|)
name|t
operator|=
name|t
operator|<<
operator|(
literal|13
operator|-
name|r
operator|)
expr_stmt|;
else|else
name|t
operator|=
name|t
operator|>>
operator|(
name|r
operator|-
literal|13
operator|)
expr_stmt|;
return|return
operator|(
name|t
operator|*
literal|10
operator|)
operator|/
operator|(
name|p
operator|*
literal|441
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|calc_gus_sustain
parameter_list|(
name|val
parameter_list|)
value|(0x7f - vol_table[(val)/2])
end_define

begin_define
define|#
directive|define
name|calc_gus_attenuation
parameter_list|(
name|val
parameter_list|)
value|vol_table[(val)/2]
end_define

begin_comment
comment|/* load GUS patch */
end_comment

begin_function
specifier|static
name|int
name|awe_load_guspatch
parameter_list|(
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|offs
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|pmgr_flag
parameter_list|)
block|{
name|struct
name|patch_info
name|patch
decl_stmt|;
name|awe_voice_info
modifier|*
name|rec
decl_stmt|;
name|awe_sample_info
modifier|*
name|smp
decl_stmt|;
name|int
name|sizeof_patch
decl_stmt|;
name|int
name|note
decl_stmt|,
name|free_sample
decl_stmt|,
name|free_info
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|sizeof_patch
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|long
operator|)
operator|&
name|patch
operator|.
name|data
index|[
literal|0
index|]
operator|-
operator|(
name|long
operator|)
operator|&
name|patch
argument_list|)
expr_stmt|;
comment|/* header size */
if|if
condition|(
name|size
operator|<
name|sizeof_patch
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32 Error: Patch header too short\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|COPY_FROM_USER
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|patch
operator|)
operator|+
name|offs
argument_list|,
name|addr
argument_list|,
name|offs
argument_list|,
name|sizeof_patch
operator|-
name|offs
argument_list|)
expr_stmt|;
name|size
operator|-=
name|sizeof_patch
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|patch
operator|.
name|len
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32 Warning: Patch record too short (%d<%d)\n"
argument_list|,
name|size
argument_list|,
name|patch
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|check_patch_opened
argument_list|(
name|AWE_PAT_TYPE_GUS
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
if|if
condition|(
name|alloc_new_sample
argument_list|()
operator|<
literal|0
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
if|if
condition|(
name|alloc_new_info
argument_list|(
literal|1
argument_list|)
condition|)
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
name|free_sample
operator|=
name|awe_free_sample
argument_list|()
expr_stmt|;
name|smp
operator|=
operator|&
name|samples
index|[
name|free_sample
index|]
operator|.
name|v
expr_stmt|;
name|smp
operator|->
name|sample
operator|=
name|free_sample
expr_stmt|;
name|smp
operator|->
name|start
operator|=
literal|0
expr_stmt|;
name|smp
operator|->
name|end
operator|=
name|patch
operator|.
name|len
expr_stmt|;
name|smp
operator|->
name|loopstart
operator|=
name|patch
operator|.
name|loop_start
expr_stmt|;
name|smp
operator|->
name|loopend
operator|=
name|patch
operator|.
name|loop_end
expr_stmt|;
name|smp
operator|->
name|size
operator|=
name|patch
operator|.
name|len
expr_stmt|;
comment|/* set up mode flags */
name|smp
operator|->
name|mode_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_16_BITS
operator|)
condition|)
name|smp
operator|->
name|mode_flags
operator||=
name|AWE_SAMPLE_8BITS
expr_stmt|;
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_UNSIGNED
condition|)
name|smp
operator|->
name|mode_flags
operator||=
name|AWE_SAMPLE_UNSIGNED
expr_stmt|;
name|smp
operator|->
name|mode_flags
operator||=
name|AWE_SAMPLE_NO_BLANK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|patch
operator|.
name|mode
operator|&
operator|(
name|WAVE_LOOPING
operator||
name|WAVE_BIDIR_LOOP
operator||
name|WAVE_LOOP_BACK
operator|)
operator|)
condition|)
name|smp
operator|->
name|mode_flags
operator||=
name|AWE_SAMPLE_SINGLESHOT
expr_stmt|;
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_BIDIR_LOOP
condition|)
name|smp
operator|->
name|mode_flags
operator||=
name|AWE_SAMPLE_BIDIR_LOOP
expr_stmt|;
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_LOOP_BACK
condition|)
name|smp
operator|->
name|mode_flags
operator||=
name|AWE_SAMPLE_REVERSE_LOOP
expr_stmt|;
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [sample %d mode %x]\n"
argument_list|,
name|patch
operator|.
name|instr_no
argument_list|,
name|smp
operator|->
name|mode_flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_16_BITS
condition|)
block|{
comment|/* convert to word offsets */
name|smp
operator|->
name|size
operator|/=
literal|2
expr_stmt|;
name|smp
operator|->
name|end
operator|/=
literal|2
expr_stmt|;
name|smp
operator|->
name|loopstart
operator|/=
literal|2
expr_stmt|;
name|smp
operator|->
name|loopend
operator|/=
literal|2
expr_stmt|;
block|}
name|smp
operator|->
name|checksum_flag
operator|=
literal|0
expr_stmt|;
name|smp
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|rc
operator|=
name|awe_write_wave_data
argument_list|(
name|addr
argument_list|,
name|sizeof_patch
argument_list|,
name|smp
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|rc
return|;
name|smp
operator|->
name|sf_id
operator|=
name|current_sf_id
expr_stmt|;
name|add_sf_sample
argument_list|(
name|free_sample
argument_list|)
expr_stmt|;
comment|/* set up voice info */
name|free_info
operator|=
name|awe_free_info
argument_list|()
expr_stmt|;
name|rec
operator|=
operator|&
name|infos
index|[
name|free_info
index|]
operator|.
name|v
expr_stmt|;
name|awe_init_voice_info
argument_list|(
name|rec
argument_list|)
expr_stmt|;
name|rec
operator|->
name|sample
operator|=
name|free_sample
expr_stmt|;
comment|/* the last sample */
name|rec
operator|->
name|rate_offset
operator|=
name|calc_rate_offset
argument_list|(
name|patch
operator|.
name|base_freq
argument_list|)
expr_stmt|;
name|note
operator|=
name|freq_to_note
argument_list|(
name|patch
operator|.
name|base_note
argument_list|)
expr_stmt|;
name|rec
operator|->
name|root
operator|=
name|note
operator|/
literal|100
expr_stmt|;
name|rec
operator|->
name|tune
operator|=
operator|-
operator|(
name|note
operator|%
literal|100
operator|)
expr_stmt|;
name|rec
operator|->
name|low
operator|=
name|freq_to_note
argument_list|(
name|patch
operator|.
name|low_note
argument_list|)
operator|/
literal|100
expr_stmt|;
name|rec
operator|->
name|high
operator|=
name|freq_to_note
argument_list|(
name|patch
operator|.
name|high_note
argument_list|)
operator|/
literal|100
expr_stmt|;
name|DEBUG
argument_list|(
literal|1
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [gus base offset=%d, note=%d, range=%d-%d(%d-%d)]\n"
argument_list|,
name|rec
operator|->
name|rate_offset
argument_list|,
name|note
argument_list|,
name|rec
operator|->
name|low
argument_list|,
name|rec
operator|->
name|high
argument_list|,
name|patch
operator|.
name|low_note
argument_list|,
name|patch
operator|.
name|high_note
argument_list|)
argument_list|)
expr_stmt|;
comment|/* panning position; -128 - 127 => 0-127 */
name|rec
operator|->
name|pan
operator|=
operator|(
name|patch
operator|.
name|panning
operator|+
literal|128
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* detuning is ignored */
comment|/* 6points volume envelope */
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_ENVELOPES
condition|)
block|{
name|int
name|attack
decl_stmt|,
name|hold
decl_stmt|,
name|decay
decl_stmt|,
name|release
decl_stmt|;
name|attack
operator|=
name|calc_gus_envelope_time
argument_list|(
name|patch
operator|.
name|env_rate
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|patch
operator|.
name|env_offset
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|hold
operator|=
name|calc_gus_envelope_time
argument_list|(
name|patch
operator|.
name|env_rate
index|[
literal|1
index|]
argument_list|,
name|patch
operator|.
name|env_offset
index|[
literal|0
index|]
argument_list|,
name|patch
operator|.
name|env_offset
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|decay
operator|=
name|calc_gus_envelope_time
argument_list|(
name|patch
operator|.
name|env_rate
index|[
literal|2
index|]
argument_list|,
name|patch
operator|.
name|env_offset
index|[
literal|1
index|]
argument_list|,
name|patch
operator|.
name|env_offset
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|release
operator|=
name|calc_gus_envelope_time
argument_list|(
name|patch
operator|.
name|env_rate
index|[
literal|3
index|]
argument_list|,
name|patch
operator|.
name|env_offset
index|[
literal|1
index|]
argument_list|,
name|patch
operator|.
name|env_offset
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|release
operator|+=
name|calc_gus_envelope_time
argument_list|(
name|patch
operator|.
name|env_rate
index|[
literal|4
index|]
argument_list|,
name|patch
operator|.
name|env_offset
index|[
literal|3
index|]
argument_list|,
name|patch
operator|.
name|env_offset
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|release
operator|+=
name|calc_gus_envelope_time
argument_list|(
name|patch
operator|.
name|env_rate
index|[
literal|5
index|]
argument_list|,
name|patch
operator|.
name|env_offset
index|[
literal|4
index|]
argument_list|,
name|patch
operator|.
name|env_offset
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|rec
operator|->
name|parm
operator|.
name|volatkhld
operator|=
operator|(
name|calc_parm_attack
argument_list|(
name|attack
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|calc_parm_hold
argument_list|(
name|hold
argument_list|)
expr_stmt|;
name|rec
operator|->
name|parm
operator|.
name|voldcysus
operator|=
operator|(
name|calc_gus_sustain
argument_list|(
name|patch
operator|.
name|env_offset
index|[
literal|2
index|]
argument_list|)
operator|<<
literal|8
operator|)
operator||
name|calc_parm_decay
argument_list|(
name|decay
argument_list|)
expr_stmt|;
name|rec
operator|->
name|parm
operator|.
name|volrelease
operator|=
literal|0x8000
operator||
name|calc_parm_decay
argument_list|(
name|release
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [gusenv atk=%d, hld=%d, dcy=%d, rel=%d]\n"
argument_list|,
name|attack
argument_list|,
name|hold
argument_list|,
name|decay
argument_list|,
name|release
argument_list|)
argument_list|)
expr_stmt|;
name|rec
operator|->
name|attenuation
operator|=
name|calc_gus_attenuation
argument_list|(
name|patch
operator|.
name|env_offset
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* tremolo effect */
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_TREMOLO
condition|)
block|{
name|int
name|rate
init|=
operator|(
name|patch
operator|.
name|tremolo_rate
operator|*
literal|1000
operator|/
literal|38
operator|)
operator|/
literal|42
decl_stmt|;
name|rec
operator|->
name|parm
operator|.
name|tremfrq
operator|=
operator|(
operator|(
name|patch
operator|.
name|tremolo_depth
operator|/
literal|2
operator|)
operator|<<
literal|8
operator|)
operator||
name|rate
expr_stmt|;
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [gusenv tremolo rate=%d, dep=%d, tremfrq=%x]\n"
argument_list|,
name|patch
operator|.
name|tremolo_rate
argument_list|,
name|patch
operator|.
name|tremolo_depth
argument_list|,
name|rec
operator|->
name|parm
operator|.
name|tremfrq
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* vibrato effect */
if|if
condition|(
name|patch
operator|.
name|mode
operator|&
name|WAVE_VIBRATO
condition|)
block|{
name|int
name|rate
init|=
operator|(
name|patch
operator|.
name|vibrato_rate
operator|*
literal|1000
operator|/
literal|38
operator|)
operator|/
literal|42
decl_stmt|;
name|rec
operator|->
name|parm
operator|.
name|fm2frq2
operator|=
operator|(
operator|(
name|patch
operator|.
name|vibrato_depth
operator|/
literal|6
operator|)
operator|<<
literal|8
operator|)
operator||
name|rate
expr_stmt|;
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [gusenv vibrato rate=%d, dep=%d, tremfrq=%x]\n"
argument_list|,
name|patch
operator|.
name|tremolo_rate
argument_list|,
name|patch
operator|.
name|tremolo_depth
argument_list|,
name|rec
operator|->
name|parm
operator|.
name|tremfrq
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* scale_freq, scale_factor, volume, and fractions not implemented */
comment|/* append to the tail of the list */
name|infos
index|[
name|free_info
index|]
operator|.
name|bank
operator|=
name|misc_modes
index|[
name|AWE_MD_GUS_BANK
index|]
expr_stmt|;
name|infos
index|[
name|free_info
index|]
operator|.
name|instr
operator|=
name|patch
operator|.
name|instr_no
expr_stmt|;
name|infos
index|[
name|free_info
index|]
operator|.
name|disabled
operator|=
name|FALSE
expr_stmt|;
name|infos
index|[
name|free_info
index|]
operator|.
name|type
operator|=
name|V_ST_NORMAL
expr_stmt|;
name|infos
index|[
name|free_info
index|]
operator|.
name|v
operator|.
name|sf_id
operator|=
name|current_sf_id
expr_stmt|;
name|add_info_list
argument_list|(
name|free_info
argument_list|)
expr_stmt|;
name|add_sf_info
argument_list|(
name|free_info
argument_list|)
expr_stmt|;
comment|/* set the voice index */
name|awe_set_sample
argument_list|(
name|rec
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* AWE_HAS_GUS_COMPATIBILITY */
end_comment

begin_comment
comment|/*----------------------------------------------------------------  * sample and voice list handlers  *----------------------------------------------------------------*/
end_comment

begin_comment
comment|/* append this to the sf list */
end_comment

begin_function
specifier|static
name|void
name|add_sf_info
parameter_list|(
name|int
name|rec
parameter_list|)
block|{
name|int
name|sf_id
init|=
name|infos
index|[
name|rec
index|]
operator|.
name|v
operator|.
name|sf_id
decl_stmt|;
if|if
condition|(
name|sf_id
operator|==
literal|0
condition|)
return|return;
name|sf_id
operator|--
expr_stmt|;
if|if
condition|(
name|sflists
index|[
name|sf_id
index|]
operator|.
name|infos
operator|<
literal|0
condition|)
name|sflists
index|[
name|sf_id
index|]
operator|.
name|infos
operator|=
name|rec
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|,
name|prev
decl_stmt|;
name|prev
operator|=
name|sflists
index|[
name|sf_id
index|]
operator|.
name|infos
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|infos
index|[
name|prev
index|]
operator|.
name|next
operator|)
operator|>=
literal|0
condition|)
name|prev
operator|=
name|i
expr_stmt|;
name|infos
index|[
name|prev
index|]
operator|.
name|next
operator|=
name|rec
expr_stmt|;
block|}
name|infos
index|[
name|rec
index|]
operator|.
name|next
operator|=
operator|-
literal|1
expr_stmt|;
name|sflists
index|[
name|sf_id
index|]
operator|.
name|num_info
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* prepend this sample to sf list */
end_comment

begin_function
specifier|static
name|void
name|add_sf_sample
parameter_list|(
name|int
name|rec
parameter_list|)
block|{
name|int
name|sf_id
init|=
name|samples
index|[
name|rec
index|]
operator|.
name|v
operator|.
name|sf_id
decl_stmt|;
if|if
condition|(
name|sf_id
operator|==
literal|0
condition|)
return|return;
name|sf_id
operator|--
expr_stmt|;
name|samples
index|[
name|rec
index|]
operator|.
name|next
operator|=
name|sflists
index|[
name|sf_id
index|]
operator|.
name|samples
expr_stmt|;
name|sflists
index|[
name|sf_id
index|]
operator|.
name|samples
operator|=
name|rec
expr_stmt|;
name|sflists
index|[
name|sf_id
index|]
operator|.
name|num_sample
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* purge the old records which don't belong with the same file id */
end_comment

begin_function
specifier|static
name|void
name|purge_old_list
parameter_list|(
name|int
name|rec
parameter_list|,
name|int
name|next
parameter_list|)
block|{
name|infos
index|[
name|rec
index|]
operator|.
name|next_instr
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|infos
index|[
name|rec
index|]
operator|.
name|bank
operator|==
name|AWE_DRUM_BANK
condition|)
block|{
comment|/* remove samples with the same note range */
name|int
name|cur
decl_stmt|,
modifier|*
name|prevp
init|=
operator|&
name|infos
index|[
name|rec
index|]
operator|.
name|next_instr
decl_stmt|;
name|int
name|low
init|=
name|infos
index|[
name|rec
index|]
operator|.
name|v
operator|.
name|low
decl_stmt|;
name|int
name|high
init|=
name|infos
index|[
name|rec
index|]
operator|.
name|v
operator|.
name|high
decl_stmt|;
for|for
control|(
name|cur
operator|=
name|next
init|;
name|cur
operator|>=
literal|0
condition|;
name|cur
operator|=
name|infos
index|[
name|cur
index|]
operator|.
name|next_instr
control|)
block|{
if|if
condition|(
name|infos
index|[
name|cur
index|]
operator|.
name|v
operator|.
name|low
operator|==
name|low
operator|&&
name|infos
index|[
name|cur
index|]
operator|.
name|v
operator|.
name|high
operator|==
name|high
operator|&&
name|infos
index|[
name|cur
index|]
operator|.
name|v
operator|.
name|sf_id
operator|!=
name|infos
index|[
name|rec
index|]
operator|.
name|v
operator|.
name|sf_id
condition|)
operator|*
name|prevp
operator|=
name|infos
index|[
name|cur
index|]
operator|.
name|next_instr
expr_stmt|;
name|prevp
operator|=
operator|&
name|infos
index|[
name|cur
index|]
operator|.
name|next_instr
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|infos
index|[
name|next
index|]
operator|.
name|v
operator|.
name|sf_id
operator|!=
name|infos
index|[
name|rec
index|]
operator|.
name|v
operator|.
name|sf_id
condition|)
name|infos
index|[
name|rec
index|]
operator|.
name|next_instr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* prepend to top of the preset table */
end_comment

begin_function
specifier|static
name|void
name|add_info_list
parameter_list|(
name|int
name|rec
parameter_list|)
block|{
name|int
modifier|*
name|prevp
decl_stmt|,
name|cur
decl_stmt|;
name|int
name|instr
init|=
name|infos
index|[
name|rec
index|]
operator|.
name|instr
decl_stmt|;
name|int
name|bank
init|=
name|infos
index|[
name|rec
index|]
operator|.
name|bank
decl_stmt|;
if|if
condition|(
name|infos
index|[
name|rec
index|]
operator|.
name|disabled
condition|)
return|return;
name|prevp
operator|=
operator|&
name|preset_table
index|[
name|instr
index|]
expr_stmt|;
name|cur
operator|=
operator|*
name|prevp
expr_stmt|;
while|while
condition|(
name|cur
operator|>=
literal|0
condition|)
block|{
comment|/* search the first record with the same bank number */
if|if
condition|(
name|infos
index|[
name|cur
index|]
operator|.
name|bank
operator|==
name|bank
condition|)
block|{
comment|/* replace the list with the new record */
name|infos
index|[
name|rec
index|]
operator|.
name|next_bank
operator|=
name|infos
index|[
name|cur
index|]
operator|.
name|next_bank
expr_stmt|;
operator|*
name|prevp
operator|=
name|rec
expr_stmt|;
name|purge_old_list
argument_list|(
name|rec
argument_list|,
name|cur
argument_list|)
expr_stmt|;
return|return;
block|}
name|prevp
operator|=
operator|&
name|infos
index|[
name|cur
index|]
operator|.
name|next_bank
expr_stmt|;
name|cur
operator|=
name|infos
index|[
name|cur
index|]
operator|.
name|next_bank
expr_stmt|;
block|}
comment|/* this is the first bank record.. just add this */
name|infos
index|[
name|rec
index|]
operator|.
name|next_instr
operator|=
operator|-
literal|1
expr_stmt|;
name|infos
index|[
name|rec
index|]
operator|.
name|next_bank
operator|=
name|preset_table
index|[
name|instr
index|]
expr_stmt|;
name|preset_table
index|[
name|instr
index|]
operator|=
name|rec
expr_stmt|;
block|}
end_function

begin_comment
comment|/* remove samples later than the specified sf_id */
end_comment

begin_function
specifier|static
name|void
name|awe_remove_samples
parameter_list|(
name|int
name|sf_id
parameter_list|)
block|{
if|if
condition|(
name|sf_id
operator|<=
literal|0
condition|)
block|{
name|awe_reset_samples
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* already removed? */
if|if
condition|(
name|current_sf_id
operator|<=
name|sf_id
condition|)
return|return;
name|current_sf_id
operator|=
name|sf_id
expr_stmt|;
if|if
condition|(
name|locked_sf_id
operator|>
name|sf_id
condition|)
name|locked_sf_id
operator|=
name|sf_id
expr_stmt|;
name|rebuild_preset_list
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* rebuild preset search list */
end_comment

begin_function
specifier|static
name|void
name|rebuild_preset_list
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_MAX_PRESETS
condition|;
name|i
operator|++
control|)
name|preset_table
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|current_sf_id
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|sflists
index|[
name|i
index|]
operator|.
name|infos
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|=
name|infos
index|[
name|j
index|]
operator|.
name|next
control|)
name|add_info_list
argument_list|(
name|j
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* search the specified sample */
end_comment

begin_function
specifier|static
name|short
name|awe_set_sample
parameter_list|(
name|awe_voice_info
modifier|*
name|vp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vp
operator|->
name|index
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sflists
index|[
name|vp
operator|->
name|sf_id
operator|-
literal|1
index|]
operator|.
name|samples
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|=
name|samples
index|[
name|i
index|]
operator|.
name|next
control|)
block|{
if|if
condition|(
name|samples
index|[
name|i
index|]
operator|.
name|v
operator|.
name|sample
operator|==
name|vp
operator|->
name|sample
condition|)
block|{
comment|/* set the actual sample offsets */
name|vp
operator|->
name|start
operator|+=
name|samples
index|[
name|i
index|]
operator|.
name|v
operator|.
name|start
expr_stmt|;
name|vp
operator|->
name|end
operator|+=
name|samples
index|[
name|i
index|]
operator|.
name|v
operator|.
name|end
expr_stmt|;
name|vp
operator|->
name|loopstart
operator|+=
name|samples
index|[
name|i
index|]
operator|.
name|v
operator|.
name|loopstart
expr_stmt|;
name|vp
operator|->
name|loopend
operator|+=
name|samples
index|[
name|i
index|]
operator|.
name|v
operator|.
name|loopend
expr_stmt|;
comment|/* copy mode flags */
name|vp
operator|->
name|mode
operator|=
name|samples
index|[
name|i
index|]
operator|.
name|v
operator|.
name|mode_flags
expr_stmt|;
comment|/* set index */
name|vp
operator|->
name|index
operator|=
name|i
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------  * voice allocation  *----------------------------------------------------------------*/
end_comment

begin_comment
comment|/* look for all voices associated with the specified note& velocity */
end_comment

begin_function
specifier|static
name|int
name|awe_search_multi_voices
parameter_list|(
name|int
name|rec
parameter_list|,
name|int
name|note
parameter_list|,
name|int
name|velocity
parameter_list|,
name|awe_voice_info
modifier|*
modifier|*
name|vlist
parameter_list|)
block|{
name|int
name|nvoices
decl_stmt|;
name|nvoices
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|rec
operator|>=
literal|0
condition|;
name|rec
operator|=
name|infos
index|[
name|rec
index|]
operator|.
name|next_instr
control|)
block|{
if|if
condition|(
name|note
operator|>=
name|infos
index|[
name|rec
index|]
operator|.
name|v
operator|.
name|low
operator|&&
name|note
operator|<=
name|infos
index|[
name|rec
index|]
operator|.
name|v
operator|.
name|high
operator|&&
name|velocity
operator|>=
name|infos
index|[
name|rec
index|]
operator|.
name|v
operator|.
name|vellow
operator|&&
name|velocity
operator|<=
name|infos
index|[
name|rec
index|]
operator|.
name|v
operator|.
name|velhigh
condition|)
block|{
name|vlist
index|[
name|nvoices
index|]
operator|=
operator|&
name|infos
index|[
name|rec
index|]
operator|.
name|v
expr_stmt|;
if|if
condition|(
name|infos
index|[
name|rec
index|]
operator|.
name|type
operator|==
name|V_ST_MAPPED
condition|)
comment|/* mapper */
return|return
operator|-
literal|1
return|;
name|nvoices
operator|++
expr_stmt|;
if|if
condition|(
name|nvoices
operator|>=
name|AWE_MAX_VOICES
condition|)
break|break;
block|}
block|}
return|return
name|nvoices
return|;
block|}
end_function

begin_comment
comment|/* store the voice list from the specified note and velocity.    if the preset is mapped, seek for the destination preset, and rewrite    the note number if necessary.    */
end_comment

begin_function
specifier|static
name|int
name|really_alloc_voices
parameter_list|(
name|int
name|vrec
parameter_list|,
name|int
name|def_vrec
parameter_list|,
name|int
modifier|*
name|note
parameter_list|,
name|int
name|velocity
parameter_list|,
name|awe_voice_info
modifier|*
modifier|*
name|vlist
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|int
name|nvoices
decl_stmt|;
name|nvoices
operator|=
name|awe_search_multi_voices
argument_list|(
name|vrec
argument_list|,
operator|*
name|note
argument_list|,
name|velocity
argument_list|,
name|vlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvoices
operator|==
literal|0
condition|)
name|nvoices
operator|=
name|awe_search_multi_voices
argument_list|(
name|def_vrec
argument_list|,
operator|*
name|note
argument_list|,
name|velocity
argument_list|,
name|vlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvoices
operator|<
literal|0
condition|)
block|{
comment|/* mapping */
name|int
name|preset
init|=
name|vlist
index|[
literal|0
index|]
operator|->
name|start
decl_stmt|;
name|int
name|bank
init|=
name|vlist
index|[
literal|0
index|]
operator|->
name|end
decl_stmt|;
name|int
name|key
init|=
name|vlist
index|[
literal|0
index|]
operator|->
name|fixkey
decl_stmt|;
if|if
condition|(
name|level
operator|>
literal|5
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32: too deep mapping level\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|vrec
operator|=
name|awe_search_instr
argument_list|(
name|bank
argument_list|,
name|preset
argument_list|)
expr_stmt|;
if|if
condition|(
name|bank
operator|==
name|AWE_DRUM_BANK
condition|)
name|def_vrec
operator|=
name|awe_search_instr
argument_list|(
name|bank
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|def_vrec
operator|=
name|awe_search_instr
argument_list|(
literal|0
argument_list|,
name|preset
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|>=
literal|0
condition|)
operator|*
name|note
operator|=
name|key
expr_stmt|;
return|return
name|really_alloc_voices
argument_list|(
name|vrec
argument_list|,
name|def_vrec
argument_list|,
name|note
argument_list|,
name|velocity
argument_list|,
name|vlist
argument_list|,
name|level
operator|+
literal|1
argument_list|)
return|;
block|}
return|return
name|nvoices
return|;
block|}
end_function

begin_comment
comment|/* allocate voices corresponding note and velocity; supports multiple insts. */
end_comment

begin_function
specifier|static
name|void
name|awe_alloc_multi_voices
parameter_list|(
name|int
name|ch
parameter_list|,
name|int
name|note
parameter_list|,
name|int
name|velocity
parameter_list|,
name|int
name|key
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|v
decl_stmt|,
name|nvoices
decl_stmt|;
name|awe_voice_info
modifier|*
name|vlist
index|[
name|AWE_MAX_VOICES
index|]
decl_stmt|;
if|if
condition|(
name|channels
index|[
name|ch
index|]
operator|.
name|vrec
operator|<
literal|0
operator|&&
name|channels
index|[
name|ch
index|]
operator|.
name|def_vrec
operator|<
literal|0
condition|)
name|awe_set_instr
argument_list|(
literal|0
argument_list|,
name|ch
argument_list|,
name|channels
index|[
name|ch
index|]
operator|.
name|instr
argument_list|)
expr_stmt|;
comment|/* check the possible voices; note may be changeable if mapped */
name|nvoices
operator|=
name|really_alloc_voices
argument_list|(
name|channels
index|[
name|ch
index|]
operator|.
name|vrec
argument_list|,
name|channels
index|[
name|ch
index|]
operator|.
name|def_vrec
argument_list|,
operator|&
name|note
argument_list|,
name|velocity
argument_list|,
name|vlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* set the voices */
name|current_alloc_time
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvoices
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
name|awe_clear_voice
argument_list|()
expr_stmt|;
name|voices
index|[
name|v
index|]
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|voices
index|[
name|v
index|]
operator|.
name|ch
operator|=
name|ch
expr_stmt|;
name|voices
index|[
name|v
index|]
operator|.
name|note
operator|=
name|note
expr_stmt|;
name|voices
index|[
name|v
index|]
operator|.
name|velocity
operator|=
name|velocity
expr_stmt|;
name|voices
index|[
name|v
index|]
operator|.
name|time
operator|=
name|current_alloc_time
expr_stmt|;
name|voices
index|[
name|v
index|]
operator|.
name|cinfo
operator|=
operator|&
name|channels
index|[
name|ch
index|]
expr_stmt|;
name|voices
index|[
name|v
index|]
operator|.
name|sample
operator|=
name|vlist
index|[
name|i
index|]
expr_stmt|;
name|voices
index|[
name|v
index|]
operator|.
name|state
operator|=
name|AWE_ST_MARK
expr_stmt|;
name|voices
index|[
name|v
index|]
operator|.
name|layer
operator|=
name|nvoices
operator|-
name|i
operator|-
literal|1
expr_stmt|;
comment|/* in reverse order */
block|}
comment|/* clear the mark in allocated voices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|awe_max_voices
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|voices
index|[
name|i
index|]
operator|.
name|state
operator|==
name|AWE_ST_MARK
condition|)
name|voices
index|[
name|i
index|]
operator|.
name|state
operator|=
name|AWE_ST_OFF
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* search the best voice from the specified status condition */
end_comment

begin_function
specifier|static
name|int
name|search_best_voice
parameter_list|(
name|int
name|condition
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|time
decl_stmt|,
name|best
decl_stmt|;
name|best
operator|=
operator|-
literal|1
expr_stmt|;
name|time
operator|=
name|current_alloc_time
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|awe_max_voices
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|voices
index|[
name|i
index|]
operator|.
name|state
operator|&
name|condition
operator|)
operator|&&
operator|(
name|best
operator|<
literal|0
operator|||
name|voices
index|[
name|i
index|]
operator|.
name|time
operator|<
name|time
operator|)
condition|)
block|{
name|best
operator|=
name|i
expr_stmt|;
name|time
operator|=
name|voices
index|[
name|i
index|]
operator|.
name|time
expr_stmt|;
block|}
block|}
comment|/* clear voice */
if|if
condition|(
name|best
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|voices
index|[
name|best
index|]
operator|.
name|state
operator|!=
name|AWE_ST_OFF
condition|)
name|awe_terminate
argument_list|(
name|best
argument_list|)
expr_stmt|;
name|awe_voice_init
argument_list|(
name|best
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
return|return
name|best
return|;
block|}
end_function

begin_comment
comment|/* search an empty voice.    if no empty voice is found, at least terminate a voice    */
end_comment

begin_function
specifier|static
name|int
name|awe_clear_voice
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|best
decl_stmt|;
comment|/* looking for the oldest empty voice */
if|if
condition|(
operator|(
name|best
operator|=
name|search_best_voice
argument_list|(
name|AWE_ST_OFF
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
name|best
return|;
if|if
condition|(
operator|(
name|best
operator|=
name|search_best_voice
argument_list|(
name|AWE_ST_RELEASED
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
name|best
return|;
comment|/* looking for the oldest sustained voice */
if|if
condition|(
operator|(
name|best
operator|=
name|search_best_voice
argument_list|(
name|AWE_ST_SUSTAINED
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
name|best
return|;
ifdef|#
directive|ifdef
name|AWE_LOOKUP_MIDI_PRIORITY
if|if
condition|(
name|MULTI_LAYER_MODE
argument_list|()
operator|&&
name|misc_modes
index|[
name|AWE_MD_CHN_PRIOR
index|]
condition|)
block|{
name|int
name|ch
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|time
init|=
name|current_alloc_time
operator|+
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* looking for the voices from high channel (except drum ch) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|awe_max_voices
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IS_DRUM_CHANNEL
argument_list|(
name|voices
index|[
name|i
index|]
operator|.
name|ch
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|voices
index|[
name|i
index|]
operator|.
name|ch
operator|<
name|ch
condition|)
continue|continue;
if|if
condition|(
name|voices
index|[
name|i
index|]
operator|.
name|state
operator|!=
name|AWE_ST_MARK
operator|&&
operator|(
name|voices
index|[
name|i
index|]
operator|.
name|ch
operator|>
name|ch
operator|||
name|voices
index|[
name|i
index|]
operator|.
name|time
operator|<
name|time
operator|)
condition|)
block|{
name|best
operator|=
name|i
expr_stmt|;
name|time
operator|=
name|voices
index|[
name|i
index|]
operator|.
name|time
expr_stmt|;
name|ch
operator|=
name|voices
index|[
name|i
index|]
operator|.
name|ch
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|best
operator|<
literal|0
condition|)
name|best
operator|=
name|search_best_voice
argument_list|(
operator|~
name|AWE_ST_MARK
argument_list|)
expr_stmt|;
if|if
condition|(
name|best
operator|>=
literal|0
condition|)
return|return
name|best
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* search sample for the specified note& velocity and set it on the voice;  * note that voice is the voice index (not channel index)  */
end_comment

begin_function
specifier|static
name|void
name|awe_alloc_one_voice
parameter_list|(
name|int
name|voice
parameter_list|,
name|int
name|note
parameter_list|,
name|int
name|velocity
parameter_list|)
block|{
name|int
name|ch
decl_stmt|,
name|nvoices
decl_stmt|;
name|awe_voice_info
modifier|*
name|vlist
index|[
name|AWE_MAX_VOICES
index|]
decl_stmt|;
name|ch
operator|=
name|voices
index|[
name|voice
index|]
operator|.
name|ch
expr_stmt|;
if|if
condition|(
name|channels
index|[
name|ch
index|]
operator|.
name|vrec
operator|<
literal|0
operator|&&
name|channels
index|[
name|ch
index|]
operator|.
name|def_vrec
operator|<
literal|0
condition|)
name|awe_set_instr
argument_list|(
literal|0
argument_list|,
name|ch
argument_list|,
name|channels
index|[
name|ch
index|]
operator|.
name|instr
argument_list|)
expr_stmt|;
name|nvoices
operator|=
name|really_alloc_voices
argument_list|(
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
operator|->
name|vrec
argument_list|,
name|voices
index|[
name|voice
index|]
operator|.
name|cinfo
operator|->
name|def_vrec
argument_list|,
operator|&
name|note
argument_list|,
name|velocity
argument_list|,
name|vlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvoices
operator|>
literal|0
condition|)
block|{
name|voices
index|[
name|voice
index|]
operator|.
name|time
operator|=
operator|++
name|current_alloc_time
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|sample
operator|=
name|vlist
index|[
literal|0
index|]
expr_stmt|;
comment|/* use the first one */
name|voices
index|[
name|voice
index|]
operator|.
name|layer
operator|=
literal|0
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|note
operator|=
name|note
expr_stmt|;
name|voices
index|[
name|voice
index|]
operator|.
name|velocity
operator|=
name|velocity
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------  * sequencer2 functions  *----------------------------------------------------------------*/
end_comment

begin_comment
comment|/* search an empty voice; used by sequencer2 */
end_comment

begin_function
specifier|static
name|int
name|awe_alloc
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|chn
parameter_list|,
name|int
name|note
parameter_list|,
name|struct
name|voice_alloc_info
modifier|*
name|alloc
parameter_list|)
block|{
name|playing_mode
operator|=
name|AWE_PLAY_MULTI2
expr_stmt|;
name|awe_info
operator|.
name|nr_voices
operator|=
name|AWE_MAX_CHANNELS
expr_stmt|;
return|return
name|awe_clear_voice
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* set up voice; used by sequencer2 */
end_comment

begin_function
specifier|static
name|void
name|awe_setup_voice
parameter_list|(
name|int
name|dev
parameter_list|,
name|int
name|voice
parameter_list|,
name|int
name|chn
parameter_list|)
block|{
name|struct
name|channel_info
modifier|*
name|info
decl_stmt|;
if|if
condition|(
name|synth_devs
index|[
name|dev
index|]
operator|==
name|NULL
operator|||
operator|(
name|info
operator|=
operator|&
name|synth_devs
index|[
name|dev
index|]
operator|->
name|chn_info
index|[
name|chn
index|]
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|voice
operator|<
literal|0
operator|||
name|voice
operator|>=
name|awe_max_voices
condition|)
return|return;
name|DEBUG
argument_list|(
literal|2
argument_list|,
name|printk
argument_list|(
literal|"AWE32: [setup(%d) ch=%d]\n"
argument_list|,
name|voice
argument_list|,
name|chn
argument_list|)
argument_list|)
expr_stmt|;
name|channels
index|[
name|chn
index|]
operator|.
name|expression_vol
operator|=
name|info
operator|->
name|controllers
index|[
name|CTL_EXPRESSION
index|]
expr_stmt|;
name|channels
index|[
name|chn
index|]
operator|.
name|main_vol
operator|=
name|info
operator|->
name|controllers
index|[
name|CTL_MAIN_VOLUME
index|]
expr_stmt|;
name|channels
index|[
name|chn
index|]
operator|.
name|panning
operator|=
name|info
operator|->
name|controllers
index|[
name|CTL_PAN
index|]
operator|*
literal|2
operator|-
literal|128
expr_stmt|;
comment|/* signed 8bit */
name|channels
index|[
name|chn
index|]
operator|.
name|bender
operator|=
name|info
operator|->
name|bender_value
expr_stmt|;
comment|/* zero center */
name|channels
index|[
name|chn
index|]
operator|.
name|bank
operator|=
name|info
operator|->
name|controllers
index|[
name|CTL_BANK_SELECT
index|]
expr_stmt|;
name|channels
index|[
name|chn
index|]
operator|.
name|sustained
operator|=
name|info
operator|->
name|controllers
index|[
name|CTL_SUSTAIN
index|]
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|controllers
index|[
name|CTL_EXT_EFF_DEPTH
index|]
condition|)
block|{
name|FX_SET
argument_list|(
operator|&
name|channels
index|[
name|chn
index|]
operator|.
name|fx
argument_list|,
name|AWE_FX_REVERB
argument_list|,
name|info
operator|->
name|controllers
index|[
name|CTL_EXT_EFF_DEPTH
index|]
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|controllers
index|[
name|CTL_CHORUS_DEPTH
index|]
condition|)
block|{
name|FX_SET
argument_list|(
operator|&
name|channels
index|[
name|chn
index|]
operator|.
name|fx
argument_list|,
name|AWE_FX_CHORUS
argument_list|,
name|info
operator|->
name|controllers
index|[
name|CTL_CHORUS_DEPTH
index|]
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
name|awe_set_instr
argument_list|(
name|dev
argument_list|,
name|chn
argument_list|,
name|info
operator|->
name|pgm_num
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_AWE32_MIXER
end_ifdef

begin_comment
comment|/*================================================================  * AWE32 mixer device control  *================================================================*/
end_comment

begin_function
specifier|static
name|int
name|awe_mixer_ioctl
parameter_list|(
name|int
name|dev
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|level
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|cmd
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator|!=
literal|'M'
condition|)
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
name|level
operator|=
operator|(
name|int
operator|)
name|IOCTL_IN
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|level
operator|=
operator|(
operator|(
name|level
operator|&
literal|0xff
operator|)
operator|+
operator|(
name|level
operator|>>
literal|8
operator|)
operator|)
operator|/
literal|2
expr_stmt|;
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWEMix: cmd=%x val=%d\n"
argument_list|,
name|cmd
operator|&
literal|0xff
argument_list|,
name|level
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IO_WRITE_CHECK
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|cmd
operator|&
literal|0xff
condition|)
block|{
case|case
name|SOUND_MIXER_BASS
case|:
name|awe_bass_level
operator|=
name|level
operator|*
literal|12
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|awe_bass_level
operator|>=
literal|12
condition|)
name|awe_bass_level
operator|=
literal|11
expr_stmt|;
name|awe_equalizer
argument_list|(
name|awe_bass_level
argument_list|,
name|awe_treble_level
argument_list|)
expr_stmt|;
break|break;
case|case
name|SOUND_MIXER_TREBLE
case|:
name|awe_treble_level
operator|=
name|level
operator|*
literal|12
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|awe_treble_level
operator|>=
literal|12
condition|)
name|awe_treble_level
operator|=
literal|11
expr_stmt|;
name|awe_equalizer
argument_list|(
name|awe_bass_level
argument_list|,
name|awe_treble_level
argument_list|)
expr_stmt|;
break|break;
case|case
name|SOUND_MIXER_VOLUME
case|:
name|level
operator|=
name|level
operator|*
literal|127
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|level
operator|>=
literal|128
condition|)
name|level
operator|=
literal|127
expr_stmt|;
name|init_atten
operator|=
name|vol_table
index|[
name|level
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|awe_max_voices
condition|;
name|i
operator|++
control|)
name|awe_set_voice_vol
argument_list|(
name|i
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
switch|switch
condition|(
name|cmd
operator|&
literal|0xff
condition|)
block|{
case|case
name|SOUND_MIXER_BASS
case|:
name|level
operator|=
name|awe_bass_level
operator|*
literal|100
operator|/
literal|24
expr_stmt|;
name|level
operator|=
operator|(
name|level
operator|<<
literal|8
operator|)
operator||
name|level
expr_stmt|;
break|break;
case|case
name|SOUND_MIXER_TREBLE
case|:
name|level
operator|=
name|awe_treble_level
operator|*
literal|100
operator|/
literal|24
expr_stmt|;
name|level
operator|=
operator|(
name|level
operator|<<
literal|8
operator|)
operator||
name|level
expr_stmt|;
break|break;
case|case
name|SOUND_MIXER_VOLUME
case|:
for|for
control|(
name|i
operator|=
literal|127
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|init_atten
operator|<=
name|vol_table
index|[
name|i
index|]
condition|)
break|break;
block|}
name|level
operator|=
name|i
operator|*
literal|100
operator|/
literal|127
expr_stmt|;
name|level
operator|=
operator|(
name|level
operator|<<
literal|8
operator|)
operator||
name|level
expr_stmt|;
break|break;
case|case
name|SOUND_MIXER_DEVMASK
case|:
name|level
operator|=
name|SOUND_MASK_BASS
operator||
name|SOUND_MASK_TREBLE
operator||
name|SOUND_MASK_VOLUME
expr_stmt|;
break|break;
default|default:
name|level
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|IOCTL_OUT
argument_list|(
name|arg
argument_list|,
name|level
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_AWE32_MIXER */
end_comment

begin_comment
comment|/*================================================================  * initialization of AWE32  *================================================================*/
end_comment

begin_comment
comment|/* intiailize audio channels */
end_comment

begin_function
specifier|static
name|void
name|awe_init_audio
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
comment|/* turn off envelope engines */
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
name|AWE_MAX_VOICES
condition|;
name|ch
operator|++
control|)
block|{
name|awe_poke
argument_list|(
name|AWE_DCYSUSV
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
block|}
comment|/* reset all other parameters to zero */
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
name|AWE_MAX_VOICES
condition|;
name|ch
operator|++
control|)
block|{
name|awe_poke
argument_list|(
name|AWE_ENVVOL
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_ENVVAL
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_DCYSUS
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_ATKHLDV
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_LFO1VAL
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_ATKHLD
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_LFO2VAL
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_IP
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_IFATN
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_PEFE
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_FMMOD
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_TREMFRQ
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_FM2FRQ2
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PTRX
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_VTFT
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PSST
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CSL
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
name|AWE_MAX_VOICES
condition|;
name|ch
operator|++
control|)
block|{
name|awe_poke_dw
argument_list|(
name|AWE_CPF
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CVCF
argument_list|(
name|ch
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* initialize DMA address */
end_comment

begin_function
specifier|static
name|void
name|awe_init_dma
parameter_list|(
name|void
parameter_list|)
block|{
name|awe_poke_dw
argument_list|(
name|AWE_SMALR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_SMARR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_SMALW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_SMARW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* initialization arrays; from ADIP */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|init1
index|[
literal|128
index|]
init|=
block|{
literal|0x03ff
block|,
literal|0x0030
block|,
literal|0x07ff
block|,
literal|0x0130
block|,
literal|0x0bff
block|,
literal|0x0230
block|,
literal|0x0fff
block|,
literal|0x0330
block|,
literal|0x13ff
block|,
literal|0x0430
block|,
literal|0x17ff
block|,
literal|0x0530
block|,
literal|0x1bff
block|,
literal|0x0630
block|,
literal|0x1fff
block|,
literal|0x0730
block|,
literal|0x23ff
block|,
literal|0x0830
block|,
literal|0x27ff
block|,
literal|0x0930
block|,
literal|0x2bff
block|,
literal|0x0a30
block|,
literal|0x2fff
block|,
literal|0x0b30
block|,
literal|0x33ff
block|,
literal|0x0c30
block|,
literal|0x37ff
block|,
literal|0x0d30
block|,
literal|0x3bff
block|,
literal|0x0e30
block|,
literal|0x3fff
block|,
literal|0x0f30
block|,
literal|0x43ff
block|,
literal|0x0030
block|,
literal|0x47ff
block|,
literal|0x0130
block|,
literal|0x4bff
block|,
literal|0x0230
block|,
literal|0x4fff
block|,
literal|0x0330
block|,
literal|0x53ff
block|,
literal|0x0430
block|,
literal|0x57ff
block|,
literal|0x0530
block|,
literal|0x5bff
block|,
literal|0x0630
block|,
literal|0x5fff
block|,
literal|0x0730
block|,
literal|0x63ff
block|,
literal|0x0830
block|,
literal|0x67ff
block|,
literal|0x0930
block|,
literal|0x6bff
block|,
literal|0x0a30
block|,
literal|0x6fff
block|,
literal|0x0b30
block|,
literal|0x73ff
block|,
literal|0x0c30
block|,
literal|0x77ff
block|,
literal|0x0d30
block|,
literal|0x7bff
block|,
literal|0x0e30
block|,
literal|0x7fff
block|,
literal|0x0f30
block|,
literal|0x83ff
block|,
literal|0x0030
block|,
literal|0x87ff
block|,
literal|0x0130
block|,
literal|0x8bff
block|,
literal|0x0230
block|,
literal|0x8fff
block|,
literal|0x0330
block|,
literal|0x93ff
block|,
literal|0x0430
block|,
literal|0x97ff
block|,
literal|0x0530
block|,
literal|0x9bff
block|,
literal|0x0630
block|,
literal|0x9fff
block|,
literal|0x0730
block|,
literal|0xa3ff
block|,
literal|0x0830
block|,
literal|0xa7ff
block|,
literal|0x0930
block|,
literal|0xabff
block|,
literal|0x0a30
block|,
literal|0xafff
block|,
literal|0x0b30
block|,
literal|0xb3ff
block|,
literal|0x0c30
block|,
literal|0xb7ff
block|,
literal|0x0d30
block|,
literal|0xbbff
block|,
literal|0x0e30
block|,
literal|0xbfff
block|,
literal|0x0f30
block|,
literal|0xc3ff
block|,
literal|0x0030
block|,
literal|0xc7ff
block|,
literal|0x0130
block|,
literal|0xcbff
block|,
literal|0x0230
block|,
literal|0xcfff
block|,
literal|0x0330
block|,
literal|0xd3ff
block|,
literal|0x0430
block|,
literal|0xd7ff
block|,
literal|0x0530
block|,
literal|0xdbff
block|,
literal|0x0630
block|,
literal|0xdfff
block|,
literal|0x0730
block|,
literal|0xe3ff
block|,
literal|0x0830
block|,
literal|0xe7ff
block|,
literal|0x0930
block|,
literal|0xebff
block|,
literal|0x0a30
block|,
literal|0xefff
block|,
literal|0x0b30
block|,
literal|0xf3ff
block|,
literal|0x0c30
block|,
literal|0xf7ff
block|,
literal|0x0d30
block|,
literal|0xfbff
block|,
literal|0x0e30
block|,
literal|0xffff
block|,
literal|0x0f30
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|init2
index|[
literal|128
index|]
init|=
block|{
literal|0x03ff
block|,
literal|0x8030
block|,
literal|0x07ff
block|,
literal|0x8130
block|,
literal|0x0bff
block|,
literal|0x8230
block|,
literal|0x0fff
block|,
literal|0x8330
block|,
literal|0x13ff
block|,
literal|0x8430
block|,
literal|0x17ff
block|,
literal|0x8530
block|,
literal|0x1bff
block|,
literal|0x8630
block|,
literal|0x1fff
block|,
literal|0x8730
block|,
literal|0x23ff
block|,
literal|0x8830
block|,
literal|0x27ff
block|,
literal|0x8930
block|,
literal|0x2bff
block|,
literal|0x8a30
block|,
literal|0x2fff
block|,
literal|0x8b30
block|,
literal|0x33ff
block|,
literal|0x8c30
block|,
literal|0x37ff
block|,
literal|0x8d30
block|,
literal|0x3bff
block|,
literal|0x8e30
block|,
literal|0x3fff
block|,
literal|0x8f30
block|,
literal|0x43ff
block|,
literal|0x8030
block|,
literal|0x47ff
block|,
literal|0x8130
block|,
literal|0x4bff
block|,
literal|0x8230
block|,
literal|0x4fff
block|,
literal|0x8330
block|,
literal|0x53ff
block|,
literal|0x8430
block|,
literal|0x57ff
block|,
literal|0x8530
block|,
literal|0x5bff
block|,
literal|0x8630
block|,
literal|0x5fff
block|,
literal|0x8730
block|,
literal|0x63ff
block|,
literal|0x8830
block|,
literal|0x67ff
block|,
literal|0x8930
block|,
literal|0x6bff
block|,
literal|0x8a30
block|,
literal|0x6fff
block|,
literal|0x8b30
block|,
literal|0x73ff
block|,
literal|0x8c30
block|,
literal|0x77ff
block|,
literal|0x8d30
block|,
literal|0x7bff
block|,
literal|0x8e30
block|,
literal|0x7fff
block|,
literal|0x8f30
block|,
literal|0x83ff
block|,
literal|0x8030
block|,
literal|0x87ff
block|,
literal|0x8130
block|,
literal|0x8bff
block|,
literal|0x8230
block|,
literal|0x8fff
block|,
literal|0x8330
block|,
literal|0x93ff
block|,
literal|0x8430
block|,
literal|0x97ff
block|,
literal|0x8530
block|,
literal|0x9bff
block|,
literal|0x8630
block|,
literal|0x9fff
block|,
literal|0x8730
block|,
literal|0xa3ff
block|,
literal|0x8830
block|,
literal|0xa7ff
block|,
literal|0x8930
block|,
literal|0xabff
block|,
literal|0x8a30
block|,
literal|0xafff
block|,
literal|0x8b30
block|,
literal|0xb3ff
block|,
literal|0x8c30
block|,
literal|0xb7ff
block|,
literal|0x8d30
block|,
literal|0xbbff
block|,
literal|0x8e30
block|,
literal|0xbfff
block|,
literal|0x8f30
block|,
literal|0xc3ff
block|,
literal|0x8030
block|,
literal|0xc7ff
block|,
literal|0x8130
block|,
literal|0xcbff
block|,
literal|0x8230
block|,
literal|0xcfff
block|,
literal|0x8330
block|,
literal|0xd3ff
block|,
literal|0x8430
block|,
literal|0xd7ff
block|,
literal|0x8530
block|,
literal|0xdbff
block|,
literal|0x8630
block|,
literal|0xdfff
block|,
literal|0x8730
block|,
literal|0xe3ff
block|,
literal|0x8830
block|,
literal|0xe7ff
block|,
literal|0x8930
block|,
literal|0xebff
block|,
literal|0x8a30
block|,
literal|0xefff
block|,
literal|0x8b30
block|,
literal|0xf3ff
block|,
literal|0x8c30
block|,
literal|0xf7ff
block|,
literal|0x8d30
block|,
literal|0xfbff
block|,
literal|0x8e30
block|,
literal|0xffff
block|,
literal|0x8f30
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|init3
index|[
literal|128
index|]
init|=
block|{
literal|0x0C10
block|,
literal|0x8470
block|,
literal|0x14FE
block|,
literal|0xB488
block|,
literal|0x167F
block|,
literal|0xA470
block|,
literal|0x18E7
block|,
literal|0x84B5
block|,
literal|0x1B6E
block|,
literal|0x842A
block|,
literal|0x1F1D
block|,
literal|0x852A
block|,
literal|0x0DA3
block|,
literal|0x8F7C
block|,
literal|0x167E
block|,
literal|0xF254
block|,
literal|0x0000
block|,
literal|0x842A
block|,
literal|0x0001
block|,
literal|0x852A
block|,
literal|0x18E6
block|,
literal|0x8BAA
block|,
literal|0x1B6D
block|,
literal|0xF234
block|,
literal|0x229F
block|,
literal|0x8429
block|,
literal|0x2746
block|,
literal|0x8529
block|,
literal|0x1F1C
block|,
literal|0x86E7
block|,
literal|0x229E
block|,
literal|0xF224
block|,
literal|0x0DA4
block|,
literal|0x8429
block|,
literal|0x2C29
block|,
literal|0x8529
block|,
literal|0x2745
block|,
literal|0x87F6
block|,
literal|0x2C28
block|,
literal|0xF254
block|,
literal|0x383B
block|,
literal|0x8428
block|,
literal|0x320F
block|,
literal|0x8528
block|,
literal|0x320E
block|,
literal|0x8F02
block|,
literal|0x1341
block|,
literal|0xF264
block|,
literal|0x3EB6
block|,
literal|0x8428
block|,
literal|0x3EB9
block|,
literal|0x8528
block|,
literal|0x383A
block|,
literal|0x8FA9
block|,
literal|0x3EB5
block|,
literal|0xF294
block|,
literal|0x3EB7
block|,
literal|0x8474
block|,
literal|0x3EBA
block|,
literal|0x8575
block|,
literal|0x3EB8
block|,
literal|0xC4C3
block|,
literal|0x3EBB
block|,
literal|0xC5C3
block|,
literal|0x0000
block|,
literal|0xA404
block|,
literal|0x0001
block|,
literal|0xA504
block|,
literal|0x141F
block|,
literal|0x8671
block|,
literal|0x14FD
block|,
literal|0x8287
block|,
literal|0x3EBC
block|,
literal|0xE610
block|,
literal|0x3EC8
block|,
literal|0x8C7B
block|,
literal|0x031A
block|,
literal|0x87E6
block|,
literal|0x3EC8
block|,
literal|0x86F7
block|,
literal|0x3EC0
block|,
literal|0x821E
block|,
literal|0x3EBE
block|,
literal|0xD208
block|,
literal|0x3EBD
block|,
literal|0x821F
block|,
literal|0x3ECA
block|,
literal|0x8386
block|,
literal|0x3EC1
block|,
literal|0x8C03
block|,
literal|0x3EC9
block|,
literal|0x831E
block|,
literal|0x3ECA
block|,
literal|0x8C4C
block|,
literal|0x3EBF
block|,
literal|0x8C55
block|,
literal|0x3EC9
block|,
literal|0xC208
block|,
literal|0x3EC4
block|,
literal|0xBC84
block|,
literal|0x3EC8
block|,
literal|0x8EAD
block|,
literal|0x3EC8
block|,
literal|0xD308
block|,
literal|0x3EC2
block|,
literal|0x8F7E
block|,
literal|0x3ECB
block|,
literal|0x8219
block|,
literal|0x3ECB
block|,
literal|0xD26E
block|,
literal|0x3EC5
block|,
literal|0x831F
block|,
literal|0x3EC6
block|,
literal|0xC308
block|,
literal|0x3EC3
block|,
literal|0xB2FF
block|,
literal|0x3EC9
block|,
literal|0x8265
block|,
literal|0x3EC9
block|,
literal|0x8319
block|,
literal|0x1342
block|,
literal|0xD36E
block|,
literal|0x3EC7
block|,
literal|0xB3FF
block|,
literal|0x0000
block|,
literal|0x8365
block|,
literal|0x1420
block|,
literal|0x9570
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|init4
index|[
literal|128
index|]
init|=
block|{
literal|0x0C10
block|,
literal|0x8470
block|,
literal|0x14FE
block|,
literal|0xB488
block|,
literal|0x167F
block|,
literal|0xA470
block|,
literal|0x18E7
block|,
literal|0x84B5
block|,
literal|0x1B6E
block|,
literal|0x842A
block|,
literal|0x1F1D
block|,
literal|0x852A
block|,
literal|0x0DA3
block|,
literal|0x0F7C
block|,
literal|0x167E
block|,
literal|0x7254
block|,
literal|0x0000
block|,
literal|0x842A
block|,
literal|0x0001
block|,
literal|0x852A
block|,
literal|0x18E6
block|,
literal|0x0BAA
block|,
literal|0x1B6D
block|,
literal|0x7234
block|,
literal|0x229F
block|,
literal|0x8429
block|,
literal|0x2746
block|,
literal|0x8529
block|,
literal|0x1F1C
block|,
literal|0x06E7
block|,
literal|0x229E
block|,
literal|0x7224
block|,
literal|0x0DA4
block|,
literal|0x8429
block|,
literal|0x2C29
block|,
literal|0x8529
block|,
literal|0x2745
block|,
literal|0x07F6
block|,
literal|0x2C28
block|,
literal|0x7254
block|,
literal|0x383B
block|,
literal|0x8428
block|,
literal|0x320F
block|,
literal|0x8528
block|,
literal|0x320E
block|,
literal|0x0F02
block|,
literal|0x1341
block|,
literal|0x7264
block|,
literal|0x3EB6
block|,
literal|0x8428
block|,
literal|0x3EB9
block|,
literal|0x8528
block|,
literal|0x383A
block|,
literal|0x0FA9
block|,
literal|0x3EB5
block|,
literal|0x7294
block|,
literal|0x3EB7
block|,
literal|0x8474
block|,
literal|0x3EBA
block|,
literal|0x8575
block|,
literal|0x3EB8
block|,
literal|0x44C3
block|,
literal|0x3EBB
block|,
literal|0x45C3
block|,
literal|0x0000
block|,
literal|0xA404
block|,
literal|0x0001
block|,
literal|0xA504
block|,
literal|0x141F
block|,
literal|0x0671
block|,
literal|0x14FD
block|,
literal|0x0287
block|,
literal|0x3EBC
block|,
literal|0xE610
block|,
literal|0x3EC8
block|,
literal|0x0C7B
block|,
literal|0x031A
block|,
literal|0x07E6
block|,
literal|0x3EC8
block|,
literal|0x86F7
block|,
literal|0x3EC0
block|,
literal|0x821E
block|,
literal|0x3EBE
block|,
literal|0xD208
block|,
literal|0x3EBD
block|,
literal|0x021F
block|,
literal|0x3ECA
block|,
literal|0x0386
block|,
literal|0x3EC1
block|,
literal|0x0C03
block|,
literal|0x3EC9
block|,
literal|0x031E
block|,
literal|0x3ECA
block|,
literal|0x8C4C
block|,
literal|0x3EBF
block|,
literal|0x0C55
block|,
literal|0x3EC9
block|,
literal|0xC208
block|,
literal|0x3EC4
block|,
literal|0xBC84
block|,
literal|0x3EC8
block|,
literal|0x0EAD
block|,
literal|0x3EC8
block|,
literal|0xD308
block|,
literal|0x3EC2
block|,
literal|0x8F7E
block|,
literal|0x3ECB
block|,
literal|0x0219
block|,
literal|0x3ECB
block|,
literal|0xD26E
block|,
literal|0x3EC5
block|,
literal|0x031F
block|,
literal|0x3EC6
block|,
literal|0xC308
block|,
literal|0x3EC3
block|,
literal|0x32FF
block|,
literal|0x3EC9
block|,
literal|0x0265
block|,
literal|0x3EC9
block|,
literal|0x8319
block|,
literal|0x1342
block|,
literal|0xD36E
block|,
literal|0x3EC7
block|,
literal|0x33FF
block|,
literal|0x0000
block|,
literal|0x8365
block|,
literal|0x1420
block|,
literal|0x9570
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* send initialization arrays to start up */
end_comment

begin_function
specifier|static
name|void
name|awe_init_array
parameter_list|(
name|void
parameter_list|)
block|{
name|awe_send_array
argument_list|(
name|init1
argument_list|)
expr_stmt|;
name|awe_wait
argument_list|(
literal|1024
argument_list|)
expr_stmt|;
name|awe_send_array
argument_list|(
name|init2
argument_list|)
expr_stmt|;
name|awe_send_array
argument_list|(
name|init3
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_HWCF4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_HWCF5
argument_list|,
literal|0x83
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_HWCF6
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|awe_send_array
argument_list|(
name|init4
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* send an initialization array */
end_comment

begin_function
specifier|static
name|void
name|awe_send_array
parameter_list|(
name|unsigned
name|short
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|short
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_MAX_VOICES
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
name|awe_poke
argument_list|(
name|AWE_INIT1
argument_list|(
name|i
argument_list|)
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_MAX_VOICES
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
name|awe_poke
argument_list|(
name|AWE_INIT2
argument_list|(
name|i
argument_list|)
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_MAX_VOICES
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
name|awe_poke
argument_list|(
name|AWE_INIT3
argument_list|(
name|i
argument_list|)
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_MAX_VOICES
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
name|awe_poke
argument_list|(
name|AWE_INIT4
argument_list|(
name|i
argument_list|)
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * set up awe32 channels to some known state.  */
end_comment

begin_comment
comment|/* set the envelope& LFO parameters to the default values; see ADIP */
end_comment

begin_function
specifier|static
name|void
name|awe_tweak_voice
parameter_list|(
name|int
name|i
parameter_list|)
block|{
comment|/* set all mod/vol envelope shape to minimum */
name|awe_poke
argument_list|(
name|AWE_ENVVOL
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_ENVVAL
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_DCYSUS
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x7F7F
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_ATKHLDV
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x7F7F
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_ATKHLD
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x7F7F
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_PEFE
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* mod envelope height to zero */
name|awe_poke
argument_list|(
name|AWE_LFO1VAL
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
comment|/* no delay for LFO1 */
name|awe_poke
argument_list|(
name|AWE_LFO2VAL
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_IP
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0xE000
argument_list|)
expr_stmt|;
comment|/* no pitch shift */
name|awe_poke
argument_list|(
name|AWE_IFATN
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0xFF00
argument_list|)
expr_stmt|;
comment|/* volume to minimum */
name|awe_poke
argument_list|(
name|AWE_FMMOD
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_TREMFRQ
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_FM2FRQ2
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|awe_tweak
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* reset all channels */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|awe_max_voices
condition|;
name|i
operator|++
control|)
name|awe_tweak_voice
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  initializes the FM section of AWE32;  *   see Vince Vu's unofficial AWE32 programming guide  */
end_comment

begin_function
specifier|static
name|void
name|awe_init_fm
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|AWE_ALWAYS_INIT_FM
comment|/* if no extended memory is on board.. */
if|if
condition|(
name|awe_mem_size
operator|<=
literal|0
condition|)
return|return;
endif|#
directive|endif
name|DEBUG
argument_list|(
literal|3
argument_list|,
name|printk
argument_list|(
literal|"AWE32: initializing FM\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the last two channels for DRAM refresh and producing 	   the reverb and chorus effects for Yamaha OPL-3 synthesizer */
comment|/* 31: FM left channel, 0xffffe0-0xffffe8 */
name|awe_poke
argument_list|(
name|AWE_DCYSUSV
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PSST
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0xFFFFFFE0
argument_list|)
expr_stmt|;
comment|/* full left */
name|awe_poke_dw
argument_list|(
name|AWE_CSL
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0x00FFFFE8
operator||
operator|(
name|DEF_FM_CHORUS_DEPTH
operator|<<
literal|24
operator|)
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PTRX
argument_list|(
literal|30
argument_list|)
argument_list|,
operator|(
name|DEF_FM_REVERB_DEPTH
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CPF
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0x00FFFFE3
argument_list|)
expr_stmt|;
comment|/* 32: FM right channel, 0xfffff0-0xfffff8 */
name|awe_poke
argument_list|(
name|AWE_DCYSUSV
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PSST
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0x00FFFFF0
argument_list|)
expr_stmt|;
comment|/* full right */
name|awe_poke_dw
argument_list|(
name|AWE_CSL
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0x00FFFFF8
operator||
operator|(
name|DEF_FM_CHORUS_DEPTH
operator|<<
literal|24
operator|)
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PTRX
argument_list|(
literal|31
argument_list|)
argument_list|,
operator|(
name|DEF_FM_REVERB_DEPTH
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CPF
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0x00FFFFF3
argument_list|)
expr_stmt|;
comment|/* skew volume& cutoff */
name|awe_poke_dw
argument_list|(
name|AWE_VTFT
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0x8000FFFF
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_VTFT
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0x8000FFFF
argument_list|)
expr_stmt|;
name|voices
index|[
literal|30
index|]
operator|.
name|state
operator|=
name|AWE_ST_FM
expr_stmt|;
name|voices
index|[
literal|31
index|]
operator|.
name|state
operator|=
name|AWE_ST_FM
expr_stmt|;
comment|/* change maximum channels to 30 */
name|awe_max_voices
operator|=
name|AWE_NORMAL_VOICES
expr_stmt|;
if|if
condition|(
name|playing_mode
operator|==
name|AWE_PLAY_DIRECT
condition|)
name|awe_info
operator|.
name|nr_voices
operator|=
name|awe_max_voices
expr_stmt|;
else|else
name|awe_info
operator|.
name|nr_voices
operator|=
name|AWE_MAX_CHANNELS
expr_stmt|;
name|voice_alloc
operator|->
name|max_voice
operator|=
name|awe_max_voices
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  AWE32 DRAM access routines  */
end_comment

begin_comment
comment|/* open DRAM write accessing mode */
end_comment

begin_function
specifier|static
name|int
name|awe_open_dram_for_write
parameter_list|(
name|int
name|offset
parameter_list|,
name|int
name|channels
parameter_list|)
block|{
name|int
name|vidx
index|[
name|AWE_NORMAL_VOICES
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|channels
operator|<
literal|0
operator|||
name|channels
operator|>=
name|AWE_NORMAL_VOICES
condition|)
block|{
name|channels
operator|=
name|AWE_NORMAL_VOICES
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_NORMAL_VOICES
condition|;
name|i
operator|++
control|)
name|vidx
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels
condition|;
name|i
operator|++
control|)
name|vidx
index|[
name|i
index|]
operator|=
name|awe_clear_voice
argument_list|()
expr_stmt|;
block|}
comment|/* use all channels for DMA transfer */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vidx
index|[
name|i
index|]
operator|<
literal|0
condition|)
continue|continue;
name|awe_poke
argument_list|(
name|AWE_DCYSUSV
argument_list|(
name|vidx
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_VTFT
argument_list|(
name|vidx
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CVCF
argument_list|(
name|vidx
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PTRX
argument_list|(
name|vidx
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|0x40000000
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CPF
argument_list|(
name|vidx
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|0x40000000
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PSST
argument_list|(
name|vidx
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CSL
argument_list|(
name|vidx
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
name|vidx
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|0x06000000
argument_list|)
expr_stmt|;
name|voices
index|[
name|vidx
index|[
name|i
index|]
index|]
operator|.
name|state
operator|=
name|AWE_ST_DRAM
expr_stmt|;
block|}
comment|/* point channels 31& 32 to ROM samples for DRAM refresh */
name|awe_poke_dw
argument_list|(
name|AWE_VTFT
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PSST
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0x1d8
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CSL
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0x1e0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
literal|30
argument_list|)
argument_list|,
literal|0x1d8
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_VTFT
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PSST
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0x1d8
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CSL
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0x1e0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
literal|31
argument_list|)
argument_list|,
literal|0x1d8
argument_list|)
expr_stmt|;
name|voices
index|[
literal|30
index|]
operator|.
name|state
operator|=
name|AWE_ST_FM
expr_stmt|;
name|voices
index|[
literal|31
index|]
operator|.
name|state
operator|=
name|AWE_ST_FM
expr_stmt|;
comment|/* if full bit is on, not ready to write on */
if|if
condition|(
name|awe_peek_dw
argument_list|(
name|AWE_SMALW
argument_list|)
operator|&
literal|0x80000000
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|channels
condition|;
name|i
operator|++
control|)
block|{
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
name|vidx
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|voices
index|[
name|i
index|]
operator|.
name|state
operator|=
name|AWE_ST_OFF
expr_stmt|;
block|}
return|return
name|RET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
return|;
block|}
comment|/* set address to write */
name|awe_poke_dw
argument_list|(
name|AWE_SMALW
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* open DRAM for RAM size detection */
end_comment

begin_function
specifier|static
name|void
name|awe_open_dram_for_check
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_NORMAL_VOICES
condition|;
name|i
operator|++
control|)
block|{
name|awe_poke
argument_list|(
name|AWE_DCYSUSV
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x80
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_VTFT
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CVCF
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PTRX
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x40000000
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CPF
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x40000000
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_PSST
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_CSL
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|&
literal|1
condition|)
comment|/* DMA write */
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x06000000
argument_list|)
expr_stmt|;
else|else
comment|/* DMA read */
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x04000000
argument_list|)
expr_stmt|;
name|voices
index|[
name|i
index|]
operator|.
name|state
operator|=
name|AWE_ST_DRAM
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* close dram access */
end_comment

begin_function
specifier|static
name|void
name|awe_close_dram
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* wait until FULL bit in SMAxW register be false */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10000
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|awe_peek_dw
argument_list|(
name|AWE_SMALW
argument_list|)
operator|&
literal|0x80000000
operator|)
condition|)
break|break;
name|awe_wait
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|AWE_NORMAL_VOICES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|voices
index|[
name|i
index|]
operator|.
name|state
operator|==
name|AWE_ST_DRAM
condition|)
block|{
name|awe_poke_dw
argument_list|(
name|AWE_CCCA
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_DCYSUSV
argument_list|(
name|i
argument_list|)
argument_list|,
literal|0x807F
argument_list|)
expr_stmt|;
name|voices
index|[
name|i
index|]
operator|.
name|state
operator|=
name|AWE_ST_OFF
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*================================================================  * detect presence of AWE32 and check memory size  *================================================================*/
end_comment

begin_comment
comment|/* detect emu8000 chip on the specified address; from VV's guide */
end_comment

begin_function
specifier|static
name|int
name|awe_detect_base
parameter_list|(
name|int
name|addr
parameter_list|)
block|{
name|awe_base
operator|=
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|awe_peek
argument_list|(
name|AWE_U1
argument_list|)
operator|&
literal|0x000F
operator|)
operator|!=
literal|0x000C
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|awe_peek
argument_list|(
name|AWE_HWCF1
argument_list|)
operator|&
literal|0x007E
operator|)
operator|!=
literal|0x0058
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|awe_peek
argument_list|(
name|AWE_HWCF2
argument_list|)
operator|&
literal|0x0003
operator|)
operator|!=
literal|0x0003
condition|)
return|return
literal|0
return|;
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32 found at %x\n"
argument_list|,
name|awe_base
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|awe_detect
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|base
decl_stmt|;
if|if
condition|(
name|awe_base
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|base
operator|=
literal|0x620
init|;
name|base
operator|<=
literal|0x680
condition|;
name|base
operator|+=
literal|0x20
control|)
if|if
condition|(
name|awe_detect_base
argument_list|(
name|base
argument_list|)
condition|)
return|return
literal|1
return|;
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32 not found\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*================================================================  * check dram size on AWE board  *================================================================*/
end_comment

begin_comment
comment|/* any three numbers you like */
end_comment

begin_define
define|#
directive|define
name|UNIQUE_ID1
value|0x1234
end_define

begin_define
define|#
directive|define
name|UNIQUE_ID2
value|0x4321
end_define

begin_define
define|#
directive|define
name|UNIQUE_ID3
value|0xFFFF
end_define

begin_function
specifier|static
name|int
name|awe_check_dram
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|awe_mem_size
operator|>
literal|0
condition|)
block|{
name|awe_mem_size
operator|*=
literal|1024
expr_stmt|;
comment|/* convert to Kbytes */
return|return
name|awe_mem_size
return|;
block|}
name|awe_open_dram_for_check
argument_list|()
expr_stmt|;
name|awe_mem_size
operator|=
literal|0
expr_stmt|;
comment|/* set up unique two id numbers */
name|awe_poke_dw
argument_list|(
name|AWE_SMALW
argument_list|,
name|AWE_DRAM_OFFSET
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_SMLD
argument_list|,
name|UNIQUE_ID1
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_SMLD
argument_list|,
name|UNIQUE_ID2
argument_list|)
expr_stmt|;
while|while
condition|(
name|awe_mem_size
operator|<
name|AWE_MAX_DRAM_SIZE
condition|)
block|{
name|awe_wait
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* read a data on the DRAM start address */
name|awe_poke_dw
argument_list|(
name|AWE_SMALR
argument_list|,
name|AWE_DRAM_OFFSET
argument_list|)
expr_stmt|;
name|awe_peek
argument_list|(
name|AWE_SMLD
argument_list|)
expr_stmt|;
comment|/* discard stale data  */
if|if
condition|(
name|awe_peek
argument_list|(
name|AWE_SMLD
argument_list|)
operator|!=
name|UNIQUE_ID1
condition|)
break|break;
if|if
condition|(
name|awe_peek
argument_list|(
name|AWE_SMLD
argument_list|)
operator|!=
name|UNIQUE_ID2
condition|)
break|break;
name|awe_mem_size
operator|+=
literal|32
expr_stmt|;
comment|/* increment 32 Kbytes */
comment|/* Write a unique data on the test address; 		 * if the address is out of range, the data is written on 		 * 0x200000(=AWE_DRAM_OFFSET).  Then the two id words are 		 * broken by this data. 		 */
name|awe_poke_dw
argument_list|(
name|AWE_SMALW
argument_list|,
name|AWE_DRAM_OFFSET
operator|+
name|awe_mem_size
operator|*
literal|512L
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_SMLD
argument_list|,
name|UNIQUE_ID3
argument_list|)
expr_stmt|;
name|awe_wait
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/* read a data on the just written DRAM address */
name|awe_poke_dw
argument_list|(
name|AWE_SMALR
argument_list|,
name|AWE_DRAM_OFFSET
operator|+
name|awe_mem_size
operator|*
literal|512L
argument_list|)
expr_stmt|;
name|awe_peek
argument_list|(
name|AWE_SMLD
argument_list|)
expr_stmt|;
comment|/* discard stale data  */
if|if
condition|(
name|awe_peek
argument_list|(
name|AWE_SMLD
argument_list|)
operator|!=
name|UNIQUE_ID3
condition|)
break|break;
block|}
name|awe_close_dram
argument_list|()
expr_stmt|;
name|DEBUG
argument_list|(
literal|0
argument_list|,
name|printk
argument_list|(
literal|"AWE32: %d Kbytes memory detected\n"
argument_list|,
name|awe_mem_size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* convert to Kbytes */
name|awe_mem_size
operator|*=
literal|1024
expr_stmt|;
return|return
name|awe_mem_size
return|;
block|}
end_function

begin_comment
comment|/*================================================================  * chorus and reverb controls; from VV's guide  *================================================================*/
end_comment

begin_comment
comment|/* 5 parameters for each chorus mode; 3 x 16bit, 2 x 32bit */
end_comment

begin_decl_stmt
specifier|static
name|char
name|chorus_defined
index|[
name|AWE_CHORUS_NUMBERS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|awe_chorus_fx_rec
name|chorus_parm
index|[
name|AWE_CHORUS_NUMBERS
index|]
init|=
block|{
block|{
literal|0xE600
block|,
literal|0x03F6
block|,
literal|0xBC2C
block|,
literal|0x00000000
block|,
literal|0x0000006D
block|}
block|,
comment|/* chorus 1 */
block|{
literal|0xE608
block|,
literal|0x031A
block|,
literal|0xBC6E
block|,
literal|0x00000000
block|,
literal|0x0000017C
block|}
block|,
comment|/* chorus 2 */
block|{
literal|0xE610
block|,
literal|0x031A
block|,
literal|0xBC84
block|,
literal|0x00000000
block|,
literal|0x00000083
block|}
block|,
comment|/* chorus 3 */
block|{
literal|0xE620
block|,
literal|0x0269
block|,
literal|0xBC6E
block|,
literal|0x00000000
block|,
literal|0x0000017C
block|}
block|,
comment|/* chorus 4 */
block|{
literal|0xE680
block|,
literal|0x04D3
block|,
literal|0xBCA6
block|,
literal|0x00000000
block|,
literal|0x0000005B
block|}
block|,
comment|/* feedback */
block|{
literal|0xE6E0
block|,
literal|0x044E
block|,
literal|0xBC37
block|,
literal|0x00000000
block|,
literal|0x00000026
block|}
block|,
comment|/* flanger */
block|{
literal|0xE600
block|,
literal|0x0B06
block|,
literal|0xBC00
block|,
literal|0x0000E000
block|,
literal|0x00000083
block|}
block|,
comment|/* short delay */
block|{
literal|0xE6C0
block|,
literal|0x0B06
block|,
literal|0xBC00
block|,
literal|0x0000E000
block|,
literal|0x00000083
block|}
block|,
comment|/* short delay + feedback */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|awe_load_chorus_fx
parameter_list|(
name|awe_patch_info
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
if|if
condition|(
name|patch
operator|->
name|optarg
operator|<
name|AWE_CHORUS_PREDEFINED
operator|||
name|patch
operator|->
name|optarg
operator|>=
name|AWE_CHORUS_NUMBERS
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32 Error: illegal chorus mode %d for uploading\n"
argument_list|,
name|patch
operator|->
name|optarg
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|count
operator|<
sizeof|sizeof
argument_list|(
name|awe_chorus_fx_rec
argument_list|)
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32 Error: too short chorus fx parameters\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|COPY_FROM_USER
argument_list|(
operator|&
name|chorus_parm
index|[
name|patch
operator|->
name|optarg
index|]
argument_list|,
name|addr
argument_list|,
name|AWE_PATCH_INFO_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|awe_chorus_fx_rec
argument_list|)
argument_list|)
expr_stmt|;
name|chorus_defined
index|[
name|patch
operator|->
name|optarg
index|]
operator|=
name|TRUE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|awe_set_chorus_mode
parameter_list|(
name|int
name|effect
parameter_list|)
block|{
if|if
condition|(
name|effect
operator|<
literal|0
operator|||
name|effect
operator|>=
name|AWE_CHORUS_NUMBERS
operator|||
operator|(
name|effect
operator|>=
name|AWE_CHORUS_PREDEFINED
operator|&&
operator|!
name|chorus_defined
index|[
name|effect
index|]
operator|)
condition|)
return|return;
name|awe_poke
argument_list|(
name|AWE_INIT3
argument_list|(
literal|9
argument_list|)
argument_list|,
name|chorus_parm
index|[
name|effect
index|]
operator|.
name|feedback
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_INIT3
argument_list|(
literal|12
argument_list|)
argument_list|,
name|chorus_parm
index|[
name|effect
index|]
operator|.
name|delay_offset
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_INIT4
argument_list|(
literal|3
argument_list|)
argument_list|,
name|chorus_parm
index|[
name|effect
index|]
operator|.
name|lfo_depth
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_HWCF4
argument_list|,
name|chorus_parm
index|[
name|effect
index|]
operator|.
name|delay
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_HWCF5
argument_list|,
name|chorus_parm
index|[
name|effect
index|]
operator|.
name|lfo_freq
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_HWCF6
argument_list|,
literal|0x8000
argument_list|)
expr_stmt|;
name|awe_poke_dw
argument_list|(
name|AWE_HWCF7
argument_list|,
literal|0x0000
argument_list|)
expr_stmt|;
name|chorus_mode
operator|=
name|effect
expr_stmt|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------*/
end_comment

begin_comment
comment|/* reverb mode settings; write the following 28 data of 16 bit length  *   on the corresponding ports in the reverb_cmds array  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|reverb_defined
index|[
name|AWE_CHORUS_NUMBERS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|awe_reverb_fx_rec
name|reverb_parm
index|[
name|AWE_REVERB_NUMBERS
index|]
init|=
block|{
block|{
block|{
comment|/* room 1 */
literal|0xB488
block|,
literal|0xA450
block|,
literal|0x9550
block|,
literal|0x84B5
block|,
literal|0x383A
block|,
literal|0x3EB5
block|,
literal|0x72F4
block|,
literal|0x72A4
block|,
literal|0x7254
block|,
literal|0x7204
block|,
literal|0x7204
block|,
literal|0x7204
block|,
literal|0x4416
block|,
literal|0x4516
block|,
literal|0xA490
block|,
literal|0xA590
block|,
literal|0x842A
block|,
literal|0x852A
block|,
literal|0x842A
block|,
literal|0x852A
block|,
literal|0x8429
block|,
literal|0x8529
block|,
literal|0x8429
block|,
literal|0x8529
block|,
literal|0x8428
block|,
literal|0x8528
block|,
literal|0x8428
block|,
literal|0x8528
block|, }
block|}
block|,
block|{
block|{
comment|/* room 2 */
literal|0xB488
block|,
literal|0xA458
block|,
literal|0x9558
block|,
literal|0x84B5
block|,
literal|0x383A
block|,
literal|0x3EB5
block|,
literal|0x7284
block|,
literal|0x7254
block|,
literal|0x7224
block|,
literal|0x7224
block|,
literal|0x7254
block|,
literal|0x7284
block|,
literal|0x4448
block|,
literal|0x4548
block|,
literal|0xA440
block|,
literal|0xA540
block|,
literal|0x842A
block|,
literal|0x852A
block|,
literal|0x842A
block|,
literal|0x852A
block|,
literal|0x8429
block|,
literal|0x8529
block|,
literal|0x8429
block|,
literal|0x8529
block|,
literal|0x8428
block|,
literal|0x8528
block|,
literal|0x8428
block|,
literal|0x8528
block|, }
block|}
block|,
block|{
block|{
comment|/* room 3 */
literal|0xB488
block|,
literal|0xA460
block|,
literal|0x9560
block|,
literal|0x84B5
block|,
literal|0x383A
block|,
literal|0x3EB5
block|,
literal|0x7284
block|,
literal|0x7254
block|,
literal|0x7224
block|,
literal|0x7224
block|,
literal|0x7254
block|,
literal|0x7284
block|,
literal|0x4416
block|,
literal|0x4516
block|,
literal|0xA490
block|,
literal|0xA590
block|,
literal|0x842C
block|,
literal|0x852C
block|,
literal|0x842C
block|,
literal|0x852C
block|,
literal|0x842B
block|,
literal|0x852B
block|,
literal|0x842B
block|,
literal|0x852B
block|,
literal|0x842A
block|,
literal|0x852A
block|,
literal|0x842A
block|,
literal|0x852A
block|, }
block|}
block|,
block|{
block|{
comment|/* hall 1 */
literal|0xB488
block|,
literal|0xA470
block|,
literal|0x9570
block|,
literal|0x84B5
block|,
literal|0x383A
block|,
literal|0x3EB5
block|,
literal|0x7284
block|,
literal|0x7254
block|,
literal|0x7224
block|,
literal|0x7224
block|,
literal|0x7254
block|,
literal|0x7284
block|,
literal|0x4448
block|,
literal|0x4548
block|,
literal|0xA440
block|,
literal|0xA540
block|,
literal|0x842B
block|,
literal|0x852B
block|,
literal|0x842B
block|,
literal|0x852B
block|,
literal|0x842A
block|,
literal|0x852A
block|,
literal|0x842A
block|,
literal|0x852A
block|,
literal|0x8429
block|,
literal|0x8529
block|,
literal|0x8429
block|,
literal|0x8529
block|, }
block|}
block|,
block|{
block|{
comment|/* hall 2 */
literal|0xB488
block|,
literal|0xA470
block|,
literal|0x9570
block|,
literal|0x84B5
block|,
literal|0x383A
block|,
literal|0x3EB5
block|,
literal|0x7254
block|,
literal|0x7234
block|,
literal|0x7224
block|,
literal|0x7254
block|,
literal|0x7264
block|,
literal|0x7294
block|,
literal|0x44C3
block|,
literal|0x45C3
block|,
literal|0xA404
block|,
literal|0xA504
block|,
literal|0x842A
block|,
literal|0x852A
block|,
literal|0x842A
block|,
literal|0x852A
block|,
literal|0x8429
block|,
literal|0x8529
block|,
literal|0x8429
block|,
literal|0x8529
block|,
literal|0x8428
block|,
literal|0x8528
block|,
literal|0x8428
block|,
literal|0x8528
block|, }
block|}
block|,
block|{
block|{
comment|/* plate */
literal|0xB4FF
block|,
literal|0xA470
block|,
literal|0x9570
block|,
literal|0x84B5
block|,
literal|0x383A
block|,
literal|0x3EB5
block|,
literal|0x7234
block|,
literal|0x7234
block|,
literal|0x7234
block|,
literal|0x7234
block|,
literal|0x7234
block|,
literal|0x7234
block|,
literal|0x4448
block|,
literal|0x4548
block|,
literal|0xA440
block|,
literal|0xA540
block|,
literal|0x842A
block|,
literal|0x852A
block|,
literal|0x842A
block|,
literal|0x852A
block|,
literal|0x8429
block|,
literal|0x8529
block|,
literal|0x8429
block|,
literal|0x8529
block|,
literal|0x8428
block|,
literal|0x8528
block|,
literal|0x8428
block|,
literal|0x8528
block|, }
block|}
block|,
block|{
block|{
comment|/* delay */
literal|0xB4FF
block|,
literal|0xA470
block|,
literal|0x9500
block|,
literal|0x84B5
block|,
literal|0x333A
block|,
literal|0x39B5
block|,
literal|0x7204
block|,
literal|0x7204
block|,
literal|0x7204
block|,
literal|0x7204
block|,
literal|0x7204
block|,
literal|0x72F4
block|,
literal|0x4400
block|,
literal|0x4500
block|,
literal|0xA4FF
block|,
literal|0xA5FF
block|,
literal|0x8420
block|,
literal|0x8520
block|,
literal|0x8420
block|,
literal|0x8520
block|,
literal|0x8420
block|,
literal|0x8520
block|,
literal|0x8420
block|,
literal|0x8520
block|,
literal|0x8420
block|,
literal|0x8520
block|,
literal|0x8420
block|,
literal|0x8520
block|, }
block|}
block|,
block|{
block|{
comment|/* panning delay */
literal|0xB4FF
block|,
literal|0xA490
block|,
literal|0x9590
block|,
literal|0x8474
block|,
literal|0x333A
block|,
literal|0x39B5
block|,
literal|0x7204
block|,
literal|0x7204
block|,
literal|0x7204
block|,
literal|0x7204
block|,
literal|0x7204
block|,
literal|0x72F4
block|,
literal|0x4400
block|,
literal|0x4500
block|,
literal|0xA4FF
block|,
literal|0xA5FF
block|,
literal|0x8420
block|,
literal|0x8520
block|,
literal|0x8420
block|,
literal|0x8520
block|,
literal|0x8420
block|,
literal|0x8520
block|,
literal|0x8420
block|,
literal|0x8520
block|,
literal|0x8420
block|,
literal|0x8520
block|,
literal|0x8420
block|,
literal|0x8520
block|, }
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|ReverbCmdPair
block|{
name|unsigned
name|short
name|cmd
decl_stmt|,
name|port
decl_stmt|;
block|}
name|reverb_cmds
index|[
literal|28
index|]
init|=
block|{
block|{
name|AWE_INIT1
argument_list|(
literal|0x03
argument_list|)
block|}
block|,
block|{
name|AWE_INIT1
argument_list|(
literal|0x05
argument_list|)
block|}
block|,
block|{
name|AWE_INIT4
argument_list|(
literal|0x1F
argument_list|)
block|}
block|,
block|{
name|AWE_INIT1
argument_list|(
literal|0x07
argument_list|)
block|}
block|,
block|{
name|AWE_INIT2
argument_list|(
literal|0x14
argument_list|)
block|}
block|,
block|{
name|AWE_INIT2
argument_list|(
literal|0x16
argument_list|)
block|}
block|,
block|{
name|AWE_INIT1
argument_list|(
literal|0x0F
argument_list|)
block|}
block|,
block|{
name|AWE_INIT1
argument_list|(
literal|0x17
argument_list|)
block|}
block|,
block|{
name|AWE_INIT1
argument_list|(
literal|0x1F
argument_list|)
block|}
block|,
block|{
name|AWE_INIT2
argument_list|(
literal|0x07
argument_list|)
block|}
block|,
block|{
name|AWE_INIT2
argument_list|(
literal|0x0F
argument_list|)
block|}
block|,
block|{
name|AWE_INIT2
argument_list|(
literal|0x17
argument_list|)
block|}
block|,
block|{
name|AWE_INIT2
argument_list|(
literal|0x1D
argument_list|)
block|}
block|,
block|{
name|AWE_INIT2
argument_list|(
literal|0x1F
argument_list|)
block|}
block|,
block|{
name|AWE_INIT3
argument_list|(
literal|0x01
argument_list|)
block|}
block|,
block|{
name|AWE_INIT3
argument_list|(
literal|0x03
argument_list|)
block|}
block|,
block|{
name|AWE_INIT1
argument_list|(
literal|0x09
argument_list|)
block|}
block|,
block|{
name|AWE_INIT1
argument_list|(
literal|0x0B
argument_list|)
block|}
block|,
block|{
name|AWE_INIT1
argument_list|(
literal|0x11
argument_list|)
block|}
block|,
block|{
name|AWE_INIT1
argument_list|(
literal|0x13
argument_list|)
block|}
block|,
block|{
name|AWE_INIT1
argument_list|(
literal|0x19
argument_list|)
block|}
block|,
block|{
name|AWE_INIT1
argument_list|(
literal|0x1B
argument_list|)
block|}
block|,
block|{
name|AWE_INIT2
argument_list|(
literal|0x01
argument_list|)
block|}
block|,
block|{
name|AWE_INIT2
argument_list|(
literal|0x03
argument_list|)
block|}
block|,
block|{
name|AWE_INIT2
argument_list|(
literal|0x09
argument_list|)
block|}
block|,
block|{
name|AWE_INIT2
argument_list|(
literal|0x0B
argument_list|)
block|}
block|,
block|{
name|AWE_INIT2
argument_list|(
literal|0x11
argument_list|)
block|}
block|,
block|{
name|AWE_INIT2
argument_list|(
literal|0x13
argument_list|)
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|int
name|awe_load_reverb_fx
parameter_list|(
name|awe_patch_info
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|count
parameter_list|)
block|{
if|if
condition|(
name|patch
operator|->
name|optarg
operator|<
name|AWE_REVERB_PREDEFINED
operator|||
name|patch
operator|->
name|optarg
operator|>=
name|AWE_REVERB_NUMBERS
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32 Error: illegal reverb mode %d for uploading\n"
argument_list|,
name|patch
operator|->
name|optarg
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|count
operator|<
sizeof|sizeof
argument_list|(
name|awe_reverb_fx_rec
argument_list|)
condition|)
block|{
name|printk
argument_list|(
literal|"AWE32 Error: too short reverb fx parameters\n"
argument_list|)
expr_stmt|;
return|return
name|RET_ERROR
argument_list|(
name|EINVAL
argument_list|)
return|;
block|}
name|COPY_FROM_USER
argument_list|(
operator|&
name|reverb_parm
index|[
name|patch
operator|->
name|optarg
index|]
argument_list|,
name|addr
argument_list|,
name|AWE_PATCH_INFO_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|awe_reverb_fx_rec
argument_list|)
argument_list|)
expr_stmt|;
name|reverb_defined
index|[
name|patch
operator|->
name|optarg
index|]
operator|=
name|TRUE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|awe_set_reverb_mode
parameter_list|(
name|int
name|effect
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|effect
operator|<
literal|0
operator|||
name|effect
operator|>=
name|AWE_REVERB_NUMBERS
operator|||
operator|(
name|effect
operator|>=
name|AWE_REVERB_PREDEFINED
operator|&&
operator|!
name|reverb_defined
index|[
name|effect
index|]
operator|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|28
condition|;
name|i
operator|++
control|)
name|awe_poke
argument_list|(
name|reverb_cmds
index|[
name|i
index|]
operator|.
name|cmd
argument_list|,
name|reverb_cmds
index|[
name|i
index|]
operator|.
name|port
argument_list|,
name|reverb_parm
index|[
name|effect
index|]
operator|.
name|parms
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|reverb_mode
operator|=
name|effect
expr_stmt|;
block|}
end_function

begin_comment
comment|/*================================================================  * treble/bass equalizer control  *================================================================*/
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|bass_parm
index|[
literal|12
index|]
index|[
literal|3
index|]
init|=
block|{
block|{
literal|0xD26A
block|,
literal|0xD36A
block|,
literal|0x0000
block|}
block|,
comment|/* -12 dB */
block|{
literal|0xD25B
block|,
literal|0xD35B
block|,
literal|0x0000
block|}
block|,
comment|/*  -8 */
block|{
literal|0xD24C
block|,
literal|0xD34C
block|,
literal|0x0000
block|}
block|,
comment|/*  -6 */
block|{
literal|0xD23D
block|,
literal|0xD33D
block|,
literal|0x0000
block|}
block|,
comment|/*  -4 */
block|{
literal|0xD21F
block|,
literal|0xD31F
block|,
literal|0x0000
block|}
block|,
comment|/*  -2 */
block|{
literal|0xC208
block|,
literal|0xC308
block|,
literal|0x0001
block|}
block|,
comment|/*   0 (HW default) */
block|{
literal|0xC219
block|,
literal|0xC319
block|,
literal|0x0001
block|}
block|,
comment|/*  +2 */
block|{
literal|0xC22A
block|,
literal|0xC32A
block|,
literal|0x0001
block|}
block|,
comment|/*  +4 */
block|{
literal|0xC24C
block|,
literal|0xC34C
block|,
literal|0x0001
block|}
block|,
comment|/*  +6 */
block|{
literal|0xC26E
block|,
literal|0xC36E
block|,
literal|0x0001
block|}
block|,
comment|/*  +8 */
block|{
literal|0xC248
block|,
literal|0xC348
block|,
literal|0x0002
block|}
block|,
comment|/* +10 */
block|{
literal|0xC26A
block|,
literal|0xC36A
block|,
literal|0x0002
block|}
block|,
comment|/* +12 dB */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|short
name|treble_parm
index|[
literal|12
index|]
index|[
literal|9
index|]
init|=
block|{
block|{
literal|0x821E
block|,
literal|0xC26A
block|,
literal|0x031E
block|,
literal|0xC36A
block|,
literal|0x021E
block|,
literal|0xD208
block|,
literal|0x831E
block|,
literal|0xD308
block|,
literal|0x0001
block|}
block|,
comment|/* -12 dB */
block|{
literal|0x821E
block|,
literal|0xC25B
block|,
literal|0x031E
block|,
literal|0xC35B
block|,
literal|0x021E
block|,
literal|0xD208
block|,
literal|0x831E
block|,
literal|0xD308
block|,
literal|0x0001
block|}
block|,
block|{
literal|0x821E
block|,
literal|0xC24C
block|,
literal|0x031E
block|,
literal|0xC34C
block|,
literal|0x021E
block|,
literal|0xD208
block|,
literal|0x831E
block|,
literal|0xD308
block|,
literal|0x0001
block|}
block|,
block|{
literal|0x821E
block|,
literal|0xC23D
block|,
literal|0x031E
block|,
literal|0xC33D
block|,
literal|0x021E
block|,
literal|0xD208
block|,
literal|0x831E
block|,
literal|0xD308
block|,
literal|0x0001
block|}
block|,
block|{
literal|0x821E
block|,
literal|0xC21F
block|,
literal|0x031E
block|,
literal|0xC31F
block|,
literal|0x021E
block|,
literal|0xD208
block|,
literal|0x831E
block|,
literal|0xD308
block|,
literal|0x0001
block|}
block|,
block|{
literal|0x821E
block|,
literal|0xD208
block|,
literal|0x031E
block|,
literal|0xD308
block|,
literal|0x021E
block|,
literal|0xD208
block|,
literal|0x831E
block|,
literal|0xD308
block|,
literal|0x0002
block|}
block|,
block|{
literal|0x821E
block|,
literal|0xD208
block|,
literal|0x031E
block|,
literal|0xD308
block|,
literal|0x021D
block|,
literal|0xD219
block|,
literal|0x831D
block|,
literal|0xD319
block|,
literal|0x0002
block|}
block|,
block|{
literal|0x821E
block|,
literal|0xD208
block|,
literal|0x031E
block|,
literal|0xD308
block|,
literal|0x021C
block|,
literal|0xD22A
block|,
literal|0x831C
block|,
literal|0xD32A
block|,
literal|0x0002
block|}
block|,
block|{
literal|0x821E
block|,
literal|0xD208
block|,
literal|0x031E
block|,
literal|0xD308
block|,
literal|0x021A
block|,
literal|0xD24C
block|,
literal|0x831A
block|,
literal|0xD34C
block|,
literal|0x0002
block|}
block|,
block|{
literal|0x821E
block|,
literal|0xD208
block|,
literal|0x031E
block|,
literal|0xD308
block|,
literal|0x0219
block|,
literal|0xD26E
block|,
literal|0x8319
block|,
literal|0xD36E
block|,
literal|0x0002
block|}
block|,
comment|/* +8 (HW default) */
block|{
literal|0x821D
block|,
literal|0xD219
block|,
literal|0x031D
block|,
literal|0xD319
block|,
literal|0x0219
block|,
literal|0xD26E
block|,
literal|0x8319
block|,
literal|0xD36E
block|,
literal|0x0002
block|}
block|,
block|{
literal|0x821C
block|,
literal|0xD22A
block|,
literal|0x031C
block|,
literal|0xD32A
block|,
literal|0x0219
block|,
literal|0xD26E
block|,
literal|0x8319
block|,
literal|0xD36E
block|,
literal|0x0002
block|}
block|,
comment|/* +12 dB */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * set Emu8000 digital equalizer; from 0 to 11 [-12dB - 12dB]  */
end_comment

begin_function
specifier|static
name|void
name|awe_equalizer
parameter_list|(
name|int
name|bass
parameter_list|,
name|int
name|treble
parameter_list|)
block|{
name|unsigned
name|short
name|w
decl_stmt|;
if|if
condition|(
name|bass
operator|<
literal|0
operator|||
name|bass
operator|>
literal|11
operator|||
name|treble
operator|<
literal|0
operator|||
name|treble
operator|>
literal|11
condition|)
return|return;
name|awe_bass_level
operator|=
name|bass
expr_stmt|;
name|awe_treble_level
operator|=
name|treble
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_INIT4
argument_list|(
literal|0x01
argument_list|)
argument_list|,
name|bass_parm
index|[
name|bass
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_INIT4
argument_list|(
literal|0x11
argument_list|)
argument_list|,
name|bass_parm
index|[
name|bass
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_INIT3
argument_list|(
literal|0x11
argument_list|)
argument_list|,
name|treble_parm
index|[
name|treble
index|]
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_INIT3
argument_list|(
literal|0x13
argument_list|)
argument_list|,
name|treble_parm
index|[
name|treble
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_INIT3
argument_list|(
literal|0x1B
argument_list|)
argument_list|,
name|treble_parm
index|[
name|treble
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_INIT4
argument_list|(
literal|0x07
argument_list|)
argument_list|,
name|treble_parm
index|[
name|treble
index|]
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_INIT4
argument_list|(
literal|0x0B
argument_list|)
argument_list|,
name|treble_parm
index|[
name|treble
index|]
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_INIT4
argument_list|(
literal|0x0D
argument_list|)
argument_list|,
name|treble_parm
index|[
name|treble
index|]
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_INIT4
argument_list|(
literal|0x17
argument_list|)
argument_list|,
name|treble_parm
index|[
name|treble
index|]
index|[
literal|6
index|]
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_INIT4
argument_list|(
literal|0x19
argument_list|)
argument_list|,
name|treble_parm
index|[
name|treble
index|]
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
name|w
operator|=
name|bass_parm
index|[
name|bass
index|]
index|[
literal|2
index|]
operator|+
name|treble_parm
index|[
name|treble
index|]
index|[
literal|8
index|]
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_INIT4
argument_list|(
literal|0x15
argument_list|)
argument_list|,
call|(
name|unsigned
name|short
call|)
argument_list|(
name|w
operator|+
literal|0x0262
argument_list|)
argument_list|)
expr_stmt|;
name|awe_poke
argument_list|(
name|AWE_INIT4
argument_list|(
literal|0x1D
argument_list|)
argument_list|,
call|(
name|unsigned
name|short
call|)
argument_list|(
name|w
operator|+
literal|0x8362
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_AWE32_SYNTH */
end_comment

end_unit

