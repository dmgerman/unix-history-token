begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2011 Aleksandr Rybalko<ray@dlink.ua>  *   based on geom_redboot.c  * Copyright (c) 2009 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom_slice.h>
end_include

begin_define
define|#
directive|define
name|MAP_CLASS_NAME
value|"MAP"
end_define

begin_struct
struct|struct
name|map_desc
block|{
name|uint8_t
name|name
index|[
literal|16
index|]
decl_stmt|;
comment|/* null-terminated name */
name|uint32_t
name|offset
decl_stmt|;
comment|/* offset in flash */
name|uint32_t
name|addr
decl_stmt|;
comment|/* address in memory */
name|uint32_t
name|size
decl_stmt|;
comment|/* image size in bytes */
name|uint32_t
name|entry
decl_stmt|;
comment|/* offset in image for entry point */
name|uint32_t
name|dsize
decl_stmt|;
comment|/* data size in bytes */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAP_MAXSLICE
value|64
end_define

begin_struct
struct|struct
name|g_map_softc
block|{
name|uint32_t
name|entry
index|[
name|MAP_MAXSLICE
index|]
decl_stmt|;
name|uint32_t
name|dsize
index|[
name|MAP_MAXSLICE
index|]
decl_stmt|;
name|uint8_t
name|readonly
index|[
name|MAP_MAXSLICE
index|]
decl_stmt|;
name|g_access_t
modifier|*
name|parent_access
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|g_map_ioctl
parameter_list|(
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
name|ENOIOCTL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_map_access
parameter_list|(
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|dread
parameter_list|,
name|int
name|dwrite
parameter_list|,
name|int
name|dexcl
parameter_list|)
block|{
name|struct
name|g_geom
modifier|*
name|gp
init|=
name|pp
operator|->
name|geom
decl_stmt|;
name|struct
name|g_slicer
modifier|*
name|gsp
init|=
name|gp
operator|->
name|softc
decl_stmt|;
name|struct
name|g_map_softc
modifier|*
name|sc
init|=
name|gsp
operator|->
name|softc
decl_stmt|;
if|if
condition|(
name|dwrite
operator|>
literal|0
operator|&&
name|sc
operator|->
name|readonly
index|[
name|pp
operator|->
name|index
index|]
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
return|return
operator|(
name|sc
operator|->
name|parent_access
argument_list|(
name|pp
argument_list|,
name|dread
argument_list|,
name|dwrite
argument_list|,
name|dexcl
argument_list|)
operator|)
return|;
comment|/*  	 * no (sc->parent_access(pp, dread, dwrite, dexcl));, 	 * We need to have way for update flash  	 */
block|}
end_function

begin_function
specifier|static
name|int
name|g_map_start
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_map_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_slicer
modifier|*
name|gsp
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|pp
operator|=
name|bp
operator|->
name|bio_to
expr_stmt|;
name|idx
operator|=
name|pp
operator|->
name|index
expr_stmt|;
name|gp
operator|=
name|pp
operator|->
name|geom
expr_stmt|;
name|gsp
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
name|sc
operator|=
name|gsp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_GETATTR
condition|)
block|{
if|if
condition|(
name|g_handleattr_int
argument_list|(
name|bp
argument_list|,
name|MAP_CLASS_NAME
literal|"::entry"
argument_list|,
name|sc
operator|->
name|entry
index|[
name|idx
index|]
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|g_handleattr_int
argument_list|(
name|bp
argument_list|,
name|MAP_CLASS_NAME
literal|"::dsize"
argument_list|,
name|sc
operator|->
name|dsize
index|[
name|idx
index|]
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_map_dumpconf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
name|__unused
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|)
block|{
name|struct
name|g_map_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_slicer
modifier|*
name|gsp
decl_stmt|;
name|gsp
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
name|sc
operator|=
name|gsp
operator|->
name|softc
expr_stmt|;
name|g_slice_dumpconf
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|gp
argument_list|,
name|cp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|indent
operator|==
name|NULL
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" entry %d"
argument_list|,
name|sc
operator|->
name|entry
index|[
name|pp
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" dsize %d"
argument_list|,
name|sc
operator|->
name|dsize
index|[
name|pp
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<entry>%d</entry>\n"
argument_list|,
name|indent
argument_list|,
name|sc
operator|->
name|entry
index|[
name|pp
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<dsize>%d</dsize>\n"
argument_list|,
name|indent
argument_list|,
name|sc
operator|->
name|dsize
index|[
name|pp
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_function
specifier|static
name|struct
name|g_geom
modifier|*
name|g_map_taste
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|insist
parameter_list|)
block|{
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|g_map_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|sectorsize
decl_stmt|,
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|struct
name|map_desc
modifier|*
name|head
decl_stmt|;
name|u_int32_t
name|start
init|=
literal|0
decl_stmt|,
name|end
init|=
literal|0
decl_stmt|,
name|size
init|=
literal|0
decl_stmt|,
name|off
decl_stmt|,
name|readonly
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|at
decl_stmt|;
specifier|const
name|char
modifier|*
name|search
decl_stmt|;
name|int
name|search_start
init|=
literal|0
decl_stmt|,
name|search_end
init|=
literal|0
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|uint32_t
name|offmask
decl_stmt|;
name|u_int
name|blksize
decl_stmt|;
comment|/* NB: flash block size stored as stripesize */
name|off_t
name|offset
decl_stmt|;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"map_taste(%s,%s)"
argument_list|,
name|mp
operator|->
name|name
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|pp
operator|->
name|geom
operator|->
name|class
operator|->
name|name
argument_list|,
name|MAP_CLASS_NAME
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|gp
operator|=
name|g_slice_new
argument_list|(
name|mp
argument_list|,
name|MAP_MAXSLICE
argument_list|,
name|pp
argument_list|,
operator|&
name|cp
argument_list|,
operator|&
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|g_map_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* interpose our access method */
name|sc
operator|->
name|parent_access
operator|=
name|gp
operator|->
name|access
expr_stmt|;
name|gp
operator|->
name|access
operator|=
name|g_map_access
expr_stmt|;
name|sectorsize
operator|=
name|cp
operator|->
name|provider
operator|->
name|sectorsize
expr_stmt|;
name|blksize
operator|=
name|cp
operator|->
name|provider
operator|->
name|stripesize
expr_stmt|;
if|if
condition|(
name|powerof2
argument_list|(
name|cp
operator|->
name|provider
operator|->
name|mediasize
argument_list|)
condition|)
name|offmask
operator|=
name|cp
operator|->
name|provider
operator|->
name|mediasize
operator|-
literal|1
expr_stmt|;
else|else
name|offmask
operator|=
literal|0xffffffff
expr_stmt|;
comment|/* XXX */
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|head
operator|=
name|NULL
expr_stmt|;
name|offset
operator|=
name|cp
operator|->
name|provider
operator|->
name|mediasize
operator|-
name|blksize
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAP_MAXSLICE
condition|;
name|i
operator|++
control|)
block|{
name|search_start
operator|=
name|search_end
operator|=
name|start
operator|=
name|end
operator|=
name|off
operator|=
name|readonly
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|resource_string_value
argument_list|(
literal|"map"
argument_list|,
name|i
argument_list|,
literal|"at"
argument_list|,
operator|&
name|at
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
continue|continue;
comment|/* Check if my provider */
if|if
condition|(
name|strncmp
argument_list|(
name|pp
operator|->
name|name
argument_list|,
name|at
argument_list|,
name|strlen
argument_list|(
name|at
argument_list|)
argument_list|)
condition|)
continue|continue;
name|ret
operator|=
name|resource_string_value
argument_list|(
literal|"map"
argument_list|,
name|i
argument_list|,
literal|"start"
argument_list|,
operator|&
name|search
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|&&
name|strncmp
argument_list|(
name|search
argument_list|,
literal|"search"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uint32_t
name|search_offset
decl_stmt|,
name|search_start
init|=
literal|0
decl_stmt|;
name|uint32_t
name|search_step
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|search_key
decl_stmt|;
name|char
name|key
index|[
literal|255
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
name|ret
operator|=
name|resource_int_value
argument_list|(
literal|"map"
argument_list|,
name|i
argument_list|,
literal|"searchstart"
argument_list|,
operator|&
name|search_start
argument_list|)
expr_stmt|;
name|ret
operator|=
name|resource_int_value
argument_list|(
literal|"map"
argument_list|,
name|i
argument_list|,
literal|"searchstep"
argument_list|,
operator|&
name|search_step
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|search_step
operator|=
literal|0x10000U
expr_stmt|;
name|ret
operator|=
name|resource_string_value
argument_list|(
literal|"map"
argument_list|,
name|i
argument_list|,
literal|"searchkey"
argument_list|,
operator|&
name|search_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
continue|continue;
name|printf
argument_list|(
literal|"GEOM_MAP: searchkey=\"%s\"\n"
argument_list|,
name|search_key
argument_list|)
expr_stmt|;
for|for
control|(
name|search_offset
operator|=
name|search_start
init|;
name|search_offset
operator|<
name|cp
operator|->
name|provider
operator|->
name|mediasize
operator|&&
name|start
operator|==
literal|0
condition|;
name|search_offset
operator|+=
name|search_step
control|)
block|{
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|rounddown
argument_list|(
name|search_offset
argument_list|,
name|sectorsize
argument_list|)
argument_list|,
name|roundup
argument_list|(
name|strlen
argument_list|(
name|search_key
argument_list|)
argument_list|,
name|sectorsize
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Wildcard, replace '.' with byte from data */
name|strncpy
argument_list|(
name|key
argument_list|,
name|search_key
argument_list|,
literal|255
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|255
operator|&&
name|key
index|[
name|c
index|]
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|key
index|[
name|c
index|]
operator|==
literal|'.'
condition|)
name|key
index|[
name|c
index|]
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|buf
operator|+
name|search_offset
operator|%
name|sectorsize
operator|)
operator|)
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|buf
operator|+
name|search_offset
operator|%
name|sectorsize
argument_list|,
name|key
argument_list|,
name|strlen
argument_list|(
name|search_key
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|start
operator|=
name|search_offset
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|start
condition|)
continue|continue;
block|}
else|else
block|{
name|ret
operator|=
name|resource_int_value
argument_list|(
literal|"map"
argument_list|,
name|i
argument_list|,
literal|"start"
argument_list|,
operator|&
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
continue|continue;
block|}
name|ret
operator|=
name|resource_string_value
argument_list|(
literal|"map"
argument_list|,
name|i
argument_list|,
literal|"end"
argument_list|,
operator|&
name|search
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|&&
name|strncmp
argument_list|(
name|search
argument_list|,
literal|"search"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uint32_t
name|search_offset
decl_stmt|,
name|search_start
init|=
literal|0
decl_stmt|,
name|search_step
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|search_key
decl_stmt|;
name|char
name|key
index|[
literal|255
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
name|ret
operator|=
name|resource_int_value
argument_list|(
literal|"map"
argument_list|,
name|i
argument_list|,
literal|"searchstart"
argument_list|,
operator|&
name|search_start
argument_list|)
expr_stmt|;
name|ret
operator|=
name|resource_int_value
argument_list|(
literal|"map"
argument_list|,
name|i
argument_list|,
literal|"searchstep"
argument_list|,
operator|&
name|search_step
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|search_step
operator|=
literal|0x10000U
expr_stmt|;
name|ret
operator|=
name|resource_string_value
argument_list|(
literal|"map"
argument_list|,
name|i
argument_list|,
literal|"searchkey"
argument_list|,
operator|&
name|search_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
continue|continue;
for|for
control|(
name|search_offset
operator|=
name|search_start
init|;
name|search_offset
operator|<
name|cp
operator|->
name|provider
operator|->
name|mediasize
operator|&&
name|end
operator|==
literal|0
condition|;
name|search_offset
operator|+=
name|search_step
control|)
block|{
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|rounddown
argument_list|(
name|search_offset
argument_list|,
name|sectorsize
argument_list|)
argument_list|,
name|roundup
argument_list|(
name|strlen
argument_list|(
name|search_key
argument_list|)
argument_list|,
name|sectorsize
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Wildcard, replace '.' with byte from data */
name|strncpy
argument_list|(
name|key
argument_list|,
name|search_key
argument_list|,
literal|255
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
literal|255
operator|&&
name|key
index|[
name|c
index|]
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|key
index|[
name|c
index|]
operator|==
literal|'.'
condition|)
name|key
index|[
name|c
index|]
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|buf
operator|+
name|search_offset
operator|%
name|sectorsize
operator|)
operator|)
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|buf
operator|+
name|search_offset
operator|%
name|sectorsize
argument_list|,
name|key
argument_list|,
name|strlen
argument_list|(
name|search_key
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|end
operator|=
name|search_offset
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|end
condition|)
continue|continue;
block|}
else|else
block|{
name|ret
operator|=
name|resource_int_value
argument_list|(
literal|"map"
argument_list|,
name|i
argument_list|,
literal|"end"
argument_list|,
operator|&
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
continue|continue;
block|}
name|size
operator|=
name|end
operator|-
name|start
expr_stmt|;
comment|/* end is 0 or size is 0, No MAP - so next */
if|if
condition|(
name|end
operator|==
literal|0
operator|||
name|size
operator|==
literal|0
condition|)
continue|continue;
name|ret
operator|=
name|resource_int_value
argument_list|(
literal|"map"
argument_list|,
name|i
argument_list|,
literal|"offset"
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
name|ret
operator|=
name|resource_int_value
argument_list|(
literal|"map"
argument_list|,
name|i
argument_list|,
literal|"readonly"
argument_list|,
operator|&
name|readonly
argument_list|)
expr_stmt|;
name|ret
operator|=
name|resource_string_value
argument_list|(
literal|"map"
argument_list|,
name|i
argument_list|,
literal|"name"
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
comment|/* No name or error read name */
if|if
condition|(
name|ret
condition|)
continue|continue;
if|if
condition|(
name|off
operator|>
name|size
condition|)
name|printf
argument_list|(
literal|"%s: off(%d)> size(%d) for \"%s\"\n"
argument_list|,
name|__func__
argument_list|,
name|off
argument_list|,
name|size
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_slice_config
argument_list|(
name|gp
argument_list|,
name|i
argument_list|,
name|G_SLICE_CONFIG_SET
argument_list|,
name|start
operator|+
name|off
argument_list|,
name|size
operator|-
name|off
argument_list|,
name|sectorsize
argument_list|,
literal|"map/%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"MAP: %08x-%08x, offset=%08x \"map/%s\"\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|start
argument_list|,
operator|(
name|uint32_t
operator|)
name|size
argument_list|,
operator|(
name|uint32_t
operator|)
name|off
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"%s g_slice_config returns %d for \"%s\"\n"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|sc
operator|->
name|entry
index|[
name|i
index|]
operator|=
name|off
expr_stmt|;
name|sc
operator|->
name|dsize
index|[
name|i
index|]
operator|=
name|size
operator|-
name|off
expr_stmt|;
name|sc
operator|->
name|readonly
index|[
name|i
index|]
operator|=
name|readonly
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|gp
operator|->
name|provider
argument_list|)
condition|)
block|{
name|g_slice_spoiled
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|gp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_map_config
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
specifier|const
name|char
modifier|*
name|verb
parameter_list|)
block|{
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|gp
operator|=
name|gctl_get_geom
argument_list|(
name|req
argument_list|,
name|mp
argument_list|,
literal|"geom"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|==
name|NULL
condition|)
return|return;
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Unknown verb"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|g_class
name|g_map_class
init|=
block|{
operator|.
name|name
operator|=
name|MAP_CLASS_NAME
block|,
operator|.
name|version
operator|=
name|G_VERSION
block|,
operator|.
name|taste
operator|=
name|g_map_taste
block|,
operator|.
name|dumpconf
operator|=
name|g_map_dumpconf
block|,
operator|.
name|ctlreq
operator|=
name|g_map_config
block|,
operator|.
name|ioctl
operator|=
name|g_map_ioctl
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_GEOM_CLASS
argument_list|(
name|g_map_class
argument_list|,
name|g_map
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

