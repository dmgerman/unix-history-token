begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2011 Aleksandr Rybalko<ray@dlink.ua>  *   based on geom_redboot.c  * Copyright (c) 2009 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification.  * 2. Redistributions in binary form must reproduce at minimum a disclaimer  *    similar to the "NO WARRANTY" disclaimer below ("Disclaimer") and any  *    redistribution must be conditioned upon including a substantially  *    similar Disclaimer requirement for further binary redistribution.  *  * NO WARRANTY  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  * LIMITED TO, THE IMPLIED WARRANTIES OF NONINFRINGEMENT, MERCHANTIBILITY  * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL  * THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY,  * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER  * IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom_slice.h>
end_include

begin_define
define|#
directive|define
name|MAP_CLASS_NAME
value|"MAP"
end_define

begin_define
define|#
directive|define
name|MAP_MAXSLICE
value|64
end_define

begin_define
define|#
directive|define
name|MAP_MAX_MARKER_LEN
value|64
end_define

begin_struct
struct|struct
name|g_map_softc
block|{
name|off_t
name|offset
index|[
name|MAP_MAXSLICE
index|]
decl_stmt|;
comment|/* offset in flash */
name|off_t
name|size
index|[
name|MAP_MAXSLICE
index|]
decl_stmt|;
comment|/* image size in bytes */
name|off_t
name|entry
index|[
name|MAP_MAXSLICE
index|]
decl_stmt|;
name|off_t
name|dsize
index|[
name|MAP_MAXSLICE
index|]
decl_stmt|;
name|uint8_t
name|readonly
index|[
name|MAP_MAXSLICE
index|]
decl_stmt|;
name|g_access_t
modifier|*
name|parent_access
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|g_map_access
parameter_list|(
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|dread
parameter_list|,
name|int
name|dwrite
parameter_list|,
name|int
name|dexcl
parameter_list|)
block|{
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_slicer
modifier|*
name|gsp
decl_stmt|;
name|struct
name|g_map_softc
modifier|*
name|sc
decl_stmt|;
name|gp
operator|=
name|pp
operator|->
name|geom
expr_stmt|;
name|gsp
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
name|sc
operator|=
name|gsp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|dwrite
operator|>
literal|0
operator|&&
name|sc
operator|->
name|readonly
index|[
name|pp
operator|->
name|index
index|]
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
return|return
operator|(
name|sc
operator|->
name|parent_access
argument_list|(
name|pp
argument_list|,
name|dread
argument_list|,
name|dwrite
argument_list|,
name|dexcl
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_map_start
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_map_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_slicer
modifier|*
name|gsp
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|pp
operator|=
name|bp
operator|->
name|bio_to
expr_stmt|;
name|idx
operator|=
name|pp
operator|->
name|index
expr_stmt|;
name|gp
operator|=
name|pp
operator|->
name|geom
expr_stmt|;
name|gsp
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
name|sc
operator|=
name|gsp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_GETATTR
condition|)
block|{
if|if
condition|(
name|g_handleattr_int
argument_list|(
name|bp
argument_list|,
name|MAP_CLASS_NAME
literal|"::entry"
argument_list|,
name|sc
operator|->
name|entry
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|g_handleattr_int
argument_list|(
name|bp
argument_list|,
name|MAP_CLASS_NAME
literal|"::dsize"
argument_list|,
name|sc
operator|->
name|dsize
index|[
name|idx
index|]
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_map_dumpconf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
name|__unused
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|)
block|{
name|struct
name|g_map_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_slicer
modifier|*
name|gsp
decl_stmt|;
name|gsp
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
name|sc
operator|=
name|gsp
operator|->
name|softc
expr_stmt|;
name|g_slice_dumpconf
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|gp
argument_list|,
name|cp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|indent
operator|==
name|NULL
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" entry %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|sc
operator|->
name|entry
index|[
name|pp
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" dsize %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|sc
operator|->
name|dsize
index|[
name|pp
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<entry>%jd</entry>\n"
argument_list|,
name|indent
argument_list|,
operator|(
name|intmax_t
operator|)
name|sc
operator|->
name|entry
index|[
name|pp
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<dsize>%jd</dsize>\n"
argument_list|,
name|indent
argument_list|,
operator|(
name|intmax_t
operator|)
name|sc
operator|->
name|dsize
index|[
name|pp
operator|->
name|index
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|find_marker
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|off_t
modifier|*
name|offset
parameter_list|)
block|{
name|off_t
name|search_start
decl_stmt|,
name|search_offset
decl_stmt|,
name|search_step
decl_stmt|;
name|size_t
name|sectorsize
decl_stmt|;
name|uint8_t
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|op
decl_stmt|,
name|key
index|[
name|MAP_MAX_MARKER_LEN
index|]
decl_stmt|,
name|search_key
index|[
name|MAP_MAX_MARKER_LEN
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|c
decl_stmt|;
comment|/* Try convert to numeric first */
operator|*
name|offset
operator|=
name|strtouq
argument_list|(
name|line
argument_list|,
operator|&
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|op
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bzero
argument_list|(
name|search_key
argument_list|,
name|MAP_MAX_MARKER_LEN
argument_list|)
expr_stmt|;
name|sectorsize
operator|=
name|cp
operator|->
name|provider
operator|->
name|sectorsize
expr_stmt|;
name|ret
operator|=
name|sscanf
argument_list|(
name|line
argument_list|,
literal|"search:%qi:%qi:%63c"
argument_list|,
operator|&
name|search_start
argument_list|,
operator|&
name|search_step
argument_list|,
name|search_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|3
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"MAP: search key \"%s\" from 0x%jx, step 0x%jx\n"
argument_list|,
name|search_key
argument_list|,
operator|(
name|intmax_t
operator|)
name|search_start
argument_list|,
operator|(
name|intmax_t
operator|)
name|search_step
argument_list|)
expr_stmt|;
block|}
comment|/* error if search_key is empty */
if|if
condition|(
name|strlen
argument_list|(
name|search_key
argument_list|)
operator|<
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* sscanf successful, and we start marker search */
for|for
control|(
name|search_offset
operator|=
name|search_start
init|;
name|search_offset
operator|<
name|cp
operator|->
name|provider
operator|->
name|mediasize
condition|;
name|search_offset
operator|+=
name|search_step
control|)
block|{
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|rounddown
argument_list|(
name|search_offset
argument_list|,
name|sectorsize
argument_list|)
argument_list|,
name|roundup
argument_list|(
name|strlen
argument_list|(
name|search_key
argument_list|)
argument_list|,
name|sectorsize
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
comment|/* Wildcard, replace '.' with byte from data */
comment|/* TODO: add support wildcard escape '\.' */
name|strncpy
argument_list|(
name|key
argument_list|,
name|search_key
argument_list|,
name|MAP_MAX_MARKER_LEN
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|MAP_MAX_MARKER_LEN
operator|&&
name|key
index|[
name|c
index|]
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|key
index|[
name|c
index|]
operator|==
literal|'.'
condition|)
block|{
name|key
index|[
name|c
index|]
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|buf
operator|+
operator|(
name|search_offset
operator|%
name|sectorsize
operator|)
operator|)
operator|)
index|[
name|c
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|buf
operator|+
name|search_offset
operator|%
name|sectorsize
argument_list|,
name|key
argument_list|,
name|strlen
argument_list|(
name|search_key
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Marker found, so return their offset */
operator|*
name|offset
operator|=
name|search_offset
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* Marker not found */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_map_parse_part
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_map_softc
modifier|*
name|sc
parameter_list|,
name|int
name|i
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|value
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|op
decl_stmt|;
name|off_t
name|start
decl_stmt|,
name|end
decl_stmt|,
name|offset
decl_stmt|,
name|size
decl_stmt|,
name|dsize
decl_stmt|;
name|int
name|readonly
decl_stmt|,
name|ret
decl_stmt|;
comment|/* hint.map.0.at="cfid0" - bind to cfid0 media */
if|if
condition|(
name|resource_string_value
argument_list|(
literal|"map"
argument_list|,
name|i
argument_list|,
literal|"at"
argument_list|,
operator|&
name|value
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Check if this correct provider */
if|if
condition|(
name|strcmp
argument_list|(
name|pp
operator|->
name|name
argument_list|,
name|value
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * hint.map.0.name="uboot" - name of partition, will be available 	 * as "/dev/map/uboot" 	 */
if|if
condition|(
name|resource_string_value
argument_list|(
literal|"map"
argument_list|,
name|i
argument_list|,
literal|"name"
argument_list|,
operator|&
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"MAP: hint.map.%d has no name\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * hint.map.0.start="0x00010000" - partition start at 0x00010000 	 * or hint.map.0.start="search:0x00010000:0x200:marker text" - 	 * search for text "marker text", begin at 0x10000, step 0x200 	 * until we found marker or end of media reached 	 */
if|if
condition|(
name|resource_string_value
argument_list|(
literal|"map"
argument_list|,
name|i
argument_list|,
literal|"start"
argument_list|,
operator|&
name|value
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"MAP: \"%s\" has no start value\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|find_marker
argument_list|(
name|cp
argument_list|,
name|value
argument_list|,
operator|&
name|start
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"MAP: \"%s\" can't parse/use start value\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* like "start" */
if|if
condition|(
name|resource_string_value
argument_list|(
literal|"map"
argument_list|,
name|i
argument_list|,
literal|"end"
argument_list|,
operator|&
name|value
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"MAP: \"%s\" has no end value\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|find_marker
argument_list|(
name|cp
argument_list|,
name|value
argument_list|,
operator|&
name|end
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"MAP: \"%s\" can't parse/use start value\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* variable readonly optional, disable write access */
if|if
condition|(
name|resource_int_value
argument_list|(
literal|"map"
argument_list|,
name|i
argument_list|,
literal|"readonly"
argument_list|,
operator|&
name|readonly
argument_list|)
operator|!=
literal|0
condition|)
name|readonly
operator|=
literal|0
expr_stmt|;
comment|/* offset of partition data, from partition begin */
if|if
condition|(
name|resource_string_value
argument_list|(
literal|"map"
argument_list|,
name|i
argument_list|,
literal|"offset"
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
condition|)
block|{
name|offset
operator|=
name|strtouq
argument_list|(
name|value
argument_list|,
operator|&
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|op
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"MAP: \"%s\" can't parse offset\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* partition data size */
if|if
condition|(
name|resource_string_value
argument_list|(
literal|"map"
argument_list|,
name|i
argument_list|,
literal|"dsize"
argument_list|,
operator|&
name|value
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dsize
operator|=
name|strtouq
argument_list|(
name|value
argument_list|,
operator|&
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|op
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"MAP: \"%s\" can't parse dsize\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|dsize
operator|=
literal|0
expr_stmt|;
block|}
name|size
operator|=
name|end
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|dsize
operator|==
literal|0
condition|)
name|dsize
operator|=
name|size
operator|-
name|offset
expr_stmt|;
comment|/* end is 0 or size is 0, No MAP - so next */
if|if
condition|(
name|end
operator|<
name|start
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"MAP: \"%s\", \"end\" less than "
literal|"\"start\"\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|offset
operator|+
name|dsize
operator|>
name|size
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"MAP: \"%s\", \"dsize\" bigger than "
literal|"partition - offset\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ret
operator|=
name|g_slice_config
argument_list|(
name|gp
argument_list|,
name|i
argument_list|,
name|G_SLICE_CONFIG_SET
argument_list|,
name|start
operator|+
name|offset
argument_list|,
name|dsize
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|sectorsize
argument_list|,
literal|"map/%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"MAP: g_slice_config returns %d for \"%s\"\n"
argument_list|,
name|ret
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"MAP: %lxx%lx, data=%lxx%lx "
literal|"\"/dev/map/%s\"\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|start
argument_list|,
operator|(
name|intmax_t
operator|)
name|size
argument_list|,
operator|(
name|intmax_t
operator|)
name|offset
argument_list|,
operator|(
name|intmax_t
operator|)
name|dsize
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|offset
index|[
name|i
index|]
operator|=
name|start
expr_stmt|;
name|sc
operator|->
name|size
index|[
name|i
index|]
operator|=
name|size
expr_stmt|;
name|sc
operator|->
name|entry
index|[
name|i
index|]
operator|=
name|offset
expr_stmt|;
name|sc
operator|->
name|dsize
index|[
name|i
index|]
operator|=
name|dsize
expr_stmt|;
name|sc
operator|->
name|readonly
index|[
name|i
index|]
operator|=
name|readonly
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|g_geom
modifier|*
name|g_map_taste
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|insist
name|__unused
parameter_list|)
block|{
name|struct
name|g_map_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"map_taste(%s,%s)"
argument_list|,
name|mp
operator|->
name|name
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|pp
operator|->
name|geom
operator|->
name|class
operator|->
name|name
argument_list|,
name|MAP_CLASS_NAME
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|gp
operator|=
name|g_slice_new
argument_list|(
name|mp
argument_list|,
name|MAP_MAXSLICE
argument_list|,
name|pp
argument_list|,
operator|&
name|cp
argument_list|,
operator|&
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|g_map_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* interpose our access method */
name|sc
operator|->
name|parent_access
operator|=
name|gp
operator|->
name|access
expr_stmt|;
name|gp
operator|->
name|access
operator|=
name|g_map_access
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAP_MAXSLICE
condition|;
name|i
operator|++
control|)
name|g_map_parse_part
argument_list|(
name|mp
argument_list|,
name|pp
argument_list|,
name|cp
argument_list|,
name|gp
argument_list|,
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|gp
operator|->
name|provider
argument_list|)
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"MAP: No valid partition found at %s\n"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_slice_spoiled
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|gp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_map_config
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
specifier|const
name|char
modifier|*
name|verb
parameter_list|)
block|{
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|gp
operator|=
name|gctl_get_geom
argument_list|(
name|req
argument_list|,
name|mp
argument_list|,
literal|"geom"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|==
name|NULL
condition|)
return|return;
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Unknown verb"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|g_class
name|g_map_class
init|=
block|{
operator|.
name|name
operator|=
name|MAP_CLASS_NAME
block|,
operator|.
name|version
operator|=
name|G_VERSION
block|,
operator|.
name|taste
operator|=
name|g_map_taste
block|,
operator|.
name|dumpconf
operator|=
name|g_map_dumpconf
block|,
operator|.
name|ctlreq
operator|=
name|g_map_config
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_GEOM_CLASS
argument_list|(
name|g_map_class
argument_list|,
name|g_map
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

