begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015 Netflix, Inc.  *  * Derived from gs_rr.c:  * Copyright (c) 2009-2010 Fabio Checconi  * Copyright (c) 2009-2010 Luigi Rizzo, Universita` di Pisa  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * $Id$  * $FreeBSD$  *  * A simple scheduler that just delays certain transactions by a certain  * amount. We collect all the transactions that are 'done' and put them on  * a queue. The queue is run through every so often and the transactions that  * have taken longer than the threshold delay are completed.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|"gs_scheduler.h"
end_include

begin_comment
comment|/* Useful constants */
end_comment

begin_define
define|#
directive|define
name|BTFRAC_1US
value|18446744073709ULL
end_define

begin_comment
comment|/* 2^64 / 1000000 */
end_comment

begin_comment
comment|/* list of scheduler instances */
end_comment

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|g_scheds
argument_list|,
name|g_delay_softc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Per device descriptor, holding the Round Robin list of queues  * accessing the disk, a reference to the geom, and the timer.  */
end_comment

begin_struct
struct|struct
name|g_delay_softc
block|{
name|struct
name|g_geom
modifier|*
name|sc_geom
decl_stmt|;
name|struct
name|bio_queue_head
name|sc_bioq
decl_stmt|;
comment|/* queue of pending requests */
name|struct
name|callout
name|sc_wait
decl_stmt|;
comment|/* timer for completing with delays */
comment|/* Statistics */
name|int
name|sc_in_flight
decl_stmt|;
comment|/* requests in the driver */
block|}
struct|;
end_struct

begin_comment
comment|/*  * parameters, config and stats  */
end_comment

begin_struct
struct|struct
name|g_delay_params
block|{
name|uint64_t
name|io
decl_stmt|;
name|int
name|bypass
decl_stmt|;
comment|/* bypass scheduling */
name|int
name|units
decl_stmt|;
comment|/* how many instances */
name|int
name|latency
decl_stmt|;
comment|/* How big a latncy are hoping for */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|g_delay_params
name|me
init|=
block|{
operator|.
name|bypass
operator|=
literal|0
block|,
operator|.
name|units
operator|=
literal|0
block|,
operator|.
name|latency
operator|=
literal|0
block|,
operator|.
name|io
operator|=
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|g_delay_params
modifier|*
name|gs_delay_me
init|=
operator|&
name|me
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_kern_geom_sched
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_kern_geom_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|delay
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"GEOM_SCHED DELAY stuff"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_geom_sched_delay
argument_list|,
name|OID_AUTO
argument_list|,
name|bypass
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|me
operator|.
name|bypass
argument_list|,
literal|0
argument_list|,
literal|"Scheduler bypass"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_geom_sched_delay
argument_list|,
name|OID_AUTO
argument_list|,
name|units
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|me
operator|.
name|units
argument_list|,
literal|0
argument_list|,
literal|"Scheduler instances"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_geom_sched_delay
argument_list|,
name|OID_AUTO
argument_list|,
name|latency
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|me
operator|.
name|latency
argument_list|,
literal|0
argument_list|,
literal|"Minimum latency for requests, in microseconds (1/hz resolution)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_QUAD
argument_list|(
name|_kern_geom_sched_delay
argument_list|,
name|OID_AUTO
argument_list|,
name|io
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|me
operator|.
name|io
argument_list|,
literal|0
argument_list|,
literal|"I/Os delayed\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|g_delay_init_class
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_delay_fini_class
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  * Called on a request arrival, timeout or completion.  * Try to serve a request among those queued.  */
end_comment

begin_function
specifier|static
name|struct
name|bio
modifier|*
name|g_delay_next
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|g_delay_softc
modifier|*
name|sc
init|=
name|data
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|struct
name|bintime
name|bt
decl_stmt|;
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|sc
operator|->
name|sc_bioq
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * If the time isn't yet ripe for this bp to be let loose, 	 * then the time isn't ripe for any of its friends either 	 * since we insert in-order. Terminate if the bio hasn't 	 * aged appropriately. Note that there's pathology here 	 * such that we may be up to one tick early in releasing 	 * this I/O. We could implement this up to a tick late too 	 * but choose not to. 	 */
name|getbinuptime
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
comment|/* BIO's bio_t0 is uptime */
if|if
condition|(
name|bintime_cmp
argument_list|(
operator|&
name|bp
operator|->
name|bio_t0
argument_list|,
operator|&
name|bt
argument_list|,
operator|>
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|me
operator|.
name|io
operator|++
expr_stmt|;
comment|/* 	 * The bp has mellowed enough, let it through and update stats. 	 * If there's others, we'll catch them next time we get called. 	 */
name|sc
operator|->
name|sc_in_flight
operator|++
expr_stmt|;
name|bp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|sc
operator|->
name|sc_bioq
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when a real request for disk I/O arrives.  * Locate the queue associated with the client.  * If the queue is the one we are anticipating for, reset its timeout;  * if the queue is not in the round robin list, insert it in the list.  * On any error, do not queue the request and return -1, the caller  * will take care of this request.  */
end_comment

begin_function
specifier|static
name|int
name|g_delay_start
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_delay_softc
modifier|*
name|sc
init|=
name|data
decl_stmt|;
if|if
condition|(
name|me
operator|.
name|bypass
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* bypass the scheduler */
name|bp
operator|->
name|bio_caller1
operator|=
name|sc
expr_stmt|;
name|getbinuptime
argument_list|(
operator|&
name|bp
operator|->
name|bio_t0
argument_list|)
expr_stmt|;
comment|/* BIO's bio_t0 is uptime */
name|bintime_addx
argument_list|(
operator|&
name|bp
operator|->
name|bio_t0
argument_list|,
name|BTFRAC_1US
operator|*
name|me
operator|.
name|latency
argument_list|)
expr_stmt|;
comment|/* 	 * Keep the I/Os ordered. Lower layers will reorder as we release them down. 	 * We rely on this in g_delay_next() so that we delay all things equally. Even 	 * if we move to multiple queues to push stuff down the stack, we'll want to 	 * insert in order and let the lower layers do whatever reordering they want. 	 */
name|bioq_insert_tail
argument_list|(
operator|&
name|sc
operator|->
name|sc_bioq
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_delay_timeout
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|g_delay_softc
modifier|*
name|sc
init|=
name|data
decl_stmt|;
name|g_sched_lock
argument_list|(
name|sc
operator|->
name|sc_geom
argument_list|)
expr_stmt|;
name|g_sched_dispatch
argument_list|(
name|sc
operator|->
name|sc_geom
argument_list|)
expr_stmt|;
name|g_sched_unlock
argument_list|(
name|sc
operator|->
name|sc_geom
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_wait
argument_list|,
literal|1
argument_list|,
name|g_delay_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Module glue: allocate descriptor, initialize its fields.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|g_delay_init
parameter_list|(
name|struct
name|g_geom
modifier|*
name|geom
parameter_list|)
block|{
name|struct
name|g_delay_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|sc
argument_list|,
name|M_GEOM_SCHED
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_geom
operator|=
name|geom
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_bioq
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_wait
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_wait
argument_list|,
literal|1
argument_list|,
name|g_delay_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|me
operator|.
name|units
operator|++
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Module glue -- drain the callout structure, destroy the  * hash table and its element, and free the descriptor.  */
end_comment

begin_function
specifier|static
name|void
name|g_delay_fini
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|g_delay_softc
modifier|*
name|sc
init|=
name|data
decl_stmt|;
comment|/* We're force drained before getting here */
comment|/* Kick out timers */
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_wait
argument_list|)
expr_stmt|;
name|me
operator|.
name|units
operator|--
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_GEOM_SCHED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when the request under service terminates.  * Start the anticipation timer if needed.  */
end_comment

begin_function
specifier|static
name|void
name|g_delay_done
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_delay_softc
modifier|*
name|sc
init|=
name|data
decl_stmt|;
name|sc
operator|->
name|sc_in_flight
operator|--
expr_stmt|;
name|g_sched_dispatch
argument_list|(
name|sc
operator|->
name|sc_geom
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_delay_dumpconf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|)
block|{ }
end_function

begin_decl_stmt
specifier|static
name|struct
name|g_gsched
name|g_delay
init|=
block|{
operator|.
name|gs_name
operator|=
literal|"delay"
block|,
operator|.
name|gs_priv_size
operator|=
literal|0
block|,
operator|.
name|gs_init
operator|=
name|g_delay_init
block|,
operator|.
name|gs_fini
operator|=
name|g_delay_fini
block|,
operator|.
name|gs_start
operator|=
name|g_delay_start
block|,
operator|.
name|gs_done
operator|=
name|g_delay_done
block|,
operator|.
name|gs_next
operator|=
name|g_delay_next
block|,
operator|.
name|gs_dumpconf
operator|=
name|g_delay_dumpconf
block|,
operator|.
name|gs_init_class
operator|=
name|g_delay_init_class
block|,
operator|.
name|gs_fini_class
operator|=
name|g_delay_fini_class
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_GSCHED_MODULE
argument_list|(
name|delay
argument_list|,
operator|&
name|g_delay
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

