begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2010 Fabio Checconi  * Copyright (c) 2009-2010 Luigi Rizzo, Universita` di Pisa  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * $Id$  * $FreeBSD$  *  * Main control module for geom-based disk schedulers ('sched').  *  * USER VIEW  * A 'sched' node is typically inserted transparently between  * an existing provider pp and its original geom gp  *  *	[pp --> gp  ..]  *  * using the command "geom sched insert<provider>" and  * resulting in the following topology  *  *	[pp --> sched_gp --> cp]   [new_pp --> gp ... ]  *  * Deletion "geom sched destroy<provider>.sched." restores the  * original chain. The normal "geom sched create<provide>"  * is also supported.  *  * INTERNALS  * Internally, the 'sched' uses the following data structures  *  *   geom{}         g_sched_softc{}      g_gsched{}  * +----------+    +---------------+   +-------------+  * |  softc *-|--->| sc_gsched   *-|-->|  gs_init    |  * |  ...     |    |               |   |  gs_fini    |  * |          |    | [ hash table] |   |  gs_start   |  * +----------+    |               |   |  ...        |  *                 |               |   +-------------+  *                 |               |  *                 |               |     g_*_softc{}  *                 |               |   +-------------+  *                 | sc_data     *-|-->|             |  *                 +---------------+   |  algorithm- |  *                                     |  specific   |  *                                     +-------------+  *  * A g_sched_softc{} is created with a "geom sched insert" call.  * In turn this instantiates a specific scheduling algorithm,  * which sets sc_gsched to point to the algorithm callbacks,  * and calls gs_init() to create the g_*_softc{} .  * The other callbacks (gs_start, gs_next, ...) are invoked  * as needed   *  * g_sched_softc{} is defined in g_sched.h and mostly used here;  * g_gsched{}, and the gs_callbacks, are documented in gs_scheduler.h;  * g_*_softc{} is defined/implemented by each algorithm (gs_*.c)  *  * DATA MOVING  * When a bio is received on the provider, it goes to the  * g_sched_start() which calls gs_start() to initially queue it;  * then we call g_sched_dispatch() that loops around gs_next()  * to select zero or more bio's to be sent downstream.  *  * g_sched_dispatch() can also be called as a result of a timeout,  * e.g. when doing anticipation or pacing requests.  *  * When a bio comes back, it goes to g_sched_done() which in turn  * calls gs_done(). The latter does any necessary housekeeping in  * the scheduling algorithm, and may decide to call g_sched_dispatch()  * to send more bio's downstream.  *  * If an algorithm needs per-flow queues, these are created  * calling gs_init_class() and destroyed with gs_fini_class(),  * and they are also inserted in the hash table implemented in  * the g_sched_softc{}  *  * If an algorithm is replaced, or a transparently-inserted node is  * removed with "geom sched destroy", we need to remove all references  * to the g_*_softc{} and g_sched_softc from the bio's still in  * the scheduler. g_sched_forced_dispatch() helps doing this.  * XXX need to explain better.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/hash.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_comment
comment|/* we access curthread */
end_comment

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|"gs_scheduler.h"
end_include

begin_include
include|#
directive|include
file|"g_sched.h"
end_include

begin_comment
comment|/* geom hooks */
end_comment

begin_comment
comment|/*  * Size of the per-geom hash table storing traffic classes.  * We may decide to change it at a later time, it has no ABI  * implications as it is only used for run-time allocations.  */
end_comment

begin_define
define|#
directive|define
name|G_SCHED_HASH_SIZE
value|32
end_define

begin_function_decl
specifier|static
name|int
name|g_sched_destroy
parameter_list|(
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|boolean_t
name|force
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_sched_destroy_geom
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_sched_config
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
specifier|const
name|char
modifier|*
name|verb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|g_geom
modifier|*
name|g_sched_taste
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|flags
name|__unused
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_sched_dumpconf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_sched_init
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_sched_fini
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_sched_ioctl
parameter_list|(
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|g_class
name|g_sched_class
init|=
block|{
operator|.
name|name
operator|=
name|G_SCHED_CLASS_NAME
block|,
operator|.
name|version
operator|=
name|G_VERSION
block|,
operator|.
name|ctlreq
operator|=
name|g_sched_config
block|,
operator|.
name|taste
operator|=
name|g_sched_taste
block|,
operator|.
name|destroy_geom
operator|=
name|g_sched_destroy_geom
block|,
operator|.
name|init
operator|=
name|g_sched_init
block|,
operator|.
name|ioctl
operator|=
name|g_sched_ioctl
block|,
operator|.
name|fini
operator|=
name|g_sched_fini
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_GEOM_SCHED
argument_list|,
literal|"GEOM_SCHED"
argument_list|,
literal|"Geom schedulers data structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Global variables describing the state of the geom_sched module.  * There is only one static instance of this structure.  */
end_comment

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|gs_list
argument_list|,
name|g_gsched
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* type, link field */
end_comment

begin_struct
struct|struct
name|geom_sched_vars
block|{
name|struct
name|mtx
name|gs_mtx
decl_stmt|;
name|struct
name|gs_list
name|gs_scheds
decl_stmt|;
comment|/* list of algorithms */
name|u_int
name|gs_debug
decl_stmt|;
name|u_int
name|gs_sched_count
decl_stmt|;
comment|/* how many algorithms ? */
name|u_int
name|gs_patched
decl_stmt|;
comment|/* g_io_request was patched */
name|u_int
name|gs_initialized
decl_stmt|;
name|u_int
name|gs_expire_secs
decl_stmt|;
comment|/* expiration of hash entries */
name|struct
name|bio_queue_head
name|gs_pending
decl_stmt|;
name|u_int
name|gs_npending
decl_stmt|;
comment|/* The following are for stats, usually protected by gs_mtx. */
name|u_long
name|gs_requests
decl_stmt|;
comment|/* total requests */
name|u_long
name|gs_done
decl_stmt|;
comment|/* total done */
name|u_int
name|gs_in_flight
decl_stmt|;
comment|/* requests in flight */
name|u_int
name|gs_writes_in_flight
decl_stmt|;
name|u_int
name|gs_bytes_in_flight
decl_stmt|;
name|u_int
name|gs_write_bytes_in_flight
decl_stmt|;
name|char
name|gs_names
index|[
literal|256
index|]
decl_stmt|;
comment|/* names of schedulers */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|geom_sched_vars
name|me
init|=
block|{
operator|.
name|gs_expire_secs
operator|=
literal|10
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_kern_geom
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern_geom
argument_list|,
name|OID_AUTO
argument_list|,
name|sched
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"GEOM_SCHED stuff"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_geom_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|in_flight_wb
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|me
operator|.
name|gs_write_bytes_in_flight
argument_list|,
literal|0
argument_list|,
literal|"Write bytes in flight"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_geom_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|in_flight_b
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|me
operator|.
name|gs_bytes_in_flight
argument_list|,
literal|0
argument_list|,
literal|"Bytes in flight"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|in_flight_w
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|me
operator|.
name|gs_writes_in_flight
argument_list|,
literal|0
argument_list|,
literal|"Write Requests in flight"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|in_flight
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|me
operator|.
name|gs_in_flight
argument_list|,
literal|0
argument_list|,
literal|"Requests in flight"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_kern_geom_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|done
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|me
operator|.
name|gs_done
argument_list|,
literal|0
argument_list|,
literal|"Total done"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_kern_geom_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|requests
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|me
operator|.
name|gs_requests
argument_list|,
literal|0
argument_list|,
literal|"Total requests"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_STRING
argument_list|(
name|_kern_geom_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|algorithms
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|me
operator|.
name|gs_names
argument_list|,
literal|0
argument_list|,
literal|"Algorithm names"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|alg_count
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|me
operator|.
name|gs_sched_count
argument_list|,
literal|0
argument_list|,
literal|"Number of algorithms"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|me
operator|.
name|gs_debug
argument_list|,
literal|0
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|expire_secs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|me
operator|.
name|gs_expire_secs
argument_list|,
literal|0
argument_list|,
literal|"Expire time in seconds"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * g_sched calls the scheduler algorithms with this lock held.  * The locking functions are exposed so the scheduler algorithms can also  * protect themselves e.g. when running a callout handler.  */
end_comment

begin_function
name|void
name|g_sched_lock
parameter_list|(
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|)
block|{
name|struct
name|g_sched_softc
modifier|*
name|sc
init|=
name|gp
operator|->
name|softc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|g_sched_unlock
parameter_list|(
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|)
block|{
name|struct
name|g_sched_softc
modifier|*
name|sc
init|=
name|gp
operator|->
name|softc
decl_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Support functions to handle references to the module,  * which are coming from devices using this scheduler.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|g_gsched_ref
parameter_list|(
name|struct
name|g_gsched
modifier|*
name|gsp
parameter_list|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|gsp
operator|->
name|gs_refs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|g_gsched_unref
parameter_list|(
name|struct
name|g_gsched
modifier|*
name|gsp
parameter_list|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|gsp
operator|->
name|gs_refs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the stats when this request is done.  */
end_comment

begin_function
specifier|static
name|void
name|g_sched_update_stats
parameter_list|(
name|struct
name|bio
modifier|*
name|bio
parameter_list|)
block|{
name|me
operator|.
name|gs_done
operator|++
expr_stmt|;
name|me
operator|.
name|gs_in_flight
operator|--
expr_stmt|;
name|me
operator|.
name|gs_bytes_in_flight
operator|-=
name|bio
operator|->
name|bio_length
expr_stmt|;
if|if
condition|(
name|bio
operator|->
name|bio_cmd
operator|&
name|BIO_WRITE
condition|)
block|{
name|me
operator|.
name|gs_writes_in_flight
operator|--
expr_stmt|;
name|me
operator|.
name|gs_write_bytes_in_flight
operator|-=
name|bio
operator|->
name|bio_length
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Dispatch any pending request.  */
end_comment

begin_function
specifier|static
name|void
name|g_sched_forced_dispatch
parameter_list|(
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|)
block|{
name|struct
name|g_sched_softc
modifier|*
name|sc
init|=
name|gp
operator|->
name|softc
decl_stmt|;
name|struct
name|g_gsched
modifier|*
name|gsp
init|=
name|sc
operator|->
name|sc_gsched
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|KASSERT
argument_list|(
name|mtx_owned
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
argument_list|,
operator|(
literal|"sc_mtx not owned during forced dispatch"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|gsp
operator|->
name|gs_next
argument_list|(
name|sc
operator|->
name|sc_data
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|g_io_request
argument_list|(
name|bp
argument_list|,
name|LIST_FIRST
argument_list|(
operator|&
name|gp
operator|->
name|consumer
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The main dispatch loop, called either here after the start  * routine, or by scheduling algorithms when they receive a timeout  * or a 'done' notification.  Does not share code with the forced  * dispatch path, since the gs_done() callback can call us.  */
end_comment

begin_function
name|void
name|g_sched_dispatch
parameter_list|(
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|)
block|{
name|struct
name|g_sched_softc
modifier|*
name|sc
init|=
name|gp
operator|->
name|softc
decl_stmt|;
name|struct
name|g_gsched
modifier|*
name|gsp
init|=
name|sc
operator|->
name|sc_gsched
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|KASSERT
argument_list|(
name|mtx_owned
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
argument_list|,
operator|(
literal|"sc_mtx not owned during dispatch"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_SCHED_FLUSHING
operator|)
condition|)
return|return;
while|while
condition|(
operator|(
name|bp
operator|=
name|gsp
operator|->
name|gs_next
argument_list|(
name|sc
operator|->
name|sc_data
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|g_io_request
argument_list|(
name|bp
argument_list|,
name|LIST_FIRST
argument_list|(
operator|&
name|gp
operator|->
name|consumer
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Recent (8.0 and above) versions of FreeBSD have support to  * register classifiers of disk requests. The classifier is  * invoked by g_io_request(), and stores the information into  * bp->bio_classifier1.  *  * Support for older versions, which is left here only for  * documentation purposes, relies on two hacks:  * 1. classification info is written into the bio_caller1  *    field of the topmost node in the bio chain. This field  *    is rarely used, but this module is incompatible with  *    those that use bio_caller1 for other purposes,  *    such as ZFS and gjournal;  * 2. g_io_request() is patched in-memory when the module is  *    loaded, so that the function calls a classifier as its  *    first thing. g_io_request() is restored when the module  *    is unloaded. This functionality is only supported for  *    x86 and amd64, other architectures need source code changes.  */
end_comment

begin_comment
comment|/*  * Lookup the identity of the issuer of the original request.  * In the current implementation we use the curthread of the  * issuer, but different mechanisms may be implemented later  * so we do not make assumptions on the return value which for  * us is just an opaque identifier.  */
end_comment

begin_function
specifier|static
specifier|inline
name|u_long
name|g_sched_classify
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|800098
comment|/* we have classifier fields in the struct bio */
define|#
directive|define
name|HAVE_BIO_CLASSIFIER
return|return
operator|(
operator|(
name|u_long
operator|)
name|bp
operator|->
name|bio_classifier1
operator|)
return|;
else|#
directive|else
warning|#
directive|warning
warning|old version!!!
while|while
condition|(
name|bp
operator|->
name|bio_parent
operator|!=
name|NULL
condition|)
name|bp
operator|=
name|bp
operator|->
name|bio_parent
expr_stmt|;
return|return
operator|(
operator|(
name|u_long
operator|)
name|bp
operator|->
name|bio_caller1
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return the hash chain for the given key. */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|g_hash
modifier|*
name|g_sched_hash
parameter_list|(
name|struct
name|g_sched_softc
modifier|*
name|sc
parameter_list|,
name|u_long
name|key
parameter_list|)
block|{
return|return
operator|(
operator|&
name|sc
operator|->
name|sc_hash
index|[
name|key
operator|&
name|sc
operator|->
name|sc_mask
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Helper function for the children classes, which takes  * a geom and a bio and returns the private descriptor  * associated to the request.  This involves fetching  * the classification field and [al]locating the  * corresponding entry in the hash table.  */
end_comment

begin_function
name|void
modifier|*
name|g_sched_get_class
parameter_list|(
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_sched_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_sched_class
modifier|*
name|gsc
decl_stmt|;
name|struct
name|g_gsched
modifier|*
name|gsp
decl_stmt|;
name|struct
name|g_hash
modifier|*
name|bucket
decl_stmt|;
name|u_long
name|key
decl_stmt|;
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
name|key
operator|=
name|g_sched_classify
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|g_sched_hash
argument_list|(
name|sc
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|gsc
argument_list|,
argument|bucket
argument_list|,
argument|gsc_clist
argument_list|)
block|{
if|if
condition|(
name|key
operator|==
name|gsc
operator|->
name|gsc_key
condition|)
block|{
name|gsc
operator|->
name|gsc_refs
operator|++
expr_stmt|;
return|return
operator|(
name|gsc
operator|->
name|gsc_priv
operator|)
return|;
block|}
block|}
name|gsp
operator|=
name|sc
operator|->
name|sc_gsched
expr_stmt|;
name|gsc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|gsc
argument_list|)
operator|+
name|gsp
operator|->
name|gs_priv_size
argument_list|,
name|M_GEOM_SCHED
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gsc
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|gsp
operator|->
name|gs_init_class
argument_list|(
name|sc
operator|->
name|sc_data
argument_list|,
name|gsc
operator|->
name|gsc_priv
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|gsc
argument_list|,
name|M_GEOM_SCHED
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|gsc
operator|->
name|gsc_refs
operator|=
literal|2
expr_stmt|;
comment|/* 1 for the hash table, 1 for the caller. */
name|gsc
operator|->
name|gsc_key
operator|=
name|key
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|bucket
argument_list|,
name|gsc
argument_list|,
name|gsc_clist
argument_list|)
expr_stmt|;
name|gsc
operator|->
name|gsc_expire
operator|=
name|ticks
operator|+
name|me
operator|.
name|gs_expire_secs
operator|*
name|hz
expr_stmt|;
return|return
operator|(
name|gsc
operator|->
name|gsc_priv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a reference to the per-client descriptor,  */
end_comment

begin_function
name|void
name|g_sched_put_class
parameter_list|(
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|g_sched_class
modifier|*
name|gsc
decl_stmt|;
name|struct
name|g_sched_softc
modifier|*
name|sc
decl_stmt|;
name|gsc
operator|=
name|g_sched_priv2class
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|gsc
operator|->
name|gsc_expire
operator|=
name|ticks
operator|+
name|me
operator|.
name|gs_expire_secs
operator|*
name|hz
expr_stmt|;
if|if
condition|(
operator|--
name|gsc
operator|->
name|gsc_refs
operator|>
literal|0
condition|)
return|return;
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
name|sc
operator|->
name|sc_gsched
operator|->
name|gs_fini_class
argument_list|(
name|sc
operator|->
name|sc_data
argument_list|,
name|priv
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|gsc
argument_list|,
name|gsc_clist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|gsc
argument_list|,
name|M_GEOM_SCHED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_sched_hash_fini
parameter_list|(
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_hash
modifier|*
name|hp
parameter_list|,
name|u_long
name|mask
parameter_list|,
name|struct
name|g_gsched
modifier|*
name|gsp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|g_sched_class
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|hp
condition|)
return|return;
if|if
condition|(
name|data
operator|&&
name|gsp
operator|->
name|gs_hash_unref
condition|)
name|gsp
operator|->
name|gs_hash_unref
argument_list|(
name|data
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|G_SCHED_HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH_SAFE
argument_list|(
argument|cp
argument_list|,
argument|&hp[i]
argument_list|,
argument|gsc_clist
argument_list|,
argument|cp2
argument_list|)
name|g_sched_put_class
argument_list|(
name|gp
argument_list|,
name|cp
operator|->
name|gsc_priv
argument_list|)
expr_stmt|;
block|}
name|hashdestroy
argument_list|(
name|hp
argument_list|,
name|M_GEOM_SCHED
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|g_hash
modifier|*
name|g_sched_hash_init
parameter_list|(
name|struct
name|g_gsched
modifier|*
name|gsp
parameter_list|,
name|u_long
modifier|*
name|mask
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|g_hash
modifier|*
name|hash
decl_stmt|;
if|if
condition|(
name|gsp
operator|->
name|gs_priv_size
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|hash
operator|=
name|hashinit_flags
argument_list|(
name|G_SCHED_HASH_SIZE
argument_list|,
name|M_GEOM_SCHED
argument_list|,
name|mask
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|hash
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_sched_flush_classes
parameter_list|(
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|)
block|{
name|struct
name|g_sched_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_sched_class
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_hash
operator|||
name|ticks
operator|-
name|sc
operator|->
name|sc_flush_ticks
operator|<=
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|G_SCHED_HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH_SAFE
argument_list|(
argument|cp
argument_list|,
argument|&sc->sc_hash[i]
argument_list|,
argument|gsc_clist
argument_list|,
argument|cp2
argument_list|)
block|{
if|if
condition|(
name|cp
operator|->
name|gsc_refs
operator|==
literal|1
operator|&&
name|ticks
operator|-
name|cp
operator|->
name|gsc_expire
operator|>
literal|0
condition|)
name|g_sched_put_class
argument_list|(
name|gp
argument_list|,
name|cp
operator|->
name|gsc_priv
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|sc_flush_ticks
operator|=
name|ticks
operator|+
name|me
operator|.
name|gs_expire_secs
operator|*
name|hz
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wait for the completion of any outstanding request.  To ensure  * that this does not take forever the caller has to make sure that  * no new request enter the scehduler before calling us.  *  * Must be called with the gp mutex held and topology locked.  */
end_comment

begin_function
specifier|static
name|int
name|g_sched_wait_pending
parameter_list|(
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|)
block|{
name|struct
name|g_sched_softc
modifier|*
name|sc
init|=
name|gp
operator|->
name|softc
decl_stmt|;
name|int
name|endticks
init|=
name|ticks
operator|+
name|hz
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|sc_pending
operator|&&
name|endticks
operator|-
name|ticks
operator|>=
literal|0
condition|)
name|msleep
argument_list|(
name|gp
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|,
literal|"sched_wait_pending"
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|->
name|sc_pending
condition|?
name|ETIMEDOUT
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_sched_remove_locked
parameter_list|(
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_gsched
modifier|*
name|gsp
parameter_list|)
block|{
name|struct
name|g_sched_softc
modifier|*
name|sc
init|=
name|gp
operator|->
name|softc
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Set the flushing flag: new bios will not enter the scheduler. */
name|sc
operator|->
name|sc_flags
operator||=
name|G_SCHED_FLUSHING
expr_stmt|;
name|g_sched_forced_dispatch
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_sched_wait_pending
argument_list|(
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
comment|/* No more requests pending or in flight from the old gsp. */
name|g_sched_hash_fini
argument_list|(
name|gp
argument_list|,
name|sc
operator|->
name|sc_hash
argument_list|,
name|sc
operator|->
name|sc_mask
argument_list|,
name|gsp
argument_list|,
name|sc
operator|->
name|sc_data
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_hash
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Avoid deadlock here by releasing the gp mutex and reacquiring 	 * it once done.  It should be safe, since no reconfiguration or 	 * destruction can take place due to the geom topology lock; no 	 * new request can use the current sc_data since we flagged the 	 * geom as being flushed. 	 */
name|g_sched_unlock
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|gsp
operator|->
name|gs_fini
argument_list|(
name|sc
operator|->
name|sc_data
argument_list|)
expr_stmt|;
name|g_sched_lock
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_gsched
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_data
operator|=
name|NULL
expr_stmt|;
name|g_gsched_unref
argument_list|(
name|gsp
argument_list|)
expr_stmt|;
name|failed
label|:
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|G_SCHED_FLUSHING
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_sched_remove
parameter_list|(
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_gsched
modifier|*
name|gsp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|g_sched_lock
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_sched_remove_locked
argument_list|(
name|gp
argument_list|,
name|gsp
argument_list|)
expr_stmt|;
comment|/* gsp is surely non-null */
name|g_sched_unlock
argument_list|(
name|gp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Support function for create/taste -- locate the desired  * algorithm and grab a reference to it.  */
end_comment

begin_function
specifier|static
name|struct
name|g_gsched
modifier|*
name|g_gsched_find
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|g_gsched
modifier|*
name|gsp
init|=
name|NULL
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|me
operator|.
name|gs_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|gsp
argument_list|,
argument|&me.gs_scheds
argument_list|,
argument|glist
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|gsp
operator|->
name|gs_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|g_gsched_ref
argument_list|(
name|gsp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|me
operator|.
name|gs_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|gsp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Rebuild the list of scheduler names.  * To be called with me.gs_mtx lock held.  */
end_comment

begin_function
specifier|static
name|void
name|g_gsched_build_names
parameter_list|(
name|struct
name|g_gsched
modifier|*
name|gsp
parameter_list|)
block|{
name|int
name|pos
decl_stmt|,
name|l
decl_stmt|;
name|struct
name|g_gsched
modifier|*
name|cur
decl_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|cur
argument_list|,
argument|&me.gs_scheds
argument_list|,
argument|glist
argument_list|)
block|{
name|l
operator|=
name|strlen
argument_list|(
name|cur
operator|->
name|gs_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|+
name|pos
operator|+
literal|1
operator|+
literal|1
operator|<
sizeof|sizeof
argument_list|(
name|me
operator|.
name|gs_names
argument_list|)
condition|)
block|{
if|if
condition|(
name|pos
operator|!=
literal|0
condition|)
name|me
operator|.
name|gs_names
index|[
name|pos
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
name|strcpy
argument_list|(
name|me
operator|.
name|gs_names
operator|+
name|pos
argument_list|,
name|cur
operator|->
name|gs_name
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|l
expr_stmt|;
block|}
block|}
name|me
operator|.
name|gs_names
index|[
name|pos
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Register or unregister individual scheduling algorithms.  */
end_comment

begin_function
specifier|static
name|int
name|g_gsched_register
parameter_list|(
name|struct
name|g_gsched
modifier|*
name|gsp
parameter_list|)
block|{
name|struct
name|g_gsched
modifier|*
name|cur
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|me
operator|.
name|gs_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|cur
argument_list|,
argument|&me.gs_scheds
argument_list|,
argument|glist
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|gsp
operator|->
name|gs_name
argument_list|,
name|cur
operator|->
name|gs_name
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|cur
operator|!=
name|NULL
condition|)
block|{
name|G_SCHED_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"A scheduler named %s already"
literal|"exists."
argument_list|,
name|gsp
operator|->
name|gs_name
argument_list|)
expr_stmt|;
name|error
operator|=
name|EEXIST
expr_stmt|;
block|}
else|else
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|me
operator|.
name|gs_scheds
argument_list|,
name|gsp
argument_list|,
name|glist
argument_list|)
expr_stmt|;
name|gsp
operator|->
name|gs_refs
operator|=
literal|1
expr_stmt|;
name|me
operator|.
name|gs_sched_count
operator|++
expr_stmt|;
name|g_gsched_build_names
argument_list|(
name|gsp
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|me
operator|.
name|gs_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|g_gsched_unregparm
block|{
name|struct
name|g_gsched
modifier|*
name|gup_gsp
decl_stmt|;
name|int
name|gup_error
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|g_gsched_unregister
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|g_gsched_unregparm
modifier|*
name|parm
init|=
name|arg
decl_stmt|;
name|struct
name|g_gsched
modifier|*
name|gsp
init|=
name|parm
operator|->
name|gup_gsp
decl_stmt|,
modifier|*
name|cur
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|struct
name|g_sched_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|,
modifier|*
name|gp_tmp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|parm
operator|->
name|gup_error
operator|=
literal|0
expr_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
if|if
condition|(
name|flag
operator|==
name|EV_CANCEL
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|me
operator|.
name|gs_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|gp
argument_list|,
argument|&g_sched_class.geom
argument_list|,
argument|geom
argument_list|,
argument|gp_tmp
argument_list|)
block|{
if|if
condition|(
name|gp
operator|->
name|class
operator|!=
operator|&
name|g_sched_class
condition|)
continue|continue;
comment|/* Should not happen. */
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_gsched
operator|==
name|gsp
condition|)
block|{
name|error
operator|=
name|g_sched_remove
argument_list|(
name|gp
argument_list|,
name|gsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|failed
goto|;
block|}
block|}
name|LIST_FOREACH_SAFE
argument_list|(
argument|cur
argument_list|,
argument|&me.gs_scheds
argument_list|,
argument|glist
argument_list|,
argument|tmp
argument_list|)
block|{
if|if
condition|(
name|cur
operator|!=
name|gsp
condition|)
continue|continue;
if|if
condition|(
name|gsp
operator|->
name|gs_refs
operator|!=
literal|1
condition|)
block|{
name|G_SCHED_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"%s still in use."
argument_list|,
name|gsp
operator|->
name|gs_name
argument_list|)
expr_stmt|;
name|parm
operator|->
name|gup_error
operator|=
name|EBUSY
expr_stmt|;
block|}
else|else
block|{
name|LIST_REMOVE
argument_list|(
name|gsp
argument_list|,
name|glist
argument_list|)
expr_stmt|;
name|me
operator|.
name|gs_sched_count
operator|--
expr_stmt|;
name|g_gsched_build_names
argument_list|(
name|gsp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
block|{
name|G_SCHED_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"%s not registered."
argument_list|,
name|gsp
operator|->
name|gs_name
argument_list|)
expr_stmt|;
name|parm
operator|->
name|gup_error
operator|=
name|ENOENT
expr_stmt|;
block|}
name|failed
label|:
name|mtx_unlock
argument_list|(
operator|&
name|me
operator|.
name|gs_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|g_gsched_global_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|me
operator|.
name|gs_initialized
condition|)
block|{
name|G_SCHED_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Initializing global data."
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|me
operator|.
name|gs_mtx
argument_list|,
literal|"gsched"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|me
operator|.
name|gs_scheds
argument_list|)
expr_stmt|;
name|gs_bioq_init
argument_list|(
operator|&
name|me
operator|.
name|gs_pending
argument_list|)
expr_stmt|;
name|me
operator|.
name|gs_initialized
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Module event called when a scheduling algorithm module is loaded or  * unloaded.  */
end_comment

begin_function
name|int
name|g_gsched_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|g_gsched
modifier|*
name|gsp
init|=
name|arg
decl_stmt|;
name|struct
name|g_gsched_unregparm
name|parm
decl_stmt|;
name|int
name|error
decl_stmt|;
name|G_SCHED_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Modevent %d."
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* 	 * If the module is loaded at boot, the geom thread that calls 	 * g_sched_init() might actually run after g_gsched_modevent(), 	 * so make sure that the module is properly initialized. 	 */
name|g_gsched_global_init
argument_list|()
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|error
operator|=
name|g_gsched_register
argument_list|(
name|gsp
argument_list|)
expr_stmt|;
name|G_SCHED_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Loaded module %s error %d."
argument_list|,
name|gsp
operator|->
name|gs_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|g_retaste
argument_list|(
operator|&
name|g_sched_class
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|parm
operator|.
name|gup_gsp
operator|=
name|gsp
expr_stmt|;
name|parm
operator|.
name|gup_error
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|g_waitfor_event
argument_list|(
name|g_gsched_unregister
argument_list|,
operator|&
name|parm
argument_list|,
name|M_WAITOK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|parm
operator|.
name|gup_error
expr_stmt|;
name|G_SCHED_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Unloaded module %s error %d."
argument_list|,
name|gsp
operator|->
name|gs_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KTR
end_ifdef

begin_define
define|#
directive|define
name|TRC_BIO_EVENT
parameter_list|(
name|e
parameter_list|,
name|bp
parameter_list|)
value|g_sched_trace_bio_ ## e (bp)
end_define

begin_function
specifier|static
specifier|inline
name|char
name|g_sched_type
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
literal|0
operator|!=
operator|(
name|bp
operator|->
name|bio_cmd
operator|&
name|BIO_READ
operator|)
condition|)
return|return
operator|(
literal|'R'
operator|)
return|;
elseif|else
if|if
condition|(
literal|0
operator|!=
operator|(
name|bp
operator|->
name|bio_cmd
operator|&
name|BIO_WRITE
operator|)
condition|)
return|return
operator|(
literal|'W'
operator|)
return|;
return|return
operator|(
literal|'U'
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|g_sched_trace_bio_START
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|CTR5
argument_list|(
name|KTR_GSCHED
argument_list|,
literal|"S %lu %c %lu/%lu %lu"
argument_list|,
name|g_sched_classify
argument_list|(
name|bp
argument_list|)
argument_list|,
name|g_sched_type
argument_list|(
name|bp
argument_list|)
argument_list|,
name|bp
operator|->
name|bio_offset
operator|/
name|ULONG_MAX
argument_list|,
name|bp
operator|->
name|bio_offset
argument_list|,
name|bp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|g_sched_trace_bio_DONE
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|CTR5
argument_list|(
name|KTR_GSCHED
argument_list|,
literal|"D %lu %c %lu/%lu %lu"
argument_list|,
name|g_sched_classify
argument_list|(
name|bp
argument_list|)
argument_list|,
name|g_sched_type
argument_list|(
name|bp
argument_list|)
argument_list|,
name|bp
operator|->
name|bio_offset
operator|/
name|ULONG_MAX
argument_list|,
name|bp
operator|->
name|bio_offset
argument_list|,
name|bp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !KTR */
end_comment

begin_define
define|#
directive|define
name|TRC_BIO_EVENT
parameter_list|(
name|e
parameter_list|,
name|bp
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !KTR */
end_comment

begin_comment
comment|/*  * g_sched_done() and g_sched_start() dispatch the geom requests to  * the scheduling algorithm in use.  */
end_comment

begin_function
specifier|static
name|void
name|g_sched_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bio
parameter_list|)
block|{
name|struct
name|g_geom
modifier|*
name|gp
init|=
name|bio
operator|->
name|bio_caller2
decl_stmt|;
name|struct
name|g_sched_softc
modifier|*
name|sc
init|=
name|gp
operator|->
name|softc
decl_stmt|;
name|TRC_BIO_EVENT
argument_list|(
name|DONE
argument_list|,
name|bio
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bio
operator|->
name|bio_caller1
argument_list|,
operator|(
literal|"null bio_caller1 in g_sched_done"
operator|)
argument_list|)
expr_stmt|;
name|g_sched_lock
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|g_sched_update_stats
argument_list|(
name|bio
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_gsched
operator|->
name|gs_done
argument_list|(
name|sc
operator|->
name|sc_data
argument_list|,
name|bio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|sc
operator|->
name|sc_pending
condition|)
name|wakeup
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|g_sched_flush_classes
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|g_sched_unlock
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|g_std_done
argument_list|(
name|bio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_sched_start
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_geom
modifier|*
name|gp
init|=
name|bp
operator|->
name|bio_to
operator|->
name|geom
decl_stmt|;
name|struct
name|g_sched_softc
modifier|*
name|sc
init|=
name|gp
operator|->
name|softc
decl_stmt|;
name|struct
name|bio
modifier|*
name|cbp
decl_stmt|;
name|TRC_BIO_EVENT
argument_list|(
name|START
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|G_SCHED_LOGREQ
argument_list|(
name|bp
argument_list|,
literal|"Request received."
argument_list|)
expr_stmt|;
name|cbp
operator|=
name|g_clone_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|==
name|NULL
condition|)
block|{
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return;
block|}
name|cbp
operator|->
name|bio_done
operator|=
name|g_sched_done
expr_stmt|;
name|cbp
operator|->
name|bio_to
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|gp
operator|->
name|provider
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cbp
operator|->
name|bio_to
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL provider"
operator|)
argument_list|)
expr_stmt|;
comment|/* We only schedule reads and writes. */
if|if
condition|(
literal|0
operator|==
operator|(
name|bp
operator|->
name|bio_cmd
operator|&
operator|(
name|BIO_READ
operator||
name|BIO_WRITE
operator|)
operator|)
condition|)
goto|goto
name|bypass
goto|;
name|G_SCHED_LOGREQ
argument_list|(
name|cbp
argument_list|,
literal|"Sending request."
argument_list|)
expr_stmt|;
name|g_sched_lock
argument_list|(
name|gp
argument_list|)
expr_stmt|;
comment|/* 	 * Call the algorithm's gs_start to queue the request in the 	 * scheduler. If gs_start fails then pass the request down, 	 * otherwise call g_sched_dispatch() which tries to push 	 * one or more requests down. 	 */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_gsched
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_SCHED_FLUSHING
operator|)
operator|||
name|sc
operator|->
name|sc_gsched
operator|->
name|gs_start
argument_list|(
name|sc
operator|->
name|sc_data
argument_list|,
name|cbp
argument_list|)
condition|)
block|{
name|g_sched_unlock
argument_list|(
name|gp
argument_list|)
expr_stmt|;
goto|goto
name|bypass
goto|;
block|}
comment|/* 	 * We use bio_caller1 to mark requests that are scheduled 	 * so make sure it is not NULL. 	 */
if|if
condition|(
name|cbp
operator|->
name|bio_caller1
operator|==
name|NULL
condition|)
name|cbp
operator|->
name|bio_caller1
operator|=
operator|&
name|me
expr_stmt|;
comment|/* anything not NULL */
name|cbp
operator|->
name|bio_caller2
operator|=
name|gp
expr_stmt|;
name|sc
operator|->
name|sc_pending
operator|++
expr_stmt|;
comment|/* Update general stats. */
name|me
operator|.
name|gs_in_flight
operator|++
expr_stmt|;
name|me
operator|.
name|gs_requests
operator|++
expr_stmt|;
name|me
operator|.
name|gs_bytes_in_flight
operator|+=
name|bp
operator|->
name|bio_length
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|&
name|BIO_WRITE
condition|)
block|{
name|me
operator|.
name|gs_writes_in_flight
operator|++
expr_stmt|;
name|me
operator|.
name|gs_write_bytes_in_flight
operator|+=
name|bp
operator|->
name|bio_length
expr_stmt|;
block|}
name|g_sched_dispatch
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|g_sched_unlock
argument_list|(
name|gp
argument_list|)
expr_stmt|;
return|return;
name|bypass
label|:
name|cbp
operator|->
name|bio_done
operator|=
name|g_std_done
expr_stmt|;
name|cbp
operator|->
name|bio_caller1
operator|=
name|NULL
expr_stmt|;
comment|/* not scheduled */
name|g_io_request
argument_list|(
name|cbp
argument_list|,
name|LIST_FIRST
argument_list|(
operator|&
name|gp
operator|->
name|consumer
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The next few functions are the geom glue.  */
end_comment

begin_function
specifier|static
name|void
name|g_sched_orphan
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|g_topology_assert
argument_list|()
expr_stmt|;
name|g_sched_destroy
argument_list|(
name|cp
operator|->
name|geom
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_sched_access
parameter_list|(
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|dr
parameter_list|,
name|int
name|dw
parameter_list|,
name|int
name|de
parameter_list|)
block|{
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|gp
operator|=
name|pp
operator|->
name|geom
expr_stmt|;
name|cp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|gp
operator|->
name|consumer
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
name|dr
argument_list|,
name|dw
argument_list|,
name|de
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_sched_temporary_start
parameter_list|(
name|struct
name|bio
modifier|*
name|bio
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|me
operator|.
name|gs_mtx
argument_list|)
expr_stmt|;
name|me
operator|.
name|gs_npending
operator|++
expr_stmt|;
name|gs_bioq_disksort
argument_list|(
operator|&
name|me
operator|.
name|gs_pending
argument_list|,
name|bio
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|me
operator|.
name|gs_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_sched_flush_pending
parameter_list|(
name|g_start_t
modifier|*
name|start
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|gs_bioq_takefirst
argument_list|(
operator|&
name|me
operator|.
name|gs_pending
argument_list|)
operator|)
condition|)
name|start
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_insert_proxy
parameter_list|(
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|newpp
parameter_list|,
name|struct
name|g_geom
modifier|*
name|dstgp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_sched_softc
modifier|*
name|sc
init|=
name|gp
operator|->
name|softc
decl_stmt|;
name|g_start_t
modifier|*
name|saved_start
decl_stmt|,
modifier|*
name|flush
init|=
name|g_sched_start
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|endticks
init|=
name|ticks
operator|+
name|hz
decl_stmt|;
name|g_cancel_event
argument_list|(
name|newpp
argument_list|)
expr_stmt|;
comment|/* prevent taste() */
comment|/* copy private fields */
name|newpp
operator|->
name|private
operator|=
name|pp
operator|->
name|private
expr_stmt|;
name|newpp
operator|->
name|index
operator|=
name|pp
operator|->
name|index
expr_stmt|;
comment|/* Queue all the early requests coming for us. */
name|me
operator|.
name|gs_npending
operator|=
literal|0
expr_stmt|;
name|saved_start
operator|=
name|pp
operator|->
name|geom
operator|->
name|start
expr_stmt|;
name|dstgp
operator|->
name|start
operator|=
name|g_sched_temporary_start
expr_stmt|;
while|while
condition|(
name|pp
operator|->
name|nstart
operator|-
name|pp
operator|->
name|nend
operator|!=
name|me
operator|.
name|gs_npending
operator|&&
name|endticks
operator|-
name|ticks
operator|>=
literal|0
condition|)
name|tsleep
argument_list|(
name|pp
argument_list|,
name|PRIBIO
argument_list|,
literal|"-"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|nstart
operator|-
name|pp
operator|->
name|nend
operator|!=
name|me
operator|.
name|gs_npending
condition|)
block|{
name|flush
operator|=
name|saved_start
expr_stmt|;
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* link pp to this geom */
name|LIST_REMOVE
argument_list|(
name|pp
argument_list|,
name|provider
argument_list|)
expr_stmt|;
name|pp
operator|->
name|geom
operator|=
name|gp
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|gp
operator|->
name|provider
argument_list|,
name|pp
argument_list|,
name|provider
argument_list|)
expr_stmt|;
comment|/* 	 * replicate the counts from the parent in the 	 * new provider and consumer nodes 	 */
name|cp
operator|->
name|acr
operator|=
name|newpp
operator|->
name|acr
operator|=
name|pp
operator|->
name|acr
expr_stmt|;
name|cp
operator|->
name|acw
operator|=
name|newpp
operator|->
name|acw
operator|=
name|pp
operator|->
name|acw
expr_stmt|;
name|cp
operator|->
name|ace
operator|=
name|newpp
operator|->
name|ace
operator|=
name|pp
operator|->
name|ace
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|G_SCHED_PROXYING
expr_stmt|;
name|fail
label|:
name|dstgp
operator|->
name|start
operator|=
name|saved_start
expr_stmt|;
name|g_sched_flush_pending
argument_list|(
name|flush
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a geom node for the device passed as *pp.  * If successful, add a reference to this gsp.  */
end_comment

begin_function
specifier|static
name|int
name|g_sched_create
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|struct
name|g_gsched
modifier|*
name|gsp
parameter_list|,
name|int
name|proxy
parameter_list|)
block|{
name|struct
name|g_sched_softc
modifier|*
name|sc
init|=
name|NULL
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|,
modifier|*
name|dstgp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|newpp
init|=
name|NULL
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
init|=
name|NULL
decl_stmt|;
name|char
name|name
index|[
literal|64
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|G_SCHED_SUFFIX
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|gp
argument_list|,
argument|&mp->geom
argument_list|,
argument|geom
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|gp
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Geom %s already exists."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
block|}
name|gp
operator|=
name|g_new_geomf
argument_list|(
name|mp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dstgp
operator|=
name|proxy
condition|?
name|pp
operator|->
name|geom
else|:
name|gp
expr_stmt|;
comment|/* where do we link the provider */
if|if
condition|(
name|gp
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Cannot create geom %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_gsched
operator|=
name|gsp
expr_stmt|;
name|sc
operator|->
name|sc_data
operator|=
name|gsp
operator|->
name|gs_init
argument_list|(
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_data
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|sc
operator|->
name|sc_hash
operator|=
name|g_sched_hash_init
argument_list|(
name|gsp
argument_list|,
operator|&
name|sc
operator|->
name|sc_mask
argument_list|,
name|HASH_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * Do not initialize the flush mechanism, will be initialized 	 * on the first insertion on the hash table. 	 */
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|"g_sched_mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|gp
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
name|gp
operator|->
name|start
operator|=
name|g_sched_start
expr_stmt|;
name|gp
operator|->
name|orphan
operator|=
name|g_sched_orphan
expr_stmt|;
name|gp
operator|->
name|access
operator|=
name|g_sched_access
expr_stmt|;
name|gp
operator|->
name|dumpconf
operator|=
name|g_sched_dumpconf
expr_stmt|;
name|newpp
operator|=
name|g_new_providerf
argument_list|(
name|dstgp
argument_list|,
name|gp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|newpp
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Cannot create provider %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|newpp
operator|->
name|mediasize
operator|=
name|pp
operator|->
name|mediasize
expr_stmt|;
name|newpp
operator|->
name|sectorsize
operator|=
name|pp
operator|->
name|sectorsize
expr_stmt|;
name|cp
operator|=
name|g_new_consumer
argument_list|(
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Cannot create consumer for %s."
argument_list|,
name|gp
operator|->
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|g_attach
argument_list|(
name|cp
argument_list|,
name|proxy
condition|?
name|newpp
else|:
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Cannot attach to provider %s."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|g_error_provider
argument_list|(
name|newpp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|proxy
condition|)
block|{
name|error
operator|=
name|g_insert_proxy
argument_list|(
name|gp
argument_list|,
name|newpp
argument_list|,
name|dstgp
argument_list|,
name|pp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
block|}
name|G_SCHED_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s created."
argument_list|,
name|gp
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_gsched_ref
argument_list|(
name|gsp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|provider
operator|!=
name|NULL
condition|)
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newpp
operator|!=
name|NULL
condition|)
name|g_destroy_provider
argument_list|(
name|newpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|&&
name|sc
operator|->
name|sc_hash
condition|)
block|{
name|g_sched_hash_fini
argument_list|(
name|gp
argument_list|,
name|sc
operator|->
name|sc_hash
argument_list|,
name|sc
operator|->
name|sc_mask
argument_list|,
name|gsp
argument_list|,
name|sc
operator|->
name|sc_data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|&&
name|sc
operator|->
name|sc_data
condition|)
name|gsp
operator|->
name|gs_fini
argument_list|(
name|sc
operator|->
name|sc_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|gp
operator|->
name|softc
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|gp
operator|->
name|softc
argument_list|)
expr_stmt|;
name|g_destroy_geom
argument_list|(
name|gp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Support for dynamic switching of scheduling algorithms.  * First initialize the data structures for the new algorithm,  * then call g_sched_remove_locked() to flush all references  * to the old one, finally link the new algorithm.  */
end_comment

begin_function
specifier|static
name|int
name|g_sched_change_algo
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|struct
name|g_gsched
modifier|*
name|gsp
parameter_list|)
block|{
name|struct
name|g_sched_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_hash
modifier|*
name|newh
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|u_long
name|mask
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|gp
operator|=
name|pp
operator|->
name|geom
expr_stmt|;
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
name|data
operator|=
name|gsp
operator|->
name|gs_init
argument_list|(
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|newh
operator|=
name|g_sched_hash_init
argument_list|(
name|gsp
argument_list|,
operator|&
name|mask
argument_list|,
name|HASH_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|gsp
operator|->
name|gs_priv_size
operator|&&
operator|!
name|newh
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|g_sched_lock
argument_list|(
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_gsched
condition|)
block|{
comment|/* can be NULL in some cases */
name|error
operator|=
name|g_sched_remove_locked
argument_list|(
name|gp
argument_list|,
name|sc
operator|->
name|sc_gsched
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
block|}
name|g_gsched_ref
argument_list|(
name|gsp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_gsched
operator|=
name|gsp
expr_stmt|;
name|sc
operator|->
name|sc_data
operator|=
name|data
expr_stmt|;
name|sc
operator|->
name|sc_hash
operator|=
name|newh
expr_stmt|;
name|sc
operator|->
name|sc_mask
operator|=
name|mask
expr_stmt|;
name|g_sched_unlock
argument_list|(
name|gp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|newh
condition|)
name|g_sched_hash_fini
argument_list|(
name|gp
argument_list|,
name|newh
argument_list|,
name|mask
argument_list|,
name|gsp
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
condition|)
name|gsp
operator|->
name|gs_fini
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|g_sched_unlock
argument_list|(
name|gp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Stop the request flow directed to the proxy, redirecting the new  * requests to the me.gs_pending queue.  */
end_comment

begin_function
specifier|static
name|struct
name|g_provider
modifier|*
name|g_detach_proxy
parameter_list|(
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|,
modifier|*
name|newpp
decl_stmt|;
do|do
block|{
name|pp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|gp
operator|->
name|provider
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
break|break;
name|cp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|gp
operator|->
name|consumer
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
break|break;
name|newpp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
if|if
condition|(
name|newpp
operator|==
name|NULL
condition|)
break|break;
name|me
operator|.
name|gs_npending
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|geom
operator|->
name|start
operator|=
name|g_sched_temporary_start
expr_stmt|;
return|return
operator|(
name|pp
operator|)
return|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|printf
argument_list|(
literal|"%s error detaching proxy %s\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|gp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_sched_blackhole
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|g_reparent_provider
parameter_list|(
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|newpp
parameter_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|pp
argument_list|,
name|provider
argument_list|)
expr_stmt|;
if|if
condition|(
name|newpp
condition|)
block|{
name|pp
operator|->
name|private
operator|=
name|newpp
operator|->
name|private
expr_stmt|;
name|pp
operator|->
name|index
operator|=
name|newpp
operator|->
name|index
expr_stmt|;
block|}
name|pp
operator|->
name|geom
operator|=
name|gp
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|gp
operator|->
name|provider
argument_list|,
name|pp
argument_list|,
name|provider
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|g_unproxy_provider
parameter_list|(
name|struct
name|g_provider
modifier|*
name|oldpp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|newpp
parameter_list|)
block|{
name|struct
name|g_geom
modifier|*
name|gp
init|=
name|oldpp
operator|->
name|geom
decl_stmt|;
name|g_reparent_provider
argument_list|(
name|oldpp
argument_list|,
name|newpp
operator|->
name|geom
argument_list|,
name|newpp
argument_list|)
expr_stmt|;
comment|/* 	 * Hackish: let the system destroy the old provider for us, just 	 * in case someone attached a consumer to it, in which case a 	 * direct call to g_destroy_provider() would not work. 	 */
name|g_reparent_provider
argument_list|(
name|newpp
argument_list|,
name|gp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete the proxy destruction, linking the old provider to its  * original geom, and destroying the proxy provider.  Also take care  * of issuing the pending requests collected in me.gs_pending (if any).  */
end_comment

begin_function
specifier|static
name|int
name|g_destroy_proxy
parameter_list|(
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|oldpp
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|newpp
decl_stmt|;
do|do
block|{
name|cp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|gp
operator|->
name|consumer
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
break|break;
name|newpp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
if|if
condition|(
name|newpp
operator|==
name|NULL
condition|)
break|break;
comment|/* Relink the provider to its original geom. */
name|g_unproxy_provider
argument_list|(
name|oldpp
argument_list|,
name|newpp
argument_list|)
expr_stmt|;
comment|/* Detach consumer from provider, and destroy provider. */
name|cp
operator|->
name|acr
operator|=
name|newpp
operator|->
name|acr
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|acw
operator|=
name|newpp
operator|->
name|acw
operator|=
literal|0
expr_stmt|;
name|cp
operator|->
name|ace
operator|=
name|newpp
operator|->
name|ace
operator|=
literal|0
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* Send the pending bios through the right start function. */
name|g_sched_flush_pending
argument_list|(
name|oldpp
operator|->
name|geom
operator|->
name|start
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|printf
argument_list|(
literal|"%s error destroying proxy %s\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|gp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* We cannot send the pending bios anywhere... */
name|g_sched_flush_pending
argument_list|(
name|g_sched_blackhole
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_sched_destroy
parameter_list|(
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|boolean_t
name|force
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|,
modifier|*
name|oldpp
init|=
name|NULL
decl_stmt|;
name|struct
name|g_sched_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_gsched
modifier|*
name|gsp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_SCHED_PROXYING
operator|)
condition|)
block|{
name|pp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|gp
operator|->
name|provider
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|&&
operator|(
name|pp
operator|->
name|acr
operator|!=
literal|0
operator|||
name|pp
operator|->
name|acw
operator|!=
literal|0
operator|||
name|pp
operator|->
name|ace
operator|!=
literal|0
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|force
condition|?
literal|"but we force removal"
else|:
literal|"cannot remove"
decl_stmt|;
name|G_SCHED_DEBUG
argument_list|(
operator|!
name|force
argument_list|,
literal|"Device %s is still open (r%dw%de%d), %s."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|pp
operator|->
name|acr
argument_list|,
name|pp
operator|->
name|acw
argument_list|,
name|pp
operator|->
name|ace
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|force
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
else|else
block|{
name|G_SCHED_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s removed."
argument_list|,
name|gp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|oldpp
operator|=
name|g_detach_proxy
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|gsp
operator|=
name|sc
operator|->
name|sc_gsched
expr_stmt|;
if|if
condition|(
name|gsp
condition|)
block|{
comment|/* 		 * XXX bad hack here: force a dispatch to release 		 * any reference to the hash table still held by 		 * the scheduler. 		 */
name|g_sched_lock
argument_list|(
name|gp
argument_list|)
expr_stmt|;
comment|/* 		 * We are dying here, no new requests should enter 		 * the scheduler.  This is granted by the topolgy, 		 * either in case we were proxying (new bios are 		 * being redirected) or not (see the access check 		 * above). 		 */
name|g_sched_forced_dispatch
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_sched_wait_pending
argument_list|(
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 			 * Not all the requests came home: this might happen 			 * under heavy load, or if we were waiting for any 			 * bio which is served in the event path (see 			 * geom_slice.c for an example of how this can 			 * happen).  Try to restore a working configuration 			 * if we can fail. 			 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_SCHED_PROXYING
operator|)
operator|&&
name|oldpp
condition|)
block|{
name|g_sched_flush_pending
argument_list|(
name|force
condition|?
name|g_sched_blackhole
else|:
name|g_sched_start
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * In the forced destroy case there is not so much 			 * we can do, we have pending bios that will call 			 * g_sched_done() somehow, and we don't want them 			 * to crash the system using freed memory.  We tell 			 * the user that something went wrong, and leak some 			 * memory here. 			 * Note: the callers using force = 1 ignore the 			 * return value. 			 */
if|if
condition|(
name|force
condition|)
block|{
name|G_SCHED_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Pending requests while "
literal|" destroying geom, some memory leaked."
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
name|g_sched_unlock
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|g_sched_hash_fini
argument_list|(
name|gp
argument_list|,
name|sc
operator|->
name|sc_hash
argument_list|,
name|sc
operator|->
name|sc_mask
argument_list|,
name|gsp
argument_list|,
name|sc
operator|->
name|sc_data
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_hash
operator|=
name|NULL
expr_stmt|;
name|gsp
operator|->
name|gs_fini
argument_list|(
name|sc
operator|->
name|sc_data
argument_list|)
expr_stmt|;
name|g_gsched_unref
argument_list|(
name|gsp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_gsched
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_SCHED_PROXYING
operator|)
operator|&&
name|oldpp
condition|)
block|{
name|error
operator|=
name|g_destroy_proxy
argument_list|(
name|gp
argument_list|,
name|oldpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|force
condition|)
block|{
name|G_SCHED_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Unrecoverable error while "
literal|"destroying a proxy geom, leaking some "
literal|" memory."
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|gp
operator|->
name|softc
argument_list|)
expr_stmt|;
name|gp
operator|->
name|softc
operator|=
name|NULL
expr_stmt|;
name|g_wither_geom
argument_list|(
name|gp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_sched_destroy_geom
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|)
block|{
return|return
operator|(
name|g_sched_destroy
argument_list|(
name|gp
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Functions related to the classification of requests.  *  * On recent FreeBSD versions (8.0 and above), we store a reference  * to the issuer of a request in bp->bio_classifier1 as soon  * as the bio is posted to the geom queue (and not later, because  * requests are managed by the g_down thread afterwards).  *  * On older versions of the system (but this code is not used  * in any existing release), we [ab]use the caller1 field in the  * root element of the bio tree to store the classification info.  * The marking is done at the beginning of g_io_request()  * and only if we find that the field is NULL.  *  * To avoid rebuilding the kernel, this module will patch the  * initial part of g_io_request() so it jumps to some hand-coded  * assembly that does the marking and then executes the original  * body of g_io_request().  *  * fake_ioreq[] is architecture-specific machine code  * that implements the above. CODE_SIZE, STORE_SIZE etc.  * are constants used in the patching routine. Look at the  * code in g_ioreq_patch() for the details.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_BIO_CLASSIFIER
end_ifndef

begin_comment
comment|/*  * Support for old FreeBSD versions  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_define
define|#
directive|define
name|CODE_SIZE
value|29
end_define

begin_define
define|#
directive|define
name|STORE_SIZE
value|5
end_define

begin_define
define|#
directive|define
name|EPILOGUE
value|5
end_define

begin_define
define|#
directive|define
name|SIZE
value|(CODE_SIZE + STORE_SIZE + EPILOGUE)
end_define

begin_decl_stmt
specifier|static
name|u_char
name|fake_ioreq
index|[
name|SIZE
index|]
init|=
block|{
literal|0x8b
block|,
literal|0x44
block|,
literal|0x24
block|,
literal|0x04
block|,
comment|/* mov bp, %eax */
comment|/* 1: */
literal|0x89
block|,
literal|0xc2
block|,
comment|/* mov %eax, %edx # edx = bp */
literal|0x8b
block|,
literal|0x40
block|,
literal|0x64
block|,
comment|/* mov bp->bio_parent, %eax */
literal|0x85
block|,
literal|0xc0
block|,
comment|/* test %eax, %eax */
literal|0x75
block|,
literal|0xf7
block|,
comment|/* jne 1b */
literal|0x8b
block|,
literal|0x42
block|,
literal|0x30
block|,
comment|/* mov bp->bp_caller1, %eax */
literal|0x85
block|,
literal|0xc0
block|,
comment|/* test %eax, %eax */
literal|0x75
block|,
literal|0x09
block|,
comment|/* jne 2f */
literal|0x64
block|,
literal|0xa1
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* mov %fs:0, %eax */
literal|0x00
block|,
literal|0x00
block|,
literal|0x89
block|,
literal|0x42
block|,
literal|0x30
block|,
comment|/* mov %eax, bp->bio_caller1 */
comment|/* 2: */
literal|0x55
block|,
literal|0x89
block|,
literal|0xe5
block|,
literal|0x57
block|,
literal|0x56
block|,
literal|0xe9
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* jmp back... */
block|}
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__amd64
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CODE_SIZE
value|38
end_define

begin_define
define|#
directive|define
name|STORE_SIZE
value|6
end_define

begin_define
define|#
directive|define
name|EPILOGUE
value|5
end_define

begin_define
define|#
directive|define
name|SIZE
value|(CODE_SIZE + STORE_SIZE + EPILOGUE)
end_define

begin_decl_stmt
specifier|static
name|u_char
name|fake_ioreq
index|[
name|SIZE
index|]
init|=
block|{
literal|0x48
block|,
literal|0x89
block|,
literal|0xf8
block|,
comment|/* mov bp, %rax */
comment|/* 1: */
literal|0x48
block|,
literal|0x89
block|,
literal|0xc2
block|,
comment|/* mov %rax, %rdx # rdx = bp */
literal|0x48
block|,
literal|0x8b
block|,
literal|0x82
block|,
literal|0xa8
block|,
comment|/* mov bp->bio_parent, %rax */
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x48
block|,
literal|0x85
block|,
literal|0xc0
block|,
comment|/* test %rax, %rax */
literal|0x75
block|,
literal|0xf1
block|,
comment|/* jne 1b */
literal|0x48
block|,
literal|0x83
block|,
literal|0x7a
block|,
literal|0x58
block|,
comment|/* cmp $0, bp->bp_caller1 */
literal|0x00
block|,
literal|0x75
block|,
literal|0x0d
block|,
comment|/* jne 2f */
literal|0x65
block|,
literal|0x48
block|,
literal|0x8b
block|,
literal|0x04
block|,
comment|/* mov %gs:0, %rax */
literal|0x25
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x48
block|,
literal|0x89
block|,
literal|0x42
block|,
literal|0x58
block|,
comment|/* mov %rax, bp->bio_caller1 */
comment|/* 2: */
literal|0x55
block|,
literal|0x48
block|,
literal|0x89
block|,
literal|0xe5
block|,
literal|0x41
block|,
literal|0x56
block|,
literal|0xe9
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* jmp back... */
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* neither x86 nor amd64 */
end_comment

begin_function
specifier|static
name|void
name|g_new_io_request
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|top
init|=
name|bp
decl_stmt|;
comment|/*          * bio classification: if bio_caller1 is available in the          * root of the 'struct bio' tree, store there the thread id          * of the thread that originated the request.          * More sophisticated classification schemes can be used.          */
while|while
condition|(
name|top
operator|->
name|bio_parent
condition|)
name|top
operator|=
name|top
operator|->
name|bio_parent
expr_stmt|;
if|if
condition|(
name|top
operator|->
name|bio_caller1
operator|==
name|NULL
condition|)
name|top
operator|->
name|bio_caller1
operator|=
name|curthread
expr_stmt|;
block|}
end_function

begin_error
error|#
directive|error
error|please add the code above in g_new_io_request() to the beginning of \ 	/sys/geom/geom_io.c::g_io_request(), and remove this line.
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* end of arch-specific code */
end_comment

begin_function
specifier|static
name|int
name|g_ioreq_patch
parameter_list|(
name|void
parameter_list|)
block|{
name|u_char
modifier|*
name|original
decl_stmt|;
name|u_long
name|ofs
decl_stmt|;
name|int
name|found
decl_stmt|;
if|if
condition|(
name|me
operator|.
name|gs_patched
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|original
operator|=
operator|(
name|u_char
operator|*
operator|)
name|g_io_request
expr_stmt|;
name|found
operator|=
operator|!
name|bcmp
argument_list|(
name|original
argument_list|,
name|fake_ioreq
operator|+
name|CODE_SIZE
argument_list|,
name|STORE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Jump back to the original + STORE_SIZE. */
name|ofs
operator|=
operator|(
name|original
operator|+
name|STORE_SIZE
operator|)
operator|-
operator|(
name|fake_ioreq
operator|+
name|SIZE
operator|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ofs
argument_list|,
name|fake_ioreq
operator|+
name|CODE_SIZE
operator|+
name|STORE_SIZE
operator|+
literal|1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Patch the original address with a jump to the trampoline. */
operator|*
name|original
operator|=
literal|0xe9
expr_stmt|;
comment|/* jump opcode */
name|ofs
operator|=
name|fake_ioreq
operator|-
operator|(
name|original
operator|+
literal|5
operator|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ofs
argument_list|,
name|original
operator|+
literal|1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|me
operator|.
name|gs_patched
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Restore the original code, this is easy.  */
end_comment

begin_function
specifier|static
name|void
name|g_ioreq_restore
parameter_list|(
name|void
parameter_list|)
block|{
name|u_char
modifier|*
name|original
decl_stmt|;
if|if
condition|(
name|me
operator|.
name|gs_patched
condition|)
block|{
name|original
operator|=
operator|(
name|u_char
operator|*
operator|)
name|g_io_request
expr_stmt|;
name|bcopy
argument_list|(
name|fake_ioreq
operator|+
name|CODE_SIZE
argument_list|,
name|original
argument_list|,
name|STORE_SIZE
argument_list|)
expr_stmt|;
name|me
operator|.
name|gs_patched
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|g_classifier_ini
parameter_list|(
name|void
parameter_list|)
block|{
name|g_ioreq_patch
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|g_classifier_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|g_ioreq_restore
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*--- end of support code for older FreeBSD versions */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* HAVE_BIO_CLASSIFIER */
end_comment

begin_comment
comment|/*  * Classifier support for recent FreeBSD versions: we use  * a very simple classifier, only use curthread to tag a request.  * The classifier is registered at module load, and unregistered  * at module unload.  */
end_comment

begin_function
specifier|static
name|int
name|g_sched_tag
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|bp
operator|->
name|bio_classifier1
operator|=
name|curthread
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|g_classifier_hook
name|g_sched_classifier
init|=
block|{
operator|.
name|func
operator|=
name|g_sched_tag
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|void
name|g_classifier_ini
parameter_list|(
name|void
parameter_list|)
block|{
name|g_register_classifier
argument_list|(
operator|&
name|g_sched_classifier
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|g_classifier_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|g_unregister_classifier
argument_list|(
operator|&
name|g_sched_classifier
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_BIO_CLASSIFIER */
end_comment

begin_function
specifier|static
name|void
name|g_sched_init
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
block|{
name|g_gsched_global_init
argument_list|()
expr_stmt|;
name|G_SCHED_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Loading: mp = %p, g_sched_class = %p."
argument_list|,
name|mp
argument_list|,
operator|&
name|g_sched_class
argument_list|)
expr_stmt|;
comment|/* Patch g_io_request to store classification info in the bio. */
name|g_classifier_ini
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_sched_fini
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
block|{
name|g_classifier_fini
argument_list|()
expr_stmt|;
name|G_SCHED_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Unloading..."
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|me
operator|.
name|gs_scheds
argument_list|)
argument_list|,
operator|(
literal|"still registered schedulers"
operator|)
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|me
operator|.
name|gs_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_sched_ioctl
parameter_list|(
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|cp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|pp
operator|->
name|geom
operator|->
name|consumer
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOIOCTL
operator|)
return|;
name|gp
operator|=
name|cp
operator|->
name|provider
operator|->
name|geom
expr_stmt|;
if|if
condition|(
name|gp
operator|->
name|ioctl
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOIOCTL
operator|)
return|;
return|return
operator|(
name|gp
operator|->
name|ioctl
argument_list|(
name|cp
operator|->
name|provider
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|fflag
argument_list|,
name|td
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read the i-th argument for a request, skipping the /dev/  * prefix if present.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|g_sched_argi
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|,
name|int
name|i
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|dev_prefix
init|=
literal|"/dev/"
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|param
index|[
literal|16
index|]
decl_stmt|;
name|int
name|l
init|=
name|strlen
argument_list|(
name|dev_prefix
argument_list|)
decl_stmt|;
name|snprintf
argument_list|(
name|param
argument_list|,
sizeof|sizeof
argument_list|(
name|param
argument_list|)
argument_list|,
literal|"arg%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|name
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No 'arg%d' argument"
argument_list|,
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|dev_prefix
argument_list|,
name|l
argument_list|)
operator|==
literal|0
condition|)
name|name
operator|+=
name|l
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch nargs and do appropriate checks.  */
end_comment

begin_function
specifier|static
name|int
name|g_sched_get_nargs
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|)
block|{
name|int
modifier|*
name|nargs
decl_stmt|;
name|nargs
operator|=
name|gctl_get_paraml
argument_list|(
name|req
argument_list|,
literal|"nargs"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nargs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No 'nargs' argument"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|nargs
operator|<=
literal|0
condition|)
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Missing device(s)."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|nargs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check whether we should add the class on certain volumes when  * this geom is created. Right now this is under control of a kenv  * variable containing the names of all devices that we care about.  * Probably we should only support transparent insertion as the  * preferred mode of operation.  */
end_comment

begin_function
specifier|static
name|struct
name|g_geom
modifier|*
name|g_sched_taste
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|flags
name|__unused
parameter_list|)
block|{
name|struct
name|g_gsched
modifier|*
name|gsp
init|=
name|NULL
decl_stmt|;
comment|/* the . algorithm we want */
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
comment|/* generic string pointer */
specifier|const
name|char
modifier|*
name|taste_names
decl_stmt|;
comment|/* devices we like */
name|int
name|l
decl_stmt|;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"%s(%s, %s)"
argument_list|,
name|__func__
argument_list|,
name|mp
operator|->
name|name
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|G_SCHED_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Tasting %s."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* do not taste on ourselves */
if|if
condition|(
name|pp
operator|->
name|geom
operator|->
name|class
operator|==
name|mp
condition|)
break|break;
name|taste_names
operator|=
name|getenv
argument_list|(
literal|"geom.sched.taste"
argument_list|)
expr_stmt|;
if|if
condition|(
name|taste_names
operator|==
name|NULL
condition|)
break|break;
name|l
operator|=
name|strlen
argument_list|(
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|taste_names
init|;
operator|*
name|s
operator|&&
operator|(
name|s
operator|=
name|strstr
argument_list|(
name|s
argument_list|,
name|pp
operator|->
name|name
argument_list|)
operator|)
condition|;
name|s
operator|++
control|)
block|{
comment|/* further checks for an exact match */
if|if
condition|(
operator|(
name|s
operator|==
name|taste_names
operator|||
name|s
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|)
operator|&&
operator|(
name|s
index|[
name|l
index|]
operator|==
literal|'\0'
operator|||
name|s
index|[
name|l
index|]
operator|==
literal|' '
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
break|break;
name|G_SCHED_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Attach device %s match [%s]\n"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* look up the provider name in the list */
name|s
operator|=
name|getenv
argument_list|(
literal|"geom.sched.algo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|s
operator|=
literal|"rr"
expr_stmt|;
name|gsp
operator|=
name|g_gsched_find
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* also get a reference */
if|if
condition|(
name|gsp
operator|==
name|NULL
condition|)
block|{
name|G_SCHED_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Bad '%s' algorithm."
argument_list|,
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* XXX create with 1 as last argument ? */
name|g_sched_create
argument_list|(
name|NULL
argument_list|,
name|mp
argument_list|,
name|pp
argument_list|,
name|gsp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_gsched_unref
argument_list|(
name|gsp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_sched_ctl_create
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|int
name|proxy
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_gsched
modifier|*
name|gsp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nargs
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|name
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
literal|"algo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No '%s' argument"
argument_list|,
literal|"algo"
argument_list|)
expr_stmt|;
return|return;
block|}
name|gsp
operator|=
name|g_gsched_find
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* also get a reference */
if|if
condition|(
name|gsp
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Bad algorithm '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|nargs
operator|=
name|g_sched_get_nargs
argument_list|(
name|req
argument_list|)
expr_stmt|;
comment|/* 	 * Run on the arguments, and break on any error. 	 * We look for a device name, but skip the /dev/ prefix if any. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|name
operator|=
name|g_sched_argi
argument_list|(
name|req
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
break|break;
name|pp
operator|=
name|g_provider_by_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
block|{
name|G_SCHED_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Provider %s is invalid."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Provider %s is invalid."
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|g_sched_create
argument_list|(
name|req
argument_list|,
name|mp
argument_list|,
name|pp
argument_list|,
name|gsp
argument_list|,
name|proxy
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
name|g_gsched_unref
argument_list|(
name|gsp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_sched_ctl_configure
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_gsched
modifier|*
name|gsp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nargs
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|name
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
literal|"algo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No '%s' argument"
argument_list|,
literal|"algo"
argument_list|)
expr_stmt|;
return|return;
block|}
name|gsp
operator|=
name|g_gsched_find
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* also get a reference */
if|if
condition|(
name|gsp
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Bad algorithm '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|nargs
operator|=
name|g_sched_get_nargs
argument_list|(
name|req
argument_list|)
expr_stmt|;
comment|/* 	 * Run on the arguments, and break on any error. 	 * We look for a device name, but skip the /dev/ prefix if any. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|name
operator|=
name|g_sched_argi
argument_list|(
name|req
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
break|break;
name|pp
operator|=
name|g_provider_by_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
operator|||
name|pp
operator|->
name|geom
operator|->
name|class
operator|!=
name|mp
condition|)
block|{
name|G_SCHED_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Provider %s is invalid."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Provider %s is invalid."
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|g_sched_change_algo
argument_list|(
name|req
argument_list|,
name|mp
argument_list|,
name|pp
argument_list|,
name|gsp
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
name|g_gsched_unref
argument_list|(
name|gsp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|g_geom
modifier|*
name|g_sched_find_geom
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|gp
argument_list|,
argument|&mp->geom
argument_list|,
argument|geom
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|gp
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|gp
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_sched_ctl_destroy
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
block|{
name|int
name|nargs
decl_stmt|,
modifier|*
name|force
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|nargs
operator|=
name|g_sched_get_nargs
argument_list|(
name|req
argument_list|)
expr_stmt|;
name|force
operator|=
name|gctl_get_paraml
argument_list|(
name|req
argument_list|,
literal|"force"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|force
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|force
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No 'force' argument"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|name
operator|=
name|g_sched_argi
argument_list|(
name|req
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
break|break;
name|gp
operator|=
name|g_sched_find_geom
argument_list|(
name|mp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|==
name|NULL
condition|)
block|{
name|G_SCHED_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Device %s is invalid."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Device %s is invalid."
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|g_sched_destroy
argument_list|(
name|gp
argument_list|,
operator|*
name|force
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Cannot destroy device %s (error=%d)."
argument_list|,
name|gp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_sched_config
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
specifier|const
name|char
modifier|*
name|verb
parameter_list|)
block|{
name|uint32_t
modifier|*
name|version
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|version
operator|=
name|gctl_get_paraml
argument_list|(
name|req
argument_list|,
literal|"version"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|version
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No '%s' argument."
argument_list|,
literal|"version"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|version
operator|!=
name|G_SCHED_VERSION
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Userland and kernel parts are "
literal|"out of sync."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"create"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|g_sched_ctl_create
argument_list|(
name|req
argument_list|,
name|mp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"insert"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|g_sched_ctl_create
argument_list|(
name|req
argument_list|,
name|mp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"configure"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|g_sched_ctl_configure
argument_list|(
name|req
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"destroy"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|g_sched_ctl_destroy
argument_list|(
name|req
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return;
block|}
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Unknown verb."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_sched_dumpconf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|)
block|{
name|struct
name|g_sched_softc
modifier|*
name|sc
init|=
name|gp
operator|->
name|softc
decl_stmt|;
name|struct
name|g_gsched
modifier|*
name|gsp
init|=
name|sc
operator|->
name|sc_gsched
decl_stmt|;
if|if
condition|(
name|indent
operator|==
name|NULL
condition|)
block|{
comment|/* plaintext */
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" algo %s"
argument_list|,
name|gsp
condition|?
name|gsp
operator|->
name|gs_name
else|:
literal|"--"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gsp
operator|->
name|gs_dumpconf
condition|)
name|gsp
operator|->
name|gs_dumpconf
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|gp
argument_list|,
name|cp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|DECLARE_GEOM_CLASS
argument_list|(
name|g_sched_class
argument_list|,
name|g_sched
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|geom_sched
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

