begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2010 Fabio Checconi  * Copyright (c) 2009-2010 Luigi Rizzo, Universita` di Pisa  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * $Id$  * $FreeBSD$  *  * A round-robin (RR) anticipatory scheduler, with per-client queues.  *  * The goal of this implementation is to improve throughput compared  * to the pure elevator algorithm, and insure some fairness among  * clients.  *   * Requests coming from the same client are put in the same queue.  * We use anticipation to help reducing seeks, and each queue  * is never served continuously for more than a given amount of  * time or data. Queues are then served in a round-robin fashion.  *  * Each queue can be in any of the following states:  *     READY	immediately serve the first pending request;  *     BUSY	one request is under service, wait for completion;  *     IDLING	do not serve incoming requests immediately, unless  * 		they are "eligible" as defined later.  *  * Scheduling is made looking at the status of all queues,  * and the first one in round-robin order is privileged.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|"gs_scheduler.h"
end_include

begin_comment
comment|/* possible states of the scheduler */
end_comment

begin_enum
enum|enum
name|g_rr_state
block|{
name|G_QUEUE_READY
init|=
literal|0
block|,
comment|/* Ready to dispatch. */
name|G_QUEUE_BUSY
block|,
comment|/* Waiting for a completion. */
name|G_QUEUE_IDLING
comment|/* Waiting for a new request. */
block|}
enum|;
end_enum

begin_comment
comment|/* possible queue flags */
end_comment

begin_enum
enum|enum
name|g_rr_flags
block|{
comment|/* G_FLAG_COMPLETED means that the field q_slice_end is valid. */
name|G_FLAG_COMPLETED
init|=
literal|1
block|,
comment|/* Completed a req. in the current budget. */
block|}
enum|;
end_enum

begin_struct_decl
struct_decl|struct
name|g_rr_softc
struct_decl|;
end_struct_decl

begin_comment
comment|/*  * Queue descriptor, containing reference count, scheduling  * state, a queue of pending requests, configuration parameters.  * Queues with pending request(s) and not under service are also  * stored in a Round Robin (RR) list.  */
end_comment

begin_struct
struct|struct
name|g_rr_queue
block|{
name|struct
name|g_rr_softc
modifier|*
name|q_sc
decl_stmt|;
comment|/* link to the parent */
name|enum
name|g_rr_state
name|q_status
decl_stmt|;
name|unsigned
name|int
name|q_service
decl_stmt|;
comment|/* service received so far */
name|int
name|q_slice_end
decl_stmt|;
comment|/* actual slice end time, in ticks */
name|enum
name|g_rr_flags
name|q_flags
decl_stmt|;
comment|/* queue flags */
name|struct
name|bio_queue_head
name|q_bioq
decl_stmt|;
comment|/* Scheduling parameters */
name|unsigned
name|int
name|q_budget
decl_stmt|;
comment|/* slice size in bytes */
name|unsigned
name|int
name|q_slice_duration
decl_stmt|;
comment|/* slice size in ticks */
name|unsigned
name|int
name|q_wait_ticks
decl_stmt|;
comment|/* wait time for anticipation */
comment|/* Stats to drive the various heuristics. */
name|struct
name|g_savg
name|q_thinktime
decl_stmt|;
comment|/* Thinktime average. */
name|struct
name|g_savg
name|q_seekdist
decl_stmt|;
comment|/* Seek distance average. */
name|int
name|q_bionum
decl_stmt|;
comment|/* Number of requests. */
name|off_t
name|q_lastoff
decl_stmt|;
comment|/* Last submitted req. offset. */
name|int
name|q_lastsub
decl_stmt|;
comment|/* Last submitted req. time. */
comment|/* Expiration deadline for an empty queue. */
name|int
name|q_expire
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|g_rr_queue
argument_list|)
name|q_tailq
expr_stmt|;
comment|/* RR list link field */
block|}
struct|;
end_struct

begin_comment
comment|/* List types. */
end_comment

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|g_rr_tailq
argument_list|,
name|g_rr_queue
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* list of scheduler instances */
end_comment

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|g_scheds
argument_list|,
name|g_rr_softc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Default quantum for RR between queues. */
end_comment

begin_define
define|#
directive|define
name|G_RR_DEFAULT_BUDGET
value|0x00800000
end_define

begin_comment
comment|/*  * Per device descriptor, holding the Round Robin list of queues  * accessing the disk, a reference to the geom, and the timer.  */
end_comment

begin_struct
struct|struct
name|g_rr_softc
block|{
name|struct
name|g_geom
modifier|*
name|sc_geom
decl_stmt|;
comment|/* 	 * sc_active is the queue we are anticipating for. 	 * It is set only in gs_rr_next(), and possibly cleared 	 * only in gs_rr_next() or on a timeout. 	 * The active queue is never in the Round Robin list 	 * even if it has requests queued. 	 */
name|struct
name|g_rr_queue
modifier|*
name|sc_active
decl_stmt|;
name|struct
name|callout
name|sc_wait
decl_stmt|;
comment|/* timer for sc_active */
name|struct
name|g_rr_tailq
name|sc_rr_tailq
decl_stmt|;
comment|/* the round-robin list */
name|int
name|sc_nqueues
decl_stmt|;
comment|/* number of queues */
comment|/* Statistics */
name|int
name|sc_in_flight
decl_stmt|;
comment|/* requests in the driver */
name|LIST_ENTRY
argument_list|(
argument|g_rr_softc
argument_list|)
name|sc_next
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Descriptor for bounded values, min and max are constant. */
end_comment

begin_struct
struct|struct
name|x_bound
block|{
specifier|const
name|int
name|x_min
decl_stmt|;
name|int
name|x_cur
decl_stmt|;
specifier|const
name|int
name|x_max
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * parameters, config and stats  */
end_comment

begin_struct
struct|struct
name|g_rr_params
block|{
name|int
name|queues
decl_stmt|;
comment|/* total number of queues */
name|int
name|w_anticipate
decl_stmt|;
comment|/* anticipate writes */
name|int
name|bypass
decl_stmt|;
comment|/* bypass scheduling writes */
name|int
name|units
decl_stmt|;
comment|/* how many instances */
comment|/* sc_head is used for debugging */
name|struct
name|g_scheds
name|sc_head
decl_stmt|;
comment|/* first scheduler instance */
name|struct
name|x_bound
name|queue_depth
decl_stmt|;
comment|/* max parallel requests */
name|struct
name|x_bound
name|wait_ms
decl_stmt|;
comment|/* wait time, milliseconds */
name|struct
name|x_bound
name|quantum_ms
decl_stmt|;
comment|/* quantum size, milliseconds */
name|struct
name|x_bound
name|quantum_kb
decl_stmt|;
comment|/* quantum size, Kb (1024 bytes) */
comment|/* statistics */
name|int
name|wait_hit
decl_stmt|;
comment|/* success in anticipation */
name|int
name|wait_miss
decl_stmt|;
comment|/* failure in anticipation */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Default parameters for the scheduler.  The quantum sizes target  * a 80MB/s disk; if the hw is faster or slower the minimum of the  * two will have effect: the clients will still be isolated but  * the fairness may be limited.  A complete solution would involve  * the on-line measurement of the actual disk throughput to derive  * these parameters.  Or we may just choose to ignore service domain  * fairness and accept what can be achieved with time-only budgets.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|g_rr_params
name|me
init|=
block|{
operator|.
name|sc_head
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
operator|&
name|me
operator|.
name|sc_head
argument_list|)
block|,
operator|.
name|w_anticipate
operator|=
literal|1
block|,
operator|.
name|queue_depth
operator|=
block|{
literal|1
block|,
literal|1
block|,
literal|50
block|}
block|,
operator|.
name|wait_ms
operator|=
block|{
literal|1
block|,
literal|10
block|,
literal|30
block|}
block|,
operator|.
name|quantum_ms
operator|=
block|{
literal|1
block|,
literal|100
block|,
literal|500
block|}
block|,
operator|.
name|quantum_kb
operator|=
block|{
literal|16
block|,
literal|8192
block|,
literal|65536
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|g_rr_params
modifier|*
name|gs_rr_me
init|=
operator|&
name|me
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_kern_geom_sched
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_kern_geom_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|rr
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"GEOM_SCHED ROUND ROBIN stuff"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_geom_sched_rr
argument_list|,
name|OID_AUTO
argument_list|,
name|units
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|me
operator|.
name|units
argument_list|,
literal|0
argument_list|,
literal|"Scheduler instances"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_geom_sched_rr
argument_list|,
name|OID_AUTO
argument_list|,
name|queues
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|me
operator|.
name|queues
argument_list|,
literal|0
argument_list|,
literal|"Total rr queues"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_geom_sched_rr
argument_list|,
name|OID_AUTO
argument_list|,
name|wait_ms
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|me
operator|.
name|wait_ms
operator|.
name|x_cur
argument_list|,
literal|0
argument_list|,
literal|"Wait time milliseconds"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_geom_sched_rr
argument_list|,
name|OID_AUTO
argument_list|,
name|quantum_ms
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|me
operator|.
name|quantum_ms
operator|.
name|x_cur
argument_list|,
literal|0
argument_list|,
literal|"Quantum size milliseconds"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_geom_sched_rr
argument_list|,
name|OID_AUTO
argument_list|,
name|bypass
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|me
operator|.
name|bypass
argument_list|,
literal|0
argument_list|,
literal|"Bypass scheduler"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_geom_sched_rr
argument_list|,
name|OID_AUTO
argument_list|,
name|w_anticipate
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|me
operator|.
name|w_anticipate
argument_list|,
literal|0
argument_list|,
literal|"Do anticipation on writes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_geom_sched_rr
argument_list|,
name|OID_AUTO
argument_list|,
name|quantum_kb
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|me
operator|.
name|quantum_kb
operator|.
name|x_cur
argument_list|,
literal|0
argument_list|,
literal|"Quantum size Kbytes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_geom_sched_rr
argument_list|,
name|OID_AUTO
argument_list|,
name|queue_depth
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|me
operator|.
name|queue_depth
operator|.
name|x_cur
argument_list|,
literal|0
argument_list|,
literal|"Maximum simultaneous requests"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_geom_sched_rr
argument_list|,
name|OID_AUTO
argument_list|,
name|wait_hit
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|me
operator|.
name|wait_hit
argument_list|,
literal|0
argument_list|,
literal|"Hits in anticipation"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_geom_sched_rr
argument_list|,
name|OID_AUTO
argument_list|,
name|wait_miss
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|me
operator|.
name|wait_miss
argument_list|,
literal|0
argument_list|,
literal|"Misses in anticipation"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_QUEUES
end_ifdef

begin_comment
comment|/* print the status of a queue */
end_comment

begin_function
specifier|static
name|void
name|gs_rr_dump_q
parameter_list|(
name|struct
name|g_rr_queue
modifier|*
name|qp
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|int
name|l
init|=
literal|0
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&(qp->q_bioq.queue)
argument_list|,
argument|bio_queue
argument_list|)
block|{
name|l
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"--- rr queue %d %p status %d len %d ---\n"
argument_list|,
name|index
argument_list|,
name|qp
argument_list|,
name|qp
operator|->
name|q_status
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump the scheduler status when writing to this sysctl variable.  * XXX right now we only dump the status of the last instance created.  * not a severe issue because this is only for debugging  */
end_comment

begin_function
specifier|static
name|int
name|gs_rr_sysctl_status
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|val
init|=
literal|0
decl_stmt|;
name|struct
name|g_rr_softc
modifier|*
name|sc
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|printf
argument_list|(
literal|"called %s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sc
argument_list|,
argument|&me.sc_head
argument_list|,
argument|sc_next
argument_list|)
block|{
name|int
name|i
decl_stmt|,
name|tot
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"--- sc %p active %p nqueues %d "
literal|"callout %d in_flight %d ---\n"
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sc_active
argument_list|,
name|sc
operator|->
name|sc_nqueues
argument_list|,
name|callout_active
argument_list|(
operator|&
name|sc
operator|->
name|sc_wait
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_in_flight
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|G_RR_HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|g_rr_queue
modifier|*
name|qp
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|qp
argument_list|,
argument|&sc->sc_hash[i]
argument_list|,
argument|q_hash
argument_list|)
block|{
name|gs_rr_dump_q
argument_list|(
name|qp
argument_list|,
name|tot
argument_list|)
expr_stmt|;
name|tot
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_geom_sched_rr
argument_list|,
name|OID_AUTO
argument_list|,
name|status
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|gs_rr_sysctl_status
argument_list|,
literal|"I"
argument_list|,
literal|"status"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG_QUEUES */
end_comment

begin_comment
comment|/*  * Get a bounded value, optionally convert to a min of t_min ticks.  */
end_comment

begin_function
specifier|static
name|int
name|get_bounded
parameter_list|(
name|struct
name|x_bound
modifier|*
name|v
parameter_list|,
name|int
name|t_min
parameter_list|)
block|{
name|int
name|x
decl_stmt|;
name|x
operator|=
name|v
operator|->
name|x_cur
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|v
operator|->
name|x_min
condition|)
name|x
operator|=
name|v
operator|->
name|x_min
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|>
name|v
operator|->
name|x_max
condition|)
name|x
operator|=
name|v
operator|->
name|x_max
expr_stmt|;
if|if
condition|(
name|t_min
condition|)
block|{
name|x
operator|=
name|x
operator|*
name|hz
operator|/
literal|1000
expr_stmt|;
comment|/* convert to ticks */
if|if
condition|(
name|x
operator|<
name|t_min
condition|)
name|x
operator|=
name|t_min
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/*  * Get a reference to the queue for bp, using the generic  * classification mechanism.  */
end_comment

begin_function
specifier|static
name|struct
name|g_rr_queue
modifier|*
name|g_rr_queue_get
parameter_list|(
name|struct
name|g_rr_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
return|return
operator|(
name|g_sched_get_class
argument_list|(
name|sc
operator|->
name|sc_geom
argument_list|,
name|bp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_rr_init_class
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|g_rr_softc
modifier|*
name|sc
init|=
name|data
decl_stmt|;
name|struct
name|g_rr_queue
modifier|*
name|qp
init|=
name|priv
decl_stmt|;
name|bioq_init
argument_list|(
operator|&
name|qp
operator|->
name|q_bioq
argument_list|)
expr_stmt|;
comment|/* 	 * Set the initial parameters for the client: 	 * slice size in bytes and ticks, and wait ticks. 	 * Right now these are constant, but we could have 	 * autoconfiguration code to adjust the values based on 	 * the actual workload. 	 */
name|qp
operator|->
name|q_budget
operator|=
literal|1024
operator|*
name|get_bounded
argument_list|(
operator|&
name|me
operator|.
name|quantum_kb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_slice_duration
operator|=
name|get_bounded
argument_list|(
operator|&
name|me
operator|.
name|quantum_ms
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_wait_ticks
operator|=
name|get_bounded
argument_list|(
operator|&
name|me
operator|.
name|wait_ms
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_sc
operator|=
name|sc
expr_stmt|;
comment|/* link to the parent */
name|qp
operator|->
name|q_sc
operator|->
name|sc_nqueues
operator|++
expr_stmt|;
name|me
operator|.
name|queues
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a reference to the queue.  */
end_comment

begin_function
specifier|static
name|void
name|g_rr_queue_put
parameter_list|(
name|struct
name|g_rr_queue
modifier|*
name|qp
parameter_list|)
block|{
name|g_sched_put_class
argument_list|(
name|qp
operator|->
name|q_sc
operator|->
name|sc_geom
argument_list|,
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_rr_fini_class
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|void
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|g_rr_queue
modifier|*
name|qp
init|=
name|priv
decl_stmt|;
name|KASSERT
argument_list|(
name|bioq_first
argument_list|(
operator|&
name|qp
operator|->
name|q_bioq
argument_list|)
operator|==
name|NULL
argument_list|,
operator|(
literal|"released nonempty queue"
operator|)
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_sc
operator|->
name|sc_nqueues
operator|--
expr_stmt|;
name|me
operator|.
name|queues
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|g_rr_queue_expired
parameter_list|(
name|struct
name|g_rr_queue
modifier|*
name|qp
parameter_list|)
block|{
if|if
condition|(
name|qp
operator|->
name|q_service
operator|>=
name|qp
operator|->
name|q_budget
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|G_FLAG_COMPLETED
operator|)
operator|&&
name|ticks
operator|-
name|qp
operator|->
name|q_slice_end
operator|>=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|g_rr_should_anticipate
parameter_list|(
name|struct
name|g_rr_queue
modifier|*
name|qp
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|wait
init|=
name|get_bounded
argument_list|(
operator|&
name|me
operator|.
name|wait_ms
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|me
operator|.
name|w_anticipate
operator|&&
operator|(
name|bp
operator|->
name|bio_cmd
operator|&
name|BIO_WRITE
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|g_savg_valid
argument_list|(
operator|&
name|qp
operator|->
name|q_thinktime
argument_list|)
operator|&&
name|g_savg_read
argument_list|(
operator|&
name|qp
operator|->
name|q_thinktime
argument_list|)
operator|>
name|wait
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|g_savg_valid
argument_list|(
operator|&
name|qp
operator|->
name|q_seekdist
argument_list|)
operator|&&
name|g_savg_read
argument_list|(
operator|&
name|qp
operator|->
name|q_seekdist
argument_list|)
operator|>
literal|8192
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called on a request arrival, timeout or completion.  * Try to serve a request among those queued.  */
end_comment

begin_function
specifier|static
name|struct
name|bio
modifier|*
name|g_rr_next
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|g_rr_softc
modifier|*
name|sc
init|=
name|data
decl_stmt|;
name|struct
name|g_rr_queue
modifier|*
name|qp
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|expired
decl_stmt|;
name|qp
operator|=
name|sc
operator|->
name|sc_active
expr_stmt|;
if|if
condition|(
name|me
operator|.
name|bypass
operator|==
literal|0
operator|&&
operator|!
name|force
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_in_flight
operator|>=
name|get_bounded
argument_list|(
operator|&
name|me
operator|.
name|queue_depth
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Try with the queue under service first. */
if|if
condition|(
name|qp
operator|!=
name|NULL
operator|&&
name|qp
operator|->
name|q_status
operator|!=
name|G_QUEUE_READY
condition|)
block|{
comment|/* 			 * Queue is anticipating, ignore request. 			 * We should check that we are not past 			 * the timeout, but in that case the timeout 			 * will fire immediately afterwards so we 			 * don't bother. 			 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|qp
operator|!=
name|NULL
operator|&&
name|qp
operator|->
name|q_status
operator|!=
name|G_QUEUE_READY
condition|)
block|{
name|g_rr_queue_put
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_active
operator|=
name|qp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * No queue under service, look for the first in RR order. 	 * If we find it, select if as sc_active, clear service 	 * and record the end time of the slice. 	 */
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
block|{
name|qp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rr_tailq
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* no queues at all, return */
comment|/* otherwise select the new queue for service. */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_rr_tailq
argument_list|,
name|qp
argument_list|,
name|q_tailq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_active
operator|=
name|qp
expr_stmt|;
name|qp
operator|->
name|q_service
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|q_flags
operator|&=
operator|~
name|G_FLAG_COMPLETED
expr_stmt|;
block|}
name|bp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|qp
operator|->
name|q_bioq
argument_list|)
expr_stmt|;
comment|/* surely not NULL */
name|qp
operator|->
name|q_service
operator|+=
name|bp
operator|->
name|bio_length
expr_stmt|;
comment|/* charge the service */
comment|/* 	 * The request at the head of the active queue is always 	 * dispatched, and gs_rr_next() will be called again 	 * immediately. 	 * We need to prepare for what to do next: 	 * 	 * 1. have we reached the end of the (time or service) slice ? 	 *    If so, clear sc_active and possibly requeue the previous 	 *    active queue if it has more requests pending; 	 * 2. do we have more requests in sc_active ? 	 *    If yes, do not anticipate, as gs_rr_next() will run again; 	 *    if no, decide whether or not to anticipate depending 	 *    on read or writes (e.g., anticipate only on reads). 	 */
name|expired
operator|=
name|g_rr_queue_expired
argument_list|(
name|qp
argument_list|)
expr_stmt|;
comment|/* are we expired ? */
name|next
operator|=
name|bioq_first
argument_list|(
operator|&
name|qp
operator|->
name|q_bioq
argument_list|)
expr_stmt|;
comment|/* do we have one more ? */
if|if
condition|(
name|expired
condition|)
block|{
name|sc
operator|->
name|sc_active
operator|=
name|NULL
expr_stmt|;
comment|/* Either requeue or release reference. */
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rr_tailq
argument_list|,
name|qp
argument_list|,
name|q_tailq
argument_list|)
expr_stmt|;
else|else
name|g_rr_queue_put
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
name|qp
operator|->
name|q_status
operator|=
name|G_QUEUE_READY
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|force
operator|&&
name|g_rr_should_anticipate
argument_list|(
name|qp
argument_list|,
name|bp
argument_list|)
condition|)
block|{
comment|/* anticipate */
name|qp
operator|->
name|q_status
operator|=
name|G_QUEUE_BUSY
expr_stmt|;
block|}
else|else
block|{
comment|/* do not anticipate, release reference */
name|g_rr_queue_put
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_active
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* If sc_active != NULL, its q_status is always correct. */
name|sc
operator|->
name|sc_in_flight
operator|++
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|g_rr_update_thinktime
parameter_list|(
name|struct
name|g_rr_queue
modifier|*
name|qp
parameter_list|)
block|{
name|int
name|delta
init|=
name|ticks
operator|-
name|qp
operator|->
name|q_lastsub
decl_stmt|,
name|wait
init|=
name|get_bounded
argument_list|(
operator|&
name|me
operator|.
name|wait_ms
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_sc
operator|->
name|sc_active
operator|!=
name|qp
condition|)
return|return;
name|qp
operator|->
name|q_lastsub
operator|=
name|ticks
expr_stmt|;
name|delta
operator|=
operator|(
name|delta
operator|>
literal|2
operator|*
name|wait
operator|)
condition|?
literal|2
operator|*
name|wait
else|:
name|delta
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_bionum
operator|>
literal|7
condition|)
name|g_savg_add_sample
argument_list|(
operator|&
name|qp
operator|->
name|q_thinktime
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|g_rr_update_seekdist
parameter_list|(
name|struct
name|g_rr_queue
modifier|*
name|qp
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|off_t
name|dist
decl_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_lastoff
operator|>
name|bp
operator|->
name|bio_offset
condition|)
name|dist
operator|=
name|qp
operator|->
name|q_lastoff
operator|-
name|bp
operator|->
name|bio_offset
expr_stmt|;
else|else
name|dist
operator|=
name|bp
operator|->
name|bio_offset
operator|-
name|qp
operator|->
name|q_lastoff
expr_stmt|;
if|if
condition|(
name|dist
operator|>
operator|(
literal|8192
operator|*
literal|8
operator|)
condition|)
name|dist
operator|=
literal|8192
operator|*
literal|8
expr_stmt|;
name|qp
operator|->
name|q_lastoff
operator|=
name|bp
operator|->
name|bio_offset
operator|+
name|bp
operator|->
name|bio_length
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_bionum
operator|>
literal|7
condition|)
name|g_savg_add_sample
argument_list|(
operator|&
name|qp
operator|->
name|q_seekdist
argument_list|,
name|dist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when a real request for disk I/O arrives.  * Locate the queue associated with the client.  * If the queue is the one we are anticipating for, reset its timeout;  * if the queue is not in the round robin list, insert it in the list.  * On any error, do not queue the request and return -1, the caller  * will take care of this request.  */
end_comment

begin_function
specifier|static
name|int
name|g_rr_start
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_rr_softc
modifier|*
name|sc
init|=
name|data
decl_stmt|;
name|struct
name|g_rr_queue
modifier|*
name|qp
decl_stmt|;
if|if
condition|(
name|me
operator|.
name|bypass
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* bypass the scheduler */
comment|/* Get the queue for the request. */
name|qp
operator|=
name|g_rr_queue_get
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* allocation failed, tell upstream */
if|if
condition|(
name|bioq_first
argument_list|(
operator|&
name|qp
operator|->
name|q_bioq
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * We are inserting into an empty queue. 		 * Reset its state if it is sc_active, 		 * otherwise insert it in the RR list. 		 */
if|if
condition|(
name|qp
operator|==
name|sc
operator|->
name|sc_active
condition|)
block|{
name|qp
operator|->
name|q_status
operator|=
name|G_QUEUE_READY
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_wait
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_sched_priv_ref
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_rr_tailq
argument_list|,
name|qp
argument_list|,
name|q_tailq
argument_list|)
expr_stmt|;
block|}
block|}
name|qp
operator|->
name|q_bionum
operator|=
literal|1
operator|+
name|qp
operator|->
name|q_bionum
operator|-
operator|(
name|qp
operator|->
name|q_bionum
operator|>>
literal|3
operator|)
expr_stmt|;
name|g_rr_update_thinktime
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|g_rr_update_seekdist
argument_list|(
name|qp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* Inherit the reference returned by g_rr_queue_get(). */
name|bp
operator|->
name|bio_caller1
operator|=
name|qp
expr_stmt|;
name|bioq_disksort
argument_list|(
operator|&
name|qp
operator|->
name|q_bioq
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Callout executed when a queue times out anticipating a new request.  */
end_comment

begin_function
specifier|static
name|void
name|g_rr_wait_timeout
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|g_rr_softc
modifier|*
name|sc
init|=
name|data
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|geom
init|=
name|sc
operator|->
name|sc_geom
decl_stmt|;
name|g_sched_lock
argument_list|(
name|geom
argument_list|)
expr_stmt|;
comment|/* 	 * We can race with other events, so check if 	 * sc_active is still valid. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_active
operator|!=
name|NULL
condition|)
block|{
comment|/* Release the reference to the queue. */
name|g_rr_queue_put
argument_list|(
name|sc
operator|->
name|sc_active
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_active
operator|=
name|NULL
expr_stmt|;
name|me
operator|.
name|wait_hit
operator|--
expr_stmt|;
name|me
operator|.
name|wait_miss
operator|++
expr_stmt|;
comment|/* record the miss */
block|}
name|g_sched_dispatch
argument_list|(
name|geom
argument_list|)
expr_stmt|;
name|g_sched_unlock
argument_list|(
name|geom
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Module glue: allocate descriptor, initialize its fields.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|g_rr_init
parameter_list|(
name|struct
name|g_geom
modifier|*
name|geom
parameter_list|)
block|{
name|struct
name|g_rr_softc
modifier|*
name|sc
decl_stmt|;
comment|/* XXX check whether we can sleep */
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|sc
argument_list|,
name|M_GEOM_SCHED
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_geom
operator|=
name|geom
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rr_tailq
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_wait
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|me
operator|.
name|sc_head
argument_list|,
name|sc
argument_list|,
name|sc_next
argument_list|)
expr_stmt|;
name|me
operator|.
name|units
operator|++
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Module glue -- drain the callout structure, destroy the  * hash table and its element, and free the descriptor.  */
end_comment

begin_function
specifier|static
name|void
name|g_rr_fini
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|g_rr_softc
modifier|*
name|sc
init|=
name|data
decl_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_wait
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_active
operator|==
name|NULL
argument_list|,
operator|(
literal|"still a queue under service"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_rr_tailq
argument_list|)
argument_list|,
operator|(
literal|"still scheduled queues"
operator|)
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sc
argument_list|,
name|sc_next
argument_list|)
expr_stmt|;
name|me
operator|.
name|units
operator|--
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_GEOM_SCHED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when the request under service terminates.  * Start the anticipation timer if needed.  */
end_comment

begin_function
specifier|static
name|void
name|g_rr_done
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_rr_softc
modifier|*
name|sc
init|=
name|data
decl_stmt|;
name|struct
name|g_rr_queue
modifier|*
name|qp
decl_stmt|;
name|sc
operator|->
name|sc_in_flight
operator|--
expr_stmt|;
name|qp
operator|=
name|bp
operator|->
name|bio_caller1
expr_stmt|;
comment|/* 	 * When the first request for this queue completes, update the 	 * duration and end of the slice. We do not do it when the 	 * slice starts to avoid charging to the queue the time for 	 * the first seek. 	 */
if|if
condition|(
operator|!
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|G_FLAG_COMPLETED
operator|)
condition|)
block|{
name|qp
operator|->
name|q_flags
operator||=
name|G_FLAG_COMPLETED
expr_stmt|;
comment|/* 		 * recompute the slice duration, in case we want 		 * to make it adaptive. This is not used right now. 		 * XXX should we do the same for q_quantum and q_wait_ticks ? 		 */
name|qp
operator|->
name|q_slice_duration
operator|=
name|get_bounded
argument_list|(
operator|&
name|me
operator|.
name|quantum_ms
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_slice_end
operator|=
name|ticks
operator|+
name|qp
operator|->
name|q_slice_duration
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|==
name|sc
operator|->
name|sc_active
operator|&&
name|qp
operator|->
name|q_status
operator|==
name|G_QUEUE_BUSY
condition|)
block|{
comment|/* The queue is trying anticipation, start the timer. */
name|qp
operator|->
name|q_status
operator|=
name|G_QUEUE_IDLING
expr_stmt|;
comment|/* may make this adaptive */
name|qp
operator|->
name|q_wait_ticks
operator|=
name|get_bounded
argument_list|(
operator|&
name|me
operator|.
name|wait_ms
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|me
operator|.
name|wait_hit
operator|++
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_wait
argument_list|,
name|qp
operator|->
name|q_wait_ticks
argument_list|,
name|g_rr_wait_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|g_sched_dispatch
argument_list|(
name|sc
operator|->
name|sc_geom
argument_list|)
expr_stmt|;
comment|/* Release a reference to the queue. */
name|g_rr_queue_put
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_rr_dumpconf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|)
block|{
if|if
condition|(
name|indent
operator|==
name|NULL
condition|)
block|{
comment|/* plaintext */
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" units %d queues %d"
argument_list|,
name|me
operator|.
name|units
argument_list|,
name|me
operator|.
name|queues
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|g_gsched
name|g_rr
init|=
block|{
operator|.
name|gs_name
operator|=
literal|"rr"
block|,
operator|.
name|gs_priv_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|g_rr_queue
argument_list|)
block|,
operator|.
name|gs_init
operator|=
name|g_rr_init
block|,
operator|.
name|gs_fini
operator|=
name|g_rr_fini
block|,
operator|.
name|gs_start
operator|=
name|g_rr_start
block|,
operator|.
name|gs_done
operator|=
name|g_rr_done
block|,
operator|.
name|gs_next
operator|=
name|g_rr_next
block|,
operator|.
name|gs_dumpconf
operator|=
name|g_rr_dumpconf
block|,
operator|.
name|gs_init_class
operator|=
name|g_rr_init_class
block|,
operator|.
name|gs_fini_class
operator|=
name|g_rr_fini_class
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_GSCHED_MODULE
argument_list|(
name|rr
argument_list|,
operator|&
name|g_rr
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

