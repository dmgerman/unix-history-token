begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002 Marcel Moolenaar  * Copyright (c) 2002 Poul-Henning Kamp  * Copyright (c) 2002 Networks Associates Technology, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The names of the authors may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/uuid.h>
end_include

begin_include
include|#
directive|include
file|<sys/gpt.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom_slice.h>
end_include

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|gpt_hdr
argument_list|,
name|padding
argument_list|)
operator|==
literal|92
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gpt_ent
argument_list|)
operator|==
literal|128
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * XXX: GEOM is not dynamic enough. We are forced to use a compile-time  * limit. The minimum number of partitions (128) as required by EFI is  * most of the time just a waste of space.  */
end_comment

begin_define
define|#
directive|define
name|GPT_MAX_SLICES
value|128
end_define

begin_struct
struct|struct
name|g_gpt_softc
block|{
name|struct
name|gpt_ent
modifier|*
name|part
index|[
name|GPT_MAX_SLICES
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|is_gpt_hdr
parameter_list|(
name|struct
name|gpt_hdr
modifier|*
name|hdr
parameter_list|)
block|{
name|uint32_t
name|crc
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|hdr
operator|->
name|hdr_sig
argument_list|,
name|GPT_HDR_SIG
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|hdr_sig
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|crc
operator|=
name|hdr
operator|->
name|hdr_crc_self
expr_stmt|;
name|hdr
operator|->
name|hdr_crc_self
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|crc32
argument_list|(
name|hdr
argument_list|,
name|hdr
operator|->
name|hdr_size
argument_list|)
operator|!=
name|crc
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|hdr
operator|->
name|hdr_crc_self
operator|=
name|crc
expr_stmt|;
comment|/* We're happy... */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_gpt_start
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|uuid
name|freebsd
init|=
name|GPT_ENT_TYPE_FREEBSD
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
init|=
name|bp
operator|->
name|bio_to
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
init|=
name|pp
operator|->
name|geom
decl_stmt|;
name|struct
name|g_slicer
modifier|*
name|gsp
init|=
name|gp
operator|->
name|softc
decl_stmt|;
name|struct
name|g_gpt_softc
modifier|*
name|gs
init|=
name|gsp
operator|->
name|softc
decl_stmt|;
name|u_int
name|type
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|!=
name|BIO_GETATTR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * XXX: this is bogus. The BSD class has a strong dependency on 	 * the MBR/MBREXT class, because it asks for an attribute that's 	 * specific to the MBR/MBREXT class and the value of the attribute 	 * is just as specific to the MBR class. In an extensible scheme 	 * a geom would ask another geom if it could possible accomodate a 	 * class and the answer should be yes or no. Now we're forced to 	 * emulate a MBR class :-/ 	 */
name|type
operator|=
operator|(
name|memcmp
argument_list|(
operator|&
name|gs
operator|->
name|part
index|[
name|pp
operator|->
name|index
index|]
operator|->
name|ent_type
argument_list|,
operator|&
name|freebsd
argument_list|,
sizeof|sizeof
argument_list|(
name|freebsd
argument_list|)
argument_list|)
operator|)
condition|?
literal|0
else|:
literal|165
expr_stmt|;
return|return
operator|(
operator|(
name|g_handleattr_int
argument_list|(
name|bp
argument_list|,
literal|"MBR::type"
argument_list|,
name|type
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_gpt_dumpconf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|)
block|{
name|struct
name|g_slicer
modifier|*
name|gsp
init|=
name|gp
operator|->
name|softc
decl_stmt|;
name|struct
name|g_gpt_softc
modifier|*
name|gs
init|=
name|gsp
operator|->
name|softc
decl_stmt|;
name|struct
name|uuid
modifier|*
name|uuid
decl_stmt|;
name|g_slice_dumpconf
argument_list|(
name|sb
argument_list|,
name|indent
argument_list|,
name|gp
argument_list|,
name|cp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|!=
name|NULL
condition|)
block|{
name|uuid
operator|=
operator|&
name|gs
operator|->
name|part
index|[
name|pp
operator|->
name|index
index|]
operator|->
name|ent_type
expr_stmt|;
if|if
condition|(
name|indent
operator|!=
name|NULL
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<type>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" ty "
argument_list|)
expr_stmt|;
name|sbuf_printf_uuid
argument_list|(
name|sb
argument_list|,
name|uuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|indent
operator|!=
name|NULL
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</type>\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|g_geom
modifier|*
name|g_gpt_taste
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|insist
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_gpt_softc
modifier|*
name|gs
decl_stmt|;
name|struct
name|g_slicer
modifier|*
name|gsp
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|mbr
decl_stmt|;
name|struct
name|gpt_ent
modifier|*
name|ent
decl_stmt|;
name|struct
name|gpt_hdr
modifier|*
name|hdr
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|npart
decl_stmt|,
name|secsz
decl_stmt|,
name|tblsz
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ps
decl_stmt|;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"g_gpt_taste(%s,%s)"
argument_list|,
name|mp
operator|->
name|name
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
comment|/* 	 * XXX: I don't like to hardcode a maximum number of slices, since 	 * it's wasting space most of the time and insufficient any time. 	 * It's easier for now... 	 */
name|gp
operator|=
name|g_slice_new
argument_list|(
name|mp
argument_list|,
name|GPT_MAX_SLICES
argument_list|,
name|pp
argument_list|,
operator|&
name|cp
argument_list|,
operator|&
name|gs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gs
argument_list|)
argument_list|,
name|g_gpt_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|gsp
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|gp
operator|->
name|dumpconf
operator|=
name|g_gpt_dumpconf
expr_stmt|;
do|do
block|{
name|npart
operator|=
literal|0
expr_stmt|;
name|mbr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|gp
operator|->
name|rank
operator|!=
literal|2
operator|&&
name|insist
operator|==
literal|0
condition|)
break|break;
name|secsz
operator|=
name|cp
operator|->
name|provider
operator|->
name|sectorsize
expr_stmt|;
if|if
condition|(
name|secsz
operator|<
literal|512
condition|)
break|break;
comment|/* XXX: we need to get the media size as well. */
comment|/* Read both the MBR sector and the GPT sector. */
name|mbr
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
name|secsz
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbr
operator|==
name|NULL
operator|||
name|error
operator|!=
literal|0
condition|)
break|break;
if|#
directive|if
literal|0
comment|/* 	 * XXX: we should ignore the GPT if there's a MBR and the MBR is 	 * not a PMBR (Protective MBR). I believe this is what the EFI 	 * spec is going to say eventually (this is hearsay :-) 	 * Currently EFI (version 1.02) accepts and uses the GPT even 	 * though there's a valid MBR. We do this too, because it allows 	 * us to test this code without first nuking the only partitioning 	 * scheme we grok until this is working. 	 */
block|if (!is_pmbr((void*)mbr)) 		goto out;
endif|#
directive|endif
name|hdr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|mbr
operator|+
name|secsz
operator|)
expr_stmt|;
comment|/* 	 * XXX: if we don't have a GPT header at LBA 1, we should check if 	 * there's a backup GPT at the end of the medium. If we have a valid 	 * backup GPT, we should restore the primary GPT and claim this lunch. 	 */
if|if
condition|(
operator|!
name|is_gpt_hdr
argument_list|(
name|hdr
argument_list|)
condition|)
break|break;
name|tblsz
operator|=
operator|(
name|hdr
operator|->
name|hdr_entries
operator|*
name|hdr
operator|->
name|hdr_entsz
operator|+
name|secsz
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|secsz
operator|-
literal|1
operator|)
expr_stmt|;
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|hdr
operator|->
name|hdr_lba_table
operator|*
name|secsz
argument_list|,
name|tblsz
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|hdr_entries
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|uuid
name|unused
init|=
name|GPT_ENT_TYPE_UNUSED
decl_stmt|;
name|struct
name|uuid
name|freebsd
init|=
name|GPT_ENT_TYPE_FREEBSD
decl_stmt|;
if|if
condition|(
name|i
operator|>=
name|GPT_MAX_SLICES
condition|)
break|break;
name|ent
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|buf
operator|+
name|i
operator|*
name|hdr
operator|->
name|hdr_entsz
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
operator|&
name|ent
operator|->
name|ent_type
argument_list|,
operator|&
name|unused
argument_list|,
sizeof|sizeof
argument_list|(
name|unused
argument_list|)
argument_list|)
condition|)
continue|continue;
name|gs
operator|->
name|part
index|[
name|i
index|]
operator|=
name|g_malloc
argument_list|(
name|hdr
operator|->
name|hdr_entsz
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|gs
operator|->
name|part
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
name|bcopy
argument_list|(
name|ent
argument_list|,
name|gs
operator|->
name|part
index|[
name|i
index|]
argument_list|,
name|hdr
operator|->
name|hdr_entsz
argument_list|)
expr_stmt|;
name|ps
operator|=
operator|(
operator|!
name|memcmp
argument_list|(
operator|&
name|ent
operator|->
name|ent_type
argument_list|,
operator|&
name|freebsd
argument_list|,
sizeof|sizeof
argument_list|(
name|freebsd
argument_list|)
argument_list|)
operator|)
condition|?
literal|'s'
else|:
literal|'p'
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|g_slice_config
argument_list|(
name|gp
argument_list|,
name|i
argument_list|,
name|G_SLICE_CONFIG_SET
argument_list|,
name|ent
operator|->
name|ent_lba_start
operator|*
name|secsz
argument_list|,
operator|(
literal|1
operator|+
name|ent
operator|->
name|ent_lba_end
operator|-
name|ent
operator|->
name|ent_lba_start
operator|)
operator|*
name|secsz
argument_list|,
name|secsz
argument_list|,
literal|"%s%c%d"
argument_list|,
name|gp
operator|->
name|name
argument_list|,
name|ps
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|npart
operator|++
expr_stmt|;
block|}
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
if|if
condition|(
name|mbr
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|mbr
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_access_rel
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|gp
operator|->
name|provider
argument_list|)
condition|)
block|{
name|g_std_spoiled
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|gp
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|g_class
name|g_gpt_class
init|=
block|{
operator|.
name|name
operator|=
literal|"GPT"
block|,
operator|.
name|taste
operator|=
name|g_gpt_taste
block|,
name|G_CLASS_INITIALIZER
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_GEOM_CLASS
argument_list|(
name|g_gpt_class
argument_list|,
name|g_gpt
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

