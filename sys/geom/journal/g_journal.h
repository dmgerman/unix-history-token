begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005-2006 Pawel Jakub Dawidek<pjd@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_G_JOURNAL_H_
end_ifndef

begin_define
define|#
directive|define
name|_G_JOURNAL_H_
end_define

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/md5.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|G_JOURNAL_CLASS_NAME
value|"JOURNAL"
end_define

begin_define
define|#
directive|define
name|G_JOURNAL_MAGIC
value|"GEOM::JOURNAL"
end_define

begin_comment
comment|/*  * Version history:  * 0 - Initial version number.  */
end_comment

begin_define
define|#
directive|define
name|G_JOURNAL_VERSION
value|0
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|g_journal_debug
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GJ_DEBUG
parameter_list|(
name|lvl
parameter_list|,
modifier|...
parameter_list|)
value|do {					\ 	if (g_journal_debug>= (lvl)) {					\ 		printf("GEOM_JOURNAL");					\ 		if (g_journal_debug> 0)				\ 			printf("[%u]", lvl);				\ 		printf(": ");						\ 		printf(__VA_ARGS__);					\ 		printf("\n");						\ 	}								\ } while (0)
end_define

begin_define
define|#
directive|define
name|GJ_LOGREQ
parameter_list|(
name|lvl
parameter_list|,
name|bp
parameter_list|,
modifier|...
parameter_list|)
value|do {					\ 	if (g_journal_debug>= (lvl)) {					\ 		printf("GEOM_JOURNAL");					\ 		if (g_journal_debug> 0)				\ 			printf("[%u]", lvl);				\ 		printf(": ");						\ 		printf(__VA_ARGS__);					\ 		printf(" ");						\ 		g_print_bio(bp);					\ 		printf("\n");						\ 	}								\ } while (0)
end_define

begin_define
define|#
directive|define
name|JEMPTY
parameter_list|(
name|sc
parameter_list|)
value|((sc)->sc_journal_offset -			\ 			 (sc)->sc_jprovider->sectorsize ==		\ 			 (sc)->sc_active.jj_offset&&			\ 			 (sc)->sc_current_count == 0)
end_define

begin_define
define|#
directive|define
name|GJ_BIO_REGULAR
value|0x00
end_define

begin_define
define|#
directive|define
name|GJ_BIO_READ
value|0x01
end_define

begin_define
define|#
directive|define
name|GJ_BIO_JOURNAL
value|0x02
end_define

begin_define
define|#
directive|define
name|GJ_BIO_COPY
value|0x03
end_define

begin_define
define|#
directive|define
name|GJ_BIO_MASK
value|0x0f
end_define

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|GJF_BIO_DONT_FREE
value|0x10
end_define

begin_define
define|#
directive|define
name|GJF_BIO_MASK
value|0xf0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|GJF_DEVICE_HARDCODED
value|0x0001
end_define

begin_define
define|#
directive|define
name|GJF_DEVICE_DESTROY
value|0x0010
end_define

begin_define
define|#
directive|define
name|GJF_DEVICE_SWITCH
value|0x0020
end_define

begin_define
define|#
directive|define
name|GJF_DEVICE_BEFORE_SWITCH
value|0x0040
end_define

begin_define
define|#
directive|define
name|GJF_DEVICE_CLEAN
value|0x0080
end_define

begin_define
define|#
directive|define
name|GJF_DEVICE_CHECKSUM
value|0x0100
end_define

begin_define
define|#
directive|define
name|GJ_HARD_LIMIT
value|64
end_define

begin_comment
comment|/*  * We keep pointers to journaled data in bio structure and because we  * need to store two off_t values (offset in data provider and offset in  * journal), we have to borrow bio_completed field for this.  */
end_comment

begin_define
define|#
directive|define
name|bio_joffset
value|bio_completed
end_define

begin_comment
comment|/*  * Use bio_caller1 field as a pointer in queue.  */
end_comment

begin_define
define|#
directive|define
name|bio_next
value|bio_caller1
end_define

begin_comment
comment|/*  * There are two such structures maintained inside each journaled device.  * One describes active part of the journal, were recent requests are stored.  * The second describes the last consistent part of the journal with requests  * that are copied to the destination provider.  */
end_comment

begin_struct
struct|struct
name|g_journal_journal
block|{
name|struct
name|bio
modifier|*
name|jj_queue
decl_stmt|;
comment|/* Cached journal entries. */
name|off_t
name|jj_offset
decl_stmt|;
comment|/* Journal's start offset. */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|g_journal_softc
block|{
name|uint32_t
name|sc_id
decl_stmt|;
name|uint8_t
name|sc_type
decl_stmt|;
name|uint8_t
name|sc_orig_type
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|sc_geom
decl_stmt|;
name|u_int
name|sc_flags
decl_stmt|;
name|struct
name|mtx
name|sc_mtx
decl_stmt|;
name|off_t
name|sc_mediasize
decl_stmt|;
name|u_int
name|sc_sectorsize
decl_stmt|;
define|#
directive|define
name|GJ_FLUSH_DATA
value|0x01
define|#
directive|define
name|GJ_FLUSH_JOURNAL
value|0x02
name|u_int
name|sc_bio_flush
decl_stmt|;
name|uint32_t
name|sc_journal_id
decl_stmt|;
name|uint32_t
name|sc_journal_next_id
decl_stmt|;
name|int
name|sc_journal_copying
decl_stmt|;
name|off_t
name|sc_journal_offset
decl_stmt|;
name|off_t
name|sc_journal_previous_id
decl_stmt|;
name|struct
name|bio_queue_head
name|sc_back_queue
decl_stmt|;
name|struct
name|bio_queue_head
name|sc_regular_queue
decl_stmt|;
name|struct
name|bio_queue_head
name|sc_delayed_queue
decl_stmt|;
name|int
name|sc_delayed_count
decl_stmt|;
name|struct
name|bio
modifier|*
name|sc_current_queue
decl_stmt|;
name|int
name|sc_current_count
decl_stmt|;
name|struct
name|bio
modifier|*
name|sc_flush_queue
decl_stmt|;
name|int
name|sc_flush_count
decl_stmt|;
name|int
name|sc_flush_in_progress
decl_stmt|;
name|struct
name|bio
modifier|*
name|sc_copy_queue
decl_stmt|;
name|int
name|sc_copy_in_progress
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|sc_dconsumer
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|sc_jconsumer
decl_stmt|;
name|struct
name|g_journal_journal
name|sc_inactive
decl_stmt|;
name|struct
name|g_journal_journal
name|sc_active
decl_stmt|;
name|off_t
name|sc_jstart
decl_stmt|;
comment|/* Journal space start offset. */
name|off_t
name|sc_jend
decl_stmt|;
comment|/* Journal space end offset. */
name|struct
name|callout
name|sc_callout
decl_stmt|;
name|struct
name|proc
modifier|*
name|sc_worker
decl_stmt|;
name|struct
name|root_hold_token
modifier|*
name|sc_rootmount
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|sc_dprovider
value|sc_dconsumer->provider
end_define

begin_define
define|#
directive|define
name|sc_jprovider
value|sc_jconsumer->provider
end_define

begin_define
define|#
directive|define
name|sc_name
value|sc_dprovider->name
end_define

begin_define
define|#
directive|define
name|GJQ_INSERT_HEAD
parameter_list|(
name|head
parameter_list|,
name|bp
parameter_list|)
value|do {				\ 	(bp)->bio_next = (head);					\ 	(head) = (bp);							\ } while (0)
end_define

begin_define
define|#
directive|define
name|GJQ_INSERT_AFTER
parameter_list|(
name|head
parameter_list|,
name|bp
parameter_list|,
name|pbp
parameter_list|)
value|do {				\ 	if ((pbp) == NULL)						\ 		GJQ_INSERT_HEAD(head, bp);				\ 	else {								\ 		(bp)->bio_next = (pbp)->bio_next;			\ 		(pbp)->bio_next = (bp);					\ 	}								\ } while (0)
end_define

begin_define
define|#
directive|define
name|GJQ_LAST
parameter_list|(
name|head
parameter_list|,
name|bp
parameter_list|)
value|do {						\ 	struct bio *_bp;						\ 									\ 	if ((head) == NULL) {						\ 		(bp) = (head);						\ 		break;							\ 	}								\ 	for (_bp = (head); _bp->bio_next != NULL; _bp = _bp->bio_next)	\ 		continue;						\ 	(bp) = (_bp);							\ } while (0)
end_define

begin_define
define|#
directive|define
name|GJQ_FIRST
parameter_list|(
name|head
parameter_list|)
value|(head)
end_define

begin_define
define|#
directive|define
name|GJQ_REMOVE
parameter_list|(
name|head
parameter_list|,
name|bp
parameter_list|)
value|do {					\ 	struct bio *_bp;						\ 									\ 	if ((head) == (bp)) {						\ 		(head) = (bp)->bio_next;				\ 		(bp)->bio_next = NULL;					\ 		break;							\ 	}								\ 	for (_bp = (head); _bp->bio_next != NULL; _bp = _bp->bio_next) {\ 		if (_bp->bio_next == (bp))				\ 			break;						\ 	}								\ 	KASSERT(_bp->bio_next != NULL, ("NULL bio_next"));		\ 	KASSERT(_bp->bio_next == (bp), ("bio_next != bp"));		\ 	_bp->bio_next = (bp)->bio_next;					\ 	(bp)->bio_next = NULL;						\ } while (0)
end_define

begin_define
define|#
directive|define
name|GJQ_FOREACH
parameter_list|(
name|head
parameter_list|,
name|bp
parameter_list|)
define|\
value|for ((bp) = (head); (bp) != NULL; (bp) = (bp)->bio_next)
end_define

begin_define
define|#
directive|define
name|GJ_HEADER_MAGIC
value|"GJHDR"
end_define

begin_struct
struct|struct
name|g_journal_header
block|{
name|char
name|jh_magic
index|[
sizeof|sizeof
argument_list|(
name|GJ_HEADER_MAGIC
argument_list|)
index|]
decl_stmt|;
name|uint32_t
name|jh_journal_id
decl_stmt|;
name|uint32_t
name|jh_journal_next_id
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_struct
struct|struct
name|g_journal_entry
block|{
name|uint64_t
name|je_joffset
decl_stmt|;
name|uint64_t
name|je_offset
decl_stmt|;
name|uint64_t
name|je_length
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_define
define|#
directive|define
name|GJ_RECORD_HEADER_MAGIC
value|"GJRHDR"
end_define

begin_define
define|#
directive|define
name|GJ_RECORD_HEADER_NENTRIES
value|(20)
end_define

begin_define
define|#
directive|define
name|GJ_RECORD_MAX_SIZE
parameter_list|(
name|sc
parameter_list|)
define|\
value|((sc)->sc_jprovider->sectorsize + GJ_RECORD_HEADER_NENTRIES * MAXPHYS)
end_define

begin_define
define|#
directive|define
name|GJ_VALIDATE_OFFSET
parameter_list|(
name|offset
parameter_list|,
name|sc
parameter_list|)
value|do {				\ 	if ((offset) + GJ_RECORD_MAX_SIZE(sc)>= (sc)->sc_jend) {	\ 		(offset) = (sc)->sc_jstart;				\ 		GJ_DEBUG(2, "Starting from the beginning (%s).",		\ 		    (sc)->sc_name);					\ 	}								\ } while (0)
end_define

begin_struct
struct|struct
name|g_journal_record_header
block|{
name|char
name|jrh_magic
index|[
sizeof|sizeof
argument_list|(
name|GJ_RECORD_HEADER_MAGIC
argument_list|)
index|]
decl_stmt|;
name|uint32_t
name|jrh_journal_id
decl_stmt|;
name|uint16_t
name|jrh_nentries
decl_stmt|;
name|u_char
name|jrh_sum
index|[
literal|8
index|]
decl_stmt|;
name|struct
name|g_journal_entry
name|jrh_entries
index|[
name|GJ_RECORD_HEADER_NENTRIES
index|]
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_typedef
typedef|typedef
name|int
function_decl|(
name|g_journal_clean_t
function_decl|)
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|void
function_decl|(
name|g_journal_dirty_t
function_decl|)
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|g_journal_desc
block|{
specifier|const
name|char
modifier|*
name|jd_fstype
decl_stmt|;
name|g_journal_clean_t
modifier|*
name|jd_clean
decl_stmt|;
name|g_journal_dirty_t
modifier|*
name|jd_dirty
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Supported file systems. */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|g_journal_desc
name|g_journal_ufs
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|GJ_TIMER_START
parameter_list|(
name|lvl
parameter_list|,
name|bt
parameter_list|)
value|do {					\ 	if (g_journal_debug>= (lvl))					\ 		binuptime(bt);						\ } while (0)
end_define

begin_define
define|#
directive|define
name|GJ_TIMER_STOP
parameter_list|(
name|lvl
parameter_list|,
name|bt
parameter_list|,
modifier|...
parameter_list|)
value|do {				\ 	if (g_journal_debug>= (lvl)) {					\ 		struct bintime _bt2;					\ 		struct timeval _tv;					\ 									\ 		binuptime(&_bt2);					\ 		bintime_sub(&_bt2, bt);					\ 		bintime2timeval(&_bt2,&_tv);				\ 		printf("GEOM_JOURNAL");					\ 		if (g_journal_debug> 0)				\ 			printf("[%u]", lvl);				\ 		printf(": ");						\ 		printf(__VA_ARGS__);					\ 		printf(": %jd.%06jds\n", (intmax_t)_tv.tv_sec,		\ 		    (intmax_t)_tv.tv_usec);				\ 	}								\ } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_define
define|#
directive|define
name|GJ_TYPE_DATA
value|0x01
end_define

begin_define
define|#
directive|define
name|GJ_TYPE_JOURNAL
value|0x02
end_define

begin_define
define|#
directive|define
name|GJ_TYPE_COMPLETE
value|(GJ_TYPE_DATA|GJ_TYPE_JOURNAL)
end_define

begin_define
define|#
directive|define
name|GJ_FLAG_CLEAN
value|0x01
end_define

begin_define
define|#
directive|define
name|GJ_FLAG_CHECKSUM
value|0x02
end_define

begin_struct
struct|struct
name|g_journal_metadata
block|{
name|char
name|md_magic
index|[
literal|16
index|]
decl_stmt|;
comment|/* Magic value. */
name|uint32_t
name|md_version
decl_stmt|;
comment|/* Version number. */
name|uint32_t
name|md_id
decl_stmt|;
comment|/* Journal unique ID. */
name|uint8_t
name|md_type
decl_stmt|;
comment|/* Provider type. */
name|uint64_t
name|md_jstart
decl_stmt|;
comment|/* Journal space start offset. */
name|uint64_t
name|md_jend
decl_stmt|;
comment|/* Journal space end offset. */
name|uint64_t
name|md_joffset
decl_stmt|;
comment|/* Last known consistent journal offset. */
name|uint32_t
name|md_jid
decl_stmt|;
comment|/* Last known consistent journal ID. */
name|uint64_t
name|md_flags
decl_stmt|;
comment|/* Journal flags. */
name|char
name|md_provider
index|[
literal|16
index|]
decl_stmt|;
comment|/* Hardcoded provider. */
name|uint64_t
name|md_provsize
decl_stmt|;
comment|/* Provider's size. */
name|u_char
name|md_hash
index|[
literal|16
index|]
decl_stmt|;
comment|/* MD5 hash. */
block|}
struct|;
end_struct

begin_function
specifier|static
name|__inline
name|void
name|journal_metadata_encode
parameter_list|(
name|struct
name|g_journal_metadata
modifier|*
name|md
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
name|MD5_CTX
name|ctx
decl_stmt|;
name|bcopy
argument_list|(
name|md
operator|->
name|md_magic
argument_list|,
name|data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
name|data
operator|+
literal|16
argument_list|,
name|md
operator|->
name|md_version
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
name|data
operator|+
literal|20
argument_list|,
name|md
operator|->
name|md_id
argument_list|)
expr_stmt|;
operator|*
operator|(
name|data
operator|+
literal|24
operator|)
operator|=
name|md
operator|->
name|md_type
expr_stmt|;
name|le64enc
argument_list|(
name|data
operator|+
literal|25
argument_list|,
name|md
operator|->
name|md_jstart
argument_list|)
expr_stmt|;
name|le64enc
argument_list|(
name|data
operator|+
literal|33
argument_list|,
name|md
operator|->
name|md_jend
argument_list|)
expr_stmt|;
name|le64enc
argument_list|(
name|data
operator|+
literal|41
argument_list|,
name|md
operator|->
name|md_joffset
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
name|data
operator|+
literal|49
argument_list|,
name|md
operator|->
name|md_jid
argument_list|)
expr_stmt|;
name|le64enc
argument_list|(
name|data
operator|+
literal|53
argument_list|,
name|md
operator|->
name|md_flags
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|md
operator|->
name|md_provider
argument_list|,
name|data
operator|+
literal|61
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|le64enc
argument_list|(
name|data
operator|+
literal|77
argument_list|,
name|md
operator|->
name|md_provsize
argument_list|)
expr_stmt|;
name|MD5Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|data
argument_list|,
literal|85
argument_list|)
expr_stmt|;
name|MD5Final
argument_list|(
name|md
operator|->
name|md_hash
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|md
operator|->
name|md_hash
argument_list|,
name|data
operator|+
literal|85
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|journal_metadata_decode_v0
parameter_list|(
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|struct
name|g_journal_metadata
modifier|*
name|md
parameter_list|)
block|{
name|MD5_CTX
name|ctx
decl_stmt|;
name|md
operator|->
name|md_id
operator|=
name|le32dec
argument_list|(
name|data
operator|+
literal|20
argument_list|)
expr_stmt|;
name|md
operator|->
name|md_type
operator|=
operator|*
operator|(
name|data
operator|+
literal|24
operator|)
expr_stmt|;
name|md
operator|->
name|md_jstart
operator|=
name|le64dec
argument_list|(
name|data
operator|+
literal|25
argument_list|)
expr_stmt|;
name|md
operator|->
name|md_jend
operator|=
name|le64dec
argument_list|(
name|data
operator|+
literal|33
argument_list|)
expr_stmt|;
name|md
operator|->
name|md_joffset
operator|=
name|le64dec
argument_list|(
name|data
operator|+
literal|41
argument_list|)
expr_stmt|;
name|md
operator|->
name|md_jid
operator|=
name|le32dec
argument_list|(
name|data
operator|+
literal|49
argument_list|)
expr_stmt|;
name|md
operator|->
name|md_flags
operator|=
name|le64dec
argument_list|(
name|data
operator|+
literal|53
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|data
operator|+
literal|61
argument_list|,
name|md
operator|->
name|md_provider
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|md
operator|->
name|md_provsize
operator|=
name|le64dec
argument_list|(
name|data
operator|+
literal|77
argument_list|)
expr_stmt|;
name|MD5Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|data
argument_list|,
literal|85
argument_list|)
expr_stmt|;
name|MD5Final
argument_list|(
name|md
operator|->
name|md_hash
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|md
operator|->
name|md_hash
argument_list|,
name|data
operator|+
literal|85
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|journal_metadata_decode
parameter_list|(
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|struct
name|g_journal_metadata
modifier|*
name|md
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|md
operator|->
name|md_magic
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|md
operator|->
name|md_version
operator|=
name|le32dec
argument_list|(
name|data
operator|+
literal|16
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|md
operator|->
name|md_version
condition|)
block|{
case|case
literal|0
case|:
name|error
operator|=
name|journal_metadata_decode_v0
argument_list|(
name|data
argument_list|,
name|md
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|journal_metadata_dump
parameter_list|(
specifier|const
name|struct
name|g_journal_metadata
modifier|*
name|md
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|char
name|hash
index|[
literal|16
operator|*
literal|2
operator|+
literal|1
index|]
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"     magic: %s\n"
argument_list|,
name|md
operator|->
name|md_magic
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   version: %u\n"
argument_list|,
operator|(
name|u_int
operator|)
name|md
operator|->
name|md_version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        id: %u\n"
argument_list|,
operator|(
name|u_int
operator|)
name|md
operator|->
name|md_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      type: %u\n"
argument_list|,
operator|(
name|u_int
operator|)
name|md
operator|->
name|md_type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     start: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|md
operator|->
name|md_jstart
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"       end: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|md
operator|->
name|md_jend
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"   joffset: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|md
operator|->
name|md_joffset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"       jid: %u\n"
argument_list|,
operator|(
name|u_int
operator|)
name|md
operator|->
name|md_jid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     flags: %u\n"
argument_list|,
operator|(
name|u_int
operator|)
name|md
operator|->
name|md_flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"hcprovider: %s\n"
argument_list|,
name|md
operator|->
name|md_provider
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  provsize: %ju\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|md
operator|->
name|md_provsize
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|hash
argument_list|,
sizeof|sizeof
argument_list|(
name|hash
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|hash
index|[
name|i
operator|*
literal|2
index|]
operator|=
name|hex
index|[
name|md
operator|->
name|md_hash
index|[
name|i
index|]
operator|>>
literal|4
index|]
expr_stmt|;
name|hash
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
name|hex
index|[
name|md
operator|->
name|md_hash
index|[
name|i
index|]
operator|&
literal|0x0f
index|]
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"  MD5 hash: %s\n"
argument_list|,
name|hash
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_G_JOURNAL_H_ */
end_comment

end_unit

