begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005-2006 Pawel Jakub Dawidek<pjd@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|GJ_MEMDEBUG
end_ifdef

begin_include
include|#
directive|include
file|<sys/stack.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/journal/g_journal.h>
end_include

begin_comment
comment|/*  * On-disk journal format:  *  * JH - Journal header  * RH - Record header  *  * %%%%%% ****** +------+ +------+     ****** +------+     %%%%%%  * % JH % * RH * | Data | | Data | ... * RH * | Data | ... % JH % ...  * %%%%%% ****** +------+ +------+     ****** +------+     %%%%%%  *  */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|g_journal_header
argument_list|)
operator|<=
literal|512
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|g_journal_record_header
argument_list|)
operator|<=
literal|512
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_JOURNAL
argument_list|,
literal|"journal_data"
argument_list|,
literal|"GEOM_JOURNAL Data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|g_journal_cache_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|g_journal_cache
argument_list|,
operator|&
name|g_journal_cache_mtx
argument_list|,
literal|"cache usage"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|struct
name|g_journal_desc
modifier|*
name|g_journal_filesystems
index|[]
init|=
block|{
operator|&
name|g_journal_ufs
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_kern_geom
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|g_journal_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.geom.journal.debug"
argument_list|,
operator|&
name|g_journal_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_journal_switch_time
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_journal_force_switch
init|=
literal|70
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_journal_parallel_flushes
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_journal_parallel_copies
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_journal_accept_immediately
init|=
literal|64
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_journal_record_entries
init|=
name|GJ_RECORD_HEADER_NENTRIES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_journal_do_optimize
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern_geom
argument_list|,
name|OID_AUTO
argument_list|,
name|journal
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"GEOM_JOURNAL stuff"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_geom_journal
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_journal_debug
argument_list|,
literal|0
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_journal
argument_list|,
name|OID_AUTO
argument_list|,
name|switch_time
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_journal_switch_time
argument_list|,
literal|0
argument_list|,
literal|"Switch journals every N seconds"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_journal
argument_list|,
name|OID_AUTO
argument_list|,
name|force_switch
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_journal_force_switch
argument_list|,
literal|0
argument_list|,
literal|"Force switch when journal is N%% full"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_journal
argument_list|,
name|OID_AUTO
argument_list|,
name|parallel_flushes
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_journal_parallel_flushes
argument_list|,
literal|0
argument_list|,
literal|"Number of flush I/O requests send in parallel"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_journal
argument_list|,
name|OID_AUTO
argument_list|,
name|accept_immediately
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_journal_accept_immediately
argument_list|,
literal|0
argument_list|,
literal|"Number of I/O requests accepted immediatelly"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_journal
argument_list|,
name|OID_AUTO
argument_list|,
name|parallel_copies
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_journal_parallel_copies
argument_list|,
literal|0
argument_list|,
literal|"Number of copy I/O requests send in parallel"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|g_journal_record_entries_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|u_int
name|entries
decl_stmt|;
name|int
name|error
decl_stmt|;
name|entries
operator|=
name|g_journal_record_entries
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|entries
argument_list|,
sizeof|sizeof
argument_list|(
name|entries
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|entries
operator|<
literal|1
operator|||
name|entries
operator|>
name|GJ_RECORD_HEADER_NENTRIES
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|g_journal_record_entries
operator|=
name|entries
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_geom_journal
argument_list|,
name|OID_AUTO
argument_list|,
name|record_entries
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|g_journal_record_entries_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Maximum number of entires in one journal record"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_journal
argument_list|,
name|OID_AUTO
argument_list|,
name|optimize
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_journal_do_optimize
argument_list|,
literal|0
argument_list|,
literal|"Try to combine bios on flush and copy"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_journal_cache_used
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_journal_cache_limit
init|=
literal|64
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.geom.journal.cache.limit"
argument_list|,
operator|&
name|g_journal_cache_limit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_journal_cache_divisor
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.geom.journal.cache.divisor"
argument_list|,
operator|&
name|g_journal_cache_divisor
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_journal_cache_switch
init|=
literal|90
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_journal_cache_misses
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_journal_cache_alloc_failures
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_journal_cache_low
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern_geom_journal
argument_list|,
name|OID_AUTO
argument_list|,
name|cache
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"GEOM_JOURNAL cache"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_journal_cache
argument_list|,
name|OID_AUTO
argument_list|,
name|used
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|g_journal_cache_used
argument_list|,
literal|0
argument_list|,
literal|"Number of allocated bytes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|g_journal_cache_limit_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|u_int
name|limit
decl_stmt|;
name|int
name|error
decl_stmt|;
name|limit
operator|=
name|g_journal_cache_limit
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|limit
argument_list|,
sizeof|sizeof
argument_list|(
name|limit
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|g_journal_cache_limit
operator|=
name|limit
expr_stmt|;
name|g_journal_cache_low
operator|=
operator|(
name|limit
operator|/
literal|100
operator|)
operator|*
name|g_journal_cache_switch
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_geom_journal_cache
argument_list|,
name|OID_AUTO
argument_list|,
name|limit
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|g_journal_cache_limit_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Maximum number of allocated bytes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_journal_cache
argument_list|,
name|OID_AUTO
argument_list|,
name|divisor
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|g_journal_cache_divisor
argument_list|,
literal|0
argument_list|,
literal|"(kmem_size / kern.geom.journal.cache.divisor) == cache size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|g_journal_cache_switch_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|u_int
name|cswitch
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cswitch
operator|=
name|g_journal_cache_switch
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|cswitch
argument_list|,
sizeof|sizeof
argument_list|(
name|cswitch
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|cswitch
operator|<
literal|0
operator|||
name|cswitch
operator|>
literal|100
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|g_journal_cache_switch
operator|=
name|cswitch
expr_stmt|;
name|g_journal_cache_low
operator|=
operator|(
name|g_journal_cache_limit
operator|/
literal|100
operator|)
operator|*
name|cswitch
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_macro
name|SYSCTL_PROC
argument_list|(
argument|_kern_geom_journal_cache
argument_list|,
argument|OID_AUTO
argument_list|,
argument|switch
argument_list|,
argument|CTLTYPE_UINT | CTLFLAG_RW
argument_list|,
argument|NULL
argument_list|,
literal|0
argument_list|,
argument|g_journal_cache_switch_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Force switch when we hit this percent of cache use"
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_journal_cache
argument_list|,
name|OID_AUTO
argument_list|,
name|misses
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_journal_cache_misses
argument_list|,
literal|0
argument_list|,
literal|"Number of cache misses"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_journal_cache
argument_list|,
name|OID_AUTO
argument_list|,
name|alloc_failures
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_journal_cache_alloc_failures
argument_list|,
literal|0
argument_list|,
literal|"Memory allocation failures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|g_journal_stats_bytes_skipped
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|g_journal_stats_combined_ios
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|g_journal_stats_switches
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|g_journal_stats_wait_for_copy
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|g_journal_stats_journal_full
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|g_journal_stats_low_mem
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern_geom_journal
argument_list|,
name|OID_AUTO
argument_list|,
name|stats
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"GEOM_JOURNAL statistics"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_kern_geom_journal_stats
argument_list|,
name|OID_AUTO
argument_list|,
name|skipped_bytes
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_journal_stats_bytes_skipped
argument_list|,
literal|0
argument_list|,
literal|"Number of skipped bytes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_kern_geom_journal_stats
argument_list|,
name|OID_AUTO
argument_list|,
name|combined_ios
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_journal_stats_combined_ios
argument_list|,
literal|0
argument_list|,
literal|"Number of combined I/O requests"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_kern_geom_journal_stats
argument_list|,
name|OID_AUTO
argument_list|,
name|switches
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_journal_stats_switches
argument_list|,
literal|0
argument_list|,
literal|"Number of journal switches"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_kern_geom_journal_stats
argument_list|,
name|OID_AUTO
argument_list|,
name|wait_for_copy
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_journal_stats_wait_for_copy
argument_list|,
literal|0
argument_list|,
literal|"Wait for journal copy on switch"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_kern_geom_journal_stats
argument_list|,
name|OID_AUTO
argument_list|,
name|journal_full
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_journal_stats_journal_full
argument_list|,
literal|0
argument_list|,
literal|"Number of times journal was almost full."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_kern_geom_journal_stats
argument_list|,
name|OID_AUTO
argument_list|,
name|low_mem
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_journal_stats_low_mem
argument_list|,
literal|0
argument_list|,
literal|"Number of times low_mem hook was called."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|g_taste_t
name|g_journal_taste
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_ctl_req_t
name|g_journal_config
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_dumpconf_t
name|g_journal_dumpconf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_init_t
name|g_journal_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_fini_t
name|g_journal_fini
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|g_class
name|g_journal_class
init|=
block|{
operator|.
name|name
operator|=
name|G_JOURNAL_CLASS_NAME
block|,
operator|.
name|version
operator|=
name|G_VERSION
block|,
operator|.
name|taste
operator|=
name|g_journal_taste
block|,
operator|.
name|ctlreq
operator|=
name|g_journal_config
block|,
operator|.
name|dumpconf
operator|=
name|g_journal_dumpconf
block|,
operator|.
name|init
operator|=
name|g_journal_init
block|,
operator|.
name|fini
operator|=
name|g_journal_fini
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|g_journal_destroy
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_journal_metadata_update
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_journal_switch_wait
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|GJ_SWITCHER_WORKING
value|0
end_define

begin_define
define|#
directive|define
name|GJ_SWITCHER_DIE
value|1
end_define

begin_define
define|#
directive|define
name|GJ_SWITCHER_DIED
value|2
end_define

begin_decl_stmt
specifier|static
name|int
name|g_journal_switcher_state
init|=
name|GJ_SWITCHER_WORKING
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_journal_switcher_wokenup
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_journal_sync_requested
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GJ_MEMDEBUG
end_ifdef

begin_struct
struct|struct
name|meminfo
block|{
name|size_t
name|mi_size
decl_stmt|;
name|struct
name|stack
name|mi_stack
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * We use our own malloc/realloc/free funtions, so we can collect statistics  * and force journal switch when we're running out of cache.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|gj_malloc
parameter_list|(
name|size_t
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|GJ_MEMDEBUG
name|struct
name|meminfo
modifier|*
name|mi
decl_stmt|;
endif|#
directive|endif
name|mtx_lock
argument_list|(
operator|&
name|g_journal_cache_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_journal_cache_limit
operator|>
literal|0
operator|&&
operator|!
name|g_journal_switcher_wokenup
operator|&&
name|g_journal_cache_used
operator|+
name|size
operator|>
name|g_journal_cache_low
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"No cache, waking up the switcher."
argument_list|)
expr_stmt|;
name|g_journal_switcher_wokenup
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|g_journal_switcher_state
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|M_NOWAIT
operator|)
operator|&&
name|g_journal_cache_limit
operator|>
literal|0
operator|&&
name|g_journal_cache_used
operator|+
name|size
operator|>
name|g_journal_cache_limit
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|g_journal_cache_mtx
argument_list|)
expr_stmt|;
name|g_journal_cache_alloc_failures
operator|++
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|g_journal_cache_used
operator|+=
name|size
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|g_journal_cache_mtx
argument_list|)
expr_stmt|;
name|flags
operator|&=
operator|~
name|M_NOWAIT
expr_stmt|;
ifndef|#
directive|ifndef
name|GJ_MEMDEBUG
name|p
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_JOURNAL
argument_list|,
name|flags
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
else|#
directive|else
name|mi
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mi
argument_list|)
operator|+
name|size
argument_list|,
name|M_JOURNAL
argument_list|,
name|flags
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
name|mi
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|mi
argument_list|)
expr_stmt|;
name|mi
operator|->
name|mi_size
operator|=
name|size
expr_stmt|;
name|stack_save
argument_list|(
operator|&
name|mi
operator|->
name|mi_stack
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gj_free
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|GJ_MEMDEBUG
name|struct
name|meminfo
modifier|*
name|mi
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|p
operator|!=
name|NULL
argument_list|,
operator|(
literal|"p=NULL"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|size
operator|>
literal|0
argument_list|,
operator|(
literal|"size=0"
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|g_journal_cache_mtx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|g_journal_cache_used
operator|>=
name|size
argument_list|,
operator|(
literal|"Freeing too much?"
operator|)
argument_list|)
expr_stmt|;
name|g_journal_cache_used
operator|-=
name|size
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|g_journal_cache_mtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GJ_MEMDEBUG
name|mi
operator|=
name|p
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|u_char
operator|*
operator|)
name|p
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|mi
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|mi
operator|->
name|mi_size
operator|!=
name|size
condition|)
block|{
name|printf
argument_list|(
literal|"GJOURNAL: Size mismatch! %zu != %zu\n"
argument_list|,
name|size
argument_list|,
name|mi
operator|->
name|mi_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"GJOURNAL: Alloc backtrace:\n"
argument_list|)
expr_stmt|;
name|stack_print
argument_list|(
operator|&
name|mi
operator|->
name|mi_stack
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"GJOURNAL: Free backtrace:\n"
argument_list|)
expr_stmt|;
name|kdb_backtrace
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|free
argument_list|(
name|p
argument_list|,
name|M_JOURNAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|gj_realloc
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|oldsize
parameter_list|)
block|{
name|void
modifier|*
name|np
decl_stmt|;
ifndef|#
directive|ifndef
name|GJ_MEMDEBUG
name|mtx_lock
argument_list|(
operator|&
name|g_journal_cache_mtx
argument_list|)
expr_stmt|;
name|g_journal_cache_used
operator|-=
name|oldsize
expr_stmt|;
name|g_journal_cache_used
operator|+=
name|size
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|g_journal_cache_mtx
argument_list|)
expr_stmt|;
name|np
operator|=
name|realloc
argument_list|(
name|p
argument_list|,
name|size
argument_list|,
name|M_JOURNAL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
else|#
directive|else
name|np
operator|=
name|gj_malloc
argument_list|(
name|size
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|p
argument_list|,
name|np
argument_list|,
name|MIN
argument_list|(
name|oldsize
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|gj_free
argument_list|(
name|p
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|np
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_journal_check_overflow
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|)
block|{
name|off_t
name|length
decl_stmt|,
name|used
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_active
operator|.
name|jj_offset
operator|<
name|sc
operator|->
name|sc_inactive
operator|.
name|jj_offset
operator|&&
name|sc
operator|->
name|sc_journal_offset
operator|>=
name|sc
operator|->
name|sc_inactive
operator|.
name|jj_offset
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_active
operator|.
name|jj_offset
operator|>
name|sc
operator|->
name|sc_inactive
operator|.
name|jj_offset
operator|&&
name|sc
operator|->
name|sc_journal_offset
operator|>=
name|sc
operator|->
name|sc_inactive
operator|.
name|jj_offset
operator|&&
name|sc
operator|->
name|sc_journal_offset
operator|<
name|sc
operator|->
name|sc_active
operator|.
name|jj_offset
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"Journal overflow (joffset=%jd active=%jd inactive=%jd)"
argument_list|,
operator|(
name|intmax_t
operator|)
name|sc
operator|->
name|sc_journal_offset
argument_list|,
operator|(
name|intmax_t
operator|)
name|sc
operator|->
name|sc_active
operator|.
name|jj_offset
argument_list|,
operator|(
name|intmax_t
operator|)
name|sc
operator|->
name|sc_inactive
operator|.
name|jj_offset
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_active
operator|.
name|jj_offset
operator|<
name|sc
operator|->
name|sc_inactive
operator|.
name|jj_offset
condition|)
block|{
name|length
operator|=
name|sc
operator|->
name|sc_inactive
operator|.
name|jj_offset
operator|-
name|sc
operator|->
name|sc_active
operator|.
name|jj_offset
expr_stmt|;
name|used
operator|=
name|sc
operator|->
name|sc_journal_offset
operator|-
name|sc
operator|->
name|sc_active
operator|.
name|jj_offset
expr_stmt|;
block|}
else|else
block|{
name|length
operator|=
name|sc
operator|->
name|sc_jend
operator|-
name|sc
operator|->
name|sc_active
operator|.
name|jj_offset
expr_stmt|;
name|length
operator|+=
name|sc
operator|->
name|sc_inactive
operator|.
name|jj_offset
operator|-
name|sc
operator|->
name|sc_jstart
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_journal_offset
operator|>=
name|sc
operator|->
name|sc_active
operator|.
name|jj_offset
condition|)
name|used
operator|=
name|sc
operator|->
name|sc_journal_offset
operator|-
name|sc
operator|->
name|sc_active
operator|.
name|jj_offset
expr_stmt|;
else|else
block|{
name|used
operator|=
name|sc
operator|->
name|sc_jend
operator|-
name|sc
operator|->
name|sc_active
operator|.
name|jj_offset
expr_stmt|;
name|used
operator|+=
name|sc
operator|->
name|sc_journal_offset
operator|-
name|sc
operator|->
name|sc_jstart
expr_stmt|;
block|}
block|}
comment|/* Already woken up? */
if|if
condition|(
name|g_journal_switcher_wokenup
condition|)
return|return;
comment|/* 	 * If the active journal takes more than g_journal_force_switch precent 	 * of free journal space, we force journal switch. 	 */
name|KASSERT
argument_list|(
name|length
operator|>
literal|0
argument_list|,
operator|(
literal|"length=%jd used=%jd active=%jd inactive=%jd joffset=%jd"
operator|,
operator|(
name|intmax_t
operator|)
name|length
operator|,
operator|(
name|intmax_t
operator|)
name|used
operator|,
operator|(
name|intmax_t
operator|)
name|sc
operator|->
name|sc_active
operator|.
name|jj_offset
operator|,
operator|(
name|intmax_t
operator|)
name|sc
operator|->
name|sc_inactive
operator|.
name|jj_offset
operator|,
operator|(
name|intmax_t
operator|)
name|sc
operator|->
name|sc_journal_offset
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|used
operator|*
literal|100
operator|)
operator|/
name|length
operator|>
name|g_journal_force_switch
condition|)
block|{
name|g_journal_stats_journal_full
operator|++
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Journal %s %jd%% full, forcing journal switch."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
operator|(
name|used
operator|*
literal|100
operator|)
operator|/
name|length
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|g_journal_cache_mtx
argument_list|)
expr_stmt|;
name|g_journal_switcher_wokenup
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|g_journal_switcher_state
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|g_journal_cache_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_journal_orphan
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_journal_softc
modifier|*
name|sc
decl_stmt|;
name|char
name|name
index|[
literal|256
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|sc
operator|=
name|cp
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|strlcpy
argument_list|(
name|name
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Lost provider %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|error
operator|=
name|g_journal_destroy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Journal %s destroyed."
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot destroy journal %s (error=%d). "
literal|"Destroy it manually after last close."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|g_journal_access
parameter_list|(
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|acr
parameter_list|,
name|int
name|acw
parameter_list|,
name|int
name|ace
parameter_list|)
block|{
name|struct
name|g_journal_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|dcr
decl_stmt|,
name|dcw
decl_stmt|,
name|dce
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Access request for %s: r%dw%de%d."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|acr
argument_list|,
name|acw
argument_list|,
name|ace
argument_list|)
expr_stmt|;
name|dcr
operator|=
name|pp
operator|->
name|acr
operator|+
name|acr
expr_stmt|;
name|dcw
operator|=
name|pp
operator|->
name|acw
operator|+
name|acw
expr_stmt|;
name|dce
operator|=
name|pp
operator|->
name|ace
operator|+
name|ace
expr_stmt|;
name|sc
operator|=
name|pp
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|GJF_DEVICE_DESTROY
operator|)
condition|)
block|{
if|if
condition|(
name|acr
operator|<=
literal|0
operator|&&
name|acw
operator|<=
literal|0
operator|&&
name|ace
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|pp
operator|->
name|acw
operator|==
literal|0
operator|&&
name|dcw
operator|>
literal|0
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Marking %s as dirty."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|GJF_DEVICE_CLEAN
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|g_journal_metadata_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
block|}
comment|/* else if (pp->acw == 0&& dcw> 0&& JEMPTY(sc)) { 		GJ_DEBUG(1, "Marking %s as clean.", sc->sc_name); 		sc->sc_flags |= GJF_DEVICE_CLEAN; 		g_topology_unlock(); 		g_journal_metadata_update(sc); 		g_topology_lock(); 	} */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_journal_header_encode
parameter_list|(
name|struct
name|g_journal_header
modifier|*
name|hdr
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
name|bcopy
argument_list|(
name|GJ_HEADER_MAGIC
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|GJ_HEADER_MAGIC
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|GJ_HEADER_MAGIC
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
name|data
argument_list|,
name|hdr
operator|->
name|jh_journal_id
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|4
expr_stmt|;
name|le32enc
argument_list|(
name|data
argument_list|,
name|hdr
operator|->
name|jh_journal_next_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_journal_header_decode
parameter_list|(
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|struct
name|g_journal_header
modifier|*
name|hdr
parameter_list|)
block|{
name|bcopy
argument_list|(
name|data
argument_list|,
name|hdr
operator|->
name|jh_magic
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|jh_magic
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|jh_magic
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|hdr
operator|->
name|jh_magic
argument_list|,
name|GJ_HEADER_MAGIC
argument_list|,
sizeof|sizeof
argument_list|(
name|GJ_HEADER_MAGIC
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|hdr
operator|->
name|jh_journal_id
operator|=
name|le32dec
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|4
expr_stmt|;
name|hdr
operator|->
name|jh_journal_next_id
operator|=
name|le32dec
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_journal_flush_cache
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bio_flush
operator|==
literal|0
condition|)
return|return;
name|GJ_TIMER_START
argument_list|(
literal|1
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_bio_flush
operator|&
name|GJ_FLUSH_JOURNAL
condition|)
block|{
name|error
operator|=
name|g_io_flush
argument_list|(
name|sc
operator|->
name|sc_jconsumer
argument_list|)
expr_stmt|;
name|GJ_DEBUG
argument_list|(
name|error
operator|==
literal|0
condition|?
literal|2
else|:
literal|0
argument_list|,
literal|"Flush cache of %s: error=%d."
argument_list|,
name|sc
operator|->
name|sc_jconsumer
operator|->
name|provider
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_bio_flush
operator|&
name|GJ_FLUSH_DATA
condition|)
block|{
comment|/* 		 * TODO: This could be called in parallel with the 		 *       previous call. 		 */
name|error
operator|=
name|g_io_flush
argument_list|(
name|sc
operator|->
name|sc_dconsumer
argument_list|)
expr_stmt|;
name|GJ_DEBUG
argument_list|(
name|error
operator|==
literal|0
condition|?
literal|2
else|:
literal|0
argument_list|,
literal|"Flush cache of %s: error=%d."
argument_list|,
name|sc
operator|->
name|sc_dconsumer
operator|->
name|provider
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|GJ_TIMER_STOP
argument_list|(
literal|1
argument_list|,
operator|&
name|bt
argument_list|,
literal|"Cache flush time"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_journal_write_header
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_journal_header
name|hdr
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cp
operator|=
name|sc
operator|->
name|sc_jconsumer
expr_stmt|;
name|buf
operator|=
name|gj_malloc
argument_list|(
name|cp
operator|->
name|provider
operator|->
name|sectorsize
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|hdr
operator|.
name|jh_magic
argument_list|,
name|GJ_HEADER_MAGIC
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|.
name|jh_magic
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|jh_journal_id
operator|=
name|sc
operator|->
name|sc_journal_id
expr_stmt|;
name|hdr
operator|.
name|jh_journal_next_id
operator|=
name|sc
operator|->
name|sc_journal_next_id
expr_stmt|;
name|g_journal_header_encode
argument_list|(
operator|&
name|hdr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_write_data
argument_list|(
name|cp
argument_list|,
name|sc
operator|->
name|sc_journal_offset
argument_list|,
name|buf
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
comment|/* if (error == 0) */
name|sc
operator|->
name|sc_journal_offset
operator|+=
name|cp
operator|->
name|provider
operator|->
name|sectorsize
expr_stmt|;
name|gj_free
argument_list|(
name|buf
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Every journal record has a header and data following it.  * Functions below are used to decode the header before storing it to  * little endian and to encode it after reading to system endianess.  */
end_comment

begin_function
specifier|static
name|void
name|g_journal_record_header_encode
parameter_list|(
name|struct
name|g_journal_record_header
modifier|*
name|hdr
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|g_journal_entry
modifier|*
name|ent
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|bcopy
argument_list|(
name|GJ_RECORD_HEADER_MAGIC
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|GJ_RECORD_HEADER_MAGIC
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|GJ_RECORD_HEADER_MAGIC
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
name|data
argument_list|,
name|hdr
operator|->
name|jrh_journal_id
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|8
expr_stmt|;
name|le16enc
argument_list|(
name|data
argument_list|,
name|hdr
operator|->
name|jrh_nentries
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
name|bcopy
argument_list|(
name|hdr
operator|->
name|jrh_sum
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|jrh_sum
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|jrh_nentries
condition|;
name|i
operator|++
control|)
block|{
name|ent
operator|=
operator|&
name|hdr
operator|->
name|jrh_entries
index|[
name|i
index|]
expr_stmt|;
name|le64enc
argument_list|(
name|data
argument_list|,
name|ent
operator|->
name|je_joffset
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|8
expr_stmt|;
name|le64enc
argument_list|(
name|data
argument_list|,
name|ent
operator|->
name|je_offset
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|8
expr_stmt|;
name|le64enc
argument_list|(
name|data
argument_list|,
name|ent
operator|->
name|je_length
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|g_journal_record_header_decode
parameter_list|(
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|struct
name|g_journal_record_header
modifier|*
name|hdr
parameter_list|)
block|{
name|struct
name|g_journal_entry
modifier|*
name|ent
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|hdr
operator|->
name|jrh_magic
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|jrh_magic
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|jrh_magic
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|hdr
operator|->
name|jrh_magic
argument_list|,
name|GJ_RECORD_HEADER_MAGIC
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|hdr
operator|->
name|jrh_journal_id
operator|=
name|le32dec
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|8
expr_stmt|;
name|hdr
operator|->
name|jrh_nentries
operator|=
name|le16dec
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|jrh_nentries
operator|>
name|GJ_RECORD_HEADER_NENTRIES
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|hdr
operator|->
name|jrh_sum
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|jrh_sum
argument_list|)
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|jrh_nentries
condition|;
name|i
operator|++
control|)
block|{
name|ent
operator|=
operator|&
name|hdr
operator|->
name|jrh_entries
index|[
name|i
index|]
expr_stmt|;
name|ent
operator|->
name|je_joffset
operator|=
name|le64dec
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|8
expr_stmt|;
name|ent
operator|->
name|je_offset
operator|=
name|le64dec
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|8
expr_stmt|;
name|ent
operator|->
name|je_length
operator|=
name|le64dec
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|8
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function reads metadata from a provider (via the given consumer), decodes  * it to system endianess and verifies its correctness.  */
end_comment

begin_function
specifier|static
name|int
name|g_journal_metadata_read
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_journal_metadata
modifier|*
name|md
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
comment|/* Metadata is stored in last sector. */
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|pp
operator|->
name|mediasize
operator|-
name|pp
operator|->
name|sectorsize
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Cannot read metadata from %s (error=%d)."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Decode metadata. */
name|error
operator|=
name|journal_metadata_decode
argument_list|(
name|buf
argument_list|,
name|md
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Is this is gjournal provider at all? */
if|if
condition|(
name|strcmp
argument_list|(
name|md
operator|->
name|md_magic
argument_list|,
name|G_JOURNAL_MAGIC
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Are we able to handle this version of metadata? 	 * We only maintain backward compatibility. 	 */
if|if
condition|(
name|md
operator|->
name|md_version
operator|>
name|G_JOURNAL_VERSION
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Kernel module is too old to handle metadata from %s."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Is checksum correct? */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"MD5 metadata hash mismatch for provider %s."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Two functions below are responsible for updating metadata.  * Only metadata on the data provider is updated (we need to update  * information about active journal in there).  */
end_comment

begin_function
specifier|static
name|void
name|g_journal_metadata_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
comment|/* 	 * There is not much we can do on error except informing about it. 	 */
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|!=
literal|0
condition|)
block|{
name|GJ_LOGREQ
argument_list|(
literal|0
argument_list|,
name|bp
argument_list|,
literal|"Cannot update metadata (error=%d)."
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GJ_LOGREQ
argument_list|(
literal|2
argument_list|,
name|bp
argument_list|,
literal|"Metadata updated."
argument_list|)
expr_stmt|;
block|}
name|gj_free
argument_list|(
name|bp
operator|->
name|bio_data
argument_list|,
name|bp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_journal_metadata_update
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_journal_metadata
name|md
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|u_char
modifier|*
name|sector
decl_stmt|;
name|cp
operator|=
name|sc
operator|->
name|sc_dconsumer
expr_stmt|;
name|sector
operator|=
name|gj_malloc
argument_list|(
name|cp
operator|->
name|provider
operator|->
name|sectorsize
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|md
operator|.
name|md_magic
argument_list|,
name|G_JOURNAL_MAGIC
argument_list|,
sizeof|sizeof
argument_list|(
name|md
operator|.
name|md_magic
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|.
name|md_version
operator|=
name|G_JOURNAL_VERSION
expr_stmt|;
name|md
operator|.
name|md_id
operator|=
name|sc
operator|->
name|sc_id
expr_stmt|;
name|md
operator|.
name|md_type
operator|=
name|sc
operator|->
name|sc_orig_type
expr_stmt|;
name|md
operator|.
name|md_jstart
operator|=
name|sc
operator|->
name|sc_jstart
expr_stmt|;
name|md
operator|.
name|md_jend
operator|=
name|sc
operator|->
name|sc_jend
expr_stmt|;
name|md
operator|.
name|md_joffset
operator|=
name|sc
operator|->
name|sc_inactive
operator|.
name|jj_offset
expr_stmt|;
name|md
operator|.
name|md_jid
operator|=
name|sc
operator|->
name|sc_journal_previous_id
expr_stmt|;
name|md
operator|.
name|md_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|GJF_DEVICE_CLEAN
condition|)
name|md
operator|.
name|md_flags
operator||=
name|GJ_FLAG_CLEAN
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|GJF_DEVICE_HARDCODED
condition|)
name|strlcpy
argument_list|(
name|md
operator|.
name|md_provider
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
sizeof|sizeof
argument_list|(
name|md
operator|.
name|md_provider
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bzero
argument_list|(
name|md
operator|.
name|md_provider
argument_list|,
sizeof|sizeof
argument_list|(
name|md
operator|.
name|md_provider
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|.
name|md_provsize
operator|=
name|cp
operator|->
name|provider
operator|->
name|mediasize
expr_stmt|;
name|journal_metadata_encode
argument_list|(
operator|&
name|md
argument_list|,
name|sector
argument_list|)
expr_stmt|;
comment|/* 	 * Flush the cache, so we know all data are on disk. 	 * We write here informations like "journal is consistent", so we need 	 * to be sure it is. Without BIO_FLUSH here, we can end up in situation 	 * where metadata is stored on disk, but not all data. 	 */
name|g_journal_flush_cache
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bp
operator|=
name|g_alloc_bio
argument_list|()
expr_stmt|;
name|bp
operator|->
name|bio_offset
operator|=
name|cp
operator|->
name|provider
operator|->
name|mediasize
operator|-
name|cp
operator|->
name|provider
operator|->
name|sectorsize
expr_stmt|;
name|bp
operator|->
name|bio_length
operator|=
name|cp
operator|->
name|provider
operator|->
name|sectorsize
expr_stmt|;
name|bp
operator|->
name|bio_data
operator|=
name|sector
expr_stmt|;
name|bp
operator|->
name|bio_cmd
operator|=
name|BIO_WRITE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|GJF_DEVICE_DESTROY
operator|)
condition|)
block|{
name|bp
operator|->
name|bio_done
operator|=
name|g_journal_metadata_done
expr_stmt|;
name|g_io_request
argument_list|(
name|bp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|bio_done
operator|=
name|NULL
expr_stmt|;
name|g_io_request
argument_list|(
name|bp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|biowait
argument_list|(
name|bp
argument_list|,
literal|"gjmdu"
argument_list|)
expr_stmt|;
name|g_journal_metadata_done
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Be sure metadata reached the disk. 	 */
name|g_journal_flush_cache
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is where the I/O request comes from the GEOM.  */
end_comment

begin_function
specifier|static
name|void
name|g_journal_start
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_journal_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|GJ_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Request received."
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
case|case
name|BIO_WRITE
case|:
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|sc
operator|->
name|sc_regular_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
return|return;
case|case
name|BIO_GETATTR
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|bp
operator|->
name|bio_attribute
argument_list|,
literal|"GJOURNAL::provider"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strlcpy
argument_list|(
name|bp
operator|->
name|bio_data
argument_list|,
name|bp
operator|->
name|bio_to
operator|->
name|name
argument_list|,
name|bp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_completed
operator|=
name|strlen
argument_list|(
name|bp
operator|->
name|bio_to
operator|->
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FALLTHROUGH */
case|case
name|BIO_DELETE
case|:
default|default:
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_journal_std_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_journal_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_from
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|sc
operator|->
name|sc_back_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|bio
modifier|*
name|g_journal_new_bio
parameter_list|(
name|off_t
name|start
parameter_list|,
name|off_t
name|end
parameter_list|,
name|off_t
name|joffset
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|g_alloc_bio
argument_list|()
expr_stmt|;
name|bp
operator|->
name|bio_offset
operator|=
name|start
expr_stmt|;
name|bp
operator|->
name|bio_joffset
operator|=
name|joffset
expr_stmt|;
name|bp
operator|->
name|bio_length
operator|=
name|end
operator|-
name|start
expr_stmt|;
name|bp
operator|->
name|bio_cmd
operator|=
name|BIO_WRITE
expr_stmt|;
name|bp
operator|->
name|bio_done
operator|=
name|g_journal_std_done
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
name|bp
operator|->
name|bio_data
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|bp
operator|->
name|bio_data
operator|=
name|gj_malloc
argument_list|(
name|bp
operator|->
name|bio_length
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_data
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|data
argument_list|,
name|bp
operator|->
name|bio_data
argument_list|,
name|bp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|g_journal_insert_bio
parameter_list|(
name|head
parameter_list|,
name|bp
parameter_list|,
name|flags
parameter_list|)
define|\
value|g_journal_insert((head), (bp)->bio_offset,			\ 		(bp)->bio_offset + (bp)->bio_length, (bp)->bio_joffset,	\ 		(bp)->bio_data, flags)
end_define

begin_comment
comment|/*  * The function below does a lot more than just inserting bio to the queue.  * It keeps the queue sorted by offset and ensures that there are no doubled  * data (it combines bios where ranges overlap).  *  * The function returns the number of bios inserted (as bio can be splitted).  */
end_comment

begin_function
specifier|static
name|int
name|g_journal_insert
parameter_list|(
name|struct
name|bio
modifier|*
modifier|*
name|head
parameter_list|,
name|off_t
name|nstart
parameter_list|,
name|off_t
name|nend
parameter_list|,
name|off_t
name|joffset
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|nbp
decl_stmt|,
modifier|*
name|cbp
decl_stmt|,
modifier|*
name|pbp
decl_stmt|;
name|off_t
name|cstart
decl_stmt|,
name|cend
decl_stmt|;
name|u_char
modifier|*
name|tmpdata
decl_stmt|;
name|int
name|n
decl_stmt|;
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"INSERT(%p): (%jd, %jd, %jd)"
argument_list|,
operator|*
name|head
argument_list|,
name|nstart
argument_list|,
name|nend
argument_list|,
name|joffset
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|pbp
operator|=
name|NULL
expr_stmt|;
name|GJQ_FOREACH
argument_list|(
argument|*head
argument_list|,
argument|cbp
argument_list|)
block|{
name|cstart
operator|=
name|cbp
operator|->
name|bio_offset
expr_stmt|;
name|cend
operator|=
name|cbp
operator|->
name|bio_offset
operator|+
name|cbp
operator|->
name|bio_length
expr_stmt|;
if|if
condition|(
name|nstart
operator|>=
name|cend
condition|)
block|{
comment|/* 			 *  +-------------+ 			 *  |             | 			 *  |   current   |  +-------------+ 			 *  |     bio     |  |             | 			 *  |             |  |     new     | 			 *  +-------------+  |     bio     | 			 *                   |             | 			 *                   +-------------+ 			 */
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"INSERT(%p): 1"
argument_list|,
operator|*
name|head
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nend
operator|<=
name|cstart
condition|)
block|{
comment|/* 			 *                   +-------------+ 			 *                   |             | 			 *  +-------------+  |   current   | 			 *  |             |  |     bio     | 			 *  |     new     |  |             | 			 *  |     bio     |  +-------------+ 			 *  |             | 			 *  +-------------+ 			 */
name|nbp
operator|=
name|g_journal_new_bio
argument_list|(
name|nstart
argument_list|,
name|nend
argument_list|,
name|joffset
argument_list|,
name|data
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbp
operator|==
name|NULL
condition|)
operator|*
name|head
operator|=
name|nbp
expr_stmt|;
else|else
name|pbp
operator|->
name|bio_next
operator|=
name|nbp
expr_stmt|;
name|nbp
operator|->
name|bio_next
operator|=
name|cbp
expr_stmt|;
name|n
operator|++
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"INSERT(%p): 2 (nbp=%p pbp=%p)"
argument_list|,
operator|*
name|head
argument_list|,
name|nbp
argument_list|,
name|pbp
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
elseif|else
if|if
condition|(
name|nstart
operator|<=
name|cstart
operator|&&
name|nend
operator|>=
name|cend
condition|)
block|{
comment|/* 			 *      +-------------+      +-------------+ 			 *      | current bio |      | current bio | 			 *  +---+-------------+---+  +-------------+---+ 			 *  |   |             |   |  |             |   | 			 *  |   |             |   |  |             |   | 			 *  |   +-------------+   |  +-------------+   | 			 *  |       new bio       |  |     new bio     | 			 *  +---------------------+  +-----------------+ 			 * 			 *      +-------------+  +-------------+ 			 *      | current bio |  | current bio | 			 *  +---+-------------+  +-------------+ 			 *  |   |             |  |             | 			 *  |   |             |  |             | 			 *  |   +-------------+  +-------------+ 			 *  |     new bio     |  |   new bio   | 			 *  +-----------------+  +-------------+ 			 */
name|g_journal_stats_bytes_skipped
operator|+=
name|cbp
operator|->
name|bio_length
expr_stmt|;
name|cbp
operator|->
name|bio_offset
operator|=
name|nstart
expr_stmt|;
name|cbp
operator|->
name|bio_joffset
operator|=
name|joffset
expr_stmt|;
name|cbp
operator|->
name|bio_length
operator|=
name|cend
operator|-
name|nstart
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|bio_data
operator|!=
name|NULL
condition|)
block|{
name|gj_free
argument_list|(
name|cbp
operator|->
name|bio_data
argument_list|,
name|cend
operator|-
name|cstart
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|bio_data
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
block|{
name|cbp
operator|->
name|bio_data
operator|=
name|gj_malloc
argument_list|(
name|cbp
operator|->
name|bio_length
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|bio_data
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|data
argument_list|,
name|cbp
operator|->
name|bio_data
argument_list|,
name|cbp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
block|}
name|data
operator|+=
name|cend
operator|-
name|nstart
expr_stmt|;
block|}
name|joffset
operator|+=
name|cend
operator|-
name|nstart
expr_stmt|;
name|nstart
operator|=
name|cend
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"INSERT(%p): 3 (cbp=%p)"
argument_list|,
operator|*
name|head
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nstart
operator|>
name|cstart
operator|&&
name|nend
operator|>=
name|cend
condition|)
block|{
comment|/* 			 *  +-----------------+  +-------------+ 			 *  |   current bio   |  | current bio | 			 *  |   +-------------+  |   +---------+---+ 			 *  |   |             |  |   |         |   | 			 *  |   |             |  |   |         |   | 			 *  +---+-------------+  +---+---------+   | 			 *      |   new bio   |      |   new bio   | 			 *      +-------------+      +-------------+ 			 */
name|g_journal_stats_bytes_skipped
operator|+=
name|cend
operator|-
name|nstart
expr_stmt|;
name|nbp
operator|=
name|g_journal_new_bio
argument_list|(
name|nstart
argument_list|,
name|cend
argument_list|,
name|joffset
argument_list|,
name|data
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|nbp
operator|->
name|bio_next
operator|=
name|cbp
operator|->
name|bio_next
expr_stmt|;
name|cbp
operator|->
name|bio_next
operator|=
name|nbp
expr_stmt|;
name|cbp
operator|->
name|bio_length
operator|=
name|nstart
operator|-
name|cstart
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|bio_data
operator|!=
name|NULL
condition|)
block|{
name|cbp
operator|->
name|bio_data
operator|=
name|gj_realloc
argument_list|(
name|cbp
operator|->
name|bio_data
argument_list|,
name|cbp
operator|->
name|bio_length
argument_list|,
name|cend
operator|-
name|cstart
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
name|data
operator|+=
name|cend
operator|-
name|nstart
expr_stmt|;
name|joffset
operator|+=
name|cend
operator|-
name|nstart
expr_stmt|;
name|nstart
operator|=
name|cend
expr_stmt|;
name|n
operator|++
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"INSERT(%p): 4 (cbp=%p)"
argument_list|,
operator|*
name|head
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nstart
operator|>
name|cstart
operator|&&
name|nend
operator|<
name|cend
condition|)
block|{
comment|/* 			 *  +---------------------+ 			 *  |     current bio     | 			 *  |   +-------------+   | 			 *  |   |             |   | 			 *  |   |             |   | 			 *  +---+-------------+---+ 			 *      |   new bio   | 			 *      +-------------+ 			 */
name|g_journal_stats_bytes_skipped
operator|+=
name|nend
operator|-
name|nstart
expr_stmt|;
name|nbp
operator|=
name|g_journal_new_bio
argument_list|(
name|nstart
argument_list|,
name|nend
argument_list|,
name|joffset
argument_list|,
name|data
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|nbp
operator|->
name|bio_next
operator|=
name|cbp
operator|->
name|bio_next
expr_stmt|;
name|cbp
operator|->
name|bio_next
operator|=
name|nbp
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|bio_data
operator|==
name|NULL
condition|)
name|tmpdata
operator|=
name|NULL
expr_stmt|;
else|else
name|tmpdata
operator|=
name|cbp
operator|->
name|bio_data
operator|+
name|nend
operator|-
name|cstart
expr_stmt|;
name|nbp
operator|=
name|g_journal_new_bio
argument_list|(
name|nend
argument_list|,
name|cend
argument_list|,
name|cbp
operator|->
name|bio_joffset
operator|+
name|nend
operator|-
name|cstart
argument_list|,
name|tmpdata
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|nbp
operator|->
name|bio_next
operator|=
operator|(
operator|(
expr|struct
name|bio
operator|*
operator|)
name|cbp
operator|->
name|bio_next
operator|)
operator|->
name|bio_next
expr_stmt|;
operator|(
operator|(
expr|struct
name|bio
operator|*
operator|)
name|cbp
operator|->
name|bio_next
operator|)
operator|->
name|bio_next
operator|=
name|nbp
expr_stmt|;
name|cbp
operator|->
name|bio_length
operator|=
name|nstart
operator|-
name|cstart
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|bio_data
operator|!=
name|NULL
condition|)
block|{
name|cbp
operator|->
name|bio_data
operator|=
name|gj_realloc
argument_list|(
name|cbp
operator|->
name|bio_data
argument_list|,
name|cbp
operator|->
name|bio_length
argument_list|,
name|cend
operator|-
name|cstart
argument_list|)
expr_stmt|;
block|}
name|n
operator|+=
literal|2
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"INSERT(%p): 5 (cbp=%p)"
argument_list|,
operator|*
name|head
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
elseif|else
if|if
condition|(
name|nstart
operator|<=
name|cstart
operator|&&
name|nend
operator|<
name|cend
condition|)
block|{
comment|/* 			 *  +-----------------+      +-------------+ 			 *  |   current bio   |      | current bio | 			 *  +-------------+   |  +---+---------+   | 			 *  |             |   |  |   |         |   | 			 *  |             |   |  |   |         |   | 			 *  +-------------+---+  |   +---------+---+ 			 *  |   new bio   |      |   new bio   | 			 *  +-------------+      +-------------+ 			 */
name|g_journal_stats_bytes_skipped
operator|+=
name|nend
operator|-
name|nstart
expr_stmt|;
name|nbp
operator|=
name|g_journal_new_bio
argument_list|(
name|nstart
argument_list|,
name|nend
argument_list|,
name|joffset
argument_list|,
name|data
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbp
operator|==
name|NULL
condition|)
operator|*
name|head
operator|=
name|nbp
expr_stmt|;
else|else
name|pbp
operator|->
name|bio_next
operator|=
name|nbp
expr_stmt|;
name|nbp
operator|->
name|bio_next
operator|=
name|cbp
expr_stmt|;
name|cbp
operator|->
name|bio_offset
operator|=
name|nend
expr_stmt|;
name|cbp
operator|->
name|bio_length
operator|=
name|cend
operator|-
name|nend
expr_stmt|;
name|cbp
operator|->
name|bio_joffset
operator|+=
name|nend
operator|-
name|cstart
expr_stmt|;
name|tmpdata
operator|=
name|cbp
operator|->
name|bio_data
expr_stmt|;
if|if
condition|(
name|tmpdata
operator|!=
name|NULL
condition|)
block|{
name|cbp
operator|->
name|bio_data
operator|=
name|gj_malloc
argument_list|(
name|cbp
operator|->
name|bio_length
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|bio_data
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|tmpdata
operator|+
name|nend
operator|-
name|cstart
argument_list|,
name|cbp
operator|->
name|bio_data
argument_list|,
name|cbp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
block|}
name|gj_free
argument_list|(
name|tmpdata
argument_list|,
name|cend
operator|-
name|cstart
argument_list|)
expr_stmt|;
block|}
name|n
operator|++
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"INSERT(%p): 6 (cbp=%p)"
argument_list|,
operator|*
name|head
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
if|if
condition|(
name|nstart
operator|==
name|nend
condition|)
goto|goto
name|end
goto|;
name|pbp
operator|=
name|cbp
expr_stmt|;
block|}
name|nbp
operator|=
name|g_journal_new_bio
argument_list|(
name|nstart
argument_list|,
name|nend
argument_list|,
name|joffset
argument_list|,
name|data
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbp
operator|==
name|NULL
condition|)
operator|*
name|head
operator|=
name|nbp
expr_stmt|;
else|else
name|pbp
operator|->
name|bio_next
operator|=
name|nbp
expr_stmt|;
name|nbp
operator|->
name|bio_next
operator|=
name|NULL
expr_stmt|;
name|n
operator|++
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"INSERT(%p): 8 (nbp=%p pbp=%p)"
argument_list|,
operator|*
name|head
argument_list|,
name|nbp
argument_list|,
name|pbp
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|g_journal_debug
operator|>=
literal|3
condition|)
block|{
name|GJQ_FOREACH
argument_list|(
argument|*head
argument_list|,
argument|cbp
argument_list|)
block|{
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"ELEMENT: %p (%jd, %jd, %jd, %p)"
argument_list|,
name|cbp
argument_list|,
operator|(
name|intmax_t
operator|)
name|cbp
operator|->
name|bio_offset
argument_list|,
operator|(
name|intmax_t
operator|)
name|cbp
operator|->
name|bio_length
argument_list|,
operator|(
name|intmax_t
operator|)
name|cbp
operator|->
name|bio_joffset
argument_list|,
name|cbp
operator|->
name|bio_data
argument_list|)
expr_stmt|;
block|}
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"INSERT(%p): DONE %d"
argument_list|,
operator|*
name|head
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The function combines neighbour bios trying to squeeze as much data as  * possible into one bio.  *  * The function returns the number of bios combined (negative value).  */
end_comment

begin_function
specifier|static
name|int
name|g_journal_optimize
parameter_list|(
name|struct
name|bio
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|cbp
decl_stmt|,
modifier|*
name|pbp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|pbp
operator|=
name|NULL
expr_stmt|;
name|GJQ_FOREACH
argument_list|(
argument|head
argument_list|,
argument|cbp
argument_list|)
block|{
comment|/* Skip bios which has to be read first. */
if|if
condition|(
name|cbp
operator|->
name|bio_data
operator|==
name|NULL
condition|)
block|{
name|pbp
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
comment|/* There is no previous bio yet. */
if|if
condition|(
name|pbp
operator|==
name|NULL
condition|)
block|{
name|pbp
operator|=
name|cbp
expr_stmt|;
continue|continue;
block|}
comment|/* Is this a neighbour bio? */
if|if
condition|(
name|pbp
operator|->
name|bio_offset
operator|+
name|pbp
operator|->
name|bio_length
operator|!=
name|cbp
operator|->
name|bio_offset
condition|)
block|{
comment|/* Be sure that bios queue is sorted. */
name|KASSERT
argument_list|(
name|pbp
operator|->
name|bio_offset
operator|+
name|pbp
operator|->
name|bio_length
operator|<
name|cbp
operator|->
name|bio_offset
argument_list|,
operator|(
literal|"poffset=%jd plength=%jd coffset=%jd"
operator|,
operator|(
name|intmax_t
operator|)
name|pbp
operator|->
name|bio_offset
operator|,
operator|(
name|intmax_t
operator|)
name|pbp
operator|->
name|bio_length
operator|,
operator|(
name|intmax_t
operator|)
name|cbp
operator|->
name|bio_offset
operator|)
argument_list|)
expr_stmt|;
name|pbp
operator|=
name|cbp
expr_stmt|;
continue|continue;
block|}
comment|/* Be sure we don't end up with too big bio. */
if|if
condition|(
name|pbp
operator|->
name|bio_length
operator|+
name|cbp
operator|->
name|bio_length
operator|>
name|MAXPHYS
condition|)
block|{
name|pbp
operator|=
name|cbp
expr_stmt|;
continue|continue;
block|}
comment|/* Ok, we can join bios. */
name|GJ_LOGREQ
argument_list|(
literal|4
argument_list|,
name|pbp
argument_list|,
literal|"Join: "
argument_list|)
expr_stmt|;
name|GJ_LOGREQ
argument_list|(
literal|4
argument_list|,
name|cbp
argument_list|,
literal|"and: "
argument_list|)
expr_stmt|;
name|pbp
operator|->
name|bio_data
operator|=
name|gj_realloc
argument_list|(
name|pbp
operator|->
name|bio_data
argument_list|,
name|pbp
operator|->
name|bio_length
operator|+
name|cbp
operator|->
name|bio_length
argument_list|,
name|pbp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|cbp
operator|->
name|bio_data
argument_list|,
name|pbp
operator|->
name|bio_data
operator|+
name|pbp
operator|->
name|bio_length
argument_list|,
name|cbp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
name|gj_free
argument_list|(
name|cbp
operator|->
name|bio_data
argument_list|,
name|cbp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
name|pbp
operator|->
name|bio_length
operator|+=
name|cbp
operator|->
name|bio_length
expr_stmt|;
name|pbp
operator|->
name|bio_next
operator|=
name|cbp
operator|->
name|bio_next
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
name|cbp
operator|=
name|pbp
expr_stmt|;
name|g_journal_stats_combined_ios
operator|++
expr_stmt|;
name|n
operator|--
expr_stmt|;
name|GJ_LOGREQ
argument_list|(
literal|4
argument_list|,
name|pbp
argument_list|,
literal|"Got: "
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * TODO: Update comment.  * These are functions responsible for copying one portion of data from journal  * to the destination provider.  * The order goes like this:  * 1. Read the header, which contains informations about data blocks  *    following it.  * 2. Read the data blocks from the journal.  * 3. Write the data blocks on the data provider.  *  * g_journal_copy_start()  * g_journal_copy_done() - got finished write request, logs potential errors.  */
end_comment

begin_comment
comment|/*  * When there is no data in cache, this function is used to read it.  */
end_comment

begin_function
specifier|static
name|void
name|g_journal_read_first
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|cbp
decl_stmt|;
comment|/* 	 * We were short in memory, so data was freed. 	 * In that case we need to read it back from journal. 	 */
name|cbp
operator|=
name|g_alloc_bio
argument_list|()
expr_stmt|;
name|cbp
operator|->
name|bio_cflags
operator|=
name|bp
operator|->
name|bio_cflags
expr_stmt|;
name|cbp
operator|->
name|bio_parent
operator|=
name|bp
expr_stmt|;
name|cbp
operator|->
name|bio_offset
operator|=
name|bp
operator|->
name|bio_joffset
expr_stmt|;
name|cbp
operator|->
name|bio_length
operator|=
name|bp
operator|->
name|bio_length
expr_stmt|;
name|cbp
operator|->
name|bio_data
operator|=
name|gj_malloc
argument_list|(
name|bp
operator|->
name|bio_length
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|bio_cmd
operator|=
name|BIO_READ
expr_stmt|;
name|cbp
operator|->
name|bio_done
operator|=
name|g_journal_std_done
expr_stmt|;
name|GJ_LOGREQ
argument_list|(
literal|4
argument_list|,
name|cbp
argument_list|,
literal|"READ FIRST"
argument_list|)
expr_stmt|;
name|g_io_request
argument_list|(
name|cbp
argument_list|,
name|sc
operator|->
name|sc_jconsumer
argument_list|)
expr_stmt|;
name|g_journal_cache_misses
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_journal_copy_send
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bioq
decl_stmt|,
modifier|*
name|bp
decl_stmt|,
modifier|*
name|lbp
decl_stmt|;
name|bioq
operator|=
name|lbp
operator|=
name|NULL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sc
operator|->
name|sc_copy_in_progress
operator|<
name|g_journal_parallel_copies
condition|;
control|)
block|{
name|bp
operator|=
name|GJQ_FIRST
argument_list|(
name|sc
operator|->
name|sc_inactive
operator|.
name|jj_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
break|break;
name|GJQ_REMOVE
argument_list|(
name|sc
operator|->
name|sc_inactive
operator|.
name|jj_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_copy_in_progress
operator|++
expr_stmt|;
name|GJQ_INSERT_AFTER
argument_list|(
name|bioq
argument_list|,
name|bp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
name|lbp
operator|=
name|bp
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_journal_do_optimize
condition|)
name|sc
operator|->
name|sc_copy_in_progress
operator|+=
name|g_journal_optimize
argument_list|(
name|bioq
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|GJQ_FIRST
argument_list|(
name|bioq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|GJQ_REMOVE
argument_list|(
name|bioq
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|GJQ_INSERT_HEAD
argument_list|(
name|sc
operator|->
name|sc_copy_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_cflags
operator|=
name|GJ_BIO_COPY
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_data
operator|==
name|NULL
condition|)
name|g_journal_read_first
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
else|else
block|{
name|bp
operator|->
name|bio_joffset
operator|=
literal|0
expr_stmt|;
name|GJ_LOGREQ
argument_list|(
literal|4
argument_list|,
name|bp
argument_list|,
literal|"SEND"
argument_list|)
expr_stmt|;
name|g_io_request
argument_list|(
name|bp
argument_list|,
name|sc
operator|->
name|sc_dconsumer
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_journal_copy_start
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* 	 * Remember in metadata that we're starting to copy journaled data 	 * to the data provider. 	 * In case of power failure, we will copy these data once again on boot. 	 */
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_journal_copying
condition|)
block|{
name|sc
operator|->
name|sc_journal_copying
operator|=
literal|1
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Starting copy of journal."
argument_list|)
expr_stmt|;
name|g_journal_metadata_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|g_journal_copy_send
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Data block has been read from the journal provider.  */
end_comment

begin_function
specifier|static
name|int
name|g_journal_copy_read_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_journal_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|bio
modifier|*
name|pbp
decl_stmt|;
name|KASSERT
argument_list|(
name|bp
operator|->
name|bio_cflags
operator|==
name|GJ_BIO_COPY
argument_list|,
operator|(
literal|"Invalid bio (%d != %d)."
operator|,
name|bp
operator|->
name|bio_cflags
operator|,
name|GJ_BIO_COPY
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_from
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|pbp
operator|=
name|bp
operator|->
name|bio_parent
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|!=
literal|0
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Error while reading data from %s (error=%d)."
argument_list|,
name|bp
operator|->
name|bio_to
operator|->
name|name
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
comment|/* 		 * We will not be able to deliver WRITE request as well. 		 */
name|gj_free
argument_list|(
name|bp
operator|->
name|bio_data
argument_list|,
name|bp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|pbp
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_copy_in_progress
operator|--
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|pbp
operator|->
name|bio_data
operator|=
name|bp
operator|->
name|bio_data
expr_stmt|;
name|cp
operator|=
name|sc
operator|->
name|sc_dconsumer
expr_stmt|;
name|g_io_request
argument_list|(
name|pbp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GJ_LOGREQ
argument_list|(
literal|4
argument_list|,
name|bp
argument_list|,
literal|"READ DONE"
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Data block has been written to the data provider.  */
end_comment

begin_function
specifier|static
name|void
name|g_journal_copy_write_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_journal_softc
modifier|*
name|sc
decl_stmt|;
name|KASSERT
argument_list|(
name|bp
operator|->
name|bio_cflags
operator|==
name|GJ_BIO_COPY
argument_list|,
operator|(
literal|"Invalid bio (%d != %d)."
operator|,
name|bp
operator|->
name|bio_cflags
operator|,
name|GJ_BIO_COPY
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_from
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|sc
operator|->
name|sc_copy_in_progress
operator|--
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|!=
literal|0
condition|)
block|{
name|GJ_LOGREQ
argument_list|(
literal|0
argument_list|,
name|bp
argument_list|,
literal|"[copy] Error while writting data (error=%d)"
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
block|}
name|GJQ_REMOVE
argument_list|(
name|sc
operator|->
name|sc_copy_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|gj_free
argument_list|(
name|bp
operator|->
name|bio_data
argument_list|,
name|bp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
name|GJ_LOGREQ
argument_list|(
literal|4
argument_list|,
name|bp
argument_list|,
literal|"DONE"
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_copy_in_progress
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This was the last write request for this journal. 		 */
name|GJ_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Data has been copied."
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_journal_copying
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function_decl
specifier|static
name|void
name|g_journal_flush_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Flush one record onto active journal provider.  */
end_comment

begin_function
specifier|static
name|void
name|g_journal_flush
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_journal_record_header
name|hdr
decl_stmt|;
name|struct
name|g_journal_entry
modifier|*
name|ent
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|bio
modifier|*
modifier|*
name|bioq
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|,
modifier|*
name|fbp
decl_stmt|,
modifier|*
name|pbp
decl_stmt|;
name|off_t
name|joffset
decl_stmt|,
name|size
decl_stmt|;
name|u_char
modifier|*
name|data
decl_stmt|,
name|hash
index|[
literal|16
index|]
decl_stmt|;
name|MD5_CTX
name|ctx
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_current_count
operator|==
literal|0
condition|)
return|return;
name|size
operator|=
literal|0
expr_stmt|;
name|pp
operator|=
name|sc
operator|->
name|sc_jprovider
expr_stmt|;
name|GJ_VALIDATE_OFFSET
argument_list|(
name|sc
operator|->
name|sc_journal_offset
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|joffset
operator|=
name|sc
operator|->
name|sc_journal_offset
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Storing %d journal entries on %s at %jd."
argument_list|,
name|sc
operator|->
name|sc_current_count
argument_list|,
name|pp
operator|->
name|name
argument_list|,
operator|(
name|intmax_t
operator|)
name|joffset
argument_list|)
expr_stmt|;
comment|/* 	 * Store 'journal id', so we know to which journal this record belongs. 	 */
name|hdr
operator|.
name|jrh_journal_id
operator|=
name|sc
operator|->
name|sc_journal_id
expr_stmt|;
comment|/* Could be less than g_journal_record_entries if called due timeout. */
name|hdr
operator|.
name|jrh_nentries
operator|=
name|MIN
argument_list|(
name|sc
operator|->
name|sc_current_count
argument_list|,
name|g_journal_record_entries
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|hdr
operator|.
name|jrh_magic
argument_list|,
name|GJ_RECORD_HEADER_MAGIC
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|.
name|jrh_magic
argument_list|)
argument_list|)
expr_stmt|;
name|bioq
operator|=
operator|&
name|sc
operator|->
name|sc_active
operator|.
name|jj_queue
expr_stmt|;
name|pbp
operator|=
name|sc
operator|->
name|sc_flush_queue
expr_stmt|;
name|fbp
operator|=
name|g_alloc_bio
argument_list|()
expr_stmt|;
name|fbp
operator|->
name|bio_parent
operator|=
name|NULL
expr_stmt|;
name|fbp
operator|->
name|bio_cflags
operator|=
name|GJ_BIO_JOURNAL
expr_stmt|;
name|fbp
operator|->
name|bio_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|fbp
operator|->
name|bio_joffset
operator|=
name|joffset
expr_stmt|;
name|fbp
operator|->
name|bio_length
operator|=
name|pp
operator|->
name|sectorsize
expr_stmt|;
name|fbp
operator|->
name|bio_cmd
operator|=
name|BIO_WRITE
expr_stmt|;
name|fbp
operator|->
name|bio_done
operator|=
name|g_journal_std_done
expr_stmt|;
name|GJQ_INSERT_AFTER
argument_list|(
name|sc
operator|->
name|sc_flush_queue
argument_list|,
name|fbp
argument_list|,
name|pbp
argument_list|)
expr_stmt|;
name|pbp
operator|=
name|fbp
expr_stmt|;
name|fbp
operator|->
name|bio_to
operator|=
name|pp
expr_stmt|;
name|GJ_LOGREQ
argument_list|(
literal|4
argument_list|,
name|fbp
argument_list|,
literal|"FLUSH_OUT"
argument_list|)
expr_stmt|;
name|joffset
operator|+=
name|pp
operator|->
name|sectorsize
expr_stmt|;
name|sc
operator|->
name|sc_flush_count
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|GJF_DEVICE_CHECKSUM
condition|)
name|MD5Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|.
name|jrh_nentries
condition|;
name|i
operator|++
control|)
block|{
name|bp
operator|=
name|sc
operator|->
name|sc_current_queue
expr_stmt|;
name|KASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL bp"
operator|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_to
operator|=
name|pp
expr_stmt|;
name|GJ_LOGREQ
argument_list|(
literal|4
argument_list|,
name|bp
argument_list|,
literal|"FLUSHED"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_current_queue
operator|=
name|bp
operator|->
name|bio_next
expr_stmt|;
name|bp
operator|->
name|bio_next
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_current_count
operator|--
expr_stmt|;
comment|/* Add to the header. */
name|ent
operator|=
operator|&
name|hdr
operator|.
name|jrh_entries
index|[
name|i
index|]
expr_stmt|;
name|ent
operator|->
name|je_offset
operator|=
name|bp
operator|->
name|bio_offset
expr_stmt|;
name|ent
operator|->
name|je_joffset
operator|=
name|joffset
expr_stmt|;
name|ent
operator|->
name|je_length
operator|=
name|bp
operator|->
name|bio_length
expr_stmt|;
name|size
operator|+=
name|ent
operator|->
name|je_length
expr_stmt|;
name|data
operator|=
name|bp
operator|->
name|bio_data
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|GJF_DEVICE_CHECKSUM
condition|)
name|MD5Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|data
argument_list|,
name|ent
operator|->
name|je_length
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|bp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_cflags
operator|=
name|GJ_BIO_JOURNAL
expr_stmt|;
name|bp
operator|->
name|bio_offset
operator|=
name|ent
operator|->
name|je_offset
expr_stmt|;
name|bp
operator|->
name|bio_joffset
operator|=
name|ent
operator|->
name|je_joffset
expr_stmt|;
name|bp
operator|->
name|bio_length
operator|=
name|ent
operator|->
name|je_length
expr_stmt|;
name|bp
operator|->
name|bio_data
operator|=
name|data
expr_stmt|;
name|bp
operator|->
name|bio_cmd
operator|=
name|BIO_WRITE
expr_stmt|;
name|bp
operator|->
name|bio_done
operator|=
name|g_journal_std_done
expr_stmt|;
name|GJQ_INSERT_AFTER
argument_list|(
name|sc
operator|->
name|sc_flush_queue
argument_list|,
name|bp
argument_list|,
name|pbp
argument_list|)
expr_stmt|;
name|pbp
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|bio_to
operator|=
name|pp
expr_stmt|;
name|GJ_LOGREQ
argument_list|(
literal|4
argument_list|,
name|bp
argument_list|,
literal|"FLUSH_OUT"
argument_list|)
expr_stmt|;
name|joffset
operator|+=
name|bp
operator|->
name|bio_length
expr_stmt|;
name|sc
operator|->
name|sc_flush_count
operator|++
expr_stmt|;
comment|/* 		 * Add request to the active sc_journal_queue queue. 		 * This is our cache. After journal switch we don't have to 		 * read the data from the inactive journal, because we keep 		 * it in memory. 		 */
name|g_journal_insert
argument_list|(
name|bioq
argument_list|,
name|ent
operator|->
name|je_offset
argument_list|,
name|ent
operator|->
name|je_offset
operator|+
name|ent
operator|->
name|je_length
argument_list|,
name|ent
operator|->
name|je_joffset
argument_list|,
name|data
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * After all requests, store valid header. 	 */
name|data
operator|=
name|gj_malloc
argument_list|(
name|pp
operator|->
name|sectorsize
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|GJF_DEVICE_CHECKSUM
condition|)
block|{
name|MD5Final
argument_list|(
name|hash
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hash
argument_list|,
name|hdr
operator|.
name|jrh_sum
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|.
name|jrh_sum
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|g_journal_record_header_encode
argument_list|(
operator|&
name|hdr
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|fbp
operator|->
name|bio_data
operator|=
name|data
expr_stmt|;
name|sc
operator|->
name|sc_journal_offset
operator|=
name|joffset
expr_stmt|;
name|g_journal_check_overflow
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush request finished.  */
end_comment

begin_function
specifier|static
name|void
name|g_journal_flush_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_journal_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|bp
operator|->
name|bio_cflags
operator|&
name|GJ_BIO_MASK
operator|)
operator|==
name|GJ_BIO_JOURNAL
argument_list|,
operator|(
literal|"Invalid bio (%d != %d)."
operator|,
name|bp
operator|->
name|bio_cflags
operator|,
name|GJ_BIO_JOURNAL
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|bp
operator|->
name|bio_from
expr_stmt|;
name|sc
operator|=
name|cp
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|sc
operator|->
name|sc_flush_in_progress
operator|--
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|!=
literal|0
condition|)
block|{
name|GJ_LOGREQ
argument_list|(
literal|0
argument_list|,
name|bp
argument_list|,
literal|"[flush] Error while writting data (error=%d)"
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
block|}
name|gj_free
argument_list|(
name|bp
operator|->
name|bio_data
argument_list|,
name|bp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
name|GJ_LOGREQ
argument_list|(
literal|4
argument_list|,
name|bp
argument_list|,
literal|"DONE"
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|g_journal_release_delayed
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|g_journal_flush_send
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|bio
modifier|*
name|bioq
decl_stmt|,
modifier|*
name|bp
decl_stmt|,
modifier|*
name|lbp
decl_stmt|;
name|cp
operator|=
name|sc
operator|->
name|sc_jconsumer
expr_stmt|;
name|bioq
operator|=
name|lbp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|sc_flush_in_progress
operator|<
name|g_journal_parallel_flushes
condition|)
block|{
comment|/* Send one flush requests to the active journal. */
name|bp
operator|=
name|GJQ_FIRST
argument_list|(
name|sc
operator|->
name|sc_flush_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|GJQ_REMOVE
argument_list|(
name|sc
operator|->
name|sc_flush_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flush_count
operator|--
expr_stmt|;
name|bp
operator|->
name|bio_offset
operator|=
name|bp
operator|->
name|bio_joffset
expr_stmt|;
name|bp
operator|->
name|bio_joffset
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flush_in_progress
operator|++
expr_stmt|;
name|GJQ_INSERT_AFTER
argument_list|(
name|bioq
argument_list|,
name|bp
argument_list|,
name|lbp
argument_list|)
expr_stmt|;
name|lbp
operator|=
name|bp
expr_stmt|;
block|}
comment|/* Try to release delayed requests. */
name|g_journal_release_delayed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* If there are no requests to flush, leave. */
if|if
condition|(
name|GJQ_FIRST
argument_list|(
name|sc
operator|->
name|sc_flush_queue
argument_list|)
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|g_journal_do_optimize
condition|)
name|sc
operator|->
name|sc_flush_in_progress
operator|+=
name|g_journal_optimize
argument_list|(
name|bioq
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|GJQ_FIRST
argument_list|(
name|bioq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|GJQ_REMOVE
argument_list|(
name|bioq
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|GJ_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Flush request send"
argument_list|)
expr_stmt|;
name|g_io_request
argument_list|(
name|bp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_journal_add_current
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|GJ_LOGREQ
argument_list|(
literal|4
argument_list|,
name|bp
argument_list|,
literal|"CURRENT %d"
argument_list|,
name|sc
operator|->
name|sc_current_count
argument_list|)
expr_stmt|;
name|n
operator|=
name|g_journal_insert_bio
argument_list|(
operator|&
name|sc
operator|->
name|sc_current_queue
argument_list|,
name|bp
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_current_count
operator|+=
name|n
expr_stmt|;
name|n
operator|=
name|g_journal_optimize
argument_list|(
name|sc
operator|->
name|sc_current_queue
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_current_count
operator|+=
name|n
expr_stmt|;
comment|/* 	 * For requests which are added to the current queue we deliver 	 * response immediately. 	 */
name|bp
operator|->
name|bio_completed
operator|=
name|bp
operator|->
name|bio_length
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_current_count
operator|>=
name|g_journal_record_entries
condition|)
block|{
comment|/* 		 * Let's flush one record onto active journal provider. 		 */
name|g_journal_flush
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_journal_release_delayed
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* The flush queue is full, exit. */
if|if
condition|(
name|sc
operator|->
name|sc_flush_count
operator|>=
name|g_journal_accept_immediately
condition|)
return|return;
name|bp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|sc
operator|->
name|sc_delayed_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
return|return;
name|sc
operator|->
name|sc_delayed_count
operator|--
expr_stmt|;
name|g_journal_add_current
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Add I/O request to the current queue. If we have enough requests for one  * journal record we flush them onto active journal provider.  */
end_comment

begin_function
specifier|static
name|void
name|g_journal_add_request
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
comment|/* 	 * The flush queue is full, we need to delay the request. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_delayed_count
operator|>
literal|0
operator|||
name|sc
operator|->
name|sc_flush_count
operator|>=
name|g_journal_accept_immediately
condition|)
block|{
name|GJ_LOGREQ
argument_list|(
literal|4
argument_list|,
name|bp
argument_list|,
literal|"DELAYED"
argument_list|)
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|sc
operator|->
name|sc_delayed_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_delayed_count
operator|++
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_delayed_queue
operator|.
name|queue
argument_list|)
argument_list|,
operator|(
literal|"DELAYED queue not empty."
operator|)
argument_list|)
expr_stmt|;
name|g_journal_add_current
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|g_journal_read_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Try to find requested data in cache.  */
end_comment

begin_function
specifier|static
name|struct
name|bio
modifier|*
name|g_journal_read_find
parameter_list|(
name|struct
name|bio
modifier|*
name|head
parameter_list|,
name|int
name|sorted
parameter_list|,
name|struct
name|bio
modifier|*
name|pbp
parameter_list|,
name|off_t
name|ostart
parameter_list|,
name|off_t
name|oend
parameter_list|)
block|{
name|off_t
name|cstart
decl_stmt|,
name|cend
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|GJQ_FOREACH
argument_list|(
argument|head
argument_list|,
argument|bp
argument_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_offset
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|cstart
operator|=
name|MAX
argument_list|(
name|ostart
argument_list|,
name|bp
operator|->
name|bio_offset
argument_list|)
expr_stmt|;
name|cend
operator|=
name|MIN
argument_list|(
name|oend
argument_list|,
name|bp
operator|->
name|bio_offset
operator|+
name|bp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|cend
operator|<=
name|ostart
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|cstart
operator|>=
name|oend
condition|)
block|{
if|if
condition|(
operator|!
name|sorted
condition|)
continue|continue;
else|else
block|{
name|bp
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bp
operator|->
name|bio_data
operator|==
name|NULL
condition|)
break|break;
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"READ(%p): (%jd, %jd) (bp=%p)"
argument_list|,
name|head
argument_list|,
name|cstart
argument_list|,
name|cend
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bp
operator|->
name|bio_data
operator|+
name|cstart
operator|-
name|bp
operator|->
name|bio_offset
argument_list|,
name|pbp
operator|->
name|bio_data
operator|+
name|cstart
operator|-
name|pbp
operator|->
name|bio_offset
argument_list|,
name|cend
operator|-
name|cstart
argument_list|)
expr_stmt|;
name|pbp
operator|->
name|bio_completed
operator|+=
name|cend
operator|-
name|cstart
expr_stmt|;
if|if
condition|(
name|pbp
operator|->
name|bio_completed
operator|==
name|pbp
operator|->
name|bio_length
condition|)
block|{
comment|/* 			 * Cool, the whole request was in cache, deliver happy 			 * message. 			 */
name|g_io_deliver
argument_list|(
name|pbp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|pbp
operator|)
return|;
block|}
break|break;
block|}
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to find requested data in cache.  */
end_comment

begin_function
specifier|static
name|struct
name|bio
modifier|*
name|g_journal_read_queue_find
parameter_list|(
name|struct
name|bio_queue
modifier|*
name|head
parameter_list|,
name|struct
name|bio
modifier|*
name|pbp
parameter_list|,
name|off_t
name|ostart
parameter_list|,
name|off_t
name|oend
parameter_list|)
block|{
name|off_t
name|cstart
decl_stmt|,
name|cend
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|head
argument_list|,
argument|bio_queue
argument_list|)
block|{
name|cstart
operator|=
name|MAX
argument_list|(
name|ostart
argument_list|,
name|bp
operator|->
name|bio_offset
argument_list|)
expr_stmt|;
name|cend
operator|=
name|MIN
argument_list|(
name|oend
argument_list|,
name|bp
operator|->
name|bio_offset
operator|+
name|bp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|cend
operator|<=
name|ostart
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|cstart
operator|>=
name|oend
condition|)
continue|continue;
name|KASSERT
argument_list|(
name|bp
operator|->
name|bio_data
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: bio_data == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"READ(%p): (%jd, %jd) (bp=%p)"
argument_list|,
name|head
argument_list|,
name|cstart
argument_list|,
name|cend
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|bp
operator|->
name|bio_data
operator|+
name|cstart
operator|-
name|bp
operator|->
name|bio_offset
argument_list|,
name|pbp
operator|->
name|bio_data
operator|+
name|cstart
operator|-
name|pbp
operator|->
name|bio_offset
argument_list|,
name|cend
operator|-
name|cstart
argument_list|)
expr_stmt|;
name|pbp
operator|->
name|bio_completed
operator|+=
name|cend
operator|-
name|cstart
expr_stmt|;
if|if
condition|(
name|pbp
operator|->
name|bio_completed
operator|==
name|pbp
operator|->
name|bio_length
condition|)
block|{
comment|/* 			 * Cool, the whole request was in cache, deliver happy 			 * message. 			 */
name|g_io_deliver
argument_list|(
name|pbp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|pbp
operator|)
return|;
block|}
break|break;
block|}
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is used for colecting data on read.  * The complexity is because parts of the data can be stored in four different  * places:  * - in delayed requests  * - in memory - the data not yet send to the active journal provider  * - in requests which are going to be sent to the active journal  * - in the active journal  * - in the inactive journal  * - in the data provider  */
end_comment

begin_function
specifier|static
name|void
name|g_journal_read
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|pbp
parameter_list|,
name|off_t
name|ostart
parameter_list|,
name|off_t
name|oend
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|,
modifier|*
name|nbp
decl_stmt|,
modifier|*
name|head
decl_stmt|;
name|off_t
name|cstart
decl_stmt|,
name|cend
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|sorted
init|=
literal|0
decl_stmt|;
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"READ: (%jd, %jd)"
argument_list|,
name|ostart
argument_list|,
name|oend
argument_list|)
expr_stmt|;
name|cstart
operator|=
name|cend
operator|=
operator|-
literal|1
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
name|head
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|5
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
comment|/* Delayed requests. */
name|head
operator|=
name|NULL
expr_stmt|;
name|sorted
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Not-yet-send data. */
name|head
operator|=
name|sc
operator|->
name|sc_current_queue
expr_stmt|;
name|sorted
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* In-flight to the active journal. */
name|head
operator|=
name|sc
operator|->
name|sc_flush_queue
expr_stmt|;
name|sorted
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* Active journal. */
name|head
operator|=
name|sc
operator|->
name|sc_active
operator|.
name|jj_queue
expr_stmt|;
name|sorted
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* Inactive journal. */
comment|/* 			 * XXX: Here could be a race with g_journal_lowmem(). 			 */
name|head
operator|=
name|sc
operator|->
name|sc_inactive
operator|.
name|jj_queue
expr_stmt|;
name|sorted
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* In-flight to the data provider. */
name|head
operator|=
name|sc
operator|->
name|sc_copy_queue
expr_stmt|;
name|sorted
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"gjournal %s: i=%d"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|bp
operator|=
name|g_journal_read_queue_find
argument_list|(
operator|&
name|sc
operator|->
name|sc_delayed_queue
operator|.
name|queue
argument_list|,
name|pbp
argument_list|,
name|ostart
argument_list|,
name|oend
argument_list|)
expr_stmt|;
else|else
name|bp
operator|=
name|g_journal_read_find
argument_list|(
name|head
argument_list|,
name|sorted
argument_list|,
name|pbp
argument_list|,
name|ostart
argument_list|,
name|oend
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|pbp
condition|)
block|{
comment|/* Got the whole request. */
name|GJ_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Got the whole request from %u."
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|cstart
operator|=
name|MAX
argument_list|(
name|ostart
argument_list|,
name|bp
operator|->
name|bio_offset
argument_list|)
expr_stmt|;
name|cend
operator|=
name|MIN
argument_list|(
name|oend
argument_list|,
name|bp
operator|->
name|bio_offset
operator|+
name|bp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Got part of the request from %u (%jd-%jd)."
argument_list|,
name|i
argument_list|,
operator|(
name|intmax_t
operator|)
name|cstart
argument_list|,
operator|(
name|intmax_t
operator|)
name|cend
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_data
operator|==
name|NULL
condition|)
block|{
name|nbp
operator|=
name|g_duplicate_bio
argument_list|(
name|pbp
argument_list|)
expr_stmt|;
name|nbp
operator|->
name|bio_cflags
operator|=
name|GJ_BIO_READ
expr_stmt|;
name|nbp
operator|->
name|bio_data
operator|=
name|pbp
operator|->
name|bio_data
operator|+
name|cstart
operator|-
name|pbp
operator|->
name|bio_offset
expr_stmt|;
name|nbp
operator|->
name|bio_offset
operator|=
name|bp
operator|->
name|bio_joffset
operator|+
name|cstart
operator|-
name|bp
operator|->
name|bio_offset
expr_stmt|;
name|nbp
operator|->
name|bio_length
operator|=
name|cend
operator|-
name|cstart
expr_stmt|;
name|nbp
operator|->
name|bio_done
operator|=
name|g_journal_read_done
expr_stmt|;
name|g_io_request
argument_list|(
name|nbp
argument_list|,
name|sc
operator|->
name|sc_jconsumer
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we don't have the whole request yet, call g_journal_read() 		 * recursively. 		 */
if|if
condition|(
name|ostart
operator|<
name|cstart
condition|)
name|g_journal_read
argument_list|(
name|sc
argument_list|,
name|pbp
argument_list|,
name|ostart
argument_list|,
name|cstart
argument_list|)
expr_stmt|;
if|if
condition|(
name|oend
operator|>
name|cend
condition|)
name|g_journal_read
argument_list|(
name|sc
argument_list|,
name|pbp
argument_list|,
name|cend
argument_list|,
name|oend
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * No data in memory, no data in journal. 		 * Its time for asking data provider. 		 */
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"READ(data): (%jd, %jd)"
argument_list|,
name|ostart
argument_list|,
name|oend
argument_list|)
expr_stmt|;
name|nbp
operator|=
name|g_duplicate_bio
argument_list|(
name|pbp
argument_list|)
expr_stmt|;
name|nbp
operator|->
name|bio_cflags
operator|=
name|GJ_BIO_READ
expr_stmt|;
name|nbp
operator|->
name|bio_data
operator|=
name|pbp
operator|->
name|bio_data
operator|+
name|ostart
operator|-
name|pbp
operator|->
name|bio_offset
expr_stmt|;
name|nbp
operator|->
name|bio_offset
operator|=
name|ostart
expr_stmt|;
name|nbp
operator|->
name|bio_length
operator|=
name|oend
operator|-
name|ostart
expr_stmt|;
name|nbp
operator|->
name|bio_done
operator|=
name|g_journal_read_done
expr_stmt|;
name|g_io_request
argument_list|(
name|nbp
argument_list|,
name|sc
operator|->
name|sc_dconsumer
argument_list|)
expr_stmt|;
comment|/* We have the whole request, return here. */
return|return;
block|}
block|}
end_function

begin_comment
comment|/*  * Function responsible for handling finished READ requests.  * Actually, g_std_done() could be used here, the only difference is that we  * log error.  */
end_comment

begin_function
specifier|static
name|void
name|g_journal_read_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|pbp
decl_stmt|;
name|KASSERT
argument_list|(
name|bp
operator|->
name|bio_cflags
operator|==
name|GJ_BIO_READ
argument_list|,
operator|(
literal|"Invalid bio (%d != %d)."
operator|,
name|bp
operator|->
name|bio_cflags
operator|,
name|GJ_BIO_READ
operator|)
argument_list|)
expr_stmt|;
name|pbp
operator|=
name|bp
operator|->
name|bio_parent
expr_stmt|;
name|pbp
operator|->
name|bio_inbed
operator|++
expr_stmt|;
name|pbp
operator|->
name|bio_completed
operator|+=
name|bp
operator|->
name|bio_length
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pbp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|pbp
operator|->
name|bio_error
operator|=
name|bp
operator|->
name|bio_error
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Error while reading data from %s (error=%d)."
argument_list|,
name|bp
operator|->
name|bio_to
operator|->
name|name
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
block|}
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbp
operator|->
name|bio_children
operator|==
name|pbp
operator|->
name|bio_inbed
operator|&&
name|pbp
operator|->
name|bio_completed
operator|==
name|pbp
operator|->
name|bio_length
condition|)
block|{
comment|/* We're done. */
name|g_io_deliver
argument_list|(
name|pbp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Deactive current journal and active next one.  */
end_comment

begin_function
specifier|static
name|void
name|g_journal_switch
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
name|JEMPTY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"No need for %s switch."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|pp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_geom
operator|->
name|provider
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|GJF_DEVICE_CLEAN
operator|)
operator|&&
name|pp
operator|->
name|acw
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|GJF_DEVICE_CLEAN
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Marking %s as clean."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|g_journal_metadata_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"Switching journal %s."
argument_list|,
name|sc
operator|->
name|sc_geom
operator|->
name|name
argument_list|)
expr_stmt|;
name|pp
operator|=
name|sc
operator|->
name|sc_jprovider
expr_stmt|;
name|sc
operator|->
name|sc_journal_previous_id
operator|=
name|sc
operator|->
name|sc_journal_id
expr_stmt|;
name|sc
operator|->
name|sc_journal_id
operator|=
name|sc
operator|->
name|sc_journal_next_id
expr_stmt|;
name|sc
operator|->
name|sc_journal_next_id
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|GJ_VALIDATE_OFFSET
argument_list|(
name|sc
operator|->
name|sc_journal_offset
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|g_journal_write_header
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_inactive
operator|.
name|jj_offset
operator|=
name|sc
operator|->
name|sc_active
operator|.
name|jj_offset
expr_stmt|;
name|sc
operator|->
name|sc_inactive
operator|.
name|jj_queue
operator|=
name|sc
operator|->
name|sc_active
operator|.
name|jj_queue
expr_stmt|;
name|sc
operator|->
name|sc_active
operator|.
name|jj_offset
operator|=
name|sc
operator|->
name|sc_journal_offset
operator|-
name|pp
operator|->
name|sectorsize
expr_stmt|;
name|sc
operator|->
name|sc_active
operator|.
name|jj_queue
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Switch is done, start copying data from the (now) inactive 		 * journal to the data provider. 		 */
name|g_journal_copy_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|GJF_DEVICE_SWITCH
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_journal_initialize
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|sc_journal_id
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_journal_next_id
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_journal_previous_id
operator|=
name|sc
operator|->
name|sc_journal_id
expr_stmt|;
name|sc
operator|->
name|sc_journal_offset
operator|=
name|sc
operator|->
name|sc_jstart
expr_stmt|;
name|sc
operator|->
name|sc_inactive
operator|.
name|jj_offset
operator|=
name|sc
operator|->
name|sc_jstart
expr_stmt|;
name|g_journal_write_header
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_active
operator|.
name|jj_offset
operator|=
name|sc
operator|->
name|sc_jstart
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_journal_mark_as_dirty
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|const
name|struct
name|g_journal_desc
modifier|*
name|desc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|GJ_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Marking file system %s as dirty."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|desc
operator|=
name|g_journal_filesystems
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
name|desc
operator|->
name|jd_dirty
argument_list|(
name|sc
operator|->
name|sc_dconsumer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function read record header from the given journal.  * It is very simlar to g_read_data(9), but it doesn't allocate memory for bio  * and data on every call.  */
end_comment

begin_function
specifier|static
name|int
name|g_journal_sync_read
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|bzero
argument_list|(
name|bp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_cmd
operator|=
name|BIO_READ
expr_stmt|;
name|bp
operator|->
name|bio_done
operator|=
name|NULL
expr_stmt|;
name|bp
operator|->
name|bio_offset
operator|=
name|offset
expr_stmt|;
name|bp
operator|->
name|bio_length
operator|=
name|cp
operator|->
name|provider
operator|->
name|sectorsize
expr_stmt|;
name|bp
operator|->
name|bio_data
operator|=
name|data
expr_stmt|;
name|g_io_request
argument_list|(
name|bp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|error
operator|=
name|biowait
argument_list|(
name|bp
argument_list|,
literal|"gjs_read"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Function is called when we start the journal device and we detect that  * one of the journals was not fully copied.  * The purpose of this function is to read all records headers from journal  * and placed them in the inactive queue, so we can start journal  * synchronization process and the journal provider itself.  * Design decision was taken to not synchronize the whole journal here as it  * can take too much time. Reading headers only and delaying synchronization  * process until after journal provider is started should be the best choice.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|g_journal_sync
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_journal_record_header
name|rhdr
decl_stmt|;
name|struct
name|g_journal_entry
modifier|*
name|ent
decl_stmt|;
name|struct
name|g_journal_header
name|jhdr
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|,
modifier|*
name|fbp
decl_stmt|,
modifier|*
name|tbp
decl_stmt|;
name|off_t
name|joffset
decl_stmt|,
name|offset
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|,
name|sum
index|[
literal|16
index|]
decl_stmt|;
name|uint64_t
name|id
decl_stmt|;
name|MD5_CTX
name|ctx
decl_stmt|;
name|int
name|error
decl_stmt|,
name|found
decl_stmt|,
name|i
decl_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
name|fbp
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|sc
operator|->
name|sc_jconsumer
expr_stmt|;
name|bp
operator|=
name|g_alloc_bio
argument_list|()
expr_stmt|;
name|buf
operator|=
name|gj_malloc
argument_list|(
name|cp
operator|->
name|provider
operator|->
name|sectorsize
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|offset
operator|=
name|joffset
operator|=
name|sc
operator|->
name|sc_inactive
operator|.
name|jj_offset
operator|=
name|sc
operator|->
name|sc_journal_offset
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Looking for termination at %jd."
argument_list|,
operator|(
name|intmax_t
operator|)
name|joffset
argument_list|)
expr_stmt|;
comment|/* 	 * Read and decode first journal header. 	 */
name|error
operator|=
name|g_journal_sync_read
argument_list|(
name|cp
argument_list|,
name|bp
argument_list|,
name|offset
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Error while reading journal header from %s."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|error
operator|=
name|g_journal_header_decode
argument_list|(
name|buf
argument_list|,
operator|&
name|jhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot decode journal header from %s."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|id
operator|=
name|sc
operator|->
name|sc_journal_id
expr_stmt|;
if|if
condition|(
name|jhdr
operator|.
name|jh_journal_id
operator|!=
name|sc
operator|->
name|sc_journal_id
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Journal ID mismatch at %jd (0x%08x != 0x%08x)."
argument_list|,
operator|(
name|intmax_t
operator|)
name|offset
argument_list|,
operator|(
name|u_int
operator|)
name|jhdr
operator|.
name|jh_journal_id
argument_list|,
operator|(
name|u_int
operator|)
name|id
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|offset
operator|+=
name|cp
operator|->
name|provider
operator|->
name|sectorsize
expr_stmt|;
name|id
operator|=
name|sc
operator|->
name|sc_journal_next_id
operator|=
name|jhdr
operator|.
name|jh_journal_next_id
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * If the biggest record won't fit, look for a record header or 		 * journal header from the begining. 		 */
name|GJ_VALIDATE_OFFSET
argument_list|(
name|offset
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_journal_sync_read
argument_list|(
name|cp
argument_list|,
name|bp
argument_list|,
name|offset
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Not good. Having an error while reading header 			 * means, that we cannot read next headers and in 			 * consequence we cannot find termination. 			 */
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Error while reading record header from %s."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|g_journal_record_header_decode
argument_list|(
name|buf
argument_list|,
operator|&
name|rhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Not a record header at %jd (error=%d)."
argument_list|,
operator|(
name|intmax_t
operator|)
name|offset
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 			 * This is not a record header. 			 * If we are lucky, this is next journal header. 			 */
name|error
operator|=
name|g_journal_header_decode
argument_list|(
name|buf
argument_list|,
operator|&
name|jhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Not a journal header at %jd (error=%d)."
argument_list|,
operator|(
name|intmax_t
operator|)
name|offset
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 				 * Nope, this is not journal header, which 				 * bascially means that journal is not 				 * terminated properly. 				 */
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
comment|/* 			 * Ok. This is header of _some_ journal. Now we need to 			 * verify if this is header of the _next_ journal. 			 */
if|if
condition|(
name|jhdr
operator|.
name|jh_journal_id
operator|!=
name|id
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Journal ID mismatch at %jd "
literal|"(0x%08x != 0x%08x)."
argument_list|,
operator|(
name|intmax_t
operator|)
name|offset
argument_list|,
operator|(
name|u_int
operator|)
name|jhdr
operator|.
name|jh_journal_id
argument_list|,
operator|(
name|u_int
operator|)
name|id
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
comment|/* Found termination. */
name|found
operator|++
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Found termination at %jd (id=0x%08x)."
argument_list|,
operator|(
name|intmax_t
operator|)
name|offset
argument_list|,
operator|(
name|u_int
operator|)
name|id
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_active
operator|.
name|jj_offset
operator|=
name|offset
expr_stmt|;
name|sc
operator|->
name|sc_journal_offset
operator|=
name|offset
operator|+
name|cp
operator|->
name|provider
operator|->
name|sectorsize
expr_stmt|;
name|sc
operator|->
name|sc_journal_id
operator|=
name|id
expr_stmt|;
name|id
operator|=
name|sc
operator|->
name|sc_journal_next_id
operator|=
name|jhdr
operator|.
name|jh_journal_next_id
expr_stmt|;
while|while
condition|(
operator|(
name|tbp
operator|=
name|fbp
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fbp
operator|=
name|tbp
operator|->
name|bio_next
expr_stmt|;
name|GJ_LOGREQ
argument_list|(
literal|3
argument_list|,
name|tbp
argument_list|,
literal|"Adding request."
argument_list|)
expr_stmt|;
name|g_journal_insert_bio
argument_list|(
operator|&
name|sc
operator|->
name|sc_inactive
operator|.
name|jj_queue
argument_list|,
name|tbp
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
comment|/* Skip journal's header. */
name|offset
operator|+=
name|cp
operator|->
name|provider
operator|->
name|sectorsize
expr_stmt|;
continue|continue;
block|}
comment|/* Skip record's header. */
name|offset
operator|+=
name|cp
operator|->
name|provider
operator|->
name|sectorsize
expr_stmt|;
comment|/* 		 * Add information about every record entry to the inactive 		 * queue. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|GJF_DEVICE_CHECKSUM
condition|)
name|MD5Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rhdr
operator|.
name|jrh_nentries
condition|;
name|i
operator|++
control|)
block|{
name|ent
operator|=
operator|&
name|rhdr
operator|.
name|jrh_entries
index|[
name|i
index|]
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"Insert entry: %jd %jd."
argument_list|,
operator|(
name|intmax_t
operator|)
name|ent
operator|->
name|je_offset
argument_list|,
operator|(
name|intmax_t
operator|)
name|ent
operator|->
name|je_length
argument_list|)
expr_stmt|;
name|g_journal_insert
argument_list|(
operator|&
name|fbp
argument_list|,
name|ent
operator|->
name|je_offset
argument_list|,
name|ent
operator|->
name|je_offset
operator|+
name|ent
operator|->
name|je_length
argument_list|,
name|ent
operator|->
name|je_joffset
argument_list|,
name|NULL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|GJF_DEVICE_CHECKSUM
condition|)
block|{
name|u_char
modifier|*
name|buf2
decl_stmt|;
comment|/* 				 * TODO: Should use faster function (like 				 *       g_journal_sync_read()). 				 */
name|buf2
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|offset
argument_list|,
name|ent
operator|->
name|je_length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf2
operator|==
name|NULL
condition|)
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot read data at %jd."
argument_list|,
operator|(
name|intmax_t
operator|)
name|offset
argument_list|)
expr_stmt|;
else|else
block|{
name|MD5Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|buf2
argument_list|,
name|ent
operator|->
name|je_length
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Skip entry's data. */
name|offset
operator|+=
name|ent
operator|->
name|je_length
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|GJF_DEVICE_CHECKSUM
condition|)
block|{
name|MD5Final
argument_list|(
name|sum
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|sum
argument_list|,
name|rhdr
operator|.
name|jrh_sum
argument_list|,
sizeof|sizeof
argument_list|(
name|rhdr
operator|.
name|jrh_sum
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"MD5 hash mismatch at %jd!"
argument_list|,
operator|(
name|intmax_t
operator|)
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|end
label|:
name|gj_free
argument_list|(
name|bp
operator|->
name|bio_data
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* Remove bios from unterminated journal. */
while|while
condition|(
operator|(
name|tbp
operator|=
name|fbp
operator|)
operator|!=
name|NULL
condition|)
block|{
name|fbp
operator|=
name|tbp
operator|->
name|bio_next
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|tbp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|<
literal|1
operator|&&
name|joffset
operator|>
literal|0
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Journal on %s is broken/corrupted. Initializing."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|tbp
operator|=
name|sc
operator|->
name|sc_inactive
operator|.
name|jj_queue
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_inactive
operator|.
name|jj_queue
operator|=
name|tbp
operator|->
name|bio_next
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|tbp
argument_list|)
expr_stmt|;
block|}
name|g_journal_initialize
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|g_journal_mark_as_dirty
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Journal %s consistent."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|g_journal_copy_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Wait for requests.  * If we have requests in the current queue, flush them after 3 seconds from the  * last flush. In this way we don't wait forever (or for journal switch) with  * storing not full records on journal.  */
end_comment

begin_function
specifier|static
name|void
name|g_journal_wait
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|,
name|time_t
name|last_write
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|timeout
decl_stmt|;
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"%s: enter"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_current_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|g_journal_debug
operator|<
literal|2
condition|)
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PRIBIO
operator||
name|PDROP
argument_list|,
literal|"gj:work"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 			 * If we have debug turned on, show number of elements 			 * in various queues. 			 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PRIBIO
argument_list|,
literal|"gj:work"
argument_list|,
name|hz
operator|*
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
break|break;
block|}
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"Report: current count=%d"
argument_list|,
name|sc
operator|->
name|sc_current_count
argument_list|)
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"Report: flush count=%d"
argument_list|,
name|sc
operator|->
name|sc_flush_count
argument_list|)
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"Report: flush in progress=%d"
argument_list|,
name|sc
operator|->
name|sc_flush_in_progress
argument_list|)
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"Report: copy in progress=%d"
argument_list|,
name|sc
operator|->
name|sc_copy_in_progress
argument_list|)
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"Report: delayed=%d"
argument_list|,
name|sc
operator|->
name|sc_delayed_count
argument_list|)
expr_stmt|;
block|}
block|}
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"%s: exit 1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Flush even not full records every 3 seconds. 	 */
name|timeout
operator|=
operator|(
name|last_write
operator|+
literal|3
operator|-
name|time_second
operator|)
operator|*
name|hz
expr_stmt|;
if|if
condition|(
name|timeout
operator|<=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|g_journal_flush
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|g_journal_flush_send
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"%s: exit 2"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
operator|=
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PRIBIO
operator||
name|PDROP
argument_list|,
literal|"gj:work"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
name|g_journal_flush_send
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"%s: exit 3"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Worker thread.  */
end_comment

begin_function
specifier|static
name|void
name|g_journal_worker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|g_journal_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|time_t
name|last_write
decl_stmt|;
name|int
name|type
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|sched_prio
argument_list|(
name|curthread
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
comment|/* gcc */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|GJF_DEVICE_CLEAN
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Journal %s clean."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|g_journal_initialize
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_journal_sync
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check if we can use BIO_FLUSH. 	 */
name|sc
operator|->
name|sc_bio_flush
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|g_io_flush
argument_list|(
name|sc
operator|->
name|sc_jconsumer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_bio_flush
operator||=
name|GJ_FLUSH_JOURNAL
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"BIO_FLUSH supported by %s."
argument_list|,
name|sc
operator|->
name|sc_jconsumer
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"BIO_FLUSH not supported by %s."
argument_list|,
name|sc
operator|->
name|sc_jconsumer
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_jconsumer
operator|!=
name|sc
operator|->
name|sc_dconsumer
condition|)
block|{
if|if
condition|(
name|g_io_flush
argument_list|(
name|sc
operator|->
name|sc_dconsumer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_bio_flush
operator||=
name|GJ_FLUSH_DATA
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"BIO_FLUSH supported by %s."
argument_list|,
name|sc
operator|->
name|sc_dconsumer
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"BIO_FLUSH not supported by %s."
argument_list|,
name|sc
operator|->
name|sc_dconsumer
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|gp
operator|=
name|sc
operator|->
name|sc_geom
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|pp
operator|=
name|g_new_providerf
argument_list|(
name|gp
argument_list|,
literal|"%s.journal"
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Cannot create %s.journal."
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
name|pp
operator|->
name|mediasize
operator|=
name|sc
operator|->
name|sc_mediasize
expr_stmt|;
comment|/* 	 * There could be a problem when data provider and journal providers 	 * have different sectorsize, but such scenario is prevented on journal 	 * creation. 	 */
name|pp
operator|->
name|sectorsize
operator|=
name|sc
operator|->
name|sc_sectorsize
expr_stmt|;
name|g_error_provider
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|last_write
operator|=
name|time_second
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Get first request from the queue. */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|sc
operator|->
name|sc_back_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|type
operator|=
operator|(
name|bp
operator|->
name|bio_cflags
operator|&
name|GJ_BIO_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|sc
operator|->
name|sc_regular_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|type
operator|=
name|GJ_BIO_REGULAR
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|try_switch
label|:
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|GJF_DEVICE_SWITCH
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|GJF_DEVICE_DESTROY
operator|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_current_count
operator|>
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|g_journal_flush
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|g_journal_flush_send
argument_list|(
name|sc
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flush_in_progress
operator|>
literal|0
condition|)
goto|goto
name|sleep
goto|;
if|if
condition|(
name|sc
operator|->
name|sc_copy_in_progress
operator|>
literal|0
condition|)
goto|goto
name|sleep
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|GJF_DEVICE_SWITCH
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|g_journal_switch
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_journal_copying
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|GJF_DEVICE_DESTROY
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Shutting down worker "
literal|"thread for %s."
argument_list|,
name|gp
operator|->
name|name
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_worker
operator|=
name|NULL
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_worker
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|sleep
label|:
name|g_journal_wait
argument_list|(
name|sc
argument_list|,
name|last_write
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If we're in switch process, we need to delay all new 		 * write requests until its done. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|GJF_DEVICE_SWITCH
operator|)
operator|&&
name|type
operator|==
name|GJ_BIO_REGULAR
operator|&&
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
condition|)
block|{
name|GJ_LOGREQ
argument_list|(
literal|2
argument_list|,
name|bp
argument_list|,
literal|"WRITE on SWITCH"
argument_list|)
expr_stmt|;
goto|goto
name|try_switch
goto|;
block|}
if|if
condition|(
name|type
operator|==
name|GJ_BIO_REGULAR
condition|)
name|bioq_remove
argument_list|(
operator|&
name|sc
operator|->
name|sc_regular_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
else|else
name|bioq_remove
argument_list|(
operator|&
name|sc
operator|->
name|sc_back_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GJ_BIO_REGULAR
case|:
comment|/* Regular request. */
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
name|g_journal_read
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|,
name|bp
operator|->
name|bio_offset
argument_list|,
name|bp
operator|->
name|bio_offset
operator|+
name|bp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_WRITE
case|:
name|last_write
operator|=
name|time_second
expr_stmt|;
name|g_journal_add_request
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|g_journal_flush_send
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Invalid bio_cmd (%d)."
argument_list|,
name|bp
operator|->
name|bio_cmd
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GJ_BIO_COPY
case|:
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
if|if
condition|(
name|g_journal_copy_read_done
argument_list|(
name|bp
argument_list|)
condition|)
name|g_journal_copy_send
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_WRITE
case|:
name|g_journal_copy_write_done
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|g_journal_copy_send
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Invalid bio_cmd (%d)."
argument_list|,
name|bp
operator|->
name|bio_cmd
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GJ_BIO_JOURNAL
case|:
name|g_journal_flush_done
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|g_journal_flush_send
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|GJ_BIO_READ
case|:
default|default:
name|panic
argument_list|(
literal|"Invalid bio (%d)."
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_journal_destroy_event
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
name|__unused
parameter_list|)
block|{
name|struct
name|g_journal_softc
modifier|*
name|sc
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|g_journal_destroy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_journal_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|g_journal_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Timeout. Journal %s cannot be completed."
argument_list|,
name|sc
operator|->
name|sc_geom
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_post_event
argument_list|(
name|g_journal_destroy_event
argument_list|,
name|sc
argument_list|,
name|M_NOWAIT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|g_geom
modifier|*
name|g_journal_create
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
specifier|const
name|struct
name|g_journal_metadata
modifier|*
name|md
parameter_list|)
block|{
name|struct
name|g_journal_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|NULL
expr_stmt|;
comment|/* gcc */
name|g_topology_assert
argument_list|()
expr_stmt|;
comment|/* 	 * There are two possibilities: 	 * 1. Data and both journals are on the same provider. 	 * 2. Data and journals are all on separated providers. 	 */
comment|/* Look for journal device with the same ID. */
name|LIST_FOREACH
argument_list|(
argument|gp
argument_list|,
argument|&mp->geom
argument_list|,
argument|geom
argument_list|)
block|{
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|sc
operator|->
name|sc_id
operator|==
name|md
operator|->
name|md_id
condition|)
break|break;
block|}
if|if
condition|(
name|gp
operator|==
name|NULL
condition|)
name|sc
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|!=
name|NULL
operator|&&
operator|(
name|sc
operator|->
name|sc_type
operator|&
name|md
operator|->
name|md_type
operator|)
operator|!=
literal|0
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Journal device %u already configured."
argument_list|,
name|sc
operator|->
name|sc_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|md
operator|->
name|md_type
operator|==
literal|0
operator|||
operator|(
name|md
operator|->
name|md_type
operator|&
operator|~
name|GJ_TYPE_COMPLETE
operator|)
operator|!=
literal|0
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Invalid type on %s."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|md
operator|->
name|md_type
operator|&
name|GJ_TYPE_DATA
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Journal %u: %s contains data."
argument_list|,
name|md
operator|->
name|md_id
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|md
operator|->
name|md_type
operator|&
name|GJ_TYPE_JOURNAL
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Journal %u: %s contains journal."
argument_list|,
name|md
operator|->
name|md_id
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
comment|/* Action geom. */
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_JOURNAL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_id
operator|=
name|md
operator|->
name|md_id
expr_stmt|;
name|sc
operator|->
name|sc_type
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_worker
operator|=
name|NULL
expr_stmt|;
name|gp
operator|=
name|g_new_geomf
argument_list|(
name|mp
argument_list|,
literal|"gjournal %u"
argument_list|,
name|sc
operator|->
name|sc_id
argument_list|)
expr_stmt|;
name|gp
operator|->
name|start
operator|=
name|g_journal_start
expr_stmt|;
name|gp
operator|->
name|orphan
operator|=
name|g_journal_orphan
expr_stmt|;
name|gp
operator|->
name|access
operator|=
name|g_journal_access
expr_stmt|;
name|gp
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_geom
operator|=
name|gp
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|"gjournal"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_back_queue
argument_list|)
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_regular_queue
argument_list|)
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_delayed_queue
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_delayed_count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_current_queue
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_current_count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flush_queue
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_flush_count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flush_in_progress
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_copy_queue
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_copy_in_progress
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_inactive
operator|.
name|jj_queue
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_active
operator|.
name|jj_queue
operator|=
name|NULL
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|md_type
operator|!=
name|GJ_TYPE_COMPLETE
condition|)
block|{
comment|/* 			 * Journal and data are on separate providers. 			 * At this point we have only one of them. 			 * We setup a timeout in case the other part will not 			 * appear, so we won't wait forever. 			 */
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|,
literal|5
operator|*
name|hz
argument_list|,
name|g_journal_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Remember type of the data provider. */
if|if
condition|(
name|md
operator|->
name|md_type
operator|&
name|GJ_TYPE_DATA
condition|)
name|sc
operator|->
name|sc_orig_type
operator|=
name|md
operator|->
name|md_type
expr_stmt|;
name|sc
operator|->
name|sc_type
operator||=
name|md
operator|->
name|md_type
expr_stmt|;
name|cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|md_type
operator|&
name|GJ_TYPE_DATA
condition|)
block|{
if|if
condition|(
name|md
operator|->
name|md_flags
operator|&
name|GJ_FLAG_CLEAN
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|GJF_DEVICE_CLEAN
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|md_flags
operator|&
name|GJ_FLAG_CHECKSUM
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|GJF_DEVICE_CHECKSUM
expr_stmt|;
name|cp
operator|=
name|g_new_consumer
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_attach
argument_list|(
name|cp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"Cannot attach to %s (error=%d)."
operator|,
name|pp
operator|->
name|name
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot access %s (error=%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|g_journal_destroy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sc
operator|->
name|sc_dconsumer
operator|=
name|cp
expr_stmt|;
name|sc
operator|->
name|sc_mediasize
operator|=
name|pp
operator|->
name|mediasize
operator|-
name|pp
operator|->
name|sectorsize
expr_stmt|;
name|sc
operator|->
name|sc_sectorsize
operator|=
name|pp
operator|->
name|sectorsize
expr_stmt|;
name|sc
operator|->
name|sc_jstart
operator|=
name|md
operator|->
name|md_jstart
expr_stmt|;
name|sc
operator|->
name|sc_jend
operator|=
name|md
operator|->
name|md_jend
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|md_provider
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|GJF_DEVICE_HARDCODED
expr_stmt|;
name|sc
operator|->
name|sc_journal_offset
operator|=
name|md
operator|->
name|md_joffset
expr_stmt|;
name|sc
operator|->
name|sc_journal_id
operator|=
name|md
operator|->
name|md_jid
expr_stmt|;
name|sc
operator|->
name|sc_journal_previous_id
operator|=
name|md
operator|->
name|md_jid
expr_stmt|;
block|}
if|if
condition|(
name|md
operator|->
name|md_type
operator|&
name|GJ_TYPE_JOURNAL
condition|)
block|{
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|cp
operator|=
name|g_new_consumer
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_attach
argument_list|(
name|cp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"Cannot attach to %s (error=%d)."
operator|,
name|pp
operator|->
name|name
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot access %s (error=%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|g_journal_destroy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 			 * Journal is on the same provider as data, which means 			 * that data provider ends where journal starts. 			 */
name|sc
operator|->
name|sc_mediasize
operator|=
name|md
operator|->
name|md_jstart
expr_stmt|;
block|}
name|sc
operator|->
name|sc_jconsumer
operator|=
name|cp
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_type
operator|&
name|GJ_TYPE_COMPLETE
operator|)
operator|!=
name|GJ_TYPE_COMPLETE
condition|)
block|{
comment|/* Journal is not complete yet. */
return|return
operator|(
name|gp
operator|)
return|;
block|}
else|else
block|{
comment|/* Journal complete, cancel timeout. */
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|kthread_create
argument_list|(
name|g_journal_worker
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_worker
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"g_journal %s"
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot create worker thread for %s.journal."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|g_journal_destroy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|gp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_journal_destroy_consumer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
name|__unused
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|cp
operator|=
name|arg
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_journal_destroy
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|gp
operator|=
name|sc
operator|->
name|sc_geom
expr_stmt|;
name|pp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|gp
operator|->
name|provider
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pp
operator|->
name|acr
operator|!=
literal|0
operator|||
name|pp
operator|->
name|acw
operator|!=
literal|0
operator|||
name|pp
operator|->
name|ace
operator|!=
literal|0
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Device %s is still open (r%dw%de%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|pp
operator|->
name|acr
argument_list|,
name|pp
operator|->
name|acw
argument_list|,
name|pp
operator|->
name|ace
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|g_error_provider
argument_list|(
name|pp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|g_journal_flush
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|g_journal_flush_send
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|g_journal_switch
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_flags
operator||=
operator|(
name|GJF_DEVICE_DESTROY
operator||
name|GJF_DEVICE_CLEAN
operator|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|sc_worker
operator|!=
name|NULL
condition|)
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_worker
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PRIBIO
argument_list|,
literal|"gj:destroy"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|!=
name|NULL
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Marking %s as clean."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|g_journal_metadata_update
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|pp
operator|->
name|flags
operator||=
name|G_PF_WITHER
expr_stmt|;
name|g_orphan_provider
argument_list|(
name|pp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_topology_lock
argument_list|()
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_current_count
operator|!=
literal|0
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Warning! Number of current requests %d."
argument_list|,
name|sc
operator|->
name|sc_current_count
argument_list|)
expr_stmt|;
block|}
name|LIST_FOREACH
argument_list|(
argument|cp
argument_list|,
argument|&gp->consumer
argument_list|,
argument|consumer
argument_list|)
block|{
if|if
condition|(
name|cp
operator|->
name|acr
operator|+
name|cp
operator|->
name|acw
operator|+
name|cp
operator|->
name|ace
operator|>
literal|0
condition|)
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * We keep all consumers open for writting, so if I'll detach 		 * and destroy consumer here, I'll get providers for taste, so 		 * journal will be started again. 		 * Sending an event here, prevents this from happening. 		 */
name|g_post_event
argument_list|(
name|g_journal_destroy_consumer
argument_list|,
name|cp
argument_list|,
name|M_WAITOK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|gp
operator|->
name|softc
operator|=
name|NULL
expr_stmt|;
name|g_wither_geom
argument_list|(
name|gp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_JOURNAL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_journal_taste_orphan
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|KASSERT
argument_list|(
literal|1
operator|==
literal|0
argument_list|,
operator|(
literal|"%s called while tasting %s."
operator|,
name|__func__
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|g_geom
modifier|*
name|g_journal_taste
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|flags
name|__unused
parameter_list|)
block|{
name|struct
name|g_journal_metadata
name|md
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"%s(%s, %s)"
argument_list|,
name|__func__
argument_list|,
name|mp
operator|->
name|name
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Tasting %s."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|geom
operator|->
name|class
operator|==
name|mp
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|gp
operator|=
name|g_new_geomf
argument_list|(
name|mp
argument_list|,
literal|"journal:taste"
argument_list|)
expr_stmt|;
comment|/* This orphan function should be never called. */
name|gp
operator|->
name|orphan
operator|=
name|g_journal_taste_orphan
expr_stmt|;
name|cp
operator|=
name|g_new_consumer
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|g_attach
argument_list|(
name|cp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_journal_metadata_read
argument_list|(
name|cp
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_geom
argument_list|(
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|gp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|md
operator|.
name|md_provider
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|strcmp
argument_list|(
name|md
operator|.
name|md_provider
argument_list|,
name|pp
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|md
operator|.
name|md_provsize
operator|!=
literal|0
operator|&&
name|md
operator|.
name|md_provsize
operator|!=
name|pp
operator|->
name|mediasize
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|g_journal_debug
operator|>=
literal|2
condition|)
name|journal_metadata_dump
argument_list|(
operator|&
name|md
argument_list|)
expr_stmt|;
name|gp
operator|=
name|g_journal_create
argument_list|(
name|mp
argument_list|,
name|pp
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
return|return
operator|(
name|gp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|g_journal_softc
modifier|*
name|g_journal_find_device
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|g_journal_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|name
operator|+=
literal|5
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|gp
argument_list|,
argument|&mp->geom
argument_list|,
argument|geom
argument_list|)
block|{
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|GJF_DEVICE_DESTROY
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_type
operator|&
name|GJ_TYPE_COMPLETE
operator|)
operator|!=
name|GJ_TYPE_COMPLETE
condition|)
continue|continue;
name|pp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|gp
operator|->
name|provider
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sc
operator|->
name|sc_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|sc
operator|)
return|;
if|if
condition|(
name|pp
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|pp
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|sc
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_journal_ctl_destroy
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|g_journal_softc
modifier|*
name|sc
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|param
index|[
literal|16
index|]
decl_stmt|;
name|int
modifier|*
name|nargs
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|nargs
operator|=
name|gctl_get_paraml
argument_list|(
name|req
argument_list|,
literal|"nargs"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nargs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nargs
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No '%s' argument."
argument_list|,
literal|"nargs"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|nargs
operator|<=
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Missing device(s)."
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|param
argument_list|,
sizeof|sizeof
argument_list|(
name|param
argument_list|)
argument_list|,
literal|"arg%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|name
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No 'arg%d' argument."
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|=
name|g_journal_find_device
argument_list|(
name|mp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No such device: %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
operator|=
name|g_journal_destroy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Cannot destroy device %s (error=%d)."
argument_list|,
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_geom
operator|->
name|provider
argument_list|)
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_journal_ctl_sync
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
name|__unused
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
name|__unused
parameter_list|)
block|{
name|g_topology_assert
argument_list|()
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|g_journal_sync_requested
operator|++
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|g_journal_switcher_state
argument_list|)
expr_stmt|;
while|while
condition|(
name|g_journal_sync_requested
operator|>
literal|0
condition|)
name|tsleep
argument_list|(
operator|&
name|g_journal_sync_requested
argument_list|,
name|PRIBIO
argument_list|,
literal|"j:sreq"
argument_list|,
name|hz
operator|/
literal|2
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_journal_config
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
specifier|const
name|char
modifier|*
name|verb
parameter_list|)
block|{
name|uint32_t
modifier|*
name|version
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|version
operator|=
name|gctl_get_paraml
argument_list|(
name|req
argument_list|,
literal|"version"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|version
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No '%s' argument."
argument_list|,
literal|"version"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|version
operator|!=
name|G_JOURNAL_VERSION
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Userland and kernel parts are out of sync."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"destroy"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"stop"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|g_journal_ctl_destroy
argument_list|(
name|req
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"sync"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|g_journal_ctl_sync
argument_list|(
name|req
argument_list|,
name|mp
argument_list|)
expr_stmt|;
return|return;
block|}
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Unknown verb."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_journal_dumpconf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|)
block|{
name|struct
name|g_journal_softc
modifier|*
name|sc
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|pp
operator|!=
name|NULL
condition|)
block|{
comment|/* Nothing here. */
block|}
elseif|else
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Role>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|sc
operator|->
name|sc_dconsumer
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Data"
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|==
name|sc
operator|->
name|sc_jconsumer
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"Journal"
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</Role>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|sc
operator|->
name|sc_jconsumer
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"<Jstart>%jd</Jstart>\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|sc
operator|->
name|sc_jstart
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"<Jend>%jd</Jend>\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|sc
operator|->
name|sc_jend
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<ID>%u</ID>\n"
argument_list|,
name|indent
argument_list|,
operator|(
name|u_int
operator|)
name|sc
operator|->
name|sc_id
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|g_journal_event_shutdown
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|g_journal_event_lowmem
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|g_journal_shutdown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
name|__unused
parameter_list|)
block|{
name|struct
name|g_class
modifier|*
name|mp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|,
modifier|*
name|gp2
decl_stmt|;
if|if
condition|(
name|panicstr
operator|!=
name|NULL
condition|)
return|return;
name|mp
operator|=
name|arg
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|gp
argument_list|,
argument|&mp->geom
argument_list|,
argument|geom
argument_list|,
argument|gp2
argument_list|)
block|{
if|if
condition|(
name|gp
operator|->
name|softc
operator|==
name|NULL
condition|)
continue|continue;
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Shutting down geom %s."
argument_list|,
name|gp
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_journal_destroy
argument_list|(
name|gp
operator|->
name|softc
argument_list|)
expr_stmt|;
block|}
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free cached requests from inactive queue in case of low memory.  * We free GJ_FREE_AT_ONCE elements at once.  */
end_comment

begin_define
define|#
directive|define
name|GJ_FREE_AT_ONCE
value|4
end_define

begin_function
specifier|static
name|void
name|g_journal_lowmem
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
name|__unused
parameter_list|)
block|{
name|struct
name|g_journal_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_class
modifier|*
name|mp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|u_int
name|nfree
init|=
name|GJ_FREE_AT_ONCE
decl_stmt|;
name|g_journal_stats_low_mem
operator|++
expr_stmt|;
name|mp
operator|=
name|arg
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|gp
argument_list|,
argument|&mp->geom
argument_list|,
argument|geom
argument_list|)
block|{
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|GJF_DEVICE_DESTROY
operator|)
condition|)
continue|continue;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|sc
operator|->
name|sc_inactive
operator|.
name|jj_queue
init|;
name|nfree
operator|>
literal|0
operator|&&
name|bp
operator|!=
name|NULL
condition|;
name|nfree
operator|--
operator|,
name|bp
operator|=
name|bp
operator|->
name|bio_next
control|)
block|{
comment|/* 			 * This is safe to free the bio_data, because: 			 * 1. If bio_data is NULL it will be read from the 			 *    inactive journal. 			 * 2. If bp is sent down, it is first removed from the 			 *    inactive queue, so it's impossible to free the 			 *    data from under in-flight bio. 			 * On the other hand, freeing elements from the active 			 * queue, is not safe. 			 */
if|if
condition|(
name|bp
operator|->
name|bio_data
operator|!=
name|NULL
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Freeing data from %s."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|gj_free
argument_list|(
name|bp
operator|->
name|bio_data
argument_list|,
name|bp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_data
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfree
operator|==
literal|0
condition|)
break|break;
block|}
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|g_journal_switcher
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|g_journal_init
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
comment|/* Pick a conservative value if provided value sucks. */
if|if
condition|(
name|g_journal_cache_divisor
operator|<=
literal|0
operator|||
operator|(
name|vm_kmem_size
operator|/
name|g_journal_cache_divisor
operator|==
literal|0
operator|)
condition|)
block|{
name|g_journal_cache_divisor
operator|=
literal|5
expr_stmt|;
block|}
if|if
condition|(
name|g_journal_cache_limit
operator|>
literal|0
condition|)
block|{
name|g_journal_cache_limit
operator|=
name|vm_kmem_size
operator|/
name|g_journal_cache_divisor
expr_stmt|;
name|g_journal_cache_low
operator|=
operator|(
name|g_journal_cache_limit
operator|/
literal|100
operator|)
operator|*
name|g_journal_cache_switch
expr_stmt|;
block|}
name|g_journal_event_shutdown
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_post_sync
argument_list|,
name|g_journal_shutdown
argument_list|,
name|mp
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_journal_event_shutdown
operator|==
name|NULL
condition|)
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Warning! Cannot register shutdown event."
argument_list|)
expr_stmt|;
name|g_journal_event_lowmem
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vm_lowmem
argument_list|,
name|g_journal_lowmem
argument_list|,
name|mp
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_journal_event_lowmem
operator|==
name|NULL
condition|)
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Warning! Cannot register lowmem event."
argument_list|)
expr_stmt|;
name|error
operator|=
name|kthread_create
argument_list|(
name|g_journal_switcher
argument_list|,
name|mp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"g_journal switcher"
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"Cannot create switcher thread."
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_journal_fini
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
block|{
if|if
condition|(
name|g_journal_event_shutdown
operator|!=
name|NULL
condition|)
block|{
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|shutdown_post_sync
argument_list|,
name|g_journal_event_shutdown
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|g_journal_event_lowmem
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vm_lowmem
argument_list|,
name|g_journal_event_lowmem
argument_list|)
expr_stmt|;
name|g_journal_switcher_state
operator|=
name|GJ_SWITCHER_DIE
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|g_journal_switcher_state
argument_list|)
expr_stmt|;
while|while
condition|(
name|g_journal_switcher_state
operator|!=
name|GJ_SWITCHER_DIED
condition|)
name|tsleep
argument_list|(
operator|&
name|g_journal_switcher_state
argument_list|,
name|PRIBIO
argument_list|,
literal|"jfini:wait"
argument_list|,
name|hz
operator|/
literal|5
argument_list|)
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Switcher died."
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|DECLARE_GEOM_CLASS
argument_list|(
name|g_journal_class
argument_list|,
name|g_journal
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
specifier|const
name|struct
name|g_journal_desc
modifier|*
name|g_journal_find_desc
parameter_list|(
specifier|const
name|char
modifier|*
name|fstype
parameter_list|)
block|{
specifier|const
name|struct
name|g_journal_desc
modifier|*
name|desc
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|desc
operator|=
name|g_journal_filesystems
index|[
name|i
operator|=
literal|0
index|]
init|;
name|desc
operator|!=
name|NULL
condition|;
name|desc
operator|=
name|g_journal_filesystems
index|[
operator|++
name|i
index|]
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|desc
operator|->
name|jd_fstype
argument_list|,
name|fstype
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|desc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_journal_switch_wait
parameter_list|(
name|struct
name|g_journal_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_journal_debug
operator|>=
literal|2
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flush_in_progress
operator|>
literal|0
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"%d requests flushing."
argument_list|,
name|sc
operator|->
name|sc_flush_in_progress
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_copy_in_progress
operator|>
literal|0
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"%d requests copying."
argument_list|,
name|sc
operator|->
name|sc_copy_in_progress
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flush_count
operator|>
literal|0
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"%d requests to flush."
argument_list|,
name|sc
operator|->
name|sc_flush_count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_delayed_count
operator|>
literal|0
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"%d requests delayed."
argument_list|,
name|sc
operator|->
name|sc_delayed_count
argument_list|)
expr_stmt|;
block|}
block|}
name|g_journal_stats_switches
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_copy_in_progress
operator|>
literal|0
condition|)
name|g_journal_stats_wait_for_copy
operator|++
expr_stmt|;
name|GJ_TIMER_START
argument_list|(
literal|1
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|GJF_DEVICE_BEFORE_SWITCH
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|GJF_DEVICE_SWITCH
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|GJF_DEVICE_SWITCH
condition|)
block|{
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_journal_copying
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|PRIBIO
argument_list|,
literal|"gj:switch"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|GJ_TIMER_STOP
argument_list|(
literal|1
argument_list|,
operator|&
name|bt
argument_list|,
literal|"Switch time of %s"
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_journal_do_switch
parameter_list|(
name|struct
name|g_class
modifier|*
name|classp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|g_journal_softc
modifier|*
name|sc
decl_stmt|;
specifier|const
name|struct
name|g_journal_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|bintime
name|bt
decl_stmt|;
name|char
modifier|*
name|mountpoint
decl_stmt|;
name|int
name|error
decl_stmt|,
name|vfslocked
decl_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|gp
argument_list|,
argument|&classp->geom
argument_list|,
argument|geom
argument_list|)
block|{
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|GJF_DEVICE_DESTROY
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_type
operator|&
name|GJ_TYPE_COMPLETE
operator|)
operator|!=
name|GJ_TYPE_COMPLETE
condition|)
continue|continue;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|GJF_DEVICE_BEFORE_SWITCH
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
block|}
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|mp
argument_list|,
argument|&mountlist
argument_list|,
argument|mnt_list
argument_list|)
block|{
if|if
condition|(
name|mp
operator|->
name|mnt_gjprovider
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
condition|)
continue|continue;
name|desc
operator|=
name|g_journal_find_desc
argument_list|(
name|mp
operator|->
name|mnt_stat
operator|.
name|f_fstypename
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|vfs_busy
argument_list|(
name|mp
argument_list|,
name|LK_NOWAIT
argument_list|,
operator|&
name|mountlist_mtx
argument_list|,
name|td
argument_list|)
condition|)
continue|continue;
comment|/* mtx_unlock(&mountlist_mtx) was done inside vfs_busy() */
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|sc
operator|=
name|g_journal_find_device
argument_list|(
name|classp
argument_list|,
name|mp
operator|->
name|mnt_gjprovider
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot find journal geom for %s."
argument_list|,
name|mp
operator|->
name|mnt_gjprovider
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
elseif|else
if|if
condition|(
name|JEMPTY
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|GJF_DEVICE_BEFORE_SWITCH
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"No need for %s switch."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|mountpoint
operator|=
name|mp
operator|->
name|mnt_stat
operator|.
name|f_mntonname
expr_stmt|;
name|vfslocked
operator|=
name|VFS_LOCK_GIANT
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_start_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|mp
argument_list|,
name|V_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"vn_start_write(%s) failed (error=%d)."
argument_list|,
name|mountpoint
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_noasync
operator|++
expr_stmt|;
name|mp
operator|->
name|mnt_kern_flag
operator|&=
operator|~
name|MNTK_ASYNC
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|GJ_TIMER_START
argument_list|(
literal|1
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
name|vfs_msync
argument_list|(
name|mp
argument_list|,
name|MNT_NOWAIT
argument_list|)
expr_stmt|;
name|GJ_TIMER_STOP
argument_list|(
literal|1
argument_list|,
operator|&
name|bt
argument_list|,
literal|"Msync time of %s"
argument_list|,
name|mountpoint
argument_list|)
expr_stmt|;
name|GJ_TIMER_START
argument_list|(
literal|1
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
name|error
operator|=
name|VFS_SYNC
argument_list|(
name|mp
argument_list|,
name|MNT_NOWAIT
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|GJ_TIMER_STOP
argument_list|(
literal|1
argument_list|,
operator|&
name|bt
argument_list|,
literal|"Sync time of %s"
argument_list|,
name|mountpoint
argument_list|)
expr_stmt|;
else|else
block|{
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot sync file system %s (error=%d)."
argument_list|,
name|mountpoint
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_noasync
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_ASYNC
operator|)
operator|!=
literal|0
operator|&&
name|mp
operator|->
name|mnt_noasync
operator|==
literal|0
condition|)
name|mp
operator|->
name|mnt_kern_flag
operator||=
name|MNTK_ASYNC
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* 		 * Send BIO_FLUSH before freezing the file system, so it can be 		 * faster after the freeze. 		 */
name|GJ_TIMER_START
argument_list|(
literal|1
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
name|g_journal_flush_cache
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|GJ_TIMER_STOP
argument_list|(
literal|1
argument_list|,
operator|&
name|bt
argument_list|,
literal|"BIO_FLUSH time of %s"
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|GJ_TIMER_START
argument_list|(
literal|1
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
name|error
operator|=
name|vfs_write_suspend
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
name|GJ_TIMER_STOP
argument_list|(
literal|1
argument_list|,
operator|&
name|bt
argument_list|,
literal|"Suspend time of %s"
argument_list|,
name|mountpoint
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot suspend file system %s (error=%d)."
argument_list|,
name|mountpoint
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|error
operator|=
name|desc
operator|->
name|jd_clean
argument_list|(
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|next
goto|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|g_journal_switch_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|vfs_write_resume
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|next
label|:
name|mtx_lock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
name|vfs_unbusy
argument_list|(
name|mp
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
name|sc
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|gp
argument_list|,
argument|&g_journal_class.geom
argument_list|,
argument|geom
argument_list|)
block|{
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
continue|continue;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_type
operator|&
name|GJ_TYPE_COMPLETE
operator|)
operator|==
name|GJ_TYPE_COMPLETE
operator|&&
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|GJF_DEVICE_DESTROY
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|GJF_DEVICE_BEFORE_SWITCH
operator|)
condition|)
block|{
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
name|sc
operator|=
name|NULL
expr_stmt|;
block|}
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
break|break;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|g_journal_switch_wait
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * TODO: Switcher thread should be started on first geom creation and killed on  * last geom destruction.  */
end_comment

begin_function
specifier|static
name|void
name|g_journal_switcher
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|g_class
modifier|*
name|mp
decl_stmt|;
name|struct
name|bintime
name|bt
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mp
operator|=
name|arg
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|g_journal_switcher_wokenup
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|g_journal_switcher_state
argument_list|,
name|PRIBIO
argument_list|,
literal|"jsw:wait"
argument_list|,
name|g_journal_switch_time
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_journal_switcher_state
operator|==
name|GJ_SWITCHER_DIE
condition|)
block|{
name|g_journal_switcher_state
operator|=
name|GJ_SWITCHER_DIED
expr_stmt|;
name|GJ_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Switcher exiting."
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|g_journal_switcher_state
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|g_journal_sync_requested
operator|==
literal|0
condition|)
block|{
name|GJ_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Out of cache, force switch (used=%u "
literal|"limit=%u)."
argument_list|,
name|g_journal_cache_used
argument_list|,
name|g_journal_cache_limit
argument_list|)
expr_stmt|;
block|}
name|GJ_TIMER_START
argument_list|(
literal|1
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
name|g_journal_do_switch
argument_list|(
name|mp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|GJ_TIMER_STOP
argument_list|(
literal|1
argument_list|,
operator|&
name|bt
argument_list|,
literal|"Entire switch time"
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_journal_sync_requested
operator|>
literal|0
condition|)
block|{
name|g_journal_sync_requested
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|g_journal_sync_requested
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

