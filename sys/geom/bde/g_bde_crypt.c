begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002 Poul-Henning Kamp  * Copyright (c) 2002 Networks Associates Technology, Inc.  * All rights reserved.  *  * This software was developed for the FreeBSD Project by Poul-Henning Kamp  * and NAI Labs, the Security Research Division of Network Associates, Inc.  * under DARPA/SPAWAR contract N66001-01-C-8035 ("CBOSS"), as part of the  * DARPA CHATS research program.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/* This source file contains the functions responsible for the crypto, keying  * and mapping operations on the I/O requests.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/md5.h>
end_include

begin_include
include|#
directive|include
file|<crypto/rijndael/rijndael-api-fst.h>
end_include

begin_include
include|#
directive|include
file|<crypto/sha2/sha2.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/bde/g_bde.h>
end_include

begin_comment
comment|/*  * XXX: Debugging DO NOT ENABLE  */
end_comment

begin_undef
undef|#
directive|undef
name|MD5_KEY
end_undef

begin_comment
comment|/*  * Derive kkey from mkey + sector offset.  *  * Security objective: Derive a potentially very large number of distinct skeys  * from the comparatively small key material in our mkey, in such a way that  * if one, more or even many of the kkeys are compromised, this does not  * significantly help an attack on other kkeys and in particular does not  * weaken or compromised the mkey.  *  * First we MD5 hash the sectornumber with the salt from the lock sector.  * The salt prevents the precalculation and statistical analysis of the MD5  * output which would be possible if we only gave it the sectornumber.  *  * The MD5 hash is used to pick out 16 bytes from the masterkey, which  * are then hashed with MD5 together with the sector number.  *  * The resulting MD5 hash is the kkey.  */
end_comment

begin_function
specifier|static
name|void
name|g_bde_kkey
parameter_list|(
name|struct
name|g_bde_softc
modifier|*
name|sc
parameter_list|,
name|keyInstance
modifier|*
name|ki
parameter_list|,
name|int
name|dir
parameter_list|,
name|off_t
name|sector
parameter_list|)
block|{
name|u_int
name|t
decl_stmt|;
name|MD5_CTX
name|ct
decl_stmt|;
name|u_char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|u_char
name|buf2
index|[
literal|8
index|]
decl_stmt|;
comment|/* We have to be architecture neutral */
name|le64enc
argument_list|(
name|buf2
argument_list|,
name|sector
argument_list|)
expr_stmt|;
name|MD5Init
argument_list|(
operator|&
name|ct
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|ct
argument_list|,
name|sc
operator|->
name|key
operator|.
name|salt
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|ct
argument_list|,
name|buf2
argument_list|,
sizeof|sizeof
name|buf2
argument_list|)
expr_stmt|;
name|MD5Update
argument_list|(
operator|&
name|ct
argument_list|,
name|sc
operator|->
name|key
operator|.
name|salt
operator|+
literal|8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|MD5Final
argument_list|(
name|buf
argument_list|,
operator|&
name|ct
argument_list|)
expr_stmt|;
name|MD5Init
argument_list|(
operator|&
name|ct
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
literal|16
condition|;
name|t
operator|++
control|)
block|{
name|MD5Update
argument_list|(
operator|&
name|ct
argument_list|,
operator|&
name|sc
operator|->
name|key
operator|.
name|mkey
index|[
name|buf
index|[
name|t
index|]
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
literal|8
condition|)
name|MD5Update
argument_list|(
operator|&
name|ct
argument_list|,
name|buf2
argument_list|,
sizeof|sizeof
name|buf2
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|buf2
argument_list|,
sizeof|sizeof
name|buf2
argument_list|)
expr_stmt|;
name|MD5Final
argument_list|(
name|buf
argument_list|,
operator|&
name|ct
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ct
argument_list|,
sizeof|sizeof
name|ct
argument_list|)
expr_stmt|;
name|AES_makekey
argument_list|(
name|ki
argument_list|,
name|dir
argument_list|,
name|G_BDE_KKEYBITS
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Encryption work for read operation.  *  * Security objective: Find the kkey, find the skey, decrypt the sector data.  */
end_comment

begin_function
name|void
name|g_bde_crypt_read
parameter_list|(
name|struct
name|g_bde_work
modifier|*
name|wp
parameter_list|)
block|{
name|struct
name|g_bde_softc
modifier|*
name|sc
decl_stmt|;
name|u_char
modifier|*
name|d
decl_stmt|;
name|u_int
name|n
decl_stmt|;
name|off_t
name|o
decl_stmt|;
name|u_char
name|skey
index|[
name|G_BDE_SKEYLEN
index|]
decl_stmt|;
name|keyInstance
name|ki
decl_stmt|;
name|cipherInstance
name|ci
decl_stmt|;
name|AES_init
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
name|sc
operator|=
name|wp
operator|->
name|softc
expr_stmt|;
name|o
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|o
operator|<
name|wp
operator|->
name|length
condition|;
name|n
operator|++
operator|,
name|o
operator|+=
name|sc
operator|->
name|sectorsize
control|)
block|{
name|d
operator|=
operator|(
name|u_char
operator|*
operator|)
name|wp
operator|->
name|ksp
operator|->
name|data
operator|+
name|wp
operator|->
name|ko
operator|+
name|n
operator|*
name|G_BDE_SKEYLEN
expr_stmt|;
name|g_bde_kkey
argument_list|(
name|sc
argument_list|,
operator|&
name|ki
argument_list|,
name|DIR_DECRYPT
argument_list|,
name|wp
operator|->
name|offset
operator|+
name|o
argument_list|)
expr_stmt|;
name|AES_decrypt
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|ki
argument_list|,
name|d
argument_list|,
name|skey
argument_list|,
sizeof|sizeof
name|skey
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
name|u_char
operator|*
operator|)
name|wp
operator|->
name|data
operator|+
name|o
expr_stmt|;
name|AES_makekey
argument_list|(
operator|&
name|ki
argument_list|,
name|DIR_DECRYPT
argument_list|,
name|G_BDE_SKEYBITS
argument_list|,
name|skey
argument_list|)
expr_stmt|;
name|AES_decrypt
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|ki
argument_list|,
name|d
argument_list|,
name|d
argument_list|,
name|sc
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|skey
argument_list|,
sizeof|sizeof
name|skey
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ci
argument_list|,
sizeof|sizeof
name|ci
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ki
argument_list|,
sizeof|sizeof
name|ki
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Encryption work for write operation.  *  * Security objective: Create random skey, encrypt sector data,  * encrypt skey with the kkey.  */
end_comment

begin_function
name|void
name|g_bde_crypt_write
parameter_list|(
name|struct
name|g_bde_work
modifier|*
name|wp
parameter_list|)
block|{
name|u_char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|struct
name|g_bde_softc
modifier|*
name|sc
decl_stmt|;
name|u_int
name|n
decl_stmt|;
name|off_t
name|o
decl_stmt|;
name|u_char
name|skey
index|[
name|G_BDE_SKEYLEN
index|]
decl_stmt|;
name|keyInstance
name|ki
decl_stmt|;
name|cipherInstance
name|ci
decl_stmt|;
name|sc
operator|=
name|wp
operator|->
name|softc
expr_stmt|;
name|AES_init
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
name|o
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|o
operator|<
name|wp
operator|->
name|length
condition|;
name|n
operator|++
operator|,
name|o
operator|+=
name|sc
operator|->
name|sectorsize
control|)
block|{
name|s
operator|=
operator|(
name|u_char
operator|*
operator|)
name|wp
operator|->
name|data
operator|+
name|o
expr_stmt|;
name|d
operator|=
operator|(
name|u_char
operator|*
operator|)
name|wp
operator|->
name|sp
operator|->
name|data
operator|+
name|o
expr_stmt|;
name|arc4rand
argument_list|(
name|skey
argument_list|,
sizeof|sizeof
name|skey
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AES_makekey
argument_list|(
operator|&
name|ki
argument_list|,
name|DIR_ENCRYPT
argument_list|,
name|G_BDE_SKEYBITS
argument_list|,
name|skey
argument_list|)
expr_stmt|;
name|AES_encrypt
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|ki
argument_list|,
name|s
argument_list|,
name|d
argument_list|,
name|sc
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|d
operator|=
operator|(
name|u_char
operator|*
operator|)
name|wp
operator|->
name|ksp
operator|->
name|data
operator|+
name|wp
operator|->
name|ko
operator|+
name|n
operator|*
name|G_BDE_SKEYLEN
expr_stmt|;
name|g_bde_kkey
argument_list|(
name|sc
argument_list|,
operator|&
name|ki
argument_list|,
name|DIR_ENCRYPT
argument_list|,
name|wp
operator|->
name|offset
operator|+
name|o
argument_list|)
expr_stmt|;
name|AES_encrypt
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|ki
argument_list|,
name|skey
argument_list|,
name|d
argument_list|,
sizeof|sizeof
name|skey
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|skey
argument_list|,
sizeof|sizeof
name|skey
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|skey
argument_list|,
sizeof|sizeof
name|skey
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ci
argument_list|,
sizeof|sizeof
name|ci
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ki
argument_list|,
sizeof|sizeof
name|ki
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Encryption work for delete operation.  *  * Security objective: Write random data to the sectors.  *  * XXX: At a hit in performance we would trash the encrypted skey as well.  * XXX: This would add frustration to the cleaning lady attack by making  * XXX: deletes look like writes.  */
end_comment

begin_function
name|void
name|g_bde_crypt_delete
parameter_list|(
name|struct
name|g_bde_work
modifier|*
name|wp
parameter_list|)
block|{
name|struct
name|g_bde_softc
modifier|*
name|sc
decl_stmt|;
name|u_char
modifier|*
name|d
decl_stmt|;
name|off_t
name|o
decl_stmt|;
name|u_char
name|skey
index|[
name|G_BDE_SKEYLEN
index|]
decl_stmt|;
name|keyInstance
name|ki
decl_stmt|;
name|cipherInstance
name|ci
decl_stmt|;
name|sc
operator|=
name|wp
operator|->
name|softc
expr_stmt|;
name|d
operator|=
name|wp
operator|->
name|sp
operator|->
name|data
expr_stmt|;
name|AES_init
argument_list|(
operator|&
name|ci
argument_list|)
expr_stmt|;
comment|/* 	 * Do not unroll this loop! 	 * Our zone may be significantly wider than the amount of random 	 * bytes arc4rand likes to give in one reseeding, whereas our 	 * sectorsize is far more likely to be in the same range. 	 */
for|for
control|(
name|o
operator|=
literal|0
init|;
name|o
operator|<
name|wp
operator|->
name|length
condition|;
name|o
operator|+=
name|sc
operator|->
name|sectorsize
control|)
block|{
name|arc4rand
argument_list|(
name|d
argument_list|,
name|sc
operator|->
name|sectorsize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|arc4rand
argument_list|(
name|skey
argument_list|,
sizeof|sizeof
name|skey
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AES_makekey
argument_list|(
operator|&
name|ki
argument_list|,
name|DIR_ENCRYPT
argument_list|,
name|G_BDE_SKEYBITS
argument_list|,
name|skey
argument_list|)
expr_stmt|;
name|AES_encrypt
argument_list|(
operator|&
name|ci
argument_list|,
operator|&
name|ki
argument_list|,
name|d
argument_list|,
name|d
argument_list|,
name|sc
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|d
operator|+=
name|sc
operator|->
name|sectorsize
expr_stmt|;
block|}
comment|/* 	 * Having written a long random sequence to disk here, we want to 	 * force a reseed, to avoid weakening the next time we use random 	 * data for something important. 	 */
name|arc4rand
argument_list|(
operator|&
name|o
argument_list|,
sizeof|sizeof
name|o
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Calculate the total payload size of the encrypted device.  *  * Security objectives: none.  *  * This function needs to agree with g_bde_map_sector() about things.  */
end_comment

begin_function
name|uint64_t
name|g_bde_max_sector
parameter_list|(
name|struct
name|g_bde_key
modifier|*
name|kp
parameter_list|)
block|{
name|uint64_t
name|maxsect
decl_stmt|;
name|maxsect
operator|=
name|kp
operator|->
name|media_width
expr_stmt|;
name|maxsect
operator|/=
name|kp
operator|->
name|zone_width
expr_stmt|;
name|maxsect
operator|*=
name|kp
operator|->
name|zone_cont
expr_stmt|;
return|return
operator|(
name|maxsect
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert an unencrypted side offset to offsets on the encrypted side.  *  * Security objective:  Make it harder to identify what sectors contain what  * on a "cold" disk image.  *  * We do this by adding the "keyoffset" from the lock to the physical sector  * number modulus the available number of sectors.  Since all physical sectors  * presumably look the same cold, this will do.  *  * As part of the mapping we have to skip the lock sectors which we know  * the physical address off.  We also truncate the work packet, respecting  * zone boundaries and lock sectors, so that we end up with a sequence of  * sectors which are physically contiguous.  *  * Shuffling things further is an option, but the incremental frustration is  * not currently deemed worth the run-time performance hit resulting from the  * increased number of disk arm movements it would incur.  *  * This function offers nothing but a trivial diversion for an attacker able  * to do "the cleaning lady attack" in its current static mapping form.  */
end_comment

begin_function
name|void
name|g_bde_map_sector
parameter_list|(
name|struct
name|g_bde_work
modifier|*
name|wp
parameter_list|)
block|{
name|u_int
name|zone
decl_stmt|,
name|zoff
decl_stmt|,
name|u
decl_stmt|,
name|len
decl_stmt|;
name|uint64_t
name|ko
decl_stmt|;
name|struct
name|g_bde_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_bde_key
modifier|*
name|kp
decl_stmt|;
name|sc
operator|=
name|wp
operator|->
name|softc
expr_stmt|;
name|kp
operator|=
operator|&
name|sc
operator|->
name|key
expr_stmt|;
comment|/* find which zone and the offset in it */
name|zone
operator|=
name|wp
operator|->
name|offset
operator|/
name|kp
operator|->
name|zone_cont
expr_stmt|;
name|zoff
operator|=
name|wp
operator|->
name|offset
operator|%
name|kp
operator|->
name|zone_cont
expr_stmt|;
comment|/* Calculate the offset of the key in the key sector */
name|wp
operator|->
name|ko
operator|=
operator|(
name|zoff
operator|/
name|kp
operator|->
name|sectorsize
operator|)
operator|*
name|G_BDE_SKEYLEN
expr_stmt|;
comment|/* restrict length to that zone */
name|len
operator|=
name|kp
operator|->
name|zone_cont
operator|-
name|zoff
expr_stmt|;
comment|/* ... and in general */
if|if
condition|(
name|len
operator|>
name|DFLTPHYS
condition|)
name|len
operator|=
name|DFLTPHYS
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|wp
operator|->
name|length
condition|)
name|wp
operator|->
name|length
operator|=
name|len
expr_stmt|;
comment|/* Find physical sector address */
name|wp
operator|->
name|so
operator|=
name|zone
operator|*
name|kp
operator|->
name|zone_width
operator|+
name|zoff
expr_stmt|;
name|wp
operator|->
name|so
operator|+=
name|kp
operator|->
name|keyoffset
expr_stmt|;
name|wp
operator|->
name|so
operator|%=
name|kp
operator|->
name|media_width
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|so
operator|+
name|wp
operator|->
name|length
operator|>
name|kp
operator|->
name|media_width
condition|)
name|wp
operator|->
name|length
operator|=
name|kp
operator|->
name|media_width
operator|-
name|wp
operator|->
name|so
expr_stmt|;
name|wp
operator|->
name|so
operator|+=
name|kp
operator|->
name|sector0
expr_stmt|;
comment|/* The key sector is the last in this zone. */
name|wp
operator|->
name|kso
operator|=
name|zone
operator|*
name|kp
operator|->
name|zone_width
operator|+
name|kp
operator|->
name|zone_cont
expr_stmt|;
name|wp
operator|->
name|kso
operator|+=
name|kp
operator|->
name|keyoffset
expr_stmt|;
name|wp
operator|->
name|kso
operator|%=
name|kp
operator|->
name|media_width
expr_stmt|;
name|wp
operator|->
name|kso
operator|+=
name|kp
operator|->
name|sector0
expr_stmt|;
comment|/* Compensate for lock sectors */
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|G_BDE_MAXKEYS
condition|;
name|u
operator|++
control|)
block|{
comment|/* Find the start of this lock sector */
name|ko
operator|=
name|kp
operator|->
name|lsector
index|[
name|u
index|]
operator|&
operator|~
operator|(
operator|(
name|uint64_t
operator|)
name|kp
operator|->
name|sectorsize
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|kso
operator|>=
name|ko
condition|)
name|wp
operator|->
name|kso
operator|+=
name|kp
operator|->
name|sectorsize
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|so
operator|>=
name|ko
condition|)
block|{
comment|/* lock sector before work packet */
name|wp
operator|->
name|so
operator|+=
name|kp
operator|->
name|sectorsize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|wp
operator|->
name|so
operator|+
name|wp
operator|->
name|length
operator|)
operator|>
name|ko
condition|)
block|{
comment|/* lock sector in work packet, truncate */
name|wp
operator|->
name|length
operator|=
name|ko
operator|-
name|wp
operator|->
name|so
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
block|printf("off %jd len %jd so %jd ko %jd kso %u\n", 	    (intmax_t)wp->offset, 	    (intmax_t)wp->length, 	    (intmax_t)wp->so, 	    (intmax_t)wp->kso, 	    wp->ko);
endif|#
directive|endif
name|KASSERT
argument_list|(
name|wp
operator|->
name|so
operator|+
name|wp
operator|->
name|length
operator|<=
name|kp
operator|->
name|sectorN
argument_list|,
operator|(
literal|"wp->so (%jd) + wp->length (%jd)> EOM (%jd), offset = %jd"
operator|,
operator|(
name|intmax_t
operator|)
name|wp
operator|->
name|so
operator|,
operator|(
name|intmax_t
operator|)
name|wp
operator|->
name|length
operator|,
operator|(
name|intmax_t
operator|)
name|kp
operator|->
name|sectorN
operator|,
operator|(
name|intmax_t
operator|)
name|wp
operator|->
name|offset
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|wp
operator|->
name|kso
operator|+
name|kp
operator|->
name|sectorsize
operator|<=
name|kp
operator|->
name|sectorN
argument_list|,
operator|(
literal|"wp->kso (%jd) + kp->sectorsize> EOM (%jd), offset = %jd"
operator|,
operator|(
name|intmax_t
operator|)
name|wp
operator|->
name|kso
operator|,
operator|(
name|intmax_t
operator|)
name|kp
operator|->
name|sectorN
operator|,
operator|(
name|intmax_t
operator|)
name|wp
operator|->
name|offset
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|wp
operator|->
name|so
operator|>=
name|kp
operator|->
name|sector0
argument_list|,
operator|(
literal|"wp->so (%jd)< BOM (%jd), offset = %jd"
operator|,
operator|(
name|intmax_t
operator|)
name|wp
operator|->
name|so
operator|,
operator|(
name|intmax_t
operator|)
name|kp
operator|->
name|sector0
operator|,
operator|(
name|intmax_t
operator|)
name|wp
operator|->
name|offset
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|wp
operator|->
name|kso
operator|>=
name|kp
operator|->
name|sector0
argument_list|,
operator|(
literal|"wp->kso (%jd)<BOM (%jd), offset = %jd"
operator|,
operator|(
name|intmax_t
operator|)
name|wp
operator|->
name|kso
operator|,
operator|(
name|intmax_t
operator|)
name|kp
operator|->
name|sector0
operator|,
operator|(
name|intmax_t
operator|)
name|wp
operator|->
name|offset
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

