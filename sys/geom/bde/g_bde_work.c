begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002 Poul-Henning Kamp  * Copyright (c) 2002 Networks Associates Technology, Inc.  * All rights reserved.  *  * This software was developed for the FreeBSD Project by Poul-Henning Kamp  * and NAI Labs, the Security Research Division of Network Associates, Inc.  * under DARPA/SPAWAR contract N66001-01-C-8035 ("CBOSS"), as part of the  * DARPA CHATS research program.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  *  * This source file contains the state-engine which makes things happen in the  * right order.  *  * Outline:  *   1) g_bde_start1()  *	Break the struct bio into multiple work packets one per zone.  *   2) g_bde_start2()  *	Setup the necessary sector buffers and start those read operations  *	which we can start at this time and put the item on the work-list.  *   3) g_bde_worker()  *	Scan the work-list for items which are ready for crypto processing  *	and call the matching crypto function in g_bde_crypt.c and schedule  *	any writes needed.  Read operations finish here by releasing the  *	sector buffers and delivering the original bio request.  *   4) g_bde_write_done()  *	Release sector buffers and deliver the original bio request.  *  * Because of the C-scope rules, the functions are almost perfectly in the  * opposite order in this source file.  *  * XXX: A switch to the hardware assisted crypto in src/sys/opencrypto will add  * XXX: additional states to this state-engine.  Since no hardware available  * XXX: at this time has AES support, implementing this has been postponed  * XXX: until such time as it would result in a benefit.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<crypto/rijndael/rijndael.h>
end_include

begin_include
include|#
directive|include
file|<crypto/sha2/sha2.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/bde/g_bde.h>
end_include

begin_function_decl
specifier|static
name|void
name|g_bde_delete_sector
parameter_list|(
name|struct
name|g_bde_softc
modifier|*
name|wp
parameter_list|,
name|struct
name|g_bde_sector
modifier|*
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|g_bde_sector
modifier|*
name|g_bde_new_sector
parameter_list|(
name|struct
name|g_bde_work
modifier|*
name|wp
parameter_list|,
name|u_int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_bde_release_keysector
parameter_list|(
name|struct
name|g_bde_work
modifier|*
name|wp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|g_bde_sector
modifier|*
name|g_bde_get_keysector
parameter_list|(
name|struct
name|g_bde_work
modifier|*
name|wp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_bde_start_read
parameter_list|(
name|struct
name|g_bde_sector
modifier|*
name|sp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_bde_purge_sector
parameter_list|(
name|struct
name|g_bde_softc
modifier|*
name|sc
parameter_list|,
name|int
name|fraction
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Work item allocation.  *  * C++ would call these constructors and destructors.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|g_bde_nwork
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|gbde_nwork
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|g_bde_nwork
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_GBDE
argument_list|,
literal|"GBDE"
argument_list|,
literal|"GBDE data structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|struct
name|g_bde_work
modifier|*
name|g_bde_new_work
parameter_list|(
name|struct
name|g_bde_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_bde_work
modifier|*
name|wp
decl_stmt|;
name|wp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|wp
argument_list|,
name|M_GBDE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|==
name|NULL
condition|)
return|return
operator|(
name|wp
operator|)
return|;
name|wp
operator|->
name|state
operator|=
name|SETUP
expr_stmt|;
name|wp
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
name|g_bde_nwork
operator|++
expr_stmt|;
name|sc
operator|->
name|nwork
operator|++
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|worklist
argument_list|,
name|wp
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
operator|(
name|wp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_bde_delete_work
parameter_list|(
name|struct
name|g_bde_work
modifier|*
name|wp
parameter_list|)
block|{
name|struct
name|g_bde_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|wp
operator|->
name|softc
expr_stmt|;
name|g_bde_nwork
operator|--
expr_stmt|;
name|sc
operator|->
name|nwork
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|worklist
argument_list|,
name|wp
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wp
argument_list|,
name|M_GBDE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sector buffer allocation  *  * These two functions allocate and free back variable sized sector buffers  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|g_bde_nsect
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|gbde_nsect
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|g_bde_nsect
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|g_bde_delete_sector
parameter_list|(
name|struct
name|g_bde_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_bde_sector
modifier|*
name|sp
parameter_list|)
block|{
name|g_bde_nsect
operator|--
expr_stmt|;
name|sc
operator|->
name|nsect
operator|--
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|malloc
condition|)
name|free
argument_list|(
name|sp
operator|->
name|data
argument_list|,
name|M_GBDE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sp
argument_list|,
name|M_GBDE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|g_bde_sector
modifier|*
name|g_bde_new_sector
parameter_list|(
name|struct
name|g_bde_work
modifier|*
name|wp
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|struct
name|g_bde_sector
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|sp
argument_list|,
name|M_GBDE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
return|return
operator|(
name|sp
operator|)
return|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|sp
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_GBDE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sp
argument_list|,
name|M_GBDE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sp
operator|->
name|malloc
operator|=
literal|1
expr_stmt|;
block|}
name|g_bde_nsect
operator|++
expr_stmt|;
name|wp
operator|->
name|softc
operator|->
name|nsect
operator|++
expr_stmt|;
name|sp
operator|->
name|size
operator|=
name|len
expr_stmt|;
name|sp
operator|->
name|softc
operator|=
name|wp
operator|->
name|softc
expr_stmt|;
name|sp
operator|->
name|ref
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|owner
operator|=
name|wp
expr_stmt|;
name|sp
operator|->
name|offset
operator|=
name|wp
operator|->
name|so
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|JUNK
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Skey sector cache.  *  * Nothing prevents two separate I/O requests from addressing the same zone  * and thereby needing the same skey sector.  We therefore need to sequence  * I/O operations to the skey sectors.  A certain amount of caching is also  * desirable, although the extent of benefit from this is not at this point  * determined.  *  * XXX: GEOM may be able to grow a generic caching facility at some point  * XXX: to support such needs.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|g_bde_ncache
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|gbde_ncache
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|g_bde_ncache
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|g_bde_purge_one_sector
parameter_list|(
name|struct
name|g_bde_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_bde_sector
modifier|*
name|sp
parameter_list|)
block|{
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"g_bde_purge_one_sector(%p, %p)"
argument_list|,
name|sc
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|ref
operator|!=
literal|0
condition|)
return|return;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|freelist
argument_list|,
name|sp
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|g_bde_ncache
operator|--
expr_stmt|;
name|sc
operator|->
name|ncache
operator|--
expr_stmt|;
name|bzero
argument_list|(
name|sp
operator|->
name|data
argument_list|,
name|sp
operator|->
name|size
argument_list|)
expr_stmt|;
name|g_bde_delete_sector
argument_list|(
name|sc
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|g_bde_sector
modifier|*
name|g_bde_get_keysector
parameter_list|(
name|struct
name|g_bde_work
modifier|*
name|wp
parameter_list|)
block|{
name|struct
name|g_bde_sector
modifier|*
name|sp
decl_stmt|;
name|struct
name|g_bde_softc
modifier|*
name|sc
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|offset
operator|=
name|wp
operator|->
name|kso
expr_stmt|;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"g_bde_get_keysector(%p, %jd)"
argument_list|,
name|wp
argument_list|,
operator|(
name|intmax_t
operator|)
name|offset
argument_list|)
expr_stmt|;
name|sc
operator|=
name|wp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|malloc_last_fail
argument_list|()
operator|<
name|g_bde_ncache
condition|)
name|g_bde_purge_sector
argument_list|(
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|freelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|NULL
operator|&&
name|sp
operator|->
name|ref
operator|==
literal|0
operator|&&
name|sp
operator|->
name|used
operator|+
literal|300
operator|<
name|time_uptime
condition|)
name|g_bde_purge_one_sector
argument_list|(
name|sc
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&sc->freelist
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|offset
operator|==
name|offset
condition|)
break|break;
block|}
if|if
condition|(
name|sp
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|->
name|ref
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
name|sp
operator|->
name|offset
operator|==
name|offset
argument_list|,
operator|(
literal|"wrong offset"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sp
operator|->
name|softc
operator|==
name|wp
operator|->
name|softc
argument_list|,
operator|(
literal|"wrong softc"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|ref
operator|==
literal|1
condition|)
name|sp
operator|->
name|owner
operator|=
name|wp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|malloc_last_fail
argument_list|()
operator|<
name|g_bde_ncache
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&sc->freelist
argument_list|,
argument|list
argument_list|)
if|if
condition|(
name|sp
operator|->
name|ref
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|sp
operator|==
name|NULL
operator|&&
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|freelist
argument_list|)
condition|)
name|sp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|freelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|NULL
operator|&&
name|sp
operator|->
name|ref
operator|>
literal|0
condition|)
name|sp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|sp
operator|=
name|g_bde_new_sector
argument_list|(
name|wp
argument_list|,
name|sc
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|NULL
condition|)
block|{
name|g_bde_ncache
operator|++
expr_stmt|;
name|sc
operator|->
name|ncache
operator|++
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|freelist
argument_list|,
name|sp
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|sp
operator|->
name|malloc
operator|=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sp
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|sp
operator|->
name|softc
operator|=
name|wp
operator|->
name|softc
expr_stmt|;
name|sp
operator|->
name|ref
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|owner
operator|=
name|wp
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|JUNK
expr_stmt|;
name|sp
operator|->
name|error
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sp
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|freelist
argument_list|,
name|sp
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|freelist
argument_list|,
name|sp
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|sp
operator|->
name|used
operator|=
name|time_uptime
expr_stmt|;
block|}
name|wp
operator|->
name|ksp
operator|=
name|sp
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_bde_release_keysector
parameter_list|(
name|struct
name|g_bde_work
modifier|*
name|wp
parameter_list|)
block|{
name|struct
name|g_bde_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_bde_work
modifier|*
name|wp2
decl_stmt|;
name|struct
name|g_bde_sector
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|wp
operator|->
name|ksp
expr_stmt|;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"g_bde_release_keysector(%p)"
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sp
operator|->
name|malloc
operator|==
literal|2
argument_list|,
operator|(
literal|"Wrong sector released"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|sp
operator|->
name|softc
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL sp->softc"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|wp
operator|==
name|sp
operator|->
name|owner
argument_list|,
operator|(
literal|"Releasing, not owner"
operator|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|owner
operator|=
name|NULL
expr_stmt|;
name|wp
operator|->
name|ksp
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|ref
operator|--
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|ref
operator|>
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|freelist
argument_list|,
name|sp
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|freelist
argument_list|,
name|sp
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|wp2
argument_list|,
argument|&sc->worklist
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|wp2
operator|->
name|ksp
operator|==
name|sp
condition|)
block|{
name|KASSERT
argument_list|(
name|wp2
operator|!=
name|wp
argument_list|,
operator|(
literal|"Self-reowning"
operator|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|owner
operator|=
name|wp2
expr_stmt|;
name|wakeup
argument_list|(
name|sp
operator|->
name|softc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|KASSERT
argument_list|(
name|wp2
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Failed to pick up owner for %p\n"
operator|,
name|sp
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|error
operator|!=
literal|0
condition|)
block|{
name|sp
operator|->
name|offset
operator|=
operator|~
literal|0
expr_stmt|;
name|sp
operator|->
name|error
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|JUNK
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|freelist
argument_list|,
name|sp
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|freelist
argument_list|,
name|sp
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_bde_purge_sector
parameter_list|(
name|struct
name|g_bde_softc
modifier|*
name|sc
parameter_list|,
name|int
name|fraction
parameter_list|)
block|{
name|struct
name|g_bde_sector
modifier|*
name|sp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"g_bde_purge_sector(%p)"
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fraction
operator|>
literal|0
condition|)
name|n
operator|=
name|sc
operator|->
name|ncache
operator|/
name|fraction
operator|+
literal|1
expr_stmt|;
else|else
name|n
operator|=
name|g_bde_ncache
operator|-
name|malloc_last_fail
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return;
if|if
condition|(
name|n
operator|>
name|sc
operator|->
name|ncache
condition|)
name|n
operator|=
name|sc
operator|->
name|ncache
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&sc->freelist
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|ref
operator|!=
literal|0
condition|)
continue|continue;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|freelist
argument_list|,
name|sp
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|g_bde_ncache
operator|--
expr_stmt|;
name|sc
operator|->
name|ncache
operator|--
expr_stmt|;
name|bzero
argument_list|(
name|sp
operator|->
name|data
argument_list|,
name|sp
operator|->
name|size
argument_list|)
expr_stmt|;
name|g_bde_delete_sector
argument_list|(
name|sc
argument_list|,
name|sp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|g_bde_sector
modifier|*
name|g_bde_read_keysector
parameter_list|(
name|struct
name|g_bde_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_bde_work
modifier|*
name|wp
parameter_list|)
block|{
name|struct
name|g_bde_sector
modifier|*
name|sp
decl_stmt|;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"g_bde_read_keysector(%p)"
argument_list|,
name|wp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|g_bde_get_keysector
argument_list|(
name|wp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|g_bde_purge_sector
argument_list|(
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sp
operator|=
name|g_bde_get_keysector
argument_list|(
name|wp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
return|return
operator|(
name|sp
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|owner
operator|!=
name|wp
condition|)
return|return
operator|(
name|sp
operator|)
return|;
if|if
condition|(
name|sp
operator|->
name|state
operator|==
name|VALID
condition|)
return|return
operator|(
name|sp
operator|)
return|;
if|if
condition|(
name|g_bde_start_read
argument_list|(
name|sp
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|sp
operator|)
return|;
name|g_bde_release_keysector
argument_list|(
name|wp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Contribute to the completion of the original bio request.  *  * We have no simple way to tell how many bits the original bio request has  * been segmented into, so the easiest way to determine when we can deliver  * it is to keep track of the number of bytes we have completed.  We keep  * track of any errors underway and latch onto the first one.  *  * We always report "nothing done" in case of error, because random bits here  * and there may be completed and returning a number of completed bytes does  * not convey any useful information about which bytes they were.  If some  * piece of broken code somewhere interprets this to mean that nothing has  * changed on the underlying media they deserve the lossage headed for them.  *  * A single mutex per g_bde instance is used to prevent contention.  */
end_comment

begin_function
specifier|static
name|void
name|g_bde_contribute
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|,
name|off_t
name|bytes
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"g_bde_contribute bp %p bytes %jd error %d"
argument_list|,
name|bp
argument_list|,
operator|(
name|intmax_t
operator|)
name|bytes
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|error
expr_stmt|;
name|bp
operator|->
name|bio_completed
operator|+=
name|bytes
expr_stmt|;
name|KASSERT
argument_list|(
name|bp
operator|->
name|bio_completed
operator|<=
name|bp
operator|->
name|bio_length
argument_list|,
operator|(
literal|"Too large contribution"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_completed
operator|==
name|bp
operator|->
name|bio_length
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|!=
literal|0
condition|)
name|bp
operator|->
name|bio_completed
operator|=
literal|0
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * A write operation has finished.  When we have all expected cows in the  * barn close the door and call it a day.  */
end_comment

begin_function
specifier|static
name|void
name|g_bde_write_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_bde_sector
modifier|*
name|sp
decl_stmt|;
name|struct
name|g_bde_work
modifier|*
name|wp
decl_stmt|;
name|struct
name|g_bde_softc
modifier|*
name|sc
decl_stmt|;
name|sp
operator|=
name|bp
operator|->
name|bio_caller1
expr_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_caller2
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|worklist_mutex
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL sp"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL sc"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sp
operator|->
name|owner
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL sp->owner"
operator|)
argument_list|)
expr_stmt|;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"g_bde_write_done(%p)"
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
operator|&&
name|bp
operator|->
name|bio_completed
operator|!=
name|sp
operator|->
name|size
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|EIO
expr_stmt|;
name|sp
operator|->
name|error
operator|=
name|bp
operator|->
name|bio_error
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|wp
operator|=
name|sp
operator|->
name|owner
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|error
operator|==
literal|0
condition|)
name|wp
operator|->
name|error
operator|=
name|sp
operator|->
name|error
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_DELETE
condition|)
block|{
name|KASSERT
argument_list|(
name|sp
operator|==
name|wp
operator|->
name|sp
argument_list|,
operator|(
literal|"trashed delete op"
operator|)
argument_list|)
expr_stmt|;
name|g_bde_contribute
argument_list|(
name|wp
operator|->
name|bp
argument_list|,
name|wp
operator|->
name|length
argument_list|,
name|wp
operator|->
name|error
argument_list|)
expr_stmt|;
name|g_bde_delete_sector
argument_list|(
name|sc
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|g_bde_delete_work
argument_list|(
name|wp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|worklist_mutex
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|wp
operator|->
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
argument_list|,
operator|(
literal|"Confused in g_bde_write_done()"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sp
operator|==
name|wp
operator|->
name|sp
operator|||
name|sp
operator|==
name|wp
operator|->
name|ksp
argument_list|,
operator|(
literal|"trashed write op"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|sp
operator|==
name|sp
condition|)
block|{
name|g_bde_delete_sector
argument_list|(
name|sc
argument_list|,
name|wp
operator|->
name|sp
argument_list|)
expr_stmt|;
name|wp
operator|->
name|sp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|state
operator|=
name|VALID
expr_stmt|;
block|}
if|if
condition|(
name|wp
operator|->
name|sp
operator|==
name|NULL
operator|&&
name|wp
operator|->
name|ksp
operator|!=
name|NULL
operator|&&
name|wp
operator|->
name|ksp
operator|->
name|state
operator|==
name|VALID
condition|)
block|{
name|g_bde_contribute
argument_list|(
name|wp
operator|->
name|bp
argument_list|,
name|wp
operator|->
name|length
argument_list|,
name|wp
operator|->
name|error
argument_list|)
expr_stmt|;
name|g_bde_release_keysector
argument_list|(
name|wp
argument_list|)
expr_stmt|;
name|g_bde_delete_work
argument_list|(
name|wp
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|worklist_mutex
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Send a write request for the given sector down the pipeline.  */
end_comment

begin_function
specifier|static
name|int
name|g_bde_start_write
parameter_list|(
name|struct
name|g_bde_sector
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|struct
name|g_bde_softc
modifier|*
name|sc
decl_stmt|;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"g_bde_start_write(%p)"
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|sc
operator|=
name|sp
operator|->
name|softc
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL sc in g_bde_start_write"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sp
operator|->
name|owner
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL sp->owner in g_bde_start_write"
operator|)
argument_list|)
expr_stmt|;
name|bp
operator|=
name|g_new_bio
argument_list|()
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bp
operator|->
name|bio_cmd
operator|=
name|BIO_WRITE
expr_stmt|;
name|bp
operator|->
name|bio_offset
operator|=
name|sp
operator|->
name|offset
expr_stmt|;
name|bp
operator|->
name|bio_data
operator|=
name|sp
operator|->
name|data
expr_stmt|;
name|bp
operator|->
name|bio_length
operator|=
name|sp
operator|->
name|size
expr_stmt|;
name|bp
operator|->
name|bio_done
operator|=
name|g_bde_write_done
expr_stmt|;
name|bp
operator|->
name|bio_caller1
operator|=
name|sp
expr_stmt|;
name|bp
operator|->
name|bio_caller2
operator|=
name|sc
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|IO
expr_stmt|;
name|g_io_request
argument_list|(
name|bp
argument_list|,
name|sc
operator|->
name|consumer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A read operation has finished.  Mark the sector no longer iobusy and  * wake up the worker thread and let it do its thing.  */
end_comment

begin_function
specifier|static
name|void
name|g_bde_read_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_bde_sector
modifier|*
name|sp
decl_stmt|;
name|struct
name|g_bde_softc
modifier|*
name|sc
decl_stmt|;
name|sp
operator|=
name|bp
operator|->
name|bio_caller1
expr_stmt|;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"g_bde_read_done(%p)"
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_caller2
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|worklist_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
operator|&&
name|bp
operator|->
name|bio_completed
operator|!=
name|sp
operator|->
name|size
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|EIO
expr_stmt|;
name|sp
operator|->
name|error
operator|=
name|bp
operator|->
name|bio_error
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|error
operator|==
literal|0
condition|)
name|sp
operator|->
name|state
operator|=
name|VALID
expr_stmt|;
else|else
name|sp
operator|->
name|state
operator|=
name|JUNK
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|worklist_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a read request for the given sector down the pipeline.  */
end_comment

begin_function
specifier|static
name|int
name|g_bde_start_read
parameter_list|(
name|struct
name|g_bde_sector
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|struct
name|g_bde_softc
modifier|*
name|sc
decl_stmt|;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"g_bde_start_read(%p)"
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|sc
operator|=
name|sp
operator|->
name|softc
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Null softc in sp %p"
operator|,
name|sp
operator|)
argument_list|)
expr_stmt|;
name|bp
operator|=
name|g_new_bio
argument_list|()
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bp
operator|->
name|bio_cmd
operator|=
name|BIO_READ
expr_stmt|;
name|bp
operator|->
name|bio_offset
operator|=
name|sp
operator|->
name|offset
expr_stmt|;
name|bp
operator|->
name|bio_data
operator|=
name|sp
operator|->
name|data
expr_stmt|;
name|bp
operator|->
name|bio_length
operator|=
name|sp
operator|->
name|size
expr_stmt|;
name|bp
operator|->
name|bio_done
operator|=
name|g_bde_read_done
expr_stmt|;
name|bp
operator|->
name|bio_caller1
operator|=
name|sp
expr_stmt|;
name|bp
operator|->
name|bio_caller2
operator|=
name|sc
expr_stmt|;
name|sp
operator|->
name|state
operator|=
name|IO
expr_stmt|;
name|g_io_request
argument_list|(
name|bp
argument_list|,
name|sc
operator|->
name|consumer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The worker thread.  *  * The up/down path of GEOM is not allowed to sleep or do any major work  * so we use this thread to do the actual crypto operations and to push  * the state engine onwards.  *  * XXX: if we switch to the src/sys/opencrypt hardware assisted encryption  * XXX: using a thread here is probably not needed.  */
end_comment

begin_function
name|void
name|g_bde_worker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|g_bde_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_bde_work
modifier|*
name|wp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|int
name|busy
decl_stmt|,
name|error
decl_stmt|;
name|gp
operator|=
name|arg
expr_stmt|;
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|worklist_mutex
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|busy
operator|=
literal|0
expr_stmt|;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"g_bde_worker scan"
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|wp
argument_list|,
argument|&sc->worklist
argument_list|,
argument|list
argument_list|)
block|{
name|KASSERT
argument_list|(
name|wp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL wp"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|wp
operator|->
name|softc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL wp->softc"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|state
operator|!=
name|WAIT
condition|)
continue|continue;
comment|/* Not interesting here */
name|KASSERT
argument_list|(
name|wp
operator|->
name|bp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL wp->bp"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|wp
operator|->
name|sp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL wp->sp"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|ksp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|wp
operator|->
name|ksp
operator|->
name|owner
operator|!=
name|wp
condition|)
continue|continue;
if|if
condition|(
name|wp
operator|->
name|ksp
operator|->
name|state
operator|==
name|IO
condition|)
continue|continue;
name|KASSERT
argument_list|(
name|wp
operator|->
name|ksp
operator|->
name|state
operator|==
name|VALID
argument_list|,
operator|(
literal|"Illegal sector state (JUNK ?)"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wp
operator|->
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
operator|&&
name|wp
operator|->
name|sp
operator|->
name|state
operator|==
name|IO
condition|)
continue|continue;
if|if
condition|(
name|wp
operator|->
name|ksp
operator|!=
name|NULL
operator|&&
name|wp
operator|->
name|ksp
operator|->
name|error
operator|!=
literal|0
condition|)
block|{
name|g_bde_contribute
argument_list|(
name|wp
operator|->
name|bp
argument_list|,
name|wp
operator|->
name|length
argument_list|,
name|wp
operator|->
name|ksp
operator|->
name|error
argument_list|)
expr_stmt|;
name|g_bde_delete_sector
argument_list|(
name|sc
argument_list|,
name|wp
operator|->
name|sp
argument_list|)
expr_stmt|;
name|g_bde_release_keysector
argument_list|(
name|wp
argument_list|)
expr_stmt|;
name|g_bde_delete_work
argument_list|(
name|wp
argument_list|)
expr_stmt|;
name|busy
operator|++
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|wp
operator|->
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
if|if
condition|(
name|wp
operator|->
name|ksp
operator|==
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|wp
operator|->
name|error
operator|!=
literal|0
argument_list|,
operator|(
literal|"BIO_READ, no ksp and no error"
operator|)
argument_list|)
expr_stmt|;
name|g_bde_contribute
argument_list|(
name|wp
operator|->
name|bp
argument_list|,
name|wp
operator|->
name|length
argument_list|,
name|wp
operator|->
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wp
operator|->
name|sp
operator|->
name|error
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|worklist_mutex
argument_list|)
expr_stmt|;
name|g_bde_crypt_read
argument_list|(
name|wp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|worklist_mutex
argument_list|)
expr_stmt|;
block|}
name|g_bde_contribute
argument_list|(
name|wp
operator|->
name|bp
argument_list|,
name|wp
operator|->
name|length
argument_list|,
name|wp
operator|->
name|sp
operator|->
name|error
argument_list|)
expr_stmt|;
block|}
name|g_bde_delete_sector
argument_list|(
name|sc
argument_list|,
name|wp
operator|->
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|ksp
operator|!=
name|NULL
condition|)
name|g_bde_release_keysector
argument_list|(
name|wp
argument_list|)
expr_stmt|;
name|g_bde_delete_work
argument_list|(
name|wp
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_WRITE
case|:
name|wp
operator|->
name|state
operator|=
name|FINISH
expr_stmt|;
name|KASSERT
argument_list|(
name|wp
operator|->
name|sp
operator|->
name|owner
operator|==
name|wp
argument_list|,
operator|(
literal|"Write not owner sp"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|wp
operator|->
name|ksp
operator|->
name|owner
operator|==
name|wp
argument_list|,
operator|(
literal|"Write not owner ksp"
operator|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|worklist_mutex
argument_list|)
expr_stmt|;
name|g_bde_crypt_write
argument_list|(
name|wp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|worklist_mutex
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_bde_start_write
argument_list|(
name|wp
operator|->
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|g_bde_contribute
argument_list|(
name|wp
operator|->
name|bp
argument_list|,
name|wp
operator|->
name|length
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|g_bde_release_keysector
argument_list|(
name|wp
argument_list|)
expr_stmt|;
name|g_bde_delete_sector
argument_list|(
name|sc
argument_list|,
name|wp
operator|->
name|sp
argument_list|)
expr_stmt|;
name|g_bde_delete_work
argument_list|(
name|wp
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|g_bde_start_write
argument_list|(
name|wp
operator|->
name|ksp
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|error
operator|==
literal|0
condition|)
name|wp
operator|->
name|error
operator|=
name|error
expr_stmt|;
break|break;
case|case
name|BIO_DELETE
case|:
name|wp
operator|->
name|state
operator|=
name|FINISH
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|worklist_mutex
argument_list|)
expr_stmt|;
name|g_bde_crypt_delete
argument_list|(
name|wp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|worklist_mutex
argument_list|)
expr_stmt|;
name|g_bde_start_write
argument_list|(
name|wp
operator|->
name|sp
argument_list|)
expr_stmt|;
break|break;
block|}
name|busy
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|busy
condition|)
block|{
comment|/* 			 * We don't look for our death-warrant until we are 			 * idle.  Shouldn't make a difference in practice. 			 */
if|if
condition|(
name|sc
operator|->
name|dead
condition|)
break|break;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"g_bde_worker sleep"
argument_list|)
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|worklist_mutex
argument_list|,
name|PRIBIO
argument_list|,
literal|"g_bde"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
block|{
comment|/* 				 * Loose our skey cache in an orderly fashion. 				 * The exact rate can be tuned to be less 				 * aggressive if this is desirable.  10% per 				 * second means that the cache is gone in a 				 * few minutes. 				 */
name|g_bde_purge_sector
argument_list|(
name|sc
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"g_bde_worker die"
argument_list|)
expr_stmt|;
name|g_bde_purge_sector
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|nwork
operator|==
literal|0
argument_list|,
operator|(
literal|"Dead but %d work remaining"
operator|,
name|sc
operator|->
name|nwork
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|ncache
operator|==
literal|0
argument_list|,
operator|(
literal|"Dead but %d cache remaining"
operator|,
name|sc
operator|->
name|ncache
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|nsect
operator|==
literal|0
argument_list|,
operator|(
literal|"Dead but %d sect remaining"
operator|,
name|sc
operator|->
name|nsect
operator|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|worklist_mutex
argument_list|)
expr_stmt|;
name|sc
operator|->
name|dead
operator|=
literal|2
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * g_bde_start1 has chopped the incoming request up so all the requests  * we see here are inside a single zone.  Map the data and key locations  * grab the buffers we need and fire off the first volley of read requests.  */
end_comment

begin_function
specifier|static
name|void
name|g_bde_start2
parameter_list|(
name|struct
name|g_bde_work
modifier|*
name|wp
parameter_list|)
block|{
name|struct
name|g_bde_softc
modifier|*
name|sc
decl_stmt|;
name|KASSERT
argument_list|(
name|wp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL wp in g_bde_start2"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|wp
operator|->
name|softc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL wp->softc"
operator|)
argument_list|)
expr_stmt|;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"g_bde_start2(%p)"
argument_list|,
name|wp
argument_list|)
expr_stmt|;
name|sc
operator|=
name|wp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
block|{
name|wp
operator|->
name|sp
operator|=
name|g_bde_new_sector
argument_list|(
name|wp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|sp
operator|==
name|NULL
condition|)
block|{
name|g_bde_contribute
argument_list|(
name|wp
operator|->
name|bp
argument_list|,
name|wp
operator|->
name|length
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
name|g_bde_delete_work
argument_list|(
name|wp
argument_list|)
expr_stmt|;
return|return;
block|}
name|wp
operator|->
name|sp
operator|->
name|size
operator|=
name|wp
operator|->
name|length
expr_stmt|;
name|wp
operator|->
name|sp
operator|->
name|data
operator|=
name|wp
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|g_bde_start_read
argument_list|(
name|wp
operator|->
name|sp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|g_bde_contribute
argument_list|(
name|wp
operator|->
name|bp
argument_list|,
name|wp
operator|->
name|length
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
name|g_bde_delete_sector
argument_list|(
name|sc
argument_list|,
name|wp
operator|->
name|sp
argument_list|)
expr_stmt|;
name|g_bde_delete_work
argument_list|(
name|wp
argument_list|)
expr_stmt|;
return|return;
block|}
name|g_bde_read_keysector
argument_list|(
name|sc
argument_list|,
name|wp
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|ksp
operator|==
name|NULL
condition|)
name|wp
operator|->
name|error
operator|=
name|ENOMEM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wp
operator|->
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_DELETE
condition|)
block|{
name|wp
operator|->
name|sp
operator|=
name|g_bde_new_sector
argument_list|(
name|wp
argument_list|,
name|wp
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|sp
operator|==
name|NULL
condition|)
block|{
name|g_bde_contribute
argument_list|(
name|wp
operator|->
name|bp
argument_list|,
name|wp
operator|->
name|length
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
name|g_bde_delete_work
argument_list|(
name|wp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|wp
operator|->
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
condition|)
block|{
name|wp
operator|->
name|sp
operator|=
name|g_bde_new_sector
argument_list|(
name|wp
argument_list|,
name|wp
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|sp
operator|==
name|NULL
condition|)
block|{
name|g_bde_contribute
argument_list|(
name|wp
operator|->
name|bp
argument_list|,
name|wp
operator|->
name|length
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
name|g_bde_delete_work
argument_list|(
name|wp
argument_list|)
expr_stmt|;
return|return;
block|}
name|g_bde_read_keysector
argument_list|(
name|sc
argument_list|,
name|wp
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|->
name|ksp
operator|==
name|NULL
condition|)
block|{
name|g_bde_contribute
argument_list|(
name|wp
operator|->
name|bp
argument_list|,
name|wp
operator|->
name|length
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
name|g_bde_delete_sector
argument_list|(
name|sc
argument_list|,
name|wp
operator|->
name|sp
argument_list|)
expr_stmt|;
name|g_bde_delete_work
argument_list|(
name|wp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|KASSERT
argument_list|(
literal|0
operator|==
literal|1
argument_list|,
operator|(
literal|"Wrong bio_cmd %d in g_bde_start2"
operator|,
name|wp
operator|->
name|bp
operator|->
name|bio_cmd
operator|)
argument_list|)
expr_stmt|;
block|}
name|wp
operator|->
name|state
operator|=
name|WAIT
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a sequence of work structures, and have g_bde_map_sector() determine  * how long they each can be.  Feed them to g_bde_start2().  */
end_comment

begin_function
name|void
name|g_bde_start1
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_bde_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_bde_work
modifier|*
name|wp
decl_stmt|;
name|off_t
name|done
decl_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|bp
operator|->
name|bio_driver1
operator|=
name|sc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|worklist_mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|done
operator|=
literal|0
init|;
name|done
operator|<
name|bp
operator|->
name|bio_length
condition|;
control|)
block|{
name|wp
operator|=
name|g_bde_new_work
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|!=
name|NULL
condition|)
block|{
name|wp
operator|->
name|bp
operator|=
name|bp
expr_stmt|;
name|wp
operator|->
name|offset
operator|=
name|bp
operator|->
name|bio_offset
operator|+
name|done
expr_stmt|;
name|wp
operator|->
name|data
operator|=
name|bp
operator|->
name|bio_data
operator|+
name|done
expr_stmt|;
name|wp
operator|->
name|length
operator|=
name|bp
operator|->
name|bio_length
operator|-
name|done
expr_stmt|;
name|g_bde_map_sector
argument_list|(
name|wp
argument_list|)
expr_stmt|;
name|done
operator|+=
name|wp
operator|->
name|length
expr_stmt|;
name|g_bde_start2
argument_list|(
name|wp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wp
operator|==
name|NULL
operator|||
name|bp
operator|->
name|bio_error
operator|!=
literal|0
condition|)
block|{
name|g_bde_contribute
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_length
operator|-
name|done
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|worklist_mutex
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

