begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005-2006 Pawel Jakub Dawidek<pjd@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/eli/g_eli.h>
end_include

begin_include
include|#
directive|include
file|<geom/eli/pkcs5v2.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_ELI
argument_list|,
literal|"eli data"
argument_list|,
literal|"GEOM_ELI Data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_kern_geom
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern_geom
argument_list|,
name|OID_AUTO
argument_list|,
name|eli
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"GEOM_ELI stuff"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_int
name|g_eli_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.geom.eli.debug"
argument_list|,
operator|&
name|g_eli_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_eli
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_eli_debug
argument_list|,
literal|0
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_eli_tries
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.geom.eli.tries"
argument_list|,
operator|&
name|g_eli_tries
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_eli
argument_list|,
name|OID_AUTO
argument_list|,
name|tries
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_eli_tries
argument_list|,
literal|0
argument_list|,
literal|"Number of tries for entering the passphrase"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_eli_visible_passphrase
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.geom.eli.visible_passphrase"
argument_list|,
operator|&
name|g_eli_visible_passphrase
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_eli
argument_list|,
name|OID_AUTO
argument_list|,
name|visible_passphrase
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_eli_visible_passphrase
argument_list|,
literal|0
argument_list|,
literal|"Turn on echo when entering the passphrase (for debug purposes only!!)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_int
name|g_eli_overwrites
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.geom.eli.overwrites"
argument_list|,
operator|&
name|g_eli_overwrites
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_eli
argument_list|,
name|OID_AUTO
argument_list|,
name|overwrites
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_eli_overwrites
argument_list|,
literal|0
argument_list|,
literal|"Number of times on-disk keys should be overwritten when destroying them"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_eli_threads
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.geom.eli.threads"
argument_list|,
operator|&
name|g_eli_threads
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_eli
argument_list|,
name|OID_AUTO
argument_list|,
name|threads
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_eli_threads
argument_list|,
literal|0
argument_list|,
literal|"Number of threads doing crypto work"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_int
name|g_eli_batch
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.geom.eli.batch"
argument_list|,
operator|&
name|g_eli_batch
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_eli
argument_list|,
name|OID_AUTO
argument_list|,
name|batch
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_eli_batch
argument_list|,
literal|0
argument_list|,
literal|"Use crypto operations batching"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|g_eli_destroy_geom
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|g_taste_t
name|g_eli_taste
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_dumpconf_t
name|g_eli_dumpconf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|g_class
name|g_eli_class
init|=
block|{
operator|.
name|name
operator|=
name|G_ELI_CLASS_NAME
block|,
operator|.
name|version
operator|=
name|G_VERSION
block|,
operator|.
name|ctlreq
operator|=
name|g_eli_config
block|,
operator|.
name|taste
operator|=
name|g_eli_taste
block|,
operator|.
name|destroy_geom
operator|=
name|g_eli_destroy_geom
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Code paths:  * BIO_READ:  *	g_eli_start -> g_io_request -> g_eli_read_done -> g_eli_crypto_run -> g_eli_crypto_read_done -> g_io_deliver  * BIO_WRITE:  *	g_eli_start -> g_eli_crypto_run -> g_eli_crypto_write_done -> g_io_request -> g_eli_write_done -> g_io_deliver  */
end_comment

begin_comment
comment|/*  * EAGAIN from crypto(9) means, that we were probably balanced to another crypto  * accelerator or something like this.  * The function updates the SID and rerun the operation.  */
end_comment

begin_function
name|int
name|g_eli_crypto_rerun
parameter_list|(
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|)
block|{
name|struct
name|g_eli_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_eli_worker
modifier|*
name|wr
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bp
operator|=
operator|(
expr|struct
name|bio
operator|*
operator|)
name|crp
operator|->
name|crp_opaque
expr_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|wr
argument_list|,
argument|&sc->sc_workers
argument_list|,
argument|w_next
argument_list|)
block|{
if|if
condition|(
name|wr
operator|->
name|w_number
operator|==
name|bp
operator|->
name|bio_pflags
condition|)
break|break;
block|}
name|KASSERT
argument_list|(
name|wr
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Invalid worker (%u)."
operator|,
name|bp
operator|->
name|bio_pflags
operator|)
argument_list|)
expr_stmt|;
name|G_ELI_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Rerunning crypto %s request (sid: %ju -> %ju)."
argument_list|,
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|?
literal|"READ"
else|:
literal|"WRITE"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|wr
operator|->
name|w_sid
argument_list|,
operator|(
name|uintmax_t
operator|)
name|crp
operator|->
name|crp_sid
argument_list|)
expr_stmt|;
name|wr
operator|->
name|w_sid
operator|=
name|crp
operator|->
name|crp_sid
expr_stmt|;
name|crp
operator|->
name|crp_etype
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|crypto_dispatch
argument_list|(
name|crp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|G_ELI_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"%s: crypto_dispatch() returned %d."
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|crp
operator|->
name|crp_etype
operator|=
name|error
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The function is called afer reading encrypted data from the provider.  *  * g_eli_start -> g_io_request -> G_ELI_READ_DONE -> g_eli_crypto_run -> g_eli_crypto_read_done -> g_io_deliver  */
end_comment

begin_function
name|void
name|g_eli_read_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_eli_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bio
modifier|*
name|pbp
decl_stmt|;
name|G_ELI_LOGREQ
argument_list|(
literal|2
argument_list|,
name|bp
argument_list|,
literal|"Request done."
argument_list|)
expr_stmt|;
name|pbp
operator|=
name|bp
operator|->
name|bio_parent
expr_stmt|;
if|if
condition|(
name|pbp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|pbp
operator|->
name|bio_error
operator|=
name|bp
operator|->
name|bio_error
expr_stmt|;
comment|/* 	 * Do we have all sectors already? 	 */
name|pbp
operator|->
name|bio_inbed
operator|++
expr_stmt|;
if|if
condition|(
name|pbp
operator|->
name|bio_inbed
operator|<
name|pbp
operator|->
name|bio_children
condition|)
return|return;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbp
operator|->
name|bio_error
operator|!=
literal|0
condition|)
block|{
name|G_ELI_LOGREQ
argument_list|(
literal|0
argument_list|,
name|pbp
argument_list|,
literal|"%s() failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|pbp
operator|->
name|bio_completed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pbp
operator|->
name|bio_driver2
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|pbp
operator|->
name|bio_driver2
argument_list|,
name|M_ELI
argument_list|)
expr_stmt|;
name|pbp
operator|->
name|bio_driver2
operator|=
name|NULL
expr_stmt|;
block|}
name|g_io_deliver
argument_list|(
name|pbp
argument_list|,
name|pbp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|=
name|pbp
operator|->
name|bio_to
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|pbp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The function is called after we encrypt and write data.  *  * g_eli_start -> g_eli_crypto_run -> g_eli_crypto_write_done -> g_io_request -> G_ELI_WRITE_DONE -> g_io_deliver  */
end_comment

begin_function
name|void
name|g_eli_write_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|pbp
decl_stmt|;
name|G_ELI_LOGREQ
argument_list|(
literal|2
argument_list|,
name|bp
argument_list|,
literal|"Request done."
argument_list|)
expr_stmt|;
name|pbp
operator|=
name|bp
operator|->
name|bio_parent
expr_stmt|;
if|if
condition|(
name|pbp
operator|->
name|bio_error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|!=
literal|0
condition|)
name|pbp
operator|->
name|bio_error
operator|=
name|bp
operator|->
name|bio_error
expr_stmt|;
block|}
comment|/* 	 * Do we have all sectors already? 	 */
name|pbp
operator|->
name|bio_inbed
operator|++
expr_stmt|;
if|if
condition|(
name|pbp
operator|->
name|bio_inbed
operator|<
name|pbp
operator|->
name|bio_children
condition|)
return|return;
name|free
argument_list|(
name|pbp
operator|->
name|bio_driver2
argument_list|,
name|M_ELI
argument_list|)
expr_stmt|;
name|pbp
operator|->
name|bio_driver2
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pbp
operator|->
name|bio_error
operator|!=
literal|0
condition|)
block|{
name|G_ELI_LOGREQ
argument_list|(
literal|0
argument_list|,
name|pbp
argument_list|,
literal|"Crypto WRITE request failed (error=%d)."
argument_list|,
name|pbp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
name|pbp
operator|->
name|bio_completed
operator|=
literal|0
expr_stmt|;
block|}
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Write is finished, send it up. 	 */
name|pbp
operator|->
name|bio_completed
operator|=
name|pbp
operator|->
name|bio_length
expr_stmt|;
name|g_io_deliver
argument_list|(
name|pbp
argument_list|,
name|pbp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function should never be called, but GEOM made as it set ->orphan()  * method for every geom.  */
end_comment

begin_function
specifier|static
name|void
name|g_eli_orphan_spoil_assert
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|panic
argument_list|(
literal|"Function %s() called for %s."
argument_list|,
name|__func__
argument_list|,
name|cp
operator|->
name|geom
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_eli_orphan
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_eli_softc
modifier|*
name|sc
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|sc
operator|=
name|cp
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|g_eli_destroy
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * BIO_READ : G_ELI_START -> g_io_request -> g_eli_read_done -> g_eli_crypto_run -> g_eli_crypto_read_done -> g_io_deliver  * BIO_WRITE: G_ELI_START -> g_eli_crypto_run -> g_eli_crypto_write_done -> g_io_request -> g_eli_write_done -> g_io_deliver  */
end_comment

begin_function
specifier|static
name|void
name|g_eli_start
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_eli_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|bio
modifier|*
name|cbp
decl_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Provider's error should be set (error=%d)(device=%s)."
operator|,
name|bp
operator|->
name|bio_to
operator|->
name|error
operator|,
name|bp
operator|->
name|bio_to
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|G_ELI_LOGREQ
argument_list|(
literal|2
argument_list|,
name|bp
argument_list|,
literal|"Request received."
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
case|case
name|BIO_WRITE
case|:
case|case
name|BIO_GETATTR
case|:
case|case
name|BIO_FLUSH
case|:
break|break;
case|case
name|BIO_DELETE
case|:
comment|/* 		 * We could eventually support BIO_DELETE request. 		 * It could be done by overwritting requested sector with 		 * random data g_eli_overwrites number of times. 		 */
default|default:
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
return|return;
block|}
name|cbp
operator|=
name|g_clone_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|==
name|NULL
condition|)
block|{
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_ELI_FLAG_AUTH
operator|)
condition|)
block|{
name|bp
operator|->
name|bio_driver2
operator|=
name|NULL
expr_stmt|;
name|cbp
operator|->
name|bio_done
operator|=
name|g_eli_read_done
expr_stmt|;
name|cp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_geom
operator|->
name|consumer
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|bio_to
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|G_ELI_LOGREQ
argument_list|(
literal|2
argument_list|,
name|cbp
argument_list|,
literal|"Sending request."
argument_list|)
expr_stmt|;
comment|/* 			 * Read encrypted data from provider. 			 */
name|g_io_request
argument_list|(
name|cbp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
block|}
name|bp
operator|->
name|bio_pflags
operator|=
literal|255
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|BIO_WRITE
case|:
name|bp
operator|->
name|bio_driver1
operator|=
name|cbp
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_GETATTR
case|:
case|case
name|BIO_FLUSH
case|:
name|cbp
operator|->
name|bio_done
operator|=
name|g_std_done
expr_stmt|;
name|cp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_geom
operator|->
name|consumer
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|bio_to
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|G_ELI_LOGREQ
argument_list|(
literal|2
argument_list|,
name|cbp
argument_list|,
literal|"Sending request."
argument_list|)
expr_stmt|;
name|g_io_request
argument_list|(
name|cbp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * This is the main function for kernel worker thread when we don't have  * hardware acceleration and we have to do cryptography in software.  * Dedicated thread is needed, so we don't slow down g_up/g_down GEOM  * threads with crypto work.  */
end_comment

begin_function
specifier|static
name|void
name|g_eli_worker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|g_eli_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_eli_worker
modifier|*
name|wr
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|wr
operator|=
name|arg
expr_stmt|;
name|sc
operator|=
name|wr
operator|->
name|w_softc
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* Before sched_bind() to a CPU, wait for all CPUs to go on-line. */
if|if
condition|(
name|sc
operator|->
name|sc_crypto
operator|==
name|G_ELI_CRYPTO_SW
operator|&&
name|g_eli_threads
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|!
name|smp_started
condition|)
name|tsleep
argument_list|(
name|wr
argument_list|,
literal|0
argument_list|,
literal|"geli:smp"
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|sched_prio
argument_list|(
name|curthread
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_crypto
operator|==
name|G_ELI_CRYPTO_SW
operator|&&
name|g_eli_threads
operator|==
literal|0
condition|)
name|sched_bind
argument_list|(
name|curthread
argument_list|,
name|wr
operator|->
name|w_number
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|G_ELI_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Thread %s started."
argument_list|,
name|curthread
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_ELI_FLAG_DESTROY
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|wr
argument_list|,
name|w_next
argument_list|)
expr_stmt|;
name|crypto_freesession
argument_list|(
name|wr
operator|->
name|w_sid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wr
argument_list|,
name|M_ELI
argument_list|)
expr_stmt|;
name|G_ELI_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Thread %s exiting."
argument_list|,
name|curthread
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_workers
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|,
name|PRIBIO
operator||
name|PDROP
argument_list|,
literal|"geli:w"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
operator|&&
name|bp
operator|->
name|bio_pflags
operator|==
literal|255
condition|)
name|g_eli_auth_read
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_ELI_FLAG_AUTH
condition|)
name|g_eli_auth_run
argument_list|(
name|wr
argument_list|,
name|bp
argument_list|)
expr_stmt|;
else|else
name|g_eli_crypto_run
argument_list|(
name|wr
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Here we generate IV. It is unique for every sector.  */
end_comment

begin_function
name|void
name|g_eli_crypto_ivgen
parameter_list|(
name|struct
name|g_eli_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|u_char
modifier|*
name|iv
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|u_char
name|off
index|[
literal|8
index|]
decl_stmt|,
name|hash
index|[
name|SHA256_DIGEST_LENGTH
index|]
decl_stmt|;
name|SHA256_CTX
name|ctx
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_ELI_FLAG_NATIVE_BYTE_ORDER
operator|)
condition|)
name|le64enc
argument_list|(
name|off
argument_list|,
operator|(
name|uint64_t
operator|)
name|offset
argument_list|)
expr_stmt|;
comment|/* Copy precalculated SHA256 context for IV-Key. */
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|sc_ivctx
argument_list|,
operator|&
name|ctx
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|SHA256_Update
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|SHA256_Final
argument_list|(
name|hash
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hash
argument_list|,
name|iv
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|g_eli_read_metadata
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|struct
name|g_eli_metadata
modifier|*
name|md
parameter_list|)
block|{
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|u_char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|gp
operator|=
name|g_new_geomf
argument_list|(
name|mp
argument_list|,
literal|"eli:taste"
argument_list|)
expr_stmt|;
name|gp
operator|->
name|start
operator|=
name|g_eli_start
expr_stmt|;
name|gp
operator|->
name|access
operator|=
name|g_std_access
expr_stmt|;
comment|/* 	 * g_eli_read_metadata() is always called from the event thread. 	 * Our geom is created and destroyed in the same event, so there 	 * could be no orphan nor spoil event in the meantime. 	 */
name|gp
operator|->
name|orphan
operator|=
name|g_eli_orphan_spoil_assert
expr_stmt|;
name|gp
operator|->
name|spoiled
operator|=
name|g_eli_orphan_spoil_assert
expr_stmt|;
name|cp
operator|=
name|g_new_consumer
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_attach
argument_list|(
name|cp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|end
goto|;
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|end
goto|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|pp
operator|->
name|mediasize
operator|-
name|pp
operator|->
name|sectorsize
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
goto|goto
name|end
goto|;
name|eli_metadata_decode
argument_list|(
name|buf
argument_list|,
name|md
argument_list|)
expr_stmt|;
name|end
label|:
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|provider
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|acr
operator|==
literal|1
condition|)
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_geom
argument_list|(
name|gp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The function is called when we had last close on provider and user requested  * to close it when this situation occur.  */
end_comment

begin_function
specifier|static
name|void
name|g_eli_last_close
parameter_list|(
name|struct
name|g_eli_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|char
name|ppname
index|[
literal|64
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|gp
operator|=
name|sc
operator|->
name|sc_geom
expr_stmt|;
name|pp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|gp
operator|->
name|provider
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ppname
argument_list|,
name|pp
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ppname
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_eli_destroy
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"Cannot detach %s on last close (error=%d)."
operator|,
name|ppname
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|G_ELI_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Detached %s on last close."
argument_list|,
name|ppname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|g_eli_access
parameter_list|(
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|dr
parameter_list|,
name|int
name|dw
parameter_list|,
name|int
name|de
parameter_list|)
block|{
name|struct
name|g_eli_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|gp
operator|=
name|pp
operator|->
name|geom
expr_stmt|;
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|dw
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_ELI_FLAG_RO
condition|)
block|{
comment|/* Deny write attempts. */
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
comment|/* Someone is opening us for write, we need to remember that. */
name|sc
operator|->
name|sc_flags
operator||=
name|G_ELI_FLAG_WOPEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Is this the last close? */
if|if
condition|(
name|pp
operator|->
name|acr
operator|+
name|dr
operator|>
literal|0
operator|||
name|pp
operator|->
name|acw
operator|+
name|dw
operator|>
literal|0
operator|||
name|pp
operator|->
name|ace
operator|+
name|de
operator|>
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Automatically detach on last close if requested. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_ELI_FLAG_RW_DETACH
operator|)
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_ELI_FLAG_WOPEN
operator|)
condition|)
block|{
name|g_eli_last_close
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_eli_cpu_is_disabled
parameter_list|(
name|int
name|cpu
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SMP
return|return
operator|(
operator|(
name|hlt_cpus_mask
operator|&
operator|(
literal|1
operator|<<
name|cpu
operator|)
operator|)
operator|!=
literal|0
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|struct
name|g_geom
modifier|*
name|g_eli_create
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|bpp
parameter_list|,
specifier|const
name|struct
name|g_eli_metadata
modifier|*
name|md
parameter_list|,
specifier|const
name|u_char
modifier|*
name|mkey
parameter_list|,
name|int
name|nkey
parameter_list|)
block|{
name|struct
name|g_eli_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_eli_worker
modifier|*
name|wr
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|cryptoini
name|crie
decl_stmt|,
name|cria
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|threads
decl_stmt|;
name|int
name|error
decl_stmt|;
name|G_ELI_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Creating device %s%s."
argument_list|,
name|bpp
operator|->
name|name
argument_list|,
name|G_ELI_SUFFIX
argument_list|)
expr_stmt|;
name|gp
operator|=
name|g_new_geomf
argument_list|(
name|mp
argument_list|,
literal|"%s%s"
argument_list|,
name|bpp
operator|->
name|name
argument_list|,
name|G_ELI_SUFFIX
argument_list|)
expr_stmt|;
name|gp
operator|->
name|softc
operator|=
name|NULL
expr_stmt|;
comment|/* for a moment */
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_ELI
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|gp
operator|->
name|start
operator|=
name|g_eli_start
expr_stmt|;
comment|/* 	 * Spoiling cannot happen actually, because we keep provider open for 	 * writing all the time or provider is read-only. 	 */
name|gp
operator|->
name|spoiled
operator|=
name|g_eli_orphan_spoil_assert
expr_stmt|;
name|gp
operator|->
name|orphan
operator|=
name|g_eli_orphan
expr_stmt|;
name|gp
operator|->
name|dumpconf
operator|=
name|g_eli_dumpconf
expr_stmt|;
comment|/* 	 * If detach-on-last-close feature is not enabled and we don't operate 	 * on read-only provider, we can simply use g_std_access(). 	 */
if|if
condition|(
name|md
operator|->
name|md_flags
operator|&
operator|(
name|G_ELI_FLAG_WO_DETACH
operator||
name|G_ELI_FLAG_RO
operator|)
condition|)
name|gp
operator|->
name|access
operator|=
name|g_eli_access
expr_stmt|;
else|else
name|gp
operator|->
name|access
operator|=
name|g_std_access
expr_stmt|;
name|sc
operator|->
name|sc_crypto
operator|=
name|G_ELI_CRYPTO_SW
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
name|md
operator|->
name|md_flags
expr_stmt|;
comment|/* Backward compatibility. */
if|if
condition|(
name|md
operator|->
name|md_version
operator|<
literal|2
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|G_ELI_FLAG_NATIVE_BYTE_ORDER
expr_stmt|;
name|sc
operator|->
name|sc_ealgo
operator|=
name|md
operator|->
name|md_ealgo
expr_stmt|;
name|sc
operator|->
name|sc_nkey
operator|=
name|nkey
expr_stmt|;
comment|/* 	 * Remember the keys in our softc structure. 	 */
name|g_eli_mkey_propagate
argument_list|(
name|sc
argument_list|,
name|mkey
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ekeylen
operator|=
name|md
operator|->
name|md_keylen
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_ELI_FLAG_AUTH
condition|)
block|{
name|sc
operator|->
name|sc_akeylen
operator|=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_akey
argument_list|)
operator|*
literal|8
expr_stmt|;
name|sc
operator|->
name|sc_aalgo
operator|=
name|md
operator|->
name|md_aalgo
expr_stmt|;
name|sc
operator|->
name|sc_alen
operator|=
name|g_eli_hashlen
argument_list|(
name|sc
operator|->
name|sc_aalgo
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_data_per_sector
operator|=
name|bpp
operator|->
name|sectorsize
operator|-
name|sc
operator|->
name|sc_alen
expr_stmt|;
comment|/* 		 * Some hash functions (like SHA1 and RIPEMD160) generates hash 		 * which length is not multiple of 128 bits, but we want data 		 * length to be multiple of 128, so we can encrypt without 		 * padding. The line below rounds down data length to multiple 		 * of 128 bits. 		 */
name|sc
operator|->
name|sc_data_per_sector
operator|-=
name|sc
operator|->
name|sc_data_per_sector
operator|%
literal|16
expr_stmt|;
name|sc
operator|->
name|sc_bytes_per_sector
operator|=
operator|(
name|md
operator|->
name|md_sectorsize
operator|-
literal|1
operator|)
operator|/
name|sc
operator|->
name|sc_data_per_sector
operator|+
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_bytes_per_sector
operator|*=
name|bpp
operator|->
name|sectorsize
expr_stmt|;
comment|/* 		 * Precalculate SHA256 for HMAC key generation. 		 * This is expensive operation and we can do it only once now or 		 * for every access to sector, so now will be much better. 		 */
name|SHA256_Init
argument_list|(
operator|&
name|sc
operator|->
name|sc_akeyctx
argument_list|)
expr_stmt|;
name|SHA256_Update
argument_list|(
operator|&
name|sc
operator|->
name|sc_akeyctx
argument_list|,
name|sc
operator|->
name|sc_akey
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_akey
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Precalculate SHA256 for IV generation. 	 * This is expensive operation and we can do it only once now or for 	 * every access to sector, so now will be much better. 	 */
name|SHA256_Init
argument_list|(
operator|&
name|sc
operator|->
name|sc_ivctx
argument_list|)
expr_stmt|;
name|SHA256_Update
argument_list|(
operator|&
name|sc
operator|->
name|sc_ivctx
argument_list|,
name|sc
operator|->
name|sc_ivkey
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ivkey
argument_list|)
argument_list|)
expr_stmt|;
name|gp
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_geom
operator|=
name|gp
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|,
literal|"geli:queue"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|pp
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|g_new_consumer
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_attach
argument_list|(
name|cp
argument_list|,
name|bpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|req
operator|!=
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Cannot attach to %s (error=%d)."
argument_list|,
name|bpp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|G_ELI_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Cannot attach to %s (error=%d)."
argument_list|,
name|bpp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
goto|goto
name|failed
goto|;
block|}
comment|/* 	 * Keep provider open all the time, so we can run critical tasks, 	 * like Master Keys deletion, without wondering if we can open 	 * provider or not. 	 * We don't open provider for writing only when user requested read-only 	 * access. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_ELI_FLAG_RO
condition|)
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|req
operator|!=
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Cannot access %s (error=%d)."
argument_list|,
name|bpp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|G_ELI_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Cannot access %s (error=%d)."
argument_list|,
name|bpp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
goto|goto
name|failed
goto|;
block|}
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_workers
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|crie
argument_list|,
sizeof|sizeof
argument_list|(
name|crie
argument_list|)
argument_list|)
expr_stmt|;
name|crie
operator|.
name|cri_alg
operator|=
name|sc
operator|->
name|sc_ealgo
expr_stmt|;
name|crie
operator|.
name|cri_klen
operator|=
name|sc
operator|->
name|sc_ekeylen
expr_stmt|;
name|crie
operator|.
name|cri_key
operator|=
name|sc
operator|->
name|sc_ekey
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_ELI_FLAG_AUTH
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|cria
argument_list|,
sizeof|sizeof
argument_list|(
name|cria
argument_list|)
argument_list|)
expr_stmt|;
name|cria
operator|.
name|cri_alg
operator|=
name|sc
operator|->
name|sc_aalgo
expr_stmt|;
name|cria
operator|.
name|cri_klen
operator|=
name|sc
operator|->
name|sc_akeylen
expr_stmt|;
name|cria
operator|.
name|cri_key
operator|=
name|sc
operator|->
name|sc_akey
expr_stmt|;
name|crie
operator|.
name|cri_next
operator|=
operator|&
name|cria
expr_stmt|;
block|}
name|threads
operator|=
name|g_eli_threads
expr_stmt|;
if|if
condition|(
name|threads
operator|==
literal|0
condition|)
name|threads
operator|=
name|mp_ncpus
expr_stmt|;
elseif|else
if|if
condition|(
name|threads
operator|>
name|mp_ncpus
condition|)
block|{
comment|/* There is really no need for too many worker threads. */
name|threads
operator|=
name|mp_ncpus
expr_stmt|;
name|G_ELI_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Reducing number of threads to %u."
argument_list|,
name|threads
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|threads
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|g_eli_cpu_is_disabled
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|G_ELI_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"%s: CPU %u disabled, skipping."
argument_list|,
name|bpp
operator|->
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|wr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|wr
argument_list|)
argument_list|,
name|M_ELI
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|wr
operator|->
name|w_softc
operator|=
name|sc
expr_stmt|;
name|wr
operator|->
name|w_number
operator|=
name|i
expr_stmt|;
comment|/* 		 * If this is the first pass, try to get hardware support. 		 * Use software cryptography, if we cannot get it. 		 */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_workers
argument_list|)
condition|)
block|{
name|error
operator|=
name|crypto_newsession
argument_list|(
operator|&
name|wr
operator|->
name|w_sid
argument_list|,
operator|&
name|crie
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_crypto
operator|=
name|G_ELI_CRYPTO_HW
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_crypto
operator|==
name|G_ELI_CRYPTO_SW
condition|)
name|error
operator|=
name|crypto_newsession
argument_list|(
operator|&
name|wr
operator|->
name|w_sid
argument_list|,
operator|&
name|crie
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|wr
argument_list|,
name|M_ELI
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|!=
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Cannot set up crypto session "
literal|"for %s (error=%d)."
argument_list|,
name|bpp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|G_ELI_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Cannot set up crypto session "
literal|"for %s (error=%d)."
argument_list|,
name|bpp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
goto|goto
name|failed
goto|;
block|}
name|error
operator|=
name|kthread_create
argument_list|(
name|g_eli_worker
argument_list|,
name|wr
argument_list|,
operator|&
name|wr
operator|->
name|w_proc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"g_eli[%u] %s"
argument_list|,
name|i
argument_list|,
name|bpp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|crypto_freesession
argument_list|(
name|wr
operator|->
name|w_sid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wr
argument_list|,
name|M_ELI
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|!=
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Cannot create kernel thread "
literal|"for %s (error=%d)."
argument_list|,
name|bpp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|G_ELI_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Cannot create kernel thread "
literal|"for %s (error=%d)."
argument_list|,
name|bpp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
goto|goto
name|failed
goto|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_workers
argument_list|,
name|wr
argument_list|,
name|w_next
argument_list|)
expr_stmt|;
comment|/* If we have hardware support, one thread is enough. */
if|if
condition|(
name|sc
operator|->
name|sc_crypto
operator|==
name|G_ELI_CRYPTO_HW
condition|)
break|break;
block|}
comment|/* 	 * Create decrypted provider. 	 */
name|pp
operator|=
name|g_new_providerf
argument_list|(
name|gp
argument_list|,
literal|"%s%s"
argument_list|,
name|bpp
operator|->
name|name
argument_list|,
name|G_ELI_SUFFIX
argument_list|)
expr_stmt|;
name|pp
operator|->
name|sectorsize
operator|=
name|md
operator|->
name|md_sectorsize
expr_stmt|;
name|pp
operator|->
name|mediasize
operator|=
name|bpp
operator|->
name|mediasize
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_ELI_FLAG_ONETIME
operator|)
condition|)
name|pp
operator|->
name|mediasize
operator|-=
name|bpp
operator|->
name|sectorsize
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_ELI_FLAG_AUTH
operator|)
condition|)
name|pp
operator|->
name|mediasize
operator|-=
operator|(
name|pp
operator|->
name|mediasize
operator|%
name|pp
operator|->
name|sectorsize
operator|)
expr_stmt|;
else|else
block|{
name|pp
operator|->
name|mediasize
operator|/=
name|sc
operator|->
name|sc_bytes_per_sector
expr_stmt|;
name|pp
operator|->
name|mediasize
operator|*=
name|pp
operator|->
name|sectorsize
expr_stmt|;
block|}
name|g_error_provider
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|G_ELI_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s created."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|G_ELI_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Encryption: %s %u"
argument_list|,
name|g_eli_algo2str
argument_list|(
name|sc
operator|->
name|sc_ealgo
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_ekeylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_ELI_FLAG_AUTH
condition|)
name|G_ELI_DEBUG
argument_list|(
literal|0
argument_list|,
literal|" Integrity: %s"
argument_list|,
name|g_eli_algo2str
argument_list|(
name|sc
operator|->
name|sc_aalgo
argument_list|)
argument_list|)
expr_stmt|;
name|G_ELI_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"    Crypto: %s"
argument_list|,
name|sc
operator|->
name|sc_crypto
operator|==
name|G_ELI_CRYPTO_SW
condition|?
literal|"software"
else|:
literal|"hardware"
argument_list|)
expr_stmt|;
return|return
operator|(
name|gp
operator|)
return|;
name|failed
label|:
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|G_ELI_FLAG_DESTROY
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for kernel threads self destruction. 	 */
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_workers
argument_list|)
condition|)
block|{
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_workers
argument_list|,
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|,
name|PRIBIO
argument_list|,
literal|"geli:destroy"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|provider
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cp
operator|->
name|acr
operator|==
literal|1
condition|)
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_geom
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_ELI
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|g_eli_destroy
parameter_list|(
name|struct
name|g_eli_softc
modifier|*
name|sc
parameter_list|,
name|boolean_t
name|force
parameter_list|)
block|{
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|gp
operator|=
name|sc
operator|->
name|sc_geom
expr_stmt|;
name|pp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|gp
operator|->
name|provider
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|!=
name|NULL
operator|&&
operator|(
name|pp
operator|->
name|acr
operator|!=
literal|0
operator|||
name|pp
operator|->
name|acw
operator|!=
literal|0
operator|||
name|pp
operator|->
name|ace
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|force
condition|)
block|{
name|G_ELI_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Device %s is still open, so it "
literal|"cannot be definitely removed."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|G_ELI_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Device %s is still open (r%dw%de%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|pp
operator|->
name|acr
argument_list|,
name|pp
operator|->
name|acw
argument_list|,
name|pp
operator|->
name|ace
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|G_ELI_FLAG_DESTROY
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_workers
argument_list|)
condition|)
block|{
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_workers
argument_list|,
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|,
name|PRIBIO
argument_list|,
literal|"geli:destroy"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|gp
operator|->
name|softc
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_ELI
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
operator|||
operator|(
name|pp
operator|->
name|acr
operator|==
literal|0
operator|&&
name|pp
operator|->
name|acw
operator|==
literal|0
operator|&&
name|pp
operator|->
name|ace
operator|==
literal|0
operator|)
condition|)
name|G_ELI_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s destroyed."
argument_list|,
name|gp
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_wither_geom_close
argument_list|(
name|gp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_eli_destroy_geom
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
name|__unused
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
name|__unused
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|)
block|{
name|struct
name|g_eli_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
return|return
operator|(
name|g_eli_destroy
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_eli_keyfiles_load
parameter_list|(
name|struct
name|hmac_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|provider
parameter_list|)
block|{
name|u_char
modifier|*
name|keyfile
decl_stmt|,
modifier|*
name|data
decl_stmt|,
modifier|*
name|size
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|,
name|name
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s:geli_keyfile%d"
argument_list|,
name|provider
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|keyfile
operator|=
name|preload_search_by_type
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyfile
operator|==
name|NULL
condition|)
return|return
operator|(
name|i
operator|)
return|;
comment|/* Return number of loaded keyfiles. */
name|data
operator|=
name|preload_search_info
argument_list|(
name|keyfile
argument_list|,
name|MODINFO_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
block|{
name|G_ELI_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot find key file data for %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|data
operator|=
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|data
expr_stmt|;
name|size
operator|=
name|preload_search_info
argument_list|(
name|keyfile
argument_list|,
name|MODINFO_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|NULL
condition|)
block|{
name|G_ELI_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot find key file size for %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|file
operator|=
name|preload_search_info
argument_list|(
name|keyfile
argument_list|,
name|MODINFO_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
block|{
name|G_ELI_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot find key file name for %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|G_ELI_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Loaded keyfile %s for %s (type: %s)."
argument_list|,
name|file
argument_list|,
name|provider
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|g_eli_crypto_hmac_update
argument_list|(
name|ctx
argument_list|,
name|data
argument_list|,
operator|*
operator|(
name|size_t
operator|*
operator|)
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_eli_keyfiles_clear
parameter_list|(
specifier|const
name|char
modifier|*
name|provider
parameter_list|)
block|{
name|u_char
modifier|*
name|keyfile
decl_stmt|,
modifier|*
name|data
decl_stmt|,
modifier|*
name|size
decl_stmt|;
name|char
name|name
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s:geli_keyfile%d"
argument_list|,
name|provider
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|keyfile
operator|=
name|preload_search_by_type
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyfile
operator|==
name|NULL
condition|)
return|return;
name|data
operator|=
name|preload_search_info
argument_list|(
name|keyfile
argument_list|,
name|MODINFO_ADDR
argument_list|)
expr_stmt|;
name|size
operator|=
name|preload_search_info
argument_list|(
name|keyfile
argument_list|,
name|MODINFO_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
operator|||
name|size
operator|==
name|NULL
condition|)
continue|continue;
name|data
operator|=
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
name|data
expr_stmt|;
name|bzero
argument_list|(
name|data
argument_list|,
operator|*
operator|(
name|size_t
operator|*
operator|)
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Tasting is only made on boot.  * We detect providers which should be attached before root is mounted.  */
end_comment

begin_function
specifier|static
name|struct
name|g_geom
modifier|*
name|g_eli_taste
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|flags
name|__unused
parameter_list|)
block|{
name|struct
name|g_eli_metadata
name|md
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|hmac_ctx
name|ctx
decl_stmt|;
name|char
name|passphrase
index|[
literal|256
index|]
decl_stmt|;
name|u_char
name|key
index|[
name|G_ELI_USERKEYLEN
index|]
decl_stmt|,
name|mkey
index|[
name|G_ELI_DATAIVKEYLEN
index|]
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|nkey
decl_stmt|,
name|nkeyfiles
decl_stmt|,
name|tries
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"%s(%s, %s)"
argument_list|,
name|__func__
argument_list|,
name|mp
operator|->
name|name
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
if|if
condition|(
name|rootvnode
operator|!=
name|NULL
operator|||
name|g_eli_tries
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|G_ELI_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"Tasting %s."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_eli_read_metadata
argument_list|(
name|mp
argument_list|,
name|pp
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|gp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|md
operator|.
name|md_magic
argument_list|,
name|G_ELI_MAGIC
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|md
operator|.
name|md_version
operator|>
name|G_ELI_VERSION
condition|)
block|{
name|printf
argument_list|(
literal|"geom_eli.ko module is too old to handle %s.\n"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|md
operator|.
name|md_provsize
operator|!=
name|pp
operator|->
name|mediasize
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Should we attach it on boot? */
if|if
condition|(
operator|!
operator|(
name|md
operator|.
name|md_flags
operator|&
name|G_ELI_FLAG_BOOT
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|md
operator|.
name|md_keys
operator|==
literal|0x00
condition|)
block|{
name|G_ELI_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"No valid keys on %s."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|md
operator|.
name|md_iterations
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* If there is no passphrase, we try only once. */
name|tries
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Ask for the passphrase no more than g_eli_tries times. */
name|tries
operator|=
name|g_eli_tries
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tries
condition|;
name|i
operator|++
control|)
block|{
name|g_eli_crypto_hmac_init
argument_list|(
operator|&
name|ctx
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Load all key files. 		 */
name|nkeyfiles
operator|=
name|g_eli_keyfiles_load
argument_list|(
operator|&
name|ctx
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nkeyfiles
operator|==
literal|0
operator|&&
name|md
operator|.
name|md_iterations
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 			 * No key files and no passphrase, something is 			 * definitely wrong here. 			 * geli(8) doesn't allow for such situation, so assume 			 * that there was really no passphrase and in that case 			 * key files are no properly defined in loader.conf. 			 */
name|G_ELI_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Found no key files in loader.conf for %s."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Ask for the passphrase if defined. */
if|if
condition|(
name|md
operator|.
name|md_iterations
operator|>=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Enter passphrase for %s: "
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|passphrase
argument_list|,
sizeof|sizeof
argument_list|(
name|passphrase
argument_list|)
argument_list|,
name|g_eli_visible_passphrase
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Prepare Derived-Key from the user passphrase. 		 */
if|if
condition|(
name|md
operator|.
name|md_iterations
operator|==
literal|0
condition|)
block|{
name|g_eli_crypto_hmac_update
argument_list|(
operator|&
name|ctx
argument_list|,
name|md
operator|.
name|md_salt
argument_list|,
sizeof|sizeof
argument_list|(
name|md
operator|.
name|md_salt
argument_list|)
argument_list|)
expr_stmt|;
name|g_eli_crypto_hmac_update
argument_list|(
operator|&
name|ctx
argument_list|,
name|passphrase
argument_list|,
name|strlen
argument_list|(
name|passphrase
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|md
operator|.
name|md_iterations
operator|>
literal|0
condition|)
block|{
name|u_char
name|dkey
index|[
name|G_ELI_USERKEYLEN
index|]
decl_stmt|;
name|pkcs5v2_genkey
argument_list|(
name|dkey
argument_list|,
sizeof|sizeof
argument_list|(
name|dkey
argument_list|)
argument_list|,
name|md
operator|.
name|md_salt
argument_list|,
sizeof|sizeof
argument_list|(
name|md
operator|.
name|md_salt
argument_list|)
argument_list|,
name|passphrase
argument_list|,
name|md
operator|.
name|md_iterations
argument_list|)
expr_stmt|;
name|g_eli_crypto_hmac_update
argument_list|(
operator|&
name|ctx
argument_list|,
name|dkey
argument_list|,
sizeof|sizeof
argument_list|(
name|dkey
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dkey
argument_list|,
sizeof|sizeof
argument_list|(
name|dkey
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|g_eli_crypto_hmac_final
argument_list|(
operator|&
name|ctx
argument_list|,
name|key
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Decrypt Master-Key. 		 */
name|error
operator|=
name|g_eli_mkey_decrypt
argument_list|(
operator|&
name|md
argument_list|,
name|key
argument_list|,
name|mkey
argument_list|,
operator|&
name|nkey
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|tries
operator|-
literal|1
condition|)
block|{
name|G_ELI_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Wrong key for %s. No tries left."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_eli_keyfiles_clear
argument_list|(
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|G_ELI_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Wrong key for %s. Tries left: %u."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|tries
operator|-
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Try again. */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|error
operator|>
literal|0
condition|)
block|{
name|G_ELI_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot decrypt Master Key for %s (error=%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|g_eli_keyfiles_clear
argument_list|(
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|G_ELI_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Using Master Key %u for %s."
argument_list|,
name|nkey
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * We have correct key, let's attach provider. 	 */
name|gp
operator|=
name|g_eli_create
argument_list|(
name|NULL
argument_list|,
name|mp
argument_list|,
name|pp
argument_list|,
operator|&
name|md
argument_list|,
name|mkey
argument_list|,
name|nkey
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mkey
argument_list|,
sizeof|sizeof
argument_list|(
name|mkey
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|md
argument_list|,
sizeof|sizeof
argument_list|(
name|md
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|==
name|NULL
condition|)
block|{
name|G_ELI_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot create device %s%s."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|G_ELI_SUFFIX
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|gp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_eli_dumpconf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|)
block|{
name|struct
name|g_eli_softc
modifier|*
name|sc
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|pp
operator|!=
name|NULL
operator|||
name|cp
operator|!=
name|NULL
condition|)
return|return;
comment|/* Nothing here. */
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Flags>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|==
literal|0
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"NONE"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
define|#
directive|define
name|ADD_FLAG
parameter_list|(
name|flag
parameter_list|,
name|name
parameter_list|)
value|do {					\ 	if (sc->sc_flags& (flag)) {					\ 		if (!first)						\ 			sbuf_printf(sb, ", ");				\ 		else							\ 			first = 0;					\ 		sbuf_printf(sb, name);					\ 	}								\ } while (0)
name|ADD_FLAG
argument_list|(
name|G_ELI_FLAG_NATIVE_BYTE_ORDER
argument_list|,
literal|"NATIVE-BYTE-ORDER"
argument_list|)
expr_stmt|;
name|ADD_FLAG
argument_list|(
name|G_ELI_FLAG_ONETIME
argument_list|,
literal|"ONETIME"
argument_list|)
expr_stmt|;
name|ADD_FLAG
argument_list|(
name|G_ELI_FLAG_BOOT
argument_list|,
literal|"BOOT"
argument_list|)
expr_stmt|;
name|ADD_FLAG
argument_list|(
name|G_ELI_FLAG_WO_DETACH
argument_list|,
literal|"W-DETACH"
argument_list|)
expr_stmt|;
name|ADD_FLAG
argument_list|(
name|G_ELI_FLAG_RW_DETACH
argument_list|,
literal|"RW-DETACH"
argument_list|)
expr_stmt|;
name|ADD_FLAG
argument_list|(
name|G_ELI_FLAG_AUTH
argument_list|,
literal|"AUTH"
argument_list|)
expr_stmt|;
name|ADD_FLAG
argument_list|(
name|G_ELI_FLAG_WOPEN
argument_list|,
literal|"W-OPEN"
argument_list|)
expr_stmt|;
name|ADD_FLAG
argument_list|(
name|G_ELI_FLAG_DESTROY
argument_list|,
literal|"DESTROY"
argument_list|)
expr_stmt|;
name|ADD_FLAG
argument_list|(
name|G_ELI_FLAG_RO
argument_list|,
literal|"READ-ONLY"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ADD_FLAG
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</Flags>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_ELI_FLAG_ONETIME
operator|)
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<UsedKey>%u</UsedKey>\n"
argument_list|,
name|indent
argument_list|,
name|sc
operator|->
name|sc_nkey
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Crypto>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_crypto
condition|)
block|{
case|case
name|G_ELI_CRYPTO_HW
case|:
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"hardware"
argument_list|)
expr_stmt|;
break|break;
case|case
name|G_ELI_CRYPTO_SW
case|:
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"software"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"UNKNOWN"
argument_list|)
expr_stmt|;
break|break;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</Crypto>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_ELI_FLAG_AUTH
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<AuthenticationAlgorithm>%s</AuthenticationAlgorithm>\n"
argument_list|,
name|indent
argument_list|,
name|g_eli_algo2str
argument_list|(
name|sc
operator|->
name|sc_aalgo
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<KeyLength>%u</KeyLength>\n"
argument_list|,
name|indent
argument_list|,
name|sc
operator|->
name|sc_ekeylen
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<EncryptionAlgorithm>%s</EncryptionAlgorithm>\n"
argument_list|,
name|indent
argument_list|,
name|g_eli_algo2str
argument_list|(
name|sc
operator|->
name|sc_ealgo
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|DECLARE_GEOM_CLASS
argument_list|(
name|g_eli_class
argument_list|,
name|g_eli
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|g_eli
argument_list|,
name|crypto
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

