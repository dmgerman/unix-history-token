begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005-2011 Pawel Jakub Dawidek<pawel@dawidek.net>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/eli/g_eli.h>
end_include

begin_include
include|#
directive|include
file|<geom/eli/pkcs5v2.h>
end_include

begin_comment
comment|/*  * The data layout description when integrity verification is configured.  *  * One of the most important assumption here is that authenticated data and its  * HMAC has to be stored in the same place (namely in the same sector) to make  * it work reliable.  * The problem is that file systems work only with sectors that are multiple of  * 512 bytes and a power of two number.  * My idea to implement it is as follows.  * Let's store HMAC in sector. This is a must. This leaves us 480 bytes for  * data. We can't use that directly (ie. we can't create provider with 480 bytes  * sector size). We need another sector from where we take only 32 bytes of data  * and we store HMAC of this data as well. This takes two sectors from the  * original provider at the input and leaves us one sector of authenticated data  * at the output. Not very efficient, but you got the idea.  * Now, let's assume, we want to create provider with 4096 bytes sector.  * To output 4096 bytes of authenticated data we need 8x480 plus 1x256, so we  * need nine 512-bytes sectors at the input to get one 4096-bytes sector at the  * output. That's better. With 4096 bytes sector we can use 89% of size of the  * original provider. I find it as an acceptable cost.  * The reliability comes from the fact, that every HMAC stored inside the sector  * is calculated only for the data in the same sector, so its impossible to  * write new data and leave old HMAC or vice versa.  *  * And here is the picture:  *  * da0: +----+----+ +----+----+ +----+----+ +----+----+ +----+----+ +----+----+ +----+----+ +----+----+ +----+-----+  *      |32b |480b| |32b |480b| |32b |480b| |32b |480b| |32b |480b| |32b |480b| |32b |480b| |32b |480b| |32b |256b |  *      |HMAC|Data| |HMAC|Data| |HMAC|Data| |HMAC|Data| |HMAC|Data| |HMAC|Data| |HMAC|Data| |HMAC|Data| |HMAC|Data |  *      +----+----+ +----+----+ +----+----+ +----+----+ +----+----+ +----+----+ +----+----+ +----+----+ +----+-----+  *      |512 bytes| |512 bytes| |512 bytes| |512 bytes| |512 bytes| |512 bytes| |512 bytes| |512 bytes| |288 bytes |  *      +---------+ +---------+ +---------+ +---------+ +---------+ +---------+ +---------+ +---------+ |224 unused|  *                                                                                                      +----------+  * da0.eli: +----+----+----+----+----+----+----+----+----+  *          |480b|480b|480b|480b|480b|480b|480b|480b|256b|  *          +----+----+----+----+----+----+----+----+----+  *          |                 4096 bytes                 |  *          +--------------------------------------------+  *  * PS. You can use any sector size with geli(8). My example is using 4kB,  *     because it's most efficient. For 8kB sectors you need 2 extra sectors,  *     so the cost is the same as for 4kB sectors.  */
end_comment

begin_comment
comment|/*  * Code paths:  * BIO_READ:  *	g_eli_start -> g_eli_auth_read -> g_io_request -> g_eli_read_done -> g_eli_auth_run -> g_eli_auth_read_done -> g_io_deliver  * BIO_WRITE:  *	g_eli_start -> g_eli_auth_run -> g_eli_auth_write_done -> g_io_request -> g_eli_write_done -> g_io_deliver  */
end_comment

begin_expr_stmt
name|MALLOC_DECLARE
argument_list|(
name|M_ELI
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Here we generate key for HMAC. Every sector has its own HMAC key, so it is  * not possible to copy sectors.  * We cannot depend on fact, that every sector has its own IV, because different  * IV doesn't change HMAC, when we use encrypt-then-authenticate method.  */
end_comment

begin_function
specifier|static
name|void
name|g_eli_auth_keygen
parameter_list|(
name|struct
name|g_eli_softc
modifier|*
name|sc
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|u_char
modifier|*
name|key
parameter_list|)
block|{
name|SHA256_CTX
name|ctx
decl_stmt|;
comment|/* Copy precalculated SHA256 context. */
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|sc_akeyctx
argument_list|,
operator|&
name|ctx
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|SHA256_Update
argument_list|(
operator|&
name|ctx
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|SHA256_Final
argument_list|(
name|key
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The function is called after we read and decrypt data.  *  * g_eli_start -> g_eli_auth_read -> g_io_request -> g_eli_read_done -> g_eli_auth_run -> G_ELI_AUTH_READ_DONE -> g_io_deliver  */
end_comment

begin_function
specifier|static
name|int
name|g_eli_auth_read_done
parameter_list|(
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|)
block|{
name|struct
name|g_eli_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|crp
operator|->
name|crp_etype
operator|==
name|EAGAIN
condition|)
block|{
if|if
condition|(
name|g_eli_crypto_rerun
argument_list|(
name|crp
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bp
operator|=
operator|(
expr|struct
name|bio
operator|*
operator|)
name|crp
operator|->
name|crp_opaque
expr_stmt|;
name|bp
operator|->
name|bio_inbed
operator|++
expr_stmt|;
if|if
condition|(
name|crp
operator|->
name|crp_etype
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|bio_completed
operator|+=
name|crp
operator|->
name|crp_olen
expr_stmt|;
name|G_ELI_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"Crypto READ request done (%d/%d) (add=%jd completed=%jd)."
argument_list|,
name|bp
operator|->
name|bio_inbed
argument_list|,
name|bp
operator|->
name|bio_children
argument_list|,
operator|(
name|intmax_t
operator|)
name|crp
operator|->
name|crp_olen
argument_list|,
operator|(
name|intmax_t
operator|)
name|bp
operator|->
name|bio_completed
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|G_ELI_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Crypto READ request failed (%d/%d) error=%d."
argument_list|,
name|bp
operator|->
name|bio_inbed
argument_list|,
name|bp
operator|->
name|bio_children
argument_list|,
name|crp
operator|->
name|crp_etype
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|crp
operator|->
name|crp_etype
expr_stmt|;
block|}
name|sc
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|g_eli_key_drop
argument_list|(
name|sc
argument_list|,
name|crp
operator|->
name|crp_desc
operator|->
name|crd_next
operator|->
name|crd_key
argument_list|)
expr_stmt|;
comment|/* 	 * Do we have all sectors already? 	 */
if|if
condition|(
name|bp
operator|->
name|bio_inbed
operator|<
name|bp
operator|->
name|bio_children
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
condition|)
block|{
name|u_int
name|i
decl_stmt|,
name|lsec
decl_stmt|,
name|nsec
decl_stmt|,
name|data_secsize
decl_stmt|,
name|decr_secsize
decl_stmt|,
name|encr_secsize
decl_stmt|;
name|u_char
modifier|*
name|srcdata
decl_stmt|,
modifier|*
name|dstdata
decl_stmt|,
modifier|*
name|auth
decl_stmt|;
name|off_t
name|coroff
decl_stmt|,
name|corsize
decl_stmt|;
comment|/* 		 * Verify data integrity based on calculated and read HMACs. 		 */
comment|/* Sectorsize of decrypted provider eg. 4096. */
name|decr_secsize
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|sectorsize
expr_stmt|;
comment|/* The real sectorsize of encrypted provider, eg. 512. */
name|encr_secsize
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_geom
operator|->
name|consumer
argument_list|)
operator|->
name|provider
operator|->
name|sectorsize
expr_stmt|;
comment|/* Number of data bytes in one encrypted sector, eg. 480. */
name|data_secsize
operator|=
name|sc
operator|->
name|sc_data_per_sector
expr_stmt|;
comment|/* Number of sectors from decrypted provider, eg. 2. */
name|nsec
operator|=
name|bp
operator|->
name|bio_length
operator|/
name|decr_secsize
expr_stmt|;
comment|/* Number of sectors from encrypted provider, eg. 18. */
name|nsec
operator|=
operator|(
name|nsec
operator|*
name|sc
operator|->
name|sc_bytes_per_sector
operator|)
operator|/
name|encr_secsize
expr_stmt|;
comment|/* Last sector number in every big sector, eg. 9. */
name|lsec
operator|=
name|sc
operator|->
name|sc_bytes_per_sector
operator|/
name|encr_secsize
expr_stmt|;
name|srcdata
operator|=
name|bp
operator|->
name|bio_driver2
expr_stmt|;
name|dstdata
operator|=
name|bp
operator|->
name|bio_data
expr_stmt|;
name|auth
operator|=
name|srcdata
operator|+
name|encr_secsize
operator|*
name|nsec
expr_stmt|;
name|coroff
operator|=
operator|-
literal|1
expr_stmt|;
name|corsize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nsec
condition|;
name|i
operator|++
control|)
block|{
name|data_secsize
operator|=
name|sc
operator|->
name|sc_data_per_sector
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|%
name|lsec
operator|)
operator|==
literal|0
condition|)
name|data_secsize
operator|=
name|decr_secsize
operator|%
name|data_secsize
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|srcdata
argument_list|,
name|auth
argument_list|,
name|sc
operator|->
name|sc_alen
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Curruption detected, remember the offset if 				 * this is the first corrupted sector and 				 * increase size. 				 */
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|bp
operator|->
name|bio_error
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|coroff
operator|==
operator|-
literal|1
condition|)
block|{
name|coroff
operator|=
name|bp
operator|->
name|bio_offset
operator|+
operator|(
name|dstdata
operator|-
operator|(
name|u_char
operator|*
operator|)
name|bp
operator|->
name|bio_data
operator|)
expr_stmt|;
block|}
name|corsize
operator|+=
name|data_secsize
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * No curruption, good. 				 * Report previous corruption if there was one. 				 */
if|if
condition|(
name|coroff
operator|!=
operator|-
literal|1
condition|)
block|{
name|G_ELI_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"%s: Failed to authenticate %jd "
literal|"bytes of data at offset %jd."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
operator|(
name|intmax_t
operator|)
name|corsize
argument_list|,
operator|(
name|intmax_t
operator|)
name|coroff
argument_list|)
expr_stmt|;
name|coroff
operator|=
operator|-
literal|1
expr_stmt|;
name|corsize
operator|=
literal|0
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|srcdata
operator|+
name|sc
operator|->
name|sc_alen
argument_list|,
name|dstdata
argument_list|,
name|data_secsize
argument_list|)
expr_stmt|;
block|}
name|srcdata
operator|+=
name|encr_secsize
expr_stmt|;
name|dstdata
operator|+=
name|data_secsize
expr_stmt|;
name|auth
operator|+=
name|sc
operator|->
name|sc_alen
expr_stmt|;
block|}
comment|/* Report previous corruption if there was one. */
if|if
condition|(
name|coroff
operator|!=
operator|-
literal|1
condition|)
block|{
name|G_ELI_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"%s: Failed to authenticate %jd "
literal|"bytes of data at offset %jd."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
operator|(
name|intmax_t
operator|)
name|corsize
argument_list|,
operator|(
name|intmax_t
operator|)
name|coroff
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|bp
operator|->
name|bio_driver2
argument_list|,
name|M_ELI
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_driver2
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
operator|-
literal|1
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|G_ELI_LOGREQ
argument_list|(
literal|0
argument_list|,
name|bp
argument_list|,
literal|"Crypto READ request failed (error=%d)."
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|bio_completed
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Read is finished, send it up. 	 */
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|sc
operator|->
name|sc_inflight
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The function is called after data encryption.  *  * g_eli_start -> g_eli_auth_run -> G_ELI_AUTH_WRITE_DONE -> g_io_request -> g_eli_write_done -> g_io_deliver  */
end_comment

begin_function
specifier|static
name|int
name|g_eli_auth_write_done
parameter_list|(
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|)
block|{
name|struct
name|g_eli_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cbp
decl_stmt|,
modifier|*
name|cbp2
decl_stmt|;
name|u_int
name|nsec
decl_stmt|;
if|if
condition|(
name|crp
operator|->
name|crp_etype
operator|==
name|EAGAIN
condition|)
block|{
if|if
condition|(
name|g_eli_crypto_rerun
argument_list|(
name|crp
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bp
operator|=
operator|(
expr|struct
name|bio
operator|*
operator|)
name|crp
operator|->
name|crp_opaque
expr_stmt|;
name|bp
operator|->
name|bio_inbed
operator|++
expr_stmt|;
if|if
condition|(
name|crp
operator|->
name|crp_etype
operator|==
literal|0
condition|)
block|{
name|G_ELI_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"Crypto WRITE request done (%d/%d)."
argument_list|,
name|bp
operator|->
name|bio_inbed
argument_list|,
name|bp
operator|->
name|bio_children
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|G_ELI_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Crypto WRITE request failed (%d/%d) error=%d."
argument_list|,
name|bp
operator|->
name|bio_inbed
argument_list|,
name|bp
operator|->
name|bio_children
argument_list|,
name|crp
operator|->
name|crp_etype
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|crp
operator|->
name|crp_etype
expr_stmt|;
block|}
name|sc
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|g_eli_key_drop
argument_list|(
name|sc
argument_list|,
name|crp
operator|->
name|crp_desc
operator|->
name|crd_key
argument_list|)
expr_stmt|;
comment|/* 	 * All sectors are already encrypted? 	 */
if|if
condition|(
name|bp
operator|->
name|bio_inbed
operator|<
name|bp
operator|->
name|bio_children
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|!=
literal|0
condition|)
block|{
name|G_ELI_LOGREQ
argument_list|(
literal|0
argument_list|,
name|bp
argument_list|,
literal|"Crypto WRITE request failed (error=%d)."
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
operator|->
name|bio_driver2
argument_list|,
name|M_ELI
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_driver2
operator|=
name|NULL
expr_stmt|;
name|cbp
operator|=
name|bp
operator|->
name|bio_driver1
expr_stmt|;
name|bp
operator|->
name|bio_driver1
operator|=
name|NULL
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|sc
operator|->
name|sc_inflight
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_geom
operator|->
name|consumer
argument_list|)
expr_stmt|;
name|cbp
operator|=
name|bp
operator|->
name|bio_driver1
expr_stmt|;
name|bp
operator|->
name|bio_driver1
operator|=
name|NULL
expr_stmt|;
name|cbp
operator|->
name|bio_to
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|cbp
operator|->
name|bio_done
operator|=
name|g_eli_write_done
expr_stmt|;
comment|/* Number of sectors from decrypted provider, eg. 1. */
name|nsec
operator|=
name|bp
operator|->
name|bio_length
operator|/
name|bp
operator|->
name|bio_to
operator|->
name|sectorsize
expr_stmt|;
comment|/* Number of sectors from encrypted provider, eg. 9. */
name|nsec
operator|=
operator|(
name|nsec
operator|*
name|sc
operator|->
name|sc_bytes_per_sector
operator|)
operator|/
name|cp
operator|->
name|provider
operator|->
name|sectorsize
expr_stmt|;
name|cbp
operator|->
name|bio_length
operator|=
name|cp
operator|->
name|provider
operator|->
name|sectorsize
operator|*
name|nsec
expr_stmt|;
name|cbp
operator|->
name|bio_offset
operator|=
operator|(
name|bp
operator|->
name|bio_offset
operator|/
name|bp
operator|->
name|bio_to
operator|->
name|sectorsize
operator|)
operator|*
name|sc
operator|->
name|sc_bytes_per_sector
expr_stmt|;
name|cbp
operator|->
name|bio_data
operator|=
name|bp
operator|->
name|bio_driver2
expr_stmt|;
comment|/* 	 * We write more than what is requested, so we have to be ready to write 	 * more than MAXPHYS. 	 */
name|cbp2
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|bio_length
operator|>
name|MAXPHYS
condition|)
block|{
name|cbp2
operator|=
name|g_duplicate_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|cbp2
operator|->
name|bio_length
operator|=
name|cbp
operator|->
name|bio_length
operator|-
name|MAXPHYS
expr_stmt|;
name|cbp2
operator|->
name|bio_data
operator|=
name|cbp
operator|->
name|bio_data
operator|+
name|MAXPHYS
expr_stmt|;
name|cbp2
operator|->
name|bio_offset
operator|=
name|cbp
operator|->
name|bio_offset
operator|+
name|MAXPHYS
expr_stmt|;
name|cbp2
operator|->
name|bio_to
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|cbp2
operator|->
name|bio_done
operator|=
name|g_eli_write_done
expr_stmt|;
name|cbp
operator|->
name|bio_length
operator|=
name|MAXPHYS
expr_stmt|;
block|}
comment|/* 	 * Send encrypted data to the provider. 	 */
name|G_ELI_LOGREQ
argument_list|(
literal|2
argument_list|,
name|cbp
argument_list|,
literal|"Sending request."
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_inbed
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bio_children
operator|=
operator|(
name|cbp2
operator|!=
name|NULL
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
name|g_io_request
argument_list|(
name|cbp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp2
operator|!=
name|NULL
condition|)
block|{
name|G_ELI_LOGREQ
argument_list|(
literal|2
argument_list|,
name|cbp2
argument_list|,
literal|"Sending request."
argument_list|)
expr_stmt|;
name|g_io_request
argument_list|(
name|cbp2
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|g_eli_auth_read
parameter_list|(
name|struct
name|g_eli_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|bio
modifier|*
name|cbp
decl_stmt|,
modifier|*
name|cbp2
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|off_t
name|nsec
decl_stmt|;
name|bp
operator|->
name|bio_pflags
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_geom
operator|->
name|consumer
argument_list|)
expr_stmt|;
name|cbp
operator|=
name|bp
operator|->
name|bio_driver1
expr_stmt|;
name|bp
operator|->
name|bio_driver1
operator|=
name|NULL
expr_stmt|;
name|cbp
operator|->
name|bio_to
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|cbp
operator|->
name|bio_done
operator|=
name|g_eli_read_done
expr_stmt|;
comment|/* Number of sectors from decrypted provider, eg. 1. */
name|nsec
operator|=
name|bp
operator|->
name|bio_length
operator|/
name|bp
operator|->
name|bio_to
operator|->
name|sectorsize
expr_stmt|;
comment|/* Number of sectors from encrypted provider, eg. 9. */
name|nsec
operator|=
operator|(
name|nsec
operator|*
name|sc
operator|->
name|sc_bytes_per_sector
operator|)
operator|/
name|cp
operator|->
name|provider
operator|->
name|sectorsize
expr_stmt|;
name|cbp
operator|->
name|bio_length
operator|=
name|cp
operator|->
name|provider
operator|->
name|sectorsize
operator|*
name|nsec
expr_stmt|;
name|size
operator|=
name|cbp
operator|->
name|bio_length
expr_stmt|;
name|size
operator|+=
name|sc
operator|->
name|sc_alen
operator|*
name|nsec
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|cryptop
argument_list|)
operator|*
name|nsec
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|cryptodesc
argument_list|)
operator|*
name|nsec
operator|*
literal|2
expr_stmt|;
name|size
operator|+=
name|G_ELI_AUTH_SECKEYLEN
operator|*
name|nsec
expr_stmt|;
name|cbp
operator|->
name|bio_offset
operator|=
operator|(
name|bp
operator|->
name|bio_offset
operator|/
name|bp
operator|->
name|bio_to
operator|->
name|sectorsize
operator|)
operator|*
name|sc
operator|->
name|sc_bytes_per_sector
expr_stmt|;
name|bp
operator|->
name|bio_driver2
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_ELI
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|bio_data
operator|=
name|bp
operator|->
name|bio_driver2
expr_stmt|;
comment|/* 	 * We read more than what is requested, so we have to be ready to read 	 * more than MAXPHYS. 	 */
name|cbp2
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|bio_length
operator|>
name|MAXPHYS
condition|)
block|{
name|cbp2
operator|=
name|g_duplicate_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|cbp2
operator|->
name|bio_length
operator|=
name|cbp
operator|->
name|bio_length
operator|-
name|MAXPHYS
expr_stmt|;
name|cbp2
operator|->
name|bio_data
operator|=
name|cbp
operator|->
name|bio_data
operator|+
name|MAXPHYS
expr_stmt|;
name|cbp2
operator|->
name|bio_offset
operator|=
name|cbp
operator|->
name|bio_offset
operator|+
name|MAXPHYS
expr_stmt|;
name|cbp2
operator|->
name|bio_to
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|cbp2
operator|->
name|bio_done
operator|=
name|g_eli_read_done
expr_stmt|;
name|cbp
operator|->
name|bio_length
operator|=
name|MAXPHYS
expr_stmt|;
block|}
comment|/* 	 * Read encrypted data from provider. 	 */
name|G_ELI_LOGREQ
argument_list|(
literal|2
argument_list|,
name|cbp
argument_list|,
literal|"Sending request."
argument_list|)
expr_stmt|;
name|g_io_request
argument_list|(
name|cbp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp2
operator|!=
name|NULL
condition|)
block|{
name|G_ELI_LOGREQ
argument_list|(
literal|2
argument_list|,
name|cbp2
argument_list|,
literal|"Sending request."
argument_list|)
expr_stmt|;
name|g_io_request
argument_list|(
name|cbp2
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is the main function responsible for cryptography (ie. communication  * with crypto(9) subsystem).  *  * BIO_READ:  *	g_eli_start -> g_eli_auth_read -> g_io_request -> g_eli_read_done -> G_ELI_AUTH_RUN -> g_eli_auth_read_done -> g_io_deliver  * BIO_WRITE:  *	g_eli_start -> G_ELI_AUTH_RUN -> g_eli_auth_write_done -> g_io_request -> g_eli_write_done -> g_io_deliver  */
end_comment

begin_function
name|void
name|g_eli_auth_run
parameter_list|(
name|struct
name|g_eli_worker
modifier|*
name|wr
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_eli_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|cryptop
modifier|*
name|crp
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|crde
decl_stmt|,
modifier|*
name|crda
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|lsec
decl_stmt|,
name|nsec
decl_stmt|,
name|data_secsize
decl_stmt|,
name|decr_secsize
decl_stmt|,
name|encr_secsize
decl_stmt|;
name|off_t
name|dstoff
decl_stmt|;
name|u_char
modifier|*
name|p
decl_stmt|,
modifier|*
name|data
decl_stmt|,
modifier|*
name|auth
decl_stmt|,
modifier|*
name|authkey
decl_stmt|,
modifier|*
name|plaindata
decl_stmt|;
name|int
name|error
decl_stmt|;
name|G_ELI_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"%s"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_pflags
operator|=
name|wr
operator|->
name|w_number
expr_stmt|;
name|sc
operator|=
name|wr
operator|->
name|w_softc
expr_stmt|;
comment|/* Sectorsize of decrypted provider eg. 4096. */
name|decr_secsize
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|sectorsize
expr_stmt|;
comment|/* The real sectorsize of encrypted provider, eg. 512. */
name|encr_secsize
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_geom
operator|->
name|consumer
argument_list|)
operator|->
name|provider
operator|->
name|sectorsize
expr_stmt|;
comment|/* Number of data bytes in one encrypted sector, eg. 480. */
name|data_secsize
operator|=
name|sc
operator|->
name|sc_data_per_sector
expr_stmt|;
comment|/* Number of sectors from decrypted provider, eg. 2. */
name|nsec
operator|=
name|bp
operator|->
name|bio_length
operator|/
name|decr_secsize
expr_stmt|;
comment|/* Number of sectors from encrypted provider, eg. 18. */
name|nsec
operator|=
operator|(
name|nsec
operator|*
name|sc
operator|->
name|sc_bytes_per_sector
operator|)
operator|/
name|encr_secsize
expr_stmt|;
comment|/* Last sector number in every big sector, eg. 9. */
name|lsec
operator|=
name|sc
operator|->
name|sc_bytes_per_sector
operator|/
name|encr_secsize
expr_stmt|;
comment|/* Destination offset, used for IV generation. */
name|dstoff
operator|=
operator|(
name|bp
operator|->
name|bio_offset
operator|/
name|bp
operator|->
name|bio_to
operator|->
name|sectorsize
operator|)
operator|*
name|sc
operator|->
name|sc_bytes_per_sector
expr_stmt|;
name|auth
operator|=
name|NULL
expr_stmt|;
comment|/* Silence compiler warning. */
name|plaindata
operator|=
name|bp
operator|->
name|bio_data
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
block|{
name|data
operator|=
name|bp
operator|->
name|bio_driver2
expr_stmt|;
name|auth
operator|=
name|data
operator|+
name|encr_secsize
operator|*
name|nsec
expr_stmt|;
name|p
operator|=
name|auth
operator|+
name|sc
operator|->
name|sc_alen
operator|*
name|nsec
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|size
decl_stmt|;
name|size
operator|=
name|encr_secsize
operator|*
name|nsec
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|crp
argument_list|)
operator|*
name|nsec
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|crde
argument_list|)
operator|*
name|nsec
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|crda
argument_list|)
operator|*
name|nsec
expr_stmt|;
name|size
operator|+=
name|G_ELI_AUTH_SECKEYLEN
operator|*
name|nsec
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
expr_stmt|;
comment|/* Space for alignment. */
name|data
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_ELI
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_driver2
operator|=
name|data
expr_stmt|;
name|p
operator|=
name|data
operator|+
name|encr_secsize
operator|*
name|nsec
expr_stmt|;
block|}
name|bp
operator|->
name|bio_inbed
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bio_children
operator|=
name|nsec
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__mips_n64
argument_list|)
operator|||
name|defined
argument_list|(
name|__mips_o64
argument_list|)
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|roundup
argument_list|(
operator|(
name|uintptr_t
operator|)
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nsec
condition|;
name|i
operator|++
operator|,
name|dstoff
operator|+=
name|encr_secsize
control|)
block|{
name|crp
operator|=
operator|(
expr|struct
name|cryptop
operator|*
operator|)
name|p
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|crp
argument_list|)
expr_stmt|;
name|crde
operator|=
operator|(
expr|struct
name|cryptodesc
operator|*
operator|)
name|p
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|crde
argument_list|)
expr_stmt|;
name|crda
operator|=
operator|(
expr|struct
name|cryptodesc
operator|*
operator|)
name|p
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|crda
argument_list|)
expr_stmt|;
name|authkey
operator|=
operator|(
name|u_char
operator|*
operator|)
name|p
expr_stmt|;
name|p
operator|+=
name|G_ELI_AUTH_SECKEYLEN
expr_stmt|;
name|data_secsize
operator|=
name|sc
operator|->
name|sc_data_per_sector
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|%
name|lsec
operator|)
operator|==
literal|0
condition|)
name|data_secsize
operator|=
name|decr_secsize
operator|%
name|data_secsize
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
block|{
comment|/* Remember read HMAC. */
name|bcopy
argument_list|(
name|data
argument_list|,
name|auth
argument_list|,
name|sc
operator|->
name|sc_alen
argument_list|)
expr_stmt|;
name|auth
operator|+=
name|sc
operator|->
name|sc_alen
expr_stmt|;
comment|/* TODO: bzero(9) can be commented out later. */
name|bzero
argument_list|(
name|data
argument_list|,
name|sc
operator|->
name|sc_alen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|plaindata
argument_list|,
name|data
operator|+
name|sc
operator|->
name|sc_alen
argument_list|,
name|data_secsize
argument_list|)
expr_stmt|;
name|plaindata
operator|+=
name|data_secsize
expr_stmt|;
block|}
name|crp
operator|->
name|crp_sid
operator|=
name|wr
operator|->
name|w_sid
expr_stmt|;
name|crp
operator|->
name|crp_ilen
operator|=
name|sc
operator|->
name|sc_alen
operator|+
name|data_secsize
expr_stmt|;
name|crp
operator|->
name|crp_olen
operator|=
name|data_secsize
expr_stmt|;
name|crp
operator|->
name|crp_opaque
operator|=
operator|(
name|void
operator|*
operator|)
name|bp
expr_stmt|;
name|crp
operator|->
name|crp_buf
operator|=
operator|(
name|void
operator|*
operator|)
name|data
expr_stmt|;
name|data
operator|+=
name|encr_secsize
expr_stmt|;
name|crp
operator|->
name|crp_flags
operator|=
name|CRYPTO_F_CBIFSYNC
expr_stmt|;
if|if
condition|(
name|g_eli_batch
condition|)
name|crp
operator|->
name|crp_flags
operator||=
name|CRYPTO_F_BATCH
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
condition|)
block|{
name|crp
operator|->
name|crp_callback
operator|=
name|g_eli_auth_write_done
expr_stmt|;
name|crp
operator|->
name|crp_desc
operator|=
name|crde
expr_stmt|;
name|crde
operator|->
name|crd_next
operator|=
name|crda
expr_stmt|;
name|crda
operator|->
name|crd_next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|crp
operator|->
name|crp_callback
operator|=
name|g_eli_auth_read_done
expr_stmt|;
name|crp
operator|->
name|crp_desc
operator|=
name|crda
expr_stmt|;
name|crda
operator|->
name|crd_next
operator|=
name|crde
expr_stmt|;
name|crde
operator|->
name|crd_next
operator|=
name|NULL
expr_stmt|;
block|}
name|crde
operator|->
name|crd_skip
operator|=
name|sc
operator|->
name|sc_alen
expr_stmt|;
name|crde
operator|->
name|crd_len
operator|=
name|data_secsize
expr_stmt|;
name|crde
operator|->
name|crd_flags
operator|=
name|CRD_F_IV_EXPLICIT
operator||
name|CRD_F_IV_PRESENT
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_ELI_FLAG_FIRST_KEY
operator|)
operator|==
literal|0
condition|)
name|crde
operator|->
name|crd_flags
operator||=
name|CRD_F_KEY_EXPLICIT
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
condition|)
name|crde
operator|->
name|crd_flags
operator||=
name|CRD_F_ENCRYPT
expr_stmt|;
name|crde
operator|->
name|crd_alg
operator|=
name|sc
operator|->
name|sc_ealgo
expr_stmt|;
name|crde
operator|->
name|crd_key
operator|=
name|g_eli_key_hold
argument_list|(
name|sc
argument_list|,
name|dstoff
argument_list|,
name|encr_secsize
argument_list|)
expr_stmt|;
name|crde
operator|->
name|crd_klen
operator|=
name|sc
operator|->
name|sc_ekeylen
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ealgo
operator|==
name|CRYPTO_AES_XTS
condition|)
name|crde
operator|->
name|crd_klen
operator|<<=
literal|1
expr_stmt|;
name|g_eli_crypto_ivgen
argument_list|(
name|sc
argument_list|,
name|dstoff
argument_list|,
name|crde
operator|->
name|crd_iv
argument_list|,
sizeof|sizeof
argument_list|(
name|crde
operator|->
name|crd_iv
argument_list|)
argument_list|)
expr_stmt|;
name|crda
operator|->
name|crd_skip
operator|=
name|sc
operator|->
name|sc_alen
expr_stmt|;
name|crda
operator|->
name|crd_len
operator|=
name|data_secsize
expr_stmt|;
name|crda
operator|->
name|crd_inject
operator|=
literal|0
expr_stmt|;
name|crda
operator|->
name|crd_flags
operator|=
name|CRD_F_KEY_EXPLICIT
expr_stmt|;
name|crda
operator|->
name|crd_alg
operator|=
name|sc
operator|->
name|sc_aalgo
expr_stmt|;
name|g_eli_auth_keygen
argument_list|(
name|sc
argument_list|,
name|dstoff
argument_list|,
name|authkey
argument_list|)
expr_stmt|;
name|crda
operator|->
name|crd_key
operator|=
name|authkey
expr_stmt|;
name|crda
operator|->
name|crd_klen
operator|=
name|G_ELI_AUTH_SECKEYLEN
operator|*
literal|8
expr_stmt|;
name|crp
operator|->
name|crp_etype
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|crypto_dispatch
argument_list|(
name|crp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"crypto_dispatch() failed (error=%d)"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

