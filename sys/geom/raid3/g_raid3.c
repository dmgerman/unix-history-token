begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004 Pawel Jakub Dawidek<pjd@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<geom/raid3/g_raid3.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_RAID3
argument_list|,
literal|"raid3 data"
argument_list|,
literal|"GEOM_RAID3 Data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_kern_geom
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern_geom
argument_list|,
name|OID_AUTO
argument_list|,
name|raid3
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"GEOM_RAID3 stuff"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_int
name|g_raid3_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.geom.raid3.debug"
argument_list|,
operator|&
name|g_raid3_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_raid3
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_raid3_debug
argument_list|,
literal|0
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_raid3_timeout
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.geom.raid3.timeout"
argument_list|,
operator|&
name|g_raid3_timeout
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_raid3
argument_list|,
name|OID_AUTO
argument_list|,
name|timeout
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_raid3_timeout
argument_list|,
literal|0
argument_list|,
literal|"Time to wait on all raid3 components"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_raid3_idletime
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.geom.raid3.idletime"
argument_list|,
operator|&
name|g_raid3_idletime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_raid3
argument_list|,
name|OID_AUTO
argument_list|,
name|idletime
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_raid3_idletime
argument_list|,
literal|0
argument_list|,
literal|"Mark components as clean when idling"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_raid3_reqs_per_sync
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_raid3
argument_list|,
name|OID_AUTO
argument_list|,
name|reqs_per_sync
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_raid3_reqs_per_sync
argument_list|,
literal|0
argument_list|,
literal|"Number of regular I/O requests per synchronization request"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_raid3_syncs_per_sec
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_raid3
argument_list|,
name|OID_AUTO
argument_list|,
name|syncs_per_sec
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_raid3_syncs_per_sec
argument_list|,
literal|0
argument_list|,
literal|"Number of synchronizations requests per second"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_raid3_n64k
init|=
literal|50
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.geom.raid3.n64k"
argument_list|,
operator|&
name|g_raid3_n64k
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_raid3
argument_list|,
name|OID_AUTO
argument_list|,
name|n64k
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|g_raid3_n64k
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of 64kB allocations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_raid3_n16k
init|=
literal|200
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.geom.raid3.n16k"
argument_list|,
operator|&
name|g_raid3_n16k
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_raid3
argument_list|,
name|OID_AUTO
argument_list|,
name|n16k
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|g_raid3_n16k
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of 16kB allocations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_raid3_n4k
init|=
literal|1200
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.geom.raid3.n4k"
argument_list|,
operator|&
name|g_raid3_n4k
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_raid3
argument_list|,
name|OID_AUTO
argument_list|,
name|n4k
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|g_raid3_n4k
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of 4kB allocations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern_geom_raid3
argument_list|,
name|OID_AUTO
argument_list|,
name|stat
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"GEOM_RAID3 statistics"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_raid3_parity_mismatch
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_raid3_stat
argument_list|,
name|OID_AUTO
argument_list|,
name|parity_mismatch
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|g_raid3_parity_mismatch
argument_list|,
literal|0
argument_list|,
literal|"Number of failures in VERIFY mode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_raid3_64k_requested
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_raid3_stat
argument_list|,
name|OID_AUTO
argument_list|,
literal|64k_requested
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|g_raid3_64k_requested
argument_list|,
literal|0
argument_list|,
literal|"Number of requested 64kB allocations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_raid3_64k_failed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_raid3_stat
argument_list|,
name|OID_AUTO
argument_list|,
literal|64k_failed
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|g_raid3_64k_failed
argument_list|,
literal|0
argument_list|,
literal|"Number of failed 64kB allocations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_raid3_16k_requested
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_raid3_stat
argument_list|,
name|OID_AUTO
argument_list|,
literal|16k_requested
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|g_raid3_16k_requested
argument_list|,
literal|0
argument_list|,
literal|"Number of requested 16kB allocations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_raid3_16k_failed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_raid3_stat
argument_list|,
name|OID_AUTO
argument_list|,
literal|16k_failed
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|g_raid3_16k_failed
argument_list|,
literal|0
argument_list|,
literal|"Number of failed 16kB allocations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_raid3_4k_requested
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_raid3_stat
argument_list|,
name|OID_AUTO
argument_list|,
literal|4k_requested
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|g_raid3_4k_requested
argument_list|,
literal|0
argument_list|,
literal|"Number of requested 4kB allocations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_raid3_4k_failed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_raid3_stat
argument_list|,
name|OID_AUTO
argument_list|,
literal|4k_failed
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|g_raid3_4k_failed
argument_list|,
literal|0
argument_list|,
literal|"Number of failed 4kB allocations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MSLEEP
parameter_list|(
name|ident
parameter_list|,
name|mtx
parameter_list|,
name|priority
parameter_list|,
name|wmesg
parameter_list|,
name|timeout
parameter_list|)
value|do {		\ 	G_RAID3_DEBUG(4, "%s: Sleeping %p.", __func__, (ident));	\ 	msleep((ident), (mtx), (priority), (wmesg), (timeout));		\ 	G_RAID3_DEBUG(4, "%s: Woken up %p.", __func__, (ident));	\ } while (0)
end_define

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|g_raid3_ehtag
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|g_raid3_destroy_geom
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|g_taste_t
name|g_raid3_taste
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|g_raid3_init
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_raid3_fini
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|g_class
name|g_raid3_class
init|=
block|{
operator|.
name|name
operator|=
name|G_RAID3_CLASS_NAME
block|,
operator|.
name|version
operator|=
name|G_VERSION
block|,
operator|.
name|ctlreq
operator|=
name|g_raid3_config
block|,
operator|.
name|taste
operator|=
name|g_raid3_taste
block|,
operator|.
name|destroy_geom
operator|=
name|g_raid3_destroy_geom
block|,
operator|.
name|init
operator|=
name|g_raid3_init
block|,
operator|.
name|fini
operator|=
name|g_raid3_fini
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|g_raid3_destroy_provider
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_raid3_update_disk
parameter_list|(
name|struct
name|g_raid3_disk
modifier|*
name|disk
parameter_list|,
name|u_int
name|state
parameter_list|,
name|int
name|waitidle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_raid3_update_device
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|,
name|boolean_t
name|force
parameter_list|,
name|int
name|waitidle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_raid3_dumpconf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_raid3_sync_stop
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * XXX: it should be placed in subr_disk.c.  */
end_comment

begin_function
specifier|static
name|void
name|bioq_insert_head
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|head
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|g_raid3_disk_state2str
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|G_RAID3_DISK_STATE_NODISK
case|:
return|return
operator|(
literal|"NODISK"
operator|)
return|;
case|case
name|G_RAID3_DISK_STATE_NONE
case|:
return|return
operator|(
literal|"NONE"
operator|)
return|;
case|case
name|G_RAID3_DISK_STATE_NEW
case|:
return|return
operator|(
literal|"NEW"
operator|)
return|;
case|case
name|G_RAID3_DISK_STATE_ACTIVE
case|:
return|return
operator|(
literal|"ACTIVE"
operator|)
return|;
case|case
name|G_RAID3_DISK_STATE_STALE
case|:
return|return
operator|(
literal|"STALE"
operator|)
return|;
case|case
name|G_RAID3_DISK_STATE_SYNCHRONIZING
case|:
return|return
operator|(
literal|"SYNCHRONIZING"
operator|)
return|;
case|case
name|G_RAID3_DISK_STATE_DISCONNECTED
case|:
return|return
operator|(
literal|"DISCONNECTED"
operator|)
return|;
default|default:
return|return
operator|(
literal|"INVALID"
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|g_raid3_device_state2str
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|G_RAID3_DEVICE_STATE_STARTING
case|:
return|return
operator|(
literal|"STARTING"
operator|)
return|;
case|case
name|G_RAID3_DEVICE_STATE_DEGRADED
case|:
return|return
operator|(
literal|"DEGRADED"
operator|)
return|;
case|case
name|G_RAID3_DEVICE_STATE_COMPLETE
case|:
return|return
operator|(
literal|"COMPLETE"
operator|)
return|;
default|default:
return|return
operator|(
literal|"INVALID"
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|g_raid3_get_diskname
parameter_list|(
name|struct
name|g_raid3_disk
modifier|*
name|disk
parameter_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_consumer
operator|==
name|NULL
operator|||
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"[unknown]"
operator|)
return|;
return|return
operator|(
name|disk
operator|->
name|d_name
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|g_raid3_xor
parameter_list|(
name|src1
parameter_list|,
name|src2
parameter_list|,
name|dst
parameter_list|,
name|size
parameter_list|)
define|\
value|_g_raid3_xor((uint64_t *)(src1), (uint64_t *)(src2),		\ 	    (uint64_t *)(dst), (size_t)size)
end_define

begin_function
specifier|static
name|void
name|_g_raid3_xor
parameter_list|(
name|uint64_t
modifier|*
name|src1
parameter_list|,
name|uint64_t
modifier|*
name|src2
parameter_list|,
name|uint64_t
modifier|*
name|dst
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|size
operator|%
literal|128
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"Invalid size: %zu."
operator|,
name|size
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|size
operator|>
literal|0
condition|;
name|size
operator|-=
literal|128
control|)
block|{
operator|*
name|dst
operator|++
operator|=
operator|(
operator|*
name|src1
operator|++
operator|)
operator|^
operator|(
operator|*
name|src2
operator|++
operator|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|(
operator|*
name|src1
operator|++
operator|)
operator|^
operator|(
operator|*
name|src2
operator|++
operator|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|(
operator|*
name|src1
operator|++
operator|)
operator|^
operator|(
operator|*
name|src2
operator|++
operator|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|(
operator|*
name|src1
operator|++
operator|)
operator|^
operator|(
operator|*
name|src2
operator|++
operator|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|(
operator|*
name|src1
operator|++
operator|)
operator|^
operator|(
operator|*
name|src2
operator|++
operator|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|(
operator|*
name|src1
operator|++
operator|)
operator|^
operator|(
operator|*
name|src2
operator|++
operator|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|(
operator|*
name|src1
operator|++
operator|)
operator|^
operator|(
operator|*
name|src2
operator|++
operator|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|(
operator|*
name|src1
operator|++
operator|)
operator|^
operator|(
operator|*
name|src2
operator|++
operator|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|(
operator|*
name|src1
operator|++
operator|)
operator|^
operator|(
operator|*
name|src2
operator|++
operator|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|(
operator|*
name|src1
operator|++
operator|)
operator|^
operator|(
operator|*
name|src2
operator|++
operator|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|(
operator|*
name|src1
operator|++
operator|)
operator|^
operator|(
operator|*
name|src2
operator|++
operator|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|(
operator|*
name|src1
operator|++
operator|)
operator|^
operator|(
operator|*
name|src2
operator|++
operator|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|(
operator|*
name|src1
operator|++
operator|)
operator|^
operator|(
operator|*
name|src2
operator|++
operator|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|(
operator|*
name|src1
operator|++
operator|)
operator|^
operator|(
operator|*
name|src2
operator|++
operator|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|(
operator|*
name|src1
operator|++
operator|)
operator|^
operator|(
operator|*
name|src2
operator|++
operator|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|(
operator|*
name|src1
operator|++
operator|)
operator|^
operator|(
operator|*
name|src2
operator|++
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid3_is_zero
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
specifier|static
specifier|const
name|uint64_t
name|zeros
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|u_char
modifier|*
name|addr
decl_stmt|;
name|ssize_t
name|size
decl_stmt|;
name|size
operator|=
name|bp
operator|->
name|bio_length
expr_stmt|;
name|addr
operator|=
operator|(
name|u_char
operator|*
operator|)
name|bp
operator|->
name|bio_data
expr_stmt|;
for|for
control|(
init|;
name|size
operator|>
literal|0
condition|;
name|size
operator|-=
sizeof|sizeof
argument_list|(
name|zeros
argument_list|)
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|zeros
argument_list|)
control|)
block|{
if|if
condition|(
name|bcmp
argument_list|(
name|addr
argument_list|,
name|zeros
argument_list|,
sizeof|sizeof
argument_list|(
name|zeros
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * --- Events handling functions ---  * Events in geom_raid3 are used to maintain disks and device status  * from one thread to simplify locking.  */
end_comment

begin_function
specifier|static
name|void
name|g_raid3_event_free
parameter_list|(
name|struct
name|g_raid3_event
modifier|*
name|ep
parameter_list|)
block|{
name|free
argument_list|(
name|ep
argument_list|,
name|M_RAID3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|g_raid3_event_send
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|state
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|g_raid3_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid3_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_raid3_event
modifier|*
name|ep
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ep
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
argument_list|,
name|M_RAID3
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Sending event %p."
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|G_RAID3_EVENT_DEVICE
operator|)
operator|!=
literal|0
condition|)
block|{
name|disk
operator|=
name|NULL
expr_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
block|}
else|else
block|{
name|disk
operator|=
name|arg
expr_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
block|}
name|ep
operator|->
name|e_disk
operator|=
name|disk
expr_stmt|;
name|ep
operator|->
name|e_state
operator|=
name|state
expr_stmt|;
name|ep
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|ep
operator|->
name|e_error
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_events
argument_list|,
name|ep
argument_list|,
name|e_next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Waking up %p."
argument_list|,
name|__func__
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|G_RAID3_EVENT_DONTWAIT
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Sleeping %p."
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_RAID3_EVENT_DONE
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|MSLEEP
argument_list|(
name|ep
argument_list|,
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|,
name|PRIBIO
operator||
name|PDROP
argument_list|,
literal|"r3:event"
argument_list|,
name|hz
operator|*
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* Don't even try to use 'sc' here, because it could be already dead. */
name|g_topology_lock
argument_list|()
expr_stmt|;
name|error
operator|=
name|ep
operator|->
name|e_error
expr_stmt|;
name|g_raid3_event_free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|g_raid3_event
modifier|*
name|g_raid3_event_get
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_raid3_event
modifier|*
name|ep
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|ep
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_events
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_events
argument_list|,
name|ep
argument_list|,
name|e_next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ep
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_event_cancel
parameter_list|(
name|struct
name|g_raid3_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_raid3_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid3_event
modifier|*
name|ep
decl_stmt|,
modifier|*
name|tmpep
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ep
argument_list|,
argument|&sc->sc_events
argument_list|,
argument|e_next
argument_list|,
argument|tmpep
argument_list|)
block|{
if|if
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_RAID3_EVENT_DEVICE
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ep
operator|->
name|e_disk
operator|!=
name|disk
condition|)
continue|continue;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_events
argument_list|,
name|ep
argument_list|,
name|e_next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_RAID3_EVENT_DONTWAIT
operator|)
operator|!=
literal|0
condition|)
name|g_raid3_event_free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
else|else
block|{
name|ep
operator|->
name|e_error
operator|=
name|ECANCELED
expr_stmt|;
name|wakeup
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the number of disks in the given state.  * If state is equal to -1, count all connected disks.  */
end_comment

begin_function
name|u_int
name|g_raid3_ndisks
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|g_raid3_disk
modifier|*
name|disk
decl_stmt|;
name|u_int
name|n
decl_stmt|,
name|ndisks
decl_stmt|;
for|for
control|(
name|n
operator|=
name|ndisks
operator|=
literal|0
init|;
name|n
operator|<
name|sc
operator|->
name|sc_ndisks
condition|;
name|n
operator|++
control|)
block|{
name|disk
operator|=
operator|&
name|sc
operator|->
name|sc_disks
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_NODISK
condition|)
continue|continue;
if|if
condition|(
name|state
operator|==
operator|-
literal|1
operator|||
name|disk
operator|->
name|d_state
operator|==
name|state
condition|)
name|ndisks
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ndisks
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|g_raid3_nrequests
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|u_int
name|nreqs
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&sc->sc_queue.queue
argument_list|,
argument|bio_queue
argument_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_from
operator|==
name|cp
condition|)
name|nreqs
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|nreqs
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid3_is_busy
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
if|if
condition|(
name|cp
operator|->
name|index
operator|>
literal|0
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"I/O requests for %s exist, can't destroy it now."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|g_raid3_nrequests
argument_list|(
name|sc
argument_list|,
name|cp
argument_list|)
operator|>
literal|0
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"I/O requests for %s in queue, can't destroy it now."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_kill_consumer
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|g_topology_assert
argument_list|()
expr_stmt|;
name|cp
operator|->
name|private
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|g_raid3_is_busy
argument_list|(
name|sc
argument_list|,
name|cp
argument_list|)
condition|)
return|return;
name|G_RAID3_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Consumer %s destroyed."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid3_connect_disk
parameter_list|(
name|struct
name|g_raid3_disk
modifier|*
name|disk
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_consumer
operator|==
name|NULL
argument_list|,
operator|(
literal|"Disk already connected (device %s)."
operator|,
name|disk
operator|->
name|d_softc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|=
name|g_new_consumer
argument_list|(
name|disk
operator|->
name|d_softc
operator|->
name|sc_geom
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|->
name|private
operator|=
name|disk
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|g_attach
argument_list|(
name|disk
operator|->
name|d_consumer
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|G_RAID3_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Disk %s connected."
argument_list|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_disconnect_consumer
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|g_topology_assert
argument_list|()
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|cp
operator|->
name|provider
operator|!=
name|NULL
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Disk %s disconnected."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|acr
operator|>
literal|0
operator|||
name|cp
operator|->
name|acw
operator|>
literal|0
operator|||
name|cp
operator|->
name|ace
operator|>
literal|0
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Access %s r%dw%de%d = %d"
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|,
operator|-
name|cp
operator|->
name|acr
argument_list|,
operator|-
name|cp
operator|->
name|acw
argument_list|,
operator|-
name|cp
operator|->
name|ace
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
name|cp
operator|->
name|acr
argument_list|,
operator|-
name|cp
operator|->
name|acw
argument_list|,
operator|-
name|cp
operator|->
name|ace
argument_list|)
expr_stmt|;
block|}
name|g_raid3_kill_consumer
argument_list|(
name|sc
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize disk. This means allocate memory, create consumer, attach it  * to the provider and open access (r1w1e1) to it.  */
end_comment

begin_function
specifier|static
name|struct
name|g_raid3_disk
modifier|*
name|g_raid3_init_disk
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|struct
name|g_raid3_metadata
modifier|*
name|md
parameter_list|,
name|int
modifier|*
name|errorp
parameter_list|)
block|{
name|struct
name|g_raid3_disk
modifier|*
name|disk
decl_stmt|;
name|int
name|error
decl_stmt|;
name|disk
operator|=
operator|&
name|sc
operator|->
name|sc_disks
index|[
name|md
operator|->
name|md_no
index|]
expr_stmt|;
name|disk
operator|->
name|d_softc
operator|=
name|sc
expr_stmt|;
name|error
operator|=
name|g_raid3_connect_disk
argument_list|(
name|disk
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|disk
operator|->
name|d_no
operator|=
name|md
operator|->
name|md_no
expr_stmt|;
name|disk
operator|->
name|d_state
operator|=
name|G_RAID3_DISK_STATE_NONE
expr_stmt|;
name|disk
operator|->
name|d_flags
operator|=
name|md
operator|->
name|md_dflags
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|md_provider
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|disk
operator|->
name|d_flags
operator||=
name|G_RAID3_DISK_FLAG_HARDCODED
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|=
name|NULL
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset
operator|=
name|md
operator|->
name|md_sync_offset
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset_done
operator|=
name|md
operator|->
name|md_sync_offset
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_resync
operator|=
operator|-
literal|1
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|=
name|md
operator|->
name|md_syncid
expr_stmt|;
if|if
condition|(
name|errorp
operator|!=
name|NULL
condition|)
operator|*
name|errorp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|disk
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|errorp
operator|!=
name|NULL
condition|)
operator|*
name|errorp
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|disk
operator|!=
name|NULL
condition|)
name|g_raid3_disconnect_consumer
argument_list|(
name|sc
argument_list|,
name|disk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_destroy_disk
parameter_list|(
name|struct
name|g_raid3_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_raid3_softc
modifier|*
name|sc
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_NODISK
condition|)
return|return;
name|g_raid3_event_cancel
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
switch|switch
condition|(
name|disk
operator|->
name|d_state
condition|)
block|{
case|case
name|G_RAID3_DISK_STATE_SYNCHRONIZING
case|:
if|if
condition|(
name|sc
operator|->
name|sc_syncdisk
operator|!=
name|NULL
condition|)
name|g_raid3_sync_stop
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|G_RAID3_DISK_STATE_NEW
case|:
case|case
name|G_RAID3_DISK_STATE_STALE
case|:
case|case
name|G_RAID3_DISK_STATE_ACTIVE
case|:
name|g_raid3_disconnect_consumer
argument_list|(
name|sc
argument_list|,
name|disk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
literal|0
operator|==
literal|1
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_raid3_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|disk
operator|->
name|d_state
operator|=
name|G_RAID3_DISK_STATE_NODISK
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_destroy_device
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_raid3_event
modifier|*
name|ep
decl_stmt|;
name|struct
name|g_raid3_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|u_int
name|n
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|gp
operator|=
name|sc
operator|->
name|sc_geom
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_provider
operator|!=
name|NULL
condition|)
name|g_raid3_destroy_provider
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|sc
operator|->
name|sc_ndisks
condition|;
name|n
operator|++
control|)
block|{
name|disk
operator|=
operator|&
name|sc
operator|->
name|sc_disks
index|[
name|n
index|]
expr_stmt|;
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_RAID3_DISK_FLAG_DIRTY
expr_stmt|;
name|g_raid3_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|g_raid3_destroy_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ep
operator|=
name|g_raid3_event_get
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_RAID3_EVENT_DONTWAIT
operator|)
operator|!=
literal|0
condition|)
name|g_raid3_event_free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
else|else
block|{
name|ep
operator|->
name|e_error
operator|=
name|ECANCELED
expr_stmt|;
name|ep
operator|->
name|e_flags
operator||=
name|G_RAID3_EVENT_DONE
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Waking up %p."
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
block|}
block|}
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|)
expr_stmt|;
name|gp
operator|->
name|softc
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
operator|->
name|consumer
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|g_raid3_disconnect_consumer
argument_list|(
name|sc
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
operator|->
name|softc
operator|=
name|NULL
expr_stmt|;
name|g_wither_geom
argument_list|(
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|sc
operator|->
name|sc_zone_64k
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|sc
operator|->
name|sc_zone_16k
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|sc
operator|->
name|sc_zone_4k
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s destroyed."
argument_list|,
name|gp
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_wither_geom
argument_list|(
name|gp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_orphan
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_raid3_disk
modifier|*
name|disk
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|disk
operator|=
name|cp
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
return|return;
name|disk
operator|->
name|d_softc
operator|->
name|sc_bump_syncid
operator|=
name|G_RAID3_BUMP_ON_FIRST_WRITE
expr_stmt|;
name|g_raid3_event_send
argument_list|(
name|disk
argument_list|,
name|G_RAID3_DISK_STATE_DISCONNECTED
argument_list|,
name|G_RAID3_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_spoiled
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_raid3_disk
modifier|*
name|disk
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|disk
operator|=
name|cp
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
return|return;
name|disk
operator|->
name|d_softc
operator|->
name|sc_bump_syncid
operator|=
name|G_RAID3_BUMP_IMMEDIATELY
expr_stmt|;
name|g_raid3_event_send
argument_list|(
name|disk
argument_list|,
name|G_RAID3_DISK_STATE_DISCONNECTED
argument_list|,
name|G_RAID3_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid3_write_metadata
parameter_list|(
name|struct
name|g_raid3_disk
modifier|*
name|disk
parameter_list|,
name|struct
name|g_raid3_metadata
modifier|*
name|md
parameter_list|)
block|{
name|struct
name|g_raid3_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|off_t
name|offset
decl_stmt|,
name|length
decl_stmt|;
name|int
name|close
init|=
literal|0
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|u_char
modifier|*
name|sector
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL consumer (%s)."
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|->
name|provider
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL provider (%s)."
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
name|length
operator|=
name|cp
operator|->
name|provider
operator|->
name|sectorsize
expr_stmt|;
name|offset
operator|=
name|cp
operator|->
name|provider
operator|->
name|mediasize
operator|-
name|length
expr_stmt|;
name|sector
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|length
argument_list|,
name|M_RAID3
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* 	 * Open consumer if it wasn't opened and remember to close it. 	 */
if|if
condition|(
name|cp
operator|->
name|acw
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Access %s r%dw%de%d = %d"
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|close
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|cp
operator|->
name|acw
operator|>
literal|0
operator|&&
name|cp
operator|->
name|ace
operator|>
literal|0
argument_list|,
operator|(
literal|"Consumer %s not opened (r%dw%de%d)."
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|,
name|cp
operator|->
name|acr
operator|,
name|cp
operator|->
name|acw
operator|,
name|cp
operator|->
name|ace
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|md
operator|!=
name|NULL
condition|)
name|raid3_metadata_encode
argument_list|(
name|md
argument_list|,
name|sector
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|error
operator|=
name|g_write_data
argument_list|(
name|cp
argument_list|,
name|offset
argument_list|,
name|sector
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
block|}
name|free
argument_list|(
name|sector
argument_list|,
name|M_RAID3
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
condition|)
block|{
name|g_access
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Access %s r%dw%de%d = %d"
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|disk
operator|->
name|d_softc
operator|->
name|sc_bump_syncid
operator|=
name|G_RAID3_BUMP_IMMEDIATELY
expr_stmt|;
name|g_raid3_event_send
argument_list|(
name|disk
argument_list|,
name|G_RAID3_DISK_STATE_DISCONNECTED
argument_list|,
name|G_RAID3_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|g_raid3_clear_metadata
parameter_list|(
name|struct
name|g_raid3_disk
modifier|*
name|disk
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|error
operator|=
name|g_raid3_write_metadata
argument_list|(
name|disk
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Metadata on %s cleared."
argument_list|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot clear metadata on disk %s (error=%d)."
argument_list|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|g_raid3_fill_metadata
parameter_list|(
name|struct
name|g_raid3_disk
modifier|*
name|disk
parameter_list|,
name|struct
name|g_raid3_metadata
modifier|*
name|md
parameter_list|)
block|{
name|struct
name|g_raid3_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|strlcpy
argument_list|(
name|md
operator|->
name|md_magic
argument_list|,
name|G_RAID3_MAGIC
argument_list|,
sizeof|sizeof
argument_list|(
name|md
operator|->
name|md_magic
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|->
name|md_version
operator|=
name|G_RAID3_VERSION
expr_stmt|;
name|strlcpy
argument_list|(
name|md
operator|->
name|md_name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
sizeof|sizeof
argument_list|(
name|md
operator|->
name|md_name
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|->
name|md_id
operator|=
name|sc
operator|->
name|sc_id
expr_stmt|;
name|md
operator|->
name|md_all
operator|=
name|sc
operator|->
name|sc_ndisks
expr_stmt|;
name|md
operator|->
name|md_mediasize
operator|=
name|sc
operator|->
name|sc_mediasize
expr_stmt|;
name|md
operator|->
name|md_sectorsize
operator|=
name|sc
operator|->
name|sc_sectorsize
expr_stmt|;
name|md
operator|->
name|md_mflags
operator|=
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_RAID3_DEVICE_FLAG_MASK
operator|)
expr_stmt|;
name|md
operator|->
name|md_no
operator|=
name|disk
operator|->
name|d_no
expr_stmt|;
name|md
operator|->
name|md_syncid
operator|=
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
expr_stmt|;
name|md
operator|->
name|md_dflags
operator|=
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_RAID3_DISK_FLAG_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_SYNCHRONIZING
condition|)
name|md
operator|->
name|md_sync_offset
operator|=
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset_done
expr_stmt|;
else|else
name|md
operator|->
name|md_sync_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_RAID3_DISK_FLAG_HARDCODED
operator|)
operator|!=
literal|0
operator|&&
name|disk
operator|->
name|d_consumer
operator|!=
name|NULL
operator|&&
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|!=
name|NULL
condition|)
block|{
name|strlcpy
argument_list|(
name|md
operator|->
name|md_provider
argument_list|,
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|md
operator|->
name|md_provider
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|md
operator|->
name|md_provider
argument_list|,
sizeof|sizeof
argument_list|(
name|md
operator|->
name|md_provider
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|g_raid3_update_metadata
parameter_list|(
name|struct
name|g_raid3_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_raid3_metadata
name|md
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|g_raid3_fill_metadata
argument_list|(
name|disk
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_raid3_write_metadata
argument_list|(
name|disk
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Metadata on %s updated."
argument_list|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot update metadata on disk %s (error=%d)."
argument_list|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_bump_syncid
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|,
name|int
name|waitidle
parameter_list|)
block|{
name|struct
name|g_raid3_disk
modifier|*
name|disk
decl_stmt|;
name|u_int
name|n
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|g_raid3_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID3_DISK_STATE_ACTIVE
argument_list|)
operator|>
literal|0
argument_list|,
operator|(
literal|"%s called with no active disks (device=%s)."
operator|,
name|__func__
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_syncid
operator|++
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|sc
operator|->
name|sc_ndisks
condition|;
name|n
operator|++
control|)
block|{
name|disk
operator|=
operator|&
name|sc
operator|->
name|sc_disks
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_ACTIVE
operator|||
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_SYNCHRONIZING
condition|)
block|{
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|=
name|sc
operator|->
name|sc_syncid
expr_stmt|;
if|if
condition|(
name|waitidle
condition|)
name|g_waitidlelock
argument_list|()
expr_stmt|;
name|g_raid3_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_idle
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_raid3_disk
modifier|*
name|disk
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_provider
operator|==
name|NULL
operator|||
name|sc
operator|->
name|sc_provider
operator|->
name|acw
operator|==
literal|0
condition|)
return|return;
name|sc
operator|->
name|sc_idle
operator|=
literal|1
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_ndisks
condition|;
name|i
operator|++
control|)
block|{
name|disk
operator|=
operator|&
name|sc
operator|->
name|sc_disks
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_RAID3_DISK_STATE_ACTIVE
condition|)
continue|continue;
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Disk %s (device %s) marked as clean."
argument_list|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_RAID3_DISK_FLAG_DIRTY
expr_stmt|;
name|g_raid3_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
name|g_topology_unlock
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_unidle
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_raid3_disk
modifier|*
name|disk
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|sc
operator|->
name|sc_idle
operator|=
literal|0
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_ndisks
condition|;
name|i
operator|++
control|)
block|{
name|disk
operator|=
operator|&
name|sc
operator|->
name|sc_disks
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_RAID3_DISK_STATE_ACTIVE
condition|)
continue|continue;
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Disk %s (device %s) marked as dirty."
argument_list|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_flags
operator||=
name|G_RAID3_DISK_FLAG_DIRTY
expr_stmt|;
name|g_raid3_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
name|g_topology_unlock
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*        * Return 1 if we should check if RAID3 device is idling.  */
end_comment

begin_function
specifier|static
name|int
name|g_raid3_check_idle
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_raid3_disk
modifier|*
name|disk
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_idle
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_provider
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|sc_provider
operator|->
name|acw
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  	 * Check if there are no in-flight requests. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_ndisks
condition|;
name|i
operator|++
control|)
block|{
name|disk
operator|=
operator|&
name|sc
operator|->
name|sc_disks
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_RAID3_DISK_STATE_ACTIVE
condition|)
continue|continue;
if|if
condition|(
name|disk
operator|->
name|d_consumer
operator|->
name|index
operator|>
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Treat bio_driver1 field in parent bio as list head and field bio_caller1  * in child bio as pointer to the next element on the list.  */
end_comment

begin_define
define|#
directive|define
name|G_RAID3_HEAD_BIO
parameter_list|(
name|pbp
parameter_list|)
value|(pbp)->bio_driver1
end_define

begin_define
define|#
directive|define
name|G_RAID3_NEXT_BIO
parameter_list|(
name|cbp
parameter_list|)
value|(cbp)->bio_caller1
end_define

begin_define
define|#
directive|define
name|G_RAID3_FOREACH_BIO
parameter_list|(
name|pbp
parameter_list|,
name|bp
parameter_list|)
define|\
value|for ((bp) = G_RAID3_HEAD_BIO(pbp); (bp) != NULL;		\ 	    (bp) = G_RAID3_NEXT_BIO(bp))
end_define

begin_define
define|#
directive|define
name|G_RAID3_FOREACH_SAFE_BIO
parameter_list|(
name|pbp
parameter_list|,
name|bp
parameter_list|,
name|tmpbp
parameter_list|)
define|\
value|for ((bp) = G_RAID3_HEAD_BIO(pbp);				\ 	    (bp) != NULL&& ((tmpbp) = G_RAID3_NEXT_BIO(bp), 1);	\ 	    (bp) = (tmpbp))
end_define

begin_function
specifier|static
name|void
name|g_raid3_init_bio
parameter_list|(
name|struct
name|bio
modifier|*
name|pbp
parameter_list|)
block|{
name|G_RAID3_HEAD_BIO
argument_list|(
name|pbp
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_remove_bio
parameter_list|(
name|struct
name|bio
modifier|*
name|cbp
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|pbp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|pbp
operator|=
name|cbp
operator|->
name|bio_parent
expr_stmt|;
if|if
condition|(
name|G_RAID3_HEAD_BIO
argument_list|(
name|pbp
argument_list|)
operator|==
name|cbp
condition|)
name|G_RAID3_HEAD_BIO
argument_list|(
name|pbp
argument_list|)
operator|=
name|G_RAID3_NEXT_BIO
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
else|else
block|{
name|G_RAID3_FOREACH_BIO
argument_list|(
argument|pbp
argument_list|,
argument|bp
argument_list|)
block|{
if|if
condition|(
name|G_RAID3_NEXT_BIO
argument_list|(
name|bp
argument_list|)
operator|==
name|cbp
condition|)
block|{
name|G_RAID3_NEXT_BIO
argument_list|(
name|bp
argument_list|)
operator|=
name|G_RAID3_NEXT_BIO
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|G_RAID3_NEXT_BIO
argument_list|(
name|cbp
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_replace_bio
parameter_list|(
name|struct
name|bio
modifier|*
name|sbp
parameter_list|,
name|struct
name|bio
modifier|*
name|dbp
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|pbp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|g_raid3_remove_bio
argument_list|(
name|sbp
argument_list|)
expr_stmt|;
name|pbp
operator|=
name|dbp
operator|->
name|bio_parent
expr_stmt|;
name|G_RAID3_NEXT_BIO
argument_list|(
name|sbp
argument_list|)
operator|=
name|G_RAID3_NEXT_BIO
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|G_RAID3_HEAD_BIO
argument_list|(
name|pbp
argument_list|)
operator|==
name|dbp
condition|)
name|G_RAID3_HEAD_BIO
argument_list|(
name|pbp
argument_list|)
operator|=
name|sbp
expr_stmt|;
else|else
block|{
name|G_RAID3_FOREACH_BIO
argument_list|(
argument|pbp
argument_list|,
argument|bp
argument_list|)
block|{
if|if
condition|(
name|G_RAID3_NEXT_BIO
argument_list|(
name|bp
argument_list|)
operator|==
name|dbp
condition|)
block|{
name|G_RAID3_NEXT_BIO
argument_list|(
name|bp
argument_list|)
operator|=
name|sbp
expr_stmt|;
break|break;
block|}
block|}
block|}
name|G_RAID3_NEXT_BIO
argument_list|(
name|dbp
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_destroy_bio
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|cbp
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|,
modifier|*
name|pbp
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|pbp
operator|=
name|cbp
operator|->
name|bio_parent
expr_stmt|;
name|pbp
operator|->
name|bio_children
operator|--
expr_stmt|;
name|KASSERT
argument_list|(
name|cbp
operator|->
name|bio_data
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL bio_data"
operator|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|pbp
operator|->
name|bio_length
operator|/
operator|(
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|16384
condition|)
name|uma_zfree
argument_list|(
name|sc
operator|->
name|sc_zone_64k
argument_list|,
name|cbp
operator|->
name|bio_data
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|>
literal|4096
condition|)
name|uma_zfree
argument_list|(
name|sc
operator|->
name|sc_zone_16k
argument_list|,
name|cbp
operator|->
name|bio_data
argument_list|)
expr_stmt|;
else|else
name|uma_zfree
argument_list|(
name|sc
operator|->
name|sc_zone_4k
argument_list|,
name|cbp
operator|->
name|bio_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|G_RAID3_HEAD_BIO
argument_list|(
name|pbp
argument_list|)
operator|==
name|cbp
condition|)
block|{
name|G_RAID3_HEAD_BIO
argument_list|(
name|pbp
argument_list|)
operator|=
name|G_RAID3_NEXT_BIO
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
name|G_RAID3_NEXT_BIO
argument_list|(
name|cbp
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|G_RAID3_FOREACH_BIO
argument_list|(
argument|pbp
argument_list|,
argument|bp
argument_list|)
block|{
if|if
condition|(
name|G_RAID3_NEXT_BIO
argument_list|(
name|bp
argument_list|)
operator|==
name|cbp
condition|)
break|break;
block|}
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|G_RAID3_NEXT_BIO
argument_list|(
name|bp
argument_list|)
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL bp->bio_driver1"
operator|)
argument_list|)
expr_stmt|;
name|G_RAID3_NEXT_BIO
argument_list|(
name|bp
argument_list|)
operator|=
name|G_RAID3_NEXT_BIO
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
name|G_RAID3_NEXT_BIO
argument_list|(
name|cbp
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
name|g_destroy_bio
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|bio
modifier|*
name|g_raid3_clone_bio
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|pbp
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cbp
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|cbp
operator|=
name|g_clone_bio
argument_list|(
name|pbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|size
operator|=
name|pbp
operator|->
name|bio_length
operator|/
operator|(
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|16384
condition|)
block|{
name|cbp
operator|->
name|bio_data
operator|=
name|uma_zalloc
argument_list|(
name|sc
operator|->
name|sc_zone_64k
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|g_raid3_64k_requested
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|>
literal|4096
condition|)
block|{
name|cbp
operator|->
name|bio_data
operator|=
name|uma_zalloc
argument_list|(
name|sc
operator|->
name|sc_zone_16k
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|g_raid3_16k_requested
operator|++
expr_stmt|;
block|}
else|else
block|{
name|cbp
operator|->
name|bio_data
operator|=
name|uma_zalloc
argument_list|(
name|sc
operator|->
name|sc_zone_4k
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|g_raid3_4k_requested
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cbp
operator|->
name|bio_data
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|size
operator|>
literal|16384
condition|)
name|g_raid3_64k_failed
operator|++
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|4096
condition|)
name|g_raid3_16k_failed
operator|++
expr_stmt|;
else|else
name|g_raid3_4k_failed
operator|++
expr_stmt|;
name|pbp
operator|->
name|bio_children
operator|--
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|G_RAID3_NEXT_BIO
argument_list|(
name|cbp
argument_list|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|G_RAID3_HEAD_BIO
argument_list|(
name|pbp
argument_list|)
operator|==
name|NULL
condition|)
name|G_RAID3_HEAD_BIO
argument_list|(
name|pbp
argument_list|)
operator|=
name|cbp
expr_stmt|;
else|else
block|{
name|G_RAID3_FOREACH_BIO
argument_list|(
argument|pbp
argument_list|,
argument|bp
argument_list|)
block|{
if|if
condition|(
name|G_RAID3_NEXT_BIO
argument_list|(
name|bp
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|G_RAID3_NEXT_BIO
argument_list|(
name|bp
argument_list|)
operator|=
name|cbp
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
operator|(
name|cbp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_scatter
parameter_list|(
name|struct
name|bio
modifier|*
name|pbp
parameter_list|)
block|{
name|struct
name|g_raid3_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid3_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cbp
decl_stmt|;
name|off_t
name|atom
decl_stmt|,
name|cadd
decl_stmt|,
name|padd
decl_stmt|,
name|left
decl_stmt|;
name|sc
operator|=
name|pbp
operator|->
name|bio_to
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|pbp
operator|->
name|bio_pflags
operator|&
name|G_RAID3_BIO_PFLAG_NOPARITY
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Find bio for which we should calculate data. 		 */
name|G_RAID3_FOREACH_BIO
argument_list|(
argument|pbp
argument_list|,
argument|cbp
argument_list|)
block|{
if|if
condition|(
operator|(
name|cbp
operator|->
name|bio_cflags
operator|&
name|G_RAID3_BIO_CFLAG_PARITY
operator|)
operator|!=
literal|0
condition|)
block|{
name|bp
operator|=
name|cbp
expr_stmt|;
break|break;
block|}
block|}
name|KASSERT
argument_list|(
name|bp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL parity bio."
operator|)
argument_list|)
expr_stmt|;
block|}
name|atom
operator|=
name|sc
operator|->
name|sc_sectorsize
operator|/
operator|(
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
operator|)
expr_stmt|;
name|cadd
operator|=
name|padd
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|left
operator|=
name|pbp
operator|->
name|bio_length
init|;
name|left
operator|>
literal|0
condition|;
name|left
operator|-=
name|sc
operator|->
name|sc_sectorsize
control|)
block|{
name|G_RAID3_FOREACH_BIO
argument_list|(
argument|pbp
argument_list|,
argument|cbp
argument_list|)
block|{
if|if
condition|(
name|cbp
operator|==
name|bp
condition|)
continue|continue;
name|bcopy
argument_list|(
name|pbp
operator|->
name|bio_data
operator|+
name|padd
argument_list|,
name|cbp
operator|->
name|bio_data
operator|+
name|cadd
argument_list|,
name|atom
argument_list|)
expr_stmt|;
name|padd
operator|+=
name|atom
expr_stmt|;
block|}
name|cadd
operator|+=
name|atom
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pbp
operator|->
name|bio_pflags
operator|&
name|G_RAID3_BIO_PFLAG_NOPARITY
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|bio
modifier|*
name|tmpbp
decl_stmt|;
comment|/* 		 * Calculate parity. 		 */
name|bzero
argument_list|(
name|bp
operator|->
name|bio_data
argument_list|,
name|bp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
name|G_RAID3_FOREACH_SAFE_BIO
argument_list|(
argument|pbp
argument_list|,
argument|cbp
argument_list|,
argument|tmpbp
argument_list|)
block|{
if|if
condition|(
name|cbp
operator|==
name|bp
condition|)
continue|continue;
name|g_raid3_xor
argument_list|(
name|cbp
operator|->
name|bio_data
argument_list|,
name|bp
operator|->
name|bio_data
argument_list|,
name|bp
operator|->
name|bio_data
argument_list|,
name|bp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cbp
operator|->
name|bio_cflags
operator|&
name|G_RAID3_BIO_CFLAG_NODISK
operator|)
operator|!=
literal|0
condition|)
name|g_raid3_destroy_bio
argument_list|(
name|sc
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
block|}
block|}
name|G_RAID3_FOREACH_BIO
argument_list|(
argument|pbp
argument_list|,
argument|cbp
argument_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|disk
operator|=
name|cbp
operator|->
name|bio_caller2
expr_stmt|;
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|cbp
operator|->
name|bio_to
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|G_RAID3_LOGREQ
argument_list|(
literal|3
argument_list|,
name|cbp
argument_list|,
literal|"Sending request."
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|cbp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
block|{
name|KASSERT
argument_list|(
name|cp
operator|->
name|acr
operator|>
literal|0
operator|&&
name|cp
operator|->
name|ace
operator|>
literal|0
argument_list|,
operator|(
literal|"Consumer %s not opened (r%dw%de%d)."
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|,
name|cp
operator|->
name|acr
operator|,
name|cp
operator|->
name|acw
operator|,
name|cp
operator|->
name|ace
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cbp
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
condition|)
block|{
name|KASSERT
argument_list|(
name|cp
operator|->
name|acw
operator|>
literal|0
operator|&&
name|cp
operator|->
name|ace
operator|>
literal|0
argument_list|,
operator|(
literal|"Consumer %s not opened (r%dw%de%d)."
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|,
name|cp
operator|->
name|acr
operator|,
name|cp
operator|->
name|acw
operator|,
name|cp
operator|->
name|ace
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|cp
operator|->
name|index
operator|++
expr_stmt|;
name|g_io_request
argument_list|(
name|cbp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_gather
parameter_list|(
name|struct
name|bio
modifier|*
name|pbp
parameter_list|)
block|{
name|struct
name|g_raid3_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid3_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|bio
modifier|*
name|xbp
decl_stmt|,
modifier|*
name|fbp
decl_stmt|,
modifier|*
name|cbp
decl_stmt|;
name|off_t
name|atom
decl_stmt|,
name|cadd
decl_stmt|,
name|padd
decl_stmt|,
name|left
decl_stmt|;
name|sc
operator|=
name|pbp
operator|->
name|bio_to
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
comment|/* 	 * Find bio for which we have to calculate data. 	 * While going through this path, check if all requests 	 * succeeded, if not, deny whole request. 	 * If we're in COMPLETE mode, we allow one request to fail, 	 * so if we find one, we're sending it to the parity consumer. 	 * If there are more failed requests, we deny whole request. 	 */
name|xbp
operator|=
name|fbp
operator|=
name|NULL
expr_stmt|;
name|G_RAID3_FOREACH_BIO
argument_list|(
argument|pbp
argument_list|,
argument|cbp
argument_list|)
block|{
if|if
condition|(
operator|(
name|cbp
operator|->
name|bio_cflags
operator|&
name|G_RAID3_BIO_CFLAG_PARITY
operator|)
operator|!=
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|xbp
operator|==
name|NULL
argument_list|,
operator|(
literal|"More than one parity bio."
operator|)
argument_list|)
expr_stmt|;
name|xbp
operator|=
name|cbp
expr_stmt|;
block|}
if|if
condition|(
name|cbp
operator|->
name|bio_error
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Found failed request. 		 */
name|G_RAID3_LOGREQ
argument_list|(
literal|0
argument_list|,
name|cbp
argument_list|,
literal|"Request failed."
argument_list|)
expr_stmt|;
name|disk
operator|=
name|cbp
operator|->
name|bio_caller2
expr_stmt|;
if|if
condition|(
name|disk
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Actually this is pointless to bump syncid, 			 * because whole device is fucked up. 			 */
name|sc
operator|->
name|sc_bump_syncid
operator|=
name|G_RAID3_BUMP_IMMEDIATELY
expr_stmt|;
name|g_raid3_event_send
argument_list|(
name|disk
argument_list|,
name|G_RAID3_DISK_STATE_DISCONNECTED
argument_list|,
name|G_RAID3_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fbp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|pbp
operator|->
name|bio_pflags
operator|&
name|G_RAID3_BIO_PFLAG_DEGRADED
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * We are already in degraded mode, so we can't 				 * accept any failures. 				 */
if|if
condition|(
name|pbp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|pbp
operator|->
name|bio_error
operator|=
name|fbp
operator|->
name|bio_error
expr_stmt|;
block|}
else|else
block|{
name|fbp
operator|=
name|cbp
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Next failed request, that's too many. 			 */
if|if
condition|(
name|pbp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|pbp
operator|->
name|bio_error
operator|=
name|fbp
operator|->
name|bio_error
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pbp
operator|->
name|bio_error
operator|!=
literal|0
condition|)
goto|goto
name|finish
goto|;
if|if
condition|(
name|fbp
operator|!=
name|NULL
operator|&&
operator|(
name|pbp
operator|->
name|bio_pflags
operator|&
name|G_RAID3_BIO_PFLAG_VERIFY
operator|)
operator|!=
literal|0
condition|)
block|{
name|pbp
operator|->
name|bio_pflags
operator|&=
operator|~
name|G_RAID3_BIO_PFLAG_VERIFY
expr_stmt|;
if|if
condition|(
name|xbp
operator|!=
name|fbp
condition|)
name|g_raid3_replace_bio
argument_list|(
name|xbp
argument_list|,
name|fbp
argument_list|)
expr_stmt|;
name|g_raid3_destroy_bio
argument_list|(
name|sc
argument_list|,
name|fbp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fbp
operator|!=
name|NULL
condition|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
comment|/* 		 * One request failed, so send the same request to 		 * the parity consumer. 		 */
name|disk
operator|=
name|pbp
operator|->
name|bio_driver2
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_RAID3_DISK_STATE_ACTIVE
condition|)
block|{
name|pbp
operator|->
name|bio_error
operator|=
name|fbp
operator|->
name|bio_error
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
name|pbp
operator|->
name|bio_pflags
operator||=
name|G_RAID3_BIO_PFLAG_DEGRADED
expr_stmt|;
name|pbp
operator|->
name|bio_inbed
operator|--
expr_stmt|;
name|fbp
operator|->
name|bio_flags
operator|&=
operator|~
operator|(
name|BIO_DONE
operator||
name|BIO_ERROR
operator|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_no
operator|==
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
condition|)
name|fbp
operator|->
name|bio_cflags
operator||=
name|G_RAID3_BIO_CFLAG_PARITY
expr_stmt|;
name|fbp
operator|->
name|bio_error
operator|=
literal|0
expr_stmt|;
name|fbp
operator|->
name|bio_completed
operator|=
literal|0
expr_stmt|;
name|fbp
operator|->
name|bio_children
operator|=
literal|0
expr_stmt|;
name|fbp
operator|->
name|bio_inbed
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|fbp
operator|->
name|bio_caller2
operator|=
name|disk
expr_stmt|;
name|fbp
operator|->
name|bio_to
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|G_RAID3_LOGREQ
argument_list|(
literal|3
argument_list|,
name|fbp
argument_list|,
literal|"Sending request (recover)."
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|->
name|acr
operator|>
literal|0
operator|&&
name|cp
operator|->
name|ace
operator|>
literal|0
argument_list|,
operator|(
literal|"Consumer %s not opened (r%dw%de%d)."
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|,
name|cp
operator|->
name|acr
operator|,
name|cp
operator|->
name|acw
operator|,
name|cp
operator|->
name|ace
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|index
operator|++
expr_stmt|;
name|g_io_request
argument_list|(
name|fbp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|xbp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Calculate parity. 		 */
name|G_RAID3_FOREACH_BIO
argument_list|(
argument|pbp
argument_list|,
argument|cbp
argument_list|)
block|{
if|if
condition|(
operator|(
name|cbp
operator|->
name|bio_cflags
operator|&
name|G_RAID3_BIO_CFLAG_PARITY
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|g_raid3_xor
argument_list|(
name|cbp
operator|->
name|bio_data
argument_list|,
name|xbp
operator|->
name|bio_data
argument_list|,
name|xbp
operator|->
name|bio_data
argument_list|,
name|xbp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
block|}
name|xbp
operator|->
name|bio_cflags
operator|&=
operator|~
name|G_RAID3_BIO_CFLAG_PARITY
expr_stmt|;
if|if
condition|(
operator|(
name|pbp
operator|->
name|bio_pflags
operator|&
name|G_RAID3_BIO_PFLAG_VERIFY
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|g_raid3_is_zero
argument_list|(
name|xbp
argument_list|)
condition|)
block|{
name|g_raid3_parity_mismatch
operator|++
expr_stmt|;
name|pbp
operator|->
name|bio_error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|finish
goto|;
block|}
name|g_raid3_destroy_bio
argument_list|(
name|sc
argument_list|,
name|xbp
argument_list|)
expr_stmt|;
block|}
block|}
name|atom
operator|=
name|sc
operator|->
name|sc_sectorsize
operator|/
operator|(
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
operator|)
expr_stmt|;
name|cadd
operator|=
name|padd
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|left
operator|=
name|pbp
operator|->
name|bio_length
init|;
name|left
operator|>
literal|0
condition|;
name|left
operator|-=
name|sc
operator|->
name|sc_sectorsize
control|)
block|{
name|G_RAID3_FOREACH_BIO
argument_list|(
argument|pbp
argument_list|,
argument|cbp
argument_list|)
block|{
name|bcopy
argument_list|(
name|cbp
operator|->
name|bio_data
operator|+
name|cadd
argument_list|,
name|pbp
operator|->
name|bio_data
operator|+
name|padd
argument_list|,
name|atom
argument_list|)
expr_stmt|;
name|pbp
operator|->
name|bio_completed
operator|+=
name|atom
expr_stmt|;
name|padd
operator|+=
name|atom
expr_stmt|;
block|}
name|cadd
operator|+=
name|atom
expr_stmt|;
block|}
name|finish
label|:
if|if
condition|(
name|pbp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|G_RAID3_LOGREQ
argument_list|(
literal|3
argument_list|,
name|pbp
argument_list|,
literal|"Request finished."
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|pbp
operator|->
name|bio_pflags
operator|&
name|G_RAID3_BIO_PFLAG_VERIFY
operator|)
operator|!=
literal|0
condition|)
name|G_RAID3_LOGREQ
argument_list|(
literal|1
argument_list|,
name|pbp
argument_list|,
literal|"Verification error."
argument_list|)
expr_stmt|;
else|else
name|G_RAID3_LOGREQ
argument_list|(
literal|0
argument_list|,
name|pbp
argument_list|,
literal|"Request failed."
argument_list|)
expr_stmt|;
block|}
name|pbp
operator|->
name|bio_pflags
operator|&=
operator|~
name|G_RAID3_BIO_PFLAG_MASK
expr_stmt|;
name|g_io_deliver
argument_list|(
name|pbp
argument_list|,
name|pbp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cbp
operator|=
name|G_RAID3_HEAD_BIO
argument_list|(
name|pbp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|g_raid3_destroy_bio
argument_list|(
name|sc
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_raid3_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_from
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|bp
operator|->
name|bio_cflags
operator||=
name|G_RAID3_BIO_CFLAG_REGULAR
expr_stmt|;
name|G_RAID3_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Regular request done (error=%d)."
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|bioq_insert_head
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_regular_request
parameter_list|(
name|struct
name|bio
modifier|*
name|cbp
parameter_list|)
block|{
name|struct
name|g_raid3_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid3_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|bio
modifier|*
name|pbp
decl_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|cbp
operator|->
name|bio_from
operator|->
name|index
operator|--
expr_stmt|;
name|pbp
operator|=
name|cbp
operator|->
name|bio_parent
expr_stmt|;
name|sc
operator|=
name|pbp
operator|->
name|bio_to
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|disk
operator|=
name|cbp
operator|->
name|bio_from
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
block|{
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_raid3_kill_consumer
argument_list|(
name|sc
argument_list|,
name|cbp
operator|->
name|bio_from
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
block|}
name|G_RAID3_LOGREQ
argument_list|(
literal|3
argument_list|,
name|cbp
argument_list|,
literal|"Request finished."
argument_list|)
expr_stmt|;
name|pbp
operator|->
name|bio_inbed
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
name|pbp
operator|->
name|bio_inbed
operator|<=
name|pbp
operator|->
name|bio_children
argument_list|,
operator|(
literal|"bio_inbed (%u) is bigger than bio_children (%u)."
operator|,
name|pbp
operator|->
name|bio_inbed
operator|,
name|pbp
operator|->
name|bio_children
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbp
operator|->
name|bio_inbed
operator|!=
name|pbp
operator|->
name|bio_children
condition|)
return|return;
switch|switch
condition|(
name|pbp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
name|g_raid3_gather
argument_list|(
name|pbp
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_WRITE
case|:
case|case
name|BIO_DELETE
case|:
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|pbp
operator|->
name|bio_completed
operator|=
name|pbp
operator|->
name|bio_length
expr_stmt|;
while|while
condition|(
operator|(
name|cbp
operator|=
name|G_RAID3_HEAD_BIO
argument_list|(
name|pbp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cbp
operator|->
name|bio_error
operator|!=
literal|0
condition|)
block|{
name|disk
operator|=
name|cbp
operator|->
name|bio_caller2
expr_stmt|;
if|if
condition|(
name|disk
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_bump_syncid
operator|=
name|G_RAID3_BUMP_IMMEDIATELY
expr_stmt|;
name|g_raid3_event_send
argument_list|(
name|disk
argument_list|,
name|G_RAID3_DISK_STATE_DISCONNECTED
argument_list|,
name|G_RAID3_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|cbp
operator|->
name|bio_error
expr_stmt|;
elseif|else
if|if
condition|(
name|pbp
operator|->
name|bio_error
operator|==
literal|0
condition|)
block|{
comment|/* 					 * Next failed request, that's too many. 					 */
name|pbp
operator|->
name|bio_error
operator|=
name|error
expr_stmt|;
block|}
block|}
name|g_raid3_destroy_bio
argument_list|(
name|sc
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pbp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|G_RAID3_LOGREQ
argument_list|(
literal|3
argument_list|,
name|pbp
argument_list|,
literal|"Request finished."
argument_list|)
expr_stmt|;
else|else
name|G_RAID3_LOGREQ
argument_list|(
literal|0
argument_list|,
name|pbp
argument_list|,
literal|"Request failed."
argument_list|)
expr_stmt|;
name|pbp
operator|->
name|bio_pflags
operator|&=
operator|~
name|G_RAID3_BIO_PFLAG_DEGRADED
expr_stmt|;
name|pbp
operator|->
name|bio_pflags
operator|&=
operator|~
name|G_RAID3_BIO_PFLAG_NOPARITY
expr_stmt|;
name|g_io_deliver
argument_list|(
name|pbp
argument_list|,
name|pbp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_sync_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_raid3_softc
modifier|*
name|sc
decl_stmt|;
name|G_RAID3_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Synchronization request delivered."
argument_list|)
expr_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_from
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|bp
operator|->
name|bio_cflags
operator||=
name|G_RAID3_BIO_CFLAG_SYNC
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|bioq_insert_head
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_start
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_raid3_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
comment|/* 	 * If sc == NULL or there are no valid disks, provider's error 	 * should be set and g_raid3_start() should not be called at all. 	 */
name|KASSERT
argument_list|(
name|sc
operator|!=
name|NULL
operator|&&
operator|(
name|sc
operator|->
name|sc_state
operator|==
name|G_RAID3_DEVICE_STATE_DEGRADED
operator|||
name|sc
operator|->
name|sc_state
operator|==
name|G_RAID3_DEVICE_STATE_COMPLETE
operator|)
argument_list|,
operator|(
literal|"Provider's error should be set (error=%d)(device=%s)."
operator|,
name|bp
operator|->
name|bio_to
operator|->
name|error
operator|,
name|bp
operator|->
name|bio_to
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|G_RAID3_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Request received."
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
case|case
name|BIO_WRITE
case|:
case|case
name|BIO_DELETE
case|:
break|break;
case|case
name|BIO_GETATTR
case|:
default|default:
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
return|return;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Waking up %p."
argument_list|,
name|__func__
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send one synchronization request.  */
end_comment

begin_function
specifier|static
name|void
name|g_raid3_sync_one
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_raid3_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_state
operator|==
name|G_RAID3_DEVICE_STATE_DEGRADED
argument_list|,
operator|(
literal|"Wrong device state (%s, %s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_raid3_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|disk
operator|=
name|sc
operator|->
name|sc_syncdisk
expr_stmt|;
name|KASSERT
argument_list|(
name|disk
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No sync disk (%s)."
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_SYNCHRONIZING
argument_list|,
operator|(
literal|"Disk %s is not marked for synchronization."
operator|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|bp
operator|=
name|g_new_bio
argument_list|()
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
return|return;
name|bp
operator|->
name|bio_parent
operator|=
name|NULL
expr_stmt|;
name|bp
operator|->
name|bio_cmd
operator|=
name|BIO_READ
expr_stmt|;
name|bp
operator|->
name|bio_offset
operator|=
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset
operator|*
operator|(
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
operator|)
expr_stmt|;
name|bp
operator|->
name|bio_length
operator|=
name|MIN
argument_list|(
name|MAXPHYS
argument_list|,
name|sc
operator|->
name|sc_mediasize
operator|-
name|bp
operator|->
name|bio_offset
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_cflags
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bio_done
operator|=
name|g_raid3_sync_done
expr_stmt|;
name|bp
operator|->
name|bio_data
operator|=
name|disk
operator|->
name|d_sync
operator|.
name|ds_data
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_data
operator|==
name|NULL
condition|)
block|{
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|->
name|bio_cflags
operator|=
name|G_RAID3_BIO_CFLAG_REGSYNC
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset
operator|+=
name|bp
operator|->
name|bio_length
operator|/
operator|(
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
operator|)
expr_stmt|;
name|bp
operator|->
name|bio_to
operator|=
name|sc
operator|->
name|sc_provider
expr_stmt|;
name|G_RAID3_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Sending synchronization request."
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|->
name|index
operator|++
expr_stmt|;
name|g_io_request
argument_list|(
name|bp
argument_list|,
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_sync_request
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_raid3_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid3_disk
modifier|*
name|disk
decl_stmt|;
name|bp
operator|->
name|bio_from
operator|->
name|index
operator|--
expr_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_from
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|disk
operator|=
name|bp
operator|->
name|bio_from
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
block|{
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_raid3_kill_consumer
argument_list|(
name|sc
argument_list|,
name|bp
operator|->
name|bio_from
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Synchronization request. 	 */
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|u_char
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
decl_stmt|;
name|off_t
name|left
decl_stmt|;
name|u_int
name|atom
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|!=
literal|0
condition|)
block|{
name|G_RAID3_LOGREQ
argument_list|(
literal|0
argument_list|,
name|bp
argument_list|,
literal|"Synchronization request failed (error=%d)."
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|G_RAID3_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Synchronization request finished."
argument_list|)
expr_stmt|;
name|atom
operator|=
name|sc
operator|->
name|sc_sectorsize
operator|/
operator|(
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
operator|)
expr_stmt|;
name|dst
operator|=
name|src
operator|=
name|bp
operator|->
name|bio_data
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_no
operator|==
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
condition|)
block|{
name|u_int
name|n
decl_stmt|;
comment|/* Parity component. */
for|for
control|(
name|left
operator|=
name|bp
operator|->
name|bio_length
init|;
name|left
operator|>
literal|0
condition|;
name|left
operator|-=
name|sc
operator|->
name|sc_sectorsize
control|)
block|{
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|atom
argument_list|)
expr_stmt|;
name|src
operator|+=
name|atom
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
condition|;
name|n
operator|++
control|)
block|{
name|g_raid3_xor
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|dst
argument_list|,
name|atom
argument_list|)
expr_stmt|;
name|src
operator|+=
name|atom
expr_stmt|;
block|}
name|dst
operator|+=
name|atom
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Regular component. */
name|src
operator|+=
name|atom
operator|*
name|disk
operator|->
name|d_no
expr_stmt|;
for|for
control|(
name|left
operator|=
name|bp
operator|->
name|bio_length
init|;
name|left
operator|>
literal|0
condition|;
name|left
operator|-=
name|sc
operator|->
name|sc_sectorsize
control|)
block|{
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|atom
argument_list|)
expr_stmt|;
name|src
operator|+=
name|sc
operator|->
name|sc_sectorsize
expr_stmt|;
name|dst
operator|+=
name|atom
expr_stmt|;
block|}
block|}
name|bp
operator|->
name|bio_offset
operator|/=
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
expr_stmt|;
name|bp
operator|->
name|bio_length
operator|/=
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
expr_stmt|;
name|bp
operator|->
name|bio_cmd
operator|=
name|BIO_WRITE
expr_stmt|;
name|bp
operator|->
name|bio_cflags
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bio_children
operator|=
name|bp
operator|->
name|bio_inbed
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|->
name|acr
operator|==
literal|0
operator|&&
name|cp
operator|->
name|acw
operator|==
literal|1
operator|&&
name|cp
operator|->
name|ace
operator|==
literal|1
argument_list|,
operator|(
literal|"Consumer %s not opened (r%dw%de%d)."
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|,
name|cp
operator|->
name|acr
operator|,
name|cp
operator|->
name|acw
operator|,
name|cp
operator|->
name|ace
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|index
operator|++
expr_stmt|;
name|g_io_request
argument_list|(
name|bp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|BIO_WRITE
case|:
block|{
name|struct
name|g_raid3_disk_sync
modifier|*
name|sync
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|!=
literal|0
condition|)
block|{
name|G_RAID3_LOGREQ
argument_list|(
literal|0
argument_list|,
name|bp
argument_list|,
literal|"Synchronization request failed (error=%d)."
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bump_syncid
operator|=
name|G_RAID3_BUMP_IMMEDIATELY
expr_stmt|;
name|g_raid3_event_send
argument_list|(
name|disk
argument_list|,
name|G_RAID3_DISK_STATE_DISCONNECTED
argument_list|,
name|G_RAID3_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
return|return;
block|}
name|G_RAID3_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Synchronization request finished."
argument_list|)
expr_stmt|;
name|sync
operator|=
operator|&
name|disk
operator|->
name|d_sync
expr_stmt|;
name|sync
operator|->
name|ds_offset_done
operator|=
name|bp
operator|->
name|bio_offset
operator|+
name|bp
operator|->
name|bio_length
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sync
operator|->
name|ds_resync
operator|!=
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|sync
operator|->
name|ds_offset_done
operator|==
name|sc
operator|->
name|sc_mediasize
operator|/
operator|(
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* 			 * Disk up-to-date, activate it. 			 */
name|g_raid3_event_send
argument_list|(
name|disk
argument_list|,
name|G_RAID3_DISK_STATE_ACTIVE
argument_list|,
name|G_RAID3_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|sync
operator|->
name|ds_offset_done
operator|%
operator|(
name|MAXPHYS
operator|*
literal|100
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Update offset_done on every 100 blocks. 			 * XXX: This should be configurable. 			 */
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_waitidlelock
argument_list|()
expr_stmt|;
name|g_raid3_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
default|default:
name|KASSERT
argument_list|(
literal|1
operator|==
literal|0
argument_list|,
operator|(
literal|"Invalid command here: %u (device=%s)"
operator|,
name|bp
operator|->
name|bio_cmd
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid3_register_request
parameter_list|(
name|struct
name|bio
modifier|*
name|pbp
parameter_list|)
block|{
name|struct
name|g_raid3_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid3_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|bio
modifier|*
name|cbp
decl_stmt|;
name|off_t
name|offset
decl_stmt|,
name|length
decl_stmt|;
name|u_int
name|n
decl_stmt|,
name|ndisks
decl_stmt|;
name|int
name|round_robin
decl_stmt|,
name|verify
decl_stmt|;
name|ndisks
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|pbp
operator|->
name|bio_to
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
if|if
condition|(
operator|(
name|pbp
operator|->
name|bio_cflags
operator|&
name|G_RAID3_BIO_CFLAG_REGSYNC
operator|)
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|sc_syncdisk
operator|==
name|NULL
condition|)
block|{
name|g_io_deliver
argument_list|(
name|pbp
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|g_raid3_init_bio
argument_list|(
name|pbp
argument_list|)
expr_stmt|;
name|length
operator|=
name|pbp
operator|->
name|bio_length
operator|/
operator|(
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
operator|)
expr_stmt|;
name|offset
operator|=
name|pbp
operator|->
name|bio_offset
operator|/
operator|(
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
operator|)
expr_stmt|;
name|round_robin
operator|=
name|verify
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|pbp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_RAID3_DEVICE_FLAG_VERIFY
operator|)
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|sc_state
operator|==
name|G_RAID3_DEVICE_STATE_COMPLETE
condition|)
block|{
name|pbp
operator|->
name|bio_pflags
operator||=
name|G_RAID3_BIO_PFLAG_VERIFY
expr_stmt|;
name|verify
operator|=
literal|1
expr_stmt|;
name|ndisks
operator|=
name|sc
operator|->
name|sc_ndisks
expr_stmt|;
block|}
else|else
block|{
name|verify
operator|=
literal|0
expr_stmt|;
name|ndisks
operator|=
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_RAID3_DEVICE_FLAG_ROUND_ROBIN
operator|)
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|sc_state
operator|==
name|G_RAID3_DEVICE_STATE_COMPLETE
condition|)
block|{
name|round_robin
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|round_robin
operator|=
literal|0
expr_stmt|;
block|}
name|KASSERT
argument_list|(
operator|!
name|round_robin
operator|||
operator|!
name|verify
argument_list|,
operator|(
literal|"ROUND-ROBIN and VERIFY are mutually exclusive."
operator|)
argument_list|)
expr_stmt|;
name|pbp
operator|->
name|bio_driver2
operator|=
operator|&
name|sc
operator|->
name|sc_disks
index|[
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|BIO_WRITE
case|:
case|case
name|BIO_DELETE
case|:
block|{
name|struct
name|g_raid3_disk_sync
modifier|*
name|sync
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_idle
condition|)
name|g_raid3_unidle
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ndisks
operator|=
name|sc
operator|->
name|sc_ndisks
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_syncdisk
operator|==
name|NULL
condition|)
break|break;
name|sync
operator|=
operator|&
name|sc
operator|->
name|sc_syncdisk
operator|->
name|d_sync
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|sync
operator|->
name|ds_offset
condition|)
break|break;
if|if
condition|(
name|offset
operator|+
name|length
operator|<=
name|sync
operator|->
name|ds_offset_done
condition|)
break|break;
if|if
condition|(
name|offset
operator|>=
name|sync
operator|->
name|ds_resync
operator|&&
name|sync
operator|->
name|ds_resync
operator|!=
operator|-
literal|1
condition|)
break|break;
name|sync
operator|->
name|ds_resync
operator|=
name|offset
operator|-
operator|(
name|offset
operator|%
name|MAXPHYS
operator|)
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|ndisks
condition|;
name|n
operator|++
control|)
block|{
name|disk
operator|=
operator|&
name|sc
operator|->
name|sc_disks
index|[
name|n
index|]
expr_stmt|;
name|cbp
operator|=
name|g_raid3_clone_bio
argument_list|(
name|sc
argument_list|,
name|pbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|==
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|cbp
operator|=
name|G_RAID3_HEAD_BIO
argument_list|(
name|pbp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|g_raid3_destroy_bio
argument_list|(
name|sc
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|cbp
operator|->
name|bio_offset
operator|=
name|offset
expr_stmt|;
name|cbp
operator|->
name|bio_length
operator|=
name|length
expr_stmt|;
name|cbp
operator|->
name|bio_done
operator|=
name|g_raid3_done
expr_stmt|;
switch|switch
condition|(
name|pbp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_RAID3_DISK_STATE_ACTIVE
condition|)
block|{
comment|/* 				 * Replace invalid component with the parity 				 * component. 				 */
name|disk
operator|=
operator|&
name|sc
operator|->
name|sc_disks
index|[
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
index|]
expr_stmt|;
name|cbp
operator|->
name|bio_cflags
operator||=
name|G_RAID3_BIO_CFLAG_PARITY
expr_stmt|;
name|pbp
operator|->
name|bio_pflags
operator||=
name|G_RAID3_BIO_PFLAG_DEGRADED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|round_robin
operator|&&
name|disk
operator|->
name|d_no
operator|==
name|sc
operator|->
name|sc_round_robin
condition|)
block|{
comment|/* 				 * In round-robin mode skip one data component 				 * and use parity component when reading. 				 */
name|pbp
operator|->
name|bio_driver2
operator|=
name|disk
expr_stmt|;
name|disk
operator|=
operator|&
name|sc
operator|->
name|sc_disks
index|[
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
index|]
expr_stmt|;
name|cbp
operator|->
name|bio_cflags
operator||=
name|G_RAID3_BIO_CFLAG_PARITY
expr_stmt|;
name|sc
operator|->
name|sc_round_robin
operator|++
expr_stmt|;
name|round_robin
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|verify
operator|&&
name|disk
operator|->
name|d_no
operator|==
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
condition|)
block|{
name|cbp
operator|->
name|bio_cflags
operator||=
name|G_RAID3_BIO_CFLAG_PARITY
expr_stmt|;
block|}
break|break;
case|case
name|BIO_WRITE
case|:
case|case
name|BIO_DELETE
case|:
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_ACTIVE
operator|||
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_SYNCHRONIZING
condition|)
block|{
if|if
condition|(
name|n
operator|==
name|ndisks
operator|-
literal|1
condition|)
block|{
comment|/* 					 * Active parity component, mark it as such. 					 */
name|cbp
operator|->
name|bio_cflags
operator||=
name|G_RAID3_BIO_CFLAG_PARITY
expr_stmt|;
block|}
block|}
else|else
block|{
name|pbp
operator|->
name|bio_pflags
operator||=
name|G_RAID3_BIO_PFLAG_DEGRADED
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|ndisks
operator|-
literal|1
condition|)
block|{
comment|/* 					 * Parity component is not connected, 					 * so destroy its request. 					 */
name|pbp
operator|->
name|bio_pflags
operator||=
name|G_RAID3_BIO_PFLAG_NOPARITY
expr_stmt|;
name|g_raid3_destroy_bio
argument_list|(
name|sc
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
name|cbp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|cbp
operator|->
name|bio_cflags
operator||=
name|G_RAID3_BIO_CFLAG_NODISK
expr_stmt|;
name|disk
operator|=
name|NULL
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|cbp
operator|!=
name|NULL
condition|)
name|cbp
operator|->
name|bio_caller2
operator|=
name|disk
expr_stmt|;
block|}
switch|switch
condition|(
name|pbp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
if|if
condition|(
name|round_robin
condition|)
block|{
comment|/* 			 * If we are in round-robin mode and 'round_robin' is 			 * still 1, it means, that we skipped parity component 			 * for this read and must reset sc_round_robin field. 			 */
name|sc
operator|->
name|sc_round_robin
operator|=
literal|0
expr_stmt|;
block|}
name|G_RAID3_FOREACH_BIO
argument_list|(
argument|pbp
argument_list|,
argument|cbp
argument_list|)
block|{
name|disk
operator|=
name|cbp
operator|->
name|bio_caller2
expr_stmt|;
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|cbp
operator|->
name|bio_to
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|G_RAID3_LOGREQ
argument_list|(
literal|3
argument_list|,
name|cbp
argument_list|,
literal|"Sending request."
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|->
name|acr
operator|>
literal|0
operator|&&
name|cp
operator|->
name|ace
operator|>
literal|0
argument_list|,
operator|(
literal|"Consumer %s not opened (r%dw%de%d)."
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|,
name|cp
operator|->
name|acr
operator|,
name|cp
operator|->
name|acw
operator|,
name|cp
operator|->
name|ace
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|index
operator|++
expr_stmt|;
name|g_io_request
argument_list|(
name|cbp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BIO_WRITE
case|:
case|case
name|BIO_DELETE
case|:
comment|/* 		 * Bump syncid on first write. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_bump_syncid
operator|==
name|G_RAID3_BUMP_ON_FIRST_WRITE
condition|)
block|{
name|sc
operator|->
name|sc_bump_syncid
operator|=
literal|0
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_raid3_bump_syncid
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
block|}
name|g_raid3_scatter
argument_list|(
name|pbp
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid3_can_destroy
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|gp
operator|=
name|sc
operator|->
name|sc_geom
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|cp
argument_list|,
argument|&gp->consumer
argument_list|,
argument|consumer
argument_list|)
block|{
if|if
condition|(
name|g_raid3_is_busy
argument_list|(
name|sc
argument_list|,
name|cp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|gp
operator|=
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|cp
argument_list|,
argument|&gp->consumer
argument_list|,
argument|consumer
argument_list|)
block|{
if|if
condition|(
name|g_raid3_is_busy
argument_list|(
name|sc
argument_list|,
name|cp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|G_RAID3_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"No I/O requests for %s, it can be destroyed."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid3_try_destroy
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_RAID3_DEVICE_FLAG_WAIT
operator|)
operator|!=
literal|0
condition|)
block|{
name|g_topology_lock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|g_raid3_can_destroy
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|g_topology_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Waking up %p."
argument_list|,
name|__func__
argument_list|,
operator|&
name|sc
operator|->
name|sc_worker
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_worker
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_worker
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|g_topology_lock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|g_raid3_can_destroy
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|g_topology_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|g_raid3_destroy_device
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sc_disks
argument_list|,
name|M_RAID3
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_RAID3
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Worker thread.  */
end_comment

begin_function
specifier|static
name|void
name|g_raid3_worker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|g_raid3_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid3_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_raid3_disk_sync
modifier|*
name|sync
decl_stmt|;
name|struct
name|g_raid3_event
modifier|*
name|ep
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|u_int
name|nreqs
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|curthread
operator|->
name|td_base_pri
operator|=
name|PRIBIO
expr_stmt|;
name|nreqs
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%s: Let's see..."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 		 * First take a look at events. 		 * This is important to handle events before any I/O requests. 		 */
name|ep
operator|=
name|g_raid3_event_get
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
block|{
name|int
name|waitidle
init|=
literal|0
decl_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_RAID3_EVENT_DONTWAIT
operator|)
operator|!=
literal|0
condition|)
name|waitidle
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_RAID3_EVENT_DEVICE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Update only device status. */
name|G_RAID3_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"Running event for device %s."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|ep
operator|->
name|e_error
operator|=
literal|0
expr_stmt|;
name|g_raid3_update_device
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
name|waitidle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Update disk status. */
name|G_RAID3_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"Running event for disk %s."
argument_list|,
name|g_raid3_get_diskname
argument_list|(
name|ep
operator|->
name|e_disk
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|e_error
operator|=
name|g_raid3_update_disk
argument_list|(
name|ep
operator|->
name|e_disk
argument_list|,
name|ep
operator|->
name|e_state
argument_list|,
name|waitidle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_error
operator|==
literal|0
condition|)
name|g_raid3_update_device
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|waitidle
argument_list|)
expr_stmt|;
block|}
name|g_topology_unlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_RAID3_EVENT_DONTWAIT
operator|)
operator|!=
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|ep
operator|->
name|e_error
operator|==
literal|0
argument_list|,
operator|(
literal|"Error cannot be handled."
operator|)
argument_list|)
expr_stmt|;
name|g_raid3_event_free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ep
operator|->
name|e_flags
operator||=
name|G_RAID3_EVENT_DONE
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Waking up %p."
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_RAID3_DEVICE_FLAG_DESTROY
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|g_raid3_try_destroy
argument_list|(
name|sc
argument_list|)
condition|)
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|G_RAID3_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%s: I'm here 1."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Now I/O requests. 		 */
comment|/* Get first request from the queue. */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_RAID3_DEVICE_FLAG_DESTROY
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_raid3_try_destroy
argument_list|(
name|sc
argument_list|)
condition|)
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sc_syncdisk
operator|!=
name|NULL
operator|&&
operator|(
name|bp
operator|==
name|NULL
operator|||
name|nreqs
operator|>
name|g_raid3_reqs_per_sync
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
comment|/* 			 * It is time for synchronization... 			 */
name|nreqs
operator|=
literal|0
expr_stmt|;
name|disk
operator|=
name|sc
operator|->
name|sc_syncdisk
expr_stmt|;
name|sync
operator|=
operator|&
name|disk
operator|->
name|d_sync
expr_stmt|;
if|if
condition|(
name|sync
operator|->
name|ds_offset
operator|<
name|sc
operator|->
name|sc_mediasize
operator|/
operator|(
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
operator|)
operator|&&
name|sync
operator|->
name|ds_offset
operator|==
name|sync
operator|->
name|ds_offset_done
condition|)
block|{
if|if
condition|(
name|sync
operator|->
name|ds_resync
operator|!=
operator|-
literal|1
condition|)
block|{
name|sync
operator|->
name|ds_offset
operator|=
name|sync
operator|->
name|ds_resync
expr_stmt|;
name|sync
operator|->
name|ds_offset_done
operator|=
name|sync
operator|->
name|ds_resync
expr_stmt|;
name|sync
operator|->
name|ds_resync
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|g_raid3_sync_one
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|G_RAID3_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%s: I'm here 2."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|sleep
goto|;
block|}
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|g_raid3_check_idle
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|u_int
name|idletime
decl_stmt|;
name|idletime
operator|=
name|g_raid3_idletime
expr_stmt|;
if|if
condition|(
name|idletime
operator|==
literal|0
condition|)
name|idletime
operator|=
literal|1
expr_stmt|;
name|idletime
operator|*=
name|hz
expr_stmt|;
if|if
condition|(
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|,
name|PRIBIO
operator||
name|PDROP
argument_list|,
literal|"r3:w1"
argument_list|,
name|idletime
argument_list|)
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%s: I'm here 3."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 					 * No I/O requests in 'idletime' 					 * seconds, so mark components as clean. 					 */
name|g_raid3_idle
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|G_RAID3_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%s: I'm here 4."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MSLEEP
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|,
name|PRIBIO
operator||
name|PDROP
argument_list|,
literal|"r3:w2"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%s: I'm here 5."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|nreqs
operator|++
expr_stmt|;
name|bioq_remove
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|bio_cflags
operator|&
name|G_RAID3_BIO_CFLAG_REGULAR
operator|)
operator|!=
literal|0
condition|)
block|{
name|g_raid3_regular_request
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bp
operator|->
name|bio_cflags
operator|&
name|G_RAID3_BIO_CFLAG_SYNC
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|timeout
decl_stmt|,
name|sps
decl_stmt|;
name|g_raid3_sync_request
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|sleep
label|:
name|sps
operator|=
name|atomic_load_acq_int
argument_list|(
operator|&
name|g_raid3_syncs_per_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|sps
operator|==
literal|0
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%s: I'm here 5."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bioq_first
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%s: I'm here 4."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|timeout
operator|=
name|hz
operator|/
name|sps
expr_stmt|;
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
name|timeout
operator|=
literal|1
expr_stmt|;
name|MSLEEP
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|,
name|PRIBIO
operator||
name|PDROP
argument_list|,
literal|"r3:w2"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|g_raid3_register_request
argument_list|(
name|bp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|MSLEEP
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|,
name|PRIBIO
operator||
name|PDROP
argument_list|,
literal|"r3:lowmem"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
name|G_RAID3_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%s: I'm here 6."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Open disk's consumer if needed.  */
end_comment

begin_function
specifier|static
name|void
name|g_raid3_update_access
parameter_list|(
name|struct
name|g_raid3_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|int
name|acr
decl_stmt|,
name|acw
decl_stmt|,
name|ace
decl_stmt|,
name|cpw
decl_stmt|,
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|pp
operator|=
name|disk
operator|->
name|d_softc
operator|->
name|sc_provider
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
block|{
name|acr
operator|=
operator|-
name|cp
operator|->
name|acr
expr_stmt|;
name|acw
operator|=
operator|-
name|cp
operator|->
name|acw
expr_stmt|;
name|ace
operator|=
operator|-
name|cp
operator|->
name|ace
expr_stmt|;
block|}
else|else
block|{
name|acr
operator|=
name|pp
operator|->
name|acr
operator|-
name|cp
operator|->
name|acr
expr_stmt|;
name|acw
operator|=
name|pp
operator|->
name|acw
operator|-
name|cp
operator|->
name|acw
expr_stmt|;
name|ace
operator|=
name|pp
operator|->
name|ace
operator|-
name|cp
operator|->
name|ace
expr_stmt|;
comment|/* Grab an extra "exclusive" bit. */
if|if
condition|(
name|pp
operator|->
name|acr
operator|>
literal|0
operator|||
name|pp
operator|->
name|acw
operator|>
literal|0
operator|||
name|pp
operator|->
name|ace
operator|>
literal|0
condition|)
name|ace
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|acr
operator|==
literal|0
operator|&&
name|acw
operator|==
literal|0
operator|&&
name|ace
operator|==
literal|0
condition|)
return|return;
name|cpw
operator|=
name|cp
operator|->
name|acw
expr_stmt|;
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
name|acr
argument_list|,
name|acw
argument_list|,
name|ace
argument_list|)
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Access %s r%dw%de%d = %d"
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|,
name|acr
argument_list|,
name|acw
argument_list|,
name|ace
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|disk
operator|->
name|d_softc
operator|->
name|sc_bump_syncid
operator|=
name|G_RAID3_BUMP_ON_FIRST_WRITE
expr_stmt|;
name|g_raid3_event_send
argument_list|(
name|disk
argument_list|,
name|G_RAID3_DISK_STATE_DISCONNECTED
argument_list|,
name|G_RAID3_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cpw
operator|==
literal|0
operator|&&
name|cp
operator|->
name|acw
operator|>
literal|0
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Disk %s (device %s) marked as dirty."
argument_list|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|disk
operator|->
name|d_softc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_flags
operator||=
name|G_RAID3_DISK_FLAG_DIRTY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cpw
operator|>
literal|0
operator|&&
name|cp
operator|->
name|acw
operator|==
literal|0
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Disk %s (device %s) marked as clean."
argument_list|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|disk
operator|->
name|d_softc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_RAID3_DISK_FLAG_DIRTY
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_sync_start
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_raid3_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|n
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_state
operator|==
name|G_RAID3_DEVICE_STATE_DEGRADED
argument_list|,
operator|(
literal|"Device not in DEGRADED state (%s, %u)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|sc
operator|->
name|sc_state
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_syncdisk
operator|==
name|NULL
argument_list|,
operator|(
literal|"Syncdisk is not NULL (%s, %u)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|sc
operator|->
name|sc_state
operator|)
argument_list|)
expr_stmt|;
name|disk
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|sc
operator|->
name|sc_ndisks
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_disks
index|[
name|n
index|]
operator|.
name|d_state
operator|!=
name|G_RAID3_DISK_STATE_SYNCHRONIZING
condition|)
continue|continue;
name|disk
operator|=
operator|&
name|sc
operator|->
name|sc_disks
index|[
name|n
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
return|return;
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|->
name|acr
operator|==
literal|0
operator|&&
name|cp
operator|->
name|acw
operator|==
literal|0
operator|&&
name|cp
operator|->
name|ace
operator|==
literal|0
argument_list|,
operator|(
literal|"Consumer %s already opened."
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: rebuilding provider %s."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Access %s r%dw%de%d = %d"
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|g_raid3_event_send
argument_list|(
name|disk
argument_list|,
name|G_RAID3_DISK_STATE_DISCONNECTED
argument_list|,
name|G_RAID3_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
return|return;
block|}
name|disk
operator|->
name|d_flags
operator||=
name|G_RAID3_DISK_FLAG_DIRTY
expr_stmt|;
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|==
name|NULL
argument_list|,
operator|(
literal|"Sync consumer already exists (device=%s, disk=%s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|=
name|g_new_consumer
argument_list|(
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|->
name|private
operator|=
name|disk
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|g_attach
argument_list|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
argument_list|,
name|disk
operator|->
name|d_softc
operator|->
name|sc_provider
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"Cannot attach to %s (error=%d)."
operator|,
name|disk
operator|->
name|d_softc
operator|->
name|sc_name
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_access
argument_list|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"Cannot open %s (error=%d)."
operator|,
name|disk
operator|->
name|d_softc
operator|->
name|sc_name
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_data
operator|=
name|malloc
argument_list|(
name|MAXPHYS
argument_list|,
name|M_RAID3
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_syncdisk
operator|=
name|disk
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop synchronization process.  * type: 0 - synchronization finished  *       1 - synchronization stopped  */
end_comment

begin_function
specifier|static
name|void
name|g_raid3_sync_stop
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|g_raid3_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_state
operator|==
name|G_RAID3_DEVICE_STATE_DEGRADED
argument_list|,
operator|(
literal|"Device not in DEGRADED state (%s, %u)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|sc
operator|->
name|sc_state
operator|)
argument_list|)
expr_stmt|;
name|disk
operator|=
name|sc
operator|->
name|sc_syncdisk
expr_stmt|;
name|sc
operator|->
name|sc_syncdisk
operator|=
name|NULL
expr_stmt|;
name|KASSERT
argument_list|(
name|disk
operator|!=
name|NULL
argument_list|,
operator|(
literal|"No disk was synchronized (%s)."
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_SYNCHRONIZING
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_raid3_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: rebuilding provider %s finished."
argument_list|,
name|disk
operator|->
name|d_softc
operator|->
name|sc_name
argument_list|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* if (type == 1) */
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: rebuilding provider %s stopped."
argument_list|,
name|disk
operator|->
name|d_softc
operator|->
name|sc_name
argument_list|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
expr_stmt|;
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_raid3_kill_consumer
argument_list|(
name|disk
operator|->
name|d_softc
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_data
argument_list|,
name|M_RAID3
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|->
name|acr
operator|==
literal|0
operator|&&
name|cp
operator|->
name|acw
operator|==
literal|1
operator|&&
name|cp
operator|->
name|ace
operator|==
literal|1
argument_list|,
operator|(
literal|"Consumer %s not opened."
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|g_access
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Access %s r%dw%de%d = %d"
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_RAID3_DISK_FLAG_DIRTY
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_launch_provider
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|pp
operator|=
name|g_new_providerf
argument_list|(
name|sc
operator|->
name|sc_geom
argument_list|,
literal|"raid3/%s"
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|pp
operator|->
name|mediasize
operator|=
name|sc
operator|->
name|sc_mediasize
expr_stmt|;
name|pp
operator|->
name|sectorsize
operator|=
name|sc
operator|->
name|sc_sectorsize
expr_stmt|;
name|sc
operator|->
name|sc_provider
operator|=
name|pp
expr_stmt|;
name|g_error_provider
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: provider %s launched."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|G_RAID3_DEVICE_STATE_DEGRADED
condition|)
name|g_raid3_sync_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_destroy_provider
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_provider
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL provider (device=%s)."
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
name|g_error_provider
argument_list|(
name|sc
operator|->
name|sc_provider
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bioq_remove
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: provider %s destroyed."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|sc
operator|->
name|sc_provider
operator|->
name|name
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_provider
operator|->
name|flags
operator||=
name|G_PF_WITHER
expr_stmt|;
name|g_orphan_provider
argument_list|(
name|sc
operator|->
name|sc_provider
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_provider
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_syncdisk
operator|!=
name|NULL
condition|)
name|g_raid3_sync_stop
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_go
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|g_raid3_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Force device %s start due to timeout."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|g_raid3_event_send
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|G_RAID3_EVENT_DONTWAIT
operator||
name|G_RAID3_EVENT_DEVICE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|g_raid3_determine_state
parameter_list|(
name|struct
name|g_raid3_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_raid3_softc
modifier|*
name|sc
decl_stmt|;
name|u_int
name|state
decl_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_syncid
operator|==
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
condition|)
block|{
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_RAID3_DISK_FLAG_SYNCHRONIZING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Disk does not need synchronization. */
name|state
operator|=
name|G_RAID3_DISK_STATE_ACTIVE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_RAID3_DEVICE_FLAG_NOAUTOSYNC
operator|)
operator|==
literal|0
operator|||
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_RAID3_DISK_FLAG_FORCE_SYNC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * We can start synchronization from 				 * the stored offset. 				 */
name|state
operator|=
name|G_RAID3_DISK_STATE_SYNCHRONIZING
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|G_RAID3_DISK_STATE_STALE
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|<
name|sc
operator|->
name|sc_syncid
condition|)
block|{
comment|/* 		 * Reset all synchronization data for this disk, 		 * because if it even was synchronized, it was 		 * synchronized to disks with different syncid. 		 */
name|disk
operator|->
name|d_flags
operator||=
name|G_RAID3_DISK_FLAG_SYNCHRONIZING
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset
operator|=
literal|0
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset_done
operator|=
literal|0
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|=
name|sc
operator|->
name|sc_syncid
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_RAID3_DEVICE_FLAG_NOAUTOSYNC
operator|)
operator|==
literal|0
operator|||
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_RAID3_DISK_FLAG_FORCE_SYNC
operator|)
operator|!=
literal|0
condition|)
block|{
name|state
operator|=
name|G_RAID3_DISK_STATE_SYNCHRONIZING
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|G_RAID3_DISK_STATE_STALE
expr_stmt|;
block|}
block|}
else|else
comment|/* if (sc->sc_syncid< disk->d_sync.ds_syncid) */
block|{
comment|/* 		 * Not good, NOT GOOD! 		 * It means that device was started on stale disks 		 * and more fresh disk just arrive. 		 * If there were writes, device is fucked up, sorry. 		 * I think the best choice here is don't touch 		 * this disk and inform the user laudly. 		 */
name|G_RAID3_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s was started before the freshest "
literal|"disk (%s) arrives!! It will not be connected to the "
literal|"running device."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
name|g_raid3_destroy_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|state
operator|=
name|G_RAID3_DISK_STATE_NONE
expr_stmt|;
comment|/* Return immediately, because disk was destroyed. */
return|return
operator|(
name|state
operator|)
return|;
block|}
name|G_RAID3_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"State for %s disk: %s."
argument_list|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|g_raid3_disk_state2str
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|state
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update device state.  */
end_comment

begin_function
specifier|static
name|void
name|g_raid3_update_device
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|,
name|boolean_t
name|force
parameter_list|,
name|int
name|waitidle
parameter_list|)
block|{
name|struct
name|g_raid3_disk
modifier|*
name|disk
decl_stmt|;
name|u_int
name|state
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_state
condition|)
block|{
case|case
name|G_RAID3_DEVICE_STATE_STARTING
case|:
block|{
name|u_int
name|n
decl_stmt|,
name|ndirty
decl_stmt|,
name|ndisks
decl_stmt|,
name|syncid
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_provider
operator|==
name|NULL
argument_list|,
operator|(
literal|"Non-NULL provider in STARTING state (%s)."
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Are we ready? We are, if all disks are connected or 		 * one disk is missing and 'force' is true. 		 */
if|if
condition|(
name|g_raid3_ndisks
argument_list|(
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
operator|+
name|force
operator|==
name|sc
operator|->
name|sc_ndisks
condition|)
block|{
if|if
condition|(
operator|!
name|force
condition|)
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|force
condition|)
block|{
comment|/* 				 * Timeout expired, so destroy device. 				 */
name|sc
operator|->
name|sc_flags
operator||=
name|G_RAID3_DEVICE_FLAG_DESTROY
expr_stmt|;
block|}
return|return;
block|}
comment|/* 		 * There must be at least 'sc->sc_ndisks - 1' components 		 * with the same syncid and without SYNCHRONIZING flag. 		 */
comment|/* 		 * Find the biggest syncid, number of valid components and 		 * number of dirty components. 		 */
name|ndirty
operator|=
name|ndisks
operator|=
name|syncid
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|sc
operator|->
name|sc_ndisks
condition|;
name|n
operator|++
control|)
block|{
name|disk
operator|=
operator|&
name|sc
operator|->
name|sc_disks
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_NODISK
condition|)
continue|continue;
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_RAID3_DISK_FLAG_DIRTY
operator|)
operator|!=
literal|0
condition|)
name|ndirty
operator|++
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|>
name|syncid
condition|)
block|{
name|syncid
operator|=
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
expr_stmt|;
name|ndisks
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|<
name|syncid
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_RAID3_DISK_FLAG_SYNCHRONIZING
operator|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
name|ndisks
operator|++
expr_stmt|;
block|}
comment|/* 		 * Do we have enough valid components? 		 */
if|if
condition|(
name|ndisks
operator|+
literal|1
operator|<
name|sc
operator|->
name|sc_ndisks
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s is broken, too few valid components."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|G_RAID3_DEVICE_FLAG_DESTROY
expr_stmt|;
return|return;
block|}
comment|/* 		 * If there is one DIRTY component and all disks are present, 		 * mark it for synchronization. If there is more than one DIRTY 		 * component, mark parity component for synchronization. 		 */
if|if
condition|(
name|ndisks
operator|==
name|sc
operator|->
name|sc_ndisks
operator|&&
name|ndirty
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|sc
operator|->
name|sc_ndisks
condition|;
name|n
operator|++
control|)
block|{
name|disk
operator|=
operator|&
name|sc
operator|->
name|sc_disks
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_RAID3_DISK_FLAG_DIRTY
operator|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|disk
operator|->
name|d_flags
operator||=
name|G_RAID3_DISK_FLAG_SYNCHRONIZING
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ndisks
operator|==
name|sc
operator|->
name|sc_ndisks
operator|&&
name|ndirty
operator|>
literal|1
condition|)
block|{
name|disk
operator|=
operator|&
name|sc
operator|->
name|sc_disks
index|[
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
index|]
expr_stmt|;
name|disk
operator|->
name|d_flags
operator||=
name|G_RAID3_DISK_FLAG_SYNCHRONIZING
expr_stmt|;
block|}
name|sc
operator|->
name|sc_syncid
operator|=
name|syncid
expr_stmt|;
if|if
condition|(
name|force
condition|)
block|{
comment|/* Remember to bump syncid on first write. */
name|sc
operator|->
name|sc_bump_syncid
operator|=
name|G_RAID3_BUMP_ON_FIRST_WRITE
expr_stmt|;
block|}
if|if
condition|(
name|ndisks
operator|==
name|sc
operator|->
name|sc_ndisks
condition|)
name|state
operator|=
name|G_RAID3_DEVICE_STATE_COMPLETE
expr_stmt|;
else|else
comment|/* if (ndisks == sc->sc_ndisks - 1) */
name|state
operator|=
name|G_RAID3_DEVICE_STATE_DEGRADED
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Device %s state changed from %s to %s."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_raid3_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
argument_list|,
name|g_raid3_device_state2str
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|state
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|sc
operator|->
name|sc_ndisks
condition|;
name|n
operator|++
control|)
block|{
name|disk
operator|=
operator|&
name|sc
operator|->
name|sc_disks
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_NODISK
condition|)
continue|continue;
name|state
operator|=
name|g_raid3_determine_state
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|g_raid3_event_send
argument_list|(
name|disk
argument_list|,
name|state
argument_list|,
name|G_RAID3_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|G_RAID3_DISK_STATE_STALE
condition|)
block|{
name|sc
operator|->
name|sc_bump_syncid
operator|=
name|G_RAID3_BUMP_ON_FIRST_WRITE
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|G_RAID3_DEVICE_STATE_DEGRADED
case|:
comment|/* 		 * Bump syncid here, if we need to do it immediately. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_bump_syncid
operator|==
name|G_RAID3_BUMP_IMMEDIATELY
condition|)
block|{
name|sc
operator|->
name|sc_bump_syncid
operator|=
literal|0
expr_stmt|;
name|g_raid3_bump_syncid
argument_list|(
name|sc
argument_list|,
name|waitidle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|g_raid3_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID3_DISK_STATE_NEW
argument_list|)
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|g_raid3_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID3_DISK_STATE_ACTIVE
argument_list|)
operator|<
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_provider
operator|!=
name|NULL
condition|)
name|g_raid3_destroy_provider
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|G_RAID3_DEVICE_FLAG_DESTROY
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|g_raid3_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID3_DISK_STATE_ACTIVE
argument_list|)
operator|==
name|sc
operator|->
name|sc_ndisks
condition|)
block|{
name|state
operator|=
name|G_RAID3_DEVICE_STATE_COMPLETE
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Device %s state changed from %s to %s."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_raid3_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
argument_list|,
name|g_raid3_device_state2str
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|state
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_provider
operator|==
name|NULL
condition|)
name|g_raid3_launch_provider
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|G_RAID3_DEVICE_STATE_COMPLETE
case|:
comment|/* 		 * Bump syncid here, if we need to do it immediately. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_bump_syncid
operator|==
name|G_RAID3_BUMP_IMMEDIATELY
condition|)
block|{
name|sc
operator|->
name|sc_bump_syncid
operator|=
literal|0
expr_stmt|;
name|g_raid3_bump_syncid
argument_list|(
name|sc
argument_list|,
name|waitidle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|g_raid3_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID3_DISK_STATE_NEW
argument_list|)
operator|>
literal|0
condition|)
return|return;
name|KASSERT
argument_list|(
name|g_raid3_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID3_DISK_STATE_ACTIVE
argument_list|)
operator|>=
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
argument_list|,
operator|(
literal|"Too few ACTIVE components in COMPLETE state (device %s)."
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_raid3_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID3_DISK_STATE_ACTIVE
argument_list|)
operator|==
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
condition|)
block|{
name|state
operator|=
name|G_RAID3_DEVICE_STATE_DEGRADED
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Device %s state changed from %s to %s."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_raid3_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
argument_list|,
name|g_raid3_device_state2str
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|state
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_provider
operator|==
name|NULL
condition|)
name|g_raid3_launch_provider
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
literal|1
operator|==
literal|0
argument_list|,
operator|(
literal|"Wrong device state (%s, %s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_raid3_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Update disk state and device state if needed.  */
end_comment

begin_define
define|#
directive|define
name|DISK_STATE_CHANGED
parameter_list|()
value|G_RAID3_DEBUG(1,			\ 	"Disk %s state changed from %s to %s (device %s).",		\ 	g_raid3_get_diskname(disk),					\ 	g_raid3_disk_state2str(disk->d_state),				\ 	g_raid3_disk_state2str(state), sc->sc_name)
end_define

begin_function
specifier|static
name|int
name|g_raid3_update_disk
parameter_list|(
name|struct
name|g_raid3_disk
modifier|*
name|disk
parameter_list|,
name|u_int
name|state
parameter_list|,
name|int
name|waitidle
parameter_list|)
block|{
name|struct
name|g_raid3_softc
modifier|*
name|sc
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|again
label|:
name|G_RAID3_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"Changing disk %s state from %s to %s."
argument_list|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|g_raid3_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
argument_list|,
name|g_raid3_disk_state2str
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|G_RAID3_DISK_STATE_NEW
case|:
comment|/* 		 * Possible scenarios: 		 * 1. New disk arrive. 		 */
comment|/* Previous state should be NONE. */
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_NONE
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_raid3_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DISK_STATE_CHANGED
argument_list|()
expr_stmt|;
name|disk
operator|->
name|d_state
operator|=
name|state
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: provider %s detected."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|G_RAID3_DEVICE_STATE_STARTING
condition|)
break|break;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_state
operator|==
name|G_RAID3_DEVICE_STATE_DEGRADED
operator|||
name|sc
operator|->
name|sc_state
operator|==
name|G_RAID3_DEVICE_STATE_COMPLETE
argument_list|,
operator|(
literal|"Wrong device state (%s, %s, %s, %s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_raid3_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
operator|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_raid3_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|state
operator|=
name|g_raid3_determine_state
argument_list|(
name|disk
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|G_RAID3_DISK_STATE_NONE
condition|)
goto|goto
name|again
goto|;
break|break;
case|case
name|G_RAID3_DISK_STATE_ACTIVE
case|:
comment|/* 		 * Possible scenarios: 		 * 1. New disk does not need synchronization. 		 * 2. Synchronization process finished successfully. 		 */
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_state
operator|==
name|G_RAID3_DEVICE_STATE_DEGRADED
operator|||
name|sc
operator|->
name|sc_state
operator|==
name|G_RAID3_DEVICE_STATE_COMPLETE
argument_list|,
operator|(
literal|"Wrong device state (%s, %s, %s, %s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_raid3_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
operator|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_raid3_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Previous state should be NEW or SYNCHRONIZING. */
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_NEW
operator|||
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_SYNCHRONIZING
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_raid3_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DISK_STATE_CHANGED
argument_list|()
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_NEW
condition|)
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_RAID3_DISK_FLAG_DIRTY
expr_stmt|;
elseif|else
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_SYNCHRONIZING
condition|)
block|{
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_RAID3_DISK_FLAG_SYNCHRONIZING
expr_stmt|;
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_RAID3_DISK_FLAG_FORCE_SYNC
expr_stmt|;
name|g_raid3_sync_stop
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|disk
operator|->
name|d_state
operator|=
name|state
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset
operator|=
literal|0
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset_done
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|waitidle
condition|)
name|g_waitidlelock
argument_list|()
expr_stmt|;
name|g_raid3_update_access
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|g_raid3_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: provider %s activated."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|G_RAID3_DISK_STATE_STALE
case|:
comment|/* 		 * Possible scenarios: 		 * 1. Stale disk was connected. 		 */
comment|/* Previous state should be NEW. */
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_NEW
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_raid3_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_state
operator|==
name|G_RAID3_DEVICE_STATE_DEGRADED
operator|||
name|sc
operator|->
name|sc_state
operator|==
name|G_RAID3_DEVICE_STATE_COMPLETE
argument_list|,
operator|(
literal|"Wrong device state (%s, %s, %s, %s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_raid3_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
operator|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_raid3_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * STALE state is only possible if device is marked 		 * NOAUTOSYNC. 		 */
name|KASSERT
argument_list|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_RAID3_DEVICE_FLAG_NOAUTOSYNC
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"Wrong device state (%s, %s, %s, %s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_raid3_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
operator|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_raid3_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DISK_STATE_CHANGED
argument_list|()
expr_stmt|;
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_RAID3_DISK_FLAG_DIRTY
expr_stmt|;
name|disk
operator|->
name|d_state
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|waitidle
condition|)
name|g_waitidlelock
argument_list|()
expr_stmt|;
name|g_raid3_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: provider %s is stale."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|G_RAID3_DISK_STATE_SYNCHRONIZING
case|:
comment|/* 		 * Possible scenarios: 		 * 1. Disk which needs synchronization was connected. 		 */
comment|/* Previous state should be NEW. */
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_NEW
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_raid3_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_state
operator|==
name|G_RAID3_DEVICE_STATE_DEGRADED
operator|||
name|sc
operator|->
name|sc_state
operator|==
name|G_RAID3_DEVICE_STATE_COMPLETE
argument_list|,
operator|(
literal|"Wrong device state (%s, %s, %s, %s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_raid3_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
operator|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_raid3_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DISK_STATE_CHANGED
argument_list|()
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_NEW
condition|)
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_RAID3_DISK_FLAG_DIRTY
expr_stmt|;
name|disk
operator|->
name|d_state
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_provider
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|waitidle
condition|)
name|g_waitidlelock
argument_list|()
expr_stmt|;
name|g_raid3_sync_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|g_raid3_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|G_RAID3_DISK_STATE_DISCONNECTED
case|:
comment|/* 		 * Possible scenarios: 		 * 1. Device wasn't running yet, but disk disappear. 		 * 2. Disk was active and disapppear. 		 * 3. Disk disappear during synchronization process. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|G_RAID3_DEVICE_STATE_DEGRADED
operator|||
name|sc
operator|->
name|sc_state
operator|==
name|G_RAID3_DEVICE_STATE_COMPLETE
condition|)
block|{
comment|/* 			 * Previous state should be ACTIVE, STALE or 			 * SYNCHRONIZING. 			 */
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_ACTIVE
operator|||
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_STALE
operator|||
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_SYNCHRONIZING
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_raid3_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|G_RAID3_DEVICE_STATE_STARTING
condition|)
block|{
comment|/* Previous state should be NEW. */
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_NEW
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_raid3_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Reset bumping syncid if disk disappeared in STARTING 			 * state. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_bump_syncid
operator|==
name|G_RAID3_BUMP_ON_FIRST_WRITE
condition|)
name|sc
operator|->
name|sc_bump_syncid
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
block|}
else|else
block|{
name|KASSERT
argument_list|(
literal|1
operator|==
literal|0
argument_list|,
operator|(
literal|"Wrong device state (%s, %s, %s, %s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_raid3_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
operator|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_raid3_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|DISK_STATE_CHANGED
argument_list|()
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: provider %s disconnected."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
name|g_raid3_destroy_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
literal|1
operator|==
literal|0
argument_list|,
operator|(
literal|"Unknown state (%u)."
operator|,
name|state
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|DISK_STATE_CHANGED
end_undef

begin_function
specifier|static
name|int
name|g_raid3_read_metadata
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_raid3_metadata
modifier|*
name|md
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
comment|/* Metadata are stored on last sector. */
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|pp
operator|->
name|mediasize
operator|-
name|pp
operator|->
name|sectorsize
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"Cannot decrease access count for %s."
operator|,
name|pp
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
comment|/* Decode metadata. */
name|error
operator|=
name|raid3_metadata_decode
argument_list|(
name|buf
argument_list|,
name|md
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|md
operator|->
name|md_magic
argument_list|,
name|G_RAID3_MAGIC
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"MD5 metadata hash mismatch for provider %s."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid3_check_metadata
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|struct
name|g_raid3_metadata
modifier|*
name|md
parameter_list|)
block|{
if|if
condition|(
name|md
operator|->
name|md_no
operator|>=
name|sc
operator|->
name|sc_ndisks
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid disk %s number (no=%u), skipping."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|md
operator|->
name|md_no
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_disks
index|[
name|md
operator|->
name|md_no
index|]
operator|.
name|d_state
operator|!=
name|G_RAID3_DISK_STATE_NODISK
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Disk %s (no=%u) already exists, skipping."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|md
operator|->
name|md_no
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
if|if
condition|(
name|md
operator|->
name|md_all
operator|!=
name|sc
operator|->
name|sc_ndisks
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid '%s' field on disk %s (device %s), skipping."
argument_list|,
literal|"md_all"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|md
operator|->
name|md_mediasize
operator|!=
name|sc
operator|->
name|sc_mediasize
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid '%s' field on disk %s (device %s), skipping."
argument_list|,
literal|"md_mediasize"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|md
operator|->
name|md_mediasize
operator|%
operator|(
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid '%s' field on disk %s (device %s), skipping."
argument_list|,
literal|"md_mediasize"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_mediasize
operator|/
operator|(
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
operator|)
operator|)
operator|>
name|pp
operator|->
name|mediasize
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid size of disk %s (device %s), skipping."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|md
operator|->
name|md_sectorsize
operator|/
name|pp
operator|->
name|sectorsize
operator|)
operator|<
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid '%s' field on disk %s (device %s), skipping."
argument_list|,
literal|"md_sectorsize"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|md
operator|->
name|md_sectorsize
operator|!=
name|sc
operator|->
name|sc_sectorsize
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid '%s' field on disk %s (device %s), skipping."
argument_list|,
literal|"md_sectorsize"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_sectorsize
operator|%
name|pp
operator|->
name|sectorsize
operator|)
operator|!=
literal|0
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid sector size of disk %s (device %s), skipping."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|md
operator|->
name|md_mflags
operator|&
operator|~
name|G_RAID3_DEVICE_FLAG_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid device flags on disk %s (device %s), skipping."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|md
operator|->
name|md_mflags
operator|&
name|G_RAID3_DEVICE_FLAG_VERIFY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|md
operator|->
name|md_mflags
operator|&
name|G_RAID3_DEVICE_FLAG_ROUND_ROBIN
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * VERIFY and ROUND-ROBIN options are mutally exclusive. 		 */
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Both VERIFY and ROUND-ROBIN flags exist on "
literal|"disk %s (device %s), skipping."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|md
operator|->
name|md_dflags
operator|&
operator|~
name|G_RAID3_DISK_FLAG_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid disk flags on disk %s (device %s), skipping."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid3_add_disk
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|struct
name|g_raid3_metadata
modifier|*
name|md
parameter_list|)
block|{
name|struct
name|g_raid3_disk
modifier|*
name|disk
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Adding disk %s."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_raid3_check_metadata
argument_list|(
name|sc
argument_list|,
name|pp
argument_list|,
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|disk
operator|=
name|g_raid3_init_disk
argument_list|(
name|sc
argument_list|,
name|pp
argument_list|,
name|md
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|g_raid3_event_send
argument_list|(
name|disk
argument_list|,
name|G_RAID3_DISK_STATE_NEW
argument_list|,
name|G_RAID3_EVENT_WAIT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid3_access
parameter_list|(
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|acr
parameter_list|,
name|int
name|acw
parameter_list|,
name|int
name|ace
parameter_list|)
block|{
name|struct
name|g_raid3_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid3_disk
modifier|*
name|disk
decl_stmt|;
name|int
name|dcr
decl_stmt|,
name|dcw
decl_stmt|,
name|dce
decl_stmt|,
name|err
decl_stmt|,
name|error
decl_stmt|;
name|u_int
name|n
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Access request for %s: r%dw%de%d."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|acr
argument_list|,
name|acw
argument_list|,
name|ace
argument_list|)
expr_stmt|;
name|dcr
operator|=
name|pp
operator|->
name|acr
operator|+
name|acr
expr_stmt|;
name|dcw
operator|=
name|pp
operator|->
name|acw
operator|+
name|acw
expr_stmt|;
name|dce
operator|=
name|pp
operator|->
name|ace
operator|+
name|ace
expr_stmt|;
comment|/* On first open, grab an extra "exclusive" bit */
if|if
condition|(
name|pp
operator|->
name|acr
operator|==
literal|0
operator|&&
name|pp
operator|->
name|acw
operator|==
literal|0
operator|&&
name|pp
operator|->
name|ace
operator|==
literal|0
condition|)
name|ace
operator|++
expr_stmt|;
comment|/* ... and let go of it on last close */
if|if
condition|(
name|dcr
operator|==
literal|0
operator|&&
name|dcw
operator|==
literal|0
operator|&&
name|dce
operator|==
literal|0
condition|)
name|ace
operator|--
expr_stmt|;
name|sc
operator|=
name|pp
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|g_raid3_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID3_DISK_STATE_ACTIVE
argument_list|)
operator|<
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_RAID3_DEVICE_FLAG_DESTROY
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|acr
operator|<=
literal|0
operator|&&
name|acw
operator|<=
literal|0
operator|&&
name|ace
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|ENXIO
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|sc
operator|->
name|sc_ndisks
condition|;
name|n
operator|++
control|)
block|{
name|disk
operator|=
operator|&
name|sc
operator|->
name|sc_disks
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_RAID3_DISK_STATE_ACTIVE
condition|)
continue|continue;
name|err
operator|=
name|g_access
argument_list|(
name|disk
operator|->
name|d_consumer
argument_list|,
name|acr
argument_list|,
name|acw
argument_list|,
name|ace
argument_list|)
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Access %s r%dw%de%d = %d"
argument_list|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|acr
argument_list|,
name|acw
argument_list|,
name|ace
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Mark disk as dirty on open and unmark on close. 			 */
if|if
condition|(
name|pp
operator|->
name|acw
operator|==
literal|0
operator|&&
name|dcw
operator|>
literal|0
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Disk %s (device %s) marked as dirty."
argument_list|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_flags
operator||=
name|G_RAID3_DISK_FLAG_DIRTY
expr_stmt|;
name|g_raid3_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pp
operator|->
name|acw
operator|>
literal|0
operator|&&
name|dcw
operator|==
literal|0
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Disk %s (device %s) marked as clean."
argument_list|,
name|g_raid3_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_RAID3_DISK_FLAG_DIRTY
expr_stmt|;
name|g_raid3_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_bump_syncid
operator|=
name|G_RAID3_BUMP_ON_FIRST_WRITE
expr_stmt|;
name|g_raid3_event_send
argument_list|(
name|disk
argument_list|,
name|G_RAID3_DISK_STATE_DISCONNECTED
argument_list|,
name|G_RAID3_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|g_geom
modifier|*
name|g_raid3_create
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
specifier|const
name|struct
name|g_raid3_metadata
modifier|*
name|md
parameter_list|)
block|{
name|struct
name|g_raid3_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|timeout
decl_stmt|;
name|u_int
name|n
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Creating device %s (id=%u)."
argument_list|,
name|md
operator|->
name|md_name
argument_list|,
name|md
operator|->
name|md_id
argument_list|)
expr_stmt|;
comment|/* One disk is minimum. */
if|if
condition|(
name|md
operator|->
name|md_all
operator|<
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Action geom. 	 */
name|gp
operator|=
name|g_new_geomf
argument_list|(
name|mp
argument_list|,
literal|"%s"
argument_list|,
name|md
operator|->
name|md_name
argument_list|)
expr_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_RAID3
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_disks
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|g_raid3_disk
argument_list|)
operator|*
name|md
operator|->
name|md_all
argument_list|,
name|M_RAID3
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|gp
operator|->
name|start
operator|=
name|g_raid3_start
expr_stmt|;
name|gp
operator|->
name|spoiled
operator|=
name|g_raid3_spoiled
expr_stmt|;
name|gp
operator|->
name|orphan
operator|=
name|g_raid3_orphan
expr_stmt|;
name|gp
operator|->
name|access
operator|=
name|g_raid3_access
expr_stmt|;
name|gp
operator|->
name|dumpconf
operator|=
name|g_raid3_dumpconf
expr_stmt|;
name|sc
operator|->
name|sc_id
operator|=
name|md
operator|->
name|md_id
expr_stmt|;
name|sc
operator|->
name|sc_mediasize
operator|=
name|md
operator|->
name|md_mediasize
expr_stmt|;
name|sc
operator|->
name|sc_sectorsize
operator|=
name|md
operator|->
name|md_sectorsize
expr_stmt|;
name|sc
operator|->
name|sc_ndisks
operator|=
name|md
operator|->
name|md_all
expr_stmt|;
name|sc
operator|->
name|sc_round_robin
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
name|md
operator|->
name|md_mflags
expr_stmt|;
name|sc
operator|->
name|sc_bump_syncid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_idle
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|sc
operator|->
name|sc_ndisks
condition|;
name|n
operator|++
control|)
name|sc
operator|->
name|sc_disks
index|[
name|n
index|]
operator|.
name|d_state
operator|=
name|G_RAID3_DISK_STATE_NODISK
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|,
literal|"graid3:queue"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_events
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|,
literal|"graid3:events"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|G_RAID3_DEVICE_STATE_STARTING
expr_stmt|;
name|gp
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_geom
operator|=
name|gp
expr_stmt|;
name|sc
operator|->
name|sc_provider
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Synchronization geom. 	 */
name|gp
operator|=
name|g_new_geomf
argument_list|(
name|mp
argument_list|,
literal|"%s.sync"
argument_list|,
name|md
operator|->
name|md_name
argument_list|)
expr_stmt|;
name|gp
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
name|gp
operator|->
name|orphan
operator|=
name|g_raid3_orphan
expr_stmt|;
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
operator|=
name|gp
expr_stmt|;
name|sc
operator|->
name|sc_zone_64k
operator|=
name|uma_zcreate
argument_list|(
literal|"gr3:64k"
argument_list|,
literal|65536
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|sc
operator|->
name|sc_zone_64k
argument_list|,
name|g_raid3_n64k
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_zone_16k
operator|=
name|uma_zcreate
argument_list|(
literal|"gr3:16k"
argument_list|,
literal|16384
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|sc
operator|->
name|sc_zone_64k
argument_list|,
name|g_raid3_n16k
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_zone_4k
operator|=
name|uma_zcreate
argument_list|(
literal|"gr3:4k"
argument_list|,
literal|4096
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|sc
operator|->
name|sc_zone_4k
argument_list|,
name|g_raid3_n4k
argument_list|)
expr_stmt|;
name|error
operator|=
name|kthread_create
argument_list|(
name|g_raid3_worker
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_worker
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"g_raid3 %s"
argument_list|,
name|md
operator|->
name|md_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Cannot create kernel thread for %s."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|sc
operator|->
name|sc_zone_64k
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|sc
operator|->
name|sc_zone_16k
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|sc
operator|->
name|sc_zone_4k
argument_list|)
expr_stmt|;
name|g_destroy_geom
argument_list|(
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|g_destroy_geom
argument_list|(
name|sc
operator|->
name|sc_geom
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sc_disks
argument_list|,
name|M_RAID3
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_RAID3
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|G_RAID3_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s created (id=%u)."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|sc
operator|->
name|sc_id
argument_list|)
expr_stmt|;
comment|/* 	 * Run timeout. 	 */
name|timeout
operator|=
name|atomic_load_acq_int
argument_list|(
operator|&
name|g_raid3_timeout
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|,
name|timeout
operator|*
name|hz
argument_list|,
name|g_raid3_go
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|->
name|sc_geom
operator|)
return|;
block|}
end_function

begin_function
name|int
name|g_raid3_destroy
parameter_list|(
name|struct
name|g_raid3_softc
modifier|*
name|sc
parameter_list|,
name|boolean_t
name|force
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pp
operator|=
name|sc
operator|->
name|sc_provider
expr_stmt|;
if|if
condition|(
name|pp
operator|!=
name|NULL
operator|&&
operator|(
name|pp
operator|->
name|acr
operator|!=
literal|0
operator|||
name|pp
operator|->
name|acw
operator|!=
literal|0
operator|||
name|pp
operator|->
name|ace
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|force
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s is still open, so it "
literal|"can't be definitely removed."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Device %s is still open (r%dw%de%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|pp
operator|->
name|acr
argument_list|,
name|pp
operator|->
name|acw
argument_list|,
name|pp
operator|->
name|ace
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
block|}
name|sc
operator|->
name|sc_flags
operator||=
name|G_RAID3_DEVICE_FLAG_DESTROY
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|G_RAID3_DEVICE_FLAG_WAIT
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Waking up %p."
argument_list|,
name|__func__
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Sleeping %p."
argument_list|,
name|__func__
argument_list|,
operator|&
name|sc
operator|->
name|sc_worker
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|sc_worker
operator|!=
name|NULL
condition|)
name|tsleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_worker
argument_list|,
name|PRIBIO
argument_list|,
literal|"r3:destroy"
argument_list|,
name|hz
operator|/
literal|5
argument_list|)
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Woken up %p."
argument_list|,
name|__func__
argument_list|,
operator|&
name|sc
operator|->
name|sc_worker
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_raid3_destroy_device
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sc_disks
argument_list|,
name|M_RAID3
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_RAID3
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_taste_orphan
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|KASSERT
argument_list|(
literal|1
operator|==
literal|0
argument_list|,
operator|(
literal|"%s called while tasting %s."
operator|,
name|__func__
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|g_geom
modifier|*
name|g_raid3_taste
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|flags
name|__unused
parameter_list|)
block|{
name|struct
name|g_raid3_metadata
name|md
decl_stmt|;
name|struct
name|g_raid3_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"%s(%s, %s)"
argument_list|,
name|__func__
argument_list|,
name|mp
operator|->
name|name
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|G_RAID3_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Tasting %s."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|gp
operator|=
name|g_new_geomf
argument_list|(
name|mp
argument_list|,
literal|"raid3:taste"
argument_list|)
expr_stmt|;
comment|/* This orphan function should be never called. */
name|gp
operator|->
name|orphan
operator|=
name|g_raid3_taste_orphan
expr_stmt|;
name|cp
operator|=
name|g_new_consumer
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|g_attach
argument_list|(
name|cp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_raid3_read_metadata
argument_list|(
name|cp
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_geom
argument_list|(
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|gp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|md
operator|.
name|md_version
operator|>
name|G_RAID3_VERSION
condition|)
block|{
name|printf
argument_list|(
literal|"geom_raid3.ko module is too old to handle %s.\n"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|md
operator|.
name|md_provider
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|strcmp
argument_list|(
name|md
operator|.
name|md_provider
argument_list|,
name|pp
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|g_raid3_debug
operator|>=
literal|2
condition|)
name|raid3_metadata_dump
argument_list|(
operator|&
name|md
argument_list|)
expr_stmt|;
comment|/* 	 * Let's check if device already exists. 	 */
name|sc
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|gp
argument_list|,
argument|&mp->geom
argument_list|,
argument|geom
argument_list|)
block|{
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
operator|==
name|gp
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|md
operator|.
name|md_name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|md
operator|.
name|md_id
operator|!=
name|sc
operator|->
name|sc_id
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s already configured."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
block|}
if|if
condition|(
name|gp
operator|==
name|NULL
condition|)
block|{
name|gp
operator|=
name|g_raid3_create
argument_list|(
name|mp
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|==
name|NULL
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot create device %s."
argument_list|,
name|md
operator|.
name|md_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
block|}
name|G_RAID3_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Adding disk %s to %s."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|gp
operator|->
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_raid3_add_disk
argument_list|(
name|sc
argument_list|,
name|pp
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_RAID3_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot add disk %s to %s (error=%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|gp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_raid3_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID3_DISK_STATE_NODISK
argument_list|)
operator|==
name|sc
operator|->
name|sc_ndisks
condition|)
block|{
name|g_raid3_destroy
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|gp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid3_destroy_geom
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
name|__unused
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
name|__unused
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|)
block|{
return|return
operator|(
name|g_raid3_destroy
argument_list|(
name|gp
operator|->
name|softc
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_dumpconf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|)
block|{
name|struct
name|g_raid3_softc
modifier|*
name|sc
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
comment|/* Skip synchronization geom. */
if|if
condition|(
name|gp
operator|==
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
condition|)
return|return;
if|if
condition|(
name|pp
operator|!=
name|NULL
condition|)
block|{
comment|/* Nothing here. */
block|}
elseif|else
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|struct
name|g_raid3_disk
modifier|*
name|disk
decl_stmt|;
name|disk
operator|=
name|cp
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
return|return;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Type>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_no
operator|==
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"PARITY"
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"DATA"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</Type>\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Number>%u</Number>\n"
argument_list|,
name|indent
argument_list|,
operator|(
name|u_int
operator|)
name|disk
operator|->
name|d_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID3_DISK_STATE_SYNCHRONIZING
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Synchronized>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset_done
operator|==
literal|0
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"0%%"
argument_list|)
expr_stmt|;
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%u%%"
argument_list|,
call|(
name|u_int
call|)
argument_list|(
operator|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset_done
operator|*
literal|100
operator|)
operator|/
operator|(
name|sc
operator|->
name|sc_mediasize
operator|/
operator|(
name|sc
operator|->
name|sc_ndisks
operator|-
literal|1
operator|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</Synchronized>\n"
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<SyncID>%u</SyncID>\n"
argument_list|,
name|indent
argument_list|,
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Flags>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_flags
operator|==
literal|0
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"NONE"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
define|#
directive|define
name|ADD_FLAG
parameter_list|(
name|flag
parameter_list|,
name|name
parameter_list|)
value|do {					\ 	if ((disk->d_flags& (flag)) != 0) {				\ 		if (!first)						\ 			sbuf_printf(sb, ", ");				\ 		else							\ 			first = 0;					\ 		sbuf_printf(sb, name);					\ 	}								\ } while (0)
name|ADD_FLAG
argument_list|(
name|G_RAID3_DISK_FLAG_DIRTY
argument_list|,
literal|"DIRTY"
argument_list|)
expr_stmt|;
name|ADD_FLAG
argument_list|(
name|G_RAID3_DISK_FLAG_HARDCODED
argument_list|,
literal|"HARDCODED"
argument_list|)
expr_stmt|;
name|ADD_FLAG
argument_list|(
name|G_RAID3_DISK_FLAG_SYNCHRONIZING
argument_list|,
literal|"SYNCHRONIZING"
argument_list|)
expr_stmt|;
name|ADD_FLAG
argument_list|(
name|G_RAID3_DISK_FLAG_FORCE_SYNC
argument_list|,
literal|"FORCE_SYNC"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ADD_FLAG
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</Flags>\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<State>%s</State>\n"
argument_list|,
name|indent
argument_list|,
name|g_raid3_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<ID>%u</ID>\n"
argument_list|,
name|indent
argument_list|,
operator|(
name|u_int
operator|)
name|sc
operator|->
name|sc_id
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<SyncID>%u</SyncID>\n"
argument_list|,
name|indent
argument_list|,
name|sc
operator|->
name|sc_syncid
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Flags>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|==
literal|0
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"NONE"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
define|#
directive|define
name|ADD_FLAG
parameter_list|(
name|flag
parameter_list|,
name|name
parameter_list|)
value|do {					\ 	if ((sc->sc_flags& (flag)) != 0) {				\ 		if (!first)						\ 			sbuf_printf(sb, ", ");				\ 		else							\ 			first = 0;					\ 		sbuf_printf(sb, name);					\ 	}								\ } while (0)
name|ADD_FLAG
argument_list|(
name|G_RAID3_DEVICE_FLAG_NOAUTOSYNC
argument_list|,
literal|"NOAUTOSYNC"
argument_list|)
expr_stmt|;
name|ADD_FLAG
argument_list|(
name|G_RAID3_DEVICE_FLAG_ROUND_ROBIN
argument_list|,
literal|"ROUND-ROBIN"
argument_list|)
expr_stmt|;
name|ADD_FLAG
argument_list|(
name|G_RAID3_DEVICE_FLAG_VERIFY
argument_list|,
literal|"VERIFY"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ADD_FLAG
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</Flags>\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Components>%u</Components>\n"
argument_list|,
name|indent
argument_list|,
name|sc
operator|->
name|sc_ndisks
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<State>%s</State>\n"
argument_list|,
name|indent
argument_list|,
name|g_raid3_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_shutdown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
block|{
name|struct
name|g_class
modifier|*
name|mp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|,
modifier|*
name|gp2
decl_stmt|;
name|mp
operator|=
name|arg
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|gp
argument_list|,
argument|&mp->geom
argument_list|,
argument|geom
argument_list|,
argument|gp2
argument_list|)
block|{
if|if
condition|(
name|gp
operator|->
name|softc
operator|==
name|NULL
condition|)
continue|continue;
name|g_raid3_destroy
argument_list|(
name|gp
operator|->
name|softc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|tsleep(&gp, PRIBIO, "r3:shutdown", hz * 20);
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_init
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
block|{
name|g_raid3_ehtag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_post_sync
argument_list|,
name|g_raid3_shutdown
argument_list|,
name|mp
argument_list|,
name|SHUTDOWN_PRI_FIRST
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_raid3_ehtag
operator|==
name|NULL
condition|)
name|G_RAID3_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Warning! Cannot register shutdown event."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid3_fini
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
block|{
if|if
condition|(
name|g_raid3_ehtag
operator|==
name|NULL
condition|)
return|return;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|shutdown_post_sync
argument_list|,
name|g_raid3_ehtag
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|DECLARE_GEOM_CLASS
argument_list|(
name|g_raid3_class
argument_list|,
name|g_raid3
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

