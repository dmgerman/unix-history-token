begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004-2006 Pawel Jakub Dawidek<pjd@FreeBSD.org>  * Copyright (c) 2009-2010 The FreeBSD Foundation  * All rights reserved.  *  * Portions of this software were developed by Pawel Jakub Dawidek  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/gate/g_gate.h>
end_include

begin_expr_stmt
name|FEATURE
argument_list|(
name|geom_gate
argument_list|,
literal|"GEOM Gate module"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_GATE
argument_list|,
literal|"gg_data"
argument_list|,
literal|"GEOM Gate Data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_kern_geom
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_kern_geom
argument_list|,
name|OID_AUTO
argument_list|,
name|gate
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"GEOM_GATE configuration"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|g_gate_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_geom_gate
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|g_gate_debug
argument_list|,
literal|0
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_gate_maxunits
init|=
literal|256
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_gate
argument_list|,
name|OID_AUTO
argument_list|,
name|maxunits
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|g_gate_maxunits
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of ggate devices"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|g_class
name|g_gate_class
init|=
block|{
operator|.
name|name
operator|=
name|G_GATE_CLASS_NAME
block|,
operator|.
name|version
operator|=
name|G_VERSION
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdev
modifier|*
name|status_dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|g_gate_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|g_gate_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_ioctl
operator|=
name|g_gate_ioctl
block|,
operator|.
name|d_name
operator|=
name|G_GATE_CTL_NAME
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|g_gate_softc
modifier|*
modifier|*
name|g_gate_units
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_gate_nunits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|g_gate_units_lock
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|g_gate_destroy
parameter_list|(
name|struct
name|g_gate_softc
modifier|*
name|sc
parameter_list|,
name|boolean_t
name|force
parameter_list|)
block|{
name|struct
name|bio_queue_head
name|queue
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|g_gate_units_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|pp
operator|=
name|sc
operator|->
name|sc_provider
expr_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
operator|(
name|pp
operator|->
name|acr
operator|!=
literal|0
operator|||
name|pp
operator|->
name|acw
operator|!=
literal|0
operator|||
name|pp
operator|->
name|ace
operator|!=
literal|0
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|g_gate_units_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|g_gate_units_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_GATE_FLAG_DESTROY
operator|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|G_GATE_FLAG_DESTROY
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|gp
operator|=
name|pp
operator|->
name|geom
expr_stmt|;
name|pp
operator|->
name|flags
operator||=
name|G_PF_WITHER
expr_stmt|;
name|g_orphan_provider
argument_list|(
name|pp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|)
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|queue
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|sc
operator|->
name|sc_inqueue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_queue_count
operator|--
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|bp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|sc
operator|->
name|sc_outqueue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_queue_count
operator|--
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|G_GATE_LOGREQ
argument_list|(
literal|1
argument_list|,
name|bp
argument_list|,
literal|"Request canceled."
argument_list|)
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|g_gate_units_lock
argument_list|)
expr_stmt|;
comment|/* One reference is ours. */
name|sc
operator|->
name|sc_ref
operator|--
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|sc_ref
operator|>
literal|0
condition|)
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_ref
argument_list|,
operator|&
name|g_gate_units_lock
argument_list|,
literal|0
argument_list|,
literal|"gg:destroy"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_gate_units
index|[
name|sc
operator|->
name|sc_unit
index|]
operator|=
name|NULL
expr_stmt|;
name|KASSERT
argument_list|(
name|g_gate_nunits
operator|>
literal|0
argument_list|,
operator|(
literal|"negative g_gate_nunits?"
operator|)
argument_list|)
expr_stmt|;
name|g_gate_nunits
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|g_gate_units_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|sc
operator|->
name|sc_readcons
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_readcons
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|G_GATE_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Device %s destroyed."
argument_list|,
name|gp
operator|->
name|name
argument_list|)
expr_stmt|;
name|gp
operator|->
name|softc
operator|=
name|NULL
expr_stmt|;
name|g_wither_geom
argument_list|(
name|gp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_provider
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_GATE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_gate_access
parameter_list|(
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|dr
parameter_list|,
name|int
name|dw
parameter_list|,
name|int
name|de
parameter_list|)
block|{
name|struct
name|g_gate_softc
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
name|dr
operator|<=
literal|0
operator|&&
name|dw
operator|<=
literal|0
operator|&&
name|de
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|=
name|pp
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_GATE_FLAG_DESTROY
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* XXX: Hack to allow read-only mounts. */
if|#
directive|if
literal|0
block|if ((sc->sc_flags& G_GATE_FLAG_READONLY) != 0&& dw> 0) 		return (EPERM);
endif|#
directive|endif
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_GATE_FLAG_WRITEONLY
operator|)
operator|!=
literal|0
operator|&&
name|dr
operator|>
literal|0
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_gate_queue_io
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_gate_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_GATE_FLAG_DESTROY
operator|)
operator|!=
literal|0
condition|)
block|{
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
return|return;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_queue_size
operator|>
literal|0
operator|&&
name|sc
operator|->
name|sc_queue_count
operator|>
name|sc
operator|->
name|sc_queue_size
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|G_GATE_LOGREQ
argument_list|(
literal|1
argument_list|,
name|bp
argument_list|,
literal|"Queue full, request canceled."
argument_list|)
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|->
name|bio_driver1
operator|=
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|sc_seq
expr_stmt|;
name|sc
operator|->
name|sc_seq
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_queue_count
operator|++
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|sc
operator|->
name|sc_inqueue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_gate_done
parameter_list|(
name|struct
name|bio
modifier|*
name|cbp
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|pbp
decl_stmt|;
name|pbp
operator|=
name|cbp
operator|->
name|bio_parent
expr_stmt|;
if|if
condition|(
name|cbp
operator|->
name|bio_error
operator|==
literal|0
condition|)
block|{
name|pbp
operator|->
name|bio_completed
operator|=
name|cbp
operator|->
name|bio_completed
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
name|pbp
operator|->
name|bio_inbed
operator|++
expr_stmt|;
name|g_io_deliver
argument_list|(
name|pbp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If direct read failed, pass it through userland daemon. */
name|g_destroy_bio
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
name|pbp
operator|->
name|bio_children
operator|--
expr_stmt|;
name|g_gate_queue_io
argument_list|(
name|pbp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_gate_start
parameter_list|(
name|struct
name|bio
modifier|*
name|pbp
parameter_list|)
block|{
name|struct
name|g_gate_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|pbp
operator|->
name|bio_to
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_GATE_FLAG_DESTROY
operator|)
operator|!=
literal|0
condition|)
block|{
name|g_io_deliver
argument_list|(
name|pbp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
return|return;
block|}
name|G_GATE_LOGREQ
argument_list|(
literal|2
argument_list|,
name|pbp
argument_list|,
literal|"Request received."
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pbp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
if|if
condition|(
name|sc
operator|->
name|sc_readcons
operator|!=
name|NULL
condition|)
block|{
name|struct
name|bio
modifier|*
name|cbp
decl_stmt|;
name|cbp
operator|=
name|g_clone_bio
argument_list|(
name|pbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|==
name|NULL
condition|)
block|{
name|g_io_deliver
argument_list|(
name|pbp
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return;
block|}
name|cbp
operator|->
name|bio_done
operator|=
name|g_gate_done
expr_stmt|;
name|cbp
operator|->
name|bio_offset
operator|=
name|pbp
operator|->
name|bio_offset
operator|+
name|sc
operator|->
name|sc_readoffset
expr_stmt|;
name|cbp
operator|->
name|bio_to
operator|=
name|sc
operator|->
name|sc_readcons
operator|->
name|provider
expr_stmt|;
name|g_io_request
argument_list|(
name|cbp
argument_list|,
name|sc
operator|->
name|sc_readcons
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|BIO_DELETE
case|:
case|case
name|BIO_WRITE
case|:
case|case
name|BIO_FLUSH
case|:
comment|/* XXX: Hack to allow read-only mounts. */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_GATE_FLAG_READONLY
operator|)
operator|!=
literal|0
condition|)
block|{
name|g_io_deliver
argument_list|(
name|pbp
argument_list|,
name|EPERM
argument_list|)
expr_stmt|;
return|return;
block|}
break|break;
case|case
name|BIO_GETATTR
case|:
default|default:
name|G_GATE_LOGREQ
argument_list|(
literal|2
argument_list|,
name|pbp
argument_list|,
literal|"Ignoring request."
argument_list|)
expr_stmt|;
name|g_io_deliver
argument_list|(
name|pbp
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
return|return;
block|}
name|g_gate_queue_io
argument_list|(
name|pbp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|g_gate_softc
modifier|*
name|g_gate_hold
parameter_list|(
name|int
name|unit
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|g_gate_softc
modifier|*
name|sc
init|=
name|NULL
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|g_gate_units_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
literal|0
operator|&&
name|unit
operator|<
name|g_gate_maxunits
condition|)
name|sc
operator|=
name|g_gate_units
index|[
name|unit
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|unit
operator|==
name|G_GATE_NAME_GIVEN
condition|)
block|{
name|KASSERT
argument_list|(
name|name
operator|!=
name|NULL
argument_list|,
operator|(
literal|"name is NULL"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|g_gate_maxunits
condition|;
name|unit
operator|++
control|)
block|{
if|if
condition|(
name|g_gate_units
index|[
name|unit
index|]
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|g_gate_units
index|[
name|unit
index|]
operator|->
name|sc_provider
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
name|sc
operator|=
name|g_gate_units
index|[
name|unit
index|]
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|sc_ref
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|g_gate_units_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_gate_release
parameter_list|(
name|struct
name|g_gate_softc
modifier|*
name|sc
parameter_list|)
block|{
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|g_gate_units_lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ref
operator|--
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_ref
operator|>=
literal|0
argument_list|,
operator|(
literal|"Negative sc_ref for %s."
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ref
operator|==
literal|0
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_GATE_FLAG_DESTROY
operator|)
operator|!=
literal|0
condition|)
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_ref
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|g_gate_units_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_gate_getunit
parameter_list|(
name|int
name|unit
parameter_list|,
name|int
modifier|*
name|errorp
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|g_gate_units_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|unit
operator|>=
name|g_gate_maxunits
condition|)
operator|*
name|errorp
operator|=
name|EINVAL
expr_stmt|;
elseif|else
if|if
condition|(
name|g_gate_units
index|[
name|unit
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
name|unit
operator|)
return|;
else|else
operator|*
name|errorp
operator|=
name|EEXIST
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|g_gate_maxunits
condition|;
name|unit
operator|++
control|)
block|{
if|if
condition|(
name|g_gate_units
index|[
name|unit
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
name|unit
operator|)
return|;
block|}
operator|*
name|errorp
operator|=
name|ENFILE
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_gate_guard
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|bio_queue_head
name|queue
decl_stmt|;
name|struct
name|g_gate_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bintime
name|curtime
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|,
modifier|*
name|bp2
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|curtime
argument_list|)
expr_stmt|;
name|g_gate_hold
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|queue
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|bp
argument_list|,
argument|&sc->sc_inqueue.queue
argument_list|,
argument|bio_queue
argument_list|,
argument|bp2
argument_list|)
block|{
if|if
condition|(
name|curtime
operator|.
name|sec
operator|-
name|bp
operator|->
name|bio_t0
operator|.
name|sec
operator|<
literal|5
condition|)
continue|continue;
name|bioq_remove
argument_list|(
operator|&
name|sc
operator|->
name|sc_inqueue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_queue_count
operator|--
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|bp
argument_list|,
argument|&sc->sc_outqueue.queue
argument_list|,
argument|bio_queue
argument_list|,
argument|bp2
argument_list|)
block|{
if|if
condition|(
name|curtime
operator|.
name|sec
operator|-
name|bp
operator|->
name|bio_t0
operator|.
name|sec
operator|<
literal|5
condition|)
continue|continue;
name|bioq_remove
argument_list|(
operator|&
name|sc
operator|->
name|sc_outqueue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_queue_count
operator|--
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|G_GATE_LOGREQ
argument_list|(
literal|1
argument_list|,
name|bp
argument_list|,
literal|"Request timeout."
argument_list|)
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_GATE_FLAG_DESTROY
operator|)
operator|==
literal|0
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|,
name|sc
operator|->
name|sc_timeout
operator|*
name|hz
argument_list|,
name|g_gate_guard
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
name|g_gate_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_gate_orphan
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_gate_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|gp
operator|=
name|cp
operator|->
name|geom
expr_stmt|;
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|KASSERT
argument_list|(
name|cp
operator|==
name|sc
operator|->
name|sc_readcons
argument_list|,
operator|(
literal|"cp=%p sc_readcons=%p"
operator|,
name|cp
operator|,
name|sc
operator|->
name|sc_readcons
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_readcons
operator|=
name|NULL
expr_stmt|;
name|G_GATE_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Destroying read consumer on provider %s orphan."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_gate_dumpconf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|)
block|{
name|struct
name|g_gate_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|pp
operator|!=
name|NULL
operator|||
name|cp
operator|!=
name|NULL
condition|)
return|return;
name|sc
operator|=
name|g_gate_hold
argument_list|(
name|sc
operator|->
name|sc_unit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_GATE_FLAG_READONLY
operator|)
operator|!=
literal|0
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<access>%s</access>\n"
argument_list|,
name|indent
argument_list|,
literal|"read-only"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_GATE_FLAG_WRITEONLY
operator|)
operator|!=
literal|0
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<access>%s</access>\n"
argument_list|,
name|indent
argument_list|,
literal|"write-only"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<access>%s</access>\n"
argument_list|,
name|indent
argument_list|,
literal|"read-write"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_readcons
operator|!=
name|NULL
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<read_offset>%jd</read_offset>\n"
argument_list|,
name|indent
argument_list|,
operator|(
name|intmax_t
operator|)
name|sc
operator|->
name|sc_readoffset
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<read_provider>%s</read_provider>\n"
argument_list|,
name|indent
argument_list|,
name|sc
operator|->
name|sc_readcons
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<timeout>%u</timeout>\n"
argument_list|,
name|indent
argument_list|,
name|sc
operator|->
name|sc_timeout
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<info>%s</info>\n"
argument_list|,
name|indent
argument_list|,
name|sc
operator|->
name|sc_info
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<queue_count>%u</queue_count>\n"
argument_list|,
name|indent
argument_list|,
name|sc
operator|->
name|sc_queue_count
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<queue_size>%u</queue_size>\n"
argument_list|,
name|indent
argument_list|,
name|sc
operator|->
name|sc_queue_size
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<ref>%u</ref>\n"
argument_list|,
name|indent
argument_list|,
name|sc
operator|->
name|sc_ref
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<unit>%d</unit>\n"
argument_list|,
name|indent
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|g_gate_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_gate_create
parameter_list|(
name|struct
name|g_gate_ctl_create
modifier|*
name|ggio
parameter_list|)
block|{
name|struct
name|g_gate_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|,
modifier|*
name|ropp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|char
name|name
index|[
name|NAME_MAX
index|]
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|unit
decl_stmt|;
if|if
condition|(
name|ggio
operator|->
name|gctl_mediasize
operator|<=
literal|0
condition|)
block|{
name|G_GATE_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid media size."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|ggio
operator|->
name|gctl_sectorsize
operator|<=
literal|0
condition|)
block|{
name|G_GATE_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid sector size."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|powerof2
argument_list|(
name|ggio
operator|->
name|gctl_sectorsize
argument_list|)
condition|)
block|{
name|G_GATE_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid sector size."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ggio
operator|->
name|gctl_mediasize
operator|%
name|ggio
operator|->
name|gctl_sectorsize
operator|)
operator|!=
literal|0
condition|)
block|{
name|G_GATE_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid media size."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ggio
operator|->
name|gctl_flags
operator|&
name|G_GATE_FLAG_READONLY
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ggio
operator|->
name|gctl_flags
operator|&
name|G_GATE_FLAG_WRITEONLY
operator|)
operator|!=
literal|0
condition|)
block|{
name|G_GATE_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid flags."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|ggio
operator|->
name|gctl_unit
operator|!=
name|G_GATE_UNIT_AUTO
operator|&&
name|ggio
operator|->
name|gctl_unit
operator|!=
name|G_GATE_NAME_GIVEN
operator|&&
name|ggio
operator|->
name|gctl_unit
operator|<
literal|0
condition|)
block|{
name|G_GATE_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid unit number."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|ggio
operator|->
name|gctl_unit
operator|==
name|G_GATE_NAME_GIVEN
operator|&&
name|ggio
operator|->
name|gctl_name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|G_GATE_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"No device name."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_GATE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
operator|(
name|ggio
operator|->
name|gctl_flags
operator|&
name|G_GATE_USERFLAGS
operator|)
expr_stmt|;
name|strlcpy
argument_list|(
name|sc
operator|->
name|sc_info
argument_list|,
name|ggio
operator|->
name|gctl_info
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_info
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_seq
operator|=
literal|1
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_inqueue
argument_list|)
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_outqueue
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|,
literal|"gg:queue"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_queue_count
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_queue_size
operator|=
name|ggio
operator|->
name|gctl_maxcount
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_queue_size
operator|>
name|G_GATE_MAX_QUEUE_SIZE
condition|)
name|sc
operator|->
name|sc_queue_size
operator|=
name|G_GATE_MAX_QUEUE_SIZE
expr_stmt|;
name|sc
operator|->
name|sc_timeout
operator|=
name|ggio
operator|->
name|gctl_timeout
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|g_gate_units_lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_unit
operator|=
name|g_gate_getunit
argument_list|(
name|ggio
operator|->
name|gctl_unit
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_unit
operator|<
literal|0
condition|)
goto|goto
name|fail1
goto|;
if|if
condition|(
name|ggio
operator|->
name|gctl_unit
operator|==
name|G_GATE_NAME_GIVEN
condition|)
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
name|ggio
operator|->
name|gctl_name
argument_list|)
expr_stmt|;
else|else
block|{
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|G_GATE_PROVIDER_NAME
argument_list|,
name|sc
operator|->
name|sc_unit
argument_list|)
expr_stmt|;
block|}
comment|/* Check for name collision. */
for|for
control|(
name|unit
operator|=
literal|0
init|;
name|unit
operator|<
name|g_gate_maxunits
condition|;
name|unit
operator|++
control|)
block|{
if|if
condition|(
name|g_gate_units
index|[
name|unit
index|]
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|g_gate_units
index|[
name|unit
index|]
operator|->
name|sc_name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|error
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|sc
operator|->
name|sc_name
operator|=
name|name
expr_stmt|;
name|g_gate_units
index|[
name|sc
operator|->
name|sc_unit
index|]
operator|=
name|sc
expr_stmt|;
name|g_gate_nunits
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|g_gate_units_lock
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|ggio
operator|->
name|gctl_readprov
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|ropp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ropp
operator|=
name|g_provider_by_name
argument_list|(
name|ggio
operator|->
name|gctl_readprov
argument_list|)
expr_stmt|;
if|if
condition|(
name|ropp
operator|==
name|NULL
condition|)
block|{
name|G_GATE_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Provider %s doesn't exist."
argument_list|,
name|ggio
operator|->
name|gctl_readprov
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
operator|(
name|ggio
operator|->
name|gctl_readoffset
operator|%
name|ggio
operator|->
name|gctl_sectorsize
operator|)
operator|!=
literal|0
condition|)
block|{
name|G_GATE_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid read offset."
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
if|if
condition|(
name|ggio
operator|->
name|gctl_mediasize
operator|+
name|ggio
operator|->
name|gctl_readoffset
operator|>
name|ropp
operator|->
name|mediasize
condition|)
block|{
name|G_GATE_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid read offset or media size."
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
block|}
name|gp
operator|=
name|g_new_geomf
argument_list|(
operator|&
name|g_gate_class
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gp
operator|->
name|start
operator|=
name|g_gate_start
expr_stmt|;
name|gp
operator|->
name|access
operator|=
name|g_gate_access
expr_stmt|;
name|gp
operator|->
name|orphan
operator|=
name|g_gate_orphan
expr_stmt|;
name|gp
operator|->
name|dumpconf
operator|=
name|g_gate_dumpconf
expr_stmt|;
name|gp
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
if|if
condition|(
name|ropp
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
name|g_new_consumer
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|flags
operator||=
name|G_CF_DIRECT_SEND
operator||
name|G_CF_DIRECT_RECEIVE
expr_stmt|;
name|error
operator|=
name|g_attach
argument_list|(
name|cp
argument_list|,
name|ropp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_GATE_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Unable to attach to %s."
argument_list|,
name|ropp
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_GATE_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Unable to access %s."
argument_list|,
name|ropp
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
goto|goto
name|fail3
goto|;
block|}
name|sc
operator|->
name|sc_readcons
operator|=
name|cp
expr_stmt|;
name|sc
operator|->
name|sc_readoffset
operator|=
name|ggio
operator|->
name|gctl_readoffset
expr_stmt|;
block|}
name|ggio
operator|->
name|gctl_unit
operator|=
name|sc
operator|->
name|sc_unit
expr_stmt|;
name|pp
operator|=
name|g_new_providerf
argument_list|(
name|gp
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pp
operator|->
name|flags
operator||=
name|G_PF_DIRECT_SEND
operator||
name|G_PF_DIRECT_RECEIVE
expr_stmt|;
name|pp
operator|->
name|mediasize
operator|=
name|ggio
operator|->
name|gctl_mediasize
expr_stmt|;
name|pp
operator|->
name|sectorsize
operator|=
name|ggio
operator|->
name|gctl_sectorsize
expr_stmt|;
name|sc
operator|->
name|sc_provider
operator|=
name|pp
expr_stmt|;
name|g_error_provider
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|g_gate_units_lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_name
operator|=
name|sc
operator|->
name|sc_provider
operator|->
name|name
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|g_gate_units_lock
argument_list|)
expr_stmt|;
name|G_GATE_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Device %s created."
argument_list|,
name|gp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_timeout
operator|>
literal|0
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|,
name|sc
operator|->
name|sc_timeout
operator|*
name|hz
argument_list|,
name|g_gate_guard
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail3
label|:
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_geom
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|fail2
label|:
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|g_gate_units_lock
argument_list|)
expr_stmt|;
name|g_gate_units
index|[
name|sc
operator|->
name|sc_unit
index|]
operator|=
name|NULL
expr_stmt|;
name|KASSERT
argument_list|(
name|g_gate_nunits
operator|>
literal|0
argument_list|,
operator|(
literal|"negative g_gate_nunits?"
operator|)
argument_list|)
expr_stmt|;
name|g_gate_nunits
operator|--
expr_stmt|;
name|fail1
label|:
name|mtx_unlock
argument_list|(
operator|&
name|g_gate_units_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_GATE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_gate_modify
parameter_list|(
name|struct
name|g_gate_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_gate_ctl_modify
modifier|*
name|ggio
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|ggio
operator|->
name|gctl_modify
operator|&
name|GG_MODIFY_MEDIASIZE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ggio
operator|->
name|gctl_mediasize
operator|<=
literal|0
condition|)
block|{
name|G_GATE_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid media size."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|pp
operator|=
name|sc
operator|->
name|sc_provider
expr_stmt|;
if|if
condition|(
operator|(
name|ggio
operator|->
name|gctl_mediasize
operator|%
name|pp
operator|->
name|sectorsize
operator|)
operator|!=
literal|0
condition|)
block|{
name|G_GATE_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid media size."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* TODO */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ggio
operator|->
name|gctl_modify
operator|&
name|GG_MODIFY_INFO
operator|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|sc
operator|->
name|sc_info
argument_list|,
name|ggio
operator|->
name|gctl_info
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_info
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|ggio
operator|->
name|gctl_modify
operator|&
name|GG_MODIFY_READPROV
operator|)
operator|!=
literal|0
condition|)
block|{
name|g_topology_lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_readcons
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
name|sc
operator|->
name|sc_readcons
expr_stmt|;
name|sc
operator|->
name|sc_readcons
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ggio
operator|->
name|gctl_readprov
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|pp
operator|=
name|g_provider_by_name
argument_list|(
name|ggio
operator|->
name|gctl_readprov
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
block|{
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|G_GATE_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Provider %s doesn't exist."
argument_list|,
name|ggio
operator|->
name|gctl_readprov
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|cp
operator|=
name|g_new_consumer
argument_list|(
name|sc
operator|->
name|sc_provider
operator|->
name|geom
argument_list|)
expr_stmt|;
name|cp
operator|->
name|flags
operator||=
name|G_CF_DIRECT_SEND
operator||
name|G_CF_DIRECT_RECEIVE
expr_stmt|;
name|error
operator|=
name|g_attach
argument_list|(
name|cp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_GATE_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Unable to attach to %s."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_GATE_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Unable to access %s."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
name|cp
operator|=
name|sc
operator|->
name|sc_readcons
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ggio
operator|->
name|gctl_modify
operator|&
name|GG_MODIFY_READOFFSET
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|G_GATE_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"No read provider."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|pp
operator|=
name|sc
operator|->
name|sc_provider
expr_stmt|;
if|if
condition|(
operator|(
name|ggio
operator|->
name|gctl_readoffset
operator|%
name|pp
operator|->
name|sectorsize
operator|)
operator|!=
literal|0
condition|)
block|{
name|G_GATE_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid read offset."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|pp
operator|->
name|mediasize
operator|+
name|ggio
operator|->
name|gctl_readoffset
operator|>
name|cp
operator|->
name|provider
operator|->
name|mediasize
condition|)
block|{
name|G_GATE_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid read offset or media size."
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sc
operator|->
name|sc_readoffset
operator|=
name|ggio
operator|->
name|gctl_readoffset
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ggio
operator|->
name|gctl_modify
operator|&
name|GG_MODIFY_READPROV
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_readcons
operator|=
name|cp
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|G_GATE_CHECK_VERSION
parameter_list|(
name|ggio
parameter_list|)
value|do {				\ 	if ((ggio)->gctl_version != G_GATE_VERSION) {			\ 		printf("Version mismatch %d != %d.\n",			\ 		    ggio->gctl_version, G_GATE_VERSION);		\ 		return (EINVAL);					\ 	}								\ } while (0)
end_define

begin_function
specifier|static
name|int
name|g_gate_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|g_gate_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|G_GATE_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"ioctl(%s, %lx, %p, %x, %p)"
argument_list|,
name|devtoname
argument_list|(
name|dev
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flags
argument_list|,
name|td
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|G_GATE_CMD_CREATE
case|:
block|{
name|struct
name|g_gate_ctl_create
modifier|*
name|ggio
init|=
operator|(
name|void
operator|*
operator|)
name|addr
decl_stmt|;
name|G_GATE_CHECK_VERSION
argument_list|(
name|ggio
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_gate_create
argument_list|(
name|ggio
argument_list|)
expr_stmt|;
comment|/* 		 * Reset TDP_GEOM flag. 		 * There are pending events for sure, because we just created 		 * new provider and other classes want to taste it, but we 		 * cannot answer on I/O requests until we're here. 		 */
name|td
operator|->
name|td_pflags
operator|&=
operator|~
name|TDP_GEOM
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|G_GATE_CMD_MODIFY
case|:
block|{
name|struct
name|g_gate_ctl_modify
modifier|*
name|ggio
init|=
operator|(
name|void
operator|*
operator|)
name|addr
decl_stmt|;
name|G_GATE_CHECK_VERSION
argument_list|(
name|ggio
argument_list|)
expr_stmt|;
name|sc
operator|=
name|g_gate_hold
argument_list|(
name|ggio
operator|->
name|gctl_unit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|error
operator|=
name|g_gate_modify
argument_list|(
name|sc
argument_list|,
name|ggio
argument_list|)
expr_stmt|;
name|g_gate_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|G_GATE_CMD_DESTROY
case|:
block|{
name|struct
name|g_gate_ctl_destroy
modifier|*
name|ggio
init|=
operator|(
name|void
operator|*
operator|)
name|addr
decl_stmt|;
name|G_GATE_CHECK_VERSION
argument_list|(
name|ggio
argument_list|)
expr_stmt|;
name|sc
operator|=
name|g_gate_hold
argument_list|(
name|ggio
operator|->
name|gctl_unit
argument_list|,
name|ggio
operator|->
name|gctl_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|g_gate_units_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_gate_destroy
argument_list|(
name|sc
argument_list|,
name|ggio
operator|->
name|gctl_force
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|g_gate_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|G_GATE_CMD_CANCEL
case|:
block|{
name|struct
name|g_gate_ctl_cancel
modifier|*
name|ggio
init|=
operator|(
name|void
operator|*
operator|)
name|addr
decl_stmt|;
name|struct
name|bio
modifier|*
name|tbp
decl_stmt|,
modifier|*
name|lbp
decl_stmt|;
name|G_GATE_CHECK_VERSION
argument_list|(
name|ggio
argument_list|)
expr_stmt|;
name|sc
operator|=
name|g_gate_hold
argument_list|(
name|ggio
operator|->
name|gctl_unit
argument_list|,
name|ggio
operator|->
name|gctl_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|lbp
operator|=
name|NULL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|bp
argument_list|,
argument|&sc->sc_outqueue.queue
argument_list|,
argument|bio_queue
argument_list|,
argument|tbp
argument_list|)
block|{
if|if
condition|(
name|ggio
operator|->
name|gctl_seq
operator|==
literal|0
operator|||
name|ggio
operator|->
name|gctl_seq
operator|==
operator|(
name|uintptr_t
operator|)
name|bp
operator|->
name|bio_driver1
condition|)
block|{
name|G_GATE_LOGREQ
argument_list|(
literal|1
argument_list|,
name|bp
argument_list|,
literal|"Request canceled."
argument_list|)
expr_stmt|;
name|bioq_remove
argument_list|(
operator|&
name|sc
operator|->
name|sc_outqueue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 				 * Be sure to put requests back onto incoming 				 * queue in the proper order. 				 */
if|if
condition|(
name|lbp
operator|==
name|NULL
condition|)
name|bioq_insert_head
argument_list|(
operator|&
name|sc
operator|->
name|sc_inqueue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
else|else
block|{
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|sc
operator|->
name|sc_inqueue
operator|.
name|queue
argument_list|,
name|lbp
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
block|}
name|lbp
operator|=
name|bp
expr_stmt|;
comment|/* 				 * If only one request was canceled, leave now. 				 */
if|if
condition|(
name|ggio
operator|->
name|gctl_seq
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|ggio
operator|->
name|gctl_unit
operator|==
name|G_GATE_NAME_GIVEN
condition|)
name|ggio
operator|->
name|gctl_unit
operator|=
name|sc
operator|->
name|sc_unit
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|g_gate_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|G_GATE_CMD_START
case|:
block|{
name|struct
name|g_gate_ctl_io
modifier|*
name|ggio
init|=
operator|(
name|void
operator|*
operator|)
name|addr
decl_stmt|;
name|G_GATE_CHECK_VERSION
argument_list|(
name|ggio
argument_list|)
expr_stmt|;
name|sc
operator|=
name|g_gate_hold
argument_list|(
name|ggio
operator|->
name|gctl_unit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|sc
operator|->
name|sc_inqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_GATE_FLAG_DESTROY
operator|)
operator|!=
literal|0
condition|)
block|{
name|ggio
operator|->
name|gctl_error
operator|=
name|ECANCELED
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
goto|goto
name|start_end
goto|;
block|}
if|if
condition|(
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|,
name|PPAUSE
operator||
name|PDROP
operator||
name|PCATCH
argument_list|,
literal|"ggwait"
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ggio
operator|->
name|gctl_error
operator|=
name|ECANCELED
expr_stmt|;
goto|goto
name|start_end
goto|;
block|}
block|}
name|ggio
operator|->
name|gctl_cmd
operator|=
name|bp
operator|->
name|bio_cmd
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
operator|&&
name|bp
operator|->
name|bio_length
operator|>
name|ggio
operator|->
name|gctl_length
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|ggio
operator|->
name|gctl_length
operator|=
name|bp
operator|->
name|bio_length
expr_stmt|;
name|ggio
operator|->
name|gctl_error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|start_end
goto|;
block|}
name|bioq_remove
argument_list|(
operator|&
name|sc
operator|->
name|sc_inqueue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|sc
operator|->
name|sc_outqueue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|ggio
operator|->
name|gctl_seq
operator|=
operator|(
name|uintptr_t
operator|)
name|bp
operator|->
name|bio_driver1
expr_stmt|;
name|ggio
operator|->
name|gctl_offset
operator|=
name|bp
operator|->
name|bio_offset
expr_stmt|;
name|ggio
operator|->
name|gctl_length
operator|=
name|bp
operator|->
name|bio_length
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
case|case
name|BIO_DELETE
case|:
case|case
name|BIO_FLUSH
case|:
break|break;
case|case
name|BIO_WRITE
case|:
name|error
operator|=
name|copyout
argument_list|(
name|bp
operator|->
name|bio_data
argument_list|,
name|ggio
operator|->
name|gctl_data
argument_list|,
name|bp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|bioq_remove
argument_list|(
operator|&
name|sc
operator|->
name|sc_outqueue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bioq_insert_head
argument_list|(
operator|&
name|sc
operator|->
name|sc_inqueue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
goto|goto
name|start_end
goto|;
block|}
break|break;
block|}
name|start_end
label|:
name|g_gate_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|G_GATE_CMD_DONE
case|:
block|{
name|struct
name|g_gate_ctl_io
modifier|*
name|ggio
init|=
operator|(
name|void
operator|*
operator|)
name|addr
decl_stmt|;
name|G_GATE_CHECK_VERSION
argument_list|(
name|ggio
argument_list|)
expr_stmt|;
name|sc
operator|=
name|g_gate_hold
argument_list|(
name|ggio
operator|->
name|gctl_unit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&sc->sc_outqueue.queue
argument_list|,
argument|bio_queue
argument_list|)
block|{
if|if
condition|(
name|ggio
operator|->
name|gctl_seq
operator|==
operator|(
name|uintptr_t
operator|)
name|bp
operator|->
name|bio_driver1
condition|)
break|break;
block|}
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|bioq_remove
argument_list|(
operator|&
name|sc
operator|->
name|sc_outqueue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_queue_count
operator|--
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Request was probably canceled. 			 */
goto|goto
name|done_end
goto|;
block|}
if|if
condition|(
name|ggio
operator|->
name|gctl_error
operator|==
name|EAGAIN
condition|)
block|{
name|bp
operator|->
name|bio_error
operator|=
literal|0
expr_stmt|;
name|G_GATE_LOGREQ
argument_list|(
literal|1
argument_list|,
name|bp
argument_list|,
literal|"Request desisted."
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_queue_count
operator|++
expr_stmt|;
name|bioq_insert_head
argument_list|(
operator|&
name|sc
operator|->
name|sc_inqueue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|bio_error
operator|=
name|ggio
operator|->
name|gctl_error
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|bio_completed
operator|=
name|bp
operator|->
name|bio_length
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
name|error
operator|=
name|copyin
argument_list|(
name|ggio
operator|->
name|gctl_data
argument_list|,
name|bp
operator|->
name|bio_data
argument_list|,
name|bp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|error
expr_stmt|;
break|break;
case|case
name|BIO_DELETE
case|:
case|case
name|BIO_WRITE
case|:
case|case
name|BIO_FLUSH
case|:
break|break;
block|}
block|}
name|G_GATE_LOGREQ
argument_list|(
literal|2
argument_list|,
name|bp
argument_list|,
literal|"Request done."
argument_list|)
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
block|}
name|done_end
label|:
name|g_gate_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ENOIOCTL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_gate_device
parameter_list|(
name|void
parameter_list|)
block|{
name|status_dev
operator|=
name|make_dev
argument_list|(
operator|&
name|g_gate_cdevsw
argument_list|,
literal|0x0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
name|G_GATE_CTL_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_gate_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|mtx_init
argument_list|(
operator|&
name|g_gate_units_lock
argument_list|,
literal|"gg_units_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|g_gate_units
operator|=
name|malloc
argument_list|(
name|g_gate_maxunits
operator|*
sizeof|sizeof
argument_list|(
name|g_gate_units
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|M_GATE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|g_gate_nunits
operator|=
literal|0
expr_stmt|;
name|g_gate_device
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|mtx_lock
argument_list|(
operator|&
name|g_gate_units_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_gate_nunits
operator|>
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|g_gate_units_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|g_gate_units_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|g_gate_units_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|status_dev
operator|!=
literal|0
condition|)
name|destroy_dev
argument_list|(
name|status_dev
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|g_gate_units
argument_list|,
name|M_GATE
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|g_gate_module
init|=
block|{
name|G_GATE_MOD_NAME
block|,
name|g_gate_modevent
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|geom_gate
argument_list|,
name|g_gate_module
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_GEOM_CLASS
argument_list|(
name|g_gate_class
argument_list|,
name|g_gate
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

