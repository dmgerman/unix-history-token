begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004 Lukas Ertl  * Copyright (c) 1997, 1998, 1999  *      Nan Yang Computer Services Limited.  All rights reserved.  *  *  Parts written by Greg Lehey  *  *  This software is distributed under the so-called ``Berkeley  *  License'':  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Nan Yang Computer  *      Services Limited.  * 4. Neither the name of the Company nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * This software is provided ``as is'', and any express or implied  * warranties, including, but not limited to, the implied warranties of  * merchantability and fitness for a particular purpose are disclaimed.  * In no event shall the company or contributors be liable for any  * direct, indirect, incidental, special, exemplary, or consequential  * damages (including, but not limited to, procurement of substitute  * goods or services; loss of use, data, or profits; or business  * interruption) however caused and on any theory of liability, whether  * in contract, strict liability, or tort (including negligence or  * otherwise) arising in any way out of the use of this software, even if  * advised of the possibility of such damage.  *  */
end_comment

begin_comment
comment|/* This file is shared between kernel and userland. */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_define
define|#
directive|define
name|iswhite
parameter_list|(
name|c
parameter_list|)
value|(((c) == ' ') || ((c) == '\t'))
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|iswhite
value|isspace
end_define

begin_define
define|#
directive|define
name|g_free
value|free
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<geom/vinum/geom_vinum_var.h>
end_include

begin_include
include|#
directive|include
file|<geom/vinum/geom_vinum_share.h>
end_include

begin_comment
comment|/*  * Take a blank separated list of tokens and turn it into a list of  * individual nul-delimited strings.  Build a list of pointers at  * token, which must have enough space for the tokens.  Return the  * number of tokens, or -1 on error (typically a missing string  * delimiter).  */
end_comment

begin_function
name|int
name|gv_tokenize
parameter_list|(
name|char
modifier|*
name|cptr
parameter_list|,
name|char
modifier|*
name|token
index|[]
parameter_list|,
name|int
name|maxtoken
parameter_list|)
block|{
name|int
name|tokennr
decl_stmt|;
comment|/* Index of this token. */
name|char
name|delim
decl_stmt|;
comment|/* Delimiter for searching for the partner. */
for|for
control|(
name|tokennr
operator|=
literal|0
init|;
name|tokennr
operator|<
name|maxtoken
condition|;
control|)
block|{
comment|/* Skip leading white space. */
while|while
condition|(
name|iswhite
argument_list|(
operator|*
name|cptr
argument_list|)
condition|)
name|cptr
operator|++
expr_stmt|;
comment|/* End of line. */
if|if
condition|(
operator|(
operator|*
name|cptr
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|*
name|cptr
operator|==
literal|'\n'
operator|)
operator|||
operator|(
operator|*
name|cptr
operator|==
literal|'#'
operator|)
condition|)
return|return
name|tokennr
return|;
name|delim
operator|=
operator|*
name|cptr
expr_stmt|;
name|token
index|[
name|tokennr
index|]
operator|=
name|cptr
expr_stmt|;
comment|/* Point to it. */
name|tokennr
operator|++
expr_stmt|;
comment|/* One more. */
comment|/* Run off the end? */
if|if
condition|(
name|tokennr
operator|==
name|maxtoken
condition|)
return|return
name|tokennr
return|;
comment|/* Quoted? */
if|if
condition|(
operator|(
name|delim
operator|==
literal|'\''
operator|)
operator|||
operator|(
name|delim
operator|==
literal|'"'
operator|)
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|cptr
operator|++
expr_stmt|;
comment|/* Found the partner. */
if|if
condition|(
operator|(
operator|*
name|cptr
operator|==
name|delim
operator|)
operator|&&
operator|(
name|cptr
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\\'
operator|)
condition|)
block|{
name|cptr
operator|++
expr_stmt|;
comment|/* Space after closing quote needed. */
if|if
condition|(
operator|!
name|iswhite
argument_list|(
operator|*
name|cptr
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Delimit. */
operator|*
name|cptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* End-of-line? */
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|cptr
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|*
name|cptr
operator|==
literal|'\n'
operator|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* Not quoted. */
block|}
else|else
block|{
while|while
condition|(
operator|(
operator|*
name|cptr
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|!
name|iswhite
argument_list|(
operator|*
name|cptr
argument_list|)
operator|)
operator|&&
operator|(
operator|*
name|cptr
operator|!=
literal|'\n'
operator|)
condition|)
name|cptr
operator|++
expr_stmt|;
comment|/* Not end-of-line; delimit and move to the next. */
if|if
condition|(
operator|*
name|cptr
operator|!=
literal|'\0'
condition|)
operator|*
name|cptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
comment|/* Can't get here. */
return|return
name|maxtoken
return|;
block|}
end_function

begin_comment
comment|/*  * Take a number with an optional scale factor and convert it to a number of  * bytes.  *  * The scale factors are:  *  * s    sectors (of 512 bytes)  * b    blocks (of 512 bytes).  This unit is deprecated, because it's  *      confusing, but maintained to avoid confusing Veritas users.  * k    kilobytes (1024 bytes)  * m    megabytes (of 1024 * 1024 bytes)  * g    gigabytes (of 1024 * 1024 * 1024 bytes)  *  * XXX: need a way to signal error  */
end_comment

begin_function
name|off_t
name|gv_sizespec
parameter_list|(
name|char
modifier|*
name|spec
parameter_list|)
block|{
name|uint64_t
name|size
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|spec
operator|!=
name|NULL
condition|)
block|{
comment|/* we have a parameter */
name|s
operator|=
name|spec
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
block|{
comment|/* negative, */
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|++
expr_stmt|;
comment|/* skip */
block|}
comment|/* It's numeric. */
if|if
condition|(
operator|(
operator|*
name|s
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|s
operator|<=
literal|'9'
operator|)
condition|)
block|{
comment|/* It's numeric. */
while|while
condition|(
operator|(
operator|*
name|s
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
operator|*
name|s
operator|<=
literal|'9'
operator|)
condition|)
comment|/* Convert it. */
name|size
operator|=
name|size
operator|*
literal|10
operator|+
operator|*
name|s
operator|++
operator|-
literal|'0'
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'\0'
case|:
return|return
name|size
operator|*
name|sign
return|;
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
case|case
literal|'S'
case|:
case|case
literal|'s'
case|:
return|return
name|size
operator|*
name|sign
operator|*
literal|512
return|;
case|case
literal|'K'
case|:
case|case
literal|'k'
case|:
return|return
name|size
operator|*
name|sign
operator|*
literal|1024
return|;
case|case
literal|'M'
case|:
case|case
literal|'m'
case|:
return|return
name|size
operator|*
name|sign
operator|*
literal|1024
operator|*
literal|1024
return|;
case|case
literal|'G'
case|:
case|case
literal|'g'
case|:
return|return
name|size
operator|*
name|sign
operator|*
literal|1024
operator|*
literal|1024
operator|*
literal|1024
return|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|gv_drivestate
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|GV_DRIVE_DOWN
case|:
return|return
literal|"down"
return|;
case|case
name|GV_DRIVE_UP
case|:
return|return
literal|"up"
return|;
default|default:
return|return
literal|"??"
return|;
block|}
block|}
end_function

begin_function
name|int
name|gv_drivestatei
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"up"
argument_list|)
condition|)
return|return
operator|(
name|GV_DRIVE_UP
operator|)
return|;
else|else
return|return
operator|(
name|GV_DRIVE_DOWN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Translate from a string to a subdisk state. */
end_comment

begin_function
name|int
name|gv_sdstatei
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"up"
argument_list|)
condition|)
return|return
operator|(
name|GV_SD_UP
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"reviving"
argument_list|)
condition|)
return|return
operator|(
name|GV_SD_REVIVING
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"stale"
argument_list|)
condition|)
return|return
operator|(
name|GV_SD_STALE
operator|)
return|;
else|else
return|return
operator|(
name|GV_SD_DOWN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Translate from a subdisk state to a string. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|gv_sdstate
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|GV_SD_INITIALIZING
case|:
return|return
literal|"initializing"
return|;
case|case
name|GV_SD_STALE
case|:
return|return
literal|"stale"
return|;
case|case
name|GV_SD_DOWN
case|:
return|return
literal|"down"
return|;
case|case
name|GV_SD_REVIVING
case|:
return|return
literal|"reviving"
return|;
case|case
name|GV_SD_UP
case|:
return|return
literal|"up"
return|;
default|default:
return|return
literal|"??"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Translate from a string to a plex state. */
end_comment

begin_function
name|int
name|gv_plexstatei
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"up"
argument_list|)
condition|)
return|return
operator|(
name|GV_PLEX_UP
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"initializing"
argument_list|)
condition|)
return|return
operator|(
name|GV_PLEX_INITIALIZING
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"degraded"
argument_list|)
condition|)
return|return
operator|(
name|GV_PLEX_DEGRADED
operator|)
return|;
else|else
return|return
operator|(
name|GV_PLEX_DOWN
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Translate from a plex state to a string. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|gv_plexstate
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|GV_PLEX_DOWN
case|:
return|return
literal|"down"
return|;
case|case
name|GV_PLEX_INITIALIZING
case|:
return|return
literal|"initializing"
return|;
case|case
name|GV_PLEX_DEGRADED
case|:
return|return
literal|"degraded"
return|;
case|case
name|GV_PLEX_UP
case|:
return|return
literal|"up"
return|;
default|default:
return|return
literal|"??"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Translate from a string to a plex organization. */
end_comment

begin_function
name|int
name|gv_plexorgi
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"concat"
argument_list|)
condition|)
return|return
operator|(
name|GV_PLEX_CONCAT
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"striped"
argument_list|)
condition|)
return|return
operator|(
name|GV_PLEX_STRIPED
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"raid5"
argument_list|)
condition|)
return|return
operator|(
name|GV_PLEX_RAID5
operator|)
return|;
else|else
return|return
operator|(
name|GV_PLEX_DISORG
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gv_volstatei
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"up"
argument_list|)
condition|)
return|return
operator|(
name|GV_VOL_UP
operator|)
return|;
else|else
return|return
operator|(
name|GV_VOL_DOWN
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|gv_volstate
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|GV_VOL_UP
case|:
return|return
literal|"up"
return|;
case|case
name|GV_VOL_DOWN
case|:
return|return
literal|"down"
return|;
default|default:
return|return
literal|"??"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Translate from a plex organization to a string. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|gv_plexorg
parameter_list|(
name|int
name|org
parameter_list|)
block|{
switch|switch
condition|(
name|org
condition|)
block|{
case|case
name|GV_PLEX_DISORG
case|:
return|return
literal|"??"
return|;
case|case
name|GV_PLEX_CONCAT
case|:
return|return
literal|"concat"
return|;
case|case
name|GV_PLEX_STRIPED
case|:
return|return
literal|"striped"
return|;
case|case
name|GV_PLEX_RAID5
case|:
return|return
literal|"raid5"
return|;
default|default:
return|return
literal|"??"
return|;
block|}
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|gv_plexorg_short
parameter_list|(
name|int
name|org
parameter_list|)
block|{
switch|switch
condition|(
name|org
condition|)
block|{
case|case
name|GV_PLEX_DISORG
case|:
return|return
literal|"??"
return|;
case|case
name|GV_PLEX_CONCAT
case|:
return|return
literal|"C"
return|;
case|case
name|GV_PLEX_STRIPED
case|:
return|return
literal|"S"
return|;
case|case
name|GV_PLEX_RAID5
case|:
return|return
literal|"R5"
return|;
default|default:
return|return
literal|"??"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Get a new drive object. */
end_comment

begin_function
name|struct
name|gv_drive
modifier|*
name|gv_new_drive
parameter_list|(
name|int
name|max
parameter_list|,
name|char
modifier|*
name|token
index|[]
parameter_list|)
block|{
name|struct
name|gv_drive
modifier|*
name|d
decl_stmt|;
name|int
name|j
decl_stmt|,
name|errors
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|token
index|[
literal|1
index|]
operator|==
name|NULL
operator|||
operator|*
name|token
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
ifdef|#
directive|ifdef
name|_KERNEL
name|d
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gv_drive
argument_list|)
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
else|#
directive|else
name|d
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gv_drive
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bzero
argument_list|(
name|d
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gv_drive
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|errors
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|max
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|token
index|[
name|j
index|]
argument_list|,
literal|"state"
argument_list|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|max
condition|)
block|{
name|errors
operator|++
expr_stmt|;
break|break;
block|}
name|d
operator|->
name|state
operator|=
name|gv_drivestatei
argument_list|(
name|token
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|token
index|[
name|j
index|]
argument_list|,
literal|"device"
argument_list|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|max
condition|)
block|{
name|errors
operator|++
expr_stmt|;
break|break;
block|}
name|ptr
operator|=
name|token
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|==
literal|'/'
condition|)
block|{
name|ptr
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|!=
literal|'/'
condition|)
name|ptr
operator|++
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|d
operator|->
name|device
argument_list|,
name|ptr
argument_list|,
name|GV_MAXDRIVENAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We assume this is the drive name. */
name|strncpy
argument_list|(
name|d
operator|->
name|name
argument_list|,
name|token
index|[
name|j
index|]
argument_list|,
name|GV_MAXDRIVENAME
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strlen
argument_list|(
name|d
operator|->
name|name
argument_list|)
operator|==
literal|0
operator|||
name|strlen
argument_list|(
name|d
operator|->
name|device
argument_list|)
operator|==
literal|0
condition|)
name|errors
operator|++
expr_stmt|;
if|if
condition|(
name|errors
condition|)
block|{
name|g_free
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|d
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get a new volume object. */
end_comment

begin_function
name|struct
name|gv_volume
modifier|*
name|gv_new_volume
parameter_list|(
name|int
name|max
parameter_list|,
name|char
modifier|*
name|token
index|[]
parameter_list|)
block|{
name|struct
name|gv_volume
modifier|*
name|v
decl_stmt|;
name|int
name|j
decl_stmt|,
name|errors
decl_stmt|;
if|if
condition|(
name|token
index|[
literal|1
index|]
operator|==
name|NULL
operator|||
operator|*
name|token
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
ifdef|#
directive|ifdef
name|_KERNEL
name|v
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gv_volume
argument_list|)
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
else|#
directive|else
name|v
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gv_volume
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bzero
argument_list|(
name|v
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gv_volume
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|errors
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|max
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|token
index|[
name|j
index|]
argument_list|,
literal|"state"
argument_list|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|max
condition|)
block|{
name|errors
operator|++
expr_stmt|;
break|break;
block|}
name|v
operator|->
name|state
operator|=
name|gv_volstatei
argument_list|(
name|token
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We assume this is the volume name. */
name|strncpy
argument_list|(
name|v
operator|->
name|name
argument_list|,
name|token
index|[
name|j
index|]
argument_list|,
name|GV_MAXVOLNAME
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strlen
argument_list|(
name|v
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
name|errors
operator|++
expr_stmt|;
if|if
condition|(
name|errors
condition|)
block|{
name|g_free
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get a new plex object. */
end_comment

begin_function
name|struct
name|gv_plex
modifier|*
name|gv_new_plex
parameter_list|(
name|int
name|max
parameter_list|,
name|char
modifier|*
name|token
index|[]
parameter_list|)
block|{
name|struct
name|gv_plex
modifier|*
name|p
decl_stmt|;
name|int
name|j
decl_stmt|,
name|errors
decl_stmt|;
if|if
condition|(
name|token
index|[
literal|1
index|]
operator|==
name|NULL
operator|||
operator|*
name|token
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
ifdef|#
directive|ifdef
name|_KERNEL
name|p
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gv_plex
argument_list|)
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
else|#
directive|else
name|p
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gv_plex
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bzero
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gv_plex
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|errors
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|max
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|token
index|[
name|j
index|]
argument_list|,
literal|"name"
argument_list|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|max
condition|)
block|{
name|errors
operator|++
expr_stmt|;
break|break;
block|}
name|strncpy
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|token
index|[
name|j
index|]
argument_list|,
name|GV_MAXPLEXNAME
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|token
index|[
name|j
index|]
argument_list|,
literal|"org"
argument_list|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|max
condition|)
block|{
name|errors
operator|++
expr_stmt|;
break|break;
block|}
name|p
operator|->
name|org
operator|=
name|gv_plexorgi
argument_list|(
name|token
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|org
operator|==
name|GV_PLEX_RAID5
operator|)
operator|||
operator|(
name|p
operator|->
name|org
operator|==
name|GV_PLEX_STRIPED
operator|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|max
condition|)
block|{
name|errors
operator|++
expr_stmt|;
break|break;
block|}
name|p
operator|->
name|stripesize
operator|=
name|gv_sizespec
argument_list|(
name|token
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|stripesize
operator|==
literal|0
condition|)
block|{
name|errors
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|token
index|[
name|j
index|]
argument_list|,
literal|"state"
argument_list|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|max
condition|)
block|{
name|errors
operator|++
expr_stmt|;
break|break;
block|}
name|p
operator|->
name|state
operator|=
name|gv_plexstatei
argument_list|(
name|token
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|token
index|[
name|j
index|]
argument_list|,
literal|"vol"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|token
index|[
name|j
index|]
argument_list|,
literal|"volume"
argument_list|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|max
condition|)
block|{
name|errors
operator|++
expr_stmt|;
break|break;
block|}
name|strncpy
argument_list|(
name|p
operator|->
name|volume
argument_list|,
name|token
index|[
name|j
index|]
argument_list|,
name|GV_MAXVOLNAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|errors
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|errors
condition|)
block|{
name|g_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get a new subdisk object. */
end_comment

begin_function
name|struct
name|gv_sd
modifier|*
name|gv_new_sd
parameter_list|(
name|int
name|max
parameter_list|,
name|char
modifier|*
name|token
index|[]
parameter_list|)
block|{
name|struct
name|gv_sd
modifier|*
name|s
decl_stmt|;
name|int
name|j
decl_stmt|,
name|errors
decl_stmt|;
if|if
condition|(
name|token
index|[
literal|1
index|]
operator|==
name|NULL
operator|||
operator|*
name|token
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
ifdef|#
directive|ifdef
name|_KERNEL
name|s
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gv_sd
argument_list|)
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gv_sd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|bzero
argument_list|(
name|s
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gv_sd
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|->
name|plex_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|size
operator|=
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|drive_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|errors
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|max
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|token
index|[
name|j
index|]
argument_list|,
literal|"name"
argument_list|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|max
condition|)
block|{
name|errors
operator|++
expr_stmt|;
break|break;
block|}
name|strncpy
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|token
index|[
name|j
index|]
argument_list|,
name|GV_MAXSDNAME
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|token
index|[
name|j
index|]
argument_list|,
literal|"drive"
argument_list|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|max
condition|)
block|{
name|errors
operator|++
expr_stmt|;
break|break;
block|}
name|strncpy
argument_list|(
name|s
operator|->
name|drive
argument_list|,
name|token
index|[
name|j
index|]
argument_list|,
name|GV_MAXDRIVENAME
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|token
index|[
name|j
index|]
argument_list|,
literal|"plex"
argument_list|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|max
condition|)
block|{
name|errors
operator|++
expr_stmt|;
break|break;
block|}
name|strncpy
argument_list|(
name|s
operator|->
name|plex
argument_list|,
name|token
index|[
name|j
index|]
argument_list|,
name|GV_MAXPLEXNAME
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|token
index|[
name|j
index|]
argument_list|,
literal|"state"
argument_list|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|max
condition|)
block|{
name|errors
operator|++
expr_stmt|;
break|break;
block|}
name|s
operator|->
name|state
operator|=
name|gv_sdstatei
argument_list|(
name|token
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|token
index|[
name|j
index|]
argument_list|,
literal|"len"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|token
index|[
name|j
index|]
argument_list|,
literal|"length"
argument_list|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|max
condition|)
block|{
name|errors
operator|++
expr_stmt|;
break|break;
block|}
name|s
operator|->
name|size
operator|=
name|gv_sizespec
argument_list|(
name|token
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|size
operator|<=
literal|0
condition|)
name|s
operator|->
name|size
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|token
index|[
name|j
index|]
argument_list|,
literal|"driveoffset"
argument_list|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|max
condition|)
block|{
name|errors
operator|++
expr_stmt|;
break|break;
block|}
name|s
operator|->
name|drive_offset
operator|=
name|gv_sizespec
argument_list|(
name|token
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|drive_offset
operator|!=
literal|0
operator|&&
name|s
operator|->
name|drive_offset
operator|<
name|GV_DATA_START
condition|)
block|{
name|errors
operator|++
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|token
index|[
name|j
index|]
argument_list|,
literal|"plexoffset"
argument_list|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|j
operator|>=
name|max
condition|)
block|{
name|errors
operator|++
expr_stmt|;
break|break;
block|}
name|s
operator|->
name|plex_offset
operator|=
name|gv_sizespec
argument_list|(
name|token
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|plex_offset
operator|<
literal|0
condition|)
block|{
name|errors
operator|++
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|errors
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|strlen
argument_list|(
name|s
operator|->
name|drive
argument_list|)
operator|==
literal|0
condition|)
name|errors
operator|++
expr_stmt|;
if|if
condition|(
name|errors
condition|)
block|{
name|g_free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Take a size in bytes and return a pointer to a string which represents the  * size best.  If lj is != 0, return left justified, otherwise in a fixed 10  * character field suitable for columnar printing.  *  * Note this uses a static string: it's only intended to be used immediately  * for printing.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|gv_roughlength
parameter_list|(
name|off_t
name|bytes
parameter_list|,
name|int
name|lj
parameter_list|)
block|{
specifier|static
name|char
name|desc
index|[
literal|16
index|]
decl_stmt|;
comment|/* Gigabytes. */
if|if
condition|(
name|bytes
operator|>
operator|(
name|off_t
operator|)
name|MEGABYTE
operator|*
literal|10000
condition|)
name|snprintf
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|,
name|lj
condition|?
literal|"%jd GB"
else|:
literal|"%10jd GB"
argument_list|,
name|bytes
operator|/
name|GIGABYTE
argument_list|)
expr_stmt|;
comment|/* Megabytes. */
elseif|else
if|if
condition|(
name|bytes
operator|>
name|KILOBYTE
operator|*
literal|10000
condition|)
name|snprintf
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|,
name|lj
condition|?
literal|"%jd MB"
else|:
literal|"%10jd MB"
argument_list|,
name|bytes
operator|/
name|MEGABYTE
argument_list|)
expr_stmt|;
comment|/* Kilobytes. */
elseif|else
if|if
condition|(
name|bytes
operator|>
literal|10000
condition|)
name|snprintf
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|,
name|lj
condition|?
literal|"%jd kB"
else|:
literal|"%10jd kB"
argument_list|,
name|bytes
operator|/
name|KILOBYTE
argument_list|)
expr_stmt|;
comment|/* Bytes. */
else|else
name|snprintf
argument_list|(
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|,
name|lj
condition|?
literal|"%jd  B"
else|:
literal|"%10jd  B"
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|desc
operator|)
return|;
block|}
end_function

end_unit

