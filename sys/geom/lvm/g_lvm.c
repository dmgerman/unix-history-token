begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Andrew Thompson<thompsa@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<geom/lvm/g_lvm.h>
end_include

begin_comment
comment|/* Declare malloc(9) label */
end_comment

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_GLVM
argument_list|,
literal|"glvm"
argument_list|,
literal|"GEOM_LVM Data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* GEOM class methods */
end_comment

begin_decl_stmt
specifier|static
name|g_access_t
name|g_lvm_access
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_init_t
name|g_lvm_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_orphan_t
name|g_lvm_orphan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_orphan_t
name|g_lvm_taste_orphan
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_start_t
name|g_lvm_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_taste_t
name|g_lvm_taste
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_ctl_destroy_geom_t
name|g_lvm_destroy_geom
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|g_lvm_done
parameter_list|(
name|struct
name|bio
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_lvm_remove_disk
parameter_list|(
name|struct
name|g_lvm_vg
modifier|*
parameter_list|,
name|struct
name|g_consumer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_lvm_activate_lv
parameter_list|(
name|struct
name|g_lvm_vg
modifier|*
parameter_list|,
name|struct
name|g_lvm_lv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_lvm_add_disk
parameter_list|(
name|struct
name|g_lvm_vg
modifier|*
parameter_list|,
name|struct
name|g_provider
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_lvm_free_vg
parameter_list|(
name|struct
name|g_lvm_vg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_lvm_destroy
parameter_list|(
name|struct
name|g_lvm_vg
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_lvm_read_label
parameter_list|(
name|struct
name|g_consumer
modifier|*
parameter_list|,
name|struct
name|g_lvm_label
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_lvm_read_md
parameter_list|(
name|struct
name|g_consumer
modifier|*
parameter_list|,
name|struct
name|g_lvm_metadata
modifier|*
parameter_list|,
name|struct
name|g_lvm_label
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lvm_label_decode
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|struct
name|g_lvm_label
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lvm_md_decode
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
name|struct
name|g_lvm_metadata
modifier|*
parameter_list|,
name|struct
name|g_lvm_label
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lvm_textconf_decode
parameter_list|(
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|g_lvm_metadata
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lvm_textconf_decode_pv
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|g_lvm_vg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lvm_textconf_decode_lv
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|g_lvm_vg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lvm_textconf_decode_sg
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|g_lvm_lv
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_kern_geom
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern_geom
argument_list|,
name|OID_AUTO
argument_list|,
name|lvm
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"GEOM_LVM stuff"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_lvm_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.geom.lvm.debug"
argument_list|,
operator|&
name|g_lvm_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_lvm
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_lvm_debug
argument_list|,
literal|0
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|LIST_HEAD
argument_list|(
argument_list|,
argument|g_lvm_vg
argument_list|)
end_macro

begin_expr_stmt
name|vg_list
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Called to notify geom when it's been opened, and for what intent  */
end_comment

begin_function
specifier|static
name|int
name|g_lvm_access
parameter_list|(
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|dr
parameter_list|,
name|int
name|dw
parameter_list|,
name|int
name|de
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|c
decl_stmt|;
name|struct
name|g_lvm_vg
modifier|*
name|vg
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|pp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: NULL provider"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|gp
operator|=
name|pp
operator|->
name|geom
expr_stmt|;
name|KASSERT
argument_list|(
name|gp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: NULL geom"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|vg
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|vg
operator|==
name|NULL
condition|)
block|{
comment|/* It seems that .access can be called with negative dr,dw,dx 		 * in this case but I want to check for myself */
name|G_LVM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"access(%d, %d, %d) for %s"
argument_list|,
name|dr
argument_list|,
name|dw
argument_list|,
name|de
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* This should only happen when geom is withered so 		 * allow only negative requests */
name|KASSERT
argument_list|(
name|dr
operator|<=
literal|0
operator|&&
name|dw
operator|<=
literal|0
operator|&&
name|de
operator|<=
literal|0
argument_list|,
operator|(
literal|"%s: Positive access for %s"
operator|,
name|__func__
operator|,
name|pp
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|acr
operator|+
name|dr
operator|==
literal|0
operator|&&
name|pp
operator|->
name|acw
operator|+
name|dw
operator|==
literal|0
operator|&&
name|pp
operator|->
name|ace
operator|+
name|de
operator|==
literal|0
condition|)
name|G_LVM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s definitely destroyed"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Grab an exclusive bit to propagate on our consumers on first open */
if|if
condition|(
name|pp
operator|->
name|acr
operator|==
literal|0
operator|&&
name|pp
operator|->
name|acw
operator|==
literal|0
operator|&&
name|pp
operator|->
name|ace
operator|==
literal|0
condition|)
name|de
operator|++
expr_stmt|;
comment|/* ... drop it on close */
if|if
condition|(
name|pp
operator|->
name|acr
operator|+
name|dr
operator|==
literal|0
operator|&&
name|pp
operator|->
name|acw
operator|+
name|dw
operator|==
literal|0
operator|&&
name|pp
operator|->
name|ace
operator|+
name|de
operator|==
literal|0
condition|)
name|de
operator|--
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|c
argument_list|,
argument|&gp->consumer
argument_list|,
argument|consumer
argument_list|)
block|{
name|KASSERT
argument_list|(
name|c
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: consumer is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_access
argument_list|(
name|c
argument_list|,
name|dr
argument_list|,
name|dw
argument_list|,
name|de
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|struct
name|g_consumer
modifier|*
name|c2
decl_stmt|;
comment|/* Backout earlier changes */
name|LIST_FOREACH
argument_list|(
argument|c2
argument_list|,
argument|&gp->consumer
argument_list|,
argument|consumer
argument_list|)
block|{
if|if
condition|(
name|c2
operator|==
name|c
condition|)
comment|/* all eariler components fixed */
return|return
operator|(
name|error
operator|)
return|;
name|g_access
argument_list|(
name|c2
argument_list|,
operator|-
name|dr
argument_list|,
operator|-
name|dw
argument_list|,
operator|-
name|de
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dismantle bio_queue and destroy its components  */
end_comment

begin_function
specifier|static
name|void
name|bioq_dismantle
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|bq
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|b
operator|=
name|bioq_first
argument_list|(
name|bq
argument_list|)
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|bioq_first
argument_list|(
name|bq
argument_list|)
control|)
block|{
name|bioq_remove
argument_list|(
name|bq
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * GEOM .done handler  * Can't use standard handler because one requested IO may  * fork into additional data IOs  */
end_comment

begin_function
specifier|static
name|void
name|g_lvm_done
parameter_list|(
name|struct
name|bio
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|parent_b
decl_stmt|;
name|parent_b
operator|=
name|b
operator|->
name|bio_parent
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|bio_error
operator|!=
literal|0
condition|)
block|{
name|G_LVM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Error %d for offset=%ju, length=%ju on %s"
argument_list|,
name|b
operator|->
name|bio_error
argument_list|,
name|b
operator|->
name|bio_offset
argument_list|,
name|b
operator|->
name|bio_length
argument_list|,
name|b
operator|->
name|bio_to
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent_b
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|parent_b
operator|->
name|bio_error
operator|=
name|b
operator|->
name|bio_error
expr_stmt|;
block|}
name|parent_b
operator|->
name|bio_inbed
operator|++
expr_stmt|;
name|parent_b
operator|->
name|bio_completed
operator|+=
name|b
operator|->
name|bio_completed
expr_stmt|;
if|if
condition|(
name|parent_b
operator|->
name|bio_children
operator|==
name|parent_b
operator|->
name|bio_inbed
condition|)
block|{
name|parent_b
operator|->
name|bio_completed
operator|=
name|parent_b
operator|->
name|bio_length
expr_stmt|;
name|g_io_deliver
argument_list|(
name|parent_b
argument_list|,
name|parent_b
operator|->
name|bio_error
argument_list|)
expr_stmt|;
block|}
name|g_destroy_bio
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_lvm_start
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_lvm_vg
modifier|*
name|vg
decl_stmt|;
name|struct
name|g_lvm_pv
modifier|*
name|pv
decl_stmt|;
name|struct
name|g_lvm_lv
modifier|*
name|lv
decl_stmt|;
name|struct
name|g_lvm_segment
modifier|*
name|sg
decl_stmt|;
name|struct
name|bio
modifier|*
name|cb
decl_stmt|;
name|struct
name|bio_queue_head
name|bq
decl_stmt|;
name|size_t
name|chunk_size
decl_stmt|;
name|off_t
name|offset
decl_stmt|,
name|length
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
name|u_int
name|count
decl_stmt|;
name|pp
operator|=
name|bp
operator|->
name|bio_to
expr_stmt|;
name|lv
operator|=
name|pp
operator|->
name|private
expr_stmt|;
name|vg
operator|=
name|pp
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
case|case
name|BIO_WRITE
case|:
case|case
name|BIO_DELETE
case|:
comment|/* XXX BIO_GETATTR allowed? */
break|break;
default|default:
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
return|return;
block|}
name|bioq_init
argument_list|(
operator|&
name|bq
argument_list|)
expr_stmt|;
name|chunk_size
operator|=
name|vg
operator|->
name|vg_extentsize
expr_stmt|;
name|addr
operator|=
name|bp
operator|->
name|bio_data
expr_stmt|;
name|offset
operator|=
name|bp
operator|->
name|bio_offset
expr_stmt|;
comment|/* virtual offset and length */
name|length
operator|=
name|bp
operator|->
name|bio_length
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|size_t
name|chunk_index
decl_stmt|,
name|in_chunk_offset
decl_stmt|,
name|in_chunk_length
decl_stmt|;
name|pv
operator|=
name|NULL
expr_stmt|;
name|cb
operator|=
name|g_clone_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|==
name|NULL
condition|)
block|{
name|bioq_dismantle
argument_list|(
operator|&
name|bq
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|ENOMEM
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* get the segment and the pv */
if|if
condition|(
name|lv
operator|->
name|lv_sgcount
operator|==
literal|1
condition|)
block|{
comment|/* skip much of the calculations for a single sg */
name|chunk_index
operator|=
literal|0
expr_stmt|;
name|in_chunk_offset
operator|=
literal|0
expr_stmt|;
name|in_chunk_length
operator|=
name|length
expr_stmt|;
name|sg
operator|=
name|lv
operator|->
name|lv_firstsg
expr_stmt|;
name|pv
operator|=
name|sg
operator|->
name|sg_pv
expr_stmt|;
name|cb
operator|->
name|bio_offset
operator|=
name|offset
operator|+
name|sg
operator|->
name|sg_pvoffset
expr_stmt|;
block|}
else|else
block|{
name|chunk_index
operator|=
name|offset
operator|/
name|chunk_size
expr_stmt|;
comment|/* round downwards */
name|in_chunk_offset
operator|=
name|offset
operator|%
name|chunk_size
expr_stmt|;
name|in_chunk_length
operator|=
name|min
argument_list|(
name|length
argument_list|,
name|chunk_size
operator|-
name|in_chunk_offset
argument_list|)
expr_stmt|;
comment|/* XXX could be faster */
name|LIST_FOREACH
argument_list|(
argument|sg
argument_list|,
argument|&lv->lv_segs
argument_list|,
argument|sg_next
argument_list|)
block|{
if|if
condition|(
name|chunk_index
operator|>=
name|sg
operator|->
name|sg_start
operator|&&
name|chunk_index
operator|<=
name|sg
operator|->
name|sg_end
condition|)
block|{
comment|/* adjust chunk index for sg start */
name|chunk_index
operator|-=
name|sg
operator|->
name|sg_start
expr_stmt|;
name|pv
operator|=
name|sg
operator|->
name|sg_pv
expr_stmt|;
break|break;
block|}
block|}
name|cb
operator|->
name|bio_offset
operator|=
operator|(
name|off_t
operator|)
name|chunk_index
operator|*
operator|(
name|off_t
operator|)
name|chunk_size
operator|+
name|in_chunk_offset
operator|+
name|sg
operator|->
name|sg_pvoffset
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|pv
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Can't find PV for chunk %d"
operator|,
name|chunk_index
operator|)
argument_list|)
expr_stmt|;
name|cb
operator|->
name|bio_to
operator|=
name|pv
operator|->
name|pv_gprov
expr_stmt|;
name|cb
operator|->
name|bio_done
operator|=
name|g_lvm_done
expr_stmt|;
name|cb
operator|->
name|bio_length
operator|=
name|in_chunk_length
expr_stmt|;
name|cb
operator|->
name|bio_data
operator|=
name|addr
expr_stmt|;
name|cb
operator|->
name|bio_caller1
operator|=
name|pv
expr_stmt|;
name|bioq_disksort
argument_list|(
operator|&
name|bq
argument_list|,
name|cb
argument_list|)
expr_stmt|;
name|G_LVM_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"Mapped %s(%ju, %ju) on %s to %zu(%zu,%zu) @ %s:%ju"
argument_list|,
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|?
literal|"R"
else|:
literal|"W"
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|lv
operator|->
name|lv_name
argument_list|,
name|chunk_index
argument_list|,
name|in_chunk_offset
argument_list|,
name|in_chunk_length
argument_list|,
name|pv
operator|->
name|pv_name
argument_list|,
name|cb
operator|->
name|bio_offset
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|in_chunk_length
expr_stmt|;
name|length
operator|-=
name|in_chunk_length
expr_stmt|;
name|offset
operator|+=
name|in_chunk_length
expr_stmt|;
block|}
comment|/* Fire off bio's here */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cb
operator|=
name|bioq_first
argument_list|(
operator|&
name|bq
argument_list|)
init|;
name|cb
operator|!=
name|NULL
condition|;
name|cb
operator|=
name|bioq_first
argument_list|(
operator|&
name|bq
argument_list|)
control|)
block|{
name|bioq_remove
argument_list|(
operator|&
name|bq
argument_list|,
name|cb
argument_list|)
expr_stmt|;
name|pv
operator|=
name|cb
operator|->
name|bio_caller1
expr_stmt|;
name|cb
operator|->
name|bio_caller1
operator|=
name|NULL
expr_stmt|;
name|G_LVM_DEBUG
argument_list|(
literal|6
argument_list|,
literal|"firing bio to %s, offset=%ju, length=%ju"
argument_list|,
name|cb
operator|->
name|bio_to
operator|->
name|name
argument_list|,
name|cb
operator|->
name|bio_offset
argument_list|,
name|cb
operator|->
name|bio_length
argument_list|)
expr_stmt|;
name|g_io_request
argument_list|(
name|cb
argument_list|,
name|pv
operator|->
name|pv_gcons
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* We handled everything locally */
name|bp
operator|->
name|bio_completed
operator|=
name|bp
operator|->
name|bio_length
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_lvm_remove_disk
parameter_list|(
name|struct
name|g_lvm_vg
modifier|*
name|vg
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_lvm_pv
modifier|*
name|pv
decl_stmt|;
name|struct
name|g_lvm_lv
modifier|*
name|lv
decl_stmt|;
name|struct
name|g_lvm_segment
modifier|*
name|sg
decl_stmt|;
name|int
name|found
decl_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Non-valid disk in %s."
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|pv
operator|=
operator|(
expr|struct
name|g_lvm_pv
operator|*
operator|)
name|cp
operator|->
name|private
expr_stmt|;
name|G_LVM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Disk %s removed from %s."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|,
name|pv
operator|->
name|pv_name
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lv
argument_list|,
argument|&vg->vg_lvs
argument_list|,
argument|lv_next
argument_list|)
block|{
comment|/* Find segments that map to this disk */
name|found
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sg
argument_list|,
argument|&lv->lv_segs
argument_list|,
argument|sg_next
argument_list|)
block|{
if|if
condition|(
name|sg
operator|->
name|sg_pv
operator|==
name|pv
condition|)
block|{
name|sg
operator|->
name|sg_pv
operator|=
name|NULL
expr_stmt|;
name|lv
operator|->
name|lv_sgactive
operator|--
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
name|G_LVM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s removed."
argument_list|,
name|lv
operator|->
name|lv_gprov
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_orphan_provider
argument_list|(
name|lv
operator|->
name|lv_gprov
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|lv
operator|->
name|lv_gprov
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cp
operator|->
name|acr
operator|>
literal|0
operator|||
name|cp
operator|->
name|acw
operator|>
literal|0
operator|||
name|cp
operator|->
name|ace
operator|>
literal|0
condition|)
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
name|cp
operator|->
name|acr
argument_list|,
operator|-
name|cp
operator|->
name|acw
argument_list|,
operator|-
name|cp
operator|->
name|ace
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_lvm_orphan
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_lvm_vg
modifier|*
name|vg
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|gp
operator|=
name|cp
operator|->
name|geom
expr_stmt|;
name|vg
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|vg
operator|==
name|NULL
condition|)
return|return;
name|g_lvm_remove_disk
argument_list|(
name|vg
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|g_lvm_destroy
argument_list|(
name|vg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_lvm_activate_lv
parameter_list|(
name|struct
name|g_lvm_vg
modifier|*
name|vg
parameter_list|,
name|struct
name|g_lvm_lv
modifier|*
name|lv
parameter_list|)
block|{
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|lv
operator|->
name|lv_sgactive
operator|==
name|lv
operator|->
name|lv_sgcount
argument_list|,
operator|(
literal|"segment missing"
operator|)
argument_list|)
expr_stmt|;
name|gp
operator|=
name|vg
operator|->
name|vg_geom
expr_stmt|;
name|pp
operator|=
name|g_new_providerf
argument_list|(
name|gp
argument_list|,
literal|"lvm/%s-%s"
argument_list|,
name|vg
operator|->
name|vg_name
argument_list|,
name|lv
operator|->
name|lv_name
argument_list|)
expr_stmt|;
name|pp
operator|->
name|mediasize
operator|=
name|vg
operator|->
name|vg_extentsize
operator|*
operator|(
name|off_t
operator|)
name|lv
operator|->
name|lv_extentcount
expr_stmt|;
name|pp
operator|->
name|sectorsize
operator|=
name|vg
operator|->
name|vg_sectorsize
expr_stmt|;
name|g_error_provider
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lv
operator|->
name|lv_gprov
operator|=
name|pp
expr_stmt|;
name|pp
operator|->
name|private
operator|=
name|lv
expr_stmt|;
name|G_LVM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Created %s, %juM"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|pp
operator|->
name|mediasize
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_lvm_add_disk
parameter_list|(
name|struct
name|g_lvm_vg
modifier|*
name|vg
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|char
modifier|*
name|uuid
parameter_list|)
block|{
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|,
modifier|*
name|fcp
decl_stmt|;
name|struct
name|g_lvm_pv
modifier|*
name|pv
decl_stmt|;
name|struct
name|g_lvm_lv
modifier|*
name|lv
decl_stmt|;
name|struct
name|g_lvm_segment
modifier|*
name|sg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&vg->vg_pvs
argument_list|,
argument|pv_next
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|pv
operator|->
name|pv_uuid
argument_list|,
name|uuid
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* found it */
block|}
if|if
condition|(
name|pv
operator|==
name|NULL
condition|)
block|{
name|G_LVM_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"uuid %s not found in pv list"
argument_list|,
name|uuid
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
if|if
condition|(
name|pv
operator|->
name|pv_gprov
operator|!=
name|NULL
condition|)
block|{
name|G_LVM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"disk %s already initialised in %s"
argument_list|,
name|pv
operator|->
name|pv_name
argument_list|,
name|vg
operator|->
name|vg_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
name|pv
operator|->
name|pv_start
operator|*=
name|vg
operator|->
name|vg_sectorsize
expr_stmt|;
name|gp
operator|=
name|vg
operator|->
name|vg_geom
expr_stmt|;
name|fcp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|gp
operator|->
name|consumer
argument_list|)
expr_stmt|;
name|cp
operator|=
name|g_new_consumer
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_attach
argument_list|(
name|cp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|G_LVM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Attached %s to %s at offset %ju"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|pv
operator|->
name|pv_name
argument_list|,
name|pv
operator|->
name|pv_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_LVM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"cannot attach %s to %s"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|vg
operator|->
name|vg_name
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|fcp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fcp
operator|->
name|provider
operator|->
name|sectorsize
operator|!=
name|pp
operator|->
name|sectorsize
condition|)
block|{
name|G_LVM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Provider %s of %s has invalid "
literal|"sector size (%d)"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|vg
operator|->
name|vg_name
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|fcp
operator|->
name|acr
operator|>
literal|0
operator|||
name|fcp
operator|->
name|acw
operator|||
name|fcp
operator|->
name|ace
operator|>
literal|0
condition|)
block|{
comment|/* Replicate access permissions from first "live" 			 * consumer to the new one */
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
name|fcp
operator|->
name|acr
argument_list|,
name|fcp
operator|->
name|acw
argument_list|,
name|fcp
operator|->
name|ace
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
block|}
name|cp
operator|->
name|private
operator|=
name|pv
expr_stmt|;
name|pv
operator|->
name|pv_gcons
operator|=
name|cp
expr_stmt|;
name|pv
operator|->
name|pv_gprov
operator|=
name|pp
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lv
argument_list|,
argument|&vg->vg_lvs
argument_list|,
argument|lv_next
argument_list|)
block|{
comment|/* Find segments that map to this disk */
name|LIST_FOREACH
argument_list|(
argument|sg
argument_list|,
argument|&lv->lv_segs
argument_list|,
argument|sg_next
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|sg
operator|->
name|sg_pvname
argument_list|,
name|pv
operator|->
name|pv_name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* avtivate the segment */
name|KASSERT
argument_list|(
name|sg
operator|->
name|sg_pv
operator|==
name|NULL
argument_list|,
operator|(
literal|"segment already mapped"
operator|)
argument_list|)
expr_stmt|;
name|sg
operator|->
name|sg_pvoffset
operator|=
operator|(
name|off_t
operator|)
name|sg
operator|->
name|sg_pvstart
operator|*
name|vg
operator|->
name|vg_extentsize
operator|+
name|pv
operator|->
name|pv_start
expr_stmt|;
name|sg
operator|->
name|sg_pv
operator|=
name|pv
expr_stmt|;
name|lv
operator|->
name|lv_sgactive
operator|++
expr_stmt|;
name|G_LVM_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"%s: %d to %d @ %s:%d"
literal|" offset %ju sector %ju"
argument_list|,
name|lv
operator|->
name|lv_name
argument_list|,
name|sg
operator|->
name|sg_start
argument_list|,
name|sg
operator|->
name|sg_end
argument_list|,
name|sg
operator|->
name|sg_pvname
argument_list|,
name|sg
operator|->
name|sg_pvstart
argument_list|,
name|sg
operator|->
name|sg_pvoffset
argument_list|,
name|sg
operator|->
name|sg_pvoffset
operator|/
name|vg
operator|->
name|vg_sectorsize
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Activate any lvs waiting on this disk */
if|if
condition|(
name|lv
operator|->
name|lv_gprov
operator|==
name|NULL
operator|&&
name|lv
operator|->
name|lv_sgactive
operator|==
name|lv
operator|->
name|lv_sgcount
condition|)
block|{
name|error
operator|=
name|g_lvm_activate_lv
argument_list|(
name|vg
argument_list|,
name|lv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_lvm_init
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|vg_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_lvm_free_vg
parameter_list|(
name|struct
name|g_lvm_vg
modifier|*
name|vg
parameter_list|)
block|{
name|struct
name|g_lvm_pv
modifier|*
name|pv
decl_stmt|;
name|struct
name|g_lvm_lv
modifier|*
name|lv
decl_stmt|;
name|struct
name|g_lvm_segment
modifier|*
name|sg
decl_stmt|;
comment|/* Free all the structures */
while|while
condition|(
operator|(
name|pv
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|vg
operator|->
name|vg_pvs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|pv
argument_list|,
name|pv_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pv
argument_list|,
name|M_GLVM
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|lv
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|vg
operator|->
name|vg_lvs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|sg
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lv
operator|->
name|lv_segs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|sg
argument_list|,
name|sg_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sg
argument_list|,
name|M_GLVM
argument_list|)
expr_stmt|;
block|}
name|LIST_REMOVE
argument_list|(
name|lv
argument_list|,
name|lv_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lv
argument_list|,
name|M_GLVM
argument_list|)
expr_stmt|;
block|}
name|LIST_REMOVE
argument_list|(
name|vg
argument_list|,
name|vg_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vg
argument_list|,
name|M_GLVM
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_lvm_taste_orphan
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|KASSERT
argument_list|(
literal|1
operator|==
literal|0
argument_list|,
operator|(
literal|"%s called while tasting %s."
operator|,
name|__func__
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|g_geom
modifier|*
name|g_lvm_taste
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|flags
name|__unused
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_lvm_label
name|ll
decl_stmt|;
name|struct
name|g_lvm_metadata
name|md
decl_stmt|;
name|struct
name|g_lvm_vg
modifier|*
name|vg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|md
argument_list|,
sizeof|sizeof
argument_list|(
name|md
argument_list|)
argument_list|)
expr_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"%s(%s, %s)"
argument_list|,
name|__func__
argument_list|,
name|mp
operator|->
name|name
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|gp
operator|=
name|g_new_geomf
argument_list|(
name|mp
argument_list|,
literal|"lvm:taste"
argument_list|)
expr_stmt|;
comment|/* This orphan function should be never called. */
name|gp
operator|->
name|orphan
operator|=
name|g_lvm_taste_orphan
expr_stmt|;
name|cp
operator|=
name|g_new_consumer
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|g_attach
argument_list|(
name|cp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_lvm_read_label
argument_list|(
name|cp
argument_list|,
operator|&
name|ll
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|g_lvm_read_md
argument_list|(
name|cp
argument_list|,
operator|&
name|md
argument_list|,
operator|&
name|ll
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_geom
argument_list|(
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|vg
operator|=
name|md
operator|.
name|md_vg
expr_stmt|;
if|if
condition|(
name|vg
operator|->
name|vg_geom
operator|==
name|NULL
condition|)
block|{
comment|/* new volume group */
name|gp
operator|=
name|g_new_geomf
argument_list|(
name|mp
argument_list|,
literal|"%s"
argument_list|,
name|vg
operator|->
name|vg_name
argument_list|)
expr_stmt|;
name|gp
operator|->
name|start
operator|=
name|g_lvm_start
expr_stmt|;
name|gp
operator|->
name|spoiled
operator|=
name|g_lvm_orphan
expr_stmt|;
name|gp
operator|->
name|orphan
operator|=
name|g_lvm_orphan
expr_stmt|;
name|gp
operator|->
name|access
operator|=
name|g_lvm_access
expr_stmt|;
name|vg
operator|->
name|vg_sectorsize
operator|=
name|pp
operator|->
name|sectorsize
expr_stmt|;
name|vg
operator|->
name|vg_extentsize
operator|*=
name|vg
operator|->
name|vg_sectorsize
expr_stmt|;
name|vg
operator|->
name|vg_geom
operator|=
name|gp
expr_stmt|;
name|gp
operator|->
name|softc
operator|=
name|vg
expr_stmt|;
name|G_LVM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Created volume %s, extent size %zuK"
argument_list|,
name|vg
operator|->
name|vg_name
argument_list|,
name|vg
operator|->
name|vg_extentsize
operator|/
literal|1024
argument_list|)
expr_stmt|;
block|}
comment|/* initialise this disk in the volume group */
name|g_lvm_add_disk
argument_list|(
name|vg
argument_list|,
name|pp
argument_list|,
name|ll
operator|.
name|ll_uuid
argument_list|)
expr_stmt|;
return|return
operator|(
name|vg
operator|->
name|vg_geom
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_lvm_destroy
parameter_list|(
name|struct
name|g_lvm_vg
modifier|*
name|vg
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
if|if
condition|(
name|vg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|gp
operator|=
name|vg
operator|->
name|vg_geom
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pp
argument_list|,
argument|&gp->provider
argument_list|,
argument|provider
argument_list|)
block|{
if|if
condition|(
name|pp
operator|->
name|acr
operator|!=
literal|0
operator|||
name|pp
operator|->
name|acw
operator|!=
literal|0
operator|||
name|pp
operator|->
name|ace
operator|!=
literal|0
condition|)
block|{
name|G_LVM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Device %s is still open (r%dw%de%d)"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|pp
operator|->
name|acr
argument_list|,
name|pp
operator|->
name|acw
argument_list|,
name|pp
operator|->
name|ace
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|force
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
block|}
name|g_lvm_free_vg
argument_list|(
name|gp
operator|->
name|softc
argument_list|)
expr_stmt|;
name|gp
operator|->
name|softc
operator|=
name|NULL
expr_stmt|;
name|g_wither_geom
argument_list|(
name|gp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_lvm_destroy_geom
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
name|__unused
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
name|__unused
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|)
block|{
name|struct
name|g_lvm_vg
modifier|*
name|vg
decl_stmt|;
name|vg
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
return|return
operator|(
name|g_lvm_destroy
argument_list|(
name|vg
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|g_lvm_read_label
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_lvm_label
modifier|*
name|ll
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
comment|/* The LVM label is stored on the first four sectors */
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|,
name|pp
operator|->
name|sectorsize
operator|*
literal|4
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|G_LVM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Cannot read metadata from %s (error=%d)"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Search the four sectors for the LVM label. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|lvm_label_decode
argument_list|(
operator|&
name|buf
index|[
name|i
operator|*
name|pp
operator|->
name|sectorsize
index|]
argument_list|,
name|ll
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
break|break;
comment|/* found it */
block|}
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|g_lvm_read_md
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_lvm_metadata
modifier|*
name|md
parameter_list|,
name|struct
name|g_lvm_label
modifier|*
name|ll
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|size
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|ll
operator|->
name|ll_md_offset
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|G_LVM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot read metadata from %s (error=%d)"
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|lvm_md_decode
argument_list|(
name|buf
argument_list|,
name|md
argument_list|,
name|ll
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|G_LVM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"reading LVM2 config @ %s:%ju"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|ll
operator|->
name|ll_md_offset
operator|+
name|md
operator|->
name|md_reloffset
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
comment|/* round up to the nearest sector */
name|size
operator|=
name|md
operator|->
name|md_relsize
operator|+
operator|(
name|pp
operator|->
name|sectorsize
operator|-
name|md
operator|->
name|md_relsize
operator|%
name|pp
operator|->
name|sectorsize
operator|)
expr_stmt|;
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|ll
operator|->
name|ll_md_offset
operator|+
name|md
operator|->
name|md_reloffset
argument_list|,
name|size
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|G_LVM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot read LVM2 config from %s (error=%d)"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|buf
index|[
name|md
operator|->
name|md_relsize
index|]
operator|=
literal|'\0'
expr_stmt|;
name|G_LVM_DEBUG
argument_list|(
literal|10
argument_list|,
literal|"LVM config:\n%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|error
operator|=
name|lvm_textconf_decode
argument_list|(
name|buf
argument_list|,
name|md
operator|->
name|md_relsize
argument_list|,
name|md
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lvm_label_decode
parameter_list|(
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|struct
name|g_lvm_label
modifier|*
name|ll
parameter_list|,
name|int
name|sector
parameter_list|)
block|{
name|uint64_t
name|off
decl_stmt|;
name|char
modifier|*
name|uuid
decl_stmt|;
comment|/* Magic string */
if|if
condition|(
name|bcmp
argument_list|(
literal|"LABELONE"
argument_list|,
name|data
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* We only support LVM2 text format */
if|if
condition|(
name|bcmp
argument_list|(
literal|"LVM2 001"
argument_list|,
name|data
operator|+
literal|24
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|G_LVM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Unsupported LVM format"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ll
operator|->
name|ll_sector
operator|=
name|le64dec
argument_list|(
name|data
operator|+
literal|8
argument_list|)
expr_stmt|;
name|ll
operator|->
name|ll_crc
operator|=
name|le32dec
argument_list|(
name|data
operator|+
literal|16
argument_list|)
expr_stmt|;
name|ll
operator|->
name|ll_offset
operator|=
name|le32dec
argument_list|(
name|data
operator|+
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|ll
operator|->
name|ll_sector
operator|!=
name|sector
condition|)
block|{
name|G_LVM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Expected sector %ju, found at %d"
argument_list|,
name|ll
operator|->
name|ll_sector
argument_list|,
name|sector
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|off
operator|=
name|ll
operator|->
name|ll_offset
expr_stmt|;
comment|/* 	 * convert the binary uuid to string format, the format is 	 * xxxxxx-xxxx-xxxx-xxxx-xxxx-xxxx-xxxxxx (6-4-4-4-4-4-6) 	 */
name|uuid
operator|=
name|ll
operator|->
name|ll_uuid
expr_stmt|;
name|bcopy
argument_list|(
name|data
operator|+
name|off
argument_list|,
name|uuid
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|6
expr_stmt|;
name|uuid
operator|+=
literal|6
expr_stmt|;
operator|*
name|uuid
operator|++
operator|=
literal|'-'
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|bcopy
argument_list|(
name|data
operator|+
name|off
argument_list|,
name|uuid
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|4
expr_stmt|;
name|uuid
operator|+=
literal|4
expr_stmt|;
operator|*
name|uuid
operator|++
operator|=
literal|'-'
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|data
operator|+
name|off
argument_list|,
name|uuid
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|6
expr_stmt|;
name|uuid
operator|+=
literal|6
expr_stmt|;
operator|*
name|uuid
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|ll
operator|->
name|ll_size
operator|=
name|le64dec
argument_list|(
name|data
operator|+
name|off
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|8
expr_stmt|;
name|ll
operator|->
name|ll_pestart
operator|=
name|le64dec
argument_list|(
name|data
operator|+
name|off
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|16
expr_stmt|;
comment|/* Only one data section is supported */
if|if
condition|(
name|le64dec
argument_list|(
name|data
operator|+
name|off
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|G_LVM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Only one data section supported"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|off
operator|+=
literal|16
expr_stmt|;
name|ll
operator|->
name|ll_md_offset
operator|=
name|le64dec
argument_list|(
name|data
operator|+
name|off
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|8
expr_stmt|;
name|ll
operator|->
name|ll_md_size
operator|=
name|le64dec
argument_list|(
name|data
operator|+
name|off
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|8
expr_stmt|;
name|G_LVM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"LVM metadata: offset=%ju, size=%ju"
argument_list|,
name|ll
operator|->
name|ll_md_offset
argument_list|,
name|ll
operator|->
name|ll_md_size
argument_list|)
expr_stmt|;
comment|/* Only one data section is supported */
if|if
condition|(
name|le64dec
argument_list|(
name|data
operator|+
name|off
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|G_LVM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Only one metadata section supported"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|G_LVM_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"label uuid=%s"
argument_list|,
name|ll
operator|->
name|ll_uuid
argument_list|)
expr_stmt|;
name|G_LVM_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"sector=%ju, crc=%u, offset=%u, size=%ju, pestart=%ju"
argument_list|,
name|ll
operator|->
name|ll_sector
argument_list|,
name|ll
operator|->
name|ll_crc
argument_list|,
name|ll
operator|->
name|ll_offset
argument_list|,
name|ll
operator|->
name|ll_size
argument_list|,
name|ll
operator|->
name|ll_pestart
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lvm_md_decode
parameter_list|(
specifier|const
name|u_char
modifier|*
name|data
parameter_list|,
name|struct
name|g_lvm_metadata
modifier|*
name|md
parameter_list|,
name|struct
name|g_lvm_label
modifier|*
name|ll
parameter_list|)
block|{
name|uint64_t
name|off
decl_stmt|;
name|char
name|magic
index|[
literal|16
index|]
decl_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|md
operator|->
name|md_csum
operator|=
name|le32dec
argument_list|(
name|data
operator|+
name|off
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|4
expr_stmt|;
name|bcopy
argument_list|(
name|data
operator|+
name|off
argument_list|,
name|magic
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|16
expr_stmt|;
name|md
operator|->
name|md_version
operator|=
name|le32dec
argument_list|(
name|data
operator|+
name|off
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|4
expr_stmt|;
name|md
operator|->
name|md_start
operator|=
name|le64dec
argument_list|(
name|data
operator|+
name|off
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|8
expr_stmt|;
name|md
operator|->
name|md_size
operator|=
name|le64dec
argument_list|(
name|data
operator|+
name|off
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|G_LVM_MAGIC
argument_list|,
name|magic
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|G_LVM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Incorrect md magic number"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|md
operator|->
name|md_version
operator|!=
literal|1
condition|)
block|{
name|G_LVM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Incorrect md version number (%u)"
argument_list|,
name|md
operator|->
name|md_version
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|md
operator|->
name|md_start
operator|!=
name|ll
operator|->
name|ll_md_offset
condition|)
block|{
name|G_LVM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Incorrect md offset (%ju)"
argument_list|,
name|md
operator|->
name|md_start
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Aparently only one is ever returned */
name|md
operator|->
name|md_reloffset
operator|=
name|le64dec
argument_list|(
name|data
operator|+
name|off
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|8
expr_stmt|;
name|md
operator|->
name|md_relsize
operator|=
name|le64dec
argument_list|(
name|data
operator|+
name|off
argument_list|)
expr_stmt|;
name|off
operator|+=
literal|16
expr_stmt|;
comment|/* XXX skipped checksum */
if|if
condition|(
name|le64dec
argument_list|(
name|data
operator|+
name|off
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|G_LVM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Only one reloc supported"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|G_LVM_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"reloc: offset=%ju, size=%ju"
argument_list|,
name|md
operator|->
name|md_reloffset
argument_list|,
name|md
operator|->
name|md_relsize
argument_list|)
expr_stmt|;
name|G_LVM_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"md: version=%u, start=%ju, size=%ju"
argument_list|,
name|md
operator|->
name|md_version
argument_list|,
name|md
operator|->
name|md_start
argument_list|,
name|md
operator|->
name|md_size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|GRAB_NAME
parameter_list|(
name|tok
parameter_list|,
name|name
parameter_list|,
name|len
parameter_list|)
define|\
value|len = 0;							\ 	while (tok[len]&& (isalpha(tok[len]) || isdigit(tok[len]))&&	\ 	    len< G_LVM_NAMELEN - 1)					\ 		len++;							\ 	bcopy(tok, name, len);						\ 	name[len] = '\0';
end_define

begin_define
define|#
directive|define
name|GRAB_INT
parameter_list|(
name|key
parameter_list|,
name|tok1
parameter_list|,
name|tok2
parameter_list|,
name|v
parameter_list|)
define|\
value|if (tok1&& tok2&& strncmp(tok1, key, sizeof(key)) == 0) {	\ 		v = strtol(tok2,&tok1, 10);				\ 		if (tok1 == tok2)					\
comment|/* strtol did not eat any of the buffer */
value|\ 			goto bad;					\ 		continue;						\ 	}
end_define

begin_define
define|#
directive|define
name|GRAB_STR
parameter_list|(
name|key
parameter_list|,
name|tok1
parameter_list|,
name|tok2
parameter_list|,
name|v
parameter_list|,
name|len
parameter_list|)
define|\
value|if (tok1&& tok2&& strncmp(tok1, key, sizeof(key)) == 0) {	\ 		strsep(&tok2, "\"");					\ 		if (tok2 == NULL)					\ 			continue;					\ 		tok1 = strsep(&tok2, "\"");				\ 		if (tok2 == NULL)					\ 			continue;					\ 		strncpy(v, tok1, len);					\ 		continue;						\ 	}
end_define

begin_define
define|#
directive|define
name|SPLIT
parameter_list|(
name|key
parameter_list|,
name|value
parameter_list|,
name|str
parameter_list|)
define|\
value|key = strsep(&value, str);					\
comment|/* strip trailing whitespace on the key */
value|\ 	for (char *t = key; *t != '\0'; t++)				\ 		if (isspace(*t)) {					\ 			*t = '\0';					\ 			break;						\ 		}
end_define

begin_function
specifier|static
name|int
name|lvm_textconf_decode
parameter_list|(
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|buflen
parameter_list|,
name|struct
name|g_lvm_metadata
modifier|*
name|md
parameter_list|)
block|{
name|struct
name|g_lvm_vg
modifier|*
name|vg
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|data
decl_stmt|;
name|char
modifier|*
name|tok
decl_stmt|,
modifier|*
name|v
decl_stmt|;
name|char
name|name
index|[
name|G_LVM_NAMELEN
index|]
decl_stmt|;
name|char
name|uuid
index|[
name|G_LVM_UUIDLEN
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
operator|||
operator|*
name|buf
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|tok
operator|=
name|strsep
argument_list|(
operator|&
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|GRAB_NAME
argument_list|(
name|tok
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* check too see if the vg has already been loaded off another disk */
name|LIST_FOREACH
argument_list|(
argument|vg
argument_list|,
argument|&vg_list
argument_list|,
argument|vg_next
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|vg
operator|->
name|vg_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uuid
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* grab the volume group uuid */
while|while
condition|(
operator|(
name|tok
operator|=
name|strsep
argument_list|(
operator|&
name|buf
argument_list|,
literal|"\n"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|tok
argument_list|,
literal|"{"
argument_list|)
condition|)
break|break;
if|if
condition|(
name|strstr
argument_list|(
name|tok
argument_list|,
literal|"="
argument_list|)
condition|)
block|{
name|SPLIT
argument_list|(
name|v
argument_list|,
name|tok
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
name|GRAB_STR
argument_list|(
literal|"id"
argument_list|,
name|v
argument_list|,
name|tok
argument_list|,
name|uuid
argument_list|,
sizeof|sizeof
argument_list|(
name|uuid
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|vg
operator|->
name|vg_uuid
argument_list|,
name|uuid
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* existing vg */
name|md
operator|->
name|md_vg
operator|=
name|vg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* XXX different volume group with name clash! */
name|G_LVM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"%s already exists, volume group not loaded"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
name|vg
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vg
argument_list|)
argument_list|,
name|M_GLVM
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|vg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|strncpy
argument_list|(
name|vg
operator|->
name|vg_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|vg
operator|->
name|vg_name
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|vg
operator|->
name|vg_pvs
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|vg
operator|->
name|vg_lvs
argument_list|)
expr_stmt|;
define|#
directive|define
name|VOL_FOREACH
parameter_list|(
name|func
parameter_list|,
name|tok
parameter_list|,
name|buf
parameter_list|,
name|p
parameter_list|)
define|\
value|while ((tok = strsep(buf, "\n")) != NULL) {			\ 		if (strstr(tok, "{")) {					\ 			func(buf, tok, p);				\ 			continue;					\ 		}							\ 		if (strstr(tok, "}"))					\ 			break;						\ 	}
while|while
condition|(
operator|(
name|tok
operator|=
name|strsep
argument_list|(
operator|&
name|buf
argument_list|,
literal|"\n"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tok
argument_list|,
literal|"physical_volumes {"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VOL_FOREACH
argument_list|(
name|lvm_textconf_decode_pv
argument_list|,
name|tok
argument_list|,
operator|&
name|buf
argument_list|,
name|vg
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|tok
argument_list|,
literal|"logical_volumes {"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VOL_FOREACH
argument_list|(
name|lvm_textconf_decode_lv
argument_list|,
name|tok
argument_list|,
operator|&
name|buf
argument_list|,
name|vg
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|tok
argument_list|,
literal|"{"
argument_list|)
condition|)
block|{
name|G_LVM_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"unknown section %s"
argument_list|,
name|tok
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* parse 'key = value' lines */
if|if
condition|(
name|strstr
argument_list|(
name|tok
argument_list|,
literal|"="
argument_list|)
condition|)
block|{
name|SPLIT
argument_list|(
name|v
argument_list|,
name|tok
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
name|GRAB_STR
argument_list|(
literal|"id"
argument_list|,
name|v
argument_list|,
name|tok
argument_list|,
name|vg
operator|->
name|vg_uuid
argument_list|,
sizeof|sizeof
argument_list|(
name|vg
operator|->
name|vg_uuid
argument_list|)
argument_list|)
expr_stmt|;
name|GRAB_INT
argument_list|(
literal|"extent_size"
argument_list|,
name|v
argument_list|,
name|tok
argument_list|,
name|vg
operator|->
name|vg_extentsize
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* basic checking */
if|if
condition|(
name|vg
operator|->
name|vg_extentsize
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|md
operator|->
name|md_vg
operator|=
name|vg
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|vg_list
argument_list|,
name|vg
argument_list|,
name|vg_next
argument_list|)
expr_stmt|;
name|G_LVM_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"vg: name=%s uuid=%s"
argument_list|,
name|vg
operator|->
name|vg_name
argument_list|,
name|vg
operator|->
name|vg_uuid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|g_lvm_free_vg
argument_list|(
name|vg
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|VOL_FOREACH
end_undef

begin_function
specifier|static
name|int
name|lvm_textconf_decode_pv
parameter_list|(
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|tok
parameter_list|,
name|struct
name|g_lvm_vg
modifier|*
name|vg
parameter_list|)
block|{
name|struct
name|g_lvm_pv
modifier|*
name|pv
decl_stmt|;
name|char
modifier|*
name|v
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
name|NULL
operator|||
operator|*
operator|*
name|buf
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pv
argument_list|)
argument_list|,
name|M_GLVM
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|pv
operator|->
name|pv_vg
operator|=
name|vg
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|GRAB_NAME
argument_list|(
name|tok
argument_list|,
name|pv
operator|->
name|pv_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
while|while
condition|(
operator|(
name|tok
operator|=
name|strsep
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|tok
argument_list|,
literal|"{"
argument_list|)
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|strstr
argument_list|(
name|tok
argument_list|,
literal|"}"
argument_list|)
condition|)
break|break;
comment|/* parse 'key = value' lines */
if|if
condition|(
name|strstr
argument_list|(
name|tok
argument_list|,
literal|"="
argument_list|)
condition|)
block|{
name|SPLIT
argument_list|(
name|v
argument_list|,
name|tok
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
name|GRAB_STR
argument_list|(
literal|"id"
argument_list|,
name|v
argument_list|,
name|tok
argument_list|,
name|pv
operator|->
name|pv_uuid
argument_list|,
sizeof|sizeof
argument_list|(
name|pv
operator|->
name|pv_uuid
argument_list|)
argument_list|)
expr_stmt|;
name|GRAB_INT
argument_list|(
literal|"pe_start"
argument_list|,
name|v
argument_list|,
name|tok
argument_list|,
name|pv
operator|->
name|pv_start
argument_list|)
expr_stmt|;
name|GRAB_INT
argument_list|(
literal|"pe_count"
argument_list|,
name|v
argument_list|,
name|tok
argument_list|,
name|pv
operator|->
name|pv_count
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|tok
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
comment|/* basic checking */
if|if
condition|(
name|pv
operator|->
name|pv_count
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|vg
operator|->
name|vg_pvs
argument_list|,
name|pv
argument_list|,
name|pv_next
argument_list|)
expr_stmt|;
name|G_LVM_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"pv: name=%s uuid=%s"
argument_list|,
name|pv
operator|->
name|pv_name
argument_list|,
name|pv
operator|->
name|pv_uuid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|free
argument_list|(
name|pv
argument_list|,
name|M_GLVM
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lvm_textconf_decode_lv
parameter_list|(
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|tok
parameter_list|,
name|struct
name|g_lvm_vg
modifier|*
name|vg
parameter_list|)
block|{
name|struct
name|g_lvm_lv
modifier|*
name|lv
decl_stmt|;
name|struct
name|g_lvm_segment
modifier|*
name|sg
decl_stmt|;
name|char
modifier|*
name|v
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
name|NULL
operator|||
operator|*
operator|*
name|buf
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|lv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lv
argument_list|)
argument_list|,
name|M_GLVM
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|lv
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|lv
operator|->
name|lv_vg
operator|=
name|vg
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|lv
operator|->
name|lv_segs
argument_list|)
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|GRAB_NAME
argument_list|(
name|tok
argument_list|,
name|lv
operator|->
name|lv_name
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
while|while
condition|(
operator|(
name|tok
operator|=
name|strsep
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|tok
argument_list|,
literal|"{"
argument_list|)
condition|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|tok
argument_list|,
literal|"segment"
argument_list|)
condition|)
block|{
name|lvm_textconf_decode_sg
argument_list|(
name|buf
argument_list|,
name|tok
argument_list|,
name|lv
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
comment|/* unexpected section */
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|tok
argument_list|,
literal|"}"
argument_list|)
condition|)
break|break;
comment|/* parse 'key = value' lines */
if|if
condition|(
name|strstr
argument_list|(
name|tok
argument_list|,
literal|"="
argument_list|)
condition|)
block|{
name|SPLIT
argument_list|(
name|v
argument_list|,
name|tok
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
name|GRAB_STR
argument_list|(
literal|"id"
argument_list|,
name|v
argument_list|,
name|tok
argument_list|,
name|lv
operator|->
name|lv_uuid
argument_list|,
sizeof|sizeof
argument_list|(
name|lv
operator|->
name|lv_uuid
argument_list|)
argument_list|)
expr_stmt|;
name|GRAB_INT
argument_list|(
literal|"segment_count"
argument_list|,
name|v
argument_list|,
name|tok
argument_list|,
name|lv
operator|->
name|lv_sgcount
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|tok
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|lv
operator|->
name|lv_sgcount
operator|==
literal|0
operator|||
name|lv
operator|->
name|lv_sgcount
operator|!=
name|lv
operator|->
name|lv_numsegs
condition|)
comment|/* zero or incomplete segment list */
goto|goto
name|bad
goto|;
comment|/* Optimize for only one segment on the pv */
name|lv
operator|->
name|lv_firstsg
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lv
operator|->
name|lv_segs
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|vg
operator|->
name|vg_lvs
argument_list|,
name|lv
argument_list|,
name|lv_next
argument_list|)
expr_stmt|;
name|G_LVM_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"lv: name=%s uuid=%s"
argument_list|,
name|lv
operator|->
name|lv_name
argument_list|,
name|lv
operator|->
name|lv_uuid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
while|while
condition|(
operator|(
name|sg
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|lv
operator|->
name|lv_segs
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|sg
argument_list|,
name|sg_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sg
argument_list|,
name|M_GLVM
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|lv
argument_list|,
name|M_GLVM
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lvm_textconf_decode_sg
parameter_list|(
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|tok
parameter_list|,
name|struct
name|g_lvm_lv
modifier|*
name|lv
parameter_list|)
block|{
name|struct
name|g_lvm_segment
modifier|*
name|sg
decl_stmt|;
name|char
modifier|*
name|v
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
name|NULL
operator|||
operator|*
operator|*
name|buf
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sg
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sg
argument_list|)
argument_list|,
name|M_GLVM
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
while|while
condition|(
operator|(
name|tok
operator|=
name|strsep
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* only a single linear stripe is supported */
if|if
condition|(
name|strstr
argument_list|(
name|tok
argument_list|,
literal|"stripe_count"
argument_list|)
condition|)
block|{
name|SPLIT
argument_list|(
name|v
argument_list|,
name|tok
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
name|GRAB_INT
argument_list|(
literal|"stripe_count"
argument_list|,
name|v
argument_list|,
name|tok
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|1
condition|)
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|strstr
argument_list|(
name|tok
argument_list|,
literal|"{"
argument_list|)
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|strstr
argument_list|(
name|tok
argument_list|,
literal|"}"
argument_list|)
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|tok
argument_list|,
literal|"stripes = ["
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tok
operator|=
name|strsep
argument_list|(
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|strsep
argument_list|(
operator|&
name|tok
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
comment|/* missing open quotes */
name|v
operator|=
name|strsep
argument_list|(
operator|&
name|tok
argument_list|,
literal|"\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
comment|/* missing close quotes */
name|strncpy
argument_list|(
name|sg
operator|->
name|sg_pvname
argument_list|,
name|v
argument_list|,
sizeof|sizeof
argument_list|(
name|sg
operator|->
name|sg_pvname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tok
operator|!=
literal|','
condition|)
goto|goto
name|bad
goto|;
comment|/* missing comma for stripe */
name|tok
operator|++
expr_stmt|;
name|sg
operator|->
name|sg_pvstart
operator|=
name|strtol
argument_list|(
name|tok
argument_list|,
operator|&
name|v
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|tok
condition|)
comment|/* strtol did not eat any of the buffer */
goto|goto
name|bad
goto|;
continue|continue;
block|}
comment|/* parse 'key = value' lines */
if|if
condition|(
name|strstr
argument_list|(
name|tok
argument_list|,
literal|"="
argument_list|)
condition|)
block|{
name|SPLIT
argument_list|(
name|v
argument_list|,
name|tok
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
name|GRAB_INT
argument_list|(
literal|"start_extent"
argument_list|,
name|v
argument_list|,
name|tok
argument_list|,
name|sg
operator|->
name|sg_start
argument_list|)
expr_stmt|;
name|GRAB_INT
argument_list|(
literal|"extent_count"
argument_list|,
name|v
argument_list|,
name|tok
argument_list|,
name|sg
operator|->
name|sg_count
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|tok
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
comment|/* basic checking */
if|if
condition|(
name|count
operator|!=
literal|1
operator|||
name|sg
operator|->
name|sg_count
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|sg
operator|->
name|sg_end
operator|=
name|sg
operator|->
name|sg_start
operator|+
name|sg
operator|->
name|sg_count
operator|-
literal|1
expr_stmt|;
name|lv
operator|->
name|lv_numsegs
operator|++
expr_stmt|;
name|lv
operator|->
name|lv_extentcount
operator|+=
name|sg
operator|->
name|sg_count
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|lv
operator|->
name|lv_segs
argument_list|,
name|sg
argument_list|,
name|sg_next
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|free
argument_list|(
name|sg
argument_list|,
name|M_GLVM
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|GRAB_NAME
end_undef

begin_undef
undef|#
directive|undef
name|GRAB_INT
end_undef

begin_undef
undef|#
directive|undef
name|GRAB_STR
end_undef

begin_undef
undef|#
directive|undef
name|SPLIT
end_undef

begin_decl_stmt
specifier|static
name|struct
name|g_class
name|g_lvm_class
init|=
block|{
operator|.
name|name
operator|=
name|G_LVM_CLASS_NAME
block|,
operator|.
name|version
operator|=
name|G_VERSION
block|,
operator|.
name|init
operator|=
name|g_lvm_init
block|,
operator|.
name|taste
operator|=
name|g_lvm_taste
block|,
operator|.
name|destroy_geom
operator|=
name|g_lvm_destroy_geom
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_GEOM_CLASS
argument_list|(
name|g_lvm_class
argument_list|,
name|g_lvm
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

