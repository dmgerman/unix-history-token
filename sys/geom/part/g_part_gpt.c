begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002, 2005, 2006, 2007 Marcel Moolenaar  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/diskmbr.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/gpt.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/uuid.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/part/g_part.h>
end_include

begin_include
include|#
directive|include
file|"g_part_if.h"
end_include

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|gpt_hdr
argument_list|,
name|padding
argument_list|)
operator|==
literal|92
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gpt_ent
argument_list|)
operator|==
literal|128
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|EQUUID
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(memcmp(a, b, sizeof(struct uuid)) == 0)
end_define

begin_enum
enum|enum
name|gpt_elt
block|{
name|GPT_ELT_PRIHDR
block|,
name|GPT_ELT_PRITBL
block|,
name|GPT_ELT_SECHDR
block|,
name|GPT_ELT_SECTBL
block|,
name|GPT_ELT_COUNT
block|}
enum|;
end_enum

begin_enum
enum|enum
name|gpt_state
block|{
name|GPT_STATE_UNKNOWN
block|,
comment|/* Not determined. */
name|GPT_STATE_MISSING
block|,
comment|/* No signature found. */
name|GPT_STATE_CORRUPT
block|,
comment|/* Checksum mismatch. */
name|GPT_STATE_INVALID
block|,
comment|/* Nonconformant/invalid. */
name|GPT_STATE_OK
comment|/* Perfectly fine. */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|g_part_gpt_table
block|{
name|struct
name|g_part_table
name|base
decl_stmt|;
name|struct
name|gpt_hdr
name|hdr
decl_stmt|;
name|quad_t
name|lba
index|[
name|GPT_ELT_COUNT
index|]
decl_stmt|;
name|enum
name|gpt_state
name|state
index|[
name|GPT_ELT_COUNT
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|g_part_gpt_entry
block|{
name|struct
name|g_part_entry
name|base
decl_stmt|;
name|struct
name|gpt_ent
name|ent
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|g_part_gpt_add
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|,
name|struct
name|g_part_parms
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_gpt_create
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_parms
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_gpt_destroy
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_parms
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_gpt_dumpto
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_gpt_modify
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|,
name|struct
name|g_part_parms
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|g_part_gpt_name
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_gpt_probe
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_consumer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_gpt_read
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_consumer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|g_part_gpt_type
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_gpt_write
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_consumer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|kobj_method_t
name|g_part_gpt_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|g_part_add
argument_list|,
name|g_part_gpt_add
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_create
argument_list|,
name|g_part_gpt_create
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_destroy
argument_list|,
name|g_part_gpt_destroy
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_dumpto
argument_list|,
name|g_part_gpt_dumpto
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_modify
argument_list|,
name|g_part_gpt_modify
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_name
argument_list|,
name|g_part_gpt_name
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_probe
argument_list|,
name|g_part_gpt_probe
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_read
argument_list|,
name|g_part_gpt_read
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_type
argument_list|,
name|g_part_gpt_type
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_write
argument_list|,
name|g_part_gpt_write
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|g_part_scheme
name|g_part_gpt_scheme
init|=
block|{
literal|"GPT"
block|,
name|g_part_gpt_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|g_part_gpt_table
argument_list|)
block|,
operator|.
name|gps_entrysz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|g_part_gpt_entry
argument_list|)
block|,
operator|.
name|gps_minent
operator|=
literal|128
block|,
operator|.
name|gps_maxent
operator|=
name|INT_MAX
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|G_PART_SCHEME_DECLARE
argument_list|(
name|g_part_gpt_scheme
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|gpt_uuid_efi
init|=
name|GPT_ENT_TYPE_EFI
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|gpt_uuid_freebsd
init|=
name|GPT_ENT_TYPE_FREEBSD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|gpt_uuid_freebsd_swap
init|=
name|GPT_ENT_TYPE_FREEBSD_SWAP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|gpt_uuid_freebsd_ufs
init|=
name|GPT_ENT_TYPE_FREEBSD_UFS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|gpt_uuid_freebsd_vinum
init|=
name|GPT_ENT_TYPE_FREEBSD_VINUM
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|gpt_uuid_linux_swap
init|=
name|GPT_ENT_TYPE_LINUX_SWAP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|gpt_uuid_mbr
init|=
name|GPT_ENT_TYPE_MBR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|gpt_uuid_unused
init|=
name|GPT_ENT_TYPE_UNUSED
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|gpt_read_hdr
parameter_list|(
name|struct
name|g_part_gpt_table
modifier|*
name|table
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|enum
name|gpt_elt
name|elt
parameter_list|,
name|struct
name|gpt_hdr
modifier|*
name|hdr
parameter_list|)
block|{
name|struct
name|uuid
name|uuid
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|quad_t
name|lba
decl_stmt|,
name|last
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|crc
decl_stmt|,
name|sz
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|last
operator|=
operator|(
name|pp
operator|->
name|mediasize
operator|/
name|pp
operator|->
name|sectorsize
operator|)
operator|-
literal|1
expr_stmt|;
name|table
operator|->
name|lba
index|[
name|elt
index|]
operator|=
operator|(
name|elt
operator|==
name|GPT_ELT_PRIHDR
operator|)
condition|?
literal|1
else|:
name|last
expr_stmt|;
name|table
operator|->
name|state
index|[
name|elt
index|]
operator|=
name|GPT_STATE_MISSING
expr_stmt|;
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|table
operator|->
name|lba
index|[
name|elt
index|]
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|hdr
operator|->
name|hdr_sig
argument_list|,
name|GPT_HDR_SIG
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|hdr_sig
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|table
operator|->
name|state
index|[
name|elt
index|]
operator|=
name|GPT_STATE_CORRUPT
expr_stmt|;
name|sz
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|hdr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|<
literal|92
operator|||
name|sz
operator|>
name|pp
operator|->
name|sectorsize
condition|)
return|return;
name|crc
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|hdr_crc_self
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|hdr_crc_self
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|crc32
argument_list|(
name|hdr
argument_list|,
name|sz
argument_list|)
operator|!=
name|crc
condition|)
return|return;
name|hdr
operator|->
name|hdr_size
operator|=
name|sz
expr_stmt|;
name|hdr
operator|->
name|hdr_crc_self
operator|=
name|crc
expr_stmt|;
name|table
operator|->
name|state
index|[
name|elt
index|]
operator|=
name|GPT_STATE_INVALID
expr_stmt|;
name|hdr
operator|->
name|hdr_revision
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|hdr_revision
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|hdr_revision
operator|<
literal|0x00010000
condition|)
return|return;
name|hdr
operator|->
name|hdr_lba_self
operator|=
name|le64toh
argument_list|(
name|hdr
operator|->
name|hdr_lba_self
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|hdr_lba_self
operator|!=
name|table
operator|->
name|lba
index|[
name|elt
index|]
condition|)
return|return;
name|hdr
operator|->
name|hdr_lba_alt
operator|=
name|le64toh
argument_list|(
name|hdr
operator|->
name|hdr_lba_alt
argument_list|)
expr_stmt|;
comment|/* Check the managed area. */
name|hdr
operator|->
name|hdr_lba_start
operator|=
name|le64toh
argument_list|(
name|hdr
operator|->
name|hdr_lba_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|hdr_lba_start
operator|<
literal|2
operator|||
name|hdr
operator|->
name|hdr_lba_start
operator|>=
name|last
condition|)
return|return;
name|hdr
operator|->
name|hdr_lba_end
operator|=
name|le64toh
argument_list|(
name|hdr
operator|->
name|hdr_lba_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|hdr_lba_end
operator|<
name|hdr
operator|->
name|hdr_lba_start
operator|||
name|hdr
operator|->
name|hdr_lba_end
operator|>=
name|last
condition|)
return|return;
comment|/* Check the table location and size of the table. */
name|hdr
operator|->
name|hdr_entries
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|hdr_entries
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|hdr_entsz
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|hdr_entsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|hdr_entries
operator|==
literal|0
operator|||
name|hdr
operator|->
name|hdr_entsz
operator|<
literal|128
operator|||
operator|(
name|hdr
operator|->
name|hdr_entsz
operator|&
literal|7
operator|)
operator|!=
literal|0
condition|)
return|return;
name|hdr
operator|->
name|hdr_lba_table
operator|=
name|le64toh
argument_list|(
name|hdr
operator|->
name|hdr_lba_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|hdr_lba_table
operator|<
literal|2
operator|||
name|hdr
operator|->
name|hdr_lba_table
operator|>=
name|last
condition|)
return|return;
if|if
condition|(
name|hdr
operator|->
name|hdr_lba_table
operator|>=
name|hdr
operator|->
name|hdr_lba_start
operator|&&
name|hdr
operator|->
name|hdr_lba_table
operator|<=
name|hdr
operator|->
name|hdr_lba_end
condition|)
return|return;
name|lba
operator|=
name|hdr
operator|->
name|hdr_lba_table
operator|+
operator|(
name|hdr
operator|->
name|hdr_entries
operator|*
name|hdr
operator|->
name|hdr_entsz
operator|+
name|pp
operator|->
name|sectorsize
operator|-
literal|1
operator|)
operator|/
name|pp
operator|->
name|sectorsize
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lba
operator|>=
name|last
condition|)
return|return;
if|if
condition|(
name|lba
operator|>=
name|hdr
operator|->
name|hdr_lba_start
operator|&&
name|lba
operator|<=
name|hdr
operator|->
name|hdr_lba_end
condition|)
return|return;
name|table
operator|->
name|state
index|[
name|elt
index|]
operator|=
name|GPT_STATE_OK
expr_stmt|;
name|le_uuid_dec
argument_list|(
operator|&
name|hdr
operator|->
name|hdr_uuid
argument_list|,
operator|&
name|uuid
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|hdr_uuid
operator|=
name|uuid
expr_stmt|;
name|hdr
operator|->
name|hdr_crc_table
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|hdr_crc_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|gpt_ent
modifier|*
name|gpt_read_tbl
parameter_list|(
name|struct
name|g_part_gpt_table
modifier|*
name|table
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|enum
name|gpt_elt
name|elt
parameter_list|,
name|struct
name|gpt_hdr
modifier|*
name|hdr
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|gpt_ent
modifier|*
name|ent
decl_stmt|,
modifier|*
name|tbl
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|,
name|sectors
decl_stmt|,
name|tblsz
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint16_t
name|ch
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|table
operator|->
name|lba
index|[
name|elt
index|]
operator|=
name|hdr
operator|->
name|hdr_lba_table
expr_stmt|;
name|table
operator|->
name|state
index|[
name|elt
index|]
operator|=
name|GPT_STATE_MISSING
expr_stmt|;
name|tblsz
operator|=
name|hdr
operator|->
name|hdr_entries
operator|*
name|hdr
operator|->
name|hdr_entsz
expr_stmt|;
name|sectors
operator|=
operator|(
name|tblsz
operator|+
name|pp
operator|->
name|sectorsize
operator|-
literal|1
operator|)
operator|/
name|pp
operator|->
name|sectorsize
expr_stmt|;
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|table
operator|->
name|lba
index|[
name|elt
index|]
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
name|sectors
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|table
operator|->
name|state
index|[
name|elt
index|]
operator|=
name|GPT_STATE_CORRUPT
expr_stmt|;
if|if
condition|(
name|crc32
argument_list|(
name|buf
argument_list|,
name|tblsz
argument_list|)
operator|!=
name|hdr
operator|->
name|hdr_crc_table
condition|)
block|{
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|table
operator|->
name|state
index|[
name|elt
index|]
operator|=
name|GPT_STATE_OK
expr_stmt|;
name|tbl
operator|=
name|g_malloc
argument_list|(
name|hdr
operator|->
name|hdr_entries
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|gpt_ent
argument_list|)
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
operator|,
name|ent
operator|=
name|tbl
operator|,
name|p
operator|=
name|buf
init|;
name|idx
operator|<
name|hdr
operator|->
name|hdr_entries
condition|;
name|idx
operator|++
operator|,
name|ent
operator|++
operator|,
name|p
operator|+=
name|hdr
operator|->
name|hdr_entsz
control|)
block|{
name|le_uuid_dec
argument_list|(
name|p
argument_list|,
operator|&
name|ent
operator|->
name|ent_type
argument_list|)
expr_stmt|;
name|le_uuid_dec
argument_list|(
name|p
operator|+
literal|16
argument_list|,
operator|&
name|ent
operator|->
name|ent_uuid
argument_list|)
expr_stmt|;
name|ent
operator|->
name|ent_lba_start
operator|=
name|le64dec
argument_list|(
name|p
operator|+
literal|32
argument_list|)
expr_stmt|;
name|ent
operator|->
name|ent_lba_end
operator|=
name|le64dec
argument_list|(
name|p
operator|+
literal|40
argument_list|)
expr_stmt|;
name|ent
operator|->
name|ent_attr
operator|=
name|le64dec
argument_list|(
name|p
operator|+
literal|48
argument_list|)
expr_stmt|;
for|for
control|(
name|ch
operator|=
literal|0
init|;
name|ch
operator|<
sizeof|sizeof
argument_list|(
name|ent
operator|->
name|ent_name
argument_list|)
operator|/
literal|2
condition|;
name|ch
operator|++
control|)
name|ent
operator|->
name|ent_name
index|[
name|ch
index|]
operator|=
name|le16dec
argument_list|(
name|p
operator|+
literal|56
operator|+
name|ch
operator|*
literal|2
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|tbl
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gpt_matched_hdrs
parameter_list|(
name|struct
name|gpt_hdr
modifier|*
name|pri
parameter_list|,
name|struct
name|gpt_hdr
modifier|*
name|sec
parameter_list|)
block|{
if|if
condition|(
operator|!
name|EQUUID
argument_list|(
operator|&
name|pri
operator|->
name|hdr_uuid
argument_list|,
operator|&
name|sec
operator|->
name|hdr_uuid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|(
name|pri
operator|->
name|hdr_revision
operator|==
name|sec
operator|->
name|hdr_revision
operator|&&
name|pri
operator|->
name|hdr_size
operator|==
name|sec
operator|->
name|hdr_size
operator|&&
name|pri
operator|->
name|hdr_lba_start
operator|==
name|sec
operator|->
name|hdr_lba_start
operator|&&
name|pri
operator|->
name|hdr_lba_end
operator|==
name|sec
operator|->
name|hdr_lba_end
operator|&&
name|pri
operator|->
name|hdr_entries
operator|==
name|sec
operator|->
name|hdr_entries
operator|&&
name|pri
operator|->
name|hdr_entsz
operator|==
name|sec
operator|->
name|hdr_entsz
operator|&&
name|pri
operator|->
name|hdr_crc_table
operator|==
name|sec
operator|->
name|hdr_crc_table
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gpt_parse_type
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|struct
name|uuid
modifier|*
name|uuid
parameter_list|)
block|{
name|struct
name|uuid
name|tmp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|type
index|[
literal|0
index|]
operator|!=
literal|'@'
condition|)
block|{
name|error
operator|=
name|parse_uuid
argument_list|(
name|type
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|EQUUID
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|gpt_uuid_unused
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|uuid
operator|=
name|tmp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|type
argument_list|,
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_EFI
argument_list|)
argument_list|)
condition|)
operator|*
name|uuid
operator|=
name|gpt_uuid_efi
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|type
argument_list|,
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_FREEBSD
argument_list|)
argument_list|)
condition|)
operator|*
name|uuid
operator|=
name|gpt_uuid_freebsd
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|type
argument_list|,
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_FREEBSD_SWAP
argument_list|)
argument_list|)
condition|)
operator|*
name|uuid
operator|=
name|gpt_uuid_freebsd_swap
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|type
argument_list|,
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_FREEBSD_UFS
argument_list|)
argument_list|)
condition|)
operator|*
name|uuid
operator|=
name|gpt_uuid_freebsd_ufs
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|type
argument_list|,
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_FREEBSD_VINUM
argument_list|)
argument_list|)
condition|)
operator|*
name|uuid
operator|=
name|gpt_uuid_freebsd_vinum
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|type
argument_list|,
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_MBR
argument_list|)
argument_list|)
condition|)
operator|*
name|uuid
operator|=
name|gpt_uuid_mbr
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_gpt_add
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|,
name|struct
name|g_part_parms
modifier|*
name|gpp
parameter_list|)
block|{
name|struct
name|g_part_gpt_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|error
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|g_part_gpt_entry
operator|*
operator|)
name|baseentry
expr_stmt|;
name|error
operator|=
name|gpt_parse_type
argument_list|(
name|gpp
operator|->
name|gpp_type
argument_list|,
operator|&
name|entry
operator|->
name|ent
operator|.
name|ent_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|kern_uuidgen
argument_list|(
operator|&
name|entry
operator|->
name|ent
operator|.
name|ent_uuid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|entry
operator|->
name|ent
operator|.
name|ent_lba_start
operator|=
name|baseentry
operator|->
name|gpe_start
expr_stmt|;
name|entry
operator|->
name|ent
operator|.
name|ent_lba_end
operator|=
name|baseentry
operator|->
name|gpe_end
expr_stmt|;
if|if
condition|(
name|baseentry
operator|->
name|gpe_deleted
condition|)
block|{
name|entry
operator|->
name|ent
operator|.
name|ent_attr
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|entry
operator|->
name|ent
operator|.
name|ent_name
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
operator|->
name|ent
operator|.
name|ent_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* XXX label */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_gpt_create
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_parms
modifier|*
name|gpp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_part_gpt_table
modifier|*
name|table
decl_stmt|;
name|quad_t
name|last
decl_stmt|;
name|size_t
name|tblsz
decl_stmt|;
name|table
operator|=
operator|(
expr|struct
name|g_part_gpt_table
operator|*
operator|)
name|basetable
expr_stmt|;
name|pp
operator|=
name|gpp
operator|->
name|gpp_provider
expr_stmt|;
name|tblsz
operator|=
operator|(
name|basetable
operator|->
name|gpt_entries
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|gpt_ent
argument_list|)
operator|+
name|pp
operator|->
name|sectorsize
operator|-
literal|1
operator|)
operator|/
name|pp
operator|->
name|sectorsize
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sectorsize
operator|<
literal|512
operator|||
name|pp
operator|->
name|mediasize
operator|<
operator|(
literal|3
operator|+
literal|2
operator|*
name|tblsz
operator|+
name|basetable
operator|->
name|gpt_entries
operator|)
operator|*
name|pp
operator|->
name|sectorsize
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|last
operator|=
operator|(
name|pp
operator|->
name|mediasize
operator|/
name|pp
operator|->
name|sectorsize
operator|)
operator|-
literal|1
expr_stmt|;
name|table
operator|->
name|lba
index|[
name|GPT_ELT_PRIHDR
index|]
operator|=
literal|1
expr_stmt|;
name|table
operator|->
name|lba
index|[
name|GPT_ELT_PRITBL
index|]
operator|=
literal|2
expr_stmt|;
name|table
operator|->
name|lba
index|[
name|GPT_ELT_SECHDR
index|]
operator|=
name|last
expr_stmt|;
name|table
operator|->
name|lba
index|[
name|GPT_ELT_SECTBL
index|]
operator|=
name|last
operator|-
name|tblsz
expr_stmt|;
name|bcopy
argument_list|(
name|GPT_HDR_SIG
argument_list|,
name|table
operator|->
name|hdr
operator|.
name|hdr_sig
argument_list|,
sizeof|sizeof
argument_list|(
name|table
operator|->
name|hdr
operator|.
name|hdr_sig
argument_list|)
argument_list|)
expr_stmt|;
name|table
operator|->
name|hdr
operator|.
name|hdr_revision
operator|=
name|GPT_HDR_REVISION
expr_stmt|;
name|table
operator|->
name|hdr
operator|.
name|hdr_size
operator|=
name|offsetof
argument_list|(
expr|struct
name|gpt_hdr
argument_list|,
name|padding
argument_list|)
expr_stmt|;
name|table
operator|->
name|hdr
operator|.
name|hdr_lba_start
operator|=
literal|2
operator|+
name|tblsz
expr_stmt|;
name|table
operator|->
name|hdr
operator|.
name|hdr_lba_end
operator|=
name|last
operator|-
name|tblsz
operator|-
literal|1
expr_stmt|;
name|kern_uuidgen
argument_list|(
operator|&
name|table
operator|->
name|hdr
operator|.
name|hdr_uuid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|table
operator|->
name|hdr
operator|.
name|hdr_entries
operator|=
name|basetable
operator|->
name|gpt_entries
expr_stmt|;
name|table
operator|->
name|hdr
operator|.
name|hdr_entsz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|gpt_ent
argument_list|)
expr_stmt|;
name|basetable
operator|->
name|gpt_first
operator|=
name|table
operator|->
name|hdr
operator|.
name|hdr_lba_start
expr_stmt|;
name|basetable
operator|->
name|gpt_last
operator|=
name|table
operator|->
name|hdr
operator|.
name|hdr_lba_end
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_gpt_destroy
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_parms
modifier|*
name|gpp
parameter_list|)
block|{
comment|/* 	 * Wipe the first 2 sectors as well as the last to clear the 	 * partitioning. 	 */
name|basetable
operator|->
name|gpt_smhead
operator||=
literal|3
expr_stmt|;
name|basetable
operator|->
name|gpt_smtail
operator||=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_gpt_dumpto
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|table
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|)
block|{
name|struct
name|g_part_gpt_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|g_part_gpt_entry
operator|*
operator|)
name|baseentry
expr_stmt|;
return|return
operator|(
operator|(
name|EQUUID
argument_list|(
operator|&
name|entry
operator|->
name|ent
operator|.
name|ent_type
argument_list|,
operator|&
name|gpt_uuid_freebsd_swap
argument_list|)
operator|||
name|EQUUID
argument_list|(
operator|&
name|entry
operator|->
name|ent
operator|.
name|ent_type
argument_list|,
operator|&
name|gpt_uuid_linux_swap
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_gpt_modify
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|,
name|struct
name|g_part_parms
modifier|*
name|gpp
parameter_list|)
block|{
name|struct
name|g_part_gpt_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|error
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|g_part_gpt_entry
operator|*
operator|)
name|baseentry
expr_stmt|;
name|error
operator|=
name|gpt_parse_type
argument_list|(
name|gpp
operator|->
name|gpp_type
argument_list|,
operator|&
name|entry
operator|->
name|ent
operator|.
name|ent_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* XXX label */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|g_part_gpt_name
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|table
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bufsz
parameter_list|)
block|{
name|struct
name|g_part_gpt_entry
modifier|*
name|entry
decl_stmt|;
name|char
name|c
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|g_part_gpt_entry
operator|*
operator|)
name|baseentry
expr_stmt|;
name|c
operator|=
operator|(
name|EQUUID
argument_list|(
operator|&
name|entry
operator|->
name|ent
operator|.
name|ent_type
argument_list|,
operator|&
name|gpt_uuid_freebsd
argument_list|)
operator|)
condition|?
literal|'s'
else|:
literal|'p'
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|bufsz
argument_list|,
literal|"%c%d"
argument_list|,
name|c
argument_list|,
name|baseentry
operator|->
name|gpe_index
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_gpt_probe
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|table
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|res
decl_stmt|;
comment|/* We don't nest, which means that our depth should be 0. */
if|if
condition|(
name|table
operator|->
name|gpt_depth
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
comment|/* 	 * Sanity-check the provider. Since the first sector on the provider 	 * must be a PMBR and a PMBR is 512 bytes large, the sector size 	 * must be at least 512 bytes.  Also, since the theoretical minimum 	 * number of sectors needed by GPT is 6, any medium that has less 	 * than 6 sectors is never going to be able to hold a GPT. The 	 * number 6 comes from: 	 *	1 sector for the PMBR 	 *	2 sectors for the GPT headers (each 1 sector) 	 *	2 sectors for the GPT tables (each 1 sector) 	 *	1 sector for an actual partition 	 * It's better to catch this pathological case early than behaving 	 * pathologically later on... 	 */
if|if
condition|(
name|pp
operator|->
name|sectorsize
operator|<
literal|512
operator|||
name|pp
operator|->
name|mediasize
operator|<
literal|6
operator|*
name|pp
operator|->
name|sectorsize
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* Check that there's a MBR. */
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
literal|0L
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|res
operator|=
name|le16dec
argument_list|(
name|buf
operator|+
name|DOSMAGICOFFSET
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|DOSMAGIC
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Check that there's a primary header. */
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|res
operator|=
name|memcmp
argument_list|(
name|buf
argument_list|,
name|GPT_HDR_SIG
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
return|return
operator|(
name|G_PART_PROBE_PRI_HIGH
operator|)
return|;
comment|/* No primary? Check that there's a secondary. */
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|pp
operator|->
name|mediasize
operator|-
name|pp
operator|->
name|sectorsize
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|res
operator|=
name|memcmp
argument_list|(
name|buf
argument_list|,
name|GPT_HDR_SIG
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|res
operator|==
literal|0
operator|)
condition|?
name|G_PART_PROBE_PRI_HIGH
else|:
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_gpt_read
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|gpt_hdr
name|prihdr
decl_stmt|,
name|sechdr
decl_stmt|;
name|struct
name|gpt_ent
modifier|*
name|tbl
decl_stmt|,
modifier|*
name|pritbl
decl_stmt|,
modifier|*
name|sectbl
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_part_gpt_table
modifier|*
name|table
decl_stmt|;
name|struct
name|g_part_gpt_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|index
decl_stmt|;
name|table
operator|=
operator|(
expr|struct
name|g_part_gpt_table
operator|*
operator|)
name|basetable
expr_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
comment|/* Read the primary header and table. */
name|gpt_read_hdr
argument_list|(
name|table
argument_list|,
name|cp
argument_list|,
name|GPT_ELT_PRIHDR
argument_list|,
operator|&
name|prihdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|state
index|[
name|GPT_ELT_PRIHDR
index|]
operator|==
name|GPT_STATE_OK
condition|)
block|{
name|pritbl
operator|=
name|gpt_read_tbl
argument_list|(
name|table
argument_list|,
name|cp
argument_list|,
name|GPT_ELT_PRITBL
argument_list|,
operator|&
name|prihdr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|table
operator|->
name|state
index|[
name|GPT_ELT_PRITBL
index|]
operator|=
name|GPT_STATE_MISSING
expr_stmt|;
name|pritbl
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Read the secondary header and table. */
name|gpt_read_hdr
argument_list|(
name|table
argument_list|,
name|cp
argument_list|,
name|GPT_ELT_SECHDR
argument_list|,
operator|&
name|sechdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|state
index|[
name|GPT_ELT_SECHDR
index|]
operator|==
name|GPT_STATE_OK
condition|)
block|{
name|sectbl
operator|=
name|gpt_read_tbl
argument_list|(
name|table
argument_list|,
name|cp
argument_list|,
name|GPT_ELT_SECTBL
argument_list|,
operator|&
name|sechdr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|table
operator|->
name|state
index|[
name|GPT_ELT_SECTBL
index|]
operator|=
name|GPT_STATE_MISSING
expr_stmt|;
name|sectbl
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Fail if we haven't got any good tables at all. */
if|if
condition|(
name|table
operator|->
name|state
index|[
name|GPT_ELT_PRITBL
index|]
operator|!=
name|GPT_STATE_OK
operator|&&
name|table
operator|->
name|state
index|[
name|GPT_ELT_SECTBL
index|]
operator|!=
name|GPT_STATE_OK
condition|)
block|{
name|printf
argument_list|(
literal|"GEOM: %s: corrupt or invalid GPT detected.\n"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"GEOM: %s: GPT rejected -- may not be recoverable.\n"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * If both headers are good but they disagree with each other, 	 * then invalidate one. We prefer to keep the primary header, 	 * unless the primary table is corrupt. 	 */
if|if
condition|(
name|table
operator|->
name|state
index|[
name|GPT_ELT_PRIHDR
index|]
operator|==
name|GPT_STATE_OK
operator|&&
name|table
operator|->
name|state
index|[
name|GPT_ELT_SECHDR
index|]
operator|==
name|GPT_STATE_OK
operator|&&
operator|!
name|gpt_matched_hdrs
argument_list|(
operator|&
name|prihdr
argument_list|,
operator|&
name|sechdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|table
operator|->
name|state
index|[
name|GPT_ELT_PRITBL
index|]
operator|==
name|GPT_STATE_OK
condition|)
name|table
operator|->
name|state
index|[
name|GPT_ELT_SECHDR
index|]
operator|=
name|GPT_STATE_INVALID
expr_stmt|;
else|else
name|table
operator|->
name|state
index|[
name|GPT_ELT_PRIHDR
index|]
operator|=
name|GPT_STATE_INVALID
expr_stmt|;
block|}
if|if
condition|(
name|table
operator|->
name|state
index|[
name|GPT_ELT_PRIHDR
index|]
operator|!=
name|GPT_STATE_OK
condition|)
block|{
name|printf
argument_list|(
literal|"GEOM: %s: the primary GPT table is corrupt or "
literal|"invalid.\n"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"GEOM: %s: using the secondary instead -- recovery "
literal|"strongly advised.\n"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|table
operator|->
name|hdr
operator|=
name|sechdr
expr_stmt|;
name|tbl
operator|=
name|sectbl
expr_stmt|;
if|if
condition|(
name|pritbl
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|pritbl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|table
operator|->
name|state
index|[
name|GPT_ELT_SECHDR
index|]
operator|!=
name|GPT_STATE_OK
condition|)
block|{
name|printf
argument_list|(
literal|"GEOM: %s: the secondary GPT table is corrupt "
literal|"or invalid.\n"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"GEOM: %s: using the primary only -- recovery "
literal|"suggested.\n"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|table
operator|->
name|hdr
operator|=
name|prihdr
expr_stmt|;
name|tbl
operator|=
name|pritbl
expr_stmt|;
if|if
condition|(
name|sectbl
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|sectbl
argument_list|)
expr_stmt|;
block|}
name|basetable
operator|->
name|gpt_first
operator|=
name|table
operator|->
name|hdr
operator|.
name|hdr_lba_start
expr_stmt|;
name|basetable
operator|->
name|gpt_last
operator|=
name|table
operator|->
name|hdr
operator|.
name|hdr_lba_end
expr_stmt|;
name|basetable
operator|->
name|gpt_entries
operator|=
name|table
operator|->
name|hdr
operator|.
name|hdr_entries
expr_stmt|;
for|for
control|(
name|index
operator|=
name|basetable
operator|->
name|gpt_entries
operator|-
literal|1
init|;
name|index
operator|>=
literal|0
condition|;
name|index
operator|--
control|)
block|{
if|if
condition|(
name|EQUUID
argument_list|(
operator|&
name|tbl
index|[
name|index
index|]
operator|.
name|ent_type
argument_list|,
operator|&
name|gpt_uuid_unused
argument_list|)
condition|)
continue|continue;
name|entry
operator|=
operator|(
expr|struct
name|g_part_gpt_entry
operator|*
operator|)
name|g_part_new_entry
argument_list|(
name|basetable
argument_list|,
name|index
operator|+
literal|1
argument_list|,
name|tbl
index|[
name|index
index|]
operator|.
name|ent_lba_start
argument_list|,
name|tbl
index|[
name|index
index|]
operator|.
name|ent_lba_end
argument_list|)
expr_stmt|;
name|entry
operator|->
name|ent
operator|=
name|tbl
index|[
name|index
index|]
expr_stmt|;
block|}
name|g_free
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|g_part_gpt_type
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bufsz
parameter_list|)
block|{
name|struct
name|g_part_gpt_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|uuid
modifier|*
name|type
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|g_part_gpt_entry
operator|*
operator|)
name|baseentry
expr_stmt|;
name|type
operator|=
operator|&
name|entry
operator|->
name|ent
operator|.
name|ent_type
expr_stmt|;
if|if
condition|(
name|EQUUID
argument_list|(
name|type
argument_list|,
operator|&
name|gpt_uuid_efi
argument_list|)
condition|)
return|return
operator|(
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_EFI
argument_list|)
operator|)
return|;
if|if
condition|(
name|EQUUID
argument_list|(
name|type
argument_list|,
operator|&
name|gpt_uuid_freebsd
argument_list|)
condition|)
return|return
operator|(
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_FREEBSD
argument_list|)
operator|)
return|;
if|if
condition|(
name|EQUUID
argument_list|(
name|type
argument_list|,
operator|&
name|gpt_uuid_freebsd_swap
argument_list|)
condition|)
return|return
operator|(
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_FREEBSD_SWAP
argument_list|)
operator|)
return|;
if|if
condition|(
name|EQUUID
argument_list|(
name|type
argument_list|,
operator|&
name|gpt_uuid_freebsd_ufs
argument_list|)
condition|)
return|return
operator|(
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_FREEBSD_UFS
argument_list|)
operator|)
return|;
if|if
condition|(
name|EQUUID
argument_list|(
name|type
argument_list|,
operator|&
name|gpt_uuid_freebsd_vinum
argument_list|)
condition|)
return|return
operator|(
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_FREEBSD_VINUM
argument_list|)
operator|)
return|;
if|if
condition|(
name|EQUUID
argument_list|(
name|type
argument_list|,
operator|&
name|gpt_uuid_mbr
argument_list|)
condition|)
return|return
operator|(
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_MBR
argument_list|)
operator|)
return|;
name|snprintf_uuid
argument_list|(
name|buf
argument_list|,
name|bufsz
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_gpt_write
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_part_entry
modifier|*
name|baseentry
decl_stmt|;
name|struct
name|g_part_gpt_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|g_part_gpt_table
modifier|*
name|table
decl_stmt|;
name|size_t
name|tlbsz
decl_stmt|;
name|uint32_t
name|crc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|index
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|table
operator|=
operator|(
expr|struct
name|g_part_gpt_table
operator|*
operator|)
name|basetable
expr_stmt|;
name|tlbsz
operator|=
operator|(
name|table
operator|->
name|hdr
operator|.
name|hdr_entries
operator|*
name|table
operator|->
name|hdr
operator|.
name|hdr_entsz
operator|+
name|pp
operator|->
name|sectorsize
operator|-
literal|1
operator|)
operator|/
name|pp
operator|->
name|sectorsize
expr_stmt|;
if|if
condition|(
name|basetable
operator|->
name|gpt_created
condition|)
block|{
name|buf
operator|=
name|g_malloc
argument_list|(
name|pp
operator|->
name|sectorsize
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|le16enc
argument_list|(
name|buf
operator|+
name|DOSMAGICOFFSET
argument_list|,
name|DOSMAGIC
argument_list|)
expr_stmt|;
name|buf
index|[
name|DOSPARTOFF
operator|+
literal|1
index|]
operator|=
literal|0xff
expr_stmt|;
comment|/* shd */
name|buf
index|[
name|DOSPARTOFF
operator|+
literal|2
index|]
operator|=
literal|0xff
expr_stmt|;
comment|/* ssect */
name|buf
index|[
name|DOSPARTOFF
operator|+
literal|3
index|]
operator|=
literal|0xff
expr_stmt|;
comment|/* scyl */
name|buf
index|[
name|DOSPARTOFF
operator|+
literal|4
index|]
operator|=
literal|0xee
expr_stmt|;
comment|/* typ */
name|buf
index|[
name|DOSPARTOFF
operator|+
literal|5
index|]
operator|=
literal|0xff
expr_stmt|;
comment|/* ehd */
name|buf
index|[
name|DOSPARTOFF
operator|+
literal|6
index|]
operator|=
literal|0xff
expr_stmt|;
comment|/* esect */
name|buf
index|[
name|DOSPARTOFF
operator|+
literal|7
index|]
operator|=
literal|0xff
expr_stmt|;
comment|/* ecyl */
name|le32enc
argument_list|(
name|buf
operator|+
name|DOSPARTOFF
operator|+
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* start */
name|le32enc
argument_list|(
name|buf
operator|+
name|DOSPARTOFF
operator|+
literal|12
argument_list|,
name|MIN
argument_list|(
name|pp
operator|->
name|mediasize
operator|/
name|pp
operator|->
name|sectorsize
operator|-
literal|1
argument_list|,
literal|0xffffffffLL
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_write_data
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Allocate space for the header and entries. */
name|buf
operator|=
name|g_malloc
argument_list|(
operator|(
name|tlbsz
operator|+
literal|1
operator|)
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|table
operator|->
name|hdr
operator|.
name|hdr_sig
argument_list|,
sizeof|sizeof
argument_list|(
name|table
operator|->
name|hdr
operator|.
name|hdr_sig
argument_list|)
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
name|buf
operator|+
literal|8
argument_list|,
name|table
operator|->
name|hdr
operator|.
name|hdr_revision
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
name|buf
operator|+
literal|12
argument_list|,
name|table
operator|->
name|hdr
operator|.
name|hdr_size
argument_list|)
expr_stmt|;
name|le64enc
argument_list|(
name|buf
operator|+
literal|40
argument_list|,
name|table
operator|->
name|hdr
operator|.
name|hdr_lba_start
argument_list|)
expr_stmt|;
name|le64enc
argument_list|(
name|buf
operator|+
literal|48
argument_list|,
name|table
operator|->
name|hdr
operator|.
name|hdr_lba_end
argument_list|)
expr_stmt|;
name|le_uuid_enc
argument_list|(
name|buf
operator|+
literal|56
argument_list|,
operator|&
name|table
operator|->
name|hdr
operator|.
name|hdr_uuid
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
name|buf
operator|+
literal|80
argument_list|,
name|table
operator|->
name|hdr
operator|.
name|hdr_entries
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
name|buf
operator|+
literal|84
argument_list|,
name|table
operator|->
name|hdr
operator|.
name|hdr_entsz
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|baseentry
argument_list|,
argument|&basetable->gpt_entry
argument_list|,
argument|gpe_entry
argument_list|)
block|{
name|entry
operator|=
operator|(
expr|struct
name|g_part_gpt_entry
operator|*
operator|)
name|baseentry
expr_stmt|;
name|index
operator|=
name|baseentry
operator|->
name|gpe_index
operator|-
literal|1
expr_stmt|;
name|bp
operator|=
name|buf
operator|+
name|pp
operator|->
name|sectorsize
operator|+
name|table
operator|->
name|hdr
operator|.
name|hdr_entsz
operator|*
name|index
expr_stmt|;
name|le_uuid_enc
argument_list|(
name|bp
argument_list|,
operator|&
name|entry
operator|->
name|ent
operator|.
name|ent_type
argument_list|)
expr_stmt|;
name|le_uuid_enc
argument_list|(
name|bp
operator|+
literal|16
argument_list|,
operator|&
name|entry
operator|->
name|ent
operator|.
name|ent_uuid
argument_list|)
expr_stmt|;
name|le64enc
argument_list|(
name|bp
operator|+
literal|32
argument_list|,
name|entry
operator|->
name|ent
operator|.
name|ent_lba_start
argument_list|)
expr_stmt|;
name|le64enc
argument_list|(
name|bp
operator|+
literal|40
argument_list|,
name|entry
operator|->
name|ent
operator|.
name|ent_lba_end
argument_list|)
expr_stmt|;
name|le64enc
argument_list|(
name|bp
operator|+
literal|48
argument_list|,
name|entry
operator|->
name|ent
operator|.
name|ent_attr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bp
operator|+
literal|56
argument_list|,
name|entry
operator|->
name|ent
operator|.
name|ent_name
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
operator|->
name|ent
operator|.
name|ent_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|crc
operator|=
name|crc32
argument_list|(
name|buf
operator|+
name|pp
operator|->
name|sectorsize
argument_list|,
name|table
operator|->
name|hdr
operator|.
name|hdr_entries
operator|*
name|table
operator|->
name|hdr
operator|.
name|hdr_entsz
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
name|buf
operator|+
literal|88
argument_list|,
name|crc
argument_list|)
expr_stmt|;
comment|/* Write primary meta-data. */
name|le32enc
argument_list|(
name|buf
operator|+
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* hdr_crc_self. */
name|le64enc
argument_list|(
name|buf
operator|+
literal|24
argument_list|,
name|table
operator|->
name|lba
index|[
name|GPT_ELT_PRIHDR
index|]
argument_list|)
expr_stmt|;
comment|/* hdr_lba_self. */
name|le64enc
argument_list|(
name|buf
operator|+
literal|32
argument_list|,
name|table
operator|->
name|lba
index|[
name|GPT_ELT_SECHDR
index|]
argument_list|)
expr_stmt|;
comment|/* hdr_lba_alt. */
name|le64enc
argument_list|(
name|buf
operator|+
literal|72
argument_list|,
name|table
operator|->
name|lba
index|[
name|GPT_ELT_PRITBL
index|]
argument_list|)
expr_stmt|;
comment|/* hdr_lba_table. */
name|crc
operator|=
name|crc32
argument_list|(
name|buf
argument_list|,
name|table
operator|->
name|hdr
operator|.
name|hdr_size
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
name|buf
operator|+
literal|16
argument_list|,
name|crc
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_write_data
argument_list|(
name|cp
argument_list|,
name|table
operator|->
name|lba
index|[
name|GPT_ELT_PRITBL
index|]
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
name|buf
operator|+
name|pp
operator|->
name|sectorsize
argument_list|,
name|tlbsz
operator|*
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|g_write_data
argument_list|(
name|cp
argument_list|,
name|table
operator|->
name|lba
index|[
name|GPT_ELT_PRIHDR
index|]
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
name|buf
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* Write secondary meta-data. */
name|le32enc
argument_list|(
name|buf
operator|+
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* hdr_crc_self. */
name|le64enc
argument_list|(
name|buf
operator|+
literal|24
argument_list|,
name|table
operator|->
name|lba
index|[
name|GPT_ELT_SECHDR
index|]
argument_list|)
expr_stmt|;
comment|/* hdr_lba_self. */
name|le64enc
argument_list|(
name|buf
operator|+
literal|32
argument_list|,
name|table
operator|->
name|lba
index|[
name|GPT_ELT_PRIHDR
index|]
argument_list|)
expr_stmt|;
comment|/* hdr_lba_alt. */
name|le64enc
argument_list|(
name|buf
operator|+
literal|72
argument_list|,
name|table
operator|->
name|lba
index|[
name|GPT_ELT_SECTBL
index|]
argument_list|)
expr_stmt|;
comment|/* hdr_lba_table. */
name|crc
operator|=
name|crc32
argument_list|(
name|buf
argument_list|,
name|table
operator|->
name|hdr
operator|.
name|hdr_size
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
name|buf
operator|+
literal|16
argument_list|,
name|crc
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_write_data
argument_list|(
name|cp
argument_list|,
name|table
operator|->
name|lba
index|[
name|GPT_ELT_SECTBL
index|]
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
name|buf
operator|+
name|pp
operator|->
name|sectorsize
argument_list|,
name|tlbsz
operator|*
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|g_write_data
argument_list|(
name|cp
argument_list|,
name|table
operator|->
name|lba
index|[
name|GPT_ELT_SECHDR
index|]
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
name|buf
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|out
label|:
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void g_gpt_to_utf8(struct sbuf *sb, uint16_t *str, size_t len) { 	u_int bo; 	uint32_t ch; 	uint16_t c;  	bo = BYTE_ORDER; 	while (len> 0&& *str != 0) { 		ch = (bo == BIG_ENDIAN) ? be16toh(*str) : le16toh(*str); 		str++, len--; 		if ((ch& 0xf800) == 0xd800) { 			if (len> 0) { 				c = (bo == BIG_ENDIAN) ? be16toh(*str) 				    : le16toh(*str); 				str++, len--; 			} else 				c = 0xfffd; 			if ((ch& 0x400) == 0&& (c& 0xfc00) == 0xdc00) { 				ch = ((ch& 0x3ff)<< 10) + (c& 0x3ff); 				ch += 0x10000; 			} else 				ch = 0xfffd; 		} else if (ch == 0xfffe) {
comment|/* BOM (U+FEFF) swapped. */
end_comment

begin_comment
unit|bo = (bo == BIG_ENDIAN) ? LITTLE_ENDIAN : BIG_ENDIAN; 			continue; 		} else if (ch == 0xfeff)
comment|/* BOM (U+FEFF) unswapped. */
end_comment

begin_endif
unit|continue;  		if (ch< 0x80) 			sbuf_printf(sb, "%c", ch); 		else if (ch< 0x800) 			sbuf_printf(sb, "%c%c", 0xc0 | (ch>> 6), 			    0x80 | (ch& 0x3f)); 		else if (ch< 0x10000) 			sbuf_printf(sb, "%c%c%c", 0xe0 | (ch>> 12), 			    0x80 | ((ch>> 6)& 0x3f), 0x80 | (ch& 0x3f)); 		else if (ch< 0x200000) 			sbuf_printf(sb, "%c%c%c%c", 0xf0 | (ch>> 18), 			    0x80 | ((ch>> 12)& 0x3f), 			    0x80 | ((ch>> 6)& 0x3f), 0x80 | (ch& 0x3f)); 	} }
endif|#
directive|endif
end_endif

end_unit

