begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002, 2005, 2006, 2007 Marcel Moolenaar  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/diskmbr.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/gpt.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/uuid.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/part/g_part.h>
end_include

begin_include
include|#
directive|include
file|"g_part_if.h"
end_include

begin_expr_stmt
name|CTASSERT
argument_list|(
name|offsetof
argument_list|(
expr|struct
name|gpt_hdr
argument_list|,
name|padding
argument_list|)
operator|==
literal|92
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gpt_ent
argument_list|)
operator|==
literal|128
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|EQUUID
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(memcmp(a, b, sizeof(struct uuid)) == 0)
end_define

begin_define
define|#
directive|define
name|MBRSIZE
value|512
end_define

begin_enum
enum|enum
name|gpt_elt
block|{
name|GPT_ELT_PRIHDR
block|,
name|GPT_ELT_PRITBL
block|,
name|GPT_ELT_SECHDR
block|,
name|GPT_ELT_SECTBL
block|,
name|GPT_ELT_COUNT
block|}
enum|;
end_enum

begin_enum
enum|enum
name|gpt_state
block|{
name|GPT_STATE_UNKNOWN
block|,
comment|/* Not determined. */
name|GPT_STATE_MISSING
block|,
comment|/* No signature found. */
name|GPT_STATE_CORRUPT
block|,
comment|/* Checksum mismatch. */
name|GPT_STATE_INVALID
block|,
comment|/* Nonconformant/invalid. */
name|GPT_STATE_OK
comment|/* Perfectly fine. */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|g_part_gpt_table
block|{
name|struct
name|g_part_table
name|base
decl_stmt|;
name|u_char
name|mbr
index|[
name|MBRSIZE
index|]
decl_stmt|;
name|struct
name|gpt_hdr
name|hdr
decl_stmt|;
name|quad_t
name|lba
index|[
name|GPT_ELT_COUNT
index|]
decl_stmt|;
name|enum
name|gpt_state
name|state
index|[
name|GPT_ELT_COUNT
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|g_part_gpt_entry
block|{
name|struct
name|g_part_entry
name|base
decl_stmt|;
name|struct
name|gpt_ent
name|ent
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|g_gpt_printf_utf16
parameter_list|(
name|struct
name|sbuf
modifier|*
parameter_list|,
name|uint16_t
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_gpt_utf8_to_utf16
parameter_list|(
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|uint16_t
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_gpt_add
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|,
name|struct
name|g_part_parms
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_gpt_bootcode
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_parms
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_gpt_create
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_parms
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_gpt_destroy
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_parms
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_part_gpt_dumpconf
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|,
name|struct
name|sbuf
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_gpt_dumpto
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_gpt_modify
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|,
name|struct
name|g_part_parms
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|g_part_gpt_name
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_gpt_probe
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_consumer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_gpt_read
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_consumer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|g_part_gpt_type
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_gpt_write
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_consumer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|kobj_method_t
name|g_part_gpt_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|g_part_add
argument_list|,
name|g_part_gpt_add
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_bootcode
argument_list|,
name|g_part_gpt_bootcode
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_create
argument_list|,
name|g_part_gpt_create
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_destroy
argument_list|,
name|g_part_gpt_destroy
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_dumpconf
argument_list|,
name|g_part_gpt_dumpconf
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_dumpto
argument_list|,
name|g_part_gpt_dumpto
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_modify
argument_list|,
name|g_part_gpt_modify
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_name
argument_list|,
name|g_part_gpt_name
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_probe
argument_list|,
name|g_part_gpt_probe
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_read
argument_list|,
name|g_part_gpt_read
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_type
argument_list|,
name|g_part_gpt_type
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_write
argument_list|,
name|g_part_gpt_write
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|g_part_scheme
name|g_part_gpt_scheme
init|=
block|{
literal|"GPT"
block|,
name|g_part_gpt_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|g_part_gpt_table
argument_list|)
block|,
operator|.
name|gps_entrysz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|g_part_gpt_entry
argument_list|)
block|,
operator|.
name|gps_minent
operator|=
literal|128
block|,
operator|.
name|gps_maxent
operator|=
name|INT_MAX
block|,
operator|.
name|gps_bootcodesz
operator|=
name|MBRSIZE
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|G_PART_SCHEME_DECLARE
argument_list|(
name|g_part_gpt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|gpt_uuid_efi
init|=
name|GPT_ENT_TYPE_EFI
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|gpt_uuid_freebsd
init|=
name|GPT_ENT_TYPE_FREEBSD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|gpt_uuid_freebsd_boot
init|=
name|GPT_ENT_TYPE_FREEBSD_BOOT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|gpt_uuid_freebsd_swap
init|=
name|GPT_ENT_TYPE_FREEBSD_SWAP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|gpt_uuid_freebsd_ufs
init|=
name|GPT_ENT_TYPE_FREEBSD_UFS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|gpt_uuid_freebsd_vinum
init|=
name|GPT_ENT_TYPE_FREEBSD_VINUM
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|gpt_uuid_freebsd_zfs
init|=
name|GPT_ENT_TYPE_FREEBSD_ZFS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|gpt_uuid_linux_swap
init|=
name|GPT_ENT_TYPE_LINUX_SWAP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|gpt_uuid_mbr
init|=
name|GPT_ENT_TYPE_MBR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|gpt_uuid_unused
init|=
name|GPT_ENT_TYPE_UNUSED
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|gpt_read_hdr
parameter_list|(
name|struct
name|g_part_gpt_table
modifier|*
name|table
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|enum
name|gpt_elt
name|elt
parameter_list|,
name|struct
name|gpt_hdr
modifier|*
name|hdr
parameter_list|)
block|{
name|struct
name|uuid
name|uuid
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|quad_t
name|lba
decl_stmt|,
name|last
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|crc
decl_stmt|,
name|sz
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|last
operator|=
operator|(
name|pp
operator|->
name|mediasize
operator|/
name|pp
operator|->
name|sectorsize
operator|)
operator|-
literal|1
expr_stmt|;
name|table
operator|->
name|lba
index|[
name|elt
index|]
operator|=
operator|(
name|elt
operator|==
name|GPT_ELT_PRIHDR
operator|)
condition|?
literal|1
else|:
name|last
expr_stmt|;
name|table
operator|->
name|state
index|[
name|elt
index|]
operator|=
name|GPT_STATE_MISSING
expr_stmt|;
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|table
operator|->
name|lba
index|[
name|elt
index|]
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|hdr
operator|->
name|hdr_sig
argument_list|,
name|GPT_HDR_SIG
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|hdr_sig
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|table
operator|->
name|state
index|[
name|elt
index|]
operator|=
name|GPT_STATE_CORRUPT
expr_stmt|;
name|sz
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|hdr_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|<
literal|92
operator|||
name|sz
operator|>
name|pp
operator|->
name|sectorsize
condition|)
return|return;
name|crc
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|hdr_crc_self
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|hdr_crc_self
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|crc32
argument_list|(
name|hdr
argument_list|,
name|sz
argument_list|)
operator|!=
name|crc
condition|)
return|return;
name|hdr
operator|->
name|hdr_size
operator|=
name|sz
expr_stmt|;
name|hdr
operator|->
name|hdr_crc_self
operator|=
name|crc
expr_stmt|;
name|table
operator|->
name|state
index|[
name|elt
index|]
operator|=
name|GPT_STATE_INVALID
expr_stmt|;
name|hdr
operator|->
name|hdr_revision
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|hdr_revision
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|hdr_revision
operator|<
literal|0x00010000
condition|)
return|return;
name|hdr
operator|->
name|hdr_lba_self
operator|=
name|le64toh
argument_list|(
name|hdr
operator|->
name|hdr_lba_self
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|hdr_lba_self
operator|!=
name|table
operator|->
name|lba
index|[
name|elt
index|]
condition|)
return|return;
name|hdr
operator|->
name|hdr_lba_alt
operator|=
name|le64toh
argument_list|(
name|hdr
operator|->
name|hdr_lba_alt
argument_list|)
expr_stmt|;
comment|/* Check the managed area. */
name|hdr
operator|->
name|hdr_lba_start
operator|=
name|le64toh
argument_list|(
name|hdr
operator|->
name|hdr_lba_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|hdr_lba_start
operator|<
literal|2
operator|||
name|hdr
operator|->
name|hdr_lba_start
operator|>=
name|last
condition|)
return|return;
name|hdr
operator|->
name|hdr_lba_end
operator|=
name|le64toh
argument_list|(
name|hdr
operator|->
name|hdr_lba_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|hdr_lba_end
operator|<
name|hdr
operator|->
name|hdr_lba_start
operator|||
name|hdr
operator|->
name|hdr_lba_end
operator|>=
name|last
condition|)
return|return;
comment|/* Check the table location and size of the table. */
name|hdr
operator|->
name|hdr_entries
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|hdr_entries
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|hdr_entsz
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|hdr_entsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|hdr_entries
operator|==
literal|0
operator|||
name|hdr
operator|->
name|hdr_entsz
operator|<
literal|128
operator|||
operator|(
name|hdr
operator|->
name|hdr_entsz
operator|&
literal|7
operator|)
operator|!=
literal|0
condition|)
return|return;
name|hdr
operator|->
name|hdr_lba_table
operator|=
name|le64toh
argument_list|(
name|hdr
operator|->
name|hdr_lba_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|hdr_lba_table
operator|<
literal|2
operator|||
name|hdr
operator|->
name|hdr_lba_table
operator|>=
name|last
condition|)
return|return;
if|if
condition|(
name|hdr
operator|->
name|hdr_lba_table
operator|>=
name|hdr
operator|->
name|hdr_lba_start
operator|&&
name|hdr
operator|->
name|hdr_lba_table
operator|<=
name|hdr
operator|->
name|hdr_lba_end
condition|)
return|return;
name|lba
operator|=
name|hdr
operator|->
name|hdr_lba_table
operator|+
operator|(
name|hdr
operator|->
name|hdr_entries
operator|*
name|hdr
operator|->
name|hdr_entsz
operator|+
name|pp
operator|->
name|sectorsize
operator|-
literal|1
operator|)
operator|/
name|pp
operator|->
name|sectorsize
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lba
operator|>=
name|last
condition|)
return|return;
if|if
condition|(
name|lba
operator|>=
name|hdr
operator|->
name|hdr_lba_start
operator|&&
name|lba
operator|<=
name|hdr
operator|->
name|hdr_lba_end
condition|)
return|return;
name|table
operator|->
name|state
index|[
name|elt
index|]
operator|=
name|GPT_STATE_OK
expr_stmt|;
name|le_uuid_dec
argument_list|(
operator|&
name|hdr
operator|->
name|hdr_uuid
argument_list|,
operator|&
name|uuid
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|hdr_uuid
operator|=
name|uuid
expr_stmt|;
name|hdr
operator|->
name|hdr_crc_table
operator|=
name|le32toh
argument_list|(
name|hdr
operator|->
name|hdr_crc_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|gpt_ent
modifier|*
name|gpt_read_tbl
parameter_list|(
name|struct
name|g_part_gpt_table
modifier|*
name|table
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|enum
name|gpt_elt
name|elt
parameter_list|,
name|struct
name|gpt_hdr
modifier|*
name|hdr
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|gpt_ent
modifier|*
name|ent
decl_stmt|,
modifier|*
name|tbl
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|unsigned
name|int
name|idx
decl_stmt|,
name|sectors
decl_stmt|,
name|tblsz
decl_stmt|;
name|int
name|error
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|table
operator|->
name|lba
index|[
name|elt
index|]
operator|=
name|hdr
operator|->
name|hdr_lba_table
expr_stmt|;
name|table
operator|->
name|state
index|[
name|elt
index|]
operator|=
name|GPT_STATE_MISSING
expr_stmt|;
name|tblsz
operator|=
name|hdr
operator|->
name|hdr_entries
operator|*
name|hdr
operator|->
name|hdr_entsz
expr_stmt|;
name|sectors
operator|=
operator|(
name|tblsz
operator|+
name|pp
operator|->
name|sectorsize
operator|-
literal|1
operator|)
operator|/
name|pp
operator|->
name|sectorsize
expr_stmt|;
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|table
operator|->
name|lba
index|[
name|elt
index|]
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
name|sectors
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|table
operator|->
name|state
index|[
name|elt
index|]
operator|=
name|GPT_STATE_CORRUPT
expr_stmt|;
if|if
condition|(
name|crc32
argument_list|(
name|buf
argument_list|,
name|tblsz
argument_list|)
operator|!=
name|hdr
operator|->
name|hdr_crc_table
condition|)
block|{
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|table
operator|->
name|state
index|[
name|elt
index|]
operator|=
name|GPT_STATE_OK
expr_stmt|;
name|tbl
operator|=
name|g_malloc
argument_list|(
name|hdr
operator|->
name|hdr_entries
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|gpt_ent
argument_list|)
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
operator|,
name|ent
operator|=
name|tbl
operator|,
name|p
operator|=
name|buf
init|;
name|idx
operator|<
name|hdr
operator|->
name|hdr_entries
condition|;
name|idx
operator|++
operator|,
name|ent
operator|++
operator|,
name|p
operator|+=
name|hdr
operator|->
name|hdr_entsz
control|)
block|{
name|le_uuid_dec
argument_list|(
name|p
argument_list|,
operator|&
name|ent
operator|->
name|ent_type
argument_list|)
expr_stmt|;
name|le_uuid_dec
argument_list|(
name|p
operator|+
literal|16
argument_list|,
operator|&
name|ent
operator|->
name|ent_uuid
argument_list|)
expr_stmt|;
name|ent
operator|->
name|ent_lba_start
operator|=
name|le64dec
argument_list|(
name|p
operator|+
literal|32
argument_list|)
expr_stmt|;
name|ent
operator|->
name|ent_lba_end
operator|=
name|le64dec
argument_list|(
name|p
operator|+
literal|40
argument_list|)
expr_stmt|;
name|ent
operator|->
name|ent_attr
operator|=
name|le64dec
argument_list|(
name|p
operator|+
literal|48
argument_list|)
expr_stmt|;
comment|/* Keep UTF-16 in little-endian. */
name|bcopy
argument_list|(
name|p
operator|+
literal|56
argument_list|,
name|ent
operator|->
name|ent_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ent
operator|->
name|ent_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|tbl
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gpt_matched_hdrs
parameter_list|(
name|struct
name|gpt_hdr
modifier|*
name|pri
parameter_list|,
name|struct
name|gpt_hdr
modifier|*
name|sec
parameter_list|)
block|{
if|if
condition|(
operator|!
name|EQUUID
argument_list|(
operator|&
name|pri
operator|->
name|hdr_uuid
argument_list|,
operator|&
name|sec
operator|->
name|hdr_uuid
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|(
name|pri
operator|->
name|hdr_revision
operator|==
name|sec
operator|->
name|hdr_revision
operator|&&
name|pri
operator|->
name|hdr_size
operator|==
name|sec
operator|->
name|hdr_size
operator|&&
name|pri
operator|->
name|hdr_lba_start
operator|==
name|sec
operator|->
name|hdr_lba_start
operator|&&
name|pri
operator|->
name|hdr_lba_end
operator|==
name|sec
operator|->
name|hdr_lba_end
operator|&&
name|pri
operator|->
name|hdr_entries
operator|==
name|sec
operator|->
name|hdr_entries
operator|&&
name|pri
operator|->
name|hdr_entsz
operator|==
name|sec
operator|->
name|hdr_entsz
operator|&&
name|pri
operator|->
name|hdr_crc_table
operator|==
name|sec
operator|->
name|hdr_crc_table
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gpt_parse_type
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|struct
name|uuid
modifier|*
name|uuid
parameter_list|)
block|{
name|struct
name|uuid
name|tmp
decl_stmt|;
specifier|const
name|char
modifier|*
name|alias
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|type
index|[
literal|0
index|]
operator|==
literal|'!'
condition|)
block|{
name|error
operator|=
name|parse_uuid
argument_list|(
name|type
operator|+
literal|1
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|EQUUID
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|gpt_uuid_unused
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|uuid
operator|=
name|tmp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|alias
operator|=
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_EFI
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|type
argument_list|,
name|alias
argument_list|)
condition|)
block|{
operator|*
name|uuid
operator|=
name|gpt_uuid_efi
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|alias
operator|=
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_FREEBSD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|type
argument_list|,
name|alias
argument_list|)
condition|)
block|{
operator|*
name|uuid
operator|=
name|gpt_uuid_freebsd
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|alias
operator|=
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_FREEBSD_BOOT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|type
argument_list|,
name|alias
argument_list|)
condition|)
block|{
operator|*
name|uuid
operator|=
name|gpt_uuid_freebsd_boot
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|alias
operator|=
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_FREEBSD_SWAP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|type
argument_list|,
name|alias
argument_list|)
condition|)
block|{
operator|*
name|uuid
operator|=
name|gpt_uuid_freebsd_swap
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|alias
operator|=
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_FREEBSD_UFS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|type
argument_list|,
name|alias
argument_list|)
condition|)
block|{
operator|*
name|uuid
operator|=
name|gpt_uuid_freebsd_ufs
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|alias
operator|=
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_FREEBSD_VINUM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|type
argument_list|,
name|alias
argument_list|)
condition|)
block|{
operator|*
name|uuid
operator|=
name|gpt_uuid_freebsd_vinum
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|alias
operator|=
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_FREEBSD_ZFS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|type
argument_list|,
name|alias
argument_list|)
condition|)
block|{
operator|*
name|uuid
operator|=
name|gpt_uuid_freebsd_zfs
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|alias
operator|=
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_MBR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|type
argument_list|,
name|alias
argument_list|)
condition|)
block|{
operator|*
name|uuid
operator|=
name|gpt_uuid_mbr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_gpt_add
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|,
name|struct
name|g_part_parms
modifier|*
name|gpp
parameter_list|)
block|{
name|struct
name|g_part_gpt_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|error
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|g_part_gpt_entry
operator|*
operator|)
name|baseentry
expr_stmt|;
name|error
operator|=
name|gpt_parse_type
argument_list|(
name|gpp
operator|->
name|gpp_type
argument_list|,
operator|&
name|entry
operator|->
name|ent
operator|.
name|ent_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|kern_uuidgen
argument_list|(
operator|&
name|entry
operator|->
name|ent
operator|.
name|ent_uuid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|entry
operator|->
name|ent
operator|.
name|ent_lba_start
operator|=
name|baseentry
operator|->
name|gpe_start
expr_stmt|;
name|entry
operator|->
name|ent
operator|.
name|ent_lba_end
operator|=
name|baseentry
operator|->
name|gpe_end
expr_stmt|;
if|if
condition|(
name|baseentry
operator|->
name|gpe_deleted
condition|)
block|{
name|entry
operator|->
name|ent
operator|.
name|ent_attr
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|entry
operator|->
name|ent
operator|.
name|ent_name
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
operator|->
name|ent
operator|.
name|ent_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|gpp
operator|->
name|gpp_parms
operator|&
name|G_PART_PARM_LABEL
condition|)
name|g_gpt_utf8_to_utf16
argument_list|(
name|gpp
operator|->
name|gpp_label
argument_list|,
name|entry
operator|->
name|ent
operator|.
name|ent_name
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
operator|->
name|ent
operator|.
name|ent_name
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_gpt_bootcode
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_parms
modifier|*
name|gpp
parameter_list|)
block|{
name|struct
name|g_part_gpt_table
modifier|*
name|table
decl_stmt|;
name|size_t
name|codesz
decl_stmt|;
name|codesz
operator|=
name|DOSPARTOFF
expr_stmt|;
name|table
operator|=
operator|(
expr|struct
name|g_part_gpt_table
operator|*
operator|)
name|basetable
expr_stmt|;
name|bzero
argument_list|(
name|table
operator|->
name|mbr
argument_list|,
name|codesz
argument_list|)
expr_stmt|;
name|codesz
operator|=
name|MIN
argument_list|(
name|codesz
argument_list|,
name|gpp
operator|->
name|gpp_codesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|codesz
operator|>
literal|0
condition|)
name|bcopy
argument_list|(
name|gpp
operator|->
name|gpp_codeptr
argument_list|,
name|table
operator|->
name|mbr
argument_list|,
name|codesz
argument_list|)
expr_stmt|;
comment|/* Mark the PMBR active since some BIOS require it */
name|table
operator|->
name|mbr
index|[
name|DOSPARTOFF
index|]
operator|=
literal|0x80
expr_stmt|;
comment|/* status */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_gpt_create
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_parms
modifier|*
name|gpp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_part_gpt_table
modifier|*
name|table
decl_stmt|;
name|quad_t
name|last
decl_stmt|;
name|size_t
name|tblsz
decl_stmt|;
name|table
operator|=
operator|(
expr|struct
name|g_part_gpt_table
operator|*
operator|)
name|basetable
expr_stmt|;
name|pp
operator|=
name|gpp
operator|->
name|gpp_provider
expr_stmt|;
name|tblsz
operator|=
operator|(
name|basetable
operator|->
name|gpt_entries
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|gpt_ent
argument_list|)
operator|+
name|pp
operator|->
name|sectorsize
operator|-
literal|1
operator|)
operator|/
name|pp
operator|->
name|sectorsize
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sectorsize
operator|<
name|MBRSIZE
operator|||
name|pp
operator|->
name|mediasize
operator|<
operator|(
literal|3
operator|+
literal|2
operator|*
name|tblsz
operator|+
name|basetable
operator|->
name|gpt_entries
operator|)
operator|*
name|pp
operator|->
name|sectorsize
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|last
operator|=
operator|(
name|pp
operator|->
name|mediasize
operator|/
name|pp
operator|->
name|sectorsize
operator|)
operator|-
literal|1
expr_stmt|;
name|le16enc
argument_list|(
name|table
operator|->
name|mbr
operator|+
name|DOSMAGICOFFSET
argument_list|,
name|DOSMAGIC
argument_list|)
expr_stmt|;
name|table
operator|->
name|mbr
index|[
name|DOSPARTOFF
operator|+
literal|1
index|]
operator|=
literal|0xff
expr_stmt|;
comment|/* shd */
name|table
operator|->
name|mbr
index|[
name|DOSPARTOFF
operator|+
literal|2
index|]
operator|=
literal|0xff
expr_stmt|;
comment|/* ssect */
name|table
operator|->
name|mbr
index|[
name|DOSPARTOFF
operator|+
literal|3
index|]
operator|=
literal|0xff
expr_stmt|;
comment|/* scyl */
name|table
operator|->
name|mbr
index|[
name|DOSPARTOFF
operator|+
literal|4
index|]
operator|=
literal|0xee
expr_stmt|;
comment|/* typ */
name|table
operator|->
name|mbr
index|[
name|DOSPARTOFF
operator|+
literal|5
index|]
operator|=
literal|0xff
expr_stmt|;
comment|/* ehd */
name|table
operator|->
name|mbr
index|[
name|DOSPARTOFF
operator|+
literal|6
index|]
operator|=
literal|0xff
expr_stmt|;
comment|/* esect */
name|table
operator|->
name|mbr
index|[
name|DOSPARTOFF
operator|+
literal|7
index|]
operator|=
literal|0xff
expr_stmt|;
comment|/* ecyl */
name|le32enc
argument_list|(
name|table
operator|->
name|mbr
operator|+
name|DOSPARTOFF
operator|+
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* start */
name|le32enc
argument_list|(
name|table
operator|->
name|mbr
operator|+
name|DOSPARTOFF
operator|+
literal|12
argument_list|,
name|MIN
argument_list|(
name|last
argument_list|,
literal|0xffffffffLL
argument_list|)
argument_list|)
expr_stmt|;
name|table
operator|->
name|lba
index|[
name|GPT_ELT_PRIHDR
index|]
operator|=
literal|1
expr_stmt|;
name|table
operator|->
name|lba
index|[
name|GPT_ELT_PRITBL
index|]
operator|=
literal|2
expr_stmt|;
name|table
operator|->
name|lba
index|[
name|GPT_ELT_SECHDR
index|]
operator|=
name|last
expr_stmt|;
name|table
operator|->
name|lba
index|[
name|GPT_ELT_SECTBL
index|]
operator|=
name|last
operator|-
name|tblsz
expr_stmt|;
name|bcopy
argument_list|(
name|GPT_HDR_SIG
argument_list|,
name|table
operator|->
name|hdr
operator|.
name|hdr_sig
argument_list|,
sizeof|sizeof
argument_list|(
name|table
operator|->
name|hdr
operator|.
name|hdr_sig
argument_list|)
argument_list|)
expr_stmt|;
name|table
operator|->
name|hdr
operator|.
name|hdr_revision
operator|=
name|GPT_HDR_REVISION
expr_stmt|;
name|table
operator|->
name|hdr
operator|.
name|hdr_size
operator|=
name|offsetof
argument_list|(
expr|struct
name|gpt_hdr
argument_list|,
name|padding
argument_list|)
expr_stmt|;
name|table
operator|->
name|hdr
operator|.
name|hdr_lba_start
operator|=
literal|2
operator|+
name|tblsz
expr_stmt|;
name|table
operator|->
name|hdr
operator|.
name|hdr_lba_end
operator|=
name|last
operator|-
name|tblsz
operator|-
literal|1
expr_stmt|;
name|kern_uuidgen
argument_list|(
operator|&
name|table
operator|->
name|hdr
operator|.
name|hdr_uuid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|table
operator|->
name|hdr
operator|.
name|hdr_entries
operator|=
name|basetable
operator|->
name|gpt_entries
expr_stmt|;
name|table
operator|->
name|hdr
operator|.
name|hdr_entsz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|gpt_ent
argument_list|)
expr_stmt|;
name|basetable
operator|->
name|gpt_first
operator|=
name|table
operator|->
name|hdr
operator|.
name|hdr_lba_start
expr_stmt|;
name|basetable
operator|->
name|gpt_last
operator|=
name|table
operator|->
name|hdr
operator|.
name|hdr_lba_end
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_gpt_destroy
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_parms
modifier|*
name|gpp
parameter_list|)
block|{
comment|/* 	 * Wipe the first 2 sectors as well as the last to clear the 	 * partitioning. 	 */
name|basetable
operator|->
name|gpt_smhead
operator||=
literal|3
expr_stmt|;
name|basetable
operator|->
name|gpt_smtail
operator||=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_part_gpt_dumpconf
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|table
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|)
block|{
name|struct
name|g_part_gpt_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|g_part_gpt_entry
operator|*
operator|)
name|baseentry
expr_stmt|;
if|if
condition|(
name|indent
operator|==
name|NULL
condition|)
block|{
comment|/* conftxt: libdisk compatibility */
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" xs GPT xt "
argument_list|)
expr_stmt|;
name|sbuf_printf_uuid
argument_list|(
name|sb
argument_list|,
operator|&
name|entry
operator|->
name|ent
operator|.
name|ent_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
comment|/* confxml: partition entry information */
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<label>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|g_gpt_printf_utf16
argument_list|(
name|sb
argument_list|,
name|entry
operator|->
name|ent
operator|.
name|ent_name
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
operator|->
name|ent
operator|.
name|ent_name
argument_list|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</label>\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<rawtype>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|sbuf_printf_uuid
argument_list|(
name|sb
argument_list|,
operator|&
name|entry
operator|->
name|ent
operator|.
name|ent_type
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</rawtype>\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* confxml: scheme information */
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_gpt_dumpto
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|table
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|)
block|{
name|struct
name|g_part_gpt_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|g_part_gpt_entry
operator|*
operator|)
name|baseentry
expr_stmt|;
return|return
operator|(
operator|(
name|EQUUID
argument_list|(
operator|&
name|entry
operator|->
name|ent
operator|.
name|ent_type
argument_list|,
operator|&
name|gpt_uuid_freebsd_swap
argument_list|)
operator|||
name|EQUUID
argument_list|(
operator|&
name|entry
operator|->
name|ent
operator|.
name|ent_type
argument_list|,
operator|&
name|gpt_uuid_linux_swap
argument_list|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_gpt_modify
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|,
name|struct
name|g_part_parms
modifier|*
name|gpp
parameter_list|)
block|{
name|struct
name|g_part_gpt_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|error
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|g_part_gpt_entry
operator|*
operator|)
name|baseentry
expr_stmt|;
if|if
condition|(
name|gpp
operator|->
name|gpp_parms
operator|&
name|G_PART_PARM_TYPE
condition|)
block|{
name|error
operator|=
name|gpt_parse_type
argument_list|(
name|gpp
operator|->
name|gpp_type
argument_list|,
operator|&
name|entry
operator|->
name|ent
operator|.
name|ent_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|gpp
operator|->
name|gpp_parms
operator|&
name|G_PART_PARM_LABEL
condition|)
name|g_gpt_utf8_to_utf16
argument_list|(
name|gpp
operator|->
name|gpp_label
argument_list|,
name|entry
operator|->
name|ent
operator|.
name|ent_name
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
operator|->
name|ent
operator|.
name|ent_name
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|g_part_gpt_name
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|table
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bufsz
parameter_list|)
block|{
name|struct
name|g_part_gpt_entry
modifier|*
name|entry
decl_stmt|;
name|char
name|c
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|g_part_gpt_entry
operator|*
operator|)
name|baseentry
expr_stmt|;
name|c
operator|=
operator|(
name|EQUUID
argument_list|(
operator|&
name|entry
operator|->
name|ent
operator|.
name|ent_type
argument_list|,
operator|&
name|gpt_uuid_freebsd
argument_list|)
operator|)
condition|?
literal|'s'
else|:
literal|'p'
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|bufsz
argument_list|,
literal|"%c%d"
argument_list|,
name|c
argument_list|,
name|baseentry
operator|->
name|gpe_index
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_gpt_probe
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|table
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|res
decl_stmt|;
comment|/* We don't nest, which means that our depth should be 0. */
if|if
condition|(
name|table
operator|->
name|gpt_depth
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
comment|/* 	 * Sanity-check the provider. Since the first sector on the provider 	 * must be a PMBR and a PMBR is 512 bytes large, the sector size 	 * must be at least 512 bytes.  Also, since the theoretical minimum 	 * number of sectors needed by GPT is 6, any medium that has less 	 * than 6 sectors is never going to be able to hold a GPT. The 	 * number 6 comes from: 	 *	1 sector for the PMBR 	 *	2 sectors for the GPT headers (each 1 sector) 	 *	2 sectors for the GPT tables (each 1 sector) 	 *	1 sector for an actual partition 	 * It's better to catch this pathological case early than behaving 	 * pathologically later on... 	 */
if|if
condition|(
name|pp
operator|->
name|sectorsize
operator|<
name|MBRSIZE
operator|||
name|pp
operator|->
name|mediasize
operator|<
literal|6
operator|*
name|pp
operator|->
name|sectorsize
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* Check that there's a MBR. */
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
literal|0L
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|res
operator|=
name|le16dec
argument_list|(
name|buf
operator|+
name|DOSMAGICOFFSET
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|!=
name|DOSMAGIC
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Check that there's a primary header. */
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|res
operator|=
name|memcmp
argument_list|(
name|buf
argument_list|,
name|GPT_HDR_SIG
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
return|return
operator|(
name|G_PART_PROBE_PRI_HIGH
operator|)
return|;
comment|/* No primary? Check that there's a secondary. */
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|pp
operator|->
name|mediasize
operator|-
name|pp
operator|->
name|sectorsize
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|res
operator|=
name|memcmp
argument_list|(
name|buf
argument_list|,
name|GPT_HDR_SIG
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|res
operator|==
literal|0
operator|)
condition|?
name|G_PART_PROBE_PRI_HIGH
else|:
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_gpt_read
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|gpt_hdr
name|prihdr
decl_stmt|,
name|sechdr
decl_stmt|;
name|struct
name|gpt_ent
modifier|*
name|tbl
decl_stmt|,
modifier|*
name|pritbl
decl_stmt|,
modifier|*
name|sectbl
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_part_gpt_table
modifier|*
name|table
decl_stmt|;
name|struct
name|g_part_gpt_entry
modifier|*
name|entry
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|index
decl_stmt|;
name|table
operator|=
operator|(
expr|struct
name|g_part_gpt_table
operator|*
operator|)
name|basetable
expr_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
comment|/* Read the PMBR */
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|table
operator|->
name|mbr
argument_list|,
name|MBRSIZE
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Read the primary header and table. */
name|gpt_read_hdr
argument_list|(
name|table
argument_list|,
name|cp
argument_list|,
name|GPT_ELT_PRIHDR
argument_list|,
operator|&
name|prihdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|state
index|[
name|GPT_ELT_PRIHDR
index|]
operator|==
name|GPT_STATE_OK
condition|)
block|{
name|pritbl
operator|=
name|gpt_read_tbl
argument_list|(
name|table
argument_list|,
name|cp
argument_list|,
name|GPT_ELT_PRITBL
argument_list|,
operator|&
name|prihdr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|table
operator|->
name|state
index|[
name|GPT_ELT_PRITBL
index|]
operator|=
name|GPT_STATE_MISSING
expr_stmt|;
name|pritbl
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Read the secondary header and table. */
name|gpt_read_hdr
argument_list|(
name|table
argument_list|,
name|cp
argument_list|,
name|GPT_ELT_SECHDR
argument_list|,
operator|&
name|sechdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|state
index|[
name|GPT_ELT_SECHDR
index|]
operator|==
name|GPT_STATE_OK
condition|)
block|{
name|sectbl
operator|=
name|gpt_read_tbl
argument_list|(
name|table
argument_list|,
name|cp
argument_list|,
name|GPT_ELT_SECTBL
argument_list|,
operator|&
name|sechdr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|table
operator|->
name|state
index|[
name|GPT_ELT_SECTBL
index|]
operator|=
name|GPT_STATE_MISSING
expr_stmt|;
name|sectbl
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Fail if we haven't got any good tables at all. */
if|if
condition|(
name|table
operator|->
name|state
index|[
name|GPT_ELT_PRITBL
index|]
operator|!=
name|GPT_STATE_OK
operator|&&
name|table
operator|->
name|state
index|[
name|GPT_ELT_SECTBL
index|]
operator|!=
name|GPT_STATE_OK
condition|)
block|{
name|printf
argument_list|(
literal|"GEOM: %s: corrupt or invalid GPT detected.\n"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"GEOM: %s: GPT rejected -- may not be recoverable.\n"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * If both headers are good but they disagree with each other, 	 * then invalidate one. We prefer to keep the primary header, 	 * unless the primary table is corrupt. 	 */
if|if
condition|(
name|table
operator|->
name|state
index|[
name|GPT_ELT_PRIHDR
index|]
operator|==
name|GPT_STATE_OK
operator|&&
name|table
operator|->
name|state
index|[
name|GPT_ELT_SECHDR
index|]
operator|==
name|GPT_STATE_OK
operator|&&
operator|!
name|gpt_matched_hdrs
argument_list|(
operator|&
name|prihdr
argument_list|,
operator|&
name|sechdr
argument_list|)
condition|)
block|{
if|if
condition|(
name|table
operator|->
name|state
index|[
name|GPT_ELT_PRITBL
index|]
operator|==
name|GPT_STATE_OK
condition|)
block|{
name|table
operator|->
name|state
index|[
name|GPT_ELT_SECHDR
index|]
operator|=
name|GPT_STATE_INVALID
expr_stmt|;
name|table
operator|->
name|state
index|[
name|GPT_ELT_SECTBL
index|]
operator|=
name|GPT_STATE_MISSING
expr_stmt|;
block|}
else|else
block|{
name|table
operator|->
name|state
index|[
name|GPT_ELT_PRIHDR
index|]
operator|=
name|GPT_STATE_INVALID
expr_stmt|;
name|table
operator|->
name|state
index|[
name|GPT_ELT_PRITBL
index|]
operator|=
name|GPT_STATE_MISSING
expr_stmt|;
block|}
block|}
if|if
condition|(
name|table
operator|->
name|state
index|[
name|GPT_ELT_PRITBL
index|]
operator|!=
name|GPT_STATE_OK
condition|)
block|{
name|printf
argument_list|(
literal|"GEOM: %s: the primary GPT table is corrupt or "
literal|"invalid.\n"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"GEOM: %s: using the secondary instead -- recovery "
literal|"strongly advised.\n"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|table
operator|->
name|hdr
operator|=
name|sechdr
expr_stmt|;
name|tbl
operator|=
name|sectbl
expr_stmt|;
if|if
condition|(
name|pritbl
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|pritbl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|table
operator|->
name|state
index|[
name|GPT_ELT_SECTBL
index|]
operator|!=
name|GPT_STATE_OK
condition|)
block|{
name|printf
argument_list|(
literal|"GEOM: %s: the secondary GPT table is corrupt "
literal|"or invalid.\n"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"GEOM: %s: using the primary only -- recovery "
literal|"suggested.\n"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|table
operator|->
name|hdr
operator|=
name|prihdr
expr_stmt|;
name|tbl
operator|=
name|pritbl
expr_stmt|;
if|if
condition|(
name|sectbl
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|sectbl
argument_list|)
expr_stmt|;
block|}
name|basetable
operator|->
name|gpt_first
operator|=
name|table
operator|->
name|hdr
operator|.
name|hdr_lba_start
expr_stmt|;
name|basetable
operator|->
name|gpt_last
operator|=
name|table
operator|->
name|hdr
operator|.
name|hdr_lba_end
expr_stmt|;
name|basetable
operator|->
name|gpt_entries
operator|=
name|table
operator|->
name|hdr
operator|.
name|hdr_entries
expr_stmt|;
for|for
control|(
name|index
operator|=
name|basetable
operator|->
name|gpt_entries
operator|-
literal|1
init|;
name|index
operator|>=
literal|0
condition|;
name|index
operator|--
control|)
block|{
if|if
condition|(
name|EQUUID
argument_list|(
operator|&
name|tbl
index|[
name|index
index|]
operator|.
name|ent_type
argument_list|,
operator|&
name|gpt_uuid_unused
argument_list|)
condition|)
continue|continue;
name|entry
operator|=
operator|(
expr|struct
name|g_part_gpt_entry
operator|*
operator|)
name|g_part_new_entry
argument_list|(
name|basetable
argument_list|,
name|index
operator|+
literal|1
argument_list|,
name|tbl
index|[
name|index
index|]
operator|.
name|ent_lba_start
argument_list|,
name|tbl
index|[
name|index
index|]
operator|.
name|ent_lba_end
argument_list|)
expr_stmt|;
name|entry
operator|->
name|ent
operator|=
name|tbl
index|[
name|index
index|]
expr_stmt|;
block|}
name|g_free
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|g_part_gpt_type
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bufsz
parameter_list|)
block|{
name|struct
name|g_part_gpt_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|uuid
modifier|*
name|type
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|g_part_gpt_entry
operator|*
operator|)
name|baseentry
expr_stmt|;
name|type
operator|=
operator|&
name|entry
operator|->
name|ent
operator|.
name|ent_type
expr_stmt|;
if|if
condition|(
name|EQUUID
argument_list|(
name|type
argument_list|,
operator|&
name|gpt_uuid_efi
argument_list|)
condition|)
return|return
operator|(
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_EFI
argument_list|)
operator|)
return|;
if|if
condition|(
name|EQUUID
argument_list|(
name|type
argument_list|,
operator|&
name|gpt_uuid_freebsd
argument_list|)
condition|)
return|return
operator|(
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_FREEBSD
argument_list|)
operator|)
return|;
if|if
condition|(
name|EQUUID
argument_list|(
name|type
argument_list|,
operator|&
name|gpt_uuid_freebsd_boot
argument_list|)
condition|)
return|return
operator|(
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_FREEBSD_BOOT
argument_list|)
operator|)
return|;
if|if
condition|(
name|EQUUID
argument_list|(
name|type
argument_list|,
operator|&
name|gpt_uuid_freebsd_swap
argument_list|)
condition|)
return|return
operator|(
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_FREEBSD_SWAP
argument_list|)
operator|)
return|;
if|if
condition|(
name|EQUUID
argument_list|(
name|type
argument_list|,
operator|&
name|gpt_uuid_freebsd_ufs
argument_list|)
condition|)
return|return
operator|(
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_FREEBSD_UFS
argument_list|)
operator|)
return|;
if|if
condition|(
name|EQUUID
argument_list|(
name|type
argument_list|,
operator|&
name|gpt_uuid_freebsd_vinum
argument_list|)
condition|)
return|return
operator|(
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_FREEBSD_VINUM
argument_list|)
operator|)
return|;
if|if
condition|(
name|EQUUID
argument_list|(
name|type
argument_list|,
operator|&
name|gpt_uuid_freebsd_zfs
argument_list|)
condition|)
return|return
operator|(
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_FREEBSD_ZFS
argument_list|)
operator|)
return|;
if|if
condition|(
name|EQUUID
argument_list|(
name|type
argument_list|,
operator|&
name|gpt_uuid_mbr
argument_list|)
condition|)
return|return
operator|(
name|g_part_alias_name
argument_list|(
name|G_PART_ALIAS_MBR
argument_list|)
operator|)
return|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'!'
expr_stmt|;
name|snprintf_uuid
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
name|bufsz
operator|-
literal|1
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_gpt_write
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_part_entry
modifier|*
name|baseentry
decl_stmt|;
name|struct
name|g_part_gpt_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|g_part_gpt_table
modifier|*
name|table
decl_stmt|;
name|size_t
name|tlbsz
decl_stmt|;
name|uint32_t
name|crc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|index
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|table
operator|=
operator|(
expr|struct
name|g_part_gpt_table
operator|*
operator|)
name|basetable
expr_stmt|;
name|tlbsz
operator|=
operator|(
name|table
operator|->
name|hdr
operator|.
name|hdr_entries
operator|*
name|table
operator|->
name|hdr
operator|.
name|hdr_entsz
operator|+
name|pp
operator|->
name|sectorsize
operator|-
literal|1
operator|)
operator|/
name|pp
operator|->
name|sectorsize
expr_stmt|;
comment|/* Write the PMBR */
name|buf
operator|=
name|g_malloc
argument_list|(
name|pp
operator|->
name|sectorsize
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|table
operator|->
name|mbr
argument_list|,
name|buf
argument_list|,
name|MBRSIZE
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_write_data
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|,
name|buf
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Allocate space for the header and entries. */
name|buf
operator|=
name|g_malloc
argument_list|(
operator|(
name|tlbsz
operator|+
literal|1
operator|)
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|table
operator|->
name|hdr
operator|.
name|hdr_sig
argument_list|,
sizeof|sizeof
argument_list|(
name|table
operator|->
name|hdr
operator|.
name|hdr_sig
argument_list|)
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
name|buf
operator|+
literal|8
argument_list|,
name|table
operator|->
name|hdr
operator|.
name|hdr_revision
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
name|buf
operator|+
literal|12
argument_list|,
name|table
operator|->
name|hdr
operator|.
name|hdr_size
argument_list|)
expr_stmt|;
name|le64enc
argument_list|(
name|buf
operator|+
literal|40
argument_list|,
name|table
operator|->
name|hdr
operator|.
name|hdr_lba_start
argument_list|)
expr_stmt|;
name|le64enc
argument_list|(
name|buf
operator|+
literal|48
argument_list|,
name|table
operator|->
name|hdr
operator|.
name|hdr_lba_end
argument_list|)
expr_stmt|;
name|le_uuid_enc
argument_list|(
name|buf
operator|+
literal|56
argument_list|,
operator|&
name|table
operator|->
name|hdr
operator|.
name|hdr_uuid
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
name|buf
operator|+
literal|80
argument_list|,
name|table
operator|->
name|hdr
operator|.
name|hdr_entries
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
name|buf
operator|+
literal|84
argument_list|,
name|table
operator|->
name|hdr
operator|.
name|hdr_entsz
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|baseentry
argument_list|,
argument|&basetable->gpt_entry
argument_list|,
argument|gpe_entry
argument_list|)
block|{
if|if
condition|(
name|baseentry
operator|->
name|gpe_deleted
condition|)
continue|continue;
name|entry
operator|=
operator|(
expr|struct
name|g_part_gpt_entry
operator|*
operator|)
name|baseentry
expr_stmt|;
name|index
operator|=
name|baseentry
operator|->
name|gpe_index
operator|-
literal|1
expr_stmt|;
name|bp
operator|=
name|buf
operator|+
name|pp
operator|->
name|sectorsize
operator|+
name|table
operator|->
name|hdr
operator|.
name|hdr_entsz
operator|*
name|index
expr_stmt|;
name|le_uuid_enc
argument_list|(
name|bp
argument_list|,
operator|&
name|entry
operator|->
name|ent
operator|.
name|ent_type
argument_list|)
expr_stmt|;
name|le_uuid_enc
argument_list|(
name|bp
operator|+
literal|16
argument_list|,
operator|&
name|entry
operator|->
name|ent
operator|.
name|ent_uuid
argument_list|)
expr_stmt|;
name|le64enc
argument_list|(
name|bp
operator|+
literal|32
argument_list|,
name|entry
operator|->
name|ent
operator|.
name|ent_lba_start
argument_list|)
expr_stmt|;
name|le64enc
argument_list|(
name|bp
operator|+
literal|40
argument_list|,
name|entry
operator|->
name|ent
operator|.
name|ent_lba_end
argument_list|)
expr_stmt|;
name|le64enc
argument_list|(
name|bp
operator|+
literal|48
argument_list|,
name|entry
operator|->
name|ent
operator|.
name|ent_attr
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bp
operator|+
literal|56
argument_list|,
name|entry
operator|->
name|ent
operator|.
name|ent_name
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
operator|->
name|ent
operator|.
name|ent_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|crc
operator|=
name|crc32
argument_list|(
name|buf
operator|+
name|pp
operator|->
name|sectorsize
argument_list|,
name|table
operator|->
name|hdr
operator|.
name|hdr_entries
operator|*
name|table
operator|->
name|hdr
operator|.
name|hdr_entsz
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
name|buf
operator|+
literal|88
argument_list|,
name|crc
argument_list|)
expr_stmt|;
comment|/* Write primary meta-data. */
name|le32enc
argument_list|(
name|buf
operator|+
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* hdr_crc_self. */
name|le64enc
argument_list|(
name|buf
operator|+
literal|24
argument_list|,
name|table
operator|->
name|lba
index|[
name|GPT_ELT_PRIHDR
index|]
argument_list|)
expr_stmt|;
comment|/* hdr_lba_self. */
name|le64enc
argument_list|(
name|buf
operator|+
literal|32
argument_list|,
name|table
operator|->
name|lba
index|[
name|GPT_ELT_SECHDR
index|]
argument_list|)
expr_stmt|;
comment|/* hdr_lba_alt. */
name|le64enc
argument_list|(
name|buf
operator|+
literal|72
argument_list|,
name|table
operator|->
name|lba
index|[
name|GPT_ELT_PRITBL
index|]
argument_list|)
expr_stmt|;
comment|/* hdr_lba_table. */
name|crc
operator|=
name|crc32
argument_list|(
name|buf
argument_list|,
name|table
operator|->
name|hdr
operator|.
name|hdr_size
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
name|buf
operator|+
literal|16
argument_list|,
name|crc
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_write_data
argument_list|(
name|cp
argument_list|,
name|table
operator|->
name|lba
index|[
name|GPT_ELT_PRITBL
index|]
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
name|buf
operator|+
name|pp
operator|->
name|sectorsize
argument_list|,
name|tlbsz
operator|*
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|g_write_data
argument_list|(
name|cp
argument_list|,
name|table
operator|->
name|lba
index|[
name|GPT_ELT_PRIHDR
index|]
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
name|buf
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* Write secondary meta-data. */
name|le32enc
argument_list|(
name|buf
operator|+
literal|16
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* hdr_crc_self. */
name|le64enc
argument_list|(
name|buf
operator|+
literal|24
argument_list|,
name|table
operator|->
name|lba
index|[
name|GPT_ELT_SECHDR
index|]
argument_list|)
expr_stmt|;
comment|/* hdr_lba_self. */
name|le64enc
argument_list|(
name|buf
operator|+
literal|32
argument_list|,
name|table
operator|->
name|lba
index|[
name|GPT_ELT_PRIHDR
index|]
argument_list|)
expr_stmt|;
comment|/* hdr_lba_alt. */
name|le64enc
argument_list|(
name|buf
operator|+
literal|72
argument_list|,
name|table
operator|->
name|lba
index|[
name|GPT_ELT_SECTBL
index|]
argument_list|)
expr_stmt|;
comment|/* hdr_lba_table. */
name|crc
operator|=
name|crc32
argument_list|(
name|buf
argument_list|,
name|table
operator|->
name|hdr
operator|.
name|hdr_size
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
name|buf
operator|+
literal|16
argument_list|,
name|crc
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_write_data
argument_list|(
name|cp
argument_list|,
name|table
operator|->
name|lba
index|[
name|GPT_ELT_SECTBL
index|]
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
name|buf
operator|+
name|pp
operator|->
name|sectorsize
argument_list|,
name|tlbsz
operator|*
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|g_write_data
argument_list|(
name|cp
argument_list|,
name|table
operator|->
name|lba
index|[
name|GPT_ELT_SECHDR
index|]
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
name|buf
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|out
label|:
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_gpt_printf_utf16
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|uint16_t
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|u_int
name|bo
decl_stmt|;
name|uint32_t
name|ch
decl_stmt|;
name|uint16_t
name|c
decl_stmt|;
name|bo
operator|=
name|LITTLE_ENDIAN
expr_stmt|;
comment|/* GPT is little-endian */
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
operator|*
name|str
operator|!=
literal|0
condition|)
block|{
name|ch
operator|=
operator|(
name|bo
operator|==
name|BIG_ENDIAN
operator|)
condition|?
name|be16toh
argument_list|(
operator|*
name|str
argument_list|)
else|:
name|le16toh
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
name|str
operator|++
operator|,
name|len
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xf800
operator|)
operator|==
literal|0xd800
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|c
operator|=
operator|(
name|bo
operator|==
name|BIG_ENDIAN
operator|)
condition|?
name|be16toh
argument_list|(
operator|*
name|str
argument_list|)
else|:
name|le16toh
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
name|str
operator|++
operator|,
name|len
operator|--
expr_stmt|;
block|}
else|else
name|c
operator|=
literal|0xfffd
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|&
literal|0x400
operator|)
operator|==
literal|0
operator|&&
operator|(
name|c
operator|&
literal|0xfc00
operator|)
operator|==
literal|0xdc00
condition|)
block|{
name|ch
operator|=
operator|(
operator|(
name|ch
operator|&
literal|0x3ff
operator|)
operator|<<
literal|10
operator|)
operator|+
operator|(
name|c
operator|&
literal|0x3ff
operator|)
expr_stmt|;
name|ch
operator|+=
literal|0x10000
expr_stmt|;
block|}
else|else
name|ch
operator|=
literal|0xfffd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|0xfffe
condition|)
block|{
comment|/* BOM (U+FEFF) swapped. */
name|bo
operator|=
operator|(
name|bo
operator|==
name|BIG_ENDIAN
operator|)
condition|?
name|LITTLE_ENDIAN
else|:
name|BIG_ENDIAN
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|0xfeff
condition|)
comment|/* BOM (U+FEFF) unswapped. */
continue|continue;
comment|/* Write the Unicode character in UTF-8 */
if|if
condition|(
name|ch
operator|<
literal|0x80
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%c"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|<
literal|0x800
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%c%c"
argument_list|,
literal|0xc0
operator||
operator|(
name|ch
operator|>>
literal|6
operator|)
argument_list|,
literal|0x80
operator||
operator|(
name|ch
operator|&
literal|0x3f
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|<
literal|0x10000
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%c%c%c"
argument_list|,
literal|0xe0
operator||
operator|(
name|ch
operator|>>
literal|12
operator|)
argument_list|,
literal|0x80
operator||
operator|(
operator|(
name|ch
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
argument_list|,
literal|0x80
operator||
operator|(
name|ch
operator|&
literal|0x3f
operator|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|<
literal|0x200000
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%c%c%c%c"
argument_list|,
literal|0xf0
operator||
operator|(
name|ch
operator|>>
literal|18
operator|)
argument_list|,
literal|0x80
operator||
operator|(
operator|(
name|ch
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
operator|)
argument_list|,
literal|0x80
operator||
operator|(
operator|(
name|ch
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
argument_list|,
literal|0x80
operator||
operator|(
name|ch
operator|&
literal|0x3f
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_gpt_utf8_to_utf16
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|s8
parameter_list|,
name|uint16_t
modifier|*
name|s16
parameter_list|,
name|size_t
name|s16len
parameter_list|)
block|{
name|size_t
name|s16idx
decl_stmt|,
name|s8idx
decl_stmt|;
name|uint32_t
name|utfchar
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|,
name|utfbytes
decl_stmt|;
name|s8idx
operator|=
name|s16idx
operator|=
literal|0
expr_stmt|;
name|utfchar
operator|=
literal|0
expr_stmt|;
name|utfbytes
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|s16
argument_list|,
name|s16len
operator|<<
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|s8
index|[
name|s8idx
index|]
operator|!=
literal|0
operator|&&
name|s16idx
operator|<
name|s16len
condition|)
block|{
name|c
operator|=
name|s8
index|[
name|s8idx
operator|++
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
block|{
comment|/* Initial characters. */
if|if
condition|(
name|utfbytes
operator|!=
literal|0
condition|)
block|{
comment|/* Incomplete encoding of previous char. */
name|s16
index|[
name|s16idx
operator|++
index|]
operator|=
name|htole16
argument_list|(
literal|0xfffd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
operator|&
literal|0xf8
operator|)
operator|==
literal|0xf0
condition|)
block|{
name|utfchar
operator|=
name|c
operator|&
literal|0x07
expr_stmt|;
name|utfbytes
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|&
literal|0xf0
operator|)
operator|==
literal|0xe0
condition|)
block|{
name|utfchar
operator|=
name|c
operator|&
literal|0x0f
expr_stmt|;
name|utfbytes
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|&
literal|0xe0
operator|)
operator|==
literal|0xc0
condition|)
block|{
name|utfchar
operator|=
name|c
operator|&
literal|0x1f
expr_stmt|;
name|utfbytes
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|utfchar
operator|=
name|c
operator|&
literal|0x7f
expr_stmt|;
name|utfbytes
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Followup characters. */
if|if
condition|(
name|utfbytes
operator|>
literal|0
condition|)
block|{
name|utfchar
operator|=
operator|(
name|utfchar
operator|<<
literal|6
operator|)
operator|+
operator|(
name|c
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|utfbytes
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|utfbytes
operator|==
literal|0
condition|)
name|utfbytes
operator|=
operator|~
literal|0
expr_stmt|;
block|}
comment|/* 		 * Write the complete Unicode character as UTF-16 when we 		 * have all the UTF-8 charactars collected. 		 */
if|if
condition|(
name|utfbytes
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If we need to write 2 UTF-16 characters, but 			 * we only have room for 1, then we truncate the 			 * string by writing a 0 instead. 			 */
if|if
condition|(
name|utfchar
operator|>=
literal|0x10000
operator|&&
name|s16idx
operator|<
name|s16len
operator|-
literal|1
condition|)
block|{
name|s16
index|[
name|s16idx
operator|++
index|]
operator|=
name|htole16
argument_list|(
literal|0xd800
operator||
operator|(
operator|(
name|utfchar
operator|>>
literal|10
operator|)
operator|-
literal|0x40
operator|)
argument_list|)
expr_stmt|;
name|s16
index|[
name|s16idx
operator|++
index|]
operator|=
name|htole16
argument_list|(
literal|0xdc00
operator||
operator|(
name|utfchar
operator|&
literal|0x3ff
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|s16
index|[
name|s16idx
operator|++
index|]
operator|=
operator|(
name|utfchar
operator|>=
literal|0x10000
operator|)
condition|?
literal|0
else|:
name|htole16
argument_list|(
name|utfchar
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If our input string was truncated, append an invalid encoding 	 * character to the output string. 	 */
if|if
condition|(
name|utfbytes
operator|!=
literal|0
operator|&&
name|s16idx
operator|<
name|s16len
condition|)
name|s16
index|[
name|s16idx
operator|++
index|]
operator|=
name|htole16
argument_list|(
literal|0xfffd
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

