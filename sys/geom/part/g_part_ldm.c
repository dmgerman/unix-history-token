begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 Andrey V. Elsukov<ae@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/diskmbr.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/gpt.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uuid.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/part/g_part.h>
end_include

begin_include
include|#
directive|include
file|"g_part_if.h"
end_include

begin_expr_stmt
name|FEATURE
argument_list|(
name|geom_part_ldm
argument_list|,
literal|"GEOM partitioning class for LDM support"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_kern_geom_part
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_kern_geom_part
argument_list|,
name|OID_AUTO
argument_list|,
name|ldm
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"GEOM_PART_LDM Logical Disk Manager"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|ldm_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_part_ldm
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|ldm_debug
argument_list|,
literal|0
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This allows access to mirrored LDM volumes. Since we do not  * doing mirroring here, it is not enabled by default.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|show_mirrors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_part_ldm
argument_list|,
name|OID_AUTO
argument_list|,
name|show_mirrors
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|show_mirrors
argument_list|,
literal|0
argument_list|,
literal|"Show mirrored volumes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|LDM_DEBUG
parameter_list|(
name|lvl
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {				\ 	if (ldm_debug>= (lvl)) {					\ 		printf("GEOM_PART: " fmt "\n", __VA_ARGS__);		\ 	}								\ } while (0)
end_define

begin_define
define|#
directive|define
name|LDM_DUMP
parameter_list|(
name|buf
parameter_list|,
name|size
parameter_list|)
value|do {					\ 	if (ldm_debug> 1) {						\ 		hexdump(buf, size, NULL, 0);				\ 	}								\ } while (0)
end_define

begin_comment
comment|/*  * There are internal representations of LDM structures.  *  * We do not keep all fields of on-disk structures, only most useful.  * All numbers in an on-disk structures are in big-endian format.  */
end_comment

begin_comment
comment|/*  * Private header is 512 bytes long. There are three copies on each disk.  * Offset and sizes are in sectors. Location of each copy:  * - the first offset is relative to the disk start;  * - the second and third offset are relative to the LDM database start.  *  * On a disk partitioned with GPT, the LDM has not first private header.  */
end_comment

begin_define
define|#
directive|define
name|LDM_PH_MBRINDEX
value|0
end_define

begin_define
define|#
directive|define
name|LDM_PH_GPTINDEX
value|2
end_define

begin_decl_stmt
specifier|static
specifier|const
name|uint64_t
name|ldm_ph_off
index|[]
init|=
block|{
literal|6
block|,
literal|1856
block|,
literal|2047
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LDM_VERSION_2K
value|0x2000b
end_define

begin_define
define|#
directive|define
name|LDM_VERSION_VISTA
value|0x2000c
end_define

begin_define
define|#
directive|define
name|LDM_PH_VERSION_OFF
value|0x00c
end_define

begin_define
define|#
directive|define
name|LDM_PH_DISKGUID_OFF
value|0x030
end_define

begin_define
define|#
directive|define
name|LDM_PH_DGGUID_OFF
value|0x0b0
end_define

begin_define
define|#
directive|define
name|LDM_PH_DGNAME_OFF
value|0x0f0
end_define

begin_define
define|#
directive|define
name|LDM_PH_START_OFF
value|0x11b
end_define

begin_define
define|#
directive|define
name|LDM_PH_SIZE_OFF
value|0x123
end_define

begin_define
define|#
directive|define
name|LDM_PH_DB_OFF
value|0x12b
end_define

begin_define
define|#
directive|define
name|LDM_PH_DBSIZE_OFF
value|0x133
end_define

begin_define
define|#
directive|define
name|LDM_PH_TH1_OFF
value|0x13b
end_define

begin_define
define|#
directive|define
name|LDM_PH_TH2_OFF
value|0x143
end_define

begin_define
define|#
directive|define
name|LDM_PH_CONFSIZE_OFF
value|0x153
end_define

begin_define
define|#
directive|define
name|LDM_PH_LOGSIZE_OFF
value|0x15b
end_define

begin_define
define|#
directive|define
name|LDM_PH_SIGN
value|"PRIVHEAD"
end_define

begin_struct
struct|struct
name|ldm_privhdr
block|{
name|struct
name|uuid
name|disk_guid
decl_stmt|;
name|struct
name|uuid
name|dg_guid
decl_stmt|;
name|u_char
name|dg_name
index|[
literal|32
index|]
decl_stmt|;
name|uint64_t
name|start
decl_stmt|;
comment|/* logical disk start */
name|uint64_t
name|size
decl_stmt|;
comment|/* logical disk size */
name|uint64_t
name|db_offset
decl_stmt|;
comment|/* LDM database start */
define|#
directive|define
name|LDM_DB_SIZE
value|2048
name|uint64_t
name|db_size
decl_stmt|;
comment|/* LDM database size */
define|#
directive|define
name|LDM_TH_COUNT
value|2
name|uint64_t
name|th_offset
index|[
name|LDM_TH_COUNT
index|]
decl_stmt|;
comment|/* TOC header offsets */
name|uint64_t
name|conf_size
decl_stmt|;
comment|/* configuration size */
name|uint64_t
name|log_size
decl_stmt|;
comment|/* size of log */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Table of contents header is 512 bytes long.  * There are two identical copies at offsets from the private header.  * Offsets are relative to the LDM database start.  */
end_comment

begin_define
define|#
directive|define
name|LDM_TH_SIGN
value|"TOCBLOCK"
end_define

begin_define
define|#
directive|define
name|LDM_TH_NAME1
value|"config"
end_define

begin_define
define|#
directive|define
name|LDM_TH_NAME2
value|"log"
end_define

begin_define
define|#
directive|define
name|LDM_TH_NAME1_OFF
value|0x024
end_define

begin_define
define|#
directive|define
name|LDM_TH_CONF_OFF
value|0x02e
end_define

begin_define
define|#
directive|define
name|LDM_TH_CONFSIZE_OFF
value|0x036
end_define

begin_define
define|#
directive|define
name|LDM_TH_NAME2_OFF
value|0x046
end_define

begin_define
define|#
directive|define
name|LDM_TH_LOG_OFF
value|0x050
end_define

begin_define
define|#
directive|define
name|LDM_TH_LOGSIZE_OFF
value|0x058
end_define

begin_struct
struct|struct
name|ldm_tochdr
block|{
name|uint64_t
name|conf_offset
decl_stmt|;
comment|/* configuration offset */
name|uint64_t
name|log_offset
decl_stmt|;
comment|/* log offset */
block|}
struct|;
end_struct

begin_comment
comment|/*  * LDM database header is 512 bytes long.  */
end_comment

begin_define
define|#
directive|define
name|LDM_VMDB_SIGN
value|"VMDB"
end_define

begin_define
define|#
directive|define
name|LDM_DB_LASTSEQ_OFF
value|0x004
end_define

begin_define
define|#
directive|define
name|LDM_DB_SIZE_OFF
value|0x008
end_define

begin_define
define|#
directive|define
name|LDM_DB_STATUS_OFF
value|0x010
end_define

begin_define
define|#
directive|define
name|LDM_DB_VERSION_OFF
value|0x012
end_define

begin_define
define|#
directive|define
name|LDM_DB_DGNAME_OFF
value|0x016
end_define

begin_define
define|#
directive|define
name|LDM_DB_DGGUID_OFF
value|0x035
end_define

begin_struct
struct|struct
name|ldm_vmdbhdr
block|{
name|uint32_t
name|last_seq
decl_stmt|;
comment|/* sequence number of last VBLK */
name|uint32_t
name|size
decl_stmt|;
comment|/* size of VBLK */
block|}
struct|;
end_struct

begin_comment
comment|/*  * The LDM database configuration section contains VMDB header and  * many VBLKs. Each VBLK represents a disk group, disk partition,  * component or volume.  *  * The most interesting for us are volumes, they are represents  * partitions in the GEOM_PART meaning. But volume VBLK does not  * contain all information needed to create GEOM provider. And we  * should get this information from the related VBLK. This is how  * VBLK releated:  *	Volumes<- Components<- Partitions -> Disks  *  * One volume can contain several components. In this case LDM  * does mirroring of volume data to each component.  *  * Also each component can contain several partitions (spanned or  * striped volumes).  */
end_comment

begin_struct
struct|struct
name|ldm_component
block|{
name|uint64_t
name|id
decl_stmt|;
comment|/* object id */
name|uint64_t
name|vol_id
decl_stmt|;
comment|/* parent volume object id */
name|int
name|count
decl_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ldm_partition
argument_list|)
name|partitions
expr_stmt|;
name|LIST_ENTRY
argument_list|(
argument|ldm_component
argument_list|)
name|entry
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ldm_volume
block|{
name|uint64_t
name|id
decl_stmt|;
comment|/* object id */
name|uint64_t
name|size
decl_stmt|;
comment|/* volume size */
name|uint8_t
name|number
decl_stmt|;
comment|/* used for ordering */
name|uint8_t
name|part_type
decl_stmt|;
comment|/* partition type */
name|int
name|count
decl_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ldm_component
argument_list|)
name|components
expr_stmt|;
name|LIST_ENTRY
argument_list|(
argument|ldm_volume
argument_list|)
name|entry
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ldm_disk
block|{
name|uint64_t
name|id
decl_stmt|;
comment|/* object id */
name|struct
name|uuid
name|guid
decl_stmt|;
comment|/* disk guid */
name|LIST_ENTRY
argument_list|(
argument|ldm_disk
argument_list|)
name|entry
expr_stmt|;
block|}
struct|;
end_struct

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|struct ldm_disk_group { 	uint64_t	id;
comment|/* object id */
end_comment

begin_comment
unit|struct uuid	guid;
comment|/* disk group guid */
end_comment

begin_comment
unit|u_char		name[32];
comment|/* disk group name */
end_comment

begin_endif
unit|LIST_ENTRY(ldm_disk_group) entry; };
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|ldm_partition
block|{
name|uint64_t
name|id
decl_stmt|;
comment|/* object id */
name|uint64_t
name|disk_id
decl_stmt|;
comment|/* disk object id */
name|uint64_t
name|comp_id
decl_stmt|;
comment|/* parent component object id */
name|uint64_t
name|start
decl_stmt|;
comment|/* offset relative to disk start */
name|uint64_t
name|offset
decl_stmt|;
comment|/* offset for spanned volumes */
name|uint64_t
name|size
decl_stmt|;
comment|/* partition size */
name|LIST_ENTRY
argument_list|(
argument|ldm_partition
argument_list|)
name|entry
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Each VBLK is 128 bytes long and has standard 16 bytes header.  * Some of VBLK's fields are fixed size, but others has variable size.  * Fields with variable size are prefixed with one byte length marker.  * Some fields are strings and also can have fixed size and variable.  * Strings with fixed size are NULL-terminated, others are not.  * All VBLKs have same several first fields:  *	Offset		Size		Description  *	---------------+---------------+--------------------------  *	0x00		16		standard VBLK header  *	0x10		2		update status  *	0x13		1		VBLK type  *	0x18		PS		object id  *	0x18+		PN		object name  *  *  o Offset 0x18+ means '0x18 + length of all variable-width fields'  *  o 'P' in size column means 'prefixed' (variable-width),  *    'S' - string, 'N' - number.  */
end_comment

begin_define
define|#
directive|define
name|LDM_VBLK_SIGN
value|"VBLK"
end_define

begin_define
define|#
directive|define
name|LDM_VBLK_SEQ_OFF
value|0x04
end_define

begin_define
define|#
directive|define
name|LDM_VBLK_GROUP_OFF
value|0x08
end_define

begin_define
define|#
directive|define
name|LDM_VBLK_INDEX_OFF
value|0x0c
end_define

begin_define
define|#
directive|define
name|LDM_VBLK_COUNT_OFF
value|0x0e
end_define

begin_define
define|#
directive|define
name|LDM_VBLK_TYPE_OFF
value|0x13
end_define

begin_define
define|#
directive|define
name|LDM_VBLK_OID_OFF
value|0x18
end_define

begin_struct
struct|struct
name|ldm_vblkhdr
block|{
name|uint32_t
name|seq
decl_stmt|;
comment|/* sequence number */
name|uint32_t
name|group
decl_stmt|;
comment|/* group number */
name|uint16_t
name|index
decl_stmt|;
comment|/* index in the group */
name|uint16_t
name|count
decl_stmt|;
comment|/* number of entries in the group */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|LDM_VBLK_T_COMPONENT
value|0x32
end_define

begin_define
define|#
directive|define
name|LDM_VBLK_T_PARTITION
value|0x33
end_define

begin_define
define|#
directive|define
name|LDM_VBLK_T_DISK
value|0x34
end_define

begin_define
define|#
directive|define
name|LDM_VBLK_T_DISKGROUP
value|0x35
end_define

begin_define
define|#
directive|define
name|LDM_VBLK_T_DISK4
value|0x44
end_define

begin_define
define|#
directive|define
name|LDM_VBLK_T_DISKGROUP4
value|0x45
end_define

begin_define
define|#
directive|define
name|LDM_VBLK_T_VOLUME
value|0x51
end_define

begin_struct
struct|struct
name|ldm_vblk
block|{
name|uint8_t
name|type
decl_stmt|;
comment|/* VBLK type */
union|union
block|{
name|uint64_t
name|id
decl_stmt|;
name|struct
name|ldm_volume
name|vol
decl_stmt|;
name|struct
name|ldm_component
name|comp
decl_stmt|;
name|struct
name|ldm_disk
name|disk
decl_stmt|;
name|struct
name|ldm_partition
name|part
decl_stmt|;
if|#
directive|if
literal|0
block|struct ldm_disk_group	disk_group;
endif|#
directive|endif
block|}
name|u
union|;
name|LIST_ENTRY
argument_list|(
argument|ldm_vblk
argument_list|)
name|entry
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Some VBLKs contains a bit more data than can fit into 128 bytes. These  * VBLKs are called eXtended VBLK. Before parsing, the data from these VBLK  * should be placed into continuous memory buffer. We can determine xVBLK  * by the count field in the standard VBLK header (count> 1).  */
end_comment

begin_struct
struct|struct
name|ldm_xvblk
block|{
name|uint32_t
name|group
decl_stmt|;
comment|/* xVBLK group number */
name|uint32_t
name|size
decl_stmt|;
comment|/* the total size of xVBLK */
name|uint8_t
name|map
decl_stmt|;
comment|/* bitmask of currently saved VBLKs */
name|u_char
modifier|*
name|data
decl_stmt|;
comment|/* xVBLK data */
name|LIST_ENTRY
argument_list|(
argument|ldm_xvblk
argument_list|)
name|entry
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The internal representation of LDM database. */
end_comment

begin_struct
struct|struct
name|ldm_db
block|{
name|struct
name|ldm_privhdr
name|ph
decl_stmt|;
comment|/* private header */
name|struct
name|ldm_tochdr
name|th
decl_stmt|;
comment|/* TOC header */
name|struct
name|ldm_vmdbhdr
name|dh
decl_stmt|;
comment|/* VMDB header */
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ldm_volume
argument_list|)
name|volumes
expr_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ldm_disk
argument_list|)
name|disks
expr_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ldm_vblk
argument_list|)
name|vblks
expr_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ldm_xvblk
argument_list|)
name|xvblks
expr_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|gpt_uuid_ms_ldm_metadata
init|=
name|GPT_ENT_TYPE_MS_LDM_METADATA
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|g_part_ldm_table
block|{
name|struct
name|g_part_table
name|base
decl_stmt|;
name|uint64_t
name|db_offset
decl_stmt|;
name|int
name|is_gpt
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|g_part_ldm_entry
block|{
name|struct
name|g_part_entry
name|base
decl_stmt|;
name|uint8_t
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|g_part_ldm_add
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|,
name|struct
name|g_part_parms
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_ldm_bootcode
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_parms
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_ldm_create
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_parms
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_ldm_destroy
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_parms
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_part_ldm_dumpconf
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|,
name|struct
name|sbuf
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_ldm_dumpto
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_ldm_modify
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|,
name|struct
name|g_part_parms
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|g_part_ldm_name
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_ldm_probe
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_consumer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_ldm_read
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_consumer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|g_part_ldm_type
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_ldm_write
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_consumer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|kobj_method_t
name|g_part_ldm_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|g_part_add
argument_list|,
name|g_part_ldm_add
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_bootcode
argument_list|,
name|g_part_ldm_bootcode
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_create
argument_list|,
name|g_part_ldm_create
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_destroy
argument_list|,
name|g_part_ldm_destroy
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_dumpconf
argument_list|,
name|g_part_ldm_dumpconf
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_dumpto
argument_list|,
name|g_part_ldm_dumpto
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_modify
argument_list|,
name|g_part_ldm_modify
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_name
argument_list|,
name|g_part_ldm_name
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_probe
argument_list|,
name|g_part_ldm_probe
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_read
argument_list|,
name|g_part_ldm_read
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_type
argument_list|,
name|g_part_ldm_type
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_write
argument_list|,
name|g_part_ldm_write
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|g_part_scheme
name|g_part_ldm_scheme
init|=
block|{
literal|"LDM"
block|,
name|g_part_ldm_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|g_part_ldm_table
argument_list|)
block|,
operator|.
name|gps_entrysz
operator|=
expr|sizeof
operator|(
expr|struct
name|g_part_ldm_entry
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|G_PART_SCHEME_DECLARE
argument_list|(
name|g_part_ldm
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
specifier|static
struct|struct
name|g_part_ldm_alias
block|{
name|u_char
name|typ
decl_stmt|;
name|int
name|alias
decl_stmt|;
block|}
name|ldm_alias_match
index|[]
init|=
block|{
block|{
name|DOSPTYP_NTFS
block|,
name|G_PART_ALIAS_MS_NTFS
block|}
block|,
block|{
name|DOSPTYP_FAT32
block|,
name|G_PART_ALIAS_MS_FAT32
block|}
block|,
block|{
name|DOSPTYP_386BSD
block|,
name|G_PART_ALIAS_FREEBSD
block|}
block|,
block|{
name|DOSPTYP_LDM
block|,
name|G_PART_ALIAS_MS_LDM_DATA
block|}
block|,
block|{
name|DOSPTYP_LINSWP
block|,
name|G_PART_ALIAS_LINUX_SWAP
block|}
block|,
block|{
name|DOSPTYP_LINUX
block|,
name|G_PART_ALIAS_LINUX_DATA
block|}
block|,
block|{
name|DOSPTYP_LINLVM
block|,
name|G_PART_ALIAS_LINUX_LVM
block|}
block|,
block|{
name|DOSPTYP_LINRAID
block|,
name|G_PART_ALIAS_LINUX_RAID
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|u_char
modifier|*
name|ldm_privhdr_read
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|off
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|buf
argument_list|,
name|LDM_PH_SIGN
argument_list|,
name|strlen
argument_list|(
name|LDM_PH_SIGN
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|LDM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"%s: invalid LDM private header signature"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ldm_privhdr_parse
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|ldm_privhdr
modifier|*
name|hdr
parameter_list|,
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|)
block|{
name|uint32_t
name|version
decl_stmt|;
name|int
name|error
decl_stmt|;
name|memset
argument_list|(
name|hdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|version
operator|=
name|be32dec
argument_list|(
name|buf
operator|+
name|LDM_PH_VERSION_OFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|LDM_VERSION_2K
operator|&&
name|version
operator|!=
name|LDM_VERSION_VISTA
condition|)
block|{
name|LDM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"%s: unsupported LDM version %u.%u"
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|,
name|version
operator|>>
literal|16
argument_list|,
name|version
operator|&
literal|0xFFFF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|parse_uuid
argument_list|(
name|buf
operator|+
name|LDM_PH_DISKGUID_OFF
argument_list|,
operator|&
name|hdr
operator|->
name|disk_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|parse_uuid
argument_list|(
name|buf
operator|+
name|LDM_PH_DGGUID_OFF
argument_list|,
operator|&
name|hdr
operator|->
name|dg_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|strncpy
argument_list|(
name|hdr
operator|->
name|dg_name
argument_list|,
name|buf
operator|+
name|LDM_PH_DGNAME_OFF
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
operator|->
name|dg_name
argument_list|)
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|start
operator|=
name|be64dec
argument_list|(
name|buf
operator|+
name|LDM_PH_START_OFF
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|size
operator|=
name|be64dec
argument_list|(
name|buf
operator|+
name|LDM_PH_SIZE_OFF
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|db_offset
operator|=
name|be64dec
argument_list|(
name|buf
operator|+
name|LDM_PH_DB_OFF
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|db_size
operator|=
name|be64dec
argument_list|(
name|buf
operator|+
name|LDM_PH_DBSIZE_OFF
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|th_offset
index|[
literal|0
index|]
operator|=
name|be64dec
argument_list|(
name|buf
operator|+
name|LDM_PH_TH1_OFF
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|th_offset
index|[
literal|1
index|]
operator|=
name|be64dec
argument_list|(
name|buf
operator|+
name|LDM_PH_TH2_OFF
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|conf_size
operator|=
name|be64dec
argument_list|(
name|buf
operator|+
name|LDM_PH_CONFSIZE_OFF
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|log_size
operator|=
name|be64dec
argument_list|(
name|buf
operator|+
name|LDM_PH_LOGSIZE_OFF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ldm_privhdr_check
parameter_list|(
name|struct
name|ldm_db
modifier|*
name|db
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|int
name|is_gpt
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp2
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|ldm_privhdr
name|hdr
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|,
name|last
decl_stmt|;
name|int
name|error
decl_stmt|,
name|found
decl_stmt|,
name|i
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
if|if
condition|(
name|is_gpt
condition|)
block|{
comment|/* 		 * The last LBA is used in several checks below, for the 		 * GPT case it should be calculated relative to the whole 		 * disk. 		 */
name|cp2
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|pp
operator|->
name|geom
operator|->
name|consumer
argument_list|)
expr_stmt|;
name|last
operator|=
name|cp2
operator|->
name|provider
operator|->
name|mediasize
operator|/
name|cp2
operator|->
name|provider
operator|->
name|sectorsize
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|last
operator|=
name|pp
operator|->
name|mediasize
operator|/
name|pp
operator|->
name|sectorsize
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|found
operator|=
literal|0
operator|,
name|i
operator|=
name|is_gpt
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ldm_ph_off
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ldm_ph_off
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|offset
operator|=
name|ldm_ph_off
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * In the GPT case consumer is attached to the LDM metadata 		 * partition and we don't need add db_offset. 		 */
if|if
condition|(
operator|!
name|is_gpt
condition|)
name|offset
operator|+=
name|db
operator|->
name|ph
operator|.
name|db_offset
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|LDM_PH_MBRINDEX
condition|)
block|{
comment|/* 			 * Prepare to errors and setup new base offset 			 * to read backup private headers. Assume that LDM 			 * database is in the last 1Mbyte area. 			 */
name|db
operator|->
name|ph
operator|.
name|db_offset
operator|=
name|last
operator|-
name|LDM_DB_SIZE
expr_stmt|;
block|}
name|buf
operator|=
name|ldm_privhdr_read
argument_list|(
name|cp
argument_list|,
name|offset
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|LDM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"%s: failed to read private header "
literal|"%d at LBA %ju"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|i
argument_list|,
operator|(
name|uintmax_t
operator|)
name|offset
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|error
operator|=
name|ldm_privhdr_parse
argument_list|(
name|cp
argument_list|,
operator|&
name|hdr
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|LDM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"%s: failed to parse private "
literal|"header %d"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|LDM_DUMP
argument_list|(
name|buf
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|.
name|start
operator|>
name|last
operator|||
name|hdr
operator|.
name|start
operator|+
name|hdr
operator|.
name|size
operator|-
literal|1
operator|>
name|last
operator|||
operator|(
name|hdr
operator|.
name|start
operator|+
name|hdr
operator|.
name|size
operator|-
literal|1
operator|>
name|hdr
operator|.
name|db_offset
operator|&&
operator|!
name|is_gpt
operator|)
operator|||
name|hdr
operator|.
name|db_size
operator|!=
name|LDM_DB_SIZE
operator|||
name|hdr
operator|.
name|db_offset
operator|+
name|LDM_DB_SIZE
operator|-
literal|1
operator|>
name|last
operator|||
name|hdr
operator|.
name|th_offset
index|[
literal|0
index|]
operator|>=
name|LDM_DB_SIZE
operator|||
name|hdr
operator|.
name|th_offset
index|[
literal|1
index|]
operator|>=
name|LDM_DB_SIZE
operator|||
name|hdr
operator|.
name|conf_size
operator|+
name|hdr
operator|.
name|log_size
operator|>=
name|LDM_DB_SIZE
condition|)
block|{
name|LDM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"%s: invalid values in the "
literal|"private header %d"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|LDM_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"%s: start: %jd, size: %jd, "
literal|"db_offset: %jd, db_size: %jd, th_offset0: %jd, "
literal|"th_offset1: %jd, conf_size: %jd, log_size: %jd, "
literal|"last: %jd"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|hdr
operator|.
name|start
argument_list|,
name|hdr
operator|.
name|size
argument_list|,
name|hdr
operator|.
name|db_offset
argument_list|,
name|hdr
operator|.
name|db_size
argument_list|,
name|hdr
operator|.
name|th_offset
index|[
literal|0
index|]
argument_list|,
name|hdr
operator|.
name|th_offset
index|[
literal|1
index|]
argument_list|,
name|hdr
operator|.
name|conf_size
argument_list|,
name|hdr
operator|.
name|log_size
argument_list|,
name|last
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|found
operator|!=
literal|0
operator|&&
name|memcmp
argument_list|(
operator|&
name|db
operator|->
name|ph
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|LDM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"%s: private headers are not equal"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
comment|/* 				 * We have different headers in the LDM. 				 * We can not trust this metadata. 				 */
name|LDM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"%s: refuse LDM metadata"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 			 * We already have read primary private header 			 * and it differs from this backup one. 			 * Prefer the backup header and save it. 			 */
name|found
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
name|memcpy
argument_list|(
operator|&
name|db
operator|->
name|ph
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
name|LDM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"%s: valid LDM private header not found"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ldm_gpt_check
parameter_list|(
name|struct
name|ldm_db
modifier|*
name|db
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_part_table
modifier|*
name|gpt
decl_stmt|;
name|struct
name|g_part_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp2
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cp2
operator|=
name|LIST_NEXT
argument_list|(
name|cp
argument_list|,
name|consumer
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|gpt
operator|=
name|cp
operator|->
name|provider
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|e
argument_list|,
argument|&gpt->gpt_entry
argument_list|,
argument|gpe_entry
argument_list|)
block|{
if|if
condition|(
name|cp
operator|->
name|provider
operator|==
name|e
operator|->
name|gpe_pp
condition|)
block|{
comment|/* ms-ldm-metadata partition */
if|if
condition|(
name|e
operator|->
name|gpe_start
operator|!=
name|db
operator|->
name|ph
operator|.
name|db_offset
operator|||
name|e
operator|->
name|gpe_end
operator|!=
name|db
operator|->
name|ph
operator|.
name|db_offset
operator|+
name|LDM_DB_SIZE
operator|-
literal|1
condition|)
name|error
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp2
operator|->
name|provider
operator|==
name|e
operator|->
name|gpe_pp
condition|)
block|{
comment|/* ms-ldm-data partition */
if|if
condition|(
name|e
operator|->
name|gpe_start
operator|!=
name|db
operator|->
name|ph
operator|.
name|start
operator|||
name|e
operator|->
name|gpe_end
operator|!=
name|db
operator|->
name|ph
operator|.
name|start
operator|+
name|db
operator|->
name|ph
operator|.
name|size
operator|-
literal|1
condition|)
name|error
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|LDM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"%s: GPT partition %d boundaries "
literal|"do not match with the LDM metadata"
argument_list|,
name|e
operator|->
name|gpe_pp
operator|->
name|name
argument_list|,
name|e
operator|->
name|gpe_index
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
block|}
name|g_topology_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ldm_tochdr_check
parameter_list|(
name|struct
name|ldm_db
modifier|*
name|db
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|ldm_tochdr
name|hdr
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|,
name|conf_size
decl_stmt|,
name|log_size
decl_stmt|;
name|int
name|error
decl_stmt|,
name|found
decl_stmt|,
name|i
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|found
operator|=
literal|0
init|;
name|i
operator|<
name|LDM_TH_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|offset
operator|=
name|db
operator|->
name|ph
operator|.
name|db_offset
operator|+
name|db
operator|->
name|ph
operator|.
name|th_offset
index|[
name|i
index|]
expr_stmt|;
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|offset
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|LDM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"%s: failed to read TOC header "
literal|"at LBA %ju"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|offset
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|buf
argument_list|,
name|LDM_TH_SIGN
argument_list|,
name|strlen
argument_list|(
name|LDM_TH_SIGN
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|memcmp
argument_list|(
name|buf
operator|+
name|LDM_TH_NAME1_OFF
argument_list|,
name|LDM_TH_NAME1
argument_list|,
name|strlen
argument_list|(
name|LDM_TH_NAME1
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|memcmp
argument_list|(
name|buf
operator|+
name|LDM_TH_NAME2_OFF
argument_list|,
name|LDM_TH_NAME2
argument_list|,
name|strlen
argument_list|(
name|LDM_TH_NAME2
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|LDM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"%s: failed to parse TOC header "
literal|"at LBA %ju"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|offset
argument_list|)
expr_stmt|;
name|LDM_DUMP
argument_list|(
name|buf
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|hdr
operator|.
name|conf_offset
operator|=
name|be64dec
argument_list|(
name|buf
operator|+
name|LDM_TH_CONF_OFF
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|log_offset
operator|=
name|be64dec
argument_list|(
name|buf
operator|+
name|LDM_TH_LOG_OFF
argument_list|)
expr_stmt|;
name|conf_size
operator|=
name|be64dec
argument_list|(
name|buf
operator|+
name|LDM_TH_CONFSIZE_OFF
argument_list|)
expr_stmt|;
name|log_size
operator|=
name|be64dec
argument_list|(
name|buf
operator|+
name|LDM_TH_LOGSIZE_OFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf_size
operator|!=
name|db
operator|->
name|ph
operator|.
name|conf_size
operator|||
name|hdr
operator|.
name|conf_offset
operator|+
name|conf_size
operator|>=
name|LDM_DB_SIZE
operator|||
name|log_size
operator|!=
name|db
operator|->
name|ph
operator|.
name|log_size
operator|||
name|hdr
operator|.
name|log_offset
operator|+
name|log_size
operator|>=
name|LDM_DB_SIZE
condition|)
block|{
name|LDM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"%s: invalid values in the "
literal|"TOC header at LBA %ju"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|offset
argument_list|)
expr_stmt|;
name|LDM_DUMP
argument_list|(
name|buf
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
literal|0
condition|)
name|memcpy
argument_list|(
operator|&
name|db
operator|->
name|th
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
name|LDM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"%s: valid LDM TOC header not found."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ldm_vmdbhdr_check
parameter_list|(
name|struct
name|ldm_db
modifier|*
name|db
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|uuid
name|dg_guid
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|;
name|uint32_t
name|version
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|offset
operator|=
name|db
operator|->
name|ph
operator|.
name|db_offset
operator|+
name|db
operator|->
name|th
operator|.
name|conf_offset
expr_stmt|;
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|offset
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|LDM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"%s: failed to read VMDB header at "
literal|"LBA %ju"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|buf
argument_list|,
name|LDM_VMDB_SIGN
argument_list|,
name|strlen
argument_list|(
name|LDM_VMDB_SIGN
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|LDM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"%s: failed to parse VMDB header at "
literal|"LBA %ju"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Check version. */
name|version
operator|=
name|be32dec
argument_list|(
name|buf
operator|+
name|LDM_DB_VERSION_OFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|!=
literal|0x4000A
condition|)
block|{
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|LDM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"%s: unsupported VMDB version %u.%u"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|version
operator|>>
literal|16
argument_list|,
name|version
operator|&
literal|0xFFFF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Check VMDB update status: 	 *	1 - in a consistent state; 	 *	2 - in a creation phase; 	 *	3 - in a deletion phase; 	 */
if|if
condition|(
name|be16dec
argument_list|(
name|buf
operator|+
name|LDM_DB_STATUS_OFF
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|LDM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"%s: VMDB is not in a consistent state"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|db
operator|->
name|dh
operator|.
name|last_seq
operator|=
name|be32dec
argument_list|(
name|buf
operator|+
name|LDM_DB_LASTSEQ_OFF
argument_list|)
expr_stmt|;
name|db
operator|->
name|dh
operator|.
name|size
operator|=
name|be32dec
argument_list|(
name|buf
operator|+
name|LDM_DB_SIZE_OFF
argument_list|)
expr_stmt|;
name|error
operator|=
name|parse_uuid
argument_list|(
name|buf
operator|+
name|LDM_DB_DGGUID_OFF
argument_list|,
operator|&
name|dg_guid
argument_list|)
expr_stmt|;
comment|/* Compare disk group name and guid from VMDB and private headers */
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|db
operator|->
name|dh
operator|.
name|size
operator|==
literal|0
operator|||
name|pp
operator|->
name|sectorsize
operator|%
name|db
operator|->
name|dh
operator|.
name|size
operator|!=
literal|0
operator|||
name|strncmp
argument_list|(
name|buf
operator|+
name|LDM_DB_DGNAME_OFF
argument_list|,
name|db
operator|->
name|ph
operator|.
name|dg_name
argument_list|,
literal|31
argument_list|)
operator|!=
literal|0
operator|||
name|memcmp
argument_list|(
operator|&
name|dg_guid
argument_list|,
operator|&
name|db
operator|->
name|ph
operator|.
name|dg_guid
argument_list|,
sizeof|sizeof
argument_list|(
name|dg_guid
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|db
operator|->
name|dh
operator|.
name|size
operator|*
name|db
operator|->
name|dh
operator|.
name|last_seq
operator|>
name|db
operator|->
name|ph
operator|.
name|conf_size
operator|*
name|pp
operator|->
name|sectorsize
condition|)
block|{
name|LDM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"%s: invalid values in the VMDB header"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|LDM_DUMP
argument_list|(
name|buf
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ldm_xvblk_handle
parameter_list|(
name|struct
name|ldm_db
modifier|*
name|db
parameter_list|,
name|struct
name|ldm_vblkhdr
modifier|*
name|vh
parameter_list|,
specifier|const
name|u_char
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|ldm_xvblk
modifier|*
name|blk
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|size
operator|=
name|db
operator|->
name|dh
operator|.
name|size
operator|-
literal|16
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|blk
argument_list|,
argument|&db->xvblks
argument_list|,
argument|entry
argument_list|)
if|if
condition|(
name|blk
operator|->
name|group
operator|==
name|vh
operator|->
name|group
condition|)
break|break;
if|if
condition|(
name|blk
operator|==
name|NULL
condition|)
block|{
name|blk
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|blk
argument_list|)
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|blk
operator|->
name|group
operator|=
name|vh
operator|->
name|group
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|size
operator|*
name|vh
operator|->
name|count
operator|+
literal|16
expr_stmt|;
name|blk
operator|->
name|data
operator|=
name|g_malloc
argument_list|(
name|blk
operator|->
name|size
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|blk
operator|->
name|map
operator|=
literal|0xFF
operator|<<
name|vh
operator|->
name|count
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|db
operator|->
name|xvblks
argument_list|,
name|blk
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|blk
operator|->
name|map
operator|&
operator|(
literal|1
operator|<<
name|vh
operator|->
name|index
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Block with given index has been already saved. */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Copy the data block to the place related to index. */
name|memcpy
argument_list|(
name|blk
operator|->
name|data
operator|+
name|size
operator|*
name|vh
operator|->
name|index
operator|+
literal|16
argument_list|,
name|p
operator|+
literal|16
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|blk
operator|->
name|map
operator||=
literal|1
operator|<<
name|vh
operator|->
name|index
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read the variable-width numeric field and return new offset */
end_comment

begin_function
specifier|static
name|int
name|ldm_vnum_get
parameter_list|(
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|offset
parameter_list|,
name|uint64_t
modifier|*
name|result
parameter_list|,
name|size_t
name|range
parameter_list|)
block|{
name|uint64_t
name|num
decl_stmt|;
name|uint8_t
name|len
decl_stmt|;
name|len
operator|=
name|buf
index|[
name|offset
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|||
name|len
operator|+
name|offset
operator|>=
name|range
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|num
operator|=
literal|0
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|--
control|)
name|num
operator|=
operator|(
name|num
operator|<<
literal|8
operator|)
operator||
name|buf
index|[
name|offset
operator|++
index|]
expr_stmt|;
operator|*
name|result
operator|=
name|num
expr_stmt|;
return|return
operator|(
name|offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Read the variable-width string and return new offset */
end_comment

begin_function
specifier|static
name|int
name|ldm_vstr_get
parameter_list|(
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|offset
parameter_list|,
name|u_char
modifier|*
name|result
parameter_list|,
name|size_t
name|maxlen
parameter_list|,
name|size_t
name|range
parameter_list|)
block|{
name|uint8_t
name|len
decl_stmt|;
name|len
operator|=
name|buf
index|[
name|offset
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|maxlen
operator|||
name|len
operator|+
name|offset
operator|>=
name|range
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|result
argument_list|,
name|buf
operator|+
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|offset
operator|+
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Just skip the variable-width variable and return new offset */
end_comment

begin_function
specifier|static
name|int
name|ldm_vparm_skip
parameter_list|(
specifier|const
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|offset
parameter_list|,
name|size_t
name|range
parameter_list|)
block|{
name|uint8_t
name|len
decl_stmt|;
name|len
operator|=
name|buf
index|[
name|offset
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|len
operator|>=
name|range
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|offset
operator|+
name|len
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ldm_vblk_handle
parameter_list|(
name|struct
name|ldm_db
modifier|*
name|db
parameter_list|,
specifier|const
name|u_char
modifier|*
name|p
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|ldm_vblk
modifier|*
name|blk
decl_stmt|;
name|struct
name|ldm_volume
modifier|*
name|volume
decl_stmt|,
modifier|*
name|last
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
name|u_char
name|vstr
index|[
literal|64
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|offset
decl_stmt|;
name|blk
operator|=
name|g_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|blk
argument_list|)
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|blk
operator|->
name|type
operator|=
name|p
index|[
name|LDM_VBLK_TYPE_OFF
index|]
expr_stmt|;
name|offset
operator|=
name|ldm_vnum_get
argument_list|(
name|p
argument_list|,
name|LDM_VBLK_OID_OFF
argument_list|,
operator|&
name|blk
operator|->
name|u
operator|.
name|id
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|errstr
operator|=
literal|"object id"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|offset
operator|=
name|ldm_vstr_get
argument_list|(
name|p
argument_list|,
name|offset
argument_list|,
name|vstr
argument_list|,
sizeof|sizeof
argument_list|(
name|vstr
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|errstr
operator|=
literal|"object name"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
switch|switch
condition|(
name|blk
operator|->
name|type
condition|)
block|{
comment|/* 	 * Component VBLK fields: 	 * Offset	Size	Description 	 * ------------+-------+------------------------ 	 *  0x18+	PS	volume state 	 *  0x18+5	PN	component children count 	 *  0x1D+16	PN	parent's volume object id 	 *  0x2D+1	PN	stripe size 	 */
case|case
name|LDM_VBLK_T_COMPONENT
case|:
name|offset
operator|=
name|ldm_vparm_skip
argument_list|(
name|p
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|errstr
operator|=
literal|"volume state"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|offset
operator|=
name|ldm_vparm_skip
argument_list|(
name|p
argument_list|,
name|offset
operator|+
literal|5
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|errstr
operator|=
literal|"children count"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|offset
operator|=
name|ldm_vnum_get
argument_list|(
name|p
argument_list|,
name|offset
operator|+
literal|16
argument_list|,
operator|&
name|blk
operator|->
name|u
operator|.
name|comp
operator|.
name|vol_id
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|errstr
operator|=
literal|"volume id"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
break|break;
comment|/* 	 * Partition VBLK fields: 	 * Offset	Size	Description 	 * ------------+-------+------------------------ 	 *  0x18+12	8	partition start offset 	 *  0x18+20	8	volume offset 	 *  0x18+28	PN	partition size 	 *  0x34+	PN	parent's component object id 	 *  0x34+	PN	disk's object id 	 */
case|case
name|LDM_VBLK_T_PARTITION
case|:
if|if
condition|(
name|offset
operator|+
literal|28
operator|>=
name|size
condition|)
block|{
name|errstr
operator|=
literal|"too small buffer"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|blk
operator|->
name|u
operator|.
name|part
operator|.
name|start
operator|=
name|be64dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|12
argument_list|)
expr_stmt|;
name|blk
operator|->
name|u
operator|.
name|part
operator|.
name|offset
operator|=
name|be64dec
argument_list|(
name|p
operator|+
name|offset
operator|+
literal|20
argument_list|)
expr_stmt|;
name|offset
operator|=
name|ldm_vnum_get
argument_list|(
name|p
argument_list|,
name|offset
operator|+
literal|28
argument_list|,
operator|&
name|blk
operator|->
name|u
operator|.
name|part
operator|.
name|size
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|errstr
operator|=
literal|"partition size"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|offset
operator|=
name|ldm_vnum_get
argument_list|(
name|p
argument_list|,
name|offset
argument_list|,
operator|&
name|blk
operator|->
name|u
operator|.
name|part
operator|.
name|comp_id
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|errstr
operator|=
literal|"component id"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|offset
operator|=
name|ldm_vnum_get
argument_list|(
name|p
argument_list|,
name|offset
argument_list|,
operator|&
name|blk
operator|->
name|u
operator|.
name|part
operator|.
name|disk_id
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|errstr
operator|=
literal|"disk id"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
break|break;
comment|/* 	 * Disk VBLK fields: 	 * Offset	Size	Description 	 * ------------+-------+------------------------ 	 *  0x18+	PS	disk GUID 	 */
case|case
name|LDM_VBLK_T_DISK
case|:
name|errstr
operator|=
literal|"disk guid"
expr_stmt|;
name|offset
operator|=
name|ldm_vstr_get
argument_list|(
name|p
argument_list|,
name|offset
argument_list|,
name|vstr
argument_list|,
sizeof|sizeof
argument_list|(
name|vstr
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
name|error
operator|=
name|parse_uuid
argument_list|(
name|vstr
argument_list|,
operator|&
name|blk
operator|->
name|u
operator|.
name|disk
operator|.
name|guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|db
operator|->
name|disks
argument_list|,
operator|&
name|blk
operator|->
name|u
operator|.
name|disk
argument_list|,
name|entry
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Disk group VBLK fields: 	 * Offset	Size	Description 	 * ------------+-------+------------------------ 	 *  0x18+	PS	disk group GUID 	 */
case|case
name|LDM_VBLK_T_DISKGROUP
case|:
if|#
directive|if
literal|0
block|strncpy(blk->u.disk_group.name, vstr, 		    sizeof(blk->u.disk_group.name)); 		offset = ldm_vstr_get(p, offset, vstr, sizeof(vstr), size); 		if (offset< 0) { 			errstr = "disk group guid"; 			goto fail; 		} 		error = parse_uuid(name,&blk->u.disk_group.guid); 		if (error != 0) { 			errstr = "disk group guid"; 			goto fail; 		} 		LIST_INSERT_HEAD(&db->groups,&blk->u.disk_group, entry);
endif|#
directive|endif
break|break;
comment|/* 	 * Disk VBLK fields: 	 * Offset	Size	Description 	 * ------------+-------+------------------------ 	 *  0x18+	16	disk GUID 	 */
case|case
name|LDM_VBLK_T_DISK4
case|:
name|be_uuid_dec
argument_list|(
name|p
operator|+
name|offset
argument_list|,
operator|&
name|blk
operator|->
name|u
operator|.
name|disk
operator|.
name|guid
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|db
operator|->
name|disks
argument_list|,
operator|&
name|blk
operator|->
name|u
operator|.
name|disk
argument_list|,
name|entry
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Disk group VBLK fields: 	 * Offset	Size	Description 	 * ------------+-------+------------------------ 	 *  0x18+	16	disk GUID 	 */
case|case
name|LDM_VBLK_T_DISKGROUP4
case|:
if|#
directive|if
literal|0
block|strncpy(blk->u.disk_group.name, vstr, 		    sizeof(blk->u.disk_group.name)); 		be_uuid_dec(p + offset,&blk->u.disk.guid); 		LIST_INSERT_HEAD(&db->groups,&blk->u.disk_group, entry);
endif|#
directive|endif
break|break;
comment|/* 	 * Volume VBLK fields: 	 * Offset	Size	Description 	 * ------------+-------+------------------------ 	 *  0x18+	PS	volume type 	 *  0x18+	PS	unknown 	 *  0x18+	14(S)	volume state 	 *  0x18+16	1	volume number 	 *  0x18+21	PN	volume children count 	 *  0x2D+16	PN	volume size 	 *  0x3D+4	1	partition type 	 */
case|case
name|LDM_VBLK_T_VOLUME
case|:
name|offset
operator|=
name|ldm_vparm_skip
argument_list|(
name|p
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|errstr
operator|=
literal|"volume type"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|offset
operator|=
name|ldm_vparm_skip
argument_list|(
name|p
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|errstr
operator|=
literal|"unknown param"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|offset
operator|+
literal|21
operator|>=
name|size
condition|)
block|{
name|errstr
operator|=
literal|"too small buffer"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|blk
operator|->
name|u
operator|.
name|vol
operator|.
name|number
operator|=
name|p
index|[
name|offset
operator|+
literal|16
index|]
expr_stmt|;
name|offset
operator|=
name|ldm_vparm_skip
argument_list|(
name|p
argument_list|,
name|offset
operator|+
literal|21
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|errstr
operator|=
literal|"children count"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|offset
operator|=
name|ldm_vnum_get
argument_list|(
name|p
argument_list|,
name|offset
operator|+
literal|16
argument_list|,
operator|&
name|blk
operator|->
name|u
operator|.
name|vol
operator|.
name|size
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|errstr
operator|=
literal|"volume size"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|offset
operator|+
literal|4
operator|>=
name|size
condition|)
block|{
name|errstr
operator|=
literal|"too small buffer"
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|blk
operator|->
name|u
operator|.
name|vol
operator|.
name|part_type
operator|=
name|p
index|[
name|offset
operator|+
literal|4
index|]
expr_stmt|;
comment|/* keep volumes ordered by volume number */
name|last
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|volume
argument_list|,
argument|&db->volumes
argument_list|,
argument|entry
argument_list|)
block|{
if|if
condition|(
name|volume
operator|->
name|number
operator|>
name|blk
operator|->
name|u
operator|.
name|vol
operator|.
name|number
condition|)
break|break;
name|last
operator|=
name|volume
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|!=
name|NULL
condition|)
name|LIST_INSERT_AFTER
argument_list|(
name|last
argument_list|,
operator|&
name|blk
operator|->
name|u
operator|.
name|vol
argument_list|,
name|entry
argument_list|)
expr_stmt|;
else|else
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|db
operator|->
name|volumes
argument_list|,
operator|&
name|blk
operator|->
name|u
operator|.
name|vol
argument_list|,
name|entry
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LDM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"unknown VBLK type 0x%02x\n"
argument_list|,
name|blk
operator|->
name|type
argument_list|)
expr_stmt|;
name|LDM_DUMP
argument_list|(
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|db
operator|->
name|vblks
argument_list|,
name|blk
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|LDM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"failed to parse '%s' in VBLK of type 0x%02x\n"
argument_list|,
name|errstr
argument_list|,
name|blk
operator|->
name|type
argument_list|)
expr_stmt|;
name|LDM_DUMP
argument_list|(
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|blk
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ldm_vmdb_free
parameter_list|(
name|struct
name|ldm_db
modifier|*
name|db
parameter_list|)
block|{
name|struct
name|ldm_vblk
modifier|*
name|vblk
decl_stmt|;
name|struct
name|ldm_xvblk
modifier|*
name|xvblk
decl_stmt|;
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|db
operator|->
name|xvblks
argument_list|)
condition|)
block|{
name|xvblk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|db
operator|->
name|xvblks
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|xvblk
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|xvblk
operator|->
name|data
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|xvblk
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|db
operator|->
name|vblks
argument_list|)
condition|)
block|{
name|vblk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|db
operator|->
name|vblks
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|vblk
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|vblk
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ldm_vmdb_parse
parameter_list|(
name|struct
name|ldm_db
modifier|*
name|db
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|ldm_vblk
modifier|*
name|vblk
decl_stmt|;
name|struct
name|ldm_xvblk
modifier|*
name|xvblk
decl_stmt|;
name|struct
name|ldm_volume
modifier|*
name|volume
decl_stmt|;
name|struct
name|ldm_component
modifier|*
name|comp
decl_stmt|;
name|struct
name|ldm_vblkhdr
name|vh
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|n
decl_stmt|,
name|sectors
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|;
name|int
name|error
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|size
operator|=
operator|(
name|db
operator|->
name|dh
operator|.
name|last_seq
operator|*
name|db
operator|->
name|dh
operator|.
name|size
operator|+
name|pp
operator|->
name|sectorsize
operator|-
literal|1
operator|)
operator|/
name|pp
operator|->
name|sectorsize
expr_stmt|;
name|size
operator|-=
literal|1
expr_stmt|;
comment|/* one sector takes vmdb header */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|size
condition|;
name|n
operator|+=
name|MAXPHYS
operator|/
name|pp
operator|->
name|sectorsize
control|)
block|{
name|offset
operator|=
name|db
operator|->
name|ph
operator|.
name|db_offset
operator|+
name|db
operator|->
name|th
operator|.
name|conf_offset
operator|+
name|n
operator|+
literal|1
expr_stmt|;
name|sectors
operator|=
operator|(
name|size
operator|-
name|n
operator|)
operator|>
operator|(
name|MAXPHYS
operator|/
name|pp
operator|->
name|sectorsize
operator|)
condition|?
name|MAXPHYS
operator|/
name|pp
operator|->
name|sectorsize
else|:
name|size
operator|-
name|n
expr_stmt|;
comment|/* read VBLKs */
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|offset
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
name|sectors
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|LDM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"%s: failed to read VBLK\n"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|p
operator|=
name|buf
init|;
name|p
operator|<
name|buf
operator|+
name|sectors
operator|*
name|pp
operator|->
name|sectorsize
condition|;
name|p
operator|+=
name|db
operator|->
name|dh
operator|.
name|size
control|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|p
argument_list|,
name|LDM_VBLK_SIGN
argument_list|,
name|strlen
argument_list|(
name|LDM_VBLK_SIGN
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|LDM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"%s: no VBLK signature\n"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|LDM_DUMP
argument_list|(
name|p
argument_list|,
name|db
operator|->
name|dh
operator|.
name|size
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|vh
operator|.
name|seq
operator|=
name|be32dec
argument_list|(
name|p
operator|+
name|LDM_VBLK_SEQ_OFF
argument_list|)
expr_stmt|;
name|vh
operator|.
name|group
operator|=
name|be32dec
argument_list|(
name|p
operator|+
name|LDM_VBLK_GROUP_OFF
argument_list|)
expr_stmt|;
comment|/* skip empty blocks */
if|if
condition|(
name|vh
operator|.
name|seq
operator|==
literal|0
operator|||
name|vh
operator|.
name|group
operator|==
literal|0
condition|)
continue|continue;
name|vh
operator|.
name|index
operator|=
name|be16dec
argument_list|(
name|p
operator|+
name|LDM_VBLK_INDEX_OFF
argument_list|)
expr_stmt|;
name|vh
operator|.
name|count
operator|=
name|be16dec
argument_list|(
name|p
operator|+
name|LDM_VBLK_COUNT_OFF
argument_list|)
expr_stmt|;
if|if
condition|(
name|vh
operator|.
name|count
operator|==
literal|0
operator|||
name|vh
operator|.
name|count
operator|>
literal|4
operator|||
name|vh
operator|.
name|seq
operator|>
name|db
operator|->
name|dh
operator|.
name|last_seq
condition|)
block|{
name|LDM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"%s: invalid values "
literal|"in the VBLK header\n"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|LDM_DUMP
argument_list|(
name|p
argument_list|,
name|db
operator|->
name|dh
operator|.
name|size
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|vh
operator|.
name|count
operator|>
literal|1
condition|)
block|{
name|error
operator|=
name|ldm_xvblk_handle
argument_list|(
name|db
argument_list|,
operator|&
name|vh
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|LDM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"%s: xVBLK "
literal|"is corrupted\n"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|LDM_DUMP
argument_list|(
name|p
argument_list|,
name|db
operator|->
name|dh
operator|.
name|size
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
continue|continue;
block|}
if|if
condition|(
name|be16dec
argument_list|(
name|p
operator|+
literal|16
argument_list|)
operator|!=
literal|0
condition|)
name|LDM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"%s: VBLK update"
literal|" status is %u\n"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|be16dec
argument_list|(
name|p
operator|+
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ldm_vblk_handle
argument_list|(
name|db
argument_list|,
name|p
argument_list|,
name|db
operator|->
name|dh
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
block|}
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Parse xVBLKs */
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|db
operator|->
name|xvblks
argument_list|)
condition|)
block|{
name|xvblk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|db
operator|->
name|xvblks
argument_list|)
expr_stmt|;
if|if
condition|(
name|xvblk
operator|->
name|map
operator|==
literal|0xFF
condition|)
block|{
name|error
operator|=
name|ldm_vblk_handle
argument_list|(
name|db
argument_list|,
name|xvblk
operator|->
name|data
argument_list|,
name|xvblk
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
block|}
else|else
block|{
name|LDM_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"%s: incomplete or corrupt "
literal|"xVBLK found\n"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|LIST_REMOVE
argument_list|(
name|xvblk
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|xvblk
operator|->
name|data
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|xvblk
argument_list|)
expr_stmt|;
block|}
comment|/* construct all VBLKs relations */
name|LIST_FOREACH
argument_list|(
argument|volume
argument_list|,
argument|&db->volumes
argument_list|,
argument|entry
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|vblk
argument_list|,
argument|&db->vblks
argument_list|,
argument|entry
argument_list|)
if|if
condition|(
name|vblk
operator|->
name|type
operator|==
name|LDM_VBLK_T_COMPONENT
operator|&&
name|vblk
operator|->
name|u
operator|.
name|comp
operator|.
name|vol_id
operator|==
name|volume
operator|->
name|id
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|volume
operator|->
name|components
argument_list|,
operator|&
name|vblk
operator|->
name|u
operator|.
name|comp
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|volume
operator|->
name|count
operator|++
expr_stmt|;
block|}
name|LIST_FOREACH
argument_list|(
argument|comp
argument_list|,
argument|&volume->components
argument_list|,
argument|entry
argument_list|)
name|LIST_FOREACH
argument_list|(
argument|vblk
argument_list|,
argument|&db->vblks
argument_list|,
argument|entry
argument_list|)
if|if
condition|(
name|vblk
operator|->
name|type
operator|==
name|LDM_VBLK_T_PARTITION
operator|&&
name|vblk
operator|->
name|u
operator|.
name|part
operator|.
name|comp_id
operator|==
name|comp
operator|->
name|id
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|comp
operator|->
name|partitions
argument_list|,
operator|&
name|vblk
operator|->
name|u
operator|.
name|part
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|comp
operator|->
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|ldm_vmdb_free
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_ldm_add
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|,
name|struct
name|g_part_parms
modifier|*
name|gpp
parameter_list|)
block|{
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_ldm_bootcode
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_parms
modifier|*
name|gpp
parameter_list|)
block|{
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_ldm_create
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_parms
modifier|*
name|gpp
parameter_list|)
block|{
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_ldm_destroy
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_parms
modifier|*
name|gpp
parameter_list|)
block|{
name|struct
name|g_part_ldm_table
modifier|*
name|table
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|table
operator|=
operator|(
expr|struct
name|g_part_ldm_table
operator|*
operator|)
name|basetable
expr_stmt|;
comment|/* 	 * To destroy LDM on a disk partitioned with GPT we should delete 	 * ms-ldm-metadata partition, but we can't do this via standard 	 * GEOM_PART method. 	 */
if|if
condition|(
name|table
operator|->
name|is_gpt
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
name|pp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|basetable
operator|->
name|gpt_gp
operator|->
name|consumer
argument_list|)
operator|->
name|provider
expr_stmt|;
comment|/* 	 * To destroy LDM we should wipe MBR, first private header and 	 * backup private headers. 	 */
name|basetable
operator|->
name|gpt_smhead
operator|=
operator|(
literal|1
operator|<<
name|ldm_ph_off
index|[
literal|0
index|]
operator|)
operator||
literal|1
expr_stmt|;
comment|/* 	 * Don't touch last backup private header when LDM database is 	 * not located in the last 1MByte area. 	 * XXX: can't remove all blocks. 	 */
if|if
condition|(
name|table
operator|->
name|db_offset
operator|+
name|LDM_DB_SIZE
operator|==
name|pp
operator|->
name|mediasize
operator|/
name|pp
operator|->
name|sectorsize
condition|)
name|basetable
operator|->
name|gpt_smtail
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_part_ldm_dumpconf
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|)
block|{
name|struct
name|g_part_ldm_entry
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|g_part_ldm_entry
operator|*
operator|)
name|baseentry
expr_stmt|;
if|if
condition|(
name|indent
operator|==
name|NULL
condition|)
block|{
comment|/* conftxt: libdisk compatibility */
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" xs LDM xt %u"
argument_list|,
name|entry
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
comment|/* confxml: partition entry information */
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<rawtype>%u</rawtype>\n"
argument_list|,
name|indent
argument_list|,
name|entry
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* confxml: scheme information */
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_ldm_dumpto
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|table
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_ldm_modify
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|,
name|struct
name|g_part_parms
modifier|*
name|gpp
parameter_list|)
block|{
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|g_part_ldm_name
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|table
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bufsz
parameter_list|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
name|bufsz
argument_list|,
literal|"s%d"
argument_list|,
name|baseentry
operator|->
name|gpe_index
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ldm_gpt_probe
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_part_ldm_table
modifier|*
name|table
decl_stmt|;
name|struct
name|g_part_table
modifier|*
name|gpt
decl_stmt|;
name|struct
name|g_part_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp2
decl_stmt|;
name|struct
name|gpt_ent
modifier|*
name|part
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * XXX: We use some knowlege about GEOM_PART_GPT internal 	 * structures, but it is easier than parse GPT by himself. 	 */
name|g_topology_lock
argument_list|()
expr_stmt|;
name|gpt
operator|=
name|cp
operator|->
name|provider
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|entry
argument_list|,
argument|&gpt->gpt_entry
argument_list|,
argument|gpe_entry
argument_list|)
block|{
name|part
operator|=
operator|(
expr|struct
name|gpt_ent
operator|*
operator|)
operator|(
name|entry
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Search ms-ldm-metadata partition */
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|part
operator|->
name|ent_type
argument_list|,
operator|&
name|gpt_uuid_ms_ldm_metadata
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uuid
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|entry
operator|->
name|gpe_end
operator|-
name|entry
operator|->
name|gpe_start
operator|<
name|LDM_DB_SIZE
operator|-
literal|1
condition|)
continue|continue;
comment|/* Create new consumer and attach it to metadata partition */
name|cp2
operator|=
name|g_new_consumer
argument_list|(
name|cp
operator|->
name|geom
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_attach
argument_list|(
name|cp2
argument_list|,
name|entry
operator|->
name|gpe_pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|g_destroy_consumer
argument_list|(
name|cp2
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|g_access
argument_list|(
name|cp2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|g_detach
argument_list|(
name|cp2
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp2
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|LDM_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"%s: LDM metadata partition %s found in the GPT"
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|,
name|cp2
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Read the LDM private header */
name|buf
operator|=
name|ldm_privhdr_read
argument_list|(
name|cp2
argument_list|,
name|ldm_ph_off
index|[
name|LDM_PH_GPTINDEX
index|]
operator|*
name|cp2
operator|->
name|provider
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
name|table
operator|=
operator|(
expr|struct
name|g_part_ldm_table
operator|*
operator|)
name|basetable
expr_stmt|;
name|table
operator|->
name|is_gpt
operator|=
literal|1
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|G_PART_PROBE_PRI_HIGH
operator|)
return|;
block|}
comment|/* second consumer is no longer needed. */
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_access
argument_list|(
name|cp2
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp2
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp2
argument_list|)
expr_stmt|;
break|break;
block|}
name|g_topology_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_ldm_probe
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|,
name|type
index|[
literal|64
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|idx
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sectorsize
operator|!=
literal|512
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|error
operator|=
name|g_getattr
argument_list|(
literal|"PART::scheme"
argument_list|,
name|cp
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"GPT"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|g_getattr
argument_list|(
literal|"PART::type"
argument_list|,
name|cp
argument_list|,
operator|&
name|type
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"ms-ldm-data"
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|error
operator|=
name|ldm_gpt_probe
argument_list|(
name|basetable
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|basetable
operator|->
name|gpt_depth
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* LDM has 1M metadata area */
if|if
condition|(
name|pp
operator|->
name|mediasize
operator|<=
literal|1024
operator|*
literal|1024
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* Check that there's a MBR */
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|le16dec
argument_list|(
name|buf
operator|+
name|DOSMAGICOFFSET
argument_list|)
operator|!=
name|DOSMAGIC
condition|)
block|{
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|ENXIO
expr_stmt|;
comment|/* Check that we have LDM partitions in the MBR */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|NDOSPART
operator|&&
name|error
operator|!=
literal|0
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|buf
index|[
name|DOSPARTOFF
operator|+
name|idx
operator|*
name|DOSPARTSIZE
operator|+
literal|4
index|]
operator|==
name|DOSPTYP_LDM
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|LDM_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"%s: LDM data partitions found in MBR"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Read the LDM private header */
name|buf
operator|=
name|ldm_privhdr_read
argument_list|(
name|cp
argument_list|,
name|ldm_ph_off
index|[
name|LDM_PH_MBRINDEX
index|]
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|G_PART_PROBE_PRI_HIGH
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_ldm_read
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_part_ldm_table
modifier|*
name|table
decl_stmt|;
name|struct
name|g_part_ldm_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp2
decl_stmt|;
name|struct
name|ldm_component
modifier|*
name|comp
decl_stmt|;
name|struct
name|ldm_partition
modifier|*
name|part
decl_stmt|;
name|struct
name|ldm_volume
modifier|*
name|vol
decl_stmt|;
name|struct
name|ldm_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|ldm_db
name|db
decl_stmt|;
name|int
name|error
decl_stmt|,
name|index
decl_stmt|,
name|skipped
decl_stmt|;
name|table
operator|=
operator|(
expr|struct
name|g_part_ldm_table
operator|*
operator|)
name|basetable
expr_stmt|;
name|memset
argument_list|(
operator|&
name|db
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|cp2
operator|=
name|cp
expr_stmt|;
comment|/* ms-ldm-data */
if|if
condition|(
name|table
operator|->
name|is_gpt
condition|)
name|cp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|cp
operator|->
name|geom
operator|->
name|consumer
argument_list|)
expr_stmt|;
comment|/* ms-ldm-metadata */
comment|/* Read and parse LDM private headers. */
name|error
operator|=
name|ldm_privhdr_check
argument_list|(
operator|&
name|db
argument_list|,
name|cp
argument_list|,
name|table
operator|->
name|is_gpt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|gpt_cleanup
goto|;
name|basetable
operator|->
name|gpt_first
operator|=
name|table
operator|->
name|is_gpt
condition|?
literal|0
else|:
name|db
operator|.
name|ph
operator|.
name|start
expr_stmt|;
name|basetable
operator|->
name|gpt_last
operator|=
name|basetable
operator|->
name|gpt_first
operator|+
name|db
operator|.
name|ph
operator|.
name|size
operator|-
literal|1
expr_stmt|;
name|table
operator|->
name|db_offset
operator|=
name|db
operator|.
name|ph
operator|.
name|db_offset
expr_stmt|;
comment|/* Make additional checks for GPT */
if|if
condition|(
name|table
operator|->
name|is_gpt
condition|)
block|{
name|error
operator|=
name|ldm_gpt_check
argument_list|(
operator|&
name|db
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|gpt_cleanup
goto|;
comment|/* 		 * Now we should reset database offset to zero, because our 		 * consumer cp is attached to the ms-ldm-metadata partition 		 * and we don't need add db_offset to read from it. 		 */
name|db
operator|.
name|ph
operator|.
name|db_offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Read and parse LDM TOC headers. */
name|error
operator|=
name|ldm_tochdr_check
argument_list|(
operator|&
name|db
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|gpt_cleanup
goto|;
comment|/* Read and parse LDM VMDB header. */
name|error
operator|=
name|ldm_vmdbhdr_check
argument_list|(
operator|&
name|db
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|gpt_cleanup
goto|;
name|error
operator|=
name|ldm_vmdb_parse
argument_list|(
operator|&
name|db
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* 	 * For the GPT case we must detach and destroy 	 * second consumer before return. 	 */
name|gpt_cleanup
label|:
if|if
condition|(
name|table
operator|->
name|is_gpt
condition|)
block|{
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|cp
operator|=
name|cp2
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Search current disk in the disk list. */
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&db.disks
argument_list|,
argument|entry
argument_list|)
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|disk
operator|->
name|guid
argument_list|,
operator|&
name|db
operator|.
name|ph
operator|.
name|disk_guid
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uuid
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
block|{
name|LDM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"%s: no LDM volumes on this disk"
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
name|ldm_vmdb_free
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|index
operator|=
literal|1
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|vol
argument_list|,
argument|&db.volumes
argument_list|,
argument|entry
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|comp
argument_list|,
argument|&vol->components
argument_list|,
argument|entry
argument_list|)
block|{
comment|/* Skip volumes from different disks. */
name|part
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|comp
operator|->
name|partitions
argument_list|)
expr_stmt|;
if|if
condition|(
name|part
operator|->
name|disk_id
operator|!=
name|disk
operator|->
name|id
condition|)
continue|continue;
name|skipped
operator|=
literal|0
expr_stmt|;
comment|/* We don't support spanned and striped volumes. */
if|if
condition|(
name|comp
operator|->
name|count
operator|>
literal|1
operator|||
name|part
operator|->
name|offset
operator|!=
literal|0
condition|)
block|{
name|LDM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"%s: LDM volume component "
literal|"%ju has %u partitions. Skipped"
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|comp
operator|->
name|id
argument_list|,
name|comp
operator|->
name|count
argument_list|)
expr_stmt|;
name|skipped
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 			 * Allow mirrored volumes only when they are explicitly 			 * allowed with kern.geom.part.ldm.show_mirrors=1. 			 */
if|if
condition|(
name|vol
operator|->
name|count
operator|>
literal|1
operator|&&
name|show_mirrors
operator|==
literal|0
condition|)
block|{
name|LDM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"%s: LDM volume %ju has %u "
literal|"components. Skipped"
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|vol
operator|->
name|id
argument_list|,
name|vol
operator|->
name|count
argument_list|)
expr_stmt|;
name|skipped
operator|=
literal|1
expr_stmt|;
block|}
name|entry
operator|=
operator|(
expr|struct
name|g_part_ldm_entry
operator|*
operator|)
name|g_part_new_entry
argument_list|(
name|basetable
argument_list|,
name|index
operator|++
argument_list|,
name|basetable
operator|->
name|gpt_first
operator|+
name|part
operator|->
name|start
argument_list|,
name|basetable
operator|->
name|gpt_first
operator|+
name|part
operator|->
name|start
operator|+
name|part
operator|->
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * Mark skipped partition as ms-ldm-data partition. 			 * We do not support them, but it is better to show 			 * that we have something there, than just show 			 * free space. 			 */
if|if
condition|(
name|skipped
operator|==
literal|0
condition|)
name|entry
operator|->
name|type
operator|=
name|vol
operator|->
name|part_type
expr_stmt|;
else|else
name|entry
operator|->
name|type
operator|=
name|DOSPTYP_LDM
expr_stmt|;
name|LDM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"%s: new volume id: %ju, start: %ju,"
literal|" end: %ju, type: 0x%02x\n"
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|,
operator|(
name|uintmax_t
operator|)
name|part
operator|->
name|id
argument_list|,
operator|(
name|uintmax_t
operator|)
name|part
operator|->
name|start
operator|+
name|basetable
operator|->
name|gpt_first
argument_list|,
operator|(
name|uintmax_t
operator|)
name|part
operator|->
name|start
operator|+
name|part
operator|->
name|size
operator|+
name|basetable
operator|->
name|gpt_first
operator|-
literal|1
argument_list|,
name|vol
operator|->
name|part_type
argument_list|)
expr_stmt|;
block|}
block|}
name|ldm_vmdb_free
argument_list|(
operator|&
name|db
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|g_part_ldm_type
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bufsz
parameter_list|)
block|{
name|struct
name|g_part_ldm_entry
modifier|*
name|entry
decl_stmt|;
name|int
name|i
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|g_part_ldm_entry
operator|*
operator|)
name|baseentry
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|ldm_alias_match
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|ldm_alias_match
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ldm_alias_match
index|[
name|i
index|]
operator|.
name|typ
operator|==
name|entry
operator|->
name|type
condition|)
return|return
operator|(
name|g_part_alias_name
argument_list|(
name|ldm_alias_match
index|[
name|i
index|]
operator|.
name|alias
argument_list|)
operator|)
return|;
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
name|bufsz
argument_list|,
literal|"!%d"
argument_list|,
name|entry
operator|->
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_ldm_write
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_function

end_unit

