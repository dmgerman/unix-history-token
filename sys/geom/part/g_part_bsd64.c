begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2014 Andrey V. Elsukov<ae@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/gpt.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom_int.h>
end_include

begin_include
include|#
directive|include
file|<geom/part/g_part.h>
end_include

begin_include
include|#
directive|include
file|"g_part_if.h"
end_include

begin_expr_stmt
name|FEATURE
argument_list|(
name|geom_part_bsd64
argument_list|,
literal|"GEOM partitioning class for 64-bit BSD disklabels"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* XXX: move this to sys/disklabel64.h */
end_comment

begin_define
define|#
directive|define
name|DISKMAGIC64
value|((uint32_t)0xc4464c59)
end_define

begin_define
define|#
directive|define
name|MAXPARTITIONS64
value|16
end_define

begin_define
define|#
directive|define
name|RESPARTITIONS64
value|32
end_define

begin_struct
struct|struct
name|disklabel64
block|{
name|char
name|d_reserved0
index|[
literal|512
index|]
decl_stmt|;
comment|/* reserved or unused */
name|u_int32_t
name|d_magic
decl_stmt|;
comment|/* the magic number */
name|u_int32_t
name|d_crc
decl_stmt|;
comment|/* crc32() d_magic thru last part */
name|u_int32_t
name|d_align
decl_stmt|;
comment|/* partition alignment requirement */
name|u_int32_t
name|d_npartitions
decl_stmt|;
comment|/* number of partitions */
name|struct
name|uuid
name|d_stor_uuid
decl_stmt|;
comment|/* unique uuid for label */
name|u_int64_t
name|d_total_size
decl_stmt|;
comment|/* total size incl everything (bytes) */
name|u_int64_t
name|d_bbase
decl_stmt|;
comment|/* boot area base offset (bytes) */
comment|/* boot area is pbase - bbase */
name|u_int64_t
name|d_pbase
decl_stmt|;
comment|/* first allocatable offset (bytes) */
name|u_int64_t
name|d_pstop
decl_stmt|;
comment|/* last allocatable offset+1 (bytes) */
name|u_int64_t
name|d_abase
decl_stmt|;
comment|/* location of backup copy if not 0 */
name|u_char
name|d_packname
index|[
literal|64
index|]
decl_stmt|;
name|u_char
name|d_reserved
index|[
literal|64
index|]
decl_stmt|;
comment|/* 	 * Note: offsets are relative to the base of the slice, NOT to 	 * d_pbase.  Unlike 32 bit disklabels the on-disk format for 	 * a 64 bit disklabel remains slice-relative. 	 * 	 * An uninitialized partition has a p_boffset and p_bsize of 0. 	 * 	 * If p_fstype is not supported for a live partition it is set 	 * to FS_OTHER.  This is typically the case when the filesystem 	 * is identified by its uuid. 	 */
struct|struct
name|partition64
block|{
comment|/* the partition table */
name|u_int64_t
name|p_boffset
decl_stmt|;
comment|/* slice relative offset, in bytes */
name|u_int64_t
name|p_bsize
decl_stmt|;
comment|/* size of partition, in bytes */
name|u_int8_t
name|p_fstype
decl_stmt|;
name|u_int8_t
name|p_unused01
decl_stmt|;
comment|/* reserved, must be 0 */
name|u_int8_t
name|p_unused02
decl_stmt|;
comment|/* reserved, must be 0 */
name|u_int8_t
name|p_unused03
decl_stmt|;
comment|/* reserved, must be 0 */
name|u_int32_t
name|p_unused04
decl_stmt|;
comment|/* reserved, must be 0 */
name|u_int32_t
name|p_unused05
decl_stmt|;
comment|/* reserved, must be 0 */
name|u_int32_t
name|p_unused06
decl_stmt|;
comment|/* reserved, must be 0 */
name|struct
name|uuid
name|p_type_uuid
decl_stmt|;
comment|/* mount type as UUID */
name|struct
name|uuid
name|p_stor_uuid
decl_stmt|;
comment|/* unique uuid for storage */
block|}
name|d_partitions
index|[
name|MAXPARTITIONS64
index|]
struct|;
comment|/* actually may be more */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|g_part_bsd64_table
block|{
name|struct
name|g_part_table
name|base
decl_stmt|;
name|uint32_t
name|d_align
decl_stmt|;
name|uint64_t
name|d_bbase
decl_stmt|;
name|uint64_t
name|d_abase
decl_stmt|;
name|struct
name|uuid
name|d_stor_uuid
decl_stmt|;
name|char
name|d_reserved0
index|[
literal|512
index|]
decl_stmt|;
name|u_char
name|d_packname
index|[
literal|64
index|]
decl_stmt|;
name|u_char
name|d_reserved
index|[
literal|64
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|g_part_bsd64_entry
block|{
name|struct
name|g_part_entry
name|base
decl_stmt|;
name|uint8_t
name|fstype
decl_stmt|;
name|struct
name|uuid
name|type_uuid
decl_stmt|;
name|struct
name|uuid
name|stor_uuid
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|g_part_bsd64_add
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|,
name|struct
name|g_part_parms
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_bsd64_bootcode
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_parms
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_bsd64_create
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_parms
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_bsd64_destroy
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_parms
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_part_bsd64_dumpconf
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|,
name|struct
name|sbuf
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_bsd64_dumpto
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_bsd64_modify
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|,
name|struct
name|g_part_parms
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|g_part_bsd64_name
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_bsd64_probe
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_consumer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_bsd64_read
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_consumer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|g_part_bsd64_type
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_bsd64_write
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_consumer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_part_bsd64_resize
parameter_list|(
name|struct
name|g_part_table
modifier|*
parameter_list|,
name|struct
name|g_part_entry
modifier|*
parameter_list|,
name|struct
name|g_part_parms
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|kobj_method_t
name|g_part_bsd64_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|g_part_add
argument_list|,
name|g_part_bsd64_add
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_bootcode
argument_list|,
name|g_part_bsd64_bootcode
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_create
argument_list|,
name|g_part_bsd64_create
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_destroy
argument_list|,
name|g_part_bsd64_destroy
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_dumpconf
argument_list|,
name|g_part_bsd64_dumpconf
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_dumpto
argument_list|,
name|g_part_bsd64_dumpto
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_modify
argument_list|,
name|g_part_bsd64_modify
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_resize
argument_list|,
name|g_part_bsd64_resize
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_name
argument_list|,
name|g_part_bsd64_name
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_probe
argument_list|,
name|g_part_bsd64_probe
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_read
argument_list|,
name|g_part_bsd64_read
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_type
argument_list|,
name|g_part_bsd64_type
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_part_write
argument_list|,
name|g_part_bsd64_write
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|g_part_scheme
name|g_part_bsd64_scheme
init|=
block|{
literal|"BSD64"
block|,
name|g_part_bsd64_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|g_part_bsd64_table
argument_list|)
block|,
operator|.
name|gps_entrysz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|g_part_bsd64_entry
argument_list|)
block|,
operator|.
name|gps_minent
operator|=
name|MAXPARTITIONS64
block|,
operator|.
name|gps_maxent
operator|=
name|MAXPARTITIONS64
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|G_PART_SCHEME_DECLARE
argument_list|(
name|g_part_bsd64
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|EQUUID
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(memcmp(a, b, sizeof(struct uuid)) == 0)
end_define

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|bsd64_uuid_unused
init|=
name|GPT_ENT_TYPE_UNUSED
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|bsd64_uuid_dfbsd_swap
init|=
name|GPT_ENT_TYPE_DRAGONFLY_SWAP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|bsd64_uuid_dfbsd_ufs1
init|=
name|GPT_ENT_TYPE_DRAGONFLY_UFS1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|bsd64_uuid_dfbsd_vinum
init|=
name|GPT_ENT_TYPE_DRAGONFLY_VINUM
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|bsd64_uuid_dfbsd_ccd
init|=
name|GPT_ENT_TYPE_DRAGONFLY_CCD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|bsd64_uuid_dfbsd_legacy
init|=
name|GPT_ENT_TYPE_DRAGONFLY_LEGACY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|bsd64_uuid_dfbsd_hammer
init|=
name|GPT_ENT_TYPE_DRAGONFLY_HAMMER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|bsd64_uuid_dfbsd_hammer2
init|=
name|GPT_ENT_TYPE_DRAGONFLY_HAMMER2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|bsd64_uuid_freebsd_boot
init|=
name|GPT_ENT_TYPE_FREEBSD_BOOT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|bsd64_uuid_freebsd_nandfs
init|=
name|GPT_ENT_TYPE_FREEBSD_NANDFS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|bsd64_uuid_freebsd_swap
init|=
name|GPT_ENT_TYPE_FREEBSD_SWAP
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|bsd64_uuid_freebsd_ufs
init|=
name|GPT_ENT_TYPE_FREEBSD_UFS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|bsd64_uuid_freebsd_vinum
init|=
name|GPT_ENT_TYPE_FREEBSD_VINUM
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|uuid
name|bsd64_uuid_freebsd_zfs
init|=
name|GPT_ENT_TYPE_FREEBSD_ZFS
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|bsd64_uuid_alias
block|{
name|struct
name|uuid
modifier|*
name|uuid
decl_stmt|;
name|uint8_t
name|fstype
decl_stmt|;
name|int
name|alias
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|bsd64_uuid_alias
name|dfbsd_alias_match
index|[]
init|=
block|{
block|{
operator|&
name|bsd64_uuid_dfbsd_swap
block|,
name|FS_SWAP
block|,
name|G_PART_ALIAS_DFBSD_SWAP
block|}
block|,
block|{
operator|&
name|bsd64_uuid_dfbsd_ufs1
block|,
name|FS_BSDFFS
block|,
name|G_PART_ALIAS_DFBSD_UFS
block|}
block|,
block|{
operator|&
name|bsd64_uuid_dfbsd_vinum
block|,
name|FS_VINUM
block|,
name|G_PART_ALIAS_DFBSD_VINUM
block|}
block|,
block|{
operator|&
name|bsd64_uuid_dfbsd_ccd
block|,
name|FS_CCD
block|,
name|G_PART_ALIAS_DFBSD_CCD
block|}
block|,
block|{
operator|&
name|bsd64_uuid_dfbsd_legacy
block|,
name|FS_OTHER
block|,
name|G_PART_ALIAS_DFBSD_LEGACY
block|}
block|,
block|{
operator|&
name|bsd64_uuid_dfbsd_hammer
block|,
name|FS_HAMMER
block|,
name|G_PART_ALIAS_DFBSD_HAMMER
block|}
block|,
block|{
operator|&
name|bsd64_uuid_dfbsd_hammer2
block|,
name|FS_HAMMER2
block|,
name|G_PART_ALIAS_DFBSD_HAMMER2
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bsd64_uuid_alias
name|fbsd_alias_match
index|[]
init|=
block|{
block|{
operator|&
name|bsd64_uuid_freebsd_boot
block|,
name|FS_OTHER
block|,
name|G_PART_ALIAS_FREEBSD_BOOT
block|}
block|,
block|{
operator|&
name|bsd64_uuid_freebsd_swap
block|,
name|FS_OTHER
block|,
name|G_PART_ALIAS_FREEBSD_SWAP
block|}
block|,
block|{
operator|&
name|bsd64_uuid_freebsd_ufs
block|,
name|FS_OTHER
block|,
name|G_PART_ALIAS_FREEBSD_UFS
block|}
block|,
block|{
operator|&
name|bsd64_uuid_freebsd_zfs
block|,
name|FS_OTHER
block|,
name|G_PART_ALIAS_FREEBSD_ZFS
block|}
block|,
block|{
operator|&
name|bsd64_uuid_freebsd_vinum
block|,
name|FS_OTHER
block|,
name|G_PART_ALIAS_FREEBSD_VINUM
block|}
block|,
block|{
operator|&
name|bsd64_uuid_freebsd_nandfs
block|,
name|FS_OTHER
block|,
name|G_PART_ALIAS_FREEBSD_NANDFS
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|bsd64_parse_type
parameter_list|(
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|struct
name|g_part_bsd64_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|uuid
name|tmp
decl_stmt|;
specifier|const
name|struct
name|bsd64_uuid_alias
modifier|*
name|uap
decl_stmt|;
specifier|const
name|char
modifier|*
name|alias
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|long
name|lt
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|type
index|[
literal|0
index|]
operator|==
literal|'!'
condition|)
block|{
if|if
condition|(
name|type
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|lt
operator|=
name|strtol
argument_list|(
name|type
operator|+
literal|1
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The type specified as number */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|lt
operator|<=
literal|0
operator|||
name|lt
operator|>
literal|255
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|entry
operator|->
name|fstype
operator|=
name|lt
expr_stmt|;
name|entry
operator|->
name|type_uuid
operator|=
name|bsd64_uuid_unused
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* The type specified as uuid */
name|error
operator|=
name|parse_uuid
argument_list|(
name|type
operator|+
literal|1
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|EQUUID
argument_list|(
operator|&
name|tmp
argument_list|,
operator|&
name|bsd64_uuid_unused
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|uap
operator|=
operator|&
name|dfbsd_alias_match
index|[
literal|0
index|]
init|;
name|uap
operator|->
name|uuid
operator|!=
name|NULL
condition|;
name|uap
operator|++
control|)
block|{
if|if
condition|(
name|EQUUID
argument_list|(
operator|&
name|tmp
argument_list|,
name|uap
operator|->
name|uuid
argument_list|)
condition|)
block|{
comment|/* Prefer fstype for known uuids */
name|entry
operator|->
name|type_uuid
operator|=
name|bsd64_uuid_unused
expr_stmt|;
name|entry
operator|->
name|fstype
operator|=
name|uap
operator|->
name|fstype
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|entry
operator|->
name|type_uuid
operator|=
name|tmp
expr_stmt|;
name|entry
operator|->
name|fstype
operator|=
name|FS_OTHER
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* The type specified as symbolic alias name */
for|for
control|(
name|uap
operator|=
operator|&
name|fbsd_alias_match
index|[
literal|0
index|]
init|;
name|uap
operator|->
name|uuid
operator|!=
name|NULL
condition|;
name|uap
operator|++
control|)
block|{
name|alias
operator|=
name|g_part_alias_name
argument_list|(
name|uap
operator|->
name|alias
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|type
argument_list|,
name|alias
argument_list|)
condition|)
block|{
name|entry
operator|->
name|type_uuid
operator|=
operator|*
name|uap
operator|->
name|uuid
expr_stmt|;
name|entry
operator|->
name|fstype
operator|=
name|uap
operator|->
name|fstype
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
for|for
control|(
name|uap
operator|=
operator|&
name|dfbsd_alias_match
index|[
literal|0
index|]
init|;
name|uap
operator|->
name|uuid
operator|!=
name|NULL
condition|;
name|uap
operator|++
control|)
block|{
name|alias
operator|=
name|g_part_alias_name
argument_list|(
name|uap
operator|->
name|alias
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|type
argument_list|,
name|alias
argument_list|)
condition|)
block|{
name|entry
operator|->
name|type_uuid
operator|=
name|bsd64_uuid_unused
expr_stmt|;
name|entry
operator|->
name|fstype
operator|=
name|uap
operator|->
name|fstype
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_bsd64_add
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|,
name|struct
name|g_part_parms
modifier|*
name|gpp
parameter_list|)
block|{
name|struct
name|g_part_bsd64_entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|gpp
operator|->
name|gpp_parms
operator|&
name|G_PART_PARM_LABEL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|entry
operator|=
operator|(
expr|struct
name|g_part_bsd64_entry
operator|*
operator|)
name|baseentry
expr_stmt|;
if|if
condition|(
name|bsd64_parse_type
argument_list|(
name|gpp
operator|->
name|gpp_type
argument_list|,
name|entry
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|kern_uuidgen
argument_list|(
operator|&
name|entry
operator|->
name|stor_uuid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_bsd64_bootcode
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_parms
modifier|*
name|gpp
parameter_list|)
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PALIGN_SIZE
value|(1024 * 1024)
end_define

begin_define
define|#
directive|define
name|PALIGN_MASK
value|(PALIGN_SIZE - 1)
end_define

begin_define
define|#
directive|define
name|BLKSIZE
value|(4 * 1024)
end_define

begin_define
define|#
directive|define
name|BOOTSIZE
value|(32 * 1024)
end_define

begin_define
define|#
directive|define
name|DALIGN_SIZE
value|(32 * 1024)
end_define

begin_function
specifier|static
name|int
name|g_part_bsd64_create
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_parms
modifier|*
name|gpp
parameter_list|)
block|{
name|struct
name|g_part_bsd64_table
modifier|*
name|table
decl_stmt|;
name|struct
name|g_part_entry
modifier|*
name|baseentry
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|uint64_t
name|blkmask
decl_stmt|,
name|pbase
decl_stmt|;
name|uint32_t
name|blksize
decl_stmt|,
name|ressize
decl_stmt|;
name|pp
operator|=
name|gpp
operator|->
name|gpp_provider
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|mediasize
operator|<
literal|2
operator|*
name|PALIGN_SIZE
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* 	 * Use at least 4KB block size. Blksize is stored in the d_align. 	 * XXX: Actually it is used just for calculate d_bbase and used 	 * for better alignment in bsdlabel64(8). 	 */
name|blksize
operator|=
name|pp
operator|->
name|sectorsize
operator|<
name|BLKSIZE
condition|?
name|BLKSIZE
else|:
name|pp
operator|->
name|sectorsize
expr_stmt|;
name|blkmask
operator|=
name|blksize
operator|-
literal|1
expr_stmt|;
comment|/* Reserve enough space for RESPARTITIONS64 partitions. */
name|ressize
operator|=
name|offsetof
argument_list|(
expr|struct
name|disklabel64
argument_list|,
name|d_partitions
index|[
name|RESPARTITIONS64
index|]
argument_list|)
expr_stmt|;
name|ressize
operator|=
operator|(
name|ressize
operator|+
name|blkmask
operator|)
operator|&
operator|~
name|blkmask
expr_stmt|;
comment|/* 	 * Reserve enough space for bootcode and align first allocatable 	 * offset to PALIGN_SIZE. 	 * XXX: Currently DragonFlyBSD has 32KB bootcode, but the size could 	 * be bigger, because it is possible change it (it is equal pbase-bbase) 	 * in the bsdlabel64(8). 	 */
name|pbase
operator|=
name|ressize
operator|+
operator|(
operator|(
name|BOOTSIZE
operator|+
name|blkmask
operator|)
operator|&
operator|~
name|blkmask
operator|)
expr_stmt|;
name|pbase
operator|=
operator|(
name|pbase
operator|+
name|PALIGN_MASK
operator|)
operator|&
operator|~
name|PALIGN_MASK
expr_stmt|;
comment|/* 	 * Take physical offset into account and make first allocatable 	 * offset 32KB aligned to the start of the physical disk. 	 * XXX: Actually there are no such restrictions, this is how 	 * DragonFlyBSD behaves. 	 */
name|pbase
operator|+=
name|DALIGN_SIZE
operator|-
name|pp
operator|->
name|stripeoffset
operator|%
name|DALIGN_SIZE
expr_stmt|;
name|table
operator|=
operator|(
expr|struct
name|g_part_bsd64_table
operator|*
operator|)
name|basetable
expr_stmt|;
name|table
operator|->
name|d_align
operator|=
name|blksize
expr_stmt|;
name|table
operator|->
name|d_bbase
operator|=
name|ressize
operator|/
name|pp
operator|->
name|sectorsize
expr_stmt|;
name|table
operator|->
name|d_abase
operator|=
operator|(
operator|(
name|pp
operator|->
name|mediasize
operator|-
name|ressize
operator|)
operator|&
operator|~
name|blkmask
operator|)
operator|/
name|pp
operator|->
name|sectorsize
expr_stmt|;
name|kern_uuidgen
argument_list|(
operator|&
name|table
operator|->
name|d_stor_uuid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|basetable
operator|->
name|gpt_first
operator|=
name|pbase
operator|/
name|pp
operator|->
name|sectorsize
expr_stmt|;
name|basetable
operator|->
name|gpt_last
operator|=
name|table
operator|->
name|d_abase
operator|-
literal|1
expr_stmt|;
comment|/* XXX */
comment|/* 	 * Create 'c' partition and make it internal, so user will not be 	 * able use it. 	 */
name|baseentry
operator|=
name|g_part_new_entry
argument_list|(
name|basetable
argument_list|,
name|RAW_PART
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|baseentry
operator|->
name|gpe_internal
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_bsd64_destroy
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_parms
modifier|*
name|gpp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|pp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|basetable
operator|->
name|gpt_gp
operator|->
name|consumer
argument_list|)
operator|->
name|provider
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|sectorsize
operator|>
name|offsetof
argument_list|(
expr|struct
name|disklabel64
argument_list|,
name|d_magic
argument_list|)
condition|)
name|basetable
operator|->
name|gpt_smhead
operator||=
literal|1
expr_stmt|;
else|else
name|basetable
operator|->
name|gpt_smhead
operator||=
literal|3
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_part_bsd64_dumpconf
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|)
block|{
name|struct
name|g_part_bsd64_table
modifier|*
name|table
decl_stmt|;
name|struct
name|g_part_bsd64_entry
modifier|*
name|entry
decl_stmt|;
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|table
operator|->
name|d_packname
argument_list|)
index|]
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|g_part_bsd64_entry
operator|*
operator|)
name|baseentry
expr_stmt|;
if|if
condition|(
name|indent
operator|==
name|NULL
condition|)
block|{
comment|/* conftxt: libdisk compatibility */
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" xs BSD64 xt %u"
argument_list|,
name|entry
operator|->
name|fstype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
comment|/* confxml: partition entry information */
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<rawtype>%u</rawtype>\n"
argument_list|,
name|indent
argument_list|,
name|entry
operator|->
name|fstype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EQUUID
argument_list|(
operator|&
name|bsd64_uuid_unused
argument_list|,
operator|&
name|entry
operator|->
name|type_uuid
argument_list|)
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<type_uuid>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|sbuf_printf_uuid
argument_list|(
name|sb
argument_list|,
operator|&
name|entry
operator|->
name|type_uuid
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</type_uuid>\n"
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<stor_uuid>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|sbuf_printf_uuid
argument_list|(
name|sb
argument_list|,
operator|&
name|entry
operator|->
name|stor_uuid
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</stor_uuid>\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* confxml: scheme information */
name|table
operator|=
operator|(
expr|struct
name|g_part_bsd64_table
operator|*
operator|)
name|basetable
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<bootbase>%ju</bootbase>\n"
argument_list|,
name|indent
argument_list|,
operator|(
name|uintmax_t
operator|)
name|table
operator|->
name|d_bbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|d_abase
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<backupbase>%ju</backupbase>\n"
argument_list|,
name|indent
argument_list|,
operator|(
name|uintmax_t
operator|)
name|table
operator|->
name|d_abase
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<stor_uuid>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|sbuf_printf_uuid
argument_list|(
name|sb
argument_list|,
operator|&
name|table
operator|->
name|d_stor_uuid
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</stor_uuid>\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<label>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|table
operator|->
name|d_packname
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|g_conf_printf_escaped
argument_list|(
name|sb
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</label>\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_bsd64_dumpto
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|table
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|)
block|{
name|struct
name|g_part_bsd64_entry
modifier|*
name|entry
decl_stmt|;
comment|/* Allow dumping to a swap partition. */
name|entry
operator|=
operator|(
expr|struct
name|g_part_bsd64_entry
operator|*
operator|)
name|baseentry
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|fstype
operator|==
name|FS_SWAP
operator|||
name|EQUUID
argument_list|(
operator|&
name|entry
operator|->
name|type_uuid
argument_list|,
operator|&
name|bsd64_uuid_dfbsd_swap
argument_list|)
operator|||
name|EQUUID
argument_list|(
operator|&
name|entry
operator|->
name|type_uuid
argument_list|,
operator|&
name|bsd64_uuid_freebsd_swap
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_bsd64_modify
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|,
name|struct
name|g_part_parms
modifier|*
name|gpp
parameter_list|)
block|{
name|struct
name|g_part_bsd64_entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|gpp
operator|->
name|gpp_parms
operator|&
name|G_PART_PARM_LABEL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|entry
operator|=
operator|(
expr|struct
name|g_part_bsd64_entry
operator|*
operator|)
name|baseentry
expr_stmt|;
if|if
condition|(
name|gpp
operator|->
name|gpp_parms
operator|&
name|G_PART_PARM_TYPE
condition|)
return|return
operator|(
name|bsd64_parse_type
argument_list|(
name|gpp
operator|->
name|gpp_type
argument_list|,
name|entry
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_bsd64_resize
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|,
name|struct
name|g_part_parms
modifier|*
name|gpp
parameter_list|)
block|{
name|struct
name|g_part_bsd64_table
modifier|*
name|table
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
if|if
condition|(
name|baseentry
operator|==
name|NULL
condition|)
block|{
name|pp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|basetable
operator|->
name|gpt_gp
operator|->
name|consumer
argument_list|)
operator|->
name|provider
expr_stmt|;
name|table
operator|=
operator|(
expr|struct
name|g_part_bsd64_table
operator|*
operator|)
name|basetable
expr_stmt|;
name|table
operator|->
name|d_abase
operator|=
operator|(
operator|(
name|pp
operator|->
name|mediasize
operator|-
name|table
operator|->
name|d_bbase
operator|*
name|pp
operator|->
name|sectorsize
operator|)
operator|&
operator|~
operator|(
name|table
operator|->
name|d_align
operator|-
literal|1
operator|)
operator|)
operator|/
name|pp
operator|->
name|sectorsize
expr_stmt|;
name|basetable
operator|->
name|gpt_last
operator|=
name|table
operator|->
name|d_abase
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|baseentry
operator|->
name|gpe_end
operator|=
name|baseentry
operator|->
name|gpe_start
operator|+
name|gpp
operator|->
name|gpp_size
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|g_part_bsd64_name
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|table
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bufsz
parameter_list|)
block|{
name|snprintf
argument_list|(
name|buf
argument_list|,
name|bufsz
argument_list|,
literal|"%c"
argument_list|,
literal|'a'
operator|+
name|baseentry
operator|->
name|gpe_index
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_bsd64_probe
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|table
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|mediasize
operator|<
literal|2
operator|*
name|PALIGN_SIZE
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|v
operator|=
operator|(
name|pp
operator|->
name|sectorsize
operator|+
name|offsetof
argument_list|(
expr|struct
name|disklabel64
argument_list|,
name|d_magic
argument_list|)
operator|)
operator|&
operator|~
operator|(
name|pp
operator|->
name|sectorsize
operator|-
literal|1
operator|)
expr_stmt|;
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|,
name|v
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|v
operator|=
name|le32dec
argument_list|(
name|buf
operator|+
name|offsetof
argument_list|(
expr|struct
name|disklabel64
argument_list|,
name|d_magic
argument_list|)
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|==
name|DISKMAGIC64
condition|?
name|G_PART_PROBE_PRI_HIGH
else|:
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_bsd64_read
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_part_bsd64_table
modifier|*
name|table
decl_stmt|;
name|struct
name|g_part_bsd64_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|g_part_entry
modifier|*
name|baseentry
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|disklabel64
modifier|*
name|dlp
decl_stmt|;
name|uint64_t
name|v64
decl_stmt|,
name|sz
decl_stmt|;
name|uint32_t
name|v32
decl_stmt|;
name|int
name|error
decl_stmt|,
name|index
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|table
operator|=
operator|(
expr|struct
name|g_part_bsd64_table
operator|*
operator|)
name|basetable
expr_stmt|;
name|v32
operator|=
operator|(
name|pp
operator|->
name|sectorsize
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|disklabel64
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|pp
operator|->
name|sectorsize
operator|-
literal|1
operator|)
expr_stmt|;
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|,
name|v32
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dlp
operator|=
operator|(
expr|struct
name|disklabel64
operator|*
operator|)
name|buf
expr_stmt|;
name|basetable
operator|->
name|gpt_entries
operator|=
name|le32toh
argument_list|(
name|dlp
operator|->
name|d_npartitions
argument_list|)
expr_stmt|;
if|if
condition|(
name|basetable
operator|->
name|gpt_entries
operator|>
name|MAXPARTITIONS64
condition|)
goto|goto
name|invalid_label
goto|;
name|v32
operator|=
name|le32toh
argument_list|(
name|dlp
operator|->
name|d_crc
argument_list|)
expr_stmt|;
name|dlp
operator|->
name|d_crc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|crc32
argument_list|(
operator|&
name|dlp
operator|->
name|d_magic
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|disklabel64
argument_list|,
name|d_partitions
index|[
name|basetable
operator|->
name|gpt_entries
index|]
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|disklabel64
argument_list|,
name|d_magic
argument_list|)
argument_list|)
operator|!=
name|v32
condition|)
goto|goto
name|invalid_label
goto|;
name|table
operator|->
name|d_align
operator|=
name|le32toh
argument_list|(
name|dlp
operator|->
name|d_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|d_align
operator|==
literal|0
operator|||
operator|(
name|table
operator|->
name|d_align
operator|&
operator|(
name|pp
operator|->
name|sectorsize
operator|-
literal|1
operator|)
operator|)
condition|)
goto|goto
name|invalid_label
goto|;
if|if
condition|(
name|le64toh
argument_list|(
name|dlp
operator|->
name|d_total_size
argument_list|)
operator|>
name|pp
operator|->
name|mediasize
condition|)
goto|goto
name|invalid_label
goto|;
name|v64
operator|=
name|le64toh
argument_list|(
name|dlp
operator|->
name|d_pbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|v64
operator|%
name|pp
operator|->
name|sectorsize
condition|)
goto|goto
name|invalid_label
goto|;
name|basetable
operator|->
name|gpt_first
operator|=
name|v64
operator|/
name|pp
operator|->
name|sectorsize
expr_stmt|;
name|v64
operator|=
name|le64toh
argument_list|(
name|dlp
operator|->
name|d_pstop
argument_list|)
expr_stmt|;
if|if
condition|(
name|v64
operator|%
name|pp
operator|->
name|sectorsize
condition|)
goto|goto
name|invalid_label
goto|;
name|basetable
operator|->
name|gpt_last
operator|=
name|v64
operator|/
name|pp
operator|->
name|sectorsize
expr_stmt|;
name|basetable
operator|->
name|gpt_isleaf
operator|=
literal|1
expr_stmt|;
name|v64
operator|=
name|le64toh
argument_list|(
name|dlp
operator|->
name|d_bbase
argument_list|)
expr_stmt|;
if|if
condition|(
name|v64
operator|%
name|pp
operator|->
name|sectorsize
condition|)
goto|goto
name|invalid_label
goto|;
name|table
operator|->
name|d_bbase
operator|=
name|v64
operator|/
name|pp
operator|->
name|sectorsize
expr_stmt|;
name|v64
operator|=
name|le64toh
argument_list|(
name|dlp
operator|->
name|d_abase
argument_list|)
expr_stmt|;
if|if
condition|(
name|v64
operator|%
name|pp
operator|->
name|sectorsize
condition|)
goto|goto
name|invalid_label
goto|;
name|table
operator|->
name|d_abase
operator|=
name|v64
operator|/
name|pp
operator|->
name|sectorsize
expr_stmt|;
name|le_uuid_dec
argument_list|(
operator|&
name|dlp
operator|->
name|d_stor_uuid
argument_list|,
operator|&
name|table
operator|->
name|d_stor_uuid
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
name|basetable
operator|->
name|gpt_entries
operator|-
literal|1
init|;
name|index
operator|>=
literal|0
condition|;
name|index
operator|--
control|)
block|{
if|if
condition|(
name|index
operator|==
name|RAW_PART
condition|)
block|{
comment|/* Skip 'c' partition. */
name|baseentry
operator|=
name|g_part_new_entry
argument_list|(
name|basetable
argument_list|,
name|index
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|baseentry
operator|->
name|gpe_internal
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|v64
operator|=
name|le64toh
argument_list|(
name|dlp
operator|->
name|d_partitions
index|[
name|index
index|]
operator|.
name|p_boffset
argument_list|)
expr_stmt|;
name|sz
operator|=
name|le64toh
argument_list|(
name|dlp
operator|->
name|d_partitions
index|[
name|index
index|]
operator|.
name|p_bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|sz
operator|==
literal|0
operator|&&
name|v64
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sz
operator|==
literal|0
operator|||
operator|(
name|v64
operator|%
name|pp
operator|->
name|sectorsize
operator|)
operator|||
operator|(
name|sz
operator|%
name|pp
operator|->
name|sectorsize
operator|)
condition|)
goto|goto
name|invalid_label
goto|;
name|baseentry
operator|=
name|g_part_new_entry
argument_list|(
name|basetable
argument_list|,
name|index
operator|+
literal|1
argument_list|,
name|v64
operator|/
name|pp
operator|->
name|sectorsize
argument_list|,
operator|(
name|v64
operator|+
name|sz
operator|)
operator|/
name|pp
operator|->
name|sectorsize
operator|-
literal|1
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|g_part_bsd64_entry
operator|*
operator|)
name|baseentry
expr_stmt|;
name|le_uuid_dec
argument_list|(
operator|&
name|dlp
operator|->
name|d_partitions
index|[
name|index
index|]
operator|.
name|p_type_uuid
argument_list|,
operator|&
name|entry
operator|->
name|type_uuid
argument_list|)
expr_stmt|;
name|le_uuid_dec
argument_list|(
operator|&
name|dlp
operator|->
name|d_partitions
index|[
name|index
index|]
operator|.
name|p_stor_uuid
argument_list|,
operator|&
name|entry
operator|->
name|stor_uuid
argument_list|)
expr_stmt|;
name|entry
operator|->
name|fstype
operator|=
name|dlp
operator|->
name|d_partitions
index|[
name|index
index|]
operator|.
name|p_fstype
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|RAW_PART
condition|)
name|baseentry
operator|->
name|gpe_internal
operator|=
literal|1
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|dlp
operator|->
name|d_reserved0
argument_list|,
name|table
operator|->
name|d_reserved0
argument_list|,
sizeof|sizeof
argument_list|(
name|table
operator|->
name|d_reserved0
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dlp
operator|->
name|d_packname
argument_list|,
name|table
operator|->
name|d_packname
argument_list|,
sizeof|sizeof
argument_list|(
name|table
operator|->
name|d_packname
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dlp
operator|->
name|d_reserved
argument_list|,
name|table
operator|->
name|d_reserved
argument_list|,
sizeof|sizeof
argument_list|(
name|table
operator|->
name|d_reserved
argument_list|)
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|invalid_label
label|:
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|g_part_bsd64_type
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_part_entry
modifier|*
name|baseentry
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bufsz
parameter_list|)
block|{
name|struct
name|g_part_bsd64_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|bsd64_uuid_alias
modifier|*
name|uap
decl_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|g_part_bsd64_entry
operator|*
operator|)
name|baseentry
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|fstype
operator|!=
name|FS_OTHER
condition|)
block|{
for|for
control|(
name|uap
operator|=
operator|&
name|dfbsd_alias_match
index|[
literal|0
index|]
init|;
name|uap
operator|->
name|uuid
operator|!=
name|NULL
condition|;
name|uap
operator|++
control|)
if|if
condition|(
name|uap
operator|->
name|fstype
operator|==
name|entry
operator|->
name|fstype
condition|)
return|return
operator|(
name|g_part_alias_name
argument_list|(
name|uap
operator|->
name|alias
argument_list|)
operator|)
return|;
block|}
else|else
block|{
for|for
control|(
name|uap
operator|=
operator|&
name|fbsd_alias_match
index|[
literal|0
index|]
init|;
name|uap
operator|->
name|uuid
operator|!=
name|NULL
condition|;
name|uap
operator|++
control|)
if|if
condition|(
name|EQUUID
argument_list|(
name|uap
operator|->
name|uuid
argument_list|,
operator|&
name|entry
operator|->
name|type_uuid
argument_list|)
condition|)
return|return
operator|(
name|g_part_alias_name
argument_list|(
name|uap
operator|->
name|alias
argument_list|)
operator|)
return|;
for|for
control|(
name|uap
operator|=
operator|&
name|dfbsd_alias_match
index|[
literal|0
index|]
init|;
name|uap
operator|->
name|uuid
operator|!=
name|NULL
condition|;
name|uap
operator|++
control|)
if|if
condition|(
name|EQUUID
argument_list|(
name|uap
operator|->
name|uuid
argument_list|,
operator|&
name|entry
operator|->
name|type_uuid
argument_list|)
condition|)
return|return
operator|(
name|g_part_alias_name
argument_list|(
name|uap
operator|->
name|alias
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|EQUUID
argument_list|(
operator|&
name|bsd64_uuid_unused
argument_list|,
operator|&
name|entry
operator|->
name|type_uuid
argument_list|)
condition|)
name|snprintf
argument_list|(
name|buf
argument_list|,
name|bufsz
argument_list|,
literal|"!%d"
argument_list|,
name|entry
operator|->
name|fstype
argument_list|)
expr_stmt|;
else|else
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|'!'
expr_stmt|;
name|snprintf_uuid
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
name|bufsz
operator|-
literal|1
argument_list|,
operator|&
name|entry
operator|->
name|type_uuid
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_part_bsd64_write
parameter_list|(
name|struct
name|g_part_table
modifier|*
name|basetable
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_part_entry
modifier|*
name|baseentry
decl_stmt|;
name|struct
name|g_part_bsd64_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|g_part_bsd64_table
modifier|*
name|table
decl_stmt|;
name|struct
name|disklabel64
modifier|*
name|dlp
decl_stmt|;
name|uint32_t
name|v
decl_stmt|,
name|sz
decl_stmt|;
name|int
name|error
decl_stmt|,
name|index
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|table
operator|=
operator|(
expr|struct
name|g_part_bsd64_table
operator|*
operator|)
name|basetable
expr_stmt|;
name|sz
operator|=
operator|(
name|pp
operator|->
name|sectorsize
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|disklabel64
argument_list|)
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|pp
operator|->
name|sectorsize
operator|-
literal|1
operator|)
expr_stmt|;
name|dlp
operator|=
name|g_malloc
argument_list|(
name|sz
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dlp
operator|->
name|d_reserved0
argument_list|,
name|table
operator|->
name|d_reserved0
argument_list|,
sizeof|sizeof
argument_list|(
name|table
operator|->
name|d_reserved0
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dlp
operator|->
name|d_packname
argument_list|,
name|table
operator|->
name|d_packname
argument_list|,
sizeof|sizeof
argument_list|(
name|table
operator|->
name|d_packname
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dlp
operator|->
name|d_reserved
argument_list|,
name|table
operator|->
name|d_reserved
argument_list|,
sizeof|sizeof
argument_list|(
name|table
operator|->
name|d_reserved
argument_list|)
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
operator|&
name|dlp
operator|->
name|d_magic
argument_list|,
name|DISKMAGIC64
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
operator|&
name|dlp
operator|->
name|d_align
argument_list|,
name|table
operator|->
name|d_align
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
operator|&
name|dlp
operator|->
name|d_npartitions
argument_list|,
name|basetable
operator|->
name|gpt_entries
argument_list|)
expr_stmt|;
name|le_uuid_enc
argument_list|(
operator|&
name|dlp
operator|->
name|d_stor_uuid
argument_list|,
operator|&
name|table
operator|->
name|d_stor_uuid
argument_list|)
expr_stmt|;
name|le64enc
argument_list|(
operator|&
name|dlp
operator|->
name|d_total_size
argument_list|,
name|pp
operator|->
name|mediasize
argument_list|)
expr_stmt|;
name|le64enc
argument_list|(
operator|&
name|dlp
operator|->
name|d_bbase
argument_list|,
name|table
operator|->
name|d_bbase
operator|*
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|le64enc
argument_list|(
operator|&
name|dlp
operator|->
name|d_pbase
argument_list|,
name|basetable
operator|->
name|gpt_first
operator|*
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|le64enc
argument_list|(
operator|&
name|dlp
operator|->
name|d_pstop
argument_list|,
name|basetable
operator|->
name|gpt_last
operator|*
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|le64enc
argument_list|(
operator|&
name|dlp
operator|->
name|d_abase
argument_list|,
name|table
operator|->
name|d_abase
operator|*
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|baseentry
argument_list|,
argument|&basetable->gpt_entry
argument_list|,
argument|gpe_entry
argument_list|)
block|{
if|if
condition|(
name|baseentry
operator|->
name|gpe_deleted
condition|)
continue|continue;
name|index
operator|=
name|baseentry
operator|->
name|gpe_index
operator|-
literal|1
expr_stmt|;
name|entry
operator|=
operator|(
expr|struct
name|g_part_bsd64_entry
operator|*
operator|)
name|baseentry
expr_stmt|;
if|if
condition|(
name|index
operator|==
name|RAW_PART
condition|)
continue|continue;
name|le64enc
argument_list|(
operator|&
name|dlp
operator|->
name|d_partitions
index|[
name|index
index|]
operator|.
name|p_boffset
argument_list|,
name|baseentry
operator|->
name|gpe_start
operator|*
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|le64enc
argument_list|(
operator|&
name|dlp
operator|->
name|d_partitions
index|[
name|index
index|]
operator|.
name|p_bsize
argument_list|,
name|pp
operator|->
name|sectorsize
operator|*
operator|(
name|baseentry
operator|->
name|gpe_end
operator|-
name|baseentry
operator|->
name|gpe_start
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|dlp
operator|->
name|d_partitions
index|[
name|index
index|]
operator|.
name|p_fstype
operator|=
name|entry
operator|->
name|fstype
expr_stmt|;
name|le_uuid_enc
argument_list|(
operator|&
name|dlp
operator|->
name|d_partitions
index|[
name|index
index|]
operator|.
name|p_type_uuid
argument_list|,
operator|&
name|entry
operator|->
name|type_uuid
argument_list|)
expr_stmt|;
name|le_uuid_enc
argument_list|(
operator|&
name|dlp
operator|->
name|d_partitions
index|[
name|index
index|]
operator|.
name|p_stor_uuid
argument_list|,
operator|&
name|entry
operator|->
name|stor_uuid
argument_list|)
expr_stmt|;
block|}
comment|/* Calculate checksum. */
name|v
operator|=
name|offsetof
argument_list|(
expr|struct
name|disklabel64
argument_list|,
name|d_partitions
index|[
name|basetable
operator|->
name|gpt_entries
index|]
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|disklabel64
argument_list|,
name|d_magic
argument_list|)
expr_stmt|;
name|le32enc
argument_list|(
operator|&
name|dlp
operator|->
name|d_crc
argument_list|,
name|crc32
argument_list|(
operator|&
name|dlp
operator|->
name|d_magic
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_write_data
argument_list|(
name|cp
argument_list|,
literal|0
argument_list|,
name|dlp
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|dlp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

