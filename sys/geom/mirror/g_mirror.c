begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004-2006 Pawel Jakub Dawidek<pjd@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<geom/mirror/g_mirror.h>
end_include

begin_expr_stmt
name|FEATURE
argument_list|(
name|geom_mirror
argument_list|,
literal|"GEOM mirroring support"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_MIRROR
argument_list|,
literal|"mirror_data"
argument_list|,
literal|"GEOM_MIRROR Data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_kern_geom
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_kern_geom
argument_list|,
name|OID_AUTO
argument_list|,
name|mirror
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"GEOM_MIRROR stuff"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_int
name|g_mirror_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_mirror
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|g_mirror_debug
argument_list|,
literal|0
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_mirror_timeout
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_mirror
argument_list|,
name|OID_AUTO
argument_list|,
name|timeout
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|g_mirror_timeout
argument_list|,
literal|0
argument_list|,
literal|"Time to wait on all mirror components"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_mirror_idletime
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_mirror
argument_list|,
name|OID_AUTO
argument_list|,
name|idletime
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|g_mirror_idletime
argument_list|,
literal|0
argument_list|,
literal|"Mark components as clean when idling"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_mirror_disconnect_on_failure
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_mirror
argument_list|,
name|OID_AUTO
argument_list|,
name|disconnect_on_failure
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|g_mirror_disconnect_on_failure
argument_list|,
literal|0
argument_list|,
literal|"Disconnect component on I/O failure."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_mirror_syncreqs
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_mirror
argument_list|,
name|OID_AUTO
argument_list|,
name|sync_requests
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|g_mirror_syncreqs
argument_list|,
literal|0
argument_list|,
literal|"Parallel synchronization I/O requests."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MSLEEP
parameter_list|(
name|ident
parameter_list|,
name|mtx
parameter_list|,
name|priority
parameter_list|,
name|wmesg
parameter_list|,
name|timeout
parameter_list|)
value|do {		\ 	G_MIRROR_DEBUG(4, "%s: Sleeping %p.", __func__, (ident));	\ 	msleep((ident), (mtx), (priority), (wmesg), (timeout));		\ 	G_MIRROR_DEBUG(4, "%s: Woken up %p.", __func__, (ident));	\ } while (0)
end_define

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|g_mirror_post_sync
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_mirror_shutdown
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_ctl_destroy_geom_t
name|g_mirror_destroy_geom
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_taste_t
name|g_mirror_taste
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_init_t
name|g_mirror_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_fini_t
name|g_mirror_fini
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_provgone_t
name|g_mirror_providergone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_resize_t
name|g_mirror_resize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|g_class
name|g_mirror_class
init|=
block|{
operator|.
name|name
operator|=
name|G_MIRROR_CLASS_NAME
block|,
operator|.
name|version
operator|=
name|G_VERSION
block|,
operator|.
name|ctlreq
operator|=
name|g_mirror_config
block|,
operator|.
name|taste
operator|=
name|g_mirror_taste
block|,
operator|.
name|destroy_geom
operator|=
name|g_mirror_destroy_geom
block|,
operator|.
name|init
operator|=
name|g_mirror_init
block|,
operator|.
name|fini
operator|=
name|g_mirror_fini
block|,
operator|.
name|providergone
operator|=
name|g_mirror_providergone
block|,
operator|.
name|resize
operator|=
name|g_mirror_resize
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|g_mirror_destroy_provider
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_mirror_update_disk
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|,
name|u_int
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_mirror_update_device
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|bool
name|force
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_mirror_dumpconf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_mirror_sync_stop
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_mirror_register_request
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_mirror_sync_release
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|g_mirror_disk_state2str
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|G_MIRROR_DISK_STATE_NONE
case|:
return|return
operator|(
literal|"NONE"
operator|)
return|;
case|case
name|G_MIRROR_DISK_STATE_NEW
case|:
return|return
operator|(
literal|"NEW"
operator|)
return|;
case|case
name|G_MIRROR_DISK_STATE_ACTIVE
case|:
return|return
operator|(
literal|"ACTIVE"
operator|)
return|;
case|case
name|G_MIRROR_DISK_STATE_STALE
case|:
return|return
operator|(
literal|"STALE"
operator|)
return|;
case|case
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
case|:
return|return
operator|(
literal|"SYNCHRONIZING"
operator|)
return|;
case|case
name|G_MIRROR_DISK_STATE_DISCONNECTED
case|:
return|return
operator|(
literal|"DISCONNECTED"
operator|)
return|;
case|case
name|G_MIRROR_DISK_STATE_DESTROY
case|:
return|return
operator|(
literal|"DESTROY"
operator|)
return|;
default|default:
return|return
operator|(
literal|"INVALID"
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|g_mirror_device_state2str
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|G_MIRROR_DEVICE_STATE_STARTING
case|:
return|return
operator|(
literal|"STARTING"
operator|)
return|;
case|case
name|G_MIRROR_DEVICE_STATE_RUNNING
case|:
return|return
operator|(
literal|"RUNNING"
operator|)
return|;
default|default:
return|return
operator|(
literal|"INVALID"
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|g_mirror_get_diskname
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_consumer
operator|==
name|NULL
operator|||
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"[unknown]"
operator|)
return|;
return|return
operator|(
name|disk
operator|->
name|d_name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * --- Events handling functions ---  * Events in geom_mirror are used to maintain disks and device status  * from one thread to simplify locking.  */
end_comment

begin_function
specifier|static
name|void
name|g_mirror_event_free
parameter_list|(
name|struct
name|g_mirror_event
modifier|*
name|ep
parameter_list|)
block|{
name|free
argument_list|(
name|ep
argument_list|,
name|M_MIRROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|g_mirror_event_send
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|state
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_mirror_event
modifier|*
name|ep
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ep
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
argument_list|,
name|M_MIRROR
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Sending event %p."
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|G_MIRROR_EVENT_DEVICE
operator|)
operator|!=
literal|0
condition|)
block|{
name|disk
operator|=
name|NULL
expr_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
block|}
else|else
block|{
name|disk
operator|=
name|arg
expr_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
block|}
name|ep
operator|->
name|e_disk
operator|=
name|disk
expr_stmt|;
name|ep
operator|->
name|e_state
operator|=
name|state
expr_stmt|;
name|ep
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|ep
operator|->
name|e_error
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_events
argument_list|,
name|ep
argument_list|,
name|e_next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Waking up %p."
argument_list|,
name|__func__
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|G_MIRROR_EVENT_DONTWAIT
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Sleeping %p."
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_MIRROR_EVENT_DONE
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|MSLEEP
argument_list|(
name|ep
argument_list|,
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|,
name|PRIBIO
operator||
name|PDROP
argument_list|,
literal|"m:event"
argument_list|,
name|hz
operator|*
literal|5
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|ep
operator|->
name|e_error
expr_stmt|;
name|g_mirror_event_free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|g_mirror_event
modifier|*
name|g_mirror_event_get
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_mirror_event
modifier|*
name|ep
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|ep
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_events
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ep
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_event_remove
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_mirror_event
modifier|*
name|ep
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_events
argument_list|,
name|ep
argument_list|,
name|e_next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_event_cancel
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_mirror_event
modifier|*
name|ep
decl_stmt|,
modifier|*
name|tmpep
decl_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ep
argument_list|,
argument|&sc->sc_events
argument_list|,
argument|e_next
argument_list|,
argument|tmpep
argument_list|)
block|{
if|if
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_MIRROR_EVENT_DEVICE
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ep
operator|->
name|e_disk
operator|!=
name|disk
condition|)
continue|continue;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_events
argument_list|,
name|ep
argument_list|,
name|e_next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_MIRROR_EVENT_DONTWAIT
operator|)
operator|!=
literal|0
condition|)
name|g_mirror_event_free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
else|else
block|{
name|ep
operator|->
name|e_error
operator|=
name|ECANCELED
expr_stmt|;
name|wakeup
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the number of disks in given state.  * If state is equal to -1, count all connected disks.  */
end_comment

begin_function
name|u_int
name|g_mirror_ndisks
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|u_int
name|n
init|=
literal|0
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|state
operator|==
operator|-
literal|1
operator|||
name|disk
operator|->
name|d_state
operator|==
name|state
condition|)
name|n
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a disk in mirror by its disk ID.  */
end_comment

begin_function
specifier|static
name|struct
name|g_mirror_disk
modifier|*
name|g_mirror_id2disk
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|id
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_id
operator|==
name|id
condition|)
return|return
operator|(
name|disk
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|g_mirror_nrequests
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|u_int
name|nreqs
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&sc->sc_queue.queue
argument_list|,
argument|bio_queue
argument_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_from
operator|==
name|cp
condition|)
name|nreqs
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|nreqs
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_mirror_is_busy
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
if|if
condition|(
name|cp
operator|->
name|index
operator|>
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"I/O requests for %s exist, can't destroy it now."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|g_mirror_nrequests
argument_list|(
name|sc
argument_list|,
name|cp
argument_list|)
operator|>
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"I/O requests for %s in queue, can't destroy it now."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_destroy_consumer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
name|__unused
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|cp
operator|=
name|arg
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Consumer %s destroyed."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_kill_consumer
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|int
name|retaste_wait
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|cp
operator|->
name|private
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|g_mirror_is_busy
argument_list|(
name|sc
argument_list|,
name|cp
argument_list|)
condition|)
return|return;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|retaste_wait
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|acw
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|pp
operator|->
name|geom
operator|->
name|flags
operator|&
name|G_GEOM_WITHER
operator|)
operator|==
literal|0
condition|)
name|retaste_wait
operator|=
literal|1
expr_stmt|;
block|}
name|G_MIRROR_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Access %s r%dw%de%d = %d"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
operator|-
name|cp
operator|->
name|acr
argument_list|,
operator|-
name|cp
operator|->
name|acw
argument_list|,
operator|-
name|cp
operator|->
name|ace
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|acr
operator|>
literal|0
operator|||
name|cp
operator|->
name|acw
operator|>
literal|0
operator|||
name|cp
operator|->
name|ace
operator|>
literal|0
condition|)
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
name|cp
operator|->
name|acr
argument_list|,
operator|-
name|cp
operator|->
name|acw
argument_list|,
operator|-
name|cp
operator|->
name|ace
argument_list|)
expr_stmt|;
if|if
condition|(
name|retaste_wait
condition|)
block|{
comment|/* 		 * After retaste event was send (inside g_access()), we can send 		 * event to detach and destroy consumer. 		 * A class, which has consumer to the given provider connected 		 * will not receive retaste event for the provider. 		 * This is the way how I ignore retaste events when I close 		 * consumers opened for write: I detach and destroy consumer 		 * after retaste event is sent. 		 */
name|g_post_event
argument_list|(
name|g_mirror_destroy_consumer
argument_list|,
name|cp
argument_list|,
name|M_WAITOK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Consumer %s destroyed."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_mirror_connect_disk
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_consumer
operator|==
name|NULL
argument_list|,
operator|(
literal|"Disk already connected (device %s)."
operator|,
name|disk
operator|->
name|d_softc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|cp
operator|=
name|g_new_consumer
argument_list|(
name|disk
operator|->
name|d_softc
operator|->
name|sc_geom
argument_list|)
expr_stmt|;
name|cp
operator|->
name|flags
operator||=
name|G_CF_DIRECT_RECEIVE
expr_stmt|;
name|error
operator|=
name|g_attach
argument_list|(
name|cp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot open consumer %s (error=%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|=
name|cp
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|->
name|private
operator|=
name|disk
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Disk %s connected."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_disconnect_consumer
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|g_topology_assert
argument_list|()
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|cp
operator|->
name|provider
operator|!=
name|NULL
condition|)
name|g_mirror_kill_consumer
argument_list|(
name|sc
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize disk. This means allocate memory, create consumer, attach it  * to the provider and open access (r1w1e1) to it.  */
end_comment

begin_function
specifier|static
name|struct
name|g_mirror_disk
modifier|*
name|g_mirror_init_disk
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|struct
name|g_mirror_metadata
modifier|*
name|md
parameter_list|,
name|int
modifier|*
name|errorp
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|disk
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|disk
argument_list|)
argument_list|,
name|M_MIRROR
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|disk
operator|->
name|d_softc
operator|=
name|sc
expr_stmt|;
name|error
operator|=
name|g_mirror_connect_disk
argument_list|(
name|disk
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|disk
operator|->
name|d_id
operator|=
name|md
operator|->
name|md_did
expr_stmt|;
name|disk
operator|->
name|d_state
operator|=
name|G_MIRROR_DISK_STATE_NONE
expr_stmt|;
name|disk
operator|->
name|d_priority
operator|=
name|md
operator|->
name|md_priority
expr_stmt|;
name|disk
operator|->
name|d_flags
operator|=
name|md
operator|->
name|md_dflags
expr_stmt|;
name|error
operator|=
name|g_getattr
argument_list|(
literal|"GEOM::candelete"
argument_list|,
name|disk
operator|->
name|d_consumer
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|i
operator|!=
literal|0
condition|)
name|disk
operator|->
name|d_flags
operator||=
name|G_MIRROR_DISK_FLAG_CANDELETE
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|md_provider
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|disk
operator|->
name|d_flags
operator||=
name|G_MIRROR_DISK_FLAG_HARDCODED
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|=
name|NULL
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset
operator|=
name|md
operator|->
name|md_sync_offset
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset_done
operator|=
name|md
operator|->
name|md_sync_offset
expr_stmt|;
name|disk
operator|->
name|d_genid
operator|=
name|md
operator|->
name|md_genid
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|=
name|md
operator|->
name|md_syncid
expr_stmt|;
if|if
condition|(
name|errorp
operator|!=
name|NULL
condition|)
operator|*
name|errorp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|disk
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|errorp
operator|!=
name|NULL
condition|)
operator|*
name|errorp
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|disk
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|disk
argument_list|,
name|M_MIRROR
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_destroy_disk
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|disk
argument_list|,
name|d_next
argument_list|)
expr_stmt|;
name|g_mirror_event_cancel
argument_list|(
name|disk
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hint
operator|==
name|disk
condition|)
name|sc
operator|->
name|sc_hint
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|disk
operator|->
name|d_state
condition|)
block|{
case|case
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
case|:
name|g_mirror_sync_stop
argument_list|(
name|disk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|G_MIRROR_DISK_STATE_NEW
case|:
case|case
name|G_MIRROR_DISK_STATE_STALE
case|:
case|case
name|G_MIRROR_DISK_STATE_ACTIVE
case|:
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_mirror_disconnect_consumer
argument_list|(
name|sc
argument_list|,
name|disk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|disk
argument_list|,
name|M_MIRROR
argument_list|)
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
literal|0
operator|==
literal|1
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_free_device
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_done_mtx
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_MIRROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_providergone
parameter_list|(
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
init|=
name|pp
operator|->
name|private
decl_stmt|;
if|if
condition|(
operator|(
operator|--
name|sc
operator|->
name|sc_refcnt
operator|)
operator|==
literal|0
condition|)
name|g_mirror_free_device
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_destroy_device
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_mirror_event
modifier|*
name|ep
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|,
modifier|*
name|tmpcp
decl_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|gp
operator|=
name|sc
operator|->
name|sc_geom
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_provider
operator|!=
name|NULL
condition|)
name|g_mirror_destroy_provider
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|disk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_disks
argument_list|)
init|;
name|disk
operator|!=
name|NULL
condition|;
name|disk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_disks
argument_list|)
control|)
block|{
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_MIRROR_DISK_FLAG_DIRTY
expr_stmt|;
name|g_mirror_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|g_mirror_destroy_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ep
operator|=
name|g_mirror_event_get
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|g_mirror_event_remove
argument_list|(
name|sc
argument_list|,
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_MIRROR_EVENT_DONTWAIT
operator|)
operator|!=
literal|0
condition|)
name|g_mirror_event_free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
else|else
block|{
name|ep
operator|->
name|e_error
operator|=
name|ECANCELED
expr_stmt|;
name|ep
operator|->
name|e_flags
operator||=
name|G_MIRROR_EVENT_DONE
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Waking up %p."
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
block|}
block|}
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|cp
argument_list|,
argument|&sc->sc_sync.ds_geom->consumer
argument_list|,
argument|consumer
argument_list|,
argument|tmpcp
argument_list|)
block|{
name|g_mirror_disconnect_consumer
argument_list|(
name|sc
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
name|g_wither_geom
argument_list|(
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s destroyed."
argument_list|,
name|gp
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_wither_geom
argument_list|(
name|gp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|--
name|sc
operator|->
name|sc_refcnt
operator|)
operator|==
literal|0
condition|)
name|g_mirror_free_device
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_orphan
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|disk
operator|=
name|cp
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
return|return;
name|disk
operator|->
name|d_softc
operator|->
name|sc_bump_id
operator||=
name|G_MIRROR_BUMP_SYNCID
expr_stmt|;
name|g_mirror_event_send
argument_list|(
name|disk
argument_list|,
name|G_MIRROR_DISK_STATE_DISCONNECTED
argument_list|,
name|G_MIRROR_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function should return the next active disk on the list.  * It is possible that it will be the same disk as given.  * If there are no active disks on list, NULL is returned.  */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|g_mirror_disk
operator|*
name|g_mirror_find_next
argument_list|(
argument|struct g_mirror_softc *sc
argument_list|,
argument|struct g_mirror_disk *disk
argument_list|)
block|{ 	struct
name|g_mirror_disk
operator|*
name|dp
block|;
for|for
control|(
name|dp
operator|=
name|LIST_NEXT
argument_list|(
name|disk
argument_list|,
name|d_next
argument_list|)
init|;
name|dp
operator|!=
name|disk
condition|;
name|dp
operator|=
name|LIST_NEXT
argument_list|(
name|dp
argument_list|,
name|d_next
argument_list|)
control|)
block|{
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
name|dp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_disks
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_ACTIVE
condition|)
break|break;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|dp
operator|->
name|d_state
operator|!=
name|G_MIRROR_DISK_STATE_ACTIVE
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
end_if

begin_return
return|return
operator|(
name|dp
operator|)
return|;
end_return

begin_function
unit|}  static
name|struct
name|g_mirror_disk
modifier|*
name|g_mirror_get_disk
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hint
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_hint
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_disks
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hint
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|disk
operator|=
name|sc
operator|->
name|sc_hint
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_MIRROR_DISK_STATE_ACTIVE
condition|)
block|{
name|disk
operator|=
name|g_mirror_find_next
argument_list|(
name|sc
argument_list|,
name|disk
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sc
operator|->
name|sc_hint
operator|=
name|g_mirror_find_next
argument_list|(
name|sc
argument_list|,
name|disk
argument_list|)
expr_stmt|;
return|return
operator|(
name|disk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_mirror_write_metadata
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|,
name|struct
name|g_mirror_metadata
modifier|*
name|md
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|off_t
name|offset
decl_stmt|,
name|length
decl_stmt|;
name|u_char
modifier|*
name|sector
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL consumer (%s)."
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|->
name|provider
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL provider (%s)."
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|->
name|acr
operator|>=
literal|1
operator|&&
name|cp
operator|->
name|acw
operator|>=
literal|1
operator|&&
name|cp
operator|->
name|ace
operator|>=
literal|1
argument_list|,
operator|(
literal|"Consumer %s closed? (r%dw%de%d)."
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|,
name|cp
operator|->
name|acr
operator|,
name|cp
operator|->
name|acw
operator|,
name|cp
operator|->
name|ace
operator|)
argument_list|)
expr_stmt|;
name|length
operator|=
name|cp
operator|->
name|provider
operator|->
name|sectorsize
expr_stmt|;
name|offset
operator|=
name|cp
operator|->
name|provider
operator|->
name|mediasize
operator|-
name|length
expr_stmt|;
name|sector
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|length
argument_list|,
name|M_MIRROR
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|!=
name|NULL
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_WIPE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Handle the case, when the size of parent provider reduced. 		 */
if|if
condition|(
name|offset
operator|<
name|md
operator|->
name|md_mediasize
condition|)
name|error
operator|=
name|ENOSPC
expr_stmt|;
else|else
name|mirror_metadata_encode
argument_list|(
name|md
argument_list|,
name|sector
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|g_write_data
argument_list|(
name|cp
argument_list|,
name|offset
argument_list|,
name|sector
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sector
argument_list|,
name|M_MIRROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_BROKEN
operator|)
operator|==
literal|0
condition|)
block|{
name|disk
operator|->
name|d_flags
operator||=
name|G_MIRROR_DISK_FLAG_BROKEN
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot write metadata on %s "
literal|"(device=%s, error=%d)."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Cannot write metadata on %s "
literal|"(device=%s, error=%d)."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|g_mirror_disconnect_on_failure
operator|&&
name|g_mirror_ndisks
argument_list|(
name|sc
argument_list|,
name|G_MIRROR_DISK_STATE_ACTIVE
argument_list|)
operator|>
literal|1
condition|)
block|{
name|sc
operator|->
name|sc_bump_id
operator||=
name|G_MIRROR_BUMP_GENID
expr_stmt|;
name|g_mirror_event_send
argument_list|(
name|disk
argument_list|,
name|G_MIRROR_DISK_STATE_DISCONNECTED
argument_list|,
name|G_MIRROR_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_mirror_clear_metadata
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|disk
operator|->
name|d_softc
operator|->
name|sc_lock
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_softc
operator|->
name|sc_type
operator|!=
name|G_MIRROR_TYPE_AUTOMATIC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|g_mirror_write_metadata
argument_list|(
name|disk
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Metadata on %s cleared."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot clear metadata on disk %s (error=%d)."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|g_mirror_fill_metadata
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|,
name|struct
name|g_mirror_metadata
modifier|*
name|md
parameter_list|)
block|{
name|strlcpy
argument_list|(
name|md
operator|->
name|md_magic
argument_list|,
name|G_MIRROR_MAGIC
argument_list|,
sizeof|sizeof
argument_list|(
name|md
operator|->
name|md_magic
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|->
name|md_version
operator|=
name|G_MIRROR_VERSION
expr_stmt|;
name|strlcpy
argument_list|(
name|md
operator|->
name|md_name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
sizeof|sizeof
argument_list|(
name|md
operator|->
name|md_name
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|->
name|md_mid
operator|=
name|sc
operator|->
name|sc_id
expr_stmt|;
name|md
operator|->
name|md_all
operator|=
name|sc
operator|->
name|sc_ndisks
expr_stmt|;
name|md
operator|->
name|md_slice
operator|=
name|sc
operator|->
name|sc_slice
expr_stmt|;
name|md
operator|->
name|md_balance
operator|=
name|sc
operator|->
name|sc_balance
expr_stmt|;
name|md
operator|->
name|md_genid
operator|=
name|sc
operator|->
name|sc_genid
expr_stmt|;
name|md
operator|->
name|md_mediasize
operator|=
name|sc
operator|->
name|sc_mediasize
expr_stmt|;
name|md
operator|->
name|md_sectorsize
operator|=
name|sc
operator|->
name|sc_sectorsize
expr_stmt|;
name|md
operator|->
name|md_mflags
operator|=
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_MASK
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|md
operator|->
name|md_provider
argument_list|,
sizeof|sizeof
argument_list|(
name|md
operator|->
name|md_provider
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
block|{
name|md
operator|->
name|md_did
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|md
operator|->
name|md_priority
operator|=
literal|0
expr_stmt|;
name|md
operator|->
name|md_syncid
operator|=
literal|0
expr_stmt|;
name|md
operator|->
name|md_dflags
operator|=
literal|0
expr_stmt|;
name|md
operator|->
name|md_sync_offset
operator|=
literal|0
expr_stmt|;
name|md
operator|->
name|md_provsize
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|md
operator|->
name|md_did
operator|=
name|disk
operator|->
name|d_id
expr_stmt|;
name|md
operator|->
name|md_priority
operator|=
name|disk
operator|->
name|d_priority
expr_stmt|;
name|md
operator|->
name|md_syncid
operator|=
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
expr_stmt|;
name|md
operator|->
name|md_dflags
operator|=
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
condition|)
name|md
operator|->
name|md_sync_offset
operator|=
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset_done
expr_stmt|;
else|else
name|md
operator|->
name|md_sync_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_HARDCODED
operator|)
operator|!=
literal|0
condition|)
block|{
name|strlcpy
argument_list|(
name|md
operator|->
name|md_provider
argument_list|,
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|md
operator|->
name|md_provider
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|md
operator|->
name|md_provsize
operator|=
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|->
name|mediasize
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|g_mirror_update_metadata
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_mirror_metadata
name|md
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_type
operator|!=
name|G_MIRROR_TYPE_AUTOMATIC
condition|)
return|return;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_WIPE
operator|)
operator|==
literal|0
condition|)
name|g_mirror_fill_metadata
argument_list|(
name|sc
argument_list|,
name|disk
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_mirror_write_metadata
argument_list|(
name|disk
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Metadata on %s updated."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot update metadata on disk %s (error=%d)."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_bump_syncid
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|g_mirror_ndisks
argument_list|(
name|sc
argument_list|,
name|G_MIRROR_DISK_STATE_ACTIVE
argument_list|)
operator|>
literal|0
argument_list|,
operator|(
literal|"%s called with no active disks (device=%s)."
operator|,
name|__func__
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_syncid
operator|++
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Device %s: syncid bumped to %u."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|sc
operator|->
name|sc_syncid
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_ACTIVE
operator|||
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
condition|)
block|{
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|=
name|sc
operator|->
name|sc_syncid
expr_stmt|;
name|g_mirror_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_bump_genid
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|g_mirror_ndisks
argument_list|(
name|sc
argument_list|,
name|G_MIRROR_DISK_STATE_ACTIVE
argument_list|)
operator|>
literal|0
argument_list|,
operator|(
literal|"%s called with no active disks (device=%s)."
operator|,
name|__func__
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_genid
operator|++
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Device %s: genid bumped to %u."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|sc
operator|->
name|sc_genid
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_ACTIVE
operator|||
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
condition|)
block|{
name|disk
operator|->
name|d_genid
operator|=
name|sc
operator|->
name|sc_genid
expr_stmt|;
name|g_mirror_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|g_mirror_idle
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|int
name|acw
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_provider
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_NOFAILSYNC
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_idle
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_writes
operator|>
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|acw
operator|>
literal|0
operator|||
operator|(
name|acw
operator|==
operator|-
literal|1
operator|&&
name|sc
operator|->
name|sc_provider
operator|->
name|acw
operator|>
literal|0
operator|)
condition|)
block|{
name|timeout
operator|=
name|g_mirror_idletime
operator|-
operator|(
name|time_uptime
operator|-
name|sc
operator|->
name|sc_last_write
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_mirror_shutdown
operator|&&
name|timeout
operator|>
literal|0
condition|)
return|return
operator|(
name|timeout
operator|)
return|;
block|}
name|sc
operator|->
name|sc_idle
operator|=
literal|1
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_MIRROR_DISK_STATE_ACTIVE
condition|)
continue|continue;
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Disk %s (device %s) marked as clean."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_MIRROR_DISK_FLAG_DIRTY
expr_stmt|;
name|g_mirror_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_unidle
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_NOFAILSYNC
operator|)
operator|!=
literal|0
condition|)
return|return;
name|sc
operator|->
name|sc_idle
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_last_write
operator|=
name|time_uptime
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_MIRROR_DISK_STATE_ACTIVE
condition|)
continue|continue;
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Disk %s (device %s) marked as dirty."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_flags
operator||=
name|G_MIRROR_DISK_FLAG_DIRTY
expr_stmt|;
name|g_mirror_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_flush_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bio
modifier|*
name|pbp
decl_stmt|;
name|pbp
operator|=
name|bp
operator|->
name|bio_parent
expr_stmt|;
name|sc
operator|=
name|pbp
operator|->
name|bio_to
operator|->
name|private
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_done_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|pbp
operator|->
name|bio_error
operator|=
name|bp
operator|->
name|bio_error
expr_stmt|;
name|pbp
operator|->
name|bio_completed
operator|+=
name|bp
operator|->
name|bio_completed
expr_stmt|;
name|pbp
operator|->
name|bio_inbed
operator|++
expr_stmt|;
if|if
condition|(
name|pbp
operator|->
name|bio_children
operator|==
name|pbp
operator|->
name|bio_inbed
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_done_mtx
argument_list|)
expr_stmt|;
name|g_io_deliver
argument_list|(
name|pbp
argument_list|,
name|pbp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_done_mtx
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_from
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|bp
operator|->
name|bio_cflags
operator|=
name|G_MIRROR_BIO_FLAG_REGULAR
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_regular_request
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|bio
modifier|*
name|pbp
decl_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|pbp
operator|=
name|bp
operator|->
name|bio_parent
expr_stmt|;
name|sc
operator|=
name|pbp
operator|->
name|bio_to
operator|->
name|private
expr_stmt|;
name|bp
operator|->
name|bio_from
operator|->
name|index
operator|--
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
condition|)
name|sc
operator|->
name|sc_writes
operator|--
expr_stmt|;
name|disk
operator|=
name|bp
operator|->
name|bio_from
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
block|{
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_mirror_kill_consumer
argument_list|(
name|sc
argument_list|,
name|bp
operator|->
name|bio_from
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
block|}
name|pbp
operator|->
name|bio_inbed
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
name|pbp
operator|->
name|bio_inbed
operator|<=
name|pbp
operator|->
name|bio_children
argument_list|,
operator|(
literal|"bio_inbed (%u) is bigger than bio_children (%u)."
operator|,
name|pbp
operator|->
name|bio_inbed
operator|,
name|pbp
operator|->
name|bio_children
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
operator|&&
name|pbp
operator|->
name|bio_error
operator|==
literal|0
condition|)
block|{
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Request delivered."
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbp
operator|->
name|bio_children
operator|==
name|pbp
operator|->
name|bio_inbed
condition|)
block|{
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|pbp
argument_list|,
literal|"Request delivered."
argument_list|)
expr_stmt|;
name|pbp
operator|->
name|bio_completed
operator|=
name|pbp
operator|->
name|bio_length
expr_stmt|;
if|if
condition|(
name|pbp
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
operator|||
name|pbp
operator|->
name|bio_cmd
operator|==
name|BIO_DELETE
condition|)
block|{
name|bioq_remove
argument_list|(
operator|&
name|sc
operator|->
name|sc_inflight
argument_list|,
name|pbp
argument_list|)
expr_stmt|;
comment|/* Release delayed sync requests if possible. */
name|g_mirror_sync_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|g_io_deliver
argument_list|(
name|pbp
argument_list|,
name|pbp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pbp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|pbp
operator|->
name|bio_error
operator|=
name|bp
operator|->
name|bio_error
expr_stmt|;
if|if
condition|(
name|disk
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_BROKEN
operator|)
operator|==
literal|0
condition|)
block|{
name|disk
operator|->
name|d_flags
operator||=
name|G_MIRROR_DISK_FLAG_BROKEN
expr_stmt|;
name|G_MIRROR_LOGREQ
argument_list|(
literal|0
argument_list|,
name|bp
argument_list|,
literal|"Request failed (error=%d)."
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|G_MIRROR_LOGREQ
argument_list|(
literal|1
argument_list|,
name|bp
argument_list|,
literal|"Request failed (error=%d)."
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|g_mirror_disconnect_on_failure
operator|&&
name|g_mirror_ndisks
argument_list|(
name|sc
argument_list|,
name|G_MIRROR_DISK_STATE_ACTIVE
argument_list|)
operator|>
literal|1
condition|)
block|{
name|sc
operator|->
name|sc_bump_id
operator||=
name|G_MIRROR_BUMP_GENID
expr_stmt|;
name|g_mirror_event_send
argument_list|(
name|disk
argument_list|,
name|G_MIRROR_DISK_STATE_DISCONNECTED
argument_list|,
name|G_MIRROR_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|pbp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_DELETE
case|:
case|case
name|BIO_WRITE
case|:
name|pbp
operator|->
name|bio_inbed
operator|--
expr_stmt|;
name|pbp
operator|->
name|bio_children
operator|--
expr_stmt|;
break|break;
block|}
block|}
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pbp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
if|if
condition|(
name|pbp
operator|->
name|bio_inbed
operator|<
name|pbp
operator|->
name|bio_children
condition|)
break|break;
if|if
condition|(
name|g_mirror_ndisks
argument_list|(
name|sc
argument_list|,
name|G_MIRROR_DISK_STATE_ACTIVE
argument_list|)
operator|==
literal|1
condition|)
name|g_io_deliver
argument_list|(
name|pbp
argument_list|,
name|pbp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
else|else
block|{
name|pbp
operator|->
name|bio_error
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|pbp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Waking up %p."
argument_list|,
name|__func__
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BIO_DELETE
case|:
case|case
name|BIO_WRITE
case|:
if|if
condition|(
name|pbp
operator|->
name|bio_children
operator|==
literal|0
condition|)
block|{
comment|/* 			 * All requests failed. 			 */
block|}
elseif|else
if|if
condition|(
name|pbp
operator|->
name|bio_inbed
operator|<
name|pbp
operator|->
name|bio_children
condition|)
block|{
comment|/* Do nothing. */
break|break;
block|}
elseif|else
if|if
condition|(
name|pbp
operator|->
name|bio_children
operator|==
name|pbp
operator|->
name|bio_inbed
condition|)
block|{
comment|/* Some requests succeeded. */
name|pbp
operator|->
name|bio_error
operator|=
literal|0
expr_stmt|;
name|pbp
operator|->
name|bio_completed
operator|=
name|pbp
operator|->
name|bio_length
expr_stmt|;
block|}
name|bioq_remove
argument_list|(
operator|&
name|sc
operator|->
name|sc_inflight
argument_list|,
name|pbp
argument_list|)
expr_stmt|;
comment|/* Release delayed sync requests if possible. */
name|g_mirror_sync_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|g_io_deliver
argument_list|(
name|pbp
argument_list|,
name|pbp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
literal|1
operator|==
literal|0
argument_list|,
operator|(
literal|"Invalid request: %u."
operator|,
name|pbp
operator|->
name|bio_cmd
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_sync_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Synchronization request delivered."
argument_list|)
expr_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_from
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|bp
operator|->
name|bio_cflags
operator|=
name|G_MIRROR_BIO_FLAG_SYNC
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_candelete
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|int
modifier|*
name|val
decl_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|private
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_CANDELETE
condition|)
break|break;
block|}
name|val
operator|=
operator|(
name|int
operator|*
operator|)
name|bp
operator|->
name|bio_data
expr_stmt|;
operator|*
name|val
operator|=
operator|(
name|disk
operator|!=
name|NULL
operator|)
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_kernel_dump
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|bio
modifier|*
name|cbp
decl_stmt|;
name|struct
name|g_kerneldump
modifier|*
name|gkd
decl_stmt|;
comment|/* 	 * We configure dumping to the first component, because this component 	 * will be used for reading with 'prefer' balance algorithm. 	 * If the component with the highest priority is currently disconnected 	 * we will not be able to read the dump after the reboot if it will be 	 * connected and synchronized later. Can we do something better? 	 */
name|sc
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|private
expr_stmt|;
name|disk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_disks
argument_list|)
expr_stmt|;
name|gkd
operator|=
operator|(
expr|struct
name|g_kerneldump
operator|*
operator|)
name|bp
operator|->
name|bio_data
expr_stmt|;
if|if
condition|(
name|gkd
operator|->
name|length
operator|>
name|bp
operator|->
name|bio_to
operator|->
name|mediasize
condition|)
name|gkd
operator|->
name|length
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|mediasize
expr_stmt|;
name|cbp
operator|=
name|g_clone_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|==
name|NULL
condition|)
block|{
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return;
block|}
name|cbp
operator|->
name|bio_done
operator|=
name|g_std_done
expr_stmt|;
name|g_io_request
argument_list|(
name|cbp
argument_list|,
name|disk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Kernel dump will go to %s."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_flush
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|bio_queue_head
name|queue
decl_stmt|;
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|bio
modifier|*
name|cbp
decl_stmt|;
name|bioq_init
argument_list|(
operator|&
name|queue
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_MIRROR_DISK_STATE_ACTIVE
condition|)
continue|continue;
name|cbp
operator|=
name|g_clone_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|==
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|cbp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|g_destroy_bio
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|ENOMEM
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
return|return;
block|}
name|bioq_insert_tail
argument_list|(
operator|&
name|queue
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|bio_done
operator|=
name|g_mirror_flush_done
expr_stmt|;
name|cbp
operator|->
name|bio_caller1
operator|=
name|disk
expr_stmt|;
name|cbp
operator|->
name|bio_to
operator|=
name|disk
operator|->
name|d_consumer
operator|->
name|provider
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|cbp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|cbp
argument_list|,
literal|"Sending request."
argument_list|)
expr_stmt|;
name|disk
operator|=
name|cbp
operator|->
name|bio_caller1
expr_stmt|;
name|cbp
operator|->
name|bio_caller1
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|->
name|acr
operator|>=
literal|1
operator|&&
name|cp
operator|->
name|acw
operator|>=
literal|1
operator|&&
name|cp
operator|->
name|ace
operator|>=
literal|1
argument_list|,
operator|(
literal|"Consumer %s not opened (r%dw%de%d)."
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|,
name|cp
operator|->
name|acr
operator|,
name|cp
operator|->
name|acw
operator|,
name|cp
operator|->
name|ace
operator|)
argument_list|)
expr_stmt|;
name|g_io_request
argument_list|(
name|cbp
argument_list|,
name|disk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_start
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|private
expr_stmt|;
comment|/* 	 * If sc == NULL or there are no valid disks, provider's error 	 * should be set and g_mirror_start() should not be called at all. 	 */
name|KASSERT
argument_list|(
name|sc
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|sc_state
operator|==
name|G_MIRROR_DEVICE_STATE_RUNNING
argument_list|,
operator|(
literal|"Provider's error should be set (error=%d)(mirror=%s)."
operator|,
name|bp
operator|->
name|bio_to
operator|->
name|error
operator|,
name|bp
operator|->
name|bio_to
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Request received."
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
case|case
name|BIO_WRITE
case|:
case|case
name|BIO_DELETE
case|:
break|break;
case|case
name|BIO_FLUSH
case|:
name|g_mirror_flush
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return;
case|case
name|BIO_GETATTR
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|bp
operator|->
name|bio_attribute
argument_list|,
literal|"GEOM::candelete"
argument_list|)
condition|)
block|{
name|g_mirror_candelete
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"GEOM::kerneldump"
argument_list|,
name|bp
operator|->
name|bio_attribute
argument_list|)
operator|==
literal|0
condition|)
block|{
name|g_mirror_kernel_dump
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* FALLTHROUGH */
default|default:
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
return|return;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Waking up %p."
argument_list|,
name|__func__
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return TRUE if the given request is colliding with a in-progress  * synchronization request.  */
end_comment

begin_function
specifier|static
name|int
name|g_mirror_sync_collision
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|bio
modifier|*
name|sbp
decl_stmt|;
name|off_t
name|rstart
decl_stmt|,
name|rend
decl_stmt|,
name|sstart
decl_stmt|,
name|send
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_sync
operator|.
name|ds_ndisks
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|rstart
operator|=
name|bp
operator|->
name|bio_offset
expr_stmt|;
name|rend
operator|=
name|bp
operator|->
name|bio_offset
operator|+
name|bp
operator|->
name|bio_length
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g_mirror_syncreqs
condition|;
name|i
operator|++
control|)
block|{
name|sbp
operator|=
name|disk
operator|->
name|d_sync
operator|.
name|ds_bios
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sbp
operator|==
name|NULL
condition|)
continue|continue;
name|sstart
operator|=
name|sbp
operator|->
name|bio_offset
expr_stmt|;
name|send
operator|=
name|sbp
operator|->
name|bio_offset
operator|+
name|sbp
operator|->
name|bio_length
expr_stmt|;
if|if
condition|(
name|rend
operator|>
name|sstart
operator|&&
name|rstart
operator|<
name|send
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return TRUE if the given sync request is colliding with a in-progress regular  * request.  */
end_comment

begin_function
specifier|static
name|int
name|g_mirror_regular_collision
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|sbp
parameter_list|)
block|{
name|off_t
name|rstart
decl_stmt|,
name|rend
decl_stmt|,
name|sstart
decl_stmt|,
name|send
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_sync
operator|.
name|ds_ndisks
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sstart
operator|=
name|sbp
operator|->
name|bio_offset
expr_stmt|;
name|send
operator|=
name|sbp
operator|->
name|bio_offset
operator|+
name|sbp
operator|->
name|bio_length
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&sc->sc_inflight.queue
argument_list|,
argument|bio_queue
argument_list|)
block|{
name|rstart
operator|=
name|bp
operator|->
name|bio_offset
expr_stmt|;
name|rend
operator|=
name|bp
operator|->
name|bio_offset
operator|+
name|bp
operator|->
name|bio_length
expr_stmt|;
if|if
condition|(
name|rend
operator|>
name|sstart
operator|&&
name|rstart
operator|<
name|send
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Puts request onto delayed queue.  */
end_comment

begin_function
specifier|static
name|void
name|g_mirror_regular_delay
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|G_MIRROR_LOGREQ
argument_list|(
literal|2
argument_list|,
name|bp
argument_list|,
literal|"Delaying request."
argument_list|)
expr_stmt|;
name|bioq_insert_head
argument_list|(
operator|&
name|sc
operator|->
name|sc_regular_delayed
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Puts synchronization request onto delayed queue.  */
end_comment

begin_function
specifier|static
name|void
name|g_mirror_sync_delay
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|G_MIRROR_LOGREQ
argument_list|(
literal|2
argument_list|,
name|bp
argument_list|,
literal|"Delaying synchronization request."
argument_list|)
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|sc
operator|->
name|sc_sync_delayed
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Releases delayed regular requests which don't collide anymore with sync  * requests.  */
end_comment

begin_function
specifier|static
name|void
name|g_mirror_regular_release
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|,
modifier|*
name|bp2
decl_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|bp
argument_list|,
argument|&sc->sc_regular_delayed.queue
argument_list|,
argument|bio_queue
argument_list|,
argument|bp2
argument_list|)
block|{
if|if
condition|(
name|g_mirror_sync_collision
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
condition|)
continue|continue;
name|bioq_remove
argument_list|(
operator|&
name|sc
operator|->
name|sc_regular_delayed
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|G_MIRROR_LOGREQ
argument_list|(
literal|2
argument_list|,
name|bp
argument_list|,
literal|"Releasing delayed request (%p)."
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|bioq_insert_head
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 		 * wakeup() is not needed, because this function is called from 		 * the worker thread. 		 */
block|wakeup(&sc->sc_queue);
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Releases delayed sync requests which don't collide anymore with regular  * requests.  */
end_comment

begin_function
specifier|static
name|void
name|g_mirror_sync_release
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|,
modifier|*
name|bp2
decl_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|bp
argument_list|,
argument|&sc->sc_sync_delayed.queue
argument_list|,
argument|bio_queue
argument_list|,
argument|bp2
argument_list|)
block|{
if|if
condition|(
name|g_mirror_regular_collision
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
condition|)
continue|continue;
name|bioq_remove
argument_list|(
operator|&
name|sc
operator|->
name|sc_sync_delayed
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|G_MIRROR_LOGREQ
argument_list|(
literal|2
argument_list|,
name|bp
argument_list|,
literal|"Releasing delayed synchronization request."
argument_list|)
expr_stmt|;
name|g_io_request
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_from
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle synchronization requests.  * Every synchronization request is two-steps process: first, READ request is  * send to active provider and then WRITE request (with read data) to the provider  * being synchronized. When WRITE is finished, new synchronization request is  * send.  */
end_comment

begin_function
specifier|static
name|void
name|g_mirror_sync_request
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|bp
operator|->
name|bio_from
operator|->
name|index
operator|--
expr_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_from
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|disk
operator|=
name|bp
operator|->
name|bio_from
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
comment|/* Avoid recursion on sc_lock. */
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_mirror_kill_consumer
argument_list|(
name|sc
argument_list|,
name|bp
operator|->
name|bio_from
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|bp
operator|->
name|bio_data
argument_list|,
name|M_MIRROR
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Synchronization request. 	 */
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|!=
literal|0
condition|)
block|{
name|G_MIRROR_LOGREQ
argument_list|(
literal|0
argument_list|,
name|bp
argument_list|,
literal|"Synchronization request failed (error=%d)."
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Synchronization request half-finished."
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_cmd
operator|=
name|BIO_WRITE
expr_stmt|;
name|bp
operator|->
name|bio_cflags
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|->
name|acr
operator|>=
literal|1
operator|&&
name|cp
operator|->
name|acw
operator|>=
literal|1
operator|&&
name|cp
operator|->
name|ace
operator|>=
literal|1
argument_list|,
operator|(
literal|"Consumer %s not opened (r%dw%de%d)."
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|,
name|cp
operator|->
name|acr
operator|,
name|cp
operator|->
name|acw
operator|,
name|cp
operator|->
name|ace
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|index
operator|++
expr_stmt|;
name|g_io_request
argument_list|(
name|bp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|BIO_WRITE
case|:
block|{
name|struct
name|g_mirror_disk_sync
modifier|*
name|sync
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|!=
literal|0
condition|)
block|{
name|G_MIRROR_LOGREQ
argument_list|(
literal|0
argument_list|,
name|bp
argument_list|,
literal|"Synchronization request failed (error=%d)."
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bump_id
operator||=
name|G_MIRROR_BUMP_GENID
expr_stmt|;
name|g_mirror_event_send
argument_list|(
name|disk
argument_list|,
name|G_MIRROR_DISK_STATE_DISCONNECTED
argument_list|,
name|G_MIRROR_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
return|return;
block|}
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Synchronization request finished."
argument_list|)
expr_stmt|;
name|sync
operator|=
operator|&
name|disk
operator|->
name|d_sync
expr_stmt|;
if|if
condition|(
name|sync
operator|->
name|ds_offset
operator|>=
name|sc
operator|->
name|sc_mediasize
operator|||
name|sync
operator|->
name|ds_consumer
operator|==
name|NULL
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_DESTROY
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Don't send more synchronization requests. */
name|sync
operator|->
name|ds_inflight
operator|--
expr_stmt|;
if|if
condition|(
name|sync
operator|->
name|ds_bios
operator|!=
name|NULL
condition|)
block|{
name|i
operator|=
operator|(
name|int
operator|)
operator|(
name|uintptr_t
operator|)
name|bp
operator|->
name|bio_caller1
expr_stmt|;
name|sync
operator|->
name|ds_bios
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|bp
operator|->
name|bio_data
argument_list|,
name|M_MIRROR
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sync
operator|->
name|ds_inflight
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|sync
operator|->
name|ds_consumer
operator|==
name|NULL
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_DESTROY
operator|)
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
comment|/* Disk up-to-date, activate it. */
name|g_mirror_event_send
argument_list|(
name|disk
argument_list|,
name|G_MIRROR_DISK_STATE_ACTIVE
argument_list|,
name|G_MIRROR_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Send next synchronization request. */
name|data
operator|=
name|bp
operator|->
name|bio_data
expr_stmt|;
name|g_reset_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_cmd
operator|=
name|BIO_READ
expr_stmt|;
name|bp
operator|->
name|bio_offset
operator|=
name|sync
operator|->
name|ds_offset
expr_stmt|;
name|bp
operator|->
name|bio_length
operator|=
name|MIN
argument_list|(
name|MAXPHYS
argument_list|,
name|sc
operator|->
name|sc_mediasize
operator|-
name|bp
operator|->
name|bio_offset
argument_list|)
expr_stmt|;
name|sync
operator|->
name|ds_offset
operator|+=
name|bp
operator|->
name|bio_length
expr_stmt|;
name|bp
operator|->
name|bio_done
operator|=
name|g_mirror_sync_done
expr_stmt|;
name|bp
operator|->
name|bio_data
operator|=
name|data
expr_stmt|;
name|bp
operator|->
name|bio_from
operator|=
name|sync
operator|->
name|ds_consumer
expr_stmt|;
name|bp
operator|->
name|bio_to
operator|=
name|sc
operator|->
name|sc_provider
expr_stmt|;
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Sending synchronization request."
argument_list|)
expr_stmt|;
name|sync
operator|->
name|ds_consumer
operator|->
name|index
operator|++
expr_stmt|;
comment|/* 		 * Delay the request if it is colliding with a regular request. 		 */
if|if
condition|(
name|g_mirror_regular_collision
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
condition|)
name|g_mirror_sync_delay
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
else|else
name|g_io_request
argument_list|(
name|bp
argument_list|,
name|sync
operator|->
name|ds_consumer
argument_list|)
expr_stmt|;
comment|/* Release delayed requests if possible. */
name|g_mirror_regular_release
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Find the smallest offset */
name|offset
operator|=
name|sc
operator|->
name|sc_mediasize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g_mirror_syncreqs
condition|;
name|i
operator|++
control|)
block|{
name|bp
operator|=
name|sync
operator|->
name|ds_bios
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_offset
operator|<
name|offset
condition|)
name|offset
operator|=
name|bp
operator|->
name|bio_offset
expr_stmt|;
block|}
if|if
condition|(
name|sync
operator|->
name|ds_offset_done
operator|+
operator|(
name|MAXPHYS
operator|*
literal|100
operator|)
operator|<
name|offset
condition|)
block|{
comment|/* Update offset_done on every 100 blocks. */
name|sync
operator|->
name|ds_offset_done
operator|=
name|offset
expr_stmt|;
name|g_mirror_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
default|default:
name|KASSERT
argument_list|(
literal|1
operator|==
literal|0
argument_list|,
operator|(
literal|"Invalid command here: %u (device=%s)"
operator|,
name|bp
operator|->
name|bio_cmd
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_request_prefer
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|bio
modifier|*
name|cbp
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_ACTIVE
condition|)
break|break;
block|}
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|ENXIO
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
return|return;
block|}
name|cbp
operator|=
name|g_clone_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|ENOMEM
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Fill in the component buf structure. 	 */
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|cbp
operator|->
name|bio_done
operator|=
name|g_mirror_done
expr_stmt|;
name|cbp
operator|->
name|bio_to
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|cbp
argument_list|,
literal|"Sending request."
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|->
name|acr
operator|>=
literal|1
operator|&&
name|cp
operator|->
name|acw
operator|>=
literal|1
operator|&&
name|cp
operator|->
name|ace
operator|>=
literal|1
argument_list|,
operator|(
literal|"Consumer %s not opened (r%dw%de%d)."
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|,
name|cp
operator|->
name|acr
operator|,
name|cp
operator|->
name|acw
operator|,
name|cp
operator|->
name|ace
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|index
operator|++
expr_stmt|;
name|g_io_request
argument_list|(
name|cbp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_request_round_robin
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|bio
modifier|*
name|cbp
decl_stmt|;
name|disk
operator|=
name|g_mirror_get_disk
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|ENXIO
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
return|return;
block|}
name|cbp
operator|=
name|g_clone_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|ENOMEM
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Fill in the component buf structure. 	 */
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|cbp
operator|->
name|bio_done
operator|=
name|g_mirror_done
expr_stmt|;
name|cbp
operator|->
name|bio_to
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|cbp
argument_list|,
literal|"Sending request."
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|->
name|acr
operator|>=
literal|1
operator|&&
name|cp
operator|->
name|acw
operator|>=
literal|1
operator|&&
name|cp
operator|->
name|ace
operator|>=
literal|1
argument_list|,
operator|(
literal|"Consumer %s not opened (r%dw%de%d)."
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|,
name|cp
operator|->
name|acr
operator|,
name|cp
operator|->
name|acw
operator|,
name|cp
operator|->
name|ace
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|index
operator|++
expr_stmt|;
name|g_io_request
argument_list|(
name|cbp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|TRACK_SIZE
value|(1 * 1024 * 1024)
end_define

begin_define
define|#
directive|define
name|LOAD_SCALE
value|256
end_define

begin_define
define|#
directive|define
name|ABS
parameter_list|(
name|x
parameter_list|)
value|(((x)>= 0) ? (x) : (-(x)))
end_define

begin_function
specifier|static
name|void
name|g_mirror_request_load
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|bio
modifier|*
name|cbp
decl_stmt|;
name|int
name|prio
decl_stmt|,
name|best
decl_stmt|;
comment|/* Find a disk with the smallest load. */
name|disk
operator|=
name|NULL
expr_stmt|;
name|best
operator|=
name|INT_MAX
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_state
operator|!=
name|G_MIRROR_DISK_STATE_ACTIVE
condition|)
continue|continue;
name|prio
operator|=
name|dp
operator|->
name|load
expr_stmt|;
comment|/* If disk head is precisely in position - highly prefer it. */
if|if
condition|(
name|dp
operator|->
name|d_last_offset
operator|==
name|bp
operator|->
name|bio_offset
condition|)
name|prio
operator|-=
literal|2
operator|*
name|LOAD_SCALE
expr_stmt|;
elseif|else
comment|/* If disk head is close to position - prefer it. */
if|if
condition|(
name|ABS
argument_list|(
name|dp
operator|->
name|d_last_offset
operator|-
name|bp
operator|->
name|bio_offset
argument_list|)
operator|<
name|TRACK_SIZE
condition|)
name|prio
operator|-=
literal|1
operator|*
name|LOAD_SCALE
expr_stmt|;
if|if
condition|(
name|prio
operator|<=
name|best
condition|)
block|{
name|disk
operator|=
name|dp
expr_stmt|;
name|best
operator|=
name|prio
expr_stmt|;
block|}
block|}
name|KASSERT
argument_list|(
name|disk
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL disk for %s."
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
name|cbp
operator|=
name|g_clone_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|ENOMEM
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Fill in the component buf structure. 	 */
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|cbp
operator|->
name|bio_done
operator|=
name|g_mirror_done
expr_stmt|;
name|cbp
operator|->
name|bio_to
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|cbp
argument_list|,
literal|"Sending request."
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|->
name|acr
operator|>=
literal|1
operator|&&
name|cp
operator|->
name|acw
operator|>=
literal|1
operator|&&
name|cp
operator|->
name|ace
operator|>=
literal|1
argument_list|,
operator|(
literal|"Consumer %s not opened (r%dw%de%d)."
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|,
name|cp
operator|->
name|acr
operator|,
name|cp
operator|->
name|acw
operator|,
name|cp
operator|->
name|ace
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|index
operator|++
expr_stmt|;
comment|/* Remember last head position */
name|disk
operator|->
name|d_last_offset
operator|=
name|bp
operator|->
name|bio_offset
operator|+
name|bp
operator|->
name|bio_length
expr_stmt|;
comment|/* Update loads. */
name|LIST_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
name|dp
operator|->
name|load
operator|=
operator|(
name|dp
operator|->
name|d_consumer
operator|->
name|index
operator|*
name|LOAD_SCALE
operator|+
name|dp
operator|->
name|load
operator|*
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
block|}
name|g_io_request
argument_list|(
name|cbp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_request_split
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|bio_queue_head
name|queue
decl_stmt|;
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|bio
modifier|*
name|cbp
decl_stmt|;
name|off_t
name|left
decl_stmt|,
name|mod
decl_stmt|,
name|offset
decl_stmt|,
name|slice
decl_stmt|;
name|u_char
modifier|*
name|data
decl_stmt|;
name|u_int
name|ndisks
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_length
operator|<=
name|sc
operator|->
name|sc_slice
condition|)
block|{
name|g_mirror_request_round_robin
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|ndisks
operator|=
name|g_mirror_ndisks
argument_list|(
name|sc
argument_list|,
name|G_MIRROR_DISK_STATE_ACTIVE
argument_list|)
expr_stmt|;
name|slice
operator|=
name|bp
operator|->
name|bio_length
operator|/
name|ndisks
expr_stmt|;
name|mod
operator|=
name|slice
operator|%
name|sc
operator|->
name|sc_provider
operator|->
name|sectorsize
expr_stmt|;
if|if
condition|(
name|mod
operator|!=
literal|0
condition|)
name|slice
operator|+=
name|sc
operator|->
name|sc_provider
operator|->
name|sectorsize
operator|-
name|mod
expr_stmt|;
comment|/* 	 * Allocate all bios before sending any request, so we can 	 * return ENOMEM in nice and clean way. 	 */
name|left
operator|=
name|bp
operator|->
name|bio_length
expr_stmt|;
name|offset
operator|=
name|bp
operator|->
name|bio_offset
expr_stmt|;
name|data
operator|=
name|bp
operator|->
name|bio_data
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|queue
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_MIRROR_DISK_STATE_ACTIVE
condition|)
continue|continue;
name|cbp
operator|=
name|g_clone_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|==
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|cbp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|g_destroy_bio
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|ENOMEM
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
return|return;
block|}
name|bioq_insert_tail
argument_list|(
operator|&
name|queue
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|bio_done
operator|=
name|g_mirror_done
expr_stmt|;
name|cbp
operator|->
name|bio_caller1
operator|=
name|disk
expr_stmt|;
name|cbp
operator|->
name|bio_to
operator|=
name|disk
operator|->
name|d_consumer
operator|->
name|provider
expr_stmt|;
name|cbp
operator|->
name|bio_offset
operator|=
name|offset
expr_stmt|;
name|cbp
operator|->
name|bio_data
operator|=
name|data
expr_stmt|;
name|cbp
operator|->
name|bio_length
operator|=
name|MIN
argument_list|(
name|left
argument_list|,
name|slice
argument_list|)
expr_stmt|;
name|left
operator|-=
name|cbp
operator|->
name|bio_length
expr_stmt|;
if|if
condition|(
name|left
operator|==
literal|0
condition|)
break|break;
name|offset
operator|+=
name|cbp
operator|->
name|bio_length
expr_stmt|;
name|data
operator|+=
name|cbp
operator|->
name|bio_length
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|cbp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|cbp
argument_list|,
literal|"Sending request."
argument_list|)
expr_stmt|;
name|disk
operator|=
name|cbp
operator|->
name|bio_caller1
expr_stmt|;
name|cbp
operator|->
name|bio_caller1
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|->
name|acr
operator|>=
literal|1
operator|&&
name|cp
operator|->
name|acw
operator|>=
literal|1
operator|&&
name|cp
operator|->
name|ace
operator|>=
literal|1
argument_list|,
operator|(
literal|"Consumer %s not opened (r%dw%de%d)."
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|,
name|cp
operator|->
name|acr
operator|,
name|cp
operator|->
name|acw
operator|,
name|cp
operator|->
name|ace
operator|)
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|->
name|index
operator|++
expr_stmt|;
name|g_io_request
argument_list|(
name|cbp
argument_list|,
name|disk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_register_request
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|private
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
switch|switch
condition|(
name|sc
operator|->
name|sc_balance
condition|)
block|{
case|case
name|G_MIRROR_BALANCE_LOAD
case|:
name|g_mirror_request_load
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
break|break;
case|case
name|G_MIRROR_BALANCE_PREFER
case|:
name|g_mirror_request_prefer
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
break|break;
case|case
name|G_MIRROR_BALANCE_ROUND_ROBIN
case|:
name|g_mirror_request_round_robin
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
break|break;
case|case
name|G_MIRROR_BALANCE_SPLIT
case|:
name|g_mirror_request_split
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
case|case
name|BIO_WRITE
case|:
case|case
name|BIO_DELETE
case|:
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_mirror_disk_sync
modifier|*
name|sync
decl_stmt|;
name|struct
name|bio_queue_head
name|queue
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|bio
modifier|*
name|cbp
decl_stmt|;
comment|/* 		 * Delay the request if it is colliding with a synchronization 		 * request. 		 */
if|if
condition|(
name|g_mirror_sync_collision
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
condition|)
block|{
name|g_mirror_regular_delay
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_idle
condition|)
name|g_mirror_unidle
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|sc_last_write
operator|=
name|time_uptime
expr_stmt|;
comment|/* 		 * Allocate all bios before sending any request, so we can 		 * return ENOMEM in nice and clean way. 		 */
name|bioq_init
argument_list|(
operator|&
name|queue
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
name|sync
operator|=
operator|&
name|disk
operator|->
name|d_sync
expr_stmt|;
switch|switch
condition|(
name|disk
operator|->
name|d_state
condition|)
block|{
case|case
name|G_MIRROR_DISK_STATE_ACTIVE
case|:
break|break;
case|case
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
case|:
if|if
condition|(
name|bp
operator|->
name|bio_offset
operator|>=
name|sync
operator|->
name|ds_offset
condition|)
continue|continue;
break|break;
default|default:
continue|continue;
block|}
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_DELETE
operator|&&
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_CANDELETE
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|cbp
operator|=
name|g_clone_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|==
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|cbp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|g_destroy_bio
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|ENOMEM
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
return|return;
block|}
name|bioq_insert_tail
argument_list|(
operator|&
name|queue
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|bio_done
operator|=
name|g_mirror_done
expr_stmt|;
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|cbp
operator|->
name|bio_caller1
operator|=
name|cp
expr_stmt|;
name|cbp
operator|->
name|bio_to
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|->
name|acr
operator|>=
literal|1
operator|&&
name|cp
operator|->
name|acw
operator|>=
literal|1
operator|&&
name|cp
operator|->
name|ace
operator|>=
literal|1
argument_list|,
operator|(
literal|"Consumer %s not opened (r%dw%de%d)."
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|,
name|cp
operator|->
name|acr
operator|,
name|cp
operator|->
name|acw
operator|,
name|cp
operator|->
name|ace
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bioq_first
argument_list|(
operator|&
name|queue
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|cbp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|cbp
argument_list|,
literal|"Sending request."
argument_list|)
expr_stmt|;
name|cp
operator|=
name|cbp
operator|->
name|bio_caller1
expr_stmt|;
name|cbp
operator|->
name|bio_caller1
operator|=
name|NULL
expr_stmt|;
name|cp
operator|->
name|index
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_writes
operator|++
expr_stmt|;
name|g_io_request
argument_list|(
name|cbp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Put request onto inflight queue, so we can check if new 		 * synchronization requests don't collide with it. 		 */
name|bioq_insert_tail
argument_list|(
operator|&
name|sc
operator|->
name|sc_inflight
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * Bump syncid on first write. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_bump_id
operator|&
name|G_MIRROR_BUMP_SYNCID
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_bump_id
operator|&=
operator|~
name|G_MIRROR_BUMP_SYNCID
expr_stmt|;
name|g_mirror_bump_syncid
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
default|default:
name|KASSERT
argument_list|(
literal|1
operator|==
literal|0
argument_list|,
operator|(
literal|"Invalid command here: %u (device=%s)"
operator|,
name|bp
operator|->
name|bio_cmd
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|g_mirror_can_destroy
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|gp
operator|=
name|sc
operator|->
name|sc_geom
expr_stmt|;
if|if
condition|(
name|gp
operator|->
name|softc
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_TASTING
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|LIST_FOREACH
argument_list|(
argument|cp
argument_list|,
argument|&gp->consumer
argument_list|,
argument|consumer
argument_list|)
block|{
if|if
condition|(
name|g_mirror_is_busy
argument_list|(
name|sc
argument_list|,
name|cp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|gp
operator|=
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|cp
argument_list|,
argument|&gp->consumer
argument_list|,
argument|consumer
argument_list|)
block|{
if|if
condition|(
name|g_mirror_is_busy
argument_list|(
name|sc
argument_list|,
name|cp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|G_MIRROR_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"No I/O requests for %s, it can be destroyed."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_mirror_try_destroy
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_rootmount
operator|!=
name|NULL
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"root_mount_rel[%u] %p"
argument_list|,
name|__LINE__
argument_list|,
name|sc
operator|->
name|sc_rootmount
argument_list|)
expr_stmt|;
name|root_mount_rel
argument_list|(
name|sc
operator|->
name|sc_rootmount
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rootmount
operator|=
name|NULL
expr_stmt|;
block|}
name|g_topology_lock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|g_mirror_can_destroy
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|g_topology_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|sc_geom
operator|->
name|softc
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
operator|->
name|softc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_WAIT
operator|)
operator|!=
literal|0
condition|)
block|{
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Waking up %p."
argument_list|,
name|__func__
argument_list|,
operator|&
name|sc
operator|->
name|sc_worker
argument_list|)
expr_stmt|;
comment|/* Unlock sc_lock here, as it can be destroyed after wakeup. */
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_worker
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_worker
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|g_mirror_destroy_device
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Worker thread.  */
end_comment

begin_function
specifier|static
name|void
name|g_mirror_worker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_mirror_event
modifier|*
name|ep
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_prio
argument_list|(
name|curthread
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%s: Let's see..."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 		 * First take a look at events. 		 * This is important to handle events before any I/O requests. 		 */
name|ep
operator|=
name|g_mirror_event_get
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
block|{
name|g_mirror_event_remove
argument_list|(
name|sc
argument_list|,
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_MIRROR_EVENT_DEVICE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Update only device status. */
name|G_MIRROR_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"Running event for device %s."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|ep
operator|->
name|e_error
operator|=
literal|0
expr_stmt|;
name|g_mirror_update_device
argument_list|(
name|sc
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Update disk status. */
name|G_MIRROR_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"Running event for disk %s."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|ep
operator|->
name|e_disk
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|e_error
operator|=
name|g_mirror_update_disk
argument_list|(
name|ep
operator|->
name|e_disk
argument_list|,
name|ep
operator|->
name|e_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_error
operator|==
literal|0
condition|)
name|g_mirror_update_device
argument_list|(
name|sc
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_MIRROR_EVENT_DONTWAIT
operator|)
operator|!=
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|ep
operator|->
name|e_error
operator|==
literal|0
argument_list|,
operator|(
literal|"Error cannot be handled."
operator|)
argument_list|)
expr_stmt|;
name|g_mirror_event_free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ep
operator|->
name|e_flags
operator||=
name|G_MIRROR_EVENT_DONE
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Waking up %p."
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_DESTROY
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|g_mirror_try_destroy
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|curthread
operator|->
name|td_pflags
operator|&=
operator|~
name|TDP_GEOM
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Thread exiting."
argument_list|)
expr_stmt|;
name|kproc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|G_MIRROR_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%s: I'm here 1."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Check if we can mark array as CLEAN and if we can't take 		 * how much seconds should we wait. 		 */
name|timeout
operator|=
name|g_mirror_idle
argument_list|(
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Now I/O requests. 		 */
comment|/* Get first request from the queue. */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_DESTROY
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_mirror_try_destroy
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|curthread
operator|->
name|td_pflags
operator|&=
operator|~
name|TDP_GEOM
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Thread exiting."
argument_list|)
expr_stmt|;
name|kproc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bioq_first
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
comment|/* 			 * XXX: We can miss an event here, because an event 			 *      can be added without sx-device-lock and without 			 *      mtx-queue-lock. Maybe I should just stop using 			 *      dedicated mutex for events synchronization and 			 *      stick with the queue lock? 			 *      The event will hang here until next I/O request 			 *      or next event is received. 			 */
name|MSLEEP
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|,
name|PRIBIO
operator||
name|PDROP
argument_list|,
literal|"m:w1"
argument_list|,
name|timeout
operator|*
name|hz
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%s: I'm here 4."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_from
operator|->
name|geom
operator|==
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
operator|&&
operator|(
name|bp
operator|->
name|bio_cflags
operator|&
name|G_MIRROR_BIO_FLAG_SYNC
operator|)
operator|!=
literal|0
condition|)
block|{
name|g_mirror_sync_request
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* READ */
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|bio_to
operator|!=
name|sc
operator|->
name|sc_provider
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|bio_cflags
operator|&
name|G_MIRROR_BIO_FLAG_REGULAR
operator|)
operator|!=
literal|0
condition|)
name|g_mirror_regular_request
argument_list|(
name|bp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bp
operator|->
name|bio_cflags
operator|&
name|G_MIRROR_BIO_FLAG_SYNC
operator|)
operator|!=
literal|0
condition|)
name|g_mirror_sync_request
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* WRITE */
else|else
block|{
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"Invalid request cflags=0x%hx to=%s."
operator|,
name|bp
operator|->
name|bio_cflags
operator|,
name|bp
operator|->
name|bio_to
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|g_mirror_register_request
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|G_MIRROR_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%s: I'm here 9."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_update_idle
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|)
block|{
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_NOFAILSYNC
operator|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_idle
operator|&&
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_DIRTY
operator|)
operator|==
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Disk %s (device %s) marked as dirty."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_flags
operator||=
name|G_MIRROR_DISK_FLAG_DIRTY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_idle
operator|&&
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_DIRTY
operator|)
operator|!=
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Disk %s (device %s) marked as clean."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_MIRROR_DISK_FLAG_DIRTY
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_sync_start
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
argument_list|,
operator|(
literal|"Disk %s is not marked for synchronization."
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_state
operator|==
name|G_MIRROR_DEVICE_STATE_RUNNING
argument_list|,
operator|(
literal|"Device not in RUNNING state (%s, %u)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|sc
operator|->
name|sc_state
operator|)
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|cp
operator|=
name|g_new_consumer
argument_list|(
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
argument_list|)
expr_stmt|;
name|cp
operator|->
name|flags
operator||=
name|G_CF_DIRECT_SEND
operator||
name|G_CF_DIRECT_RECEIVE
expr_stmt|;
name|error
operator|=
name|g_attach
argument_list|(
name|cp
argument_list|,
name|sc
operator|->
name|sc_provider
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"Cannot attach to %s (error=%d)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"Cannot open %s (error=%d)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: rebuilding provider %s."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_NOFAILSYNC
operator|)
operator|==
literal|0
condition|)
name|disk
operator|->
name|d_flags
operator||=
name|G_MIRROR_DISK_FLAG_DIRTY
expr_stmt|;
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|==
name|NULL
argument_list|,
operator|(
literal|"Sync consumer already exists (device=%s, disk=%s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|=
name|cp
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|->
name|private
operator|=
name|disk
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|->
name|index
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Allocate memory for synchronization bios and initialize them. 	 */
name|disk
operator|->
name|d_sync
operator|.
name|ds_bios
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bio
operator|*
argument_list|)
operator|*
name|g_mirror_syncreqs
argument_list|,
name|M_MIRROR
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g_mirror_syncreqs
condition|;
name|i
operator|++
control|)
block|{
name|bp
operator|=
name|g_alloc_bio
argument_list|()
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_bios
index|[
name|i
index|]
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|bio_parent
operator|=
name|NULL
expr_stmt|;
name|bp
operator|->
name|bio_cmd
operator|=
name|BIO_READ
expr_stmt|;
name|bp
operator|->
name|bio_data
operator|=
name|malloc
argument_list|(
name|MAXPHYS
argument_list|,
name|M_MIRROR
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_cflags
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bio_offset
operator|=
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset
expr_stmt|;
name|bp
operator|->
name|bio_length
operator|=
name|MIN
argument_list|(
name|MAXPHYS
argument_list|,
name|sc
operator|->
name|sc_mediasize
operator|-
name|bp
operator|->
name|bio_offset
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset
operator|+=
name|bp
operator|->
name|bio_length
expr_stmt|;
name|bp
operator|->
name|bio_done
operator|=
name|g_mirror_sync_done
expr_stmt|;
name|bp
operator|->
name|bio_from
operator|=
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
expr_stmt|;
name|bp
operator|->
name|bio_to
operator|=
name|sc
operator|->
name|sc_provider
expr_stmt|;
name|bp
operator|->
name|bio_caller1
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|i
expr_stmt|;
block|}
comment|/* Increase the number of disks in SYNCHRONIZING state. */
name|sc
operator|->
name|sc_sync
operator|.
name|ds_ndisks
operator|++
expr_stmt|;
comment|/* Set the number of in-flight synchronization requests. */
name|disk
operator|->
name|d_sync
operator|.
name|ds_inflight
operator|=
name|g_mirror_syncreqs
expr_stmt|;
comment|/* 	 * Fire off first synchronization requests. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g_mirror_syncreqs
condition|;
name|i
operator|++
control|)
block|{
name|bp
operator|=
name|disk
operator|->
name|d_sync
operator|.
name|ds_bios
index|[
name|i
index|]
expr_stmt|;
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Sending synchronization request."
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|->
name|index
operator|++
expr_stmt|;
comment|/* 		 * Delay the request if it is colliding with a regular request. 		 */
if|if
condition|(
name|g_mirror_regular_collision
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
condition|)
name|g_mirror_sync_delay
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
else|else
name|g_io_request
argument_list|(
name|bp
argument_list|,
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Stop synchronization process.  * type: 0 - synchronization finished  *       1 - synchronization stopped  */
end_comment

begin_function
specifier|static
name|void
name|g_mirror_sync_stop
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: rebuilding provider %s finished."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* if (type == 1) */
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: rebuilding provider %s stopped."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_bios
argument_list|,
name|M_MIRROR
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_bios
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|=
name|NULL
expr_stmt|;
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_MIRROR_DISK_FLAG_DIRTY
expr_stmt|;
name|sc
operator|->
name|sc_sync
operator|.
name|ds_ndisks
operator|--
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
comment|/* Avoid recursion on sc_lock. */
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_mirror_kill_consumer
argument_list|(
name|sc
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_launch_provider
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|pp
operator|=
name|g_new_providerf
argument_list|(
name|sc
operator|->
name|sc_geom
argument_list|,
literal|"mirror/%s"
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|pp
operator|->
name|flags
operator||=
name|G_PF_DIRECT_RECEIVE
expr_stmt|;
name|pp
operator|->
name|mediasize
operator|=
name|sc
operator|->
name|sc_mediasize
expr_stmt|;
name|pp
operator|->
name|sectorsize
operator|=
name|sc
operator|->
name|sc_sectorsize
expr_stmt|;
name|pp
operator|->
name|stripesize
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|stripeoffset
operator|=
literal|0
expr_stmt|;
comment|/* Splitting of unmapped BIO's could work but isn't implemented now */
if|if
condition|(
name|sc
operator|->
name|sc_balance
operator|!=
name|G_MIRROR_BALANCE_SPLIT
condition|)
name|pp
operator|->
name|flags
operator||=
name|G_PF_ACCEPT_UNMAPPED
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_consumer
operator|&&
name|disk
operator|->
name|d_consumer
operator|->
name|provider
condition|)
block|{
name|dp
operator|=
name|disk
operator|->
name|d_consumer
operator|->
name|provider
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|stripesize
operator|>
name|pp
operator|->
name|stripesize
condition|)
block|{
name|pp
operator|->
name|stripesize
operator|=
name|dp
operator|->
name|stripesize
expr_stmt|;
name|pp
operator|->
name|stripeoffset
operator|=
name|dp
operator|->
name|stripeoffset
expr_stmt|;
block|}
comment|/* A provider underneath us doesn't support unmapped */
if|if
condition|(
operator|(
name|dp
operator|->
name|flags
operator|&
name|G_PF_ACCEPT_UNMAPPED
operator|)
operator|==
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cancelling unmapped "
literal|"because of %s."
argument_list|,
name|dp
operator|->
name|name
argument_list|)
expr_stmt|;
name|pp
operator|->
name|flags
operator|&=
operator|~
name|G_PF_ACCEPT_UNMAPPED
expr_stmt|;
block|}
block|}
block|}
name|pp
operator|->
name|private
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_refcnt
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_provider
operator|=
name|pp
expr_stmt|;
name|g_error_provider
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s launched (%u/%u)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|g_mirror_ndisks
argument_list|(
name|sc
argument_list|,
name|G_MIRROR_DISK_STATE_ACTIVE
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_ndisks
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
condition|)
name|g_mirror_sync_start
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_destroy_provider
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_provider
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL provider (device=%s)."
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_error_provider
argument_list|(
name|sc
operator|->
name|sc_provider
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Abort any pending I/O that wasn't generated by us. 		 * Synchronization requests and requests destined for individual 		 * mirror components can be destroyed immediately. 		 */
if|if
condition|(
name|bp
operator|->
name|bio_to
operator|==
name|sc
operator|->
name|sc_provider
operator|&&
name|bp
operator|->
name|bio_from
operator|->
name|geom
operator|!=
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
condition|)
block|{
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|bio_cflags
operator|&
name|G_MIRROR_BIO_FLAG_SYNC
operator|)
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|bp
operator|->
name|bio_data
argument_list|,
name|M_MIRROR
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|g_wither_provider
argument_list|(
name|sc
operator|->
name|sc_provider
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_provider
operator|=
name|NULL
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: provider destroyed."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
condition|)
name|g_mirror_sync_stop
argument_list|(
name|disk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_go
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Force device %s start due to timeout."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|g_mirror_event_send
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|G_MIRROR_EVENT_DONTWAIT
operator||
name|G_MIRROR_EVENT_DEVICE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|g_mirror_determine_state
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|u_int
name|state
decl_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_syncid
operator|==
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
condition|)
block|{
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_SYNCHRONIZING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Disk does not need synchronization. */
name|state
operator|=
name|G_MIRROR_DISK_STATE_ACTIVE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_NOAUTOSYNC
operator|)
operator|==
literal|0
operator|||
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_FORCE_SYNC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * We can start synchronization from 				 * the stored offset. 				 */
name|state
operator|=
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|G_MIRROR_DISK_STATE_STALE
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|<
name|sc
operator|->
name|sc_syncid
condition|)
block|{
comment|/* 		 * Reset all synchronization data for this disk, 		 * because if it even was synchronized, it was 		 * synchronized to disks with different syncid. 		 */
name|disk
operator|->
name|d_flags
operator||=
name|G_MIRROR_DISK_FLAG_SYNCHRONIZING
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset
operator|=
literal|0
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset_done
operator|=
literal|0
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|=
name|sc
operator|->
name|sc_syncid
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_NOAUTOSYNC
operator|)
operator|==
literal|0
operator|||
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_FORCE_SYNC
operator|)
operator|!=
literal|0
condition|)
block|{
name|state
operator|=
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|G_MIRROR_DISK_STATE_STALE
expr_stmt|;
block|}
block|}
else|else
comment|/* if (sc->sc_syncid< disk->d_sync.ds_syncid) */
block|{
comment|/* 		 * Not good, NOT GOOD! 		 * It means that mirror was started on stale disks 		 * and more fresh disk just arrive. 		 * If there were writes, mirror is broken, sorry. 		 * I think the best choice here is don't touch 		 * this disk and inform the user loudly. 		 */
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s was started before the freshest "
literal|"disk (%s) arrives!! It will not be connected to the "
literal|"running device."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
name|g_mirror_destroy_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|state
operator|=
name|G_MIRROR_DISK_STATE_NONE
expr_stmt|;
comment|/* Return immediately, because disk was destroyed. */
return|return
operator|(
name|state
operator|)
return|;
block|}
name|G_MIRROR_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"State for %s disk: %s."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|g_mirror_disk_state2str
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|state
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update device state.  */
end_comment

begin_function
specifier|static
name|void
name|g_mirror_update_device
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|bool
name|force
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|u_int
name|state
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_state
condition|)
block|{
case|case
name|G_MIRROR_DEVICE_STATE_STARTING
case|:
block|{
name|struct
name|g_mirror_disk
modifier|*
name|pdisk
decl_stmt|,
modifier|*
name|tdisk
decl_stmt|;
name|u_int
name|dirty
decl_stmt|,
name|ndisks
decl_stmt|,
name|genid
decl_stmt|,
name|syncid
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_provider
operator|==
name|NULL
argument_list|,
operator|(
literal|"Non-NULL provider in STARTING state (%s)."
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Are we ready? We are, if all disks are connected or 		 * if we have any disks and 'force' is true. 		 */
name|ndisks
operator|=
name|g_mirror_ndisks
argument_list|(
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ndisks
operator|==
name|ndisks
operator|||
operator|(
name|force
operator|&&
name|ndisks
operator|>
literal|0
operator|)
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|ndisks
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Disks went down in starting phase, so destroy 			 * device. 			 */
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|G_MIRROR_DEVICE_FLAG_DESTROY
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"root_mount_rel[%u] %p"
argument_list|,
name|__LINE__
argument_list|,
name|sc
operator|->
name|sc_rootmount
argument_list|)
expr_stmt|;
name|root_mount_rel
argument_list|(
name|sc
operator|->
name|sc_rootmount
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rootmount
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
else|else
block|{
return|return;
block|}
comment|/* 		 * Activate all disks with the biggest syncid. 		 */
if|if
condition|(
name|force
condition|)
block|{
comment|/* 			 * If 'force' is true, we have been called due to 			 * timeout, so don't bother canceling timeout. 			 */
name|ndisks
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_SYNCHRONIZING
operator|)
operator|==
literal|0
condition|)
block|{
name|ndisks
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ndisks
operator|==
literal|0
condition|)
block|{
comment|/* No valid disks found, destroy device. */
name|sc
operator|->
name|sc_flags
operator||=
name|G_MIRROR_DEVICE_FLAG_DESTROY
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"root_mount_rel[%u] %p"
argument_list|,
name|__LINE__
argument_list|,
name|sc
operator|->
name|sc_rootmount
argument_list|)
expr_stmt|;
name|root_mount_rel
argument_list|(
name|sc
operator|->
name|sc_rootmount
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rootmount
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* Cancel timeout. */
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Find the biggest genid. 		 */
name|genid
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_genid
operator|>
name|genid
condition|)
name|genid
operator|=
name|disk
operator|->
name|d_genid
expr_stmt|;
block|}
name|sc
operator|->
name|sc_genid
operator|=
name|genid
expr_stmt|;
comment|/* 		 * Remove all disks without the biggest genid. 		 */
name|LIST_FOREACH_SAFE
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|,
argument|tdisk
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_genid
operator|<
name|genid
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Component %s (device %s) broken, skipping."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|g_mirror_destroy_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Find the biggest syncid. 		 */
name|syncid
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|>
name|syncid
condition|)
name|syncid
operator|=
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
expr_stmt|;
block|}
comment|/* 		 * Here we need to look for dirty disks and if all disks 		 * with the biggest syncid are dirty, we have to choose 		 * one with the biggest priority and rebuild the rest. 		 */
comment|/* 		 * Find the number of dirty disks with the biggest syncid. 		 * Find the number of disks with the biggest syncid. 		 * While here, find a disk with the biggest priority. 		 */
name|dirty
operator|=
name|ndisks
operator|=
literal|0
expr_stmt|;
name|pdisk
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|!=
name|syncid
condition|)
continue|continue;
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_SYNCHRONIZING
operator|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
name|ndisks
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_DIRTY
operator|)
operator|!=
literal|0
condition|)
block|{
name|dirty
operator|++
expr_stmt|;
if|if
condition|(
name|pdisk
operator|==
name|NULL
operator|||
name|pdisk
operator|->
name|d_priority
operator|<
name|disk
operator|->
name|d_priority
condition|)
block|{
name|pdisk
operator|=
name|disk
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|dirty
operator|==
literal|0
condition|)
block|{
comment|/* No dirty disks at all, great. */
block|}
elseif|else
if|if
condition|(
name|dirty
operator|==
name|ndisks
condition|)
block|{
comment|/* 			 * Force synchronization for all dirty disks except one 			 * with the biggest priority. 			 */
name|KASSERT
argument_list|(
name|pdisk
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pdisk == NULL"
operator|)
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Using disk %s (device %s) as a "
literal|"master disk for synchronization."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|pdisk
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|!=
name|syncid
condition|)
continue|continue;
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_SYNCHRONIZING
operator|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
name|KASSERT
argument_list|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_DIRTY
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"Disk %s isn't marked as dirty."
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Skip the disk with the biggest priority. */
if|if
condition|(
name|disk
operator|==
name|pdisk
condition|)
continue|continue;
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dirty
operator|<
name|ndisks
condition|)
block|{
comment|/* 			 * Force synchronization for all dirty disks. 			 * We have some non-dirty disks. 			 */
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|!=
name|syncid
condition|)
continue|continue;
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_SYNCHRONIZING
operator|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_DIRTY
operator|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Reset hint. */
name|sc
operator|->
name|sc_hint
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_syncid
operator|=
name|syncid
expr_stmt|;
if|if
condition|(
name|force
condition|)
block|{
comment|/* Remember to bump syncid on first write. */
name|sc
operator|->
name|sc_bump_id
operator||=
name|G_MIRROR_BUMP_SYNCID
expr_stmt|;
block|}
name|state
operator|=
name|G_MIRROR_DEVICE_STATE_RUNNING
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Device %s state changed from %s to %s."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_mirror_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
argument_list|,
name|g_mirror_device_state2str
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|state
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
name|state
operator|=
name|g_mirror_determine_state
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|g_mirror_event_send
argument_list|(
name|disk
argument_list|,
name|state
argument_list|,
name|G_MIRROR_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|G_MIRROR_DISK_STATE_STALE
condition|)
name|sc
operator|->
name|sc_bump_id
operator||=
name|G_MIRROR_BUMP_SYNCID
expr_stmt|;
block|}
break|break;
block|}
case|case
name|G_MIRROR_DEVICE_STATE_RUNNING
case|:
if|if
condition|(
name|g_mirror_ndisks
argument_list|(
name|sc
argument_list|,
name|G_MIRROR_DISK_STATE_ACTIVE
argument_list|)
operator|==
literal|0
operator|&&
name|g_mirror_ndisks
argument_list|(
name|sc
argument_list|,
name|G_MIRROR_DISK_STATE_NEW
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * No active disks or no disks at all, 			 * so destroy device. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_provider
operator|!=
name|NULL
condition|)
name|g_mirror_destroy_provider
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|G_MIRROR_DEVICE_FLAG_DESTROY
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|g_mirror_ndisks
argument_list|(
name|sc
argument_list|,
name|G_MIRROR_DISK_STATE_ACTIVE
argument_list|)
operator|>
literal|0
operator|&&
name|g_mirror_ndisks
argument_list|(
name|sc
argument_list|,
name|G_MIRROR_DISK_STATE_NEW
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * We have active disks, launch provider if it doesn't 			 * exist. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_provider
operator|==
name|NULL
condition|)
name|g_mirror_launch_provider
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rootmount
operator|!=
name|NULL
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"root_mount_rel[%u] %p"
argument_list|,
name|__LINE__
argument_list|,
name|sc
operator|->
name|sc_rootmount
argument_list|)
expr_stmt|;
name|root_mount_rel
argument_list|(
name|sc
operator|->
name|sc_rootmount
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rootmount
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 		 * Genid should be bumped immediately, so do it here. 		 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_bump_id
operator|&
name|G_MIRROR_BUMP_GENID
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_bump_id
operator|&=
operator|~
name|G_MIRROR_BUMP_GENID
expr_stmt|;
name|g_mirror_bump_genid
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|KASSERT
argument_list|(
literal|1
operator|==
literal|0
argument_list|,
operator|(
literal|"Wrong device state (%s, %s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_mirror_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Update disk state and device state if needed.  */
end_comment

begin_define
define|#
directive|define
name|DISK_STATE_CHANGED
parameter_list|()
value|G_MIRROR_DEBUG(1,			\ 	"Disk %s state changed from %s to %s (device %s).",		\ 	g_mirror_get_diskname(disk),					\ 	g_mirror_disk_state2str(disk->d_state),				\ 	g_mirror_disk_state2str(state), sc->sc_name)
end_define

begin_function
specifier|static
name|int
name|g_mirror_update_disk
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|,
name|u_int
name|state
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|again
label|:
name|G_MIRROR_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"Changing disk %s state from %s to %s."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
argument_list|,
name|g_mirror_disk_state2str
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|G_MIRROR_DISK_STATE_NEW
case|:
comment|/* 		 * Possible scenarios: 		 * 1. New disk arrive. 		 */
comment|/* Previous state should be NONE. */
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_NONE
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DISK_STATE_CHANGED
argument_list|()
expr_stmt|;
name|disk
operator|->
name|d_state
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_disks
argument_list|)
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_disks
argument_list|,
name|disk
argument_list|,
name|d_next
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|g_mirror_disk
modifier|*
name|dp
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_priority
operator|>=
name|dp
operator|->
name|d_priority
condition|)
block|{
name|LIST_INSERT_BEFORE
argument_list|(
name|dp
argument_list|,
name|disk
argument_list|,
name|d_next
argument_list|)
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|dp
argument_list|,
name|d_next
argument_list|)
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
name|LIST_INSERT_AFTER
argument_list|(
name|dp
argument_list|,
name|disk
argument_list|,
name|d_next
argument_list|)
expr_stmt|;
block|}
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Device %s: provider %s detected."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|G_MIRROR_DEVICE_STATE_STARTING
condition|)
break|break;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_state
operator|==
name|G_MIRROR_DEVICE_STATE_RUNNING
argument_list|,
operator|(
literal|"Wrong device state (%s, %s, %s, %s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_mirror_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|state
operator|=
name|g_mirror_determine_state
argument_list|(
name|disk
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|G_MIRROR_DISK_STATE_NONE
condition|)
goto|goto
name|again
goto|;
break|break;
case|case
name|G_MIRROR_DISK_STATE_ACTIVE
case|:
comment|/* 		 * Possible scenarios: 		 * 1. New disk does not need synchronization. 		 * 2. Synchronization process finished successfully. 		 */
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_state
operator|==
name|G_MIRROR_DEVICE_STATE_RUNNING
argument_list|,
operator|(
literal|"Wrong device state (%s, %s, %s, %s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_mirror_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Previous state should be NEW or SYNCHRONIZING. */
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_NEW
operator|||
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DISK_STATE_CHANGED
argument_list|()
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
condition|)
block|{
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_MIRROR_DISK_FLAG_SYNCHRONIZING
expr_stmt|;
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_MIRROR_DISK_FLAG_FORCE_SYNC
expr_stmt|;
name|g_mirror_sync_stop
argument_list|(
name|disk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|disk
operator|->
name|d_state
operator|=
name|state
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset
operator|=
literal|0
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset_done
operator|=
literal|0
expr_stmt|;
name|g_mirror_update_idle
argument_list|(
name|sc
argument_list|,
name|disk
argument_list|)
expr_stmt|;
name|g_mirror_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Device %s: provider %s activated."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|G_MIRROR_DISK_STATE_STALE
case|:
comment|/* 		 * Possible scenarios: 		 * 1. Stale disk was connected. 		 */
comment|/* Previous state should be NEW. */
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_NEW
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_state
operator|==
name|G_MIRROR_DEVICE_STATE_RUNNING
argument_list|,
operator|(
literal|"Wrong device state (%s, %s, %s, %s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_mirror_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * STALE state is only possible if device is marked 		 * NOAUTOSYNC. 		 */
name|KASSERT
argument_list|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_NOAUTOSYNC
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"Wrong device state (%s, %s, %s, %s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_mirror_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DISK_STATE_CHANGED
argument_list|()
expr_stmt|;
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_MIRROR_DISK_FLAG_DIRTY
expr_stmt|;
name|disk
operator|->
name|d_state
operator|=
name|state
expr_stmt|;
name|g_mirror_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: provider %s is stale."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
case|:
comment|/* 		 * Possible scenarios: 		 * 1. Disk which needs synchronization was connected. 		 */
comment|/* Previous state should be NEW. */
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_NEW
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_state
operator|==
name|G_MIRROR_DEVICE_STATE_RUNNING
argument_list|,
operator|(
literal|"Wrong device state (%s, %s, %s, %s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_mirror_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DISK_STATE_CHANGED
argument_list|()
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_NEW
condition|)
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_MIRROR_DISK_FLAG_DIRTY
expr_stmt|;
name|disk
operator|->
name|d_state
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_provider
operator|!=
name|NULL
condition|)
block|{
name|g_mirror_sync_start
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|g_mirror_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|G_MIRROR_DISK_STATE_DISCONNECTED
case|:
comment|/* 		 * Possible scenarios: 		 * 1. Device wasn't running yet, but disk disappear. 		 * 2. Disk was active and disapppear. 		 * 3. Disk disappear during synchronization process. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|G_MIRROR_DEVICE_STATE_RUNNING
condition|)
block|{
comment|/* 			 * Previous state should be ACTIVE, STALE or 			 * SYNCHRONIZING. 			 */
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_ACTIVE
operator|||
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_STALE
operator|||
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|G_MIRROR_DEVICE_STATE_STARTING
condition|)
block|{
comment|/* Previous state should be NEW. */
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_NEW
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Reset bumping syncid if disk disappeared in STARTING 			 * state. 			 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_bump_id
operator|&
name|G_MIRROR_BUMP_SYNCID
operator|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_bump_id
operator|&=
operator|~
name|G_MIRROR_BUMP_SYNCID
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
block|}
else|else
block|{
name|KASSERT
argument_list|(
literal|1
operator|==
literal|0
argument_list|,
operator|(
literal|"Wrong device state (%s, %s, %s, %s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_mirror_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|DISK_STATE_CHANGED
argument_list|()
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: provider %s disconnected."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
name|g_mirror_destroy_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
break|break;
case|case
name|G_MIRROR_DISK_STATE_DESTROY
case|:
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|g_mirror_clear_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: failed to clear metadata on %s: %d."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
name|DISK_STATE_CHANGED
argument_list|()
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: provider %s destroyed."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
name|g_mirror_destroy_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ndisks
operator|--
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
name|g_mirror_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|KASSERT
argument_list|(
literal|1
operator|==
literal|0
argument_list|,
operator|(
literal|"Unknown state (%u)."
operator|,
name|state
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|DISK_STATE_CHANGED
end_undef

begin_function
name|int
name|g_mirror_read_metadata
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_mirror_metadata
modifier|*
name|md
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
comment|/* Metadata are stored on last sector. */
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|pp
operator|->
name|mediasize
operator|-
name|pp
operator|->
name|sectorsize
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Cannot read metadata from %s (error=%d)."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Decode metadata. */
name|error
operator|=
name|mirror_metadata_decode
argument_list|(
name|buf
argument_list|,
name|md
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|md
operator|->
name|md_magic
argument_list|,
name|G_MIRROR_MAGIC
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|md
operator|->
name|md_version
operator|>
name|G_MIRROR_VERSION
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Kernel module is too old to handle metadata from %s."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"MD5 metadata hash mismatch for provider %s."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_mirror_check_metadata
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|struct
name|g_mirror_metadata
modifier|*
name|md
parameter_list|)
block|{
if|if
condition|(
name|g_mirror_id2disk
argument_list|(
name|sc
argument_list|,
name|md
operator|->
name|md_did
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Disk %s (id=%u) already exists, skipping."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|md
operator|->
name|md_did
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
if|if
condition|(
name|md
operator|->
name|md_all
operator|!=
name|sc
operator|->
name|sc_ndisks
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid '%s' field on disk %s (device %s), skipping."
argument_list|,
literal|"md_all"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|md
operator|->
name|md_slice
operator|!=
name|sc
operator|->
name|sc_slice
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid '%s' field on disk %s (device %s), skipping."
argument_list|,
literal|"md_slice"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|md
operator|->
name|md_balance
operator|!=
name|sc
operator|->
name|sc_balance
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid '%s' field on disk %s (device %s), skipping."
argument_list|,
literal|"md_balance"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|#
directive|if
literal|0
block|if (md->md_mediasize != sc->sc_mediasize) { 		G_MIRROR_DEBUG(1, 		    "Invalid '%s' field on disk %s (device %s), skipping.", 		    "md_mediasize", pp->name, sc->sc_name); 		return (EINVAL); 	}
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_mediasize
operator|>
name|pp
operator|->
name|mediasize
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid size of disk %s (device %s), skipping."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|md
operator|->
name|md_sectorsize
operator|!=
name|sc
operator|->
name|sc_sectorsize
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid '%s' field on disk %s (device %s), skipping."
argument_list|,
literal|"md_sectorsize"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_sectorsize
operator|%
name|pp
operator|->
name|sectorsize
operator|)
operator|!=
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid sector size of disk %s (device %s), skipping."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|md
operator|->
name|md_mflags
operator|&
operator|~
name|G_MIRROR_DEVICE_FLAG_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid device flags on disk %s (device %s), skipping."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|md
operator|->
name|md_dflags
operator|&
operator|~
name|G_MIRROR_DISK_FLAG_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid disk flags on disk %s (device %s), skipping."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|g_mirror_add_disk
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|struct
name|g_mirror_metadata
modifier|*
name|md
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Adding disk %s."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_mirror_check_metadata
argument_list|(
name|sc
argument_list|,
name|pp
argument_list|,
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|G_MIRROR_DEVICE_STATE_RUNNING
operator|&&
name|md
operator|->
name|md_genid
operator|<
name|sc
operator|->
name|sc_genid
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Component %s (device %s) broken, skipping."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|disk
operator|=
name|g_mirror_init_disk
argument_list|(
name|sc
argument_list|,
name|pp
argument_list|,
name|md
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|g_mirror_event_send
argument_list|(
name|disk
argument_list|,
name|G_MIRROR_DISK_STATE_NEW
argument_list|,
name|G_MIRROR_EVENT_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|md
operator|->
name|md_version
operator|<
name|G_MIRROR_VERSION
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Upgrading metadata on %s (v%d->v%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|md
operator|->
name|md_version
argument_list|,
name|G_MIRROR_VERSION
argument_list|)
expr_stmt|;
name|g_mirror_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_destroy_delayed
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|flag
operator|==
name|EV_CANCEL
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Destroying canceled."
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|=
name|arg
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_DESTROY
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"DESTROY flag set on %s."
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_DESTROYING
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"DESTROYING flag not set on %s."
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Destroying %s (delayed)."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_mirror_destroy
argument_list|(
name|sc
argument_list|,
name|G_MIRROR_DESTROY_SOFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot destroy %s (error=%d)."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
block|}
name|g_topology_lock
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_mirror_access
parameter_list|(
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|acr
parameter_list|,
name|int
name|acw
parameter_list|,
name|int
name|ace
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Access request for %s: r%dw%de%d."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|acr
argument_list|,
name|acw
argument_list|,
name|ace
argument_list|)
expr_stmt|;
name|sc
operator|=
name|pp
operator|->
name|private
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL softc (provider=%s)."
operator|,
name|pp
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_DESTROY
operator|)
operator|!=
literal|0
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_DESTROYING
operator|)
operator|!=
literal|0
operator|||
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_disks
argument_list|)
condition|)
block|{
if|if
condition|(
name|acr
operator|>
literal|0
operator|||
name|acw
operator|>
literal|0
operator|||
name|ace
operator|>
literal|0
condition|)
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|sc
operator|->
name|sc_provider_open
operator|+=
name|acr
operator|+
name|acw
operator|+
name|ace
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|acw
operator|+
name|acw
operator|==
literal|0
condition|)
name|g_mirror_idle
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_DESTROYING
operator|)
operator|!=
literal|0
operator|&&
name|sc
operator|->
name|sc_provider_open
operator|==
literal|0
condition|)
name|g_post_event
argument_list|(
name|g_mirror_destroy_delayed
argument_list|,
name|sc
argument_list|,
name|M_WAITOK
argument_list|,
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|end
label|:
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|g_geom
modifier|*
name|g_mirror_create
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
specifier|const
name|struct
name|g_mirror_metadata
modifier|*
name|md
parameter_list|,
name|u_int
name|type
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|timeout
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Creating device %s (id=%u)."
argument_list|,
name|md
operator|->
name|md_name
argument_list|,
name|md
operator|->
name|md_mid
argument_list|)
expr_stmt|;
comment|/* One disk is minimum. */
if|if
condition|(
name|md
operator|->
name|md_all
operator|<
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Action geom. 	 */
name|gp
operator|=
name|g_new_geomf
argument_list|(
name|mp
argument_list|,
literal|"%s"
argument_list|,
name|md
operator|->
name|md_name
argument_list|)
expr_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_MIRROR
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|gp
operator|->
name|start
operator|=
name|g_mirror_start
expr_stmt|;
name|gp
operator|->
name|orphan
operator|=
name|g_mirror_orphan
expr_stmt|;
name|gp
operator|->
name|access
operator|=
name|g_mirror_access
expr_stmt|;
name|gp
operator|->
name|dumpconf
operator|=
name|g_mirror_dumpconf
expr_stmt|;
name|sc
operator|->
name|sc_type
operator|=
name|type
expr_stmt|;
name|sc
operator|->
name|sc_id
operator|=
name|md
operator|->
name|md_mid
expr_stmt|;
name|sc
operator|->
name|sc_slice
operator|=
name|md
operator|->
name|md_slice
expr_stmt|;
name|sc
operator|->
name|sc_balance
operator|=
name|md
operator|->
name|md_balance
expr_stmt|;
name|sc
operator|->
name|sc_mediasize
operator|=
name|md
operator|->
name|md_mediasize
expr_stmt|;
name|sc
operator|->
name|sc_sectorsize
operator|=
name|md
operator|->
name|md_sectorsize
expr_stmt|;
name|sc
operator|->
name|sc_ndisks
operator|=
name|md
operator|->
name|md_all
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
name|md
operator|->
name|md_mflags
expr_stmt|;
name|sc
operator|->
name|sc_bump_id
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_idle
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_last_write
operator|=
name|time_uptime
expr_stmt|;
name|sc
operator|->
name|sc_writes
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_refcnt
operator|=
literal|1
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
literal|"gmirror:lock"
argument_list|)
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|,
literal|"gmirror:queue"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_regular_delayed
argument_list|)
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_inflight
argument_list|)
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_sync_delayed
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_disks
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_events
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|,
literal|"gmirror:events"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_done_mtx
argument_list|,
literal|"gmirror:done"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|G_MIRROR_DEVICE_STATE_STARTING
expr_stmt|;
name|gp
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_geom
operator|=
name|gp
expr_stmt|;
name|sc
operator|->
name|sc_provider
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_provider_open
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Synchronization geom. 	 */
name|gp
operator|=
name|g_new_geomf
argument_list|(
name|mp
argument_list|,
literal|"%s.sync"
argument_list|,
name|md
operator|->
name|md_name
argument_list|)
expr_stmt|;
name|gp
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
name|gp
operator|->
name|orphan
operator|=
name|g_mirror_orphan
expr_stmt|;
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
operator|=
name|gp
expr_stmt|;
name|sc
operator|->
name|sc_sync
operator|.
name|ds_ndisks
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|kproc_create
argument_list|(
name|g_mirror_worker
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_worker
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"g_mirror %s"
argument_list|,
name|md
operator|->
name|md_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Cannot create kernel thread for %s."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|g_destroy_geom
argument_list|(
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
argument_list|)
expr_stmt|;
name|g_destroy_geom
argument_list|(
name|sc
operator|->
name|sc_geom
argument_list|)
expr_stmt|;
name|g_mirror_free_device
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Device %s created (%u components, id=%u)."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|sc
operator|->
name|sc_ndisks
argument_list|,
name|sc
operator|->
name|sc_id
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rootmount
operator|=
name|root_mount_hold
argument_list|(
literal|"GMIRROR"
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"root_mount_hold %p"
argument_list|,
name|sc
operator|->
name|sc_rootmount
argument_list|)
expr_stmt|;
comment|/* 	 * Run timeout. 	 */
name|timeout
operator|=
name|g_mirror_timeout
operator|*
name|hz
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|,
name|timeout
argument_list|,
name|g_mirror_go
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|->
name|sc_geom
operator|)
return|;
block|}
end_function

begin_function
name|int
name|g_mirror_destroy
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_provider_open
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|G_MIRROR_DESTROY_SOFT
case|:
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Device %s is still open (%d)."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|sc
operator|->
name|sc_provider_open
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
case|case
name|G_MIRROR_DESTROY_DELAYED
case|:
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Device %s will be destroyed on last close."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
condition|)
block|{
name|g_mirror_sync_stop
argument_list|(
name|disk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|sc
operator|->
name|sc_flags
operator||=
name|G_MIRROR_DEVICE_FLAG_DESTROYING
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
case|case
name|G_MIRROR_DESTROY_HARD
case|:
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Device %s is still open, so it "
literal|"can't be definitely removed."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
block|}
block|}
name|g_topology_lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_geom
operator|->
name|softc
operator|==
name|NULL
condition|)
block|{
name|g_topology_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sc
operator|->
name|sc_geom
operator|->
name|softc
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
operator|->
name|softc
operator|=
name|NULL
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|G_MIRROR_DEVICE_FLAG_DESTROY
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|G_MIRROR_DEVICE_FLAG_WAIT
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Waking up %p."
argument_list|,
name|__func__
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Sleeping %p."
argument_list|,
name|__func__
argument_list|,
operator|&
name|sc
operator|->
name|sc_worker
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|sc_worker
operator|!=
name|NULL
condition|)
name|tsleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_worker
argument_list|,
name|PRIBIO
argument_list|,
literal|"m:destroy"
argument_list|,
name|hz
operator|/
literal|5
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Woken up %p."
argument_list|,
name|__func__
argument_list|,
operator|&
name|sc
operator|->
name|sc_worker
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|g_mirror_destroy_device
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_taste_orphan
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|KASSERT
argument_list|(
literal|1
operator|==
literal|0
argument_list|,
operator|(
literal|"%s called while tasting %s."
operator|,
name|__func__
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|g_geom
modifier|*
name|g_mirror_taste
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|flags
name|__unused
parameter_list|)
block|{
name|struct
name|g_mirror_metadata
name|md
decl_stmt|;
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"%s(%s, %s)"
argument_list|,
name|__func__
argument_list|,
name|mp
operator|->
name|name
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Tasting %s."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|gp
operator|=
name|g_new_geomf
argument_list|(
name|mp
argument_list|,
literal|"mirror:taste"
argument_list|)
expr_stmt|;
comment|/* 	 * This orphan function should be never called. 	 */
name|gp
operator|->
name|orphan
operator|=
name|g_mirror_taste_orphan
expr_stmt|;
name|cp
operator|=
name|g_new_consumer
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|g_attach
argument_list|(
name|cp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_mirror_read_metadata
argument_list|(
name|cp
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_geom
argument_list|(
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|gp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|md
operator|.
name|md_provider
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
operator|!
name|g_compare_names
argument_list|(
name|md
operator|.
name|md_provider
argument_list|,
name|pp
operator|->
name|name
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|md
operator|.
name|md_provsize
operator|!=
literal|0
operator|&&
name|md
operator|.
name|md_provsize
operator|!=
name|pp
operator|->
name|mediasize
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|md
operator|.
name|md_dflags
operator|&
name|G_MIRROR_DISK_FLAG_INACTIVE
operator|)
operator|!=
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: provider %s marked as inactive, skipping."
argument_list|,
name|md
operator|.
name|md_name
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|g_mirror_debug
operator|>=
literal|2
condition|)
name|mirror_metadata_dump
argument_list|(
operator|&
name|md
argument_list|)
expr_stmt|;
comment|/* 	 * Let's check if device already exists. 	 */
name|sc
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|gp
argument_list|,
argument|&mp->geom
argument_list|,
argument|geom
argument_list|)
block|{
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|sc
operator|->
name|sc_type
operator|!=
name|G_MIRROR_TYPE_AUTOMATIC
condition|)
continue|continue;
if|if
condition|(
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
operator|==
name|gp
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|md
operator|.
name|md_name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|md
operator|.
name|md_mid
operator|!=
name|sc
operator|->
name|sc_id
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s already configured."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
block|}
if|if
condition|(
name|gp
operator|==
name|NULL
condition|)
block|{
name|gp
operator|=
name|g_mirror_create
argument_list|(
name|mp
argument_list|,
operator|&
name|md
argument_list|,
name|G_MIRROR_TYPE_AUTOMATIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|==
name|NULL
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot create device %s."
argument_list|,
name|md
operator|.
name|md_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
block|}
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Adding disk %s to %s."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|gp
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|G_MIRROR_DEVICE_FLAG_TASTING
expr_stmt|;
name|error
operator|=
name|g_mirror_add_disk
argument_list|(
name|sc
argument_list|,
name|pp
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot add disk %s to %s (error=%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|gp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_disks
argument_list|)
condition|)
block|{
name|g_cancel_event
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|g_mirror_destroy
argument_list|(
name|sc
argument_list|,
name|G_MIRROR_DESTROY_HARD
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|gp
operator|=
name|NULL
expr_stmt|;
block|}
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|G_MIRROR_DEVICE_FLAG_TASTING
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_DESTROY
operator|)
operator|!=
literal|0
condition|)
block|{
name|g_mirror_destroy
argument_list|(
name|sc
argument_list|,
name|G_MIRROR_DESTROY_HARD
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
return|return
operator|(
name|gp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_resize
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"%s(%s)"
argument_list|,
name|__func__
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
name|disk
operator|=
name|cp
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
return|return;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|g_mirror_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_mirror_destroy_geom
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
name|__unused
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
name|__unused
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|g_cancel_event
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_mirror_destroy
argument_list|(
name|gp
operator|->
name|softc
argument_list|,
name|G_MIRROR_DESTROY_SOFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_dumpconf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
comment|/* Skip synchronization geom. */
if|if
condition|(
name|gp
operator|==
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
condition|)
return|return;
if|if
condition|(
name|pp
operator|!=
name|NULL
condition|)
block|{
comment|/* Nothing here. */
block|}
elseif|else
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|disk
operator|=
name|cp
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
return|return;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<ID>%u</ID>\n"
argument_list|,
name|indent
argument_list|,
operator|(
name|u_int
operator|)
name|disk
operator|->
name|d_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Synchronized>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset
operator|==
literal|0
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"0%%"
argument_list|)
expr_stmt|;
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%u%%"
argument_list|,
call|(
name|u_int
call|)
argument_list|(
operator|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset
operator|*
literal|100
operator|)
operator|/
name|sc
operator|->
name|sc_provider
operator|->
name|mediasize
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</Synchronized>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset
operator|>
literal|0
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<BytesSynced>%jd"
literal|"</BytesSynced>\n"
argument_list|,
name|indent
argument_list|,
operator|(
name|intmax_t
operator|)
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset
argument_list|)
expr_stmt|;
block|}
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<SyncID>%u</SyncID>\n"
argument_list|,
name|indent
argument_list|,
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<GenID>%u</GenID>\n"
argument_list|,
name|indent
argument_list|,
name|disk
operator|->
name|d_genid
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Flags>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_flags
operator|==
literal|0
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"NONE"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
define|#
directive|define
name|ADD_FLAG
parameter_list|(
name|flag
parameter_list|,
name|name
parameter_list|)
value|do {					\ 	if ((disk->d_flags& (flag)) != 0) {				\ 		if (!first)						\ 			sbuf_printf(sb, ", ");				\ 		else							\ 			first = 0;					\ 		sbuf_printf(sb, name);					\ 	}								\ } while (0)
name|ADD_FLAG
argument_list|(
name|G_MIRROR_DISK_FLAG_DIRTY
argument_list|,
literal|"DIRTY"
argument_list|)
expr_stmt|;
name|ADD_FLAG
argument_list|(
name|G_MIRROR_DISK_FLAG_HARDCODED
argument_list|,
literal|"HARDCODED"
argument_list|)
expr_stmt|;
name|ADD_FLAG
argument_list|(
name|G_MIRROR_DISK_FLAG_INACTIVE
argument_list|,
literal|"INACTIVE"
argument_list|)
expr_stmt|;
name|ADD_FLAG
argument_list|(
name|G_MIRROR_DISK_FLAG_SYNCHRONIZING
argument_list|,
literal|"SYNCHRONIZING"
argument_list|)
expr_stmt|;
name|ADD_FLAG
argument_list|(
name|G_MIRROR_DISK_FLAG_FORCE_SYNC
argument_list|,
literal|"FORCE_SYNC"
argument_list|)
expr_stmt|;
name|ADD_FLAG
argument_list|(
name|G_MIRROR_DISK_FLAG_BROKEN
argument_list|,
literal|"BROKEN"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ADD_FLAG
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</Flags>\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Priority>%u</Priority>\n"
argument_list|,
name|indent
argument_list|,
name|disk
operator|->
name|d_priority
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<State>%s</State>\n"
argument_list|,
name|indent
argument_list|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Type>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_type
condition|)
block|{
case|case
name|G_MIRROR_TYPE_AUTOMATIC
case|:
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"AUTOMATIC"
argument_list|)
expr_stmt|;
break|break;
case|case
name|G_MIRROR_TYPE_MANUAL
case|:
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"MANUAL"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"UNKNOWN"
argument_list|)
expr_stmt|;
break|break;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</Type>\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<ID>%u</ID>\n"
argument_list|,
name|indent
argument_list|,
operator|(
name|u_int
operator|)
name|sc
operator|->
name|sc_id
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<SyncID>%u</SyncID>\n"
argument_list|,
name|indent
argument_list|,
name|sc
operator|->
name|sc_syncid
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<GenID>%u</GenID>\n"
argument_list|,
name|indent
argument_list|,
name|sc
operator|->
name|sc_genid
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Flags>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|==
literal|0
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"NONE"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
define|#
directive|define
name|ADD_FLAG
parameter_list|(
name|flag
parameter_list|,
name|name
parameter_list|)
value|do {					\ 	if ((sc->sc_flags& (flag)) != 0) {				\ 		if (!first)						\ 			sbuf_printf(sb, ", ");				\ 		else							\ 			first = 0;					\ 		sbuf_printf(sb, name);					\ 	}								\ } while (0)
name|ADD_FLAG
argument_list|(
name|G_MIRROR_DEVICE_FLAG_NOFAILSYNC
argument_list|,
literal|"NOFAILSYNC"
argument_list|)
expr_stmt|;
name|ADD_FLAG
argument_list|(
name|G_MIRROR_DEVICE_FLAG_NOAUTOSYNC
argument_list|,
literal|"NOAUTOSYNC"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ADD_FLAG
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</Flags>\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Slice>%u</Slice>\n"
argument_list|,
name|indent
argument_list|,
operator|(
name|u_int
operator|)
name|sc
operator|->
name|sc_slice
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Balance>%s</Balance>\n"
argument_list|,
name|indent
argument_list|,
name|balance_name
argument_list|(
name|sc
operator|->
name|sc_balance
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Components>%u</Components>\n"
argument_list|,
name|indent
argument_list|,
name|sc
operator|->
name|sc_ndisks
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<State>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|G_MIRROR_DEVICE_STATE_STARTING
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s"
argument_list|,
literal|"STARTING"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_ndisks
operator|==
name|g_mirror_ndisks
argument_list|(
name|sc
argument_list|,
name|G_MIRROR_DISK_STATE_ACTIVE
argument_list|)
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s"
argument_list|,
literal|"COMPLETE"
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s"
argument_list|,
literal|"DEGRADED"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</State>\n"
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_shutdown_post_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
block|{
name|struct
name|g_class
modifier|*
name|mp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|,
modifier|*
name|gp2
decl_stmt|;
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|panicstr
operator|!=
name|NULL
condition|)
return|return;
name|mp
operator|=
name|arg
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_mirror_shutdown
operator|=
literal|1
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|gp
argument_list|,
argument|&mp->geom
argument_list|,
argument|geom
argument_list|,
argument|gp2
argument_list|)
block|{
if|if
condition|(
operator|(
name|sc
operator|=
name|gp
operator|->
name|softc
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Skip synchronization geom. */
if|if
condition|(
name|gp
operator|==
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
condition|)
continue|continue;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|g_mirror_idle
argument_list|(
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_cancel_event
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_mirror_destroy
argument_list|(
name|sc
argument_list|,
name|G_MIRROR_DESTROY_DELAYED
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
block|}
name|g_topology_unlock
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_init
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
block|{
name|g_mirror_post_sync
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_post_sync
argument_list|,
name|g_mirror_shutdown_post_sync
argument_list|,
name|mp
argument_list|,
name|SHUTDOWN_PRI_FIRST
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_mirror_post_sync
operator|==
name|NULL
condition|)
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Warning! Cannot register shutdown event."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_fini
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
block|{
if|if
condition|(
name|g_mirror_post_sync
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|shutdown_post_sync
argument_list|,
name|g_mirror_post_sync
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|DECLARE_GEOM_CLASS
argument_list|(
name|g_mirror_class
argument_list|,
name|g_mirror
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

