begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004 Pawel Jakub Dawidek<pjd@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<geom/mirror/g_mirror.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_MIRROR
argument_list|,
literal|"mirror data"
argument_list|,
literal|"GEOM_MIRROR Data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_kern_geom
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern_geom
argument_list|,
name|OID_AUTO
argument_list|,
name|mirror
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"GEOM_MIRROR stuff"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_int
name|g_mirror_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.geom.mirror.debug"
argument_list|,
operator|&
name|g_mirror_debug
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_mirror
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_mirror_debug
argument_list|,
literal|0
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_mirror_timeout
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.geom.mirror.timeout"
argument_list|,
operator|&
name|g_mirror_timeout
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_mirror
argument_list|,
name|OID_AUTO
argument_list|,
name|timeout
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_mirror_timeout
argument_list|,
literal|0
argument_list|,
literal|"Time to wait on all mirror components"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_mirror_idletime
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"kern.geom.mirror.idletime"
argument_list|,
operator|&
name|g_mirror_idletime
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_mirror
argument_list|,
name|OID_AUTO
argument_list|,
name|idletime
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_mirror_idletime
argument_list|,
literal|0
argument_list|,
literal|"Mark components as clean when idling"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_mirror_reqs_per_sync
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_mirror
argument_list|,
name|OID_AUTO
argument_list|,
name|reqs_per_sync
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_mirror_reqs_per_sync
argument_list|,
literal|0
argument_list|,
literal|"Number of regular I/O requests per synchronization request"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_mirror_syncs_per_sec
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_mirror
argument_list|,
name|OID_AUTO
argument_list|,
name|syncs_per_sec
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|g_mirror_syncs_per_sec
argument_list|,
literal|0
argument_list|,
literal|"Number of synchronizations requests per second"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MSLEEP
parameter_list|(
name|ident
parameter_list|,
name|mtx
parameter_list|,
name|priority
parameter_list|,
name|wmesg
parameter_list|,
name|timeout
parameter_list|)
value|do {		\ 	G_MIRROR_DEBUG(4, "%s: Sleeping %p.", __func__, (ident));	\ 	msleep((ident), (mtx), (priority), (wmesg), (timeout));		\ 	G_MIRROR_DEBUG(4, "%s: Woken up %p.", __func__, (ident));	\ } while (0)
end_define

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|g_mirror_ehtag
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|g_mirror_destroy_geom
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|g_taste_t
name|g_mirror_taste
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|g_mirror_init
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_mirror_fini
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|g_class
name|g_mirror_class
init|=
block|{
operator|.
name|name
operator|=
name|G_MIRROR_CLASS_NAME
block|,
operator|.
name|version
operator|=
name|G_VERSION
block|,
operator|.
name|ctlreq
operator|=
name|g_mirror_config
block|,
operator|.
name|taste
operator|=
name|g_mirror_taste
block|,
operator|.
name|destroy_geom
operator|=
name|g_mirror_destroy_geom
block|,
operator|.
name|init
operator|=
name|g_mirror_init
block|,
operator|.
name|fini
operator|=
name|g_mirror_fini
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|g_mirror_destroy_provider
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_mirror_update_disk
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|,
name|u_int
name|state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_mirror_update_device
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|boolean_t
name|force
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_mirror_dumpconf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_mirror_sync_stop
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|g_mirror_disk_state2str
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|G_MIRROR_DISK_STATE_NONE
case|:
return|return
operator|(
literal|"NONE"
operator|)
return|;
case|case
name|G_MIRROR_DISK_STATE_NEW
case|:
return|return
operator|(
literal|"NEW"
operator|)
return|;
case|case
name|G_MIRROR_DISK_STATE_ACTIVE
case|:
return|return
operator|(
literal|"ACTIVE"
operator|)
return|;
case|case
name|G_MIRROR_DISK_STATE_STALE
case|:
return|return
operator|(
literal|"STALE"
operator|)
return|;
case|case
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
case|:
return|return
operator|(
literal|"SYNCHRONIZING"
operator|)
return|;
case|case
name|G_MIRROR_DISK_STATE_DISCONNECTED
case|:
return|return
operator|(
literal|"DISCONNECTED"
operator|)
return|;
case|case
name|G_MIRROR_DISK_STATE_DESTROY
case|:
return|return
operator|(
literal|"DESTROY"
operator|)
return|;
default|default:
return|return
operator|(
literal|"INVALID"
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|g_mirror_device_state2str
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|G_MIRROR_DEVICE_STATE_STARTING
case|:
return|return
operator|(
literal|"STARTING"
operator|)
return|;
case|case
name|G_MIRROR_DEVICE_STATE_RUNNING
case|:
return|return
operator|(
literal|"RUNNING"
operator|)
return|;
default|default:
return|return
operator|(
literal|"INVALID"
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|g_mirror_get_diskname
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_consumer
operator|==
name|NULL
operator|||
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"[unknown]"
operator|)
return|;
return|return
operator|(
name|disk
operator|->
name|d_name
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * --- Events handling functions ---  * Events in geom_mirror are used to maintain disks and device status  * from one thread to simplify locking.  */
end_comment

begin_function
specifier|static
name|void
name|g_mirror_event_free
parameter_list|(
name|struct
name|g_mirror_event
modifier|*
name|ep
parameter_list|)
block|{
name|free
argument_list|(
name|ep
argument_list|,
name|M_MIRROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|g_mirror_event_send
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|state
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_mirror_event
modifier|*
name|ep
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ep
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
argument_list|,
name|M_MIRROR
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Sending event %p."
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|G_MIRROR_EVENT_DEVICE
operator|)
operator|!=
literal|0
condition|)
block|{
name|disk
operator|=
name|NULL
expr_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
block|}
else|else
block|{
name|disk
operator|=
name|arg
expr_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
block|}
name|ep
operator|->
name|e_disk
operator|=
name|disk
expr_stmt|;
name|ep
operator|->
name|e_state
operator|=
name|state
expr_stmt|;
name|ep
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|ep
operator|->
name|e_error
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_events
argument_list|,
name|ep
argument_list|,
name|e_next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Waking up %p."
argument_list|,
name|__func__
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|G_MIRROR_EVENT_DONTWAIT
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Sleeping %p."
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_MIRROR_EVENT_DONE
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|MSLEEP
argument_list|(
name|ep
argument_list|,
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|,
name|PRIBIO
operator||
name|PDROP
argument_list|,
literal|"m:event"
argument_list|,
name|hz
operator|*
literal|5
argument_list|)
expr_stmt|;
block|}
comment|/* Don't even try to use 'sc' here, because it could be already dead. */
name|g_topology_lock
argument_list|()
expr_stmt|;
name|error
operator|=
name|ep
operator|->
name|e_error
expr_stmt|;
name|g_mirror_event_free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|g_mirror_event
modifier|*
name|g_mirror_event_get
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_mirror_event
modifier|*
name|ep
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|ep
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_events
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_events
argument_list|,
name|ep
argument_list|,
name|e_next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ep
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_event_cancel
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_mirror_event
modifier|*
name|ep
decl_stmt|,
modifier|*
name|tmpep
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ep
argument_list|,
argument|&sc->sc_events
argument_list|,
argument|e_next
argument_list|,
argument|tmpep
argument_list|)
block|{
if|if
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_MIRROR_EVENT_DEVICE
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ep
operator|->
name|e_disk
operator|!=
name|disk
condition|)
continue|continue;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_events
argument_list|,
name|ep
argument_list|,
name|e_next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_MIRROR_EVENT_DONTWAIT
operator|)
operator|!=
literal|0
condition|)
name|g_mirror_event_free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
else|else
block|{
name|ep
operator|->
name|e_error
operator|=
name|ECANCELED
expr_stmt|;
name|wakeup
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the number of disks in given state.  * If state is equal to -1, count all connected disks.  */
end_comment

begin_function
name|u_int
name|g_mirror_ndisks
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|u_int
name|n
init|=
literal|0
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|state
operator|==
operator|-
literal|1
operator|||
name|disk
operator|->
name|d_state
operator|==
name|state
condition|)
name|n
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a disk in mirror by its disk ID.  */
end_comment

begin_function
specifier|static
name|struct
name|g_mirror_disk
modifier|*
name|g_mirror_id2disk
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|id
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_id
operator|==
name|id
condition|)
return|return
operator|(
name|disk
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|g_mirror_nrequests
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|u_int
name|nreqs
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&sc->sc_queue.queue
argument_list|,
argument|bio_queue
argument_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_from
operator|==
name|cp
condition|)
name|nreqs
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|nreqs
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_mirror_is_busy
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
if|if
condition|(
name|cp
operator|->
name|index
operator|>
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"I/O requests for %s exist, can't destroy it now."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|g_mirror_nrequests
argument_list|(
name|sc
argument_list|,
name|cp
argument_list|)
operator|>
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"I/O requests for %s in queue, can't destroy it now."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_destroy_consumer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
name|__unused
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|arg
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Consumer %s destroyed."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_kill_consumer
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|int
name|retaste_wait
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|cp
operator|->
name|private
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|g_mirror_is_busy
argument_list|(
name|sc
argument_list|,
name|cp
argument_list|)
condition|)
return|return;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|retaste_wait
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|acw
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|pp
operator|->
name|geom
operator|->
name|flags
operator|&
name|G_GEOM_WITHER
operator|)
operator|==
literal|0
condition|)
name|retaste_wait
operator|=
literal|1
expr_stmt|;
block|}
name|G_MIRROR_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Access %s r%dw%de%d = %d"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
operator|-
name|cp
operator|->
name|acr
argument_list|,
operator|-
name|cp
operator|->
name|acw
argument_list|,
operator|-
name|cp
operator|->
name|ace
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|acr
operator|>
literal|0
operator|||
name|cp
operator|->
name|acw
operator|>
literal|0
operator|||
name|cp
operator|->
name|ace
operator|>
literal|0
condition|)
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
name|cp
operator|->
name|acr
argument_list|,
operator|-
name|cp
operator|->
name|acw
argument_list|,
operator|-
name|cp
operator|->
name|ace
argument_list|)
expr_stmt|;
if|if
condition|(
name|retaste_wait
condition|)
block|{
comment|/* 		 * After retaste event was send (inside g_access()), we can send 		 * event to detach and destroy consumer. 		 * A class, which has consumer to the given provider connected 		 * will not receive retaste event for the provider. 		 * This is the way how I ignore retaste events when I close 		 * consumers opened for write: I detach and destroy consumer 		 * after retaste event is sent. 		 */
name|g_post_event
argument_list|(
name|g_mirror_destroy_consumer
argument_list|,
name|cp
argument_list|,
name|M_WAITOK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Consumer %s destroyed."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_mirror_connect_disk
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_consumer
operator|==
name|NULL
argument_list|,
operator|(
literal|"Disk already connected (device %s)."
operator|,
name|disk
operator|->
name|d_softc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|=
name|g_new_consumer
argument_list|(
name|disk
operator|->
name|d_softc
operator|->
name|sc_geom
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|->
name|private
operator|=
name|disk
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|g_attach
argument_list|(
name|disk
operator|->
name|d_consumer
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|g_access
argument_list|(
name|disk
operator|->
name|d_consumer
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot open consumer %s (error=%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|G_MIRROR_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Disk %s connected."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_disconnect_consumer
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|g_topology_assert
argument_list|()
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|cp
operator|->
name|provider
operator|!=
name|NULL
condition|)
name|g_mirror_kill_consumer
argument_list|(
name|sc
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize disk. This means allocate memory, create consumer, attach it  * to the provider and open access (r1w1e1) to it.  */
end_comment

begin_function
specifier|static
name|struct
name|g_mirror_disk
modifier|*
name|g_mirror_init_disk
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|struct
name|g_mirror_metadata
modifier|*
name|md
parameter_list|,
name|int
modifier|*
name|errorp
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|int
name|error
decl_stmt|;
name|disk
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|disk
argument_list|)
argument_list|,
name|M_MIRROR
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|disk
operator|->
name|d_softc
operator|=
name|sc
expr_stmt|;
name|error
operator|=
name|g_mirror_connect_disk
argument_list|(
name|disk
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|disk
operator|->
name|d_id
operator|=
name|md
operator|->
name|md_did
expr_stmt|;
name|disk
operator|->
name|d_state
operator|=
name|G_MIRROR_DISK_STATE_NONE
expr_stmt|;
name|disk
operator|->
name|d_priority
operator|=
name|md
operator|->
name|md_priority
expr_stmt|;
name|disk
operator|->
name|d_delay
operator|.
name|sec
operator|=
literal|0
expr_stmt|;
name|disk
operator|->
name|d_delay
operator|.
name|frac
operator|=
literal|0
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|disk
operator|->
name|d_last_used
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_flags
operator|=
name|md
operator|->
name|md_dflags
expr_stmt|;
if|if
condition|(
name|md
operator|->
name|md_provider
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|disk
operator|->
name|d_flags
operator||=
name|G_MIRROR_DISK_FLAG_HARDCODED
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|=
name|NULL
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset
operator|=
name|md
operator|->
name|md_sync_offset
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset_done
operator|=
name|md
operator|->
name|md_sync_offset
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_resync
operator|=
operator|-
literal|1
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|=
name|md
operator|->
name|md_syncid
expr_stmt|;
if|if
condition|(
name|errorp
operator|!=
name|NULL
condition|)
operator|*
name|errorp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|disk
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|errorp
operator|!=
name|NULL
condition|)
operator|*
name|errorp
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|disk
operator|!=
name|NULL
condition|)
block|{
name|g_mirror_disconnect_consumer
argument_list|(
name|sc
argument_list|,
name|disk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|disk
argument_list|,
name|M_MIRROR
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_destroy_disk
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|disk
argument_list|,
name|d_next
argument_list|)
expr_stmt|;
name|g_mirror_event_cancel
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hint
operator|==
name|disk
condition|)
name|sc
operator|->
name|sc_hint
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|disk
operator|->
name|d_state
condition|)
block|{
case|case
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
case|:
name|g_mirror_sync_stop
argument_list|(
name|disk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|G_MIRROR_DISK_STATE_NEW
case|:
case|case
name|G_MIRROR_DISK_STATE_STALE
case|:
case|case
name|G_MIRROR_DISK_STATE_ACTIVE
case|:
name|g_mirror_disconnect_consumer
argument_list|(
name|sc
argument_list|,
name|disk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|disk
argument_list|,
name|M_MIRROR
argument_list|)
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
literal|0
operator|==
literal|1
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_destroy_device
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_mirror_event
modifier|*
name|ep
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|,
modifier|*
name|tmpcp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|gp
operator|=
name|sc
operator|->
name|sc_geom
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_provider
operator|!=
name|NULL
condition|)
name|g_mirror_destroy_provider
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|disk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_disks
argument_list|)
init|;
name|disk
operator|!=
name|NULL
condition|;
name|disk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_disks
argument_list|)
control|)
block|{
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_MIRROR_DISK_FLAG_DIRTY
expr_stmt|;
name|g_mirror_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|g_mirror_destroy_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ep
operator|=
name|g_mirror_event_get
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_MIRROR_EVENT_DONTWAIT
operator|)
operator|!=
literal|0
condition|)
name|g_mirror_event_free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
else|else
block|{
name|ep
operator|->
name|e_error
operator|=
name|ECANCELED
expr_stmt|;
name|ep
operator|->
name|e_flags
operator||=
name|G_MIRROR_EVENT_DONE
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Waking up %p."
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
block|}
block|}
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|)
expr_stmt|;
name|gp
operator|->
name|softc
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|cp
argument_list|,
argument|&sc->sc_sync.ds_geom->consumer
argument_list|,
argument|consumer
argument_list|,
argument|tmpcp
argument_list|)
block|{
name|g_mirror_disconnect_consumer
argument_list|(
name|sc
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
operator|->
name|softc
operator|=
name|NULL
expr_stmt|;
name|g_wither_geom
argument_list|(
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s destroyed."
argument_list|,
name|gp
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_wither_geom
argument_list|(
name|gp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_orphan
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|disk
operator|=
name|cp
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
return|return;
name|disk
operator|->
name|d_softc
operator|->
name|sc_bump_syncid
operator|=
name|G_MIRROR_BUMP_ON_FIRST_WRITE
expr_stmt|;
name|g_mirror_event_send
argument_list|(
name|disk
argument_list|,
name|G_MIRROR_DISK_STATE_DISCONNECTED
argument_list|,
name|G_MIRROR_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_spoiled
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|disk
operator|=
name|cp
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
return|return;
name|disk
operator|->
name|d_softc
operator|->
name|sc_bump_syncid
operator|=
name|G_MIRROR_BUMP_IMMEDIATELY
expr_stmt|;
name|g_mirror_event_send
argument_list|(
name|disk
argument_list|,
name|G_MIRROR_DISK_STATE_DISCONNECTED
argument_list|,
name|G_MIRROR_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function should return the next active disk on the list.  * It is possible that it will be the same disk as given.  * If there are no active disks on list, NULL is returned.  */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|g_mirror_disk
operator|*
name|g_mirror_find_next
argument_list|(
argument|struct g_mirror_softc *sc
argument_list|,
argument|struct g_mirror_disk *disk
argument_list|)
block|{ 	struct
name|g_mirror_disk
operator|*
name|dp
block|;
for|for
control|(
name|dp
operator|=
name|LIST_NEXT
argument_list|(
name|disk
argument_list|,
name|d_next
argument_list|)
init|;
name|dp
operator|!=
name|disk
condition|;
name|dp
operator|=
name|LIST_NEXT
argument_list|(
name|dp
argument_list|,
name|d_next
argument_list|)
control|)
block|{
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
name|dp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_disks
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_ACTIVE
condition|)
break|break;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|dp
operator|->
name|d_state
operator|!=
name|G_MIRROR_DISK_STATE_ACTIVE
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
end_if

begin_return
return|return
operator|(
name|dp
operator|)
return|;
end_return

begin_function
unit|}  static
name|struct
name|g_mirror_disk
modifier|*
name|g_mirror_get_disk
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hint
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_hint
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_disks
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_hint
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|disk
operator|=
name|sc
operator|->
name|sc_hint
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_MIRROR_DISK_STATE_ACTIVE
condition|)
block|{
name|disk
operator|=
name|g_mirror_find_next
argument_list|(
name|sc
argument_list|,
name|disk
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sc
operator|->
name|sc_hint
operator|=
name|g_mirror_find_next
argument_list|(
name|sc
argument_list|,
name|disk
argument_list|)
expr_stmt|;
return|return
operator|(
name|disk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_mirror_write_metadata
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|,
name|struct
name|g_mirror_metadata
modifier|*
name|md
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|off_t
name|offset
decl_stmt|,
name|length
decl_stmt|;
name|u_char
modifier|*
name|sector
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL consumer (%s)."
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|->
name|provider
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL provider (%s)."
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|->
name|acr
operator|==
literal|1
operator|&&
name|cp
operator|->
name|acw
operator|==
literal|1
operator|&&
name|cp
operator|->
name|ace
operator|==
literal|1
argument_list|,
operator|(
literal|"Consumer %s closed? (r%dw%de%d)."
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|,
name|cp
operator|->
name|acr
operator|,
name|cp
operator|->
name|acw
operator|,
name|cp
operator|->
name|ace
operator|)
argument_list|)
expr_stmt|;
name|length
operator|=
name|cp
operator|->
name|provider
operator|->
name|sectorsize
expr_stmt|;
name|offset
operator|=
name|cp
operator|->
name|provider
operator|->
name|mediasize
operator|-
name|length
expr_stmt|;
name|sector
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|length
argument_list|,
name|M_MIRROR
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|!=
name|NULL
condition|)
name|mirror_metadata_encode
argument_list|(
name|md
argument_list|,
name|sector
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|error
operator|=
name|g_write_data
argument_list|(
name|cp
argument_list|,
name|offset
argument_list|,
name|sector
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|sector
argument_list|,
name|M_MIRROR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|disk
operator|->
name|d_softc
operator|->
name|sc_bump_syncid
operator|=
name|G_MIRROR_BUMP_IMMEDIATELY
expr_stmt|;
name|g_mirror_event_send
argument_list|(
name|disk
argument_list|,
name|G_MIRROR_DISK_STATE_DISCONNECTED
argument_list|,
name|G_MIRROR_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_mirror_clear_metadata
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|error
operator|=
name|g_mirror_write_metadata
argument_list|(
name|disk
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Metadata on %s cleared."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot clear metadata on disk %s (error=%d)."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|g_mirror_fill_metadata
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|,
name|struct
name|g_mirror_metadata
modifier|*
name|md
parameter_list|)
block|{
name|strlcpy
argument_list|(
name|md
operator|->
name|md_magic
argument_list|,
name|G_MIRROR_MAGIC
argument_list|,
sizeof|sizeof
argument_list|(
name|md
operator|->
name|md_magic
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|->
name|md_version
operator|=
name|G_MIRROR_VERSION
expr_stmt|;
name|strlcpy
argument_list|(
name|md
operator|->
name|md_name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
sizeof|sizeof
argument_list|(
name|md
operator|->
name|md_name
argument_list|)
argument_list|)
expr_stmt|;
name|md
operator|->
name|md_mid
operator|=
name|sc
operator|->
name|sc_id
expr_stmt|;
name|md
operator|->
name|md_all
operator|=
name|sc
operator|->
name|sc_ndisks
expr_stmt|;
name|md
operator|->
name|md_slice
operator|=
name|sc
operator|->
name|sc_slice
expr_stmt|;
name|md
operator|->
name|md_balance
operator|=
name|sc
operator|->
name|sc_balance
expr_stmt|;
name|md
operator|->
name|md_mediasize
operator|=
name|sc
operator|->
name|sc_mediasize
expr_stmt|;
name|md
operator|->
name|md_sectorsize
operator|=
name|sc
operator|->
name|sc_sectorsize
expr_stmt|;
name|md
operator|->
name|md_mflags
operator|=
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_MASK
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|md
operator|->
name|md_provider
argument_list|,
sizeof|sizeof
argument_list|(
name|md
operator|->
name|md_provider
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
block|{
name|md
operator|->
name|md_did
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|md
operator|->
name|md_priority
operator|=
literal|0
expr_stmt|;
name|md
operator|->
name|md_syncid
operator|=
literal|0
expr_stmt|;
name|md
operator|->
name|md_dflags
operator|=
literal|0
expr_stmt|;
name|md
operator|->
name|md_sync_offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|md
operator|->
name|md_did
operator|=
name|disk
operator|->
name|d_id
expr_stmt|;
name|md
operator|->
name|md_priority
operator|=
name|disk
operator|->
name|d_priority
expr_stmt|;
name|md
operator|->
name|md_syncid
operator|=
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
expr_stmt|;
name|md
operator|->
name|md_dflags
operator|=
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
condition|)
name|md
operator|->
name|md_sync_offset
operator|=
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset_done
expr_stmt|;
else|else
name|md
operator|->
name|md_sync_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_HARDCODED
operator|)
operator|!=
literal|0
condition|)
block|{
name|strlcpy
argument_list|(
name|md
operator|->
name|md_provider
argument_list|,
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|md
operator|->
name|md_provider
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|g_mirror_update_metadata
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_mirror_metadata
name|md
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|g_mirror_fill_metadata
argument_list|(
name|disk
operator|->
name|d_softc
argument_list|,
name|disk
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_mirror_write_metadata
argument_list|(
name|disk
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Metadata on %s updated."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot update metadata on disk %s (error=%d)."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_bump_syncid
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|g_mirror_ndisks
argument_list|(
name|sc
argument_list|,
name|G_MIRROR_DISK_STATE_ACTIVE
argument_list|)
operator|>
literal|0
argument_list|,
operator|(
literal|"%s called with no active disks (device=%s)."
operator|,
name|__func__
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_syncid
operator|++
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Device %s: syncid bumped to %u."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|sc
operator|->
name|sc_syncid
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_ACTIVE
operator|||
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
condition|)
block|{
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|=
name|sc
operator|->
name|sc_syncid
expr_stmt|;
name|g_mirror_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_idle
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_provider
operator|==
name|NULL
operator|||
name|sc
operator|->
name|sc_provider
operator|->
name|acw
operator|==
literal|0
condition|)
return|return;
name|sc
operator|->
name|sc_idle
operator|=
literal|1
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_MIRROR_DISK_STATE_ACTIVE
condition|)
continue|continue;
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Disk %s (device %s) marked as clean."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_MIRROR_DISK_FLAG_DIRTY
expr_stmt|;
name|g_mirror_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
name|g_topology_unlock
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_unidle
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|sc
operator|->
name|sc_idle
operator|=
literal|0
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_MIRROR_DISK_STATE_ACTIVE
condition|)
continue|continue;
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Disk %s (device %s) marked as dirty."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_flags
operator||=
name|G_MIRROR_DISK_FLAG_DIRTY
expr_stmt|;
name|g_mirror_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
name|g_topology_unlock
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return 1 if we should check if mirror is idling.  */
end_comment

begin_function
specifier|static
name|int
name|g_mirror_check_idle
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_idle
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_provider
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|sc_provider
operator|->
name|acw
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Check if there are no in-flight requests. 	 */
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_MIRROR_DISK_STATE_ACTIVE
condition|)
continue|continue;
if|if
condition|(
name|disk
operator|->
name|d_consumer
operator|->
name|index
operator|>
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|bintime_cmp
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt1
parameter_list|,
name|struct
name|bintime
modifier|*
name|bt2
parameter_list|)
block|{
if|if
condition|(
name|bt1
operator|->
name|sec
operator|<
name|bt2
operator|->
name|sec
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|bt1
operator|->
name|sec
operator|>
name|bt2
operator|->
name|sec
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|bt1
operator|->
name|frac
operator|<
name|bt2
operator|->
name|frac
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|bt1
operator|->
name|frac
operator|>
name|bt2
operator|->
name|frac
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_update_delay
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_softc
operator|->
name|sc_balance
operator|!=
name|G_MIRROR_BALANCE_LOAD
condition|)
return|return;
name|binuptime
argument_list|(
operator|&
name|disk
operator|->
name|d_delay
argument_list|)
expr_stmt|;
name|bintime_sub
argument_list|(
operator|&
name|disk
operator|->
name|d_delay
argument_list|,
operator|&
name|bp
operator|->
name|bio_t0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_from
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|bp
operator|->
name|bio_cflags
operator||=
name|G_MIRROR_BIO_FLAG_REGULAR
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|bioq_disksort
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_regular_request
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|bio
modifier|*
name|pbp
decl_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|bp
operator|->
name|bio_from
operator|->
name|index
operator|--
expr_stmt|;
name|pbp
operator|=
name|bp
operator|->
name|bio_parent
expr_stmt|;
name|sc
operator|=
name|pbp
operator|->
name|bio_to
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|disk
operator|=
name|bp
operator|->
name|bio_from
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
block|{
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_mirror_kill_consumer
argument_list|(
name|sc
argument_list|,
name|bp
operator|->
name|bio_from
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|g_mirror_update_delay
argument_list|(
name|disk
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
name|pbp
operator|->
name|bio_inbed
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
name|pbp
operator|->
name|bio_inbed
operator|<=
name|pbp
operator|->
name|bio_children
argument_list|,
operator|(
literal|"bio_inbed (%u) is bigger than bio_children (%u)."
operator|,
name|pbp
operator|->
name|bio_inbed
operator|,
name|pbp
operator|->
name|bio_children
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
operator|&&
name|pbp
operator|->
name|bio_error
operator|==
literal|0
condition|)
block|{
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Request delivered."
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbp
operator|->
name|bio_children
operator|==
name|pbp
operator|->
name|bio_inbed
condition|)
block|{
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|pbp
argument_list|,
literal|"Request delivered."
argument_list|)
expr_stmt|;
name|pbp
operator|->
name|bio_completed
operator|=
name|pbp
operator|->
name|bio_length
expr_stmt|;
name|g_io_deliver
argument_list|(
name|pbp
argument_list|,
name|pbp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pbp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|pbp
operator|->
name|bio_error
operator|=
name|bp
operator|->
name|bio_error
expr_stmt|;
name|G_MIRROR_LOGREQ
argument_list|(
literal|0
argument_list|,
name|bp
argument_list|,
literal|"Request failed (error=%d)."
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_bump_syncid
operator|=
name|G_MIRROR_BUMP_IMMEDIATELY
expr_stmt|;
name|g_mirror_event_send
argument_list|(
name|disk
argument_list|,
name|G_MIRROR_DISK_STATE_DISCONNECTED
argument_list|,
name|G_MIRROR_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|pbp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_DELETE
case|:
case|case
name|BIO_WRITE
case|:
name|pbp
operator|->
name|bio_inbed
operator|--
expr_stmt|;
name|pbp
operator|->
name|bio_children
operator|--
expr_stmt|;
break|break;
block|}
block|}
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pbp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
if|if
condition|(
name|pbp
operator|->
name|bio_children
operator|==
name|pbp
operator|->
name|bio_inbed
condition|)
block|{
name|pbp
operator|->
name|bio_error
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|bioq_disksort
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|pbp
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Waking up %p."
argument_list|,
name|__func__
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BIO_DELETE
case|:
case|case
name|BIO_WRITE
case|:
if|if
condition|(
name|pbp
operator|->
name|bio_children
operator|==
literal|0
condition|)
block|{
comment|/* 			 * All requests failed. 			 */
block|}
elseif|else
if|if
condition|(
name|pbp
operator|->
name|bio_inbed
operator|<
name|pbp
operator|->
name|bio_children
condition|)
block|{
comment|/* Do nothing. */
break|break;
block|}
elseif|else
if|if
condition|(
name|pbp
operator|->
name|bio_children
operator|==
name|pbp
operator|->
name|bio_inbed
condition|)
block|{
comment|/* Some requests succeeded. */
name|pbp
operator|->
name|bio_error
operator|=
literal|0
expr_stmt|;
name|pbp
operator|->
name|bio_completed
operator|=
name|pbp
operator|->
name|bio_length
expr_stmt|;
block|}
name|g_io_deliver
argument_list|(
name|pbp
argument_list|,
name|pbp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
literal|1
operator|==
literal|0
argument_list|,
operator|(
literal|"Invalid request: %u."
operator|,
name|pbp
operator|->
name|bio_cmd
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_sync_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Synchronization request delivered."
argument_list|)
expr_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_from
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|bp
operator|->
name|bio_cflags
operator||=
name|G_MIRROR_BIO_FLAG_SYNC
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|bioq_disksort
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_start
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
comment|/* 	 * If sc == NULL or there are no valid disks, provider's error 	 * should be set and g_mirror_start() should not be called at all. 	 */
name|KASSERT
argument_list|(
name|sc
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|sc_state
operator|==
name|G_MIRROR_DEVICE_STATE_RUNNING
argument_list|,
operator|(
literal|"Provider's error should be set (error=%d)(mirror=%s)."
operator|,
name|bp
operator|->
name|bio_to
operator|->
name|error
operator|,
name|bp
operator|->
name|bio_to
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Request received."
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
case|case
name|BIO_WRITE
case|:
case|case
name|BIO_DELETE
case|:
break|break;
case|case
name|BIO_GETATTR
case|:
default|default:
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
return|return;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|bioq_disksort
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Waking up %p."
argument_list|,
name|__func__
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send one synchronization request.  */
end_comment

begin_function
specifier|static
name|void
name|g_mirror_sync_one
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
argument_list|,
operator|(
literal|"Disk %s is not marked for synchronization."
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|bp
operator|=
name|g_new_bio
argument_list|()
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
return|return;
name|bp
operator|->
name|bio_parent
operator|=
name|NULL
expr_stmt|;
name|bp
operator|->
name|bio_cmd
operator|=
name|BIO_READ
expr_stmt|;
name|bp
operator|->
name|bio_offset
operator|=
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset
expr_stmt|;
name|bp
operator|->
name|bio_length
operator|=
name|MIN
argument_list|(
name|MAXPHYS
argument_list|,
name|sc
operator|->
name|sc_mediasize
operator|-
name|bp
operator|->
name|bio_offset
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_cflags
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bio_done
operator|=
name|g_mirror_sync_done
expr_stmt|;
name|bp
operator|->
name|bio_data
operator|=
name|disk
operator|->
name|d_sync
operator|.
name|ds_data
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_data
operator|==
name|NULL
condition|)
block|{
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset
operator|+=
name|bp
operator|->
name|bio_length
expr_stmt|;
name|bp
operator|->
name|bio_to
operator|=
name|sc
operator|->
name|sc_provider
expr_stmt|;
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Sending synchronization request."
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|->
name|index
operator|++
expr_stmt|;
name|g_io_request
argument_list|(
name|bp
argument_list|,
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_sync_request
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|bp
operator|->
name|bio_from
operator|->
name|index
operator|--
expr_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_from
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|disk
operator|=
name|bp
operator|->
name|bio_from
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
block|{
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_mirror_kill_consumer
argument_list|(
name|sc
argument_list|,
name|bp
operator|->
name|bio_from
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Synchronization request. 	 */
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|!=
literal|0
condition|)
block|{
name|G_MIRROR_LOGREQ
argument_list|(
literal|0
argument_list|,
name|bp
argument_list|,
literal|"Synchronization request failed (error=%d)."
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Synchronization request half-finished."
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bio_cmd
operator|=
name|BIO_WRITE
expr_stmt|;
name|bp
operator|->
name|bio_cflags
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|->
name|acr
operator|==
literal|1
operator|&&
name|cp
operator|->
name|acw
operator|==
literal|1
operator|&&
name|cp
operator|->
name|ace
operator|==
literal|1
argument_list|,
operator|(
literal|"Consumer %s not opened (r%dw%de%d)."
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|,
name|cp
operator|->
name|acr
operator|,
name|cp
operator|->
name|acw
operator|,
name|cp
operator|->
name|ace
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|index
operator|++
expr_stmt|;
name|g_io_request
argument_list|(
name|bp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|BIO_WRITE
case|:
block|{
name|struct
name|g_mirror_disk_sync
modifier|*
name|sync
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|!=
literal|0
condition|)
block|{
name|G_MIRROR_LOGREQ
argument_list|(
literal|0
argument_list|,
name|bp
argument_list|,
literal|"Synchronization request failed (error=%d)."
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bump_syncid
operator|=
name|G_MIRROR_BUMP_IMMEDIATELY
expr_stmt|;
name|g_mirror_event_send
argument_list|(
name|disk
argument_list|,
name|G_MIRROR_DISK_STATE_DISCONNECTED
argument_list|,
name|G_MIRROR_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
return|return;
block|}
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Synchronization request finished."
argument_list|)
expr_stmt|;
name|sync
operator|=
operator|&
name|disk
operator|->
name|d_sync
expr_stmt|;
name|sync
operator|->
name|ds_offset_done
operator|=
name|bp
operator|->
name|bio_offset
operator|+
name|bp
operator|->
name|bio_length
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sync
operator|->
name|ds_resync
operator|!=
operator|-
literal|1
condition|)
break|break;
if|if
condition|(
name|sync
operator|->
name|ds_offset_done
operator|==
name|sc
operator|->
name|sc_provider
operator|->
name|mediasize
condition|)
block|{
comment|/* 			 * Disk up-to-date, activate it. 			 */
name|g_mirror_event_send
argument_list|(
name|disk
argument_list|,
name|G_MIRROR_DISK_STATE_ACTIVE
argument_list|,
name|G_MIRROR_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|sync
operator|->
name|ds_offset_done
operator|%
operator|(
name|MAXPHYS
operator|*
literal|100
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Update offset_done on every 100 blocks. 			 * XXX: This should be configurable. 			 */
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_mirror_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
default|default:
name|KASSERT
argument_list|(
literal|1
operator|==
literal|0
argument_list|,
operator|(
literal|"Invalid command here: %u (device=%s)"
operator|,
name|bp
operator|->
name|bio_cmd
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_request_prefer
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|bio
modifier|*
name|cbp
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_ACTIVE
condition|)
break|break;
block|}
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|ENXIO
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
return|return;
block|}
name|cbp
operator|=
name|g_clone_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|ENOMEM
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Fill in the component buf structure. 	 */
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|cbp
operator|->
name|bio_done
operator|=
name|g_mirror_done
expr_stmt|;
name|cbp
operator|->
name|bio_to
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|cbp
argument_list|,
literal|"Sending request."
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|->
name|acr
operator|==
literal|1
operator|&&
name|cp
operator|->
name|acw
operator|==
literal|1
operator|&&
name|cp
operator|->
name|ace
operator|==
literal|1
argument_list|,
operator|(
literal|"Consumer %s not opened (r%dw%de%d)."
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|,
name|cp
operator|->
name|acr
operator|,
name|cp
operator|->
name|acw
operator|,
name|cp
operator|->
name|ace
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|index
operator|++
expr_stmt|;
name|g_io_request
argument_list|(
name|cbp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_request_round_robin
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|bio
modifier|*
name|cbp
decl_stmt|;
name|disk
operator|=
name|g_mirror_get_disk
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|ENXIO
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
return|return;
block|}
name|cbp
operator|=
name|g_clone_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|ENOMEM
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Fill in the component buf structure. 	 */
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|cbp
operator|->
name|bio_done
operator|=
name|g_mirror_done
expr_stmt|;
name|cbp
operator|->
name|bio_to
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|cbp
argument_list|,
literal|"Sending request."
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|->
name|acr
operator|==
literal|1
operator|&&
name|cp
operator|->
name|acw
operator|==
literal|1
operator|&&
name|cp
operator|->
name|ace
operator|==
literal|1
argument_list|,
operator|(
literal|"Consumer %s not opened (r%dw%de%d)."
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|,
name|cp
operator|->
name|acr
operator|,
name|cp
operator|->
name|acw
operator|,
name|cp
operator|->
name|ace
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|index
operator|++
expr_stmt|;
name|g_io_request
argument_list|(
name|cbp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_request_load
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|bio
modifier|*
name|cbp
decl_stmt|;
name|struct
name|bintime
name|curtime
decl_stmt|;
name|binuptime
argument_list|(
operator|&
name|curtime
argument_list|)
expr_stmt|;
comment|/* 	 * Find a disk which the smallest load. 	 */
name|disk
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_state
operator|!=
name|G_MIRROR_DISK_STATE_ACTIVE
condition|)
continue|continue;
comment|/* If disk wasn't used for more than 2 sec, use it. */
if|if
condition|(
name|curtime
operator|.
name|sec
operator|-
name|dp
operator|->
name|d_last_used
operator|.
name|sec
operator|>=
literal|2
condition|)
block|{
name|disk
operator|=
name|dp
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|disk
operator|==
name|NULL
operator|||
name|bintime_cmp
argument_list|(
operator|&
name|dp
operator|->
name|d_delay
argument_list|,
operator|&
name|disk
operator|->
name|d_delay
argument_list|)
operator|<
literal|0
condition|)
block|{
name|disk
operator|=
name|dp
expr_stmt|;
block|}
block|}
name|cbp
operator|=
name|g_clone_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|ENOMEM
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Fill in the component buf structure. 	 */
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|cbp
operator|->
name|bio_done
operator|=
name|g_mirror_done
expr_stmt|;
name|cbp
operator|->
name|bio_to
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|disk
operator|->
name|d_last_used
argument_list|)
expr_stmt|;
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|cbp
argument_list|,
literal|"Sending request."
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|->
name|acr
operator|==
literal|1
operator|&&
name|cp
operator|->
name|acw
operator|==
literal|1
operator|&&
name|cp
operator|->
name|ace
operator|==
literal|1
argument_list|,
operator|(
literal|"Consumer %s not opened (r%dw%de%d)."
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|,
name|cp
operator|->
name|acr
operator|,
name|cp
operator|->
name|acw
operator|,
name|cp
operator|->
name|ace
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|->
name|index
operator|++
expr_stmt|;
name|g_io_request
argument_list|(
name|cbp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_request_split
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|bio_queue_head
name|queue
decl_stmt|;
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|bio
modifier|*
name|cbp
decl_stmt|;
name|off_t
name|left
decl_stmt|,
name|mod
decl_stmt|,
name|offset
decl_stmt|,
name|slice
decl_stmt|;
name|u_char
modifier|*
name|data
decl_stmt|;
name|u_int
name|ndisks
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_length
operator|<=
name|sc
operator|->
name|sc_slice
condition|)
block|{
name|g_mirror_request_round_robin
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|ndisks
operator|=
name|g_mirror_ndisks
argument_list|(
name|sc
argument_list|,
name|G_MIRROR_DISK_STATE_ACTIVE
argument_list|)
expr_stmt|;
name|slice
operator|=
name|bp
operator|->
name|bio_length
operator|/
name|ndisks
expr_stmt|;
name|mod
operator|=
name|slice
operator|%
name|sc
operator|->
name|sc_provider
operator|->
name|sectorsize
expr_stmt|;
if|if
condition|(
name|mod
operator|!=
literal|0
condition|)
name|slice
operator|+=
name|sc
operator|->
name|sc_provider
operator|->
name|sectorsize
operator|-
name|mod
expr_stmt|;
comment|/* 	 * Allocate all bios before sending any request, so we can 	 * return ENOMEM in nice and clean way. 	 */
name|left
operator|=
name|bp
operator|->
name|bio_length
expr_stmt|;
name|offset
operator|=
name|bp
operator|->
name|bio_offset
expr_stmt|;
name|data
operator|=
name|bp
operator|->
name|bio_data
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|queue
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_MIRROR_DISK_STATE_ACTIVE
condition|)
continue|continue;
name|cbp
operator|=
name|g_clone_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|cbp
operator|=
name|bioq_first
argument_list|(
operator|&
name|queue
argument_list|)
init|;
name|cbp
operator|!=
name|NULL
condition|;
name|cbp
operator|=
name|bioq_first
argument_list|(
operator|&
name|queue
argument_list|)
control|)
block|{
name|bioq_remove
argument_list|(
operator|&
name|queue
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|ENOMEM
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
return|return;
block|}
name|bioq_insert_tail
argument_list|(
operator|&
name|queue
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|bio_done
operator|=
name|g_mirror_done
expr_stmt|;
name|cbp
operator|->
name|bio_caller1
operator|=
name|disk
expr_stmt|;
name|cbp
operator|->
name|bio_to
operator|=
name|disk
operator|->
name|d_consumer
operator|->
name|provider
expr_stmt|;
name|cbp
operator|->
name|bio_offset
operator|=
name|offset
expr_stmt|;
name|cbp
operator|->
name|bio_data
operator|=
name|data
expr_stmt|;
name|cbp
operator|->
name|bio_length
operator|=
name|MIN
argument_list|(
name|left
argument_list|,
name|slice
argument_list|)
expr_stmt|;
name|left
operator|-=
name|cbp
operator|->
name|bio_length
expr_stmt|;
if|if
condition|(
name|left
operator|==
literal|0
condition|)
break|break;
name|offset
operator|+=
name|cbp
operator|->
name|bio_length
expr_stmt|;
name|data
operator|+=
name|cbp
operator|->
name|bio_length
expr_stmt|;
block|}
for|for
control|(
name|cbp
operator|=
name|bioq_first
argument_list|(
operator|&
name|queue
argument_list|)
init|;
name|cbp
operator|!=
name|NULL
condition|;
name|cbp
operator|=
name|bioq_first
argument_list|(
operator|&
name|queue
argument_list|)
control|)
block|{
name|bioq_remove
argument_list|(
operator|&
name|queue
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|cbp
argument_list|,
literal|"Sending request."
argument_list|)
expr_stmt|;
name|disk
operator|=
name|cbp
operator|->
name|bio_caller1
expr_stmt|;
name|cbp
operator|->
name|bio_caller1
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|->
name|acr
operator|==
literal|1
operator|&&
name|cp
operator|->
name|acw
operator|==
literal|1
operator|&&
name|cp
operator|->
name|ace
operator|==
literal|1
argument_list|,
operator|(
literal|"Consumer %s not opened (r%dw%de%d)."
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|,
name|cp
operator|->
name|acr
operator|,
name|cp
operator|->
name|acw
operator|,
name|cp
operator|->
name|ace
operator|)
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|->
name|index
operator|++
expr_stmt|;
name|g_io_request
argument_list|(
name|cbp
argument_list|,
name|disk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_register_request
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
switch|switch
condition|(
name|sc
operator|->
name|sc_balance
condition|)
block|{
case|case
name|G_MIRROR_BALANCE_LOAD
case|:
name|g_mirror_request_load
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
break|break;
case|case
name|G_MIRROR_BALANCE_PREFER
case|:
name|g_mirror_request_prefer
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
break|break;
case|case
name|G_MIRROR_BALANCE_ROUND_ROBIN
case|:
name|g_mirror_request_round_robin
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
break|break;
case|case
name|G_MIRROR_BALANCE_SPLIT
case|:
name|g_mirror_request_split
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
case|case
name|BIO_WRITE
case|:
case|case
name|BIO_DELETE
case|:
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_mirror_disk_sync
modifier|*
name|sync
decl_stmt|;
name|struct
name|bio_queue_head
name|queue
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|bio
modifier|*
name|cbp
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_idle
condition|)
name|g_mirror_unidle
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 		 * Allocate all bios before sending any request, so we can 		 * return ENOMEM in nice and clean way. 		 */
name|bioq_init
argument_list|(
operator|&
name|queue
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
name|sync
operator|=
operator|&
name|disk
operator|->
name|d_sync
expr_stmt|;
switch|switch
condition|(
name|disk
operator|->
name|d_state
condition|)
block|{
case|case
name|G_MIRROR_DISK_STATE_ACTIVE
case|:
break|break;
case|case
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
case|:
if|if
condition|(
name|bp
operator|->
name|bio_offset
operator|>=
name|sync
operator|->
name|ds_offset
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|bp
operator|->
name|bio_offset
operator|+
name|bp
operator|->
name|bio_length
operator|>
name|sync
operator|->
name|ds_offset_done
operator|&&
operator|(
name|bp
operator|->
name|bio_offset
operator|<
name|sync
operator|->
name|ds_resync
operator|||
name|sync
operator|->
name|ds_resync
operator|==
operator|-
literal|1
operator|)
condition|)
block|{
name|sync
operator|->
name|ds_resync
operator|=
name|bp
operator|->
name|bio_offset
operator|-
operator|(
name|bp
operator|->
name|bio_offset
operator|%
name|MAXPHYS
operator|)
expr_stmt|;
block|}
break|break;
default|default:
continue|continue;
block|}
name|cbp
operator|=
name|g_clone_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|cbp
operator|=
name|bioq_first
argument_list|(
operator|&
name|queue
argument_list|)
init|;
name|cbp
operator|!=
name|NULL
condition|;
name|cbp
operator|=
name|bioq_first
argument_list|(
operator|&
name|queue
argument_list|)
control|)
block|{
name|bioq_remove
argument_list|(
operator|&
name|queue
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
name|g_destroy_bio
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|ENOMEM
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
return|return;
block|}
name|bioq_insert_tail
argument_list|(
operator|&
name|queue
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
name|cbp
operator|->
name|bio_done
operator|=
name|g_mirror_done
expr_stmt|;
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|cbp
operator|->
name|bio_caller1
operator|=
name|cp
expr_stmt|;
name|cbp
operator|->
name|bio_to
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|KASSERT
argument_list|(
name|cp
operator|->
name|acr
operator|==
literal|1
operator|&&
name|cp
operator|->
name|acw
operator|==
literal|1
operator|&&
name|cp
operator|->
name|ace
operator|==
literal|1
argument_list|,
operator|(
literal|"Consumer %s not opened (r%dw%de%d)."
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|,
name|cp
operator|->
name|acr
operator|,
name|cp
operator|->
name|acw
operator|,
name|cp
operator|->
name|ace
operator|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|cbp
operator|=
name|bioq_first
argument_list|(
operator|&
name|queue
argument_list|)
init|;
name|cbp
operator|!=
name|NULL
condition|;
name|cbp
operator|=
name|bioq_first
argument_list|(
operator|&
name|queue
argument_list|)
control|)
block|{
name|bioq_remove
argument_list|(
operator|&
name|queue
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
name|G_MIRROR_LOGREQ
argument_list|(
literal|3
argument_list|,
name|cbp
argument_list|,
literal|"Sending request."
argument_list|)
expr_stmt|;
name|cp
operator|=
name|cbp
operator|->
name|bio_caller1
expr_stmt|;
name|cbp
operator|->
name|bio_caller1
operator|=
name|NULL
expr_stmt|;
name|cp
operator|->
name|index
operator|++
expr_stmt|;
name|g_io_request
argument_list|(
name|cbp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Bump syncid on first write. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_bump_syncid
operator|==
name|G_MIRROR_BUMP_ON_FIRST_WRITE
condition|)
block|{
name|sc
operator|->
name|sc_bump_syncid
operator|=
literal|0
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_mirror_bump_syncid
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
default|default:
name|KASSERT
argument_list|(
literal|1
operator|==
literal|0
argument_list|,
operator|(
literal|"Invalid command here: %u (device=%s)"
operator|,
name|bp
operator|->
name|bio_cmd
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|g_mirror_can_destroy
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|gp
operator|=
name|sc
operator|->
name|sc_geom
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|cp
argument_list|,
argument|&gp->consumer
argument_list|,
argument|consumer
argument_list|)
block|{
if|if
condition|(
name|g_mirror_is_busy
argument_list|(
name|sc
argument_list|,
name|cp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|gp
operator|=
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|cp
argument_list|,
argument|&gp->consumer
argument_list|,
argument|consumer
argument_list|)
block|{
if|if
condition|(
name|g_mirror_is_busy
argument_list|(
name|sc
argument_list|,
name|cp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|G_MIRROR_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"No I/O requests for %s, it can be destroyed."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_mirror_try_destroy
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_WAIT
operator|)
operator|!=
literal|0
condition|)
block|{
name|g_topology_lock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|g_mirror_can_destroy
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|g_topology_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Waking up %p."
argument_list|,
name|__func__
argument_list|,
operator|&
name|sc
operator|->
name|sc_worker
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_worker
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_worker
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|g_topology_lock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|g_mirror_can_destroy
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|g_topology_unlock
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|g_mirror_destroy_device
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_MIRROR
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Worker thread.  */
end_comment

begin_function
specifier|static
name|void
name|g_mirror_worker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_mirror_disk_sync
modifier|*
name|sync
decl_stmt|;
name|struct
name|g_mirror_event
modifier|*
name|ep
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|u_int
name|nreqs
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|curthread
operator|->
name|td_base_pri
operator|=
name|PRIBIO
expr_stmt|;
name|nreqs
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%s: Let's see..."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 		 * First take a look at events. 		 * This is important to handle events before any I/O requests. 		 */
name|ep
operator|=
name|g_mirror_event_get
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
block|{
name|g_topology_lock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_MIRROR_EVENT_DEVICE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Update only device status. */
name|G_MIRROR_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"Running event for device %s."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|ep
operator|->
name|e_error
operator|=
literal|0
expr_stmt|;
name|g_mirror_update_device
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Update disk status. */
name|G_MIRROR_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"Running event for disk %s."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|ep
operator|->
name|e_disk
argument_list|)
argument_list|)
expr_stmt|;
name|ep
operator|->
name|e_error
operator|=
name|g_mirror_update_disk
argument_list|(
name|ep
operator|->
name|e_disk
argument_list|,
name|ep
operator|->
name|e_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|->
name|e_error
operator|==
literal|0
condition|)
name|g_mirror_update_device
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|g_topology_unlock
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_MIRROR_EVENT_DONTWAIT
operator|)
operator|!=
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|ep
operator|->
name|e_error
operator|==
literal|0
argument_list|,
operator|(
literal|"Error cannot be handled."
operator|)
argument_list|)
expr_stmt|;
name|g_mirror_event_free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ep
operator|->
name|e_flags
operator||=
name|G_MIRROR_EVENT_DONE
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Waking up %p."
argument_list|,
name|__func__
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_DESTROY
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|g_mirror_try_destroy
argument_list|(
name|sc
argument_list|)
condition|)
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|G_MIRROR_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%s: I'm here 1."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Now I/O requests. 		 */
comment|/* Get first request from the queue. */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_DESTROY
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_mirror_try_destroy
argument_list|(
name|sc
argument_list|)
condition|)
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sc_sync
operator|.
name|ds_ndisks
operator|>
literal|0
operator|&&
operator|(
name|bp
operator|==
name|NULL
operator|||
name|nreqs
operator|>
name|g_mirror_reqs_per_sync
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
comment|/* 			 * It is time for synchronization... 			 */
name|nreqs
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
condition|)
block|{
continue|continue;
block|}
name|sync
operator|=
operator|&
name|disk
operator|->
name|d_sync
expr_stmt|;
if|if
condition|(
name|sync
operator|->
name|ds_offset
operator|>=
name|sc
operator|->
name|sc_provider
operator|->
name|mediasize
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|sync
operator|->
name|ds_offset
operator|>
name|sync
operator|->
name|ds_offset_done
condition|)
continue|continue;
if|if
condition|(
name|sync
operator|->
name|ds_resync
operator|!=
operator|-
literal|1
condition|)
block|{
name|sync
operator|->
name|ds_offset
operator|=
name|sync
operator|->
name|ds_resync
expr_stmt|;
name|sync
operator|->
name|ds_offset_done
operator|=
name|sync
operator|->
name|ds_resync
expr_stmt|;
name|sync
operator|->
name|ds_resync
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|g_mirror_sync_one
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
name|G_MIRROR_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%s: I'm here 2."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|sleep
goto|;
block|}
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|g_mirror_check_idle
argument_list|(
name|sc
argument_list|)
condition|)
block|{
name|u_int
name|idletime
decl_stmt|;
name|idletime
operator|=
name|g_mirror_idletime
expr_stmt|;
if|if
condition|(
name|idletime
operator|==
literal|0
condition|)
name|idletime
operator|=
literal|1
expr_stmt|;
name|idletime
operator|*=
name|hz
expr_stmt|;
if|if
condition|(
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|,
name|PRIBIO
operator||
name|PDROP
argument_list|,
literal|"m:w1"
argument_list|,
name|idletime
argument_list|)
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%s: I'm here 3."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 					 * No I/O requests in 'idletime' seconds, 					 * so mark components as clean. 					 */
name|g_mirror_idle
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|G_MIRROR_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%s: I'm here 4."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MSLEEP
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|,
name|PRIBIO
operator||
name|PDROP
argument_list|,
literal|"m:w2"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%s: I'm here 5."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|nreqs
operator|++
expr_stmt|;
name|bioq_remove
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|bio_cflags
operator|&
name|G_MIRROR_BIO_FLAG_REGULAR
operator|)
operator|!=
literal|0
condition|)
block|{
name|g_mirror_regular_request
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bp
operator|->
name|bio_cflags
operator|&
name|G_MIRROR_BIO_FLAG_SYNC
operator|)
operator|!=
literal|0
condition|)
block|{
name|u_int
name|timeout
decl_stmt|,
name|sps
decl_stmt|;
name|g_mirror_sync_request
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|sleep
label|:
name|sps
operator|=
name|g_mirror_syncs_per_sec
expr_stmt|;
if|if
condition|(
name|sps
operator|==
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%s: I'm here 6."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bioq_first
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%s: I'm here 7."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|timeout
operator|=
name|hz
operator|/
name|sps
expr_stmt|;
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
name|timeout
operator|=
literal|1
expr_stmt|;
name|MSLEEP
argument_list|(
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|,
name|PRIBIO
operator||
name|PDROP
argument_list|,
literal|"m:w3"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_mirror_register_request
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|G_MIRROR_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"%s: I'm here 8."
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Open disk's consumer if needed.  */
end_comment

begin_function
specifier|static
name|void
name|g_mirror_update_access
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|pp
operator|=
name|disk
operator|->
name|d_softc
operator|->
name|sc_provider
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|pp
operator|->
name|acw
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_DIRTY
operator|)
operator|==
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Disk %s (device %s) marked as dirty."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|disk
operator|->
name|d_softc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_flags
operator||=
name|G_MIRROR_DISK_FLAG_DIRTY
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pp
operator|->
name|acw
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_DIRTY
operator|)
operator|!=
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Disk %s (device %s) marked as clean."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|disk
operator|->
name|d_softc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_MIRROR_DISK_FLAG_DIRTY
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_sync_start
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_state
operator|==
name|G_MIRROR_DEVICE_STATE_RUNNING
argument_list|,
operator|(
literal|"Device not in RUNNING state (%s, %u)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|sc
operator|->
name|sc_state
operator|)
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: rebuilding provider %s."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_flags
operator||=
name|G_MIRROR_DISK_FLAG_DIRTY
expr_stmt|;
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|==
name|NULL
argument_list|,
operator|(
literal|"Sync consumer already exists (device=%s, disk=%s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|=
name|g_new_consumer
argument_list|(
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|->
name|private
operator|=
name|disk
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|->
name|index
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|g_attach
argument_list|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
argument_list|,
name|disk
operator|->
name|d_softc
operator|->
name|sc_provider
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"Cannot attach to %s (error=%d)."
operator|,
name|disk
operator|->
name|d_softc
operator|->
name|sc_name
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_access
argument_list|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"Cannot open %s (error=%d)."
operator|,
name|disk
operator|->
name|d_softc
operator|->
name|sc_name
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_data
operator|=
name|malloc
argument_list|(
name|MAXPHYS
argument_list|,
name|M_MIRROR
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sync
operator|.
name|ds_ndisks
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop synchronization process.  * type: 0 - synchronization finished  *       1 - synchronization stopped  */
end_comment

begin_function
specifier|static
name|void
name|g_mirror_sync_stop
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|g_topology_assert
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: rebuilding provider %s finished."
argument_list|,
name|disk
operator|->
name|d_softc
operator|->
name|sc_name
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* if (type == 1) */
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: rebuilding provider %s stopped."
argument_list|,
name|disk
operator|->
name|d_softc
operator|->
name|sc_name
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|g_mirror_kill_consumer
argument_list|(
name|disk
operator|->
name|d_softc
argument_list|,
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_data
argument_list|,
name|M_MIRROR
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_consumer
operator|=
name|NULL
expr_stmt|;
name|disk
operator|->
name|d_softc
operator|->
name|sc_sync
operator|.
name|ds_ndisks
operator|--
expr_stmt|;
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_MIRROR_DISK_FLAG_DIRTY
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_launch_provider
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|pp
operator|=
name|g_new_providerf
argument_list|(
name|sc
operator|->
name|sc_geom
argument_list|,
literal|"mirror/%s"
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|pp
operator|->
name|mediasize
operator|=
name|sc
operator|->
name|sc_mediasize
expr_stmt|;
name|pp
operator|->
name|sectorsize
operator|=
name|sc
operator|->
name|sc_sectorsize
expr_stmt|;
name|sc
operator|->
name|sc_provider
operator|=
name|pp
expr_stmt|;
name|g_error_provider
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: provider %s launched."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
condition|)
name|g_mirror_sync_start
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_destroy_provider
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_provider
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL provider (device=%s)."
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
name|g_error_provider
argument_list|(
name|sc
operator|->
name|sc_provider
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|bioq_first
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bioq_remove
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: provider %s destroyed."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|sc
operator|->
name|sc_provider
operator|->
name|name
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_provider
operator|->
name|flags
operator||=
name|G_PF_WITHER
expr_stmt|;
name|g_orphan_provider
argument_list|(
name|sc
operator|->
name|sc_provider
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_provider
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
condition|)
name|g_mirror_sync_stop
argument_list|(
name|disk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_go
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Force device %s start due to timeout."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|g_mirror_event_send
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|G_MIRROR_EVENT_DONTWAIT
operator||
name|G_MIRROR_EVENT_DEVICE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|g_mirror_determine_state
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|u_int
name|state
decl_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_syncid
operator|==
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
condition|)
block|{
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_SYNCHRONIZING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Disk does not need synchronization. */
name|state
operator|=
name|G_MIRROR_DISK_STATE_ACTIVE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_NOAUTOSYNC
operator|)
operator|==
literal|0
operator|||
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_FORCE_SYNC
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * We can start synchronization from 				 * the stored offset. 				 */
name|state
operator|=
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|G_MIRROR_DISK_STATE_STALE
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|<
name|sc
operator|->
name|sc_syncid
condition|)
block|{
comment|/* 		 * Reset all synchronization data for this disk, 		 * because if it even was synchronized, it was 		 * synchronized to disks with different syncid. 		 */
name|disk
operator|->
name|d_flags
operator||=
name|G_MIRROR_DISK_FLAG_SYNCHRONIZING
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset
operator|=
literal|0
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset_done
operator|=
literal|0
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|=
name|sc
operator|->
name|sc_syncid
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_NOAUTOSYNC
operator|)
operator|==
literal|0
operator|||
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_FORCE_SYNC
operator|)
operator|!=
literal|0
condition|)
block|{
name|state
operator|=
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|G_MIRROR_DISK_STATE_STALE
expr_stmt|;
block|}
block|}
else|else
comment|/* if (sc->sc_syncid< disk->d_sync.ds_syncid) */
block|{
comment|/* 		 * Not good, NOT GOOD! 		 * It means that mirror was started on stale disks 		 * and more fresh disk just arrive. 		 * If there were writes, mirror is fucked up, sorry. 		 * I think the best choice here is don't touch 		 * this disk and inform the user laudly. 		 */
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s was started before the freshest "
literal|"disk (%s) arrives!! It will not be connected to the "
literal|"running device."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
name|g_mirror_destroy_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|state
operator|=
name|G_MIRROR_DISK_STATE_NONE
expr_stmt|;
comment|/* Return immediately, because disk was destroyed. */
return|return
operator|(
name|state
operator|)
return|;
block|}
name|G_MIRROR_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"State for %s disk: %s."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|g_mirror_disk_state2str
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|state
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update device state.  */
end_comment

begin_function
specifier|static
name|void
name|g_mirror_update_device
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|boolean_t
name|force
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|u_int
name|state
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_state
condition|)
block|{
case|case
name|G_MIRROR_DEVICE_STATE_STARTING
case|:
block|{
name|struct
name|g_mirror_disk
modifier|*
name|pdisk
decl_stmt|;
name|u_int
name|dirty
decl_stmt|,
name|ndisks
decl_stmt|,
name|syncid
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_provider
operator|==
name|NULL
argument_list|,
operator|(
literal|"Non-NULL provider in STARTING state (%s)."
operator|,
name|sc
operator|->
name|sc_name
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Are we ready? We are, if all disks are connected or 		 * if we have any disks and 'force' is true. 		 */
if|if
condition|(
operator|(
name|force
operator|&&
name|g_mirror_ndisks
argument_list|(
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
operator|>
literal|0
operator|)
operator|||
name|sc
operator|->
name|sc_ndisks
operator|==
name|g_mirror_ndisks
argument_list|(
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|g_mirror_ndisks
argument_list|(
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Disks went down in starting phase, so destroy 			 * device. 			 */
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|G_MIRROR_DEVICE_FLAG_DESTROY
expr_stmt|;
return|return;
block|}
else|else
block|{
return|return;
block|}
comment|/* 		 * Activate all disks with the biggest syncid. 		 */
if|if
condition|(
name|force
condition|)
block|{
comment|/* 			 * If 'force' is true, we have been called due to 			 * timeout, so don't bother canceling timeout. 			 */
name|ndisks
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_SYNCHRONIZING
operator|)
operator|==
literal|0
condition|)
block|{
name|ndisks
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ndisks
operator|==
literal|0
condition|)
block|{
comment|/* No valid disks found, destroy device. */
name|sc
operator|->
name|sc_flags
operator||=
name|G_MIRROR_DEVICE_FLAG_DESTROY
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* Cancel timeout. */
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Find disk with the biggest syncid. 		 */
name|syncid
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|>
name|syncid
condition|)
name|syncid
operator|=
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
expr_stmt|;
block|}
comment|/* 		 * Here we need to look for dirty disks and if all disks 		 * with the biggest syncid are dirty, we have to choose 		 * one with the biggest priority and rebuild the rest. 		 */
comment|/* 		 * Find the number of dirty disks with the biggest syncid. 		 * Find the number of disks with the biggest syncid. 		 * While here, find a disk with the biggest priority. 		 */
name|dirty
operator|=
name|ndisks
operator|=
literal|0
expr_stmt|;
name|pdisk
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|!=
name|syncid
condition|)
continue|continue;
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_SYNCHRONIZING
operator|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
name|ndisks
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_DIRTY
operator|)
operator|!=
literal|0
condition|)
block|{
name|dirty
operator|++
expr_stmt|;
if|if
condition|(
name|pdisk
operator|==
name|NULL
operator|||
name|pdisk
operator|->
name|d_priority
operator|<
name|disk
operator|->
name|d_priority
condition|)
block|{
name|pdisk
operator|=
name|disk
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|dirty
operator|==
literal|0
condition|)
block|{
comment|/* No dirty disks at all, great. */
block|}
elseif|else
if|if
condition|(
name|dirty
operator|==
name|ndisks
condition|)
block|{
comment|/* 			 * Force synchronization for all dirty disks except one 			 * with the biggest priority. 			 */
name|KASSERT
argument_list|(
name|pdisk
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pdisk == NULL"
operator|)
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Using disk %s (device %s) as a "
literal|"master disk for synchronization."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|pdisk
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|!=
name|syncid
condition|)
continue|continue;
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_SYNCHRONIZING
operator|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
name|KASSERT
argument_list|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_DIRTY
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"Disk %s isn't marked as dirty."
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Skip the disk with the biggest priority. */
if|if
condition|(
name|disk
operator|==
name|pdisk
condition|)
continue|continue;
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dirty
operator|<
name|ndisks
condition|)
block|{
comment|/* 			 * Force synchronization for all dirty disks. 			 * We have some non-dirty disks. 			 */
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|!=
name|syncid
condition|)
continue|continue;
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_SYNCHRONIZING
operator|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|disk
operator|->
name|d_flags
operator|&
name|G_MIRROR_DISK_FLAG_DIRTY
operator|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Reset hint. */
name|sc
operator|->
name|sc_hint
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_syncid
operator|=
name|syncid
expr_stmt|;
if|if
condition|(
name|force
condition|)
block|{
comment|/* Remember to bump syncid on first write. */
name|sc
operator|->
name|sc_bump_syncid
operator|=
name|G_MIRROR_BUMP_ON_FIRST_WRITE
expr_stmt|;
block|}
name|state
operator|=
name|G_MIRROR_DEVICE_STATE_RUNNING
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Device %s state changed from %s to %s."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_mirror_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
argument_list|,
name|g_mirror_device_state2str
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|state
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
name|state
operator|=
name|g_mirror_determine_state
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|g_mirror_event_send
argument_list|(
name|disk
argument_list|,
name|state
argument_list|,
name|G_MIRROR_EVENT_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|G_MIRROR_DISK_STATE_STALE
condition|)
block|{
name|sc
operator|->
name|sc_bump_syncid
operator|=
name|G_MIRROR_BUMP_ON_FIRST_WRITE
expr_stmt|;
block|}
block|}
name|wakeup
argument_list|(
operator|&
name|g_mirror_class
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|G_MIRROR_DEVICE_STATE_RUNNING
case|:
if|if
condition|(
name|g_mirror_ndisks
argument_list|(
name|sc
argument_list|,
name|G_MIRROR_DISK_STATE_ACTIVE
argument_list|)
operator|==
literal|0
operator|&&
name|g_mirror_ndisks
argument_list|(
name|sc
argument_list|,
name|G_MIRROR_DISK_STATE_NEW
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * No active disks or no disks at all, 			 * so destroy device. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_provider
operator|!=
name|NULL
condition|)
name|g_mirror_destroy_provider
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|G_MIRROR_DEVICE_FLAG_DESTROY
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|g_mirror_ndisks
argument_list|(
name|sc
argument_list|,
name|G_MIRROR_DISK_STATE_ACTIVE
argument_list|)
operator|>
literal|0
operator|&&
name|g_mirror_ndisks
argument_list|(
name|sc
argument_list|,
name|G_MIRROR_DISK_STATE_NEW
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * We have active disks, launch provider if it doesn't 			 * exist. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_provider
operator|==
name|NULL
condition|)
name|g_mirror_launch_provider
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Bump syncid here, if we need to do it immediately. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_bump_syncid
operator|==
name|G_MIRROR_BUMP_IMMEDIATELY
condition|)
block|{
name|sc
operator|->
name|sc_bump_syncid
operator|=
literal|0
expr_stmt|;
name|g_mirror_bump_syncid
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|KASSERT
argument_list|(
literal|1
operator|==
literal|0
argument_list|,
operator|(
literal|"Wrong device state (%s, %s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_mirror_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Update disk state and device state if needed.  */
end_comment

begin_define
define|#
directive|define
name|DISK_STATE_CHANGED
parameter_list|()
value|G_MIRROR_DEBUG(1,			\ 	"Disk %s state changed from %s to %s (device %s).",		\ 	g_mirror_get_diskname(disk),					\ 	g_mirror_disk_state2str(disk->d_state),				\ 	g_mirror_disk_state2str(state), sc->sc_name)
end_define

begin_function
specifier|static
name|int
name|g_mirror_update_disk
parameter_list|(
name|struct
name|g_mirror_disk
modifier|*
name|disk
parameter_list|,
name|u_int
name|state
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|again
label|:
name|G_MIRROR_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"Changing disk %s state from %s to %s."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
argument_list|,
name|g_mirror_disk_state2str
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|G_MIRROR_DISK_STATE_NEW
case|:
comment|/* 		 * Possible scenarios: 		 * 1. New disk arrive. 		 */
comment|/* Previous state should be NONE. */
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_NONE
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DISK_STATE_CHANGED
argument_list|()
expr_stmt|;
name|disk
operator|->
name|d_state
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_disks
argument_list|)
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_disks
argument_list|,
name|disk
argument_list|,
name|d_next
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|g_mirror_disk
modifier|*
name|dp
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_priority
operator|>=
name|dp
operator|->
name|d_priority
condition|)
block|{
name|LIST_INSERT_BEFORE
argument_list|(
name|dp
argument_list|,
name|disk
argument_list|,
name|d_next
argument_list|)
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|dp
argument_list|,
name|d_next
argument_list|)
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
name|LIST_INSERT_AFTER
argument_list|(
name|dp
argument_list|,
name|disk
argument_list|,
name|d_next
argument_list|)
expr_stmt|;
block|}
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: provider %s detected."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|G_MIRROR_DEVICE_STATE_STARTING
condition|)
break|break;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_state
operator|==
name|G_MIRROR_DEVICE_STATE_RUNNING
argument_list|,
operator|(
literal|"Wrong device state (%s, %s, %s, %s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_mirror_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|state
operator|=
name|g_mirror_determine_state
argument_list|(
name|disk
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|G_MIRROR_DISK_STATE_NONE
condition|)
goto|goto
name|again
goto|;
break|break;
case|case
name|G_MIRROR_DISK_STATE_ACTIVE
case|:
comment|/* 		 * Possible scenarios: 		 * 1. New disk does not need synchronization. 		 * 2. Synchronization process finished successfully. 		 */
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_state
operator|==
name|G_MIRROR_DEVICE_STATE_RUNNING
argument_list|,
operator|(
literal|"Wrong device state (%s, %s, %s, %s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_mirror_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Previous state should be NEW or SYNCHRONIZING. */
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_NEW
operator|||
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DISK_STATE_CHANGED
argument_list|()
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_NEW
condition|)
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_MIRROR_DISK_FLAG_DIRTY
expr_stmt|;
elseif|else
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
condition|)
block|{
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_MIRROR_DISK_FLAG_SYNCHRONIZING
expr_stmt|;
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_MIRROR_DISK_FLAG_FORCE_SYNC
expr_stmt|;
name|g_mirror_sync_stop
argument_list|(
name|disk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|disk
operator|->
name|d_state
operator|=
name|state
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset
operator|=
literal|0
expr_stmt|;
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset_done
operator|=
literal|0
expr_stmt|;
name|g_mirror_update_access
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|g_mirror_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: provider %s activated."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|G_MIRROR_DISK_STATE_STALE
case|:
comment|/* 		 * Possible scenarios: 		 * 1. Stale disk was connected. 		 */
comment|/* Previous state should be NEW. */
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_NEW
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_state
operator|==
name|G_MIRROR_DEVICE_STATE_RUNNING
argument_list|,
operator|(
literal|"Wrong device state (%s, %s, %s, %s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_mirror_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * STALE state is only possible if device is marked 		 * NOAUTOSYNC. 		 */
name|KASSERT
argument_list|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_NOAUTOSYNC
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"Wrong device state (%s, %s, %s, %s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_mirror_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DISK_STATE_CHANGED
argument_list|()
expr_stmt|;
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_MIRROR_DISK_FLAG_DIRTY
expr_stmt|;
name|disk
operator|->
name|d_state
operator|=
name|state
expr_stmt|;
name|g_mirror_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: provider %s is stale."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
case|:
comment|/* 		 * Possible scenarios: 		 * 1. Disk which needs synchronization was connected. 		 */
comment|/* Previous state should be NEW. */
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_NEW
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_state
operator|==
name|G_MIRROR_DEVICE_STATE_RUNNING
argument_list|,
operator|(
literal|"Wrong device state (%s, %s, %s, %s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_mirror_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|DISK_STATE_CHANGED
argument_list|()
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_NEW
condition|)
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_MIRROR_DISK_FLAG_DIRTY
expr_stmt|;
name|disk
operator|->
name|d_state
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_provider
operator|!=
name|NULL
condition|)
block|{
name|g_mirror_sync_start
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|g_mirror_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|G_MIRROR_DISK_STATE_DISCONNECTED
case|:
comment|/* 		 * Possible scenarios: 		 * 1. Device wasn't running yet, but disk disappear. 		 * 2. Disk was active and disapppear. 		 * 3. Disk disappear during synchronization process. 		 */
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|G_MIRROR_DEVICE_STATE_RUNNING
condition|)
block|{
comment|/* 			 * Previous state should be ACTIVE, STALE or 			 * SYNCHRONIZING. 			 */
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_ACTIVE
operator|||
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_STALE
operator|||
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|G_MIRROR_DEVICE_STATE_STARTING
condition|)
block|{
comment|/* Previous state should be NEW. */
name|KASSERT
argument_list|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_NEW
argument_list|,
operator|(
literal|"Wrong disk state (%s, %s)."
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Reset bumping syncid if disk disappeared in STARTING 			 * state. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_bump_syncid
operator|==
name|G_MIRROR_BUMP_ON_FIRST_WRITE
condition|)
name|sc
operator|->
name|sc_bump_syncid
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
block|}
else|else
block|{
name|KASSERT
argument_list|(
literal|1
operator|==
literal|0
argument_list|,
operator|(
literal|"Wrong device state (%s, %s, %s, %s)."
operator|,
name|sc
operator|->
name|sc_name
operator|,
name|g_mirror_device_state2str
argument_list|(
name|sc
operator|->
name|sc_state
argument_list|)
operator|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
operator|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|DISK_STATE_CHANGED
argument_list|()
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: provider %s disconnected."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
name|g_mirror_destroy_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
break|break;
case|case
name|G_MIRROR_DISK_STATE_DESTROY
case|:
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|g_mirror_clear_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|DISK_STATE_CHANGED
argument_list|()
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: provider %s destroyed."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
name|g_mirror_destroy_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ndisks
operator|--
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
name|g_mirror_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|KASSERT
argument_list|(
literal|1
operator|==
literal|0
argument_list|,
operator|(
literal|"Unknown state (%u)."
operator|,
name|state
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|DISK_STATE_CHANGED
end_undef

begin_function
specifier|static
name|int
name|g_mirror_read_metadata
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_mirror_metadata
modifier|*
name|md
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|error
operator|=
name|g_access
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
comment|/* Metadata are stored on last sector. */
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|pp
operator|->
name|mediasize
operator|-
name|pp
operator|->
name|sectorsize
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Decode metadata. */
name|error
operator|=
name|mirror_metadata_decode
argument_list|(
name|buf
argument_list|,
name|md
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|md
operator|->
name|md_magic
argument_list|,
name|G_MIRROR_MAGIC
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"MD5 metadata hash mismatch for provider %s."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_mirror_check_metadata
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|struct
name|g_mirror_metadata
modifier|*
name|md
parameter_list|)
block|{
if|if
condition|(
name|g_mirror_id2disk
argument_list|(
name|sc
argument_list|,
name|md
operator|->
name|md_did
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Disk %s (id=%u) already exists, skipping."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|md
operator|->
name|md_did
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
if|if
condition|(
name|md
operator|->
name|md_all
operator|!=
name|sc
operator|->
name|sc_ndisks
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid '%s' field on disk %s (device %s), skipping."
argument_list|,
literal|"md_all"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|md
operator|->
name|md_slice
operator|!=
name|sc
operator|->
name|sc_slice
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid '%s' field on disk %s (device %s), skipping."
argument_list|,
literal|"md_slice"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|md
operator|->
name|md_balance
operator|!=
name|sc
operator|->
name|sc_balance
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid '%s' field on disk %s (device %s), skipping."
argument_list|,
literal|"md_balance"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|md
operator|->
name|md_mediasize
operator|!=
name|sc
operator|->
name|sc_mediasize
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid '%s' field on disk %s (device %s), skipping."
argument_list|,
literal|"md_mediasize"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_mediasize
operator|>
name|pp
operator|->
name|mediasize
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid size of disk %s (device %s), skipping."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|md
operator|->
name|md_sectorsize
operator|!=
name|sc
operator|->
name|sc_sectorsize
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid '%s' field on disk %s (device %s), skipping."
argument_list|,
literal|"md_sectorsize"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_sectorsize
operator|%
name|pp
operator|->
name|sectorsize
operator|)
operator|!=
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid sector size of disk %s (device %s), skipping."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|md
operator|->
name|md_mflags
operator|&
operator|~
name|G_MIRROR_DEVICE_FLAG_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid device flags on disk %s (device %s), skipping."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|md
operator|->
name|md_dflags
operator|&
operator|~
name|G_MIRROR_DISK_FLAG_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Invalid disk flags on disk %s (device %s), skipping."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_mirror_add_disk
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|struct
name|g_mirror_metadata
modifier|*
name|md
parameter_list|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Adding disk %s."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_mirror_check_metadata
argument_list|(
name|sc
argument_list|,
name|pp
argument_list|,
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|disk
operator|=
name|g_mirror_init_disk
argument_list|(
name|sc
argument_list|,
name|pp
argument_list|,
name|md
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|g_mirror_event_send
argument_list|(
name|disk
argument_list|,
name|G_MIRROR_DISK_STATE_NEW
argument_list|,
name|G_MIRROR_EVENT_WAIT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_mirror_access
parameter_list|(
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|acr
parameter_list|,
name|int
name|acw
parameter_list|,
name|int
name|ace
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|int
name|dcr
decl_stmt|,
name|dcw
decl_stmt|,
name|dce
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Access request for %s: r%dw%de%d."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|acr
argument_list|,
name|acw
argument_list|,
name|ace
argument_list|)
expr_stmt|;
name|dcr
operator|=
name|pp
operator|->
name|acr
operator|+
name|acr
expr_stmt|;
name|dcw
operator|=
name|pp
operator|->
name|acw
operator|+
name|acw
expr_stmt|;
name|dce
operator|=
name|pp
operator|->
name|ace
operator|+
name|ace
expr_stmt|;
name|sc
operator|=
name|pp
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_disks
argument_list|)
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|G_MIRROR_DEVICE_FLAG_DESTROY
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|acr
operator|<=
literal|0
operator|&&
name|acw
operator|<=
literal|0
operator|&&
name|ace
operator|<=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|LIST_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_MIRROR_DISK_STATE_ACTIVE
condition|)
continue|continue;
comment|/* 		 * Mark disk as dirty on open and unmark on close. 		 */
if|if
condition|(
name|pp
operator|->
name|acw
operator|==
literal|0
operator|&&
name|dcw
operator|>
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Disk %s (device %s) marked as dirty."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_flags
operator||=
name|G_MIRROR_DISK_FLAG_DIRTY
expr_stmt|;
name|g_mirror_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pp
operator|->
name|acw
operator|>
literal|0
operator|&&
name|dcw
operator|==
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Disk %s (device %s) marked as clean."
argument_list|,
name|g_mirror_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_flags
operator|&=
operator|~
name|G_MIRROR_DISK_FLAG_DIRTY
expr_stmt|;
name|g_mirror_update_metadata
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|g_geom
modifier|*
name|g_mirror_create
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
specifier|const
name|struct
name|g_mirror_metadata
modifier|*
name|md
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|timeout
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Creating device %s (id=%u)."
argument_list|,
name|md
operator|->
name|md_name
argument_list|,
name|md
operator|->
name|md_mid
argument_list|)
expr_stmt|;
comment|/* One disk is minimum. */
if|if
condition|(
name|md
operator|->
name|md_all
operator|<
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Action geom. 	 */
name|gp
operator|=
name|g_new_geomf
argument_list|(
name|mp
argument_list|,
literal|"%s"
argument_list|,
name|md
operator|->
name|md_name
argument_list|)
expr_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_MIRROR
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|gp
operator|->
name|start
operator|=
name|g_mirror_start
expr_stmt|;
name|gp
operator|->
name|spoiled
operator|=
name|g_mirror_spoiled
expr_stmt|;
name|gp
operator|->
name|orphan
operator|=
name|g_mirror_orphan
expr_stmt|;
name|gp
operator|->
name|access
operator|=
name|g_mirror_access
expr_stmt|;
name|gp
operator|->
name|dumpconf
operator|=
name|g_mirror_dumpconf
expr_stmt|;
name|sc
operator|->
name|sc_id
operator|=
name|md
operator|->
name|md_mid
expr_stmt|;
name|sc
operator|->
name|sc_slice
operator|=
name|md
operator|->
name|md_slice
expr_stmt|;
name|sc
operator|->
name|sc_balance
operator|=
name|md
operator|->
name|md_balance
expr_stmt|;
name|sc
operator|->
name|sc_mediasize
operator|=
name|md
operator|->
name|md_mediasize
expr_stmt|;
name|sc
operator|->
name|sc_sectorsize
operator|=
name|md
operator|->
name|md_sectorsize
expr_stmt|;
name|sc
operator|->
name|sc_ndisks
operator|=
name|md
operator|->
name|md_all
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
name|md
operator|->
name|md_mflags
expr_stmt|;
name|sc
operator|->
name|sc_bump_syncid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_idle
operator|=
literal|0
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|,
literal|"gmirror:queue"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_disks
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_events
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|,
literal|"gmirror:events"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|G_MIRROR_DEVICE_STATE_STARTING
expr_stmt|;
name|gp
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_geom
operator|=
name|gp
expr_stmt|;
name|sc
operator|->
name|sc_provider
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Synchronization geom. 	 */
name|gp
operator|=
name|g_new_geomf
argument_list|(
name|mp
argument_list|,
literal|"%s.sync"
argument_list|,
name|md
operator|->
name|md_name
argument_list|)
expr_stmt|;
name|gp
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
name|gp
operator|->
name|orphan
operator|=
name|g_mirror_orphan
expr_stmt|;
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
operator|=
name|gp
expr_stmt|;
name|sc
operator|->
name|sc_sync
operator|.
name|ds_ndisks
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|kthread_create
argument_list|(
name|g_mirror_worker
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_worker
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"g_mirror %s"
argument_list|,
name|md
operator|->
name|md_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Cannot create kernel thread for %s."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|g_destroy_geom
argument_list|(
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_events_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|g_destroy_geom
argument_list|(
name|sc
operator|->
name|sc_geom
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_MIRROR
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s created (id=%u)."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|,
name|sc
operator|->
name|sc_id
argument_list|)
expr_stmt|;
comment|/* 	 * Run timeout. 	 */
name|timeout
operator|=
name|g_mirror_timeout
operator|*
name|hz
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_callout
argument_list|,
name|timeout
argument_list|,
name|g_mirror_go
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|->
name|sc_geom
operator|)
return|;
block|}
end_function

begin_function
name|int
name|g_mirror_destroy
parameter_list|(
name|struct
name|g_mirror_softc
modifier|*
name|sc
parameter_list|,
name|boolean_t
name|force
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|pp
operator|=
name|sc
operator|->
name|sc_provider
expr_stmt|;
if|if
condition|(
name|pp
operator|!=
name|NULL
operator|&&
operator|(
name|pp
operator|->
name|acr
operator|!=
literal|0
operator|||
name|pp
operator|->
name|acw
operator|!=
literal|0
operator|||
name|pp
operator|->
name|ace
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|force
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s is still open, so it "
literal|"can't be definitely removed."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Device %s is still open (r%dw%de%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|pp
operator|->
name|acr
argument_list|,
name|pp
operator|->
name|acw
argument_list|,
name|pp
operator|->
name|ace
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
block|}
name|sc
operator|->
name|sc_flags
operator||=
name|G_MIRROR_DEVICE_FLAG_DESTROY
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|G_MIRROR_DEVICE_FLAG_WAIT
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Waking up %p."
argument_list|,
name|__func__
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Sleeping %p."
argument_list|,
name|__func__
argument_list|,
operator|&
name|sc
operator|->
name|sc_worker
argument_list|)
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|sc_worker
operator|!=
name|NULL
condition|)
name|tsleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_worker
argument_list|,
name|PRIBIO
argument_list|,
literal|"m:destroy"
argument_list|,
name|hz
operator|/
literal|5
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|4
argument_list|,
literal|"%s: Woken up %p."
argument_list|,
name|__func__
argument_list|,
operator|&
name|sc
operator|->
name|sc_worker
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_mirror_destroy_device
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_MIRROR
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_taste_orphan
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|KASSERT
argument_list|(
literal|1
operator|==
literal|0
argument_list|,
operator|(
literal|"%s called while tasting %s."
operator|,
name|__func__
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|g_geom
modifier|*
name|g_mirror_taste
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|flags
name|__unused
parameter_list|)
block|{
name|struct
name|g_mirror_metadata
name|md
decl_stmt|;
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"%s(%s, %s)"
argument_list|,
name|__func__
argument_list|,
name|mp
operator|->
name|name
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|G_MIRROR_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Tasting %s."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|gp
operator|=
name|g_new_geomf
argument_list|(
name|mp
argument_list|,
literal|"mirror:taste"
argument_list|)
expr_stmt|;
comment|/* 	 * This orphan function should be never called. 	 */
name|gp
operator|->
name|orphan
operator|=
name|g_mirror_taste_orphan
expr_stmt|;
name|cp
operator|=
name|g_new_consumer
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|g_attach
argument_list|(
name|cp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_mirror_read_metadata
argument_list|(
name|cp
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_geom
argument_list|(
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|gp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|md
operator|.
name|md_version
operator|>
name|G_MIRROR_VERSION
condition|)
block|{
name|printf
argument_list|(
literal|"geom_mirror.ko module is too old to handle %s.\n"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|md
operator|.
name|md_provider
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|strcmp
argument_list|(
name|md
operator|.
name|md_provider
argument_list|,
name|pp
operator|->
name|name
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|md
operator|.
name|md_dflags
operator|&
name|G_MIRROR_DISK_FLAG_INACTIVE
operator|)
operator|!=
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s: provider %s marked as inactive, skipping."
argument_list|,
name|md
operator|.
name|md_name
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|g_mirror_debug
operator|>=
literal|2
condition|)
name|mirror_metadata_dump
argument_list|(
operator|&
name|md
argument_list|)
expr_stmt|;
comment|/* 	 * Let's check if device already exists. 	 */
name|sc
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|gp
argument_list|,
argument|&mp->geom
argument_list|,
argument|geom
argument_list|)
block|{
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
operator|==
name|gp
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|md
operator|.
name|md_name
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|md
operator|.
name|md_mid
operator|!=
name|sc
operator|->
name|sc_id
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Device %s already configured."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
block|}
if|if
condition|(
name|gp
operator|==
name|NULL
condition|)
block|{
name|gp
operator|=
name|g_mirror_create
argument_list|(
name|mp
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|gp
operator|==
name|NULL
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot create device %s."
argument_list|,
name|md
operator|.
name|md_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
block|}
name|G_MIRROR_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Adding disk %s to %s."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|gp
operator|->
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_mirror_add_disk
argument_list|(
name|sc
argument_list|,
name|pp
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot add disk %s to %s (error=%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|gp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_disks
argument_list|)
condition|)
name|g_mirror_destroy
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|gp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_mirror_destroy_geom
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
name|__unused
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
name|__unused
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|)
block|{
return|return
operator|(
name|g_mirror_destroy
argument_list|(
name|gp
operator|->
name|softc
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_dumpconf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
comment|/* Skip synchronization geom. */
if|if
condition|(
name|gp
operator|==
name|sc
operator|->
name|sc_sync
operator|.
name|ds_geom
condition|)
return|return;
if|if
condition|(
name|pp
operator|!=
name|NULL
condition|)
block|{
comment|/* Nothing here. */
block|}
elseif|else
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|struct
name|g_mirror_disk
modifier|*
name|disk
decl_stmt|;
name|disk
operator|=
name|cp
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
return|return;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<ID>%u</ID>\n"
argument_list|,
name|indent
argument_list|,
operator|(
name|u_int
operator|)
name|disk
operator|->
name|d_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_MIRROR_DISK_STATE_SYNCHRONIZING
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Synchronized>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset_done
operator|==
literal|0
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"0%%"
argument_list|)
expr_stmt|;
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%u%%"
argument_list|,
call|(
name|u_int
call|)
argument_list|(
operator|(
name|disk
operator|->
name|d_sync
operator|.
name|ds_offset_done
operator|*
literal|100
operator|)
operator|/
name|sc
operator|->
name|sc_provider
operator|->
name|mediasize
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</Synchronized>\n"
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<SyncID>%u</SyncID>\n"
argument_list|,
name|indent
argument_list|,
name|disk
operator|->
name|d_sync
operator|.
name|ds_syncid
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Flags>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_flags
operator|==
literal|0
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"NONE"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
define|#
directive|define
name|ADD_FLAG
parameter_list|(
name|flag
parameter_list|,
name|name
parameter_list|)
value|do {					\ 	if ((disk->d_flags& (flag)) != 0) {				\ 		if (!first)						\ 			sbuf_printf(sb, ", ");				\ 		else							\ 			first = 0;					\ 		sbuf_printf(sb, name);					\ 	}								\ } while (0)
name|ADD_FLAG
argument_list|(
name|G_MIRROR_DISK_FLAG_DIRTY
argument_list|,
literal|"DIRTY"
argument_list|)
expr_stmt|;
name|ADD_FLAG
argument_list|(
name|G_MIRROR_DISK_FLAG_HARDCODED
argument_list|,
literal|"HARDCODED"
argument_list|)
expr_stmt|;
name|ADD_FLAG
argument_list|(
name|G_MIRROR_DISK_FLAG_INACTIVE
argument_list|,
literal|"INACTIVE"
argument_list|)
expr_stmt|;
name|ADD_FLAG
argument_list|(
name|G_MIRROR_DISK_FLAG_SYNCHRONIZING
argument_list|,
literal|"SYNCHRONIZING"
argument_list|)
expr_stmt|;
name|ADD_FLAG
argument_list|(
name|G_MIRROR_DISK_FLAG_FORCE_SYNC
argument_list|,
literal|"FORCE_SYNC"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ADD_FLAG
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</Flags>\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Priority>%u</Priority>\n"
argument_list|,
name|indent
argument_list|,
name|disk
operator|->
name|d_priority
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<State>%s</State>\n"
argument_list|,
name|indent
argument_list|,
name|g_mirror_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<ID>%u</ID>\n"
argument_list|,
name|indent
argument_list|,
operator|(
name|u_int
operator|)
name|sc
operator|->
name|sc_id
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<SyncID>%u</SyncID>\n"
argument_list|,
name|indent
argument_list|,
name|sc
operator|->
name|sc_syncid
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Flags>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|==
literal|0
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"NONE"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|first
init|=
literal|1
decl_stmt|;
define|#
directive|define
name|ADD_FLAG
parameter_list|(
name|flag
parameter_list|,
name|name
parameter_list|)
value|do {					\ 	if ((sc->sc_flags& (flag)) != 0) {				\ 		if (!first)						\ 			sbuf_printf(sb, ", ");				\ 		else							\ 			first = 0;					\ 		sbuf_printf(sb, name);					\ 	}								\ } while (0)
name|ADD_FLAG
argument_list|(
name|G_MIRROR_DEVICE_FLAG_NOAUTOSYNC
argument_list|,
literal|"NOAUTOSYNC"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ADD_FLAG
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</Flags>\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Slice>%u</Slice>\n"
argument_list|,
name|indent
argument_list|,
operator|(
name|u_int
operator|)
name|sc
operator|->
name|sc_slice
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Balance>%s</Balance>\n"
argument_list|,
name|indent
argument_list|,
name|balance_name
argument_list|(
name|sc
operator|->
name|sc_balance
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Components>%u</Components>\n"
argument_list|,
name|indent
argument_list|,
name|sc
operator|->
name|sc_ndisks
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<State>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|G_MIRROR_DEVICE_STATE_STARTING
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s"
argument_list|,
literal|"STARTING"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_ndisks
operator|==
name|g_mirror_ndisks
argument_list|(
name|sc
argument_list|,
name|G_MIRROR_DISK_STATE_ACTIVE
argument_list|)
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s"
argument_list|,
literal|"COMPLETE"
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s"
argument_list|,
literal|"DEGRADED"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</State>\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_shutdown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
block|{
name|struct
name|g_class
modifier|*
name|mp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|,
modifier|*
name|gp2
decl_stmt|;
name|mp
operator|=
name|arg
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|gp
argument_list|,
argument|&mp->geom
argument_list|,
argument|geom
argument_list|,
argument|gp2
argument_list|)
block|{
if|if
condition|(
name|gp
operator|->
name|softc
operator|==
name|NULL
condition|)
continue|continue;
name|g_mirror_destroy
argument_list|(
name|gp
operator|->
name|softc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|tsleep(&gp, PRIBIO, "m:shutdown", hz * 20);
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_init
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
block|{
name|g_mirror_ehtag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_post_sync
argument_list|,
name|g_mirror_shutdown
argument_list|,
name|mp
argument_list|,
name|SHUTDOWN_PRI_FIRST
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_mirror_ehtag
operator|==
name|NULL
condition|)
name|G_MIRROR_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Warning! Cannot register shutdown event."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_fini
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
block|{
if|if
condition|(
name|g_mirror_ehtag
operator|==
name|NULL
condition|)
return|return;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|shutdown_post_sync
argument_list|,
name|g_mirror_ehtag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_mirror_can_go
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|g_mirror_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|int
name|can_go
decl_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|can_go
operator|=
literal|1
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|gp
argument_list|,
argument|&g_mirror_class.geom
argument_list|,
argument|geom
argument_list|)
block|{
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|can_go
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|pp
operator|=
name|sc
operator|->
name|sc_provider
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
operator|||
name|pp
operator|->
name|error
operator|!=
literal|0
condition|)
block|{
name|can_go
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
return|return
operator|(
name|can_go
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_mirror_rootwait
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * HACK: Wait for GEOM, because g_mirror_rootwait() can be called, 	 * HACK: before we get providers for tasting. 	 */
name|tsleep
argument_list|(
operator|&
name|g_mirror_class
argument_list|,
name|PRIBIO
argument_list|,
literal|"mroot"
argument_list|,
name|hz
operator|*
literal|3
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for mirrors in degraded state. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|g_mirror_can_go
argument_list|()
condition|)
break|break;
name|tsleep
argument_list|(
operator|&
name|g_mirror_class
argument_list|,
name|PRIBIO
argument_list|,
literal|"mroot"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|g_mirror_root
argument_list|,
argument|SI_SUB_RAID
argument_list|,
argument|SI_ORDER_FIRST
argument_list|,
argument|g_mirror_rootwait
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_expr_stmt
name|DECLARE_GEOM_CLASS
argument_list|(
name|g_mirror_class
argument_list|,
name|g_mirror
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

