begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010 Alexander Motin<mav@FreeBSD.org>  * Copyright (c) 2000 - 2008 SÃ¸ren Schmidt<sos@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|"geom/raid/g_raid.h"
end_include

begin_include
include|#
directive|include
file|"g_raid_md_if.h"
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_MD_INTEL
argument_list|,
literal|"md_intel_data"
argument_list|,
literal|"GEOM_RAID Intel metadata"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|intel_raid_map
block|{
name|uint32_t
name|offset
decl_stmt|;
name|uint32_t
name|disk_sectors
decl_stmt|;
name|uint32_t
name|stripe_count
decl_stmt|;
name|uint16_t
name|strip_sectors
decl_stmt|;
name|uint8_t
name|status
decl_stmt|;
define|#
directive|define
name|INTEL_S_READY
value|0x00
define|#
directive|define
name|INTEL_S_UNINITIALIZED
value|0x01
define|#
directive|define
name|INTEL_S_DEGRADED
value|0x02
define|#
directive|define
name|INTEL_S_FAILURE
value|0x03
name|uint8_t
name|type
decl_stmt|;
define|#
directive|define
name|INTEL_T_RAID0
value|0x00
define|#
directive|define
name|INTEL_T_RAID1
value|0x01
define|#
directive|define
name|INTEL_T_RAID5
value|0x05
name|uint8_t
name|total_disks
decl_stmt|;
name|uint8_t
name|total_domains
decl_stmt|;
name|uint8_t
name|failed_disk_num
decl_stmt|;
name|uint8_t
name|ddf
decl_stmt|;
name|uint32_t
name|offset_hi
decl_stmt|;
name|uint32_t
name|disk_sectors_hi
decl_stmt|;
name|uint32_t
name|stripe_count_hi
decl_stmt|;
name|uint32_t
name|filler_2
index|[
literal|4
index|]
decl_stmt|;
name|uint32_t
name|disk_idx
index|[
literal|1
index|]
decl_stmt|;
comment|/* total_disks entries. */
define|#
directive|define
name|INTEL_DI_IDX
value|0x00ffffff
define|#
directive|define
name|INTEL_DI_RBLD
value|0x01000000
block|}
name|__packed
struct|;
end_struct

begin_struct
struct|struct
name|intel_raid_vol
block|{
name|uint8_t
name|name
index|[
literal|16
index|]
decl_stmt|;
name|u_int64_t
name|total_sectors
name|__packed
decl_stmt|;
name|uint32_t
name|state
decl_stmt|;
define|#
directive|define
name|INTEL_ST_BOOTABLE
value|0x00000001
define|#
directive|define
name|INTEL_ST_BOOT_DEVICE
value|0x00000002
define|#
directive|define
name|INTEL_ST_READ_COALESCING
value|0x00000004
define|#
directive|define
name|INTEL_ST_WRITE_COALESCING
value|0x00000008
define|#
directive|define
name|INTEL_ST_LAST_SHUTDOWN_DIRTY
value|0x00000010
define|#
directive|define
name|INTEL_ST_HIDDEN_AT_BOOT
value|0x00000020
define|#
directive|define
name|INTEL_ST_CURRENTLY_HIDDEN
value|0x00000040
define|#
directive|define
name|INTEL_ST_VERIFY_AND_FIX
value|0x00000080
define|#
directive|define
name|INTEL_ST_MAP_STATE_UNINIT
value|0x00000100
define|#
directive|define
name|INTEL_ST_NO_AUTO_RECOVERY
value|0x00000200
define|#
directive|define
name|INTEL_ST_CLONE_N_GO
value|0x00000400
define|#
directive|define
name|INTEL_ST_CLONE_MAN_SYNC
value|0x00000800
define|#
directive|define
name|INTEL_ST_CNG_MASTER_DISK_NUM
value|0x00001000
name|uint32_t
name|reserved
decl_stmt|;
name|uint8_t
name|migr_priority
decl_stmt|;
name|uint8_t
name|num_sub_vols
decl_stmt|;
name|uint8_t
name|tid
decl_stmt|;
name|uint8_t
name|cng_master_disk
decl_stmt|;
name|uint16_t
name|cache_policy
decl_stmt|;
name|uint8_t
name|cng_state
decl_stmt|;
define|#
directive|define
name|INTEL_CNGST_UPDATED
value|0
define|#
directive|define
name|INTEL_CNGST_NEEDS_UPDATE
value|1
define|#
directive|define
name|INTEL_CNGST_MASTER_MISSING
value|2
name|uint8_t
name|cng_sub_state
decl_stmt|;
name|uint32_t
name|filler_0
index|[
literal|10
index|]
decl_stmt|;
name|uint32_t
name|curr_migr_unit
decl_stmt|;
name|uint32_t
name|checkpoint_id
decl_stmt|;
name|uint8_t
name|migr_state
decl_stmt|;
name|uint8_t
name|migr_type
decl_stmt|;
define|#
directive|define
name|INTEL_MT_INIT
value|0
define|#
directive|define
name|INTEL_MT_REBUILD
value|1
define|#
directive|define
name|INTEL_MT_VERIFY
value|2
define|#
directive|define
name|INTEL_MT_GEN_MIGR
value|3
define|#
directive|define
name|INTEL_MT_STATE_CHANGE
value|4
define|#
directive|define
name|INTEL_MT_REPAIR
value|5
name|uint8_t
name|dirty
decl_stmt|;
name|uint8_t
name|fs_state
decl_stmt|;
name|uint16_t
name|verify_errors
decl_stmt|;
name|uint16_t
name|bad_blocks
decl_stmt|;
name|uint32_t
name|curr_migr_unit_hi
decl_stmt|;
name|uint32_t
name|filler_1
index|[
literal|3
index|]
decl_stmt|;
name|struct
name|intel_raid_map
name|map
index|[
literal|1
index|]
decl_stmt|;
comment|/* 2 entries if migr_state != 0. */
block|}
name|__packed
struct|;
end_struct

begin_struct
struct|struct
name|intel_raid_disk
block|{
define|#
directive|define
name|INTEL_SERIAL_LEN
value|16
name|uint8_t
name|serial
index|[
name|INTEL_SERIAL_LEN
index|]
decl_stmt|;
name|uint32_t
name|sectors
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
define|#
directive|define
name|INTEL_F_SPARE
value|0x01
define|#
directive|define
name|INTEL_F_ASSIGNED
value|0x02
define|#
directive|define
name|INTEL_F_FAILED
value|0x04
define|#
directive|define
name|INTEL_F_ONLINE
value|0x08
define|#
directive|define
name|INTEL_F_DISABLED
value|0x80
name|uint32_t
name|owner_cfg_num
decl_stmt|;
name|uint32_t
name|sectors_hi
decl_stmt|;
name|uint32_t
name|filler
index|[
literal|3
index|]
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_struct
struct|struct
name|intel_raid_conf
block|{
name|uint8_t
name|intel_id
index|[
literal|24
index|]
decl_stmt|;
define|#
directive|define
name|INTEL_MAGIC
value|"Intel Raid ISM Cfg Sig. "
name|uint8_t
name|version
index|[
literal|6
index|]
decl_stmt|;
define|#
directive|define
name|INTEL_VERSION_1000
value|"1.0.00"
comment|/* RAID0 */
define|#
directive|define
name|INTEL_VERSION_1100
value|"1.1.00"
comment|/* RAID1 */
define|#
directive|define
name|INTEL_VERSION_1200
value|"1.2.00"
comment|/* Many volumes */
define|#
directive|define
name|INTEL_VERSION_1201
value|"1.2.01"
comment|/* 3 or 4 disks */
define|#
directive|define
name|INTEL_VERSION_1202
value|"1.2.02"
comment|/* RAID5 */
define|#
directive|define
name|INTEL_VERSION_1204
value|"1.2.04"
comment|/* 5 or 6 disks */
define|#
directive|define
name|INTEL_VERSION_1206
value|"1.2.06"
comment|/* CNG */
define|#
directive|define
name|INTEL_VERSION_1300
value|"1.3.00"
comment|/* Attributes */
name|uint8_t
name|dummy_0
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|checksum
decl_stmt|;
name|uint32_t
name|config_size
decl_stmt|;
name|uint32_t
name|config_id
decl_stmt|;
name|uint32_t
name|generation
decl_stmt|;
name|uint32_t
name|error_log_size
decl_stmt|;
name|uint32_t
name|attributes
decl_stmt|;
define|#
directive|define
name|INTEL_ATTR_RAID0
value|0x00000001
define|#
directive|define
name|INTEL_ATTR_RAID1
value|0x00000002
define|#
directive|define
name|INTEL_ATTR_RAID10
value|0x00000004
define|#
directive|define
name|INTEL_ATTR_RAID1E
value|0x00000008
define|#
directive|define
name|INTEL_ATTR_RAID5
value|0x00000010
define|#
directive|define
name|INTEL_ATTR_RAIDCNG
value|0x00000020
define|#
directive|define
name|INTEL_ATTR_EXT_STRIP
value|0x00000040
define|#
directive|define
name|INTEL_ATTR_NVM_CACHE
value|0x02000000
define|#
directive|define
name|INTEL_ATTR_2TB_DISK
value|0x04000000
define|#
directive|define
name|INTEL_ATTR_BBM
value|0x08000000
define|#
directive|define
name|INTEL_ATTR_NVM_CACHE2
value|0x10000000
define|#
directive|define
name|INTEL_ATTR_2TB
value|0x20000000
define|#
directive|define
name|INTEL_ATTR_PM
value|0x40000000
define|#
directive|define
name|INTEL_ATTR_CHECKSUM
value|0x80000000
name|uint8_t
name|total_disks
decl_stmt|;
name|uint8_t
name|total_volumes
decl_stmt|;
name|uint8_t
name|error_log_pos
decl_stmt|;
name|uint8_t
name|dummy_2
index|[
literal|1
index|]
decl_stmt|;
name|uint32_t
name|cache_size
decl_stmt|;
name|uint32_t
name|orig_config_id
decl_stmt|;
name|uint32_t
name|pwr_cycle_count
decl_stmt|;
name|uint32_t
name|bbm_log_size
decl_stmt|;
name|uint32_t
name|filler_0
index|[
literal|35
index|]
decl_stmt|;
name|struct
name|intel_raid_disk
name|disk
index|[
literal|1
index|]
decl_stmt|;
comment|/* total_disks entries. */
comment|/* Here goes total_volumes of struct intel_raid_vol. */
block|}
name|__packed
struct|;
end_struct

begin_define
define|#
directive|define
name|INTEL_ATTR_SUPPORTED
value|( INTEL_ATTR_RAID0 | INTEL_ATTR_RAID1 |	\     INTEL_ATTR_RAID10 | INTEL_ATTR_RAID1E | INTEL_ATTR_RAID5 |		\     INTEL_ATTR_RAIDCNG | INTEL_ATTR_EXT_STRIP | INTEL_ATTR_2TB_DISK |	\     INTEL_ATTR_2TB | INTEL_ATTR_PM | INTEL_ATTR_CHECKSUM )
end_define

begin_define
define|#
directive|define
name|INTEL_MAX_MD_SIZE
parameter_list|(
name|ndisks
parameter_list|)
define|\
value|(sizeof(struct intel_raid_conf) +				\      sizeof(struct intel_raid_disk) * (ndisks - 1) +		\      sizeof(struct intel_raid_vol) * 2 +			\      sizeof(struct intel_raid_map) * 2 +			\      sizeof(uint32_t) * (ndisks - 1) * 4)
end_define

begin_struct
struct|struct
name|g_raid_md_intel_perdisk
block|{
name|struct
name|intel_raid_conf
modifier|*
name|pd_meta
decl_stmt|;
name|int
name|pd_disk_pos
decl_stmt|;
name|struct
name|intel_raid_disk
name|pd_disk_meta
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|g_raid_md_intel_pervolume
block|{
name|int
name|pv_volume_pos
decl_stmt|;
name|int
name|pv_cng
decl_stmt|;
name|int
name|pv_cng_man_sync
decl_stmt|;
name|int
name|pv_cng_master_disk
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|g_raid_md_intel_object
block|{
name|struct
name|g_raid_md_object
name|mdio_base
decl_stmt|;
name|uint32_t
name|mdio_config_id
decl_stmt|;
name|uint32_t
name|mdio_orig_config_id
decl_stmt|;
name|uint32_t
name|mdio_generation
decl_stmt|;
name|struct
name|intel_raid_conf
modifier|*
name|mdio_meta
decl_stmt|;
name|struct
name|callout
name|mdio_start_co
decl_stmt|;
comment|/* STARTING state timer. */
name|int
name|mdio_disks_present
decl_stmt|;
name|int
name|mdio_started
decl_stmt|;
name|int
name|mdio_incomplete
decl_stmt|;
name|struct
name|root_hold_token
modifier|*
name|mdio_rootmount
decl_stmt|;
comment|/* Root mount delay token. */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|g_raid_md_create_t
name|g_raid_md_create_intel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_taste_t
name|g_raid_md_taste_intel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_event_t
name|g_raid_md_event_intel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_ctl_t
name|g_raid_md_ctl_intel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_write_t
name|g_raid_md_write_intel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_fail_disk_t
name|g_raid_md_fail_disk_intel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_free_disk_t
name|g_raid_md_free_disk_intel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_free_volume_t
name|g_raid_md_free_volume_intel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_free_t
name|g_raid_md_free_intel
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kobj_method_t
name|g_raid_md_intel_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|g_raid_md_create
argument_list|,
name|g_raid_md_create_intel
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_taste
argument_list|,
name|g_raid_md_taste_intel
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_event
argument_list|,
name|g_raid_md_event_intel
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_ctl
argument_list|,
name|g_raid_md_ctl_intel
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_write
argument_list|,
name|g_raid_md_write_intel
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_fail_disk
argument_list|,
name|g_raid_md_fail_disk_intel
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_free_disk
argument_list|,
name|g_raid_md_free_disk_intel
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_free_volume
argument_list|,
name|g_raid_md_free_volume_intel
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_free
argument_list|,
name|g_raid_md_free_intel
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|g_raid_md_class
name|g_raid_md_intel_class
init|=
block|{
literal|"Intel"
block|,
name|g_raid_md_intel_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|g_raid_md_intel_object
argument_list|)
block|,
operator|.
name|mdc_enable
operator|=
literal|1
block|,
operator|.
name|mdc_priority
operator|=
literal|100
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|intel_raid_map
modifier|*
name|intel_get_map
parameter_list|(
name|struct
name|intel_raid_vol
modifier|*
name|mvol
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|struct
name|intel_raid_map
modifier|*
name|mmap
decl_stmt|;
if|if
condition|(
name|i
operator|>
operator|(
name|mvol
operator|->
name|migr_state
condition|?
literal|1
else|:
literal|0
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|mmap
operator|=
operator|&
name|mvol
operator|->
name|map
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|mmap
operator|=
operator|(
expr|struct
name|intel_raid_map
operator|*
operator|)
operator|&
name|mmap
operator|->
name|disk_idx
index|[
name|mmap
operator|->
name|total_disks
index|]
expr_stmt|;
block|}
return|return
operator|(
operator|(
expr|struct
name|intel_raid_map
operator|*
operator|)
name|mmap
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|intel_raid_vol
modifier|*
name|intel_get_volume
parameter_list|(
name|struct
name|intel_raid_conf
modifier|*
name|meta
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|struct
name|intel_raid_vol
modifier|*
name|mvol
decl_stmt|;
name|struct
name|intel_raid_map
modifier|*
name|mmap
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|mvol
operator|=
operator|(
expr|struct
name|intel_raid_vol
operator|*
operator|)
operator|&
name|meta
operator|->
name|disk
index|[
name|meta
operator|->
name|total_disks
index|]
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|mmap
operator|=
name|intel_get_map
argument_list|(
name|mvol
argument_list|,
name|mvol
operator|->
name|migr_state
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|mvol
operator|=
operator|(
expr|struct
name|intel_raid_vol
operator|*
operator|)
operator|&
name|mmap
operator|->
name|disk_idx
index|[
name|mmap
operator|->
name|total_disks
index|]
expr_stmt|;
block|}
return|return
operator|(
name|mvol
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|off_t
name|intel_get_map_offset
parameter_list|(
name|struct
name|intel_raid_map
modifier|*
name|mmap
parameter_list|)
block|{
name|off_t
name|offset
init|=
operator|(
name|off_t
operator|)
name|mmap
operator|->
name|offset_hi
operator|<<
literal|32
decl_stmt|;
name|offset
operator|+=
name|mmap
operator|->
name|offset
expr_stmt|;
return|return
operator|(
name|offset
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_set_map_offset
parameter_list|(
name|struct
name|intel_raid_map
modifier|*
name|mmap
parameter_list|,
name|off_t
name|offset
parameter_list|)
block|{
name|mmap
operator|->
name|offset
operator|=
name|offset
operator|&
literal|0xffffffff
expr_stmt|;
name|mmap
operator|->
name|offset_hi
operator|=
name|offset
operator|>>
literal|32
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|off_t
name|intel_get_map_disk_sectors
parameter_list|(
name|struct
name|intel_raid_map
modifier|*
name|mmap
parameter_list|)
block|{
name|off_t
name|disk_sectors
init|=
operator|(
name|off_t
operator|)
name|mmap
operator|->
name|disk_sectors_hi
operator|<<
literal|32
decl_stmt|;
name|disk_sectors
operator|+=
name|mmap
operator|->
name|disk_sectors
expr_stmt|;
return|return
operator|(
name|disk_sectors
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_set_map_disk_sectors
parameter_list|(
name|struct
name|intel_raid_map
modifier|*
name|mmap
parameter_list|,
name|off_t
name|disk_sectors
parameter_list|)
block|{
name|mmap
operator|->
name|disk_sectors
operator|=
name|disk_sectors
operator|&
literal|0xffffffff
expr_stmt|;
name|mmap
operator|->
name|disk_sectors_hi
operator|=
name|disk_sectors
operator|>>
literal|32
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_set_map_stripe_count
parameter_list|(
name|struct
name|intel_raid_map
modifier|*
name|mmap
parameter_list|,
name|off_t
name|stripe_count
parameter_list|)
block|{
name|mmap
operator|->
name|stripe_count
operator|=
name|stripe_count
operator|&
literal|0xffffffff
expr_stmt|;
name|mmap
operator|->
name|stripe_count_hi
operator|=
name|stripe_count
operator|>>
literal|32
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|off_t
name|intel_get_disk_sectors
parameter_list|(
name|struct
name|intel_raid_disk
modifier|*
name|disk
parameter_list|)
block|{
name|off_t
name|sectors
init|=
operator|(
name|off_t
operator|)
name|disk
operator|->
name|sectors_hi
operator|<<
literal|32
decl_stmt|;
name|sectors
operator|+=
name|disk
operator|->
name|sectors
expr_stmt|;
return|return
operator|(
name|sectors
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_set_disk_sectors
parameter_list|(
name|struct
name|intel_raid_disk
modifier|*
name|disk
parameter_list|,
name|off_t
name|sectors
parameter_list|)
block|{
name|disk
operator|->
name|sectors
operator|=
name|sectors
operator|&
literal|0xffffffff
expr_stmt|;
name|disk
operator|->
name|sectors_hi
operator|=
name|sectors
operator|>>
literal|32
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|off_t
name|intel_get_vol_curr_migr_unit
parameter_list|(
name|struct
name|intel_raid_vol
modifier|*
name|vol
parameter_list|)
block|{
name|off_t
name|curr_migr_unit
init|=
operator|(
name|off_t
operator|)
name|vol
operator|->
name|curr_migr_unit_hi
operator|<<
literal|32
decl_stmt|;
name|curr_migr_unit
operator|+=
name|vol
operator|->
name|curr_migr_unit
expr_stmt|;
return|return
operator|(
name|curr_migr_unit
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|intel_set_vol_curr_migr_unit
parameter_list|(
name|struct
name|intel_raid_vol
modifier|*
name|vol
parameter_list|,
name|off_t
name|curr_migr_unit
parameter_list|)
block|{
name|vol
operator|->
name|curr_migr_unit
operator|=
name|curr_migr_unit
operator|&
literal|0xffffffff
expr_stmt|;
name|vol
operator|->
name|curr_migr_unit_hi
operator|=
name|curr_migr_unit
operator|>>
literal|32
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_md_intel_print
parameter_list|(
name|struct
name|intel_raid_conf
modifier|*
name|meta
parameter_list|)
block|{
name|struct
name|intel_raid_vol
modifier|*
name|mvol
decl_stmt|;
name|struct
name|intel_raid_map
modifier|*
name|mmap
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
if|if
condition|(
name|g_raid_debug
operator|<
literal|1
condition|)
return|return;
name|printf
argument_list|(
literal|"********* ATA Intel MatrixRAID Metadata *********\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"intel_id<%.24s>\n"
argument_list|,
name|meta
operator|->
name|intel_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"version<%.6s>\n"
argument_list|,
name|meta
operator|->
name|version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"checksum            0x%08x\n"
argument_list|,
name|meta
operator|->
name|checksum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"config_size         0x%08x\n"
argument_list|,
name|meta
operator|->
name|config_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"config_id           0x%08x\n"
argument_list|,
name|meta
operator|->
name|config_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"generation          0x%08x\n"
argument_list|,
name|meta
operator|->
name|generation
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"error_log_size      %d\n"
argument_list|,
name|meta
operator|->
name|error_log_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"attributes          0x%08x\n"
argument_list|,
name|meta
operator|->
name|attributes
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"total_disks         %u\n"
argument_list|,
name|meta
operator|->
name|total_disks
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"total_volumes       %u\n"
argument_list|,
name|meta
operator|->
name|total_volumes
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"error_log_pos       %u\n"
argument_list|,
name|meta
operator|->
name|error_log_pos
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cache_size          %u\n"
argument_list|,
name|meta
operator|->
name|cache_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"orig_config_id      0x%08x\n"
argument_list|,
name|meta
operator|->
name|orig_config_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pwr_cycle_count     %u\n"
argument_list|,
name|meta
operator|->
name|pwr_cycle_count
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bbm_log_size        %u\n"
argument_list|,
name|meta
operator|->
name|bbm_log_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"DISK#   serial disk_sectors disk_sectors_hi disk_id flags owner\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|meta
operator|->
name|total_disks
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"    %d<%.16s> %u %u 0x%08x 0x%08x %08x\n"
argument_list|,
name|i
argument_list|,
name|meta
operator|->
name|disk
index|[
name|i
index|]
operator|.
name|serial
argument_list|,
name|meta
operator|->
name|disk
index|[
name|i
index|]
operator|.
name|sectors
argument_list|,
name|meta
operator|->
name|disk
index|[
name|i
index|]
operator|.
name|sectors_hi
argument_list|,
name|meta
operator|->
name|disk
index|[
name|i
index|]
operator|.
name|id
argument_list|,
name|meta
operator|->
name|disk
index|[
name|i
index|]
operator|.
name|flags
argument_list|,
name|meta
operator|->
name|disk
index|[
name|i
index|]
operator|.
name|owner_cfg_num
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|meta
operator|->
name|total_volumes
condition|;
name|i
operator|++
control|)
block|{
name|mvol
operator|=
name|intel_get_volume
argument_list|(
name|meta
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" ****** Volume %d ******\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" name               %.16s\n"
argument_list|,
name|mvol
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" total_sectors      %ju\n"
argument_list|,
name|mvol
operator|->
name|total_sectors
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" state              0x%08x\n"
argument_list|,
name|mvol
operator|->
name|state
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" reserved           %u\n"
argument_list|,
name|mvol
operator|->
name|reserved
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" migr_priority      %u\n"
argument_list|,
name|mvol
operator|->
name|migr_priority
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" num_sub_vols       %u\n"
argument_list|,
name|mvol
operator|->
name|num_sub_vols
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" tid                %u\n"
argument_list|,
name|mvol
operator|->
name|tid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" cng_master_disk    %u\n"
argument_list|,
name|mvol
operator|->
name|cng_master_disk
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" cache_policy       %u\n"
argument_list|,
name|mvol
operator|->
name|cache_policy
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" cng_state          %u\n"
argument_list|,
name|mvol
operator|->
name|cng_state
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" cng_sub_state      %u\n"
argument_list|,
name|mvol
operator|->
name|cng_sub_state
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" curr_migr_unit     %u\n"
argument_list|,
name|mvol
operator|->
name|curr_migr_unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" curr_migr_unit_hi  %u\n"
argument_list|,
name|mvol
operator|->
name|curr_migr_unit_hi
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" checkpoint_id      %u\n"
argument_list|,
name|mvol
operator|->
name|checkpoint_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" migr_state         %u\n"
argument_list|,
name|mvol
operator|->
name|migr_state
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" migr_type          %u\n"
argument_list|,
name|mvol
operator|->
name|migr_type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" dirty              %u\n"
argument_list|,
name|mvol
operator|->
name|dirty
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" fs_state           %u\n"
argument_list|,
name|mvol
operator|->
name|fs_state
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" verify_errors      %u\n"
argument_list|,
name|mvol
operator|->
name|verify_errors
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" bad_blocks         %u\n"
argument_list|,
name|mvol
operator|->
name|bad_blocks
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|mvol
operator|->
name|migr_state
condition|?
literal|2
else|:
literal|1
operator|)
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"  *** Map %d ***\n"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|mmap
operator|=
name|intel_get_map
argument_list|(
name|mvol
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  offset            %u\n"
argument_list|,
name|mmap
operator|->
name|offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  offset_hi         %u\n"
argument_list|,
name|mmap
operator|->
name|offset_hi
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  disk_sectors      %u\n"
argument_list|,
name|mmap
operator|->
name|disk_sectors
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  disk_sectors_hi   %u\n"
argument_list|,
name|mmap
operator|->
name|disk_sectors_hi
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  stripe_count      %u\n"
argument_list|,
name|mmap
operator|->
name|stripe_count
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  stripe_count_hi   %u\n"
argument_list|,
name|mmap
operator|->
name|stripe_count_hi
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  strip_sectors     %u\n"
argument_list|,
name|mmap
operator|->
name|strip_sectors
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  status            %u\n"
argument_list|,
name|mmap
operator|->
name|status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  type              %u\n"
argument_list|,
name|mmap
operator|->
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  total_disks       %u\n"
argument_list|,
name|mmap
operator|->
name|total_disks
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  total_domains     %u\n"
argument_list|,
name|mmap
operator|->
name|total_domains
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  failed_disk_num   %u\n"
argument_list|,
name|mmap
operator|->
name|failed_disk_num
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  ddf               %u\n"
argument_list|,
name|mmap
operator|->
name|ddf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  disk_idx         "
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|mmap
operator|->
name|total_disks
condition|;
name|k
operator|++
control|)
name|printf
argument_list|(
literal|" 0x%08x"
argument_list|,
name|mmap
operator|->
name|disk_idx
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"=================================================\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|intel_raid_conf
modifier|*
name|intel_meta_copy
parameter_list|(
name|struct
name|intel_raid_conf
modifier|*
name|meta
parameter_list|)
block|{
name|struct
name|intel_raid_conf
modifier|*
name|nmeta
decl_stmt|;
name|nmeta
operator|=
name|malloc
argument_list|(
name|meta
operator|->
name|config_size
argument_list|,
name|M_MD_INTEL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nmeta
argument_list|,
name|meta
argument_list|,
name|meta
operator|->
name|config_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|nmeta
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_meta_find_disk
parameter_list|(
name|struct
name|intel_raid_conf
modifier|*
name|meta
parameter_list|,
name|char
modifier|*
name|serial
parameter_list|)
block|{
name|int
name|pos
decl_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|meta
operator|->
name|total_disks
condition|;
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|meta
operator|->
name|disk
index|[
name|pos
index|]
operator|.
name|serial
argument_list|,
name|serial
argument_list|,
name|INTEL_SERIAL_LEN
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|pos
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|intel_raid_conf
modifier|*
name|intel_meta_read
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|intel_raid_conf
modifier|*
name|meta
decl_stmt|;
name|struct
name|intel_raid_vol
modifier|*
name|mvol
decl_stmt|;
name|struct
name|intel_raid_map
modifier|*
name|mmap
decl_stmt|,
modifier|*
name|mmap1
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|left
decl_stmt|,
name|size
decl_stmt|;
name|uint32_t
name|checksum
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
comment|/* Read the anchor sector. */
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|pp
operator|->
name|mediasize
operator|-
name|pp
operator|->
name|sectorsize
operator|*
literal|2
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Cannot read metadata from %s (error=%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|meta
operator|=
operator|(
expr|struct
name|intel_raid_conf
operator|*
operator|)
name|buf
expr_stmt|;
comment|/* Check if this is an Intel RAID struct */
if|if
condition|(
name|strncmp
argument_list|(
name|meta
operator|->
name|intel_id
argument_list|,
name|INTEL_MAGIC
argument_list|,
name|strlen
argument_list|(
name|INTEL_MAGIC
argument_list|)
argument_list|)
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Intel signature check failed on %s"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|meta
operator|->
name|config_size
operator|>
literal|65536
operator|||
name|meta
operator|->
name|config_size
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|intel_raid_conf
argument_list|)
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Intel metadata size looks wrong: %d"
argument_list|,
name|meta
operator|->
name|config_size
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|size
operator|=
name|meta
operator|->
name|config_size
expr_stmt|;
name|meta
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_MD_INTEL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|meta
argument_list|,
name|buf
argument_list|,
name|min
argument_list|(
name|size
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|)
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Read all the rest, if needed. */
if|if
condition|(
name|meta
operator|->
name|config_size
operator|>
name|pp
operator|->
name|sectorsize
condition|)
block|{
name|left
operator|=
operator|(
name|meta
operator|->
name|config_size
operator|-
literal|1
operator|)
operator|/
name|pp
operator|->
name|sectorsize
expr_stmt|;
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|pp
operator|->
name|mediasize
operator|-
name|pp
operator|->
name|sectorsize
operator|*
operator|(
literal|2
operator|+
name|left
operator|)
argument_list|,
name|pp
operator|->
name|sectorsize
operator|*
name|left
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Cannot read remaining metadata"
literal|" part from %s (error=%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|meta
argument_list|,
name|M_MD_INTEL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memcpy
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|meta
operator|)
operator|+
name|pp
operator|->
name|sectorsize
argument_list|,
name|buf
argument_list|,
name|pp
operator|->
name|sectorsize
operator|*
name|left
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* Check metadata checksum. */
for|for
control|(
name|checksum
operator|=
literal|0
operator|,
name|ptr
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|meta
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|meta
operator|->
name|config_size
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|checksum
operator|+=
operator|*
name|ptr
operator|++
expr_stmt|;
block|}
name|checksum
operator|-=
name|meta
operator|->
name|checksum
expr_stmt|;
if|if
condition|(
name|checksum
operator|!=
name|meta
operator|->
name|checksum
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Intel checksum check failed on %s"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|meta
argument_list|,
name|M_MD_INTEL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Validate metadata size. */
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|intel_raid_conf
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|intel_raid_disk
argument_list|)
operator|*
operator|(
name|meta
operator|->
name|total_disks
operator|-
literal|1
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|intel_raid_vol
argument_list|)
operator|*
name|meta
operator|->
name|total_volumes
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|meta
operator|->
name|config_size
condition|)
block|{
name|badsize
label|:
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Intel metadata size incorrect %d< %d"
argument_list|,
name|meta
operator|->
name|config_size
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|meta
argument_list|,
name|M_MD_INTEL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|meta
operator|->
name|total_volumes
condition|;
name|i
operator|++
control|)
block|{
name|mvol
operator|=
name|intel_get_volume
argument_list|(
name|meta
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mmap
operator|=
name|intel_get_map
argument_list|(
name|mvol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|size
operator|+=
literal|4
operator|*
operator|(
name|mmap
operator|->
name|total_disks
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|meta
operator|->
name|config_size
condition|)
goto|goto
name|badsize
goto|;
if|if
condition|(
name|mvol
operator|->
name|migr_state
condition|)
block|{
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|intel_raid_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|meta
operator|->
name|config_size
condition|)
goto|goto
name|badsize
goto|;
name|mmap
operator|=
name|intel_get_map
argument_list|(
name|mvol
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|size
operator|+=
literal|4
operator|*
operator|(
name|mmap
operator|->
name|total_disks
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|meta
operator|->
name|config_size
condition|)
goto|goto
name|badsize
goto|;
block|}
block|}
name|g_raid_md_intel_print
argument_list|(
name|meta
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|meta
operator|->
name|version
argument_list|,
name|INTEL_VERSION_1300
argument_list|,
literal|6
argument_list|)
operator|>
literal|0
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Intel unsupported version: '%.6s'"
argument_list|,
name|meta
operator|->
name|version
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|meta
argument_list|,
name|M_MD_INTEL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|meta
operator|->
name|version
argument_list|,
name|INTEL_VERSION_1300
argument_list|,
literal|6
argument_list|)
operator|>=
literal|0
operator|&&
operator|(
name|meta
operator|->
name|attributes
operator|&
operator|~
name|INTEL_ATTR_SUPPORTED
operator|)
operator|!=
literal|0
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Intel unsupported attributes: 0x%08x"
argument_list|,
name|meta
operator|->
name|attributes
operator|&
operator|~
name|INTEL_ATTR_SUPPORTED
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|meta
argument_list|,
name|M_MD_INTEL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Validate disk indexes. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|meta
operator|->
name|total_volumes
condition|;
name|i
operator|++
control|)
block|{
name|mvol
operator|=
name|intel_get_volume
argument_list|(
name|meta
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
name|mvol
operator|->
name|migr_state
condition|?
literal|2
else|:
literal|1
operator|)
condition|;
name|j
operator|++
control|)
block|{
name|mmap
operator|=
name|intel_get_map
argument_list|(
name|mvol
argument_list|,
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|mmap
operator|->
name|total_disks
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mmap
operator|->
name|disk_idx
index|[
name|k
index|]
operator|&
name|INTEL_DI_IDX
operator|)
operator|>
name|meta
operator|->
name|total_disks
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Intel metadata disk"
literal|" index %d too big (>%d)"
argument_list|,
name|mmap
operator|->
name|disk_idx
index|[
name|k
index|]
operator|&
name|INTEL_DI_IDX
argument_list|,
name|meta
operator|->
name|total_disks
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|meta
argument_list|,
name|M_MD_INTEL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
block|}
block|}
comment|/* Validate migration types. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|meta
operator|->
name|total_volumes
condition|;
name|i
operator|++
control|)
block|{
name|mvol
operator|=
name|intel_get_volume
argument_list|(
name|meta
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Deny unknown migration types. */
if|if
condition|(
name|mvol
operator|->
name|migr_state
operator|&&
name|mvol
operator|->
name|migr_type
operator|!=
name|INTEL_MT_INIT
operator|&&
name|mvol
operator|->
name|migr_type
operator|!=
name|INTEL_MT_REBUILD
operator|&&
name|mvol
operator|->
name|migr_type
operator|!=
name|INTEL_MT_VERIFY
operator|&&
name|mvol
operator|->
name|migr_type
operator|!=
name|INTEL_MT_GEN_MIGR
operator|&&
name|mvol
operator|->
name|migr_type
operator|!=
name|INTEL_MT_REPAIR
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Intel metadata has unsupported"
literal|" migration type %d"
argument_list|,
name|mvol
operator|->
name|migr_type
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|meta
argument_list|,
name|M_MD_INTEL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Deny general migrations except SINGLE->RAID1. */
if|if
condition|(
name|mvol
operator|->
name|migr_state
operator|&&
name|mvol
operator|->
name|migr_type
operator|==
name|INTEL_MT_GEN_MIGR
condition|)
block|{
name|mmap
operator|=
name|intel_get_map
argument_list|(
name|mvol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mmap1
operator|=
name|intel_get_map
argument_list|(
name|mvol
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mmap1
operator|->
name|total_disks
operator|!=
literal|1
operator|||
name|mmap
operator|->
name|type
operator|!=
name|INTEL_T_RAID1
operator|||
name|mmap
operator|->
name|total_disks
operator|!=
literal|2
operator|||
name|mmap
operator|->
name|offset
operator|!=
name|mmap1
operator|->
name|offset
operator|||
name|mmap
operator|->
name|disk_sectors
operator|!=
name|mmap1
operator|->
name|disk_sectors
operator|||
name|mmap
operator|->
name|total_domains
operator|!=
name|mmap
operator|->
name|total_disks
operator|||
name|mmap
operator|->
name|offset_hi
operator|!=
name|mmap1
operator|->
name|offset_hi
operator|||
name|mmap
operator|->
name|disk_sectors_hi
operator|!=
name|mmap1
operator|->
name|disk_sectors_hi
operator|||
operator|(
name|mmap
operator|->
name|disk_idx
index|[
literal|0
index|]
operator|!=
name|mmap1
operator|->
name|disk_idx
index|[
literal|0
index|]
operator|&&
name|mmap
operator|->
name|disk_idx
index|[
literal|0
index|]
operator|!=
name|mmap1
operator|->
name|disk_idx
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Intel metadata has unsupported"
literal|" variant of general migration"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|meta
argument_list|,
name|M_MD_INTEL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|meta
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_meta_write
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|intel_raid_conf
modifier|*
name|meta
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|sectors
decl_stmt|;
name|uint32_t
name|checksum
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
comment|/* Recalculate checksum for case if metadata were changed. */
name|meta
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|checksum
operator|=
literal|0
operator|,
name|ptr
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|meta
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|meta
operator|->
name|config_size
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|checksum
operator|+=
operator|*
name|ptr
operator|++
expr_stmt|;
block|}
name|meta
operator|->
name|checksum
operator|=
name|checksum
expr_stmt|;
comment|/* Create and fill buffer. */
name|sectors
operator|=
operator|(
name|meta
operator|->
name|config_size
operator|+
name|pp
operator|->
name|sectorsize
operator|-
literal|1
operator|)
operator|/
name|pp
operator|->
name|sectorsize
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|sectors
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
name|M_MD_INTEL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sectors
operator|>
literal|1
condition|)
block|{
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|meta
operator|)
operator|+
name|pp
operator|->
name|sectorsize
argument_list|,
operator|(
name|sectors
operator|-
literal|1
operator|)
operator|*
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|buf
operator|+
operator|(
name|sectors
operator|-
literal|1
operator|)
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
name|meta
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_write_data
argument_list|(
name|cp
argument_list|,
name|pp
operator|->
name|mediasize
operator|-
name|pp
operator|->
name|sectorsize
operator|*
operator|(
literal|1
operator|+
name|sectors
operator|)
argument_list|,
name|buf
argument_list|,
name|pp
operator|->
name|sectorsize
operator|*
name|sectors
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Cannot write metadata to %s (error=%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|,
name|M_MD_INTEL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_meta_erase
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|pp
operator|->
name|sectorsize
argument_list|,
name|M_MD_INTEL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_write_data
argument_list|(
name|cp
argument_list|,
name|pp
operator|->
name|mediasize
operator|-
literal|2
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
name|buf
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Cannot erase metadata on %s (error=%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|,
name|M_MD_INTEL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intel_meta_write_spare
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|intel_raid_disk
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|intel_raid_conf
modifier|*
name|meta
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Fill anchor and single disk. */
name|meta
operator|=
name|malloc
argument_list|(
name|INTEL_MAX_MD_SIZE
argument_list|(
literal|1
argument_list|)
argument_list|,
name|M_MD_INTEL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|meta
operator|->
name|intel_id
index|[
literal|0
index|]
argument_list|,
name|INTEL_MAGIC
argument_list|,
sizeof|sizeof
argument_list|(
name|INTEL_MAGIC
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|meta
operator|->
name|version
index|[
literal|0
index|]
argument_list|,
name|INTEL_VERSION_1000
argument_list|,
sizeof|sizeof
argument_list|(
name|INTEL_VERSION_1000
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|meta
operator|->
name|config_size
operator|=
name|INTEL_MAX_MD_SIZE
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|meta
operator|->
name|config_id
operator|=
name|meta
operator|->
name|orig_config_id
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|meta
operator|->
name|generation
operator|=
literal|1
expr_stmt|;
name|meta
operator|->
name|total_disks
operator|=
literal|1
expr_stmt|;
name|meta
operator|->
name|disk
index|[
literal|0
index|]
operator|=
operator|*
name|d
expr_stmt|;
name|error
operator|=
name|intel_meta_write
argument_list|(
name|cp
argument_list|,
name|meta
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|meta
argument_list|,
name|M_MD_INTEL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|g_raid_disk
modifier|*
name|g_raid_md_intel_get_disk
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_raid_md_intel_perdisk
modifier|*
name|pd
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_intel_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|pd_disk_pos
operator|==
name|id
condition|)
break|break;
block|}
return|return
operator|(
name|disk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_intel_supported
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|qual
parameter_list|,
name|int
name|disks
parameter_list|,
name|int
name|force
parameter_list|)
block|{
switch|switch
condition|(
name|level
condition|)
block|{
case|case
name|G_RAID_VOLUME_RL_RAID0
case|:
if|if
condition|(
name|disks
operator|<
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|force
operator|&&
operator|(
name|disks
operator|<
literal|2
operator|||
name|disks
operator|>
literal|6
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|G_RAID_VOLUME_RL_RAID1
case|:
if|if
condition|(
name|disks
operator|<
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|force
operator|&&
operator|(
name|disks
operator|!=
literal|2
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|G_RAID_VOLUME_RL_RAID1E
case|:
if|if
condition|(
name|disks
operator|<
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|force
operator|&&
operator|(
name|disks
operator|!=
literal|4
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|G_RAID_VOLUME_RL_RAID5
case|:
if|if
condition|(
name|disks
operator|<
literal|3
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|force
operator|&&
name|disks
operator|>
literal|6
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|qual
operator|!=
name|G_RAID_VOLUME_RLQ_R5LA
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|level
operator|!=
name|G_RAID_VOLUME_RL_RAID5
operator|&&
name|qual
operator|!=
name|G_RAID_VOLUME_RLQ_NONE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|g_raid_volume
modifier|*
name|g_raid_md_intel_get_volume
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|g_raid_volume
modifier|*
name|mvol
decl_stmt|;
name|struct
name|g_raid_md_intel_pervolume
modifier|*
name|pv
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|mvol
argument_list|,
argument|&sc->sc_volumes
argument_list|,
argument|v_next
argument_list|)
block|{
name|pv
operator|=
name|mvol
operator|->
name|v_md_data
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|pv_volume_pos
operator|==
name|id
condition|)
break|break;
block|}
return|return
operator|(
name|mvol
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_intel_start_disk
parameter_list|(
name|struct
name|g_raid_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|,
modifier|*
name|tmpsd
decl_stmt|;
name|struct
name|g_raid_disk
modifier|*
name|olddisk
decl_stmt|,
modifier|*
name|tmpdisk
decl_stmt|;
name|struct
name|g_raid_md_object
modifier|*
name|md
decl_stmt|;
name|struct
name|g_raid_md_intel_object
modifier|*
name|mdi
decl_stmt|;
name|struct
name|g_raid_md_intel_pervolume
modifier|*
name|pv
decl_stmt|;
name|struct
name|g_raid_md_intel_perdisk
modifier|*
name|pd
decl_stmt|,
modifier|*
name|oldpd
decl_stmt|;
name|struct
name|intel_raid_conf
modifier|*
name|meta
decl_stmt|;
name|struct
name|intel_raid_vol
modifier|*
name|mvol
decl_stmt|;
name|struct
name|intel_raid_map
modifier|*
name|mmap0
decl_stmt|,
modifier|*
name|mmap1
decl_stmt|;
name|int
name|disk_pos
decl_stmt|,
name|resurrection
init|=
literal|0
decl_stmt|,
name|migr_global
decl_stmt|,
name|i
decl_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|md
operator|=
name|sc
operator|->
name|sc_md
expr_stmt|;
name|mdi
operator|=
operator|(
expr|struct
name|g_raid_md_intel_object
operator|*
operator|)
name|md
expr_stmt|;
name|meta
operator|=
name|mdi
operator|->
name|mdio_meta
expr_stmt|;
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_intel_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
name|olddisk
operator|=
name|NULL
expr_stmt|;
comment|/* Find disk position in metadata by it's serial. */
name|disk_pos
operator|=
name|intel_meta_find_disk
argument_list|(
name|meta
argument_list|,
name|pd
operator|->
name|pd_disk_meta
operator|.
name|serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk_pos
operator|<
literal|0
condition|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"Unknown, probably new or stale disk"
argument_list|)
expr_stmt|;
comment|/* Failed stale disk is useless for us. */
if|if
condition|(
operator|(
name|pd
operator|->
name|pd_disk_meta
operator|.
name|flags
operator|&
name|INTEL_F_FAILED
operator|)
operator|&&
operator|!
operator|(
name|pd
operator|->
name|pd_disk_meta
operator|.
name|flags
operator|&
name|INTEL_F_DISABLED
operator|)
condition|)
block|{
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_STALE_FAILED
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* If we are in the start process, that's all for now. */
if|if
condition|(
operator|!
name|mdi
operator|->
name|mdio_started
condition|)
goto|goto
name|nofit
goto|;
comment|/* 		 * If we have already started - try to get use of the disk. 		 * Try to replace OFFLINE disks first, then FAILED. 		 */
name|TAILQ_FOREACH
argument_list|(
argument|tmpdisk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|tmpdisk
operator|->
name|d_state
operator|!=
name|G_RAID_DISK_S_OFFLINE
operator|&&
name|tmpdisk
operator|->
name|d_state
operator|!=
name|G_RAID_DISK_S_FAILED
condition|)
continue|continue;
comment|/* Make sure this disk is big enough. */
name|TAILQ_FOREACH
argument_list|(
argument|sd
argument_list|,
argument|&tmpdisk->d_subdisks
argument_list|,
argument|sd_next
argument_list|)
block|{
name|off_t
name|disk_sectors
init|=
name|intel_get_disk_sectors
argument_list|(
operator|&
name|pd
operator|->
name|pd_disk_meta
argument_list|)
decl_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_offset
operator|+
name|sd
operator|->
name|sd_size
operator|+
literal|4096
operator|>
name|disk_sectors
operator|*
literal|512
condition|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"Disk too small (%llu< %llu)"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|disk_sectors
operator|*
literal|512
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|sd
operator|->
name|sd_offset
operator|+
name|sd
operator|->
name|sd_size
operator|+
literal|4096
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sd
operator|!=
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|tmpdisk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_OFFLINE
condition|)
block|{
name|olddisk
operator|=
name|tmpdisk
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|olddisk
operator|==
name|NULL
condition|)
name|olddisk
operator|=
name|tmpdisk
expr_stmt|;
block|}
if|if
condition|(
name|olddisk
operator|==
name|NULL
condition|)
block|{
name|nofit
label|:
if|if
condition|(
name|pd
operator|->
name|pd_disk_meta
operator|.
name|flags
operator|&
name|INTEL_F_SPARE
condition|)
block|{
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_SPARE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_STALE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|oldpd
operator|=
operator|(
expr|struct
name|g_raid_md_intel_perdisk
operator|*
operator|)
name|olddisk
operator|->
name|d_md_data
expr_stmt|;
name|disk_pos
operator|=
name|oldpd
operator|->
name|pd_disk_pos
expr_stmt|;
name|resurrection
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|olddisk
operator|==
name|NULL
condition|)
block|{
comment|/* Find placeholder by position. */
name|olddisk
operator|=
name|g_raid_md_intel_get_disk
argument_list|(
name|sc
argument_list|,
name|disk_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|olddisk
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"No disk at position %d!"
argument_list|,
name|disk_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|olddisk
operator|->
name|d_state
operator|!=
name|G_RAID_DISK_S_OFFLINE
condition|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"More then one disk for pos %d"
argument_list|,
name|disk_pos
argument_list|)
expr_stmt|;
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_STALE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|oldpd
operator|=
operator|(
expr|struct
name|g_raid_md_intel_perdisk
operator|*
operator|)
name|olddisk
operator|->
name|d_md_data
expr_stmt|;
block|}
comment|/* Replace failed disk or placeholder with new disk. */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|sd
argument_list|,
argument|&olddisk->d_subdisks
argument_list|,
argument|sd_next
argument_list|,
argument|tmpsd
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|olddisk
operator|->
name|d_subdisks
argument_list|,
name|sd
argument_list|,
name|sd_next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|disk
operator|->
name|d_subdisks
argument_list|,
name|sd
argument_list|,
name|sd_next
argument_list|)
expr_stmt|;
name|sd
operator|->
name|sd_disk
operator|=
name|disk
expr_stmt|;
block|}
name|oldpd
operator|->
name|pd_disk_pos
operator|=
operator|-
literal|2
expr_stmt|;
name|pd
operator|->
name|pd_disk_pos
operator|=
name|disk_pos
expr_stmt|;
comment|/* If it was placeholder -- destroy it. */
if|if
condition|(
name|olddisk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_OFFLINE
condition|)
block|{
name|g_raid_destroy_disk
argument_list|(
name|olddisk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, make it STALE_FAILED. */
name|g_raid_change_disk_state
argument_list|(
name|olddisk
argument_list|,
name|G_RAID_DISK_S_STALE_FAILED
argument_list|)
expr_stmt|;
comment|/* Update global metadata just in case. */
name|memcpy
argument_list|(
operator|&
name|meta
operator|->
name|disk
index|[
name|disk_pos
index|]
argument_list|,
operator|&
name|pd
operator|->
name|pd_disk_meta
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|intel_raid_disk
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Welcome the new disk. */
if|if
condition|(
operator|(
name|meta
operator|->
name|disk
index|[
name|disk_pos
index|]
operator|.
name|flags
operator|&
name|INTEL_F_DISABLED
operator|)
operator|&&
operator|!
operator|(
name|pd
operator|->
name|pd_disk_meta
operator|.
name|flags
operator|&
name|INTEL_F_SPARE
operator|)
condition|)
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_DISABLED
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|resurrection
condition|)
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_ACTIVE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|meta
operator|->
name|disk
index|[
name|disk_pos
index|]
operator|.
name|flags
operator|&
name|INTEL_F_FAILED
condition|)
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_FAILED
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|meta
operator|->
name|disk
index|[
name|disk_pos
index|]
operator|.
name|flags
operator|&
name|INTEL_F_SPARE
condition|)
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_SPARE
argument_list|)
expr_stmt|;
else|else
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_ACTIVE
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sd
argument_list|,
argument|&disk->d_subdisks
argument_list|,
argument|sd_next
argument_list|)
block|{
name|pv
operator|=
name|sd
operator|->
name|sd_volume
operator|->
name|v_md_data
expr_stmt|;
name|mvol
operator|=
name|intel_get_volume
argument_list|(
name|meta
argument_list|,
name|pv
operator|->
name|pv_volume_pos
argument_list|)
expr_stmt|;
name|mmap0
operator|=
name|intel_get_map
argument_list|(
name|mvol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvol
operator|->
name|migr_state
condition|)
name|mmap1
operator|=
name|intel_get_map
argument_list|(
name|mvol
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|mmap1
operator|=
name|mmap0
expr_stmt|;
name|migr_global
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mmap0
operator|->
name|total_disks
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mmap0
operator|->
name|disk_idx
index|[
name|i
index|]
operator|&
name|INTEL_DI_RBLD
operator|)
operator|==
literal|0
operator|&&
operator|(
name|mmap1
operator|->
name|disk_idx
index|[
name|i
index|]
operator|&
name|INTEL_DI_RBLD
operator|)
operator|!=
literal|0
condition|)
name|migr_global
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|meta
operator|->
name|disk
index|[
name|disk_pos
index|]
operator|.
name|flags
operator|&
name|INTEL_F_DISABLED
operator|)
operator|&&
operator|!
operator|(
name|pd
operator|->
name|pd_disk_meta
operator|.
name|flags
operator|&
name|INTEL_F_SPARE
operator|)
condition|)
block|{
comment|/* Disabled disk, useless. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_NONE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|resurrection
condition|)
block|{
comment|/* Stale disk, almost same as new. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_NEW
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|meta
operator|->
name|disk
index|[
name|disk_pos
index|]
operator|.
name|flags
operator|&
name|INTEL_F_FAILED
condition|)
block|{
comment|/* Failed disk, almost useless. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_FAILED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mvol
operator|->
name|migr_state
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mmap0
operator|->
name|status
operator|==
name|INTEL_S_UNINITIALIZED
operator|&&
operator|(
operator|!
name|pv
operator|->
name|pv_cng
operator|||
name|pv
operator|->
name|pv_cng_master_disk
operator|!=
name|disk_pos
operator|)
condition|)
block|{
comment|/* Freshly created uninitialized volume. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_UNINITIALIZED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mmap0
operator|->
name|disk_idx
index|[
name|sd
operator|->
name|sd_pos
index|]
operator|&
name|INTEL_DI_RBLD
condition|)
block|{
comment|/* Freshly inserted disk. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_NEW
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mvol
operator|->
name|dirty
operator|&&
operator|(
operator|!
name|pv
operator|->
name|pv_cng
operator|||
name|pv
operator|->
name|pv_cng_master_disk
operator|!=
name|disk_pos
operator|)
condition|)
block|{
comment|/* Dirty volume (unclean shutdown). */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_STALE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Up to date disk. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_ACTIVE
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mvol
operator|->
name|migr_type
operator|==
name|INTEL_MT_INIT
operator|||
name|mvol
operator|->
name|migr_type
operator|==
name|INTEL_MT_REBUILD
condition|)
block|{
if|if
condition|(
name|mmap0
operator|->
name|disk_idx
index|[
name|sd
operator|->
name|sd_pos
index|]
operator|&
name|INTEL_DI_RBLD
condition|)
block|{
comment|/* Freshly inserted disk. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_NEW
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mmap1
operator|->
name|disk_idx
index|[
name|sd
operator|->
name|sd_pos
index|]
operator|&
name|INTEL_DI_RBLD
condition|)
block|{
comment|/* Rebuilding disk. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_REBUILD
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvol
operator|->
name|dirty
condition|)
block|{
name|sd
operator|->
name|sd_rebuild_pos
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sd
operator|->
name|sd_rebuild_pos
operator|=
name|intel_get_vol_curr_migr_unit
argument_list|(
name|mvol
argument_list|)
operator|*
name|sd
operator|->
name|sd_volume
operator|->
name|v_strip_size
operator|*
name|mmap0
operator|->
name|total_domains
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mvol
operator|->
name|migr_type
operator|==
name|INTEL_MT_INIT
operator|&&
name|migr_global
condition|)
block|{
comment|/* Freshly created uninitialized volume. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_UNINITIALIZED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mvol
operator|->
name|dirty
operator|&&
operator|(
operator|!
name|pv
operator|->
name|pv_cng
operator|||
name|pv
operator|->
name|pv_cng_master_disk
operator|!=
name|disk_pos
operator|)
condition|)
block|{
comment|/* Dirty volume (unclean shutdown). */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_STALE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Up to date disk. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_ACTIVE
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mvol
operator|->
name|migr_type
operator|==
name|INTEL_MT_VERIFY
operator|||
name|mvol
operator|->
name|migr_type
operator|==
name|INTEL_MT_REPAIR
condition|)
block|{
if|if
condition|(
name|mmap0
operator|->
name|disk_idx
index|[
name|sd
operator|->
name|sd_pos
index|]
operator|&
name|INTEL_DI_RBLD
condition|)
block|{
comment|/* Freshly inserted disk. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_NEW
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|mmap1
operator|->
name|disk_idx
index|[
name|sd
operator|->
name|sd_pos
index|]
operator|&
name|INTEL_DI_RBLD
operator|)
operator|||
name|migr_global
condition|)
block|{
comment|/* Resyncing disk. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_RESYNC
argument_list|)
expr_stmt|;
if|if
condition|(
name|mvol
operator|->
name|dirty
condition|)
block|{
name|sd
operator|->
name|sd_rebuild_pos
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sd
operator|->
name|sd_rebuild_pos
operator|=
name|intel_get_vol_curr_migr_unit
argument_list|(
name|mvol
argument_list|)
operator|*
name|sd
operator|->
name|sd_volume
operator|->
name|v_strip_size
operator|*
name|mmap0
operator|->
name|total_domains
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mvol
operator|->
name|dirty
condition|)
block|{
comment|/* Dirty volume (unclean shutdown). */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_STALE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Up to date disk. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_ACTIVE
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mvol
operator|->
name|migr_type
operator|==
name|INTEL_MT_GEN_MIGR
condition|)
block|{
if|if
condition|(
operator|(
name|mmap1
operator|->
name|disk_idx
index|[
literal|0
index|]
operator|&
name|INTEL_DI_IDX
operator|)
operator|!=
name|disk_pos
condition|)
block|{
comment|/* Freshly inserted disk. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_NEW
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Up to date disk. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_ACTIVE
argument_list|)
expr_stmt|;
block|}
block|}
name|g_raid_event_send
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_E_NEW
argument_list|,
name|G_RAID_EVENT_SUBDISK
argument_list|)
expr_stmt|;
block|}
comment|/* Update status of our need for spare. */
if|if
condition|(
name|mdi
operator|->
name|mdio_started
condition|)
block|{
name|mdi
operator|->
name|mdio_incomplete
operator|=
operator|(
name|g_raid_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID_DISK_S_ACTIVE
argument_list|)
operator|+
name|g_raid_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID_DISK_S_DISABLED
argument_list|)
operator|<
name|meta
operator|->
name|total_disks
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|resurrection
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_disk_md_intel_retaste
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Array is not complete, trying to retaste."
argument_list|)
expr_stmt|;
name|g_retaste
argument_list|(
operator|&
name|g_raid_class
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arg
argument_list|,
name|M_MD_INTEL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_md_intel_refill
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_raid_md_object
modifier|*
name|md
decl_stmt|;
name|struct
name|g_raid_md_intel_object
modifier|*
name|mdi
decl_stmt|;
name|struct
name|intel_raid_conf
modifier|*
name|meta
decl_stmt|;
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|task
modifier|*
name|task
decl_stmt|;
name|int
name|update
decl_stmt|,
name|na
decl_stmt|;
name|md
operator|=
name|sc
operator|->
name|sc_md
expr_stmt|;
name|mdi
operator|=
operator|(
expr|struct
name|g_raid_md_intel_object
operator|*
operator|)
name|md
expr_stmt|;
name|meta
operator|=
name|mdi
operator|->
name|mdio_meta
expr_stmt|;
name|update
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* Make sure we miss anything. */
name|na
operator|=
name|g_raid_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID_DISK_S_ACTIVE
argument_list|)
operator|+
name|g_raid_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID_DISK_S_DISABLED
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|==
name|meta
operator|->
name|total_disks
condition|)
break|break;
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|md
operator|->
name|mdo_softc
argument_list|,
literal|"Array is not complete (%d of %d), "
literal|"trying to refill."
argument_list|,
name|na
argument_list|,
name|meta
operator|->
name|total_disks
argument_list|)
expr_stmt|;
comment|/* Try to get use some of STALE disks. */
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_STALE
condition|)
block|{
name|update
operator|+=
name|g_raid_md_intel_start_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_ACTIVE
operator|||
name|disk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_DISABLED
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|disk
operator|!=
name|NULL
condition|)
continue|continue;
comment|/* Try to get use some of SPARE disks. */
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_SPARE
condition|)
block|{
name|update
operator|+=
name|g_raid_md_intel_start_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_ACTIVE
condition|)
break|break;
block|}
block|}
block|}
do|while
condition|(
name|disk
operator|!=
name|NULL
condition|)
do|;
comment|/* Write new metadata if we changed something. */
if|if
condition|(
name|update
condition|)
block|{
name|g_raid_md_write_intel
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|meta
operator|=
name|mdi
operator|->
name|mdio_meta
expr_stmt|;
block|}
comment|/* Update status of our need for spare. */
name|mdi
operator|->
name|mdio_incomplete
operator|=
operator|(
name|g_raid_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID_DISK_S_ACTIVE
argument_list|)
operator|+
name|g_raid_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID_DISK_S_DISABLED
argument_list|)
operator|<
name|meta
operator|->
name|total_disks
operator|)
expr_stmt|;
comment|/* Request retaste hoping to find spare. */
if|if
condition|(
name|mdi
operator|->
name|mdio_incomplete
condition|)
block|{
name|task
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|task
argument_list|)
argument_list|,
name|M_MD_INTEL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
name|task
argument_list|,
literal|0
argument_list|,
name|g_disk_md_intel_retaste
argument_list|,
name|task
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
name|task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_md_intel_start
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_raid_md_object
modifier|*
name|md
decl_stmt|;
name|struct
name|g_raid_md_intel_object
modifier|*
name|mdi
decl_stmt|;
name|struct
name|g_raid_md_intel_pervolume
modifier|*
name|pv
decl_stmt|;
name|struct
name|g_raid_md_intel_perdisk
modifier|*
name|pd
decl_stmt|;
name|struct
name|intel_raid_conf
modifier|*
name|meta
decl_stmt|;
name|struct
name|intel_raid_vol
modifier|*
name|mvol
decl_stmt|;
name|struct
name|intel_raid_map
modifier|*
name|mmap
decl_stmt|;
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|disk_pos
decl_stmt|;
name|md
operator|=
name|sc
operator|->
name|sc_md
expr_stmt|;
name|mdi
operator|=
operator|(
expr|struct
name|g_raid_md_intel_object
operator|*
operator|)
name|md
expr_stmt|;
name|meta
operator|=
name|mdi
operator|->
name|mdio_meta
expr_stmt|;
comment|/* Create volumes and subdisks. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|meta
operator|->
name|total_volumes
condition|;
name|i
operator|++
control|)
block|{
name|mvol
operator|=
name|intel_get_volume
argument_list|(
name|meta
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mmap
operator|=
name|intel_get_map
argument_list|(
name|mvol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vol
operator|=
name|g_raid_create_volume
argument_list|(
name|sc
argument_list|,
name|mvol
operator|->
name|name
argument_list|,
name|mvol
operator|->
name|tid
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pv
argument_list|)
argument_list|,
name|M_MD_INTEL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pv_volume_pos
operator|=
name|i
expr_stmt|;
name|pv
operator|->
name|pv_cng
operator|=
operator|(
name|mvol
operator|->
name|state
operator|&
name|INTEL_ST_CLONE_N_GO
operator|)
operator|!=
literal|0
expr_stmt|;
name|pv
operator|->
name|pv_cng_man_sync
operator|=
operator|(
name|mvol
operator|->
name|state
operator|&
name|INTEL_ST_CLONE_MAN_SYNC
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|mvol
operator|->
name|cng_master_disk
operator|<
name|mmap
operator|->
name|total_disks
condition|)
name|pv
operator|->
name|pv_cng_master_disk
operator|=
name|mvol
operator|->
name|cng_master_disk
expr_stmt|;
name|vol
operator|->
name|v_md_data
operator|=
name|pv
expr_stmt|;
name|vol
operator|->
name|v_raid_level_qualifier
operator|=
name|G_RAID_VOLUME_RLQ_NONE
expr_stmt|;
if|if
condition|(
name|mmap
operator|->
name|type
operator|==
name|INTEL_T_RAID0
condition|)
name|vol
operator|->
name|v_raid_level
operator|=
name|G_RAID_VOLUME_RL_RAID0
expr_stmt|;
elseif|else
if|if
condition|(
name|mmap
operator|->
name|type
operator|==
name|INTEL_T_RAID1
operator|&&
name|mmap
operator|->
name|total_domains
operator|>=
literal|2
operator|&&
name|mmap
operator|->
name|total_domains
operator|<=
name|mmap
operator|->
name|total_disks
condition|)
block|{
comment|/* Assume total_domains is correct. */
if|if
condition|(
name|mmap
operator|->
name|total_domains
operator|==
name|mmap
operator|->
name|total_disks
condition|)
name|vol
operator|->
name|v_raid_level
operator|=
name|G_RAID_VOLUME_RL_RAID1
expr_stmt|;
else|else
name|vol
operator|->
name|v_raid_level
operator|=
name|G_RAID_VOLUME_RL_RAID1E
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mmap
operator|->
name|type
operator|==
name|INTEL_T_RAID1
condition|)
block|{
comment|/* total_domains looks wrong. */
if|if
condition|(
name|mmap
operator|->
name|total_disks
operator|<=
literal|2
condition|)
name|vol
operator|->
name|v_raid_level
operator|=
name|G_RAID_VOLUME_RL_RAID1
expr_stmt|;
else|else
name|vol
operator|->
name|v_raid_level
operator|=
name|G_RAID_VOLUME_RL_RAID1E
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mmap
operator|->
name|type
operator|==
name|INTEL_T_RAID5
condition|)
block|{
name|vol
operator|->
name|v_raid_level
operator|=
name|G_RAID_VOLUME_RL_RAID5
expr_stmt|;
name|vol
operator|->
name|v_raid_level_qualifier
operator|=
name|G_RAID_VOLUME_RLQ_R5LA
expr_stmt|;
block|}
else|else
name|vol
operator|->
name|v_raid_level
operator|=
name|G_RAID_VOLUME_RL_UNKNOWN
expr_stmt|;
name|vol
operator|->
name|v_strip_size
operator|=
operator|(
name|u_int
operator|)
name|mmap
operator|->
name|strip_sectors
operator|*
literal|512
expr_stmt|;
comment|//ZZZ
name|vol
operator|->
name|v_disks_count
operator|=
name|mmap
operator|->
name|total_disks
expr_stmt|;
name|vol
operator|->
name|v_mediasize
operator|=
operator|(
name|off_t
operator|)
name|mvol
operator|->
name|total_sectors
operator|*
literal|512
expr_stmt|;
comment|//ZZZ
name|vol
operator|->
name|v_sectorsize
operator|=
literal|512
expr_stmt|;
comment|//ZZZ
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|vol
operator|->
name|v_disks_count
condition|;
name|j
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|j
index|]
expr_stmt|;
name|sd
operator|->
name|sd_offset
operator|=
name|intel_get_map_offset
argument_list|(
name|mmap
argument_list|)
operator|*
literal|512
expr_stmt|;
comment|//ZZZ
name|sd
operator|->
name|sd_size
operator|=
name|intel_get_map_disk_sectors
argument_list|(
name|mmap
argument_list|)
operator|*
literal|512
expr_stmt|;
comment|//ZZZ
block|}
name|g_raid_start_volume
argument_list|(
name|vol
argument_list|)
expr_stmt|;
block|}
comment|/* Create disk placeholders to store data for later writing. */
for|for
control|(
name|disk_pos
operator|=
literal|0
init|;
name|disk_pos
operator|<
name|meta
operator|->
name|total_disks
condition|;
name|disk_pos
operator|++
control|)
block|{
name|pd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pd
argument_list|)
argument_list|,
name|M_MD_INTEL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pd
operator|->
name|pd_disk_pos
operator|=
name|disk_pos
expr_stmt|;
name|pd
operator|->
name|pd_disk_meta
operator|=
name|meta
operator|->
name|disk
index|[
name|disk_pos
index|]
expr_stmt|;
name|disk
operator|=
name|g_raid_create_disk
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_md_data
operator|=
operator|(
name|void
operator|*
operator|)
name|pd
expr_stmt|;
name|disk
operator|->
name|d_state
operator|=
name|G_RAID_DISK_S_OFFLINE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|meta
operator|->
name|total_volumes
condition|;
name|i
operator|++
control|)
block|{
name|mvol
operator|=
name|intel_get_volume
argument_list|(
name|meta
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mmap
operator|=
name|intel_get_map
argument_list|(
name|mvol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|mmap
operator|->
name|total_disks
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|mmap
operator|->
name|disk_idx
index|[
name|j
index|]
operator|&
name|INTEL_DI_IDX
operator|)
operator|==
name|disk_pos
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|mmap
operator|->
name|total_disks
condition|)
continue|continue;
name|vol
operator|=
name|g_raid_md_intel_get_volume
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|j
index|]
expr_stmt|;
name|sd
operator|->
name|sd_disk
operator|=
name|disk
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|disk
operator|->
name|d_subdisks
argument_list|,
name|sd
argument_list|,
name|sd_next
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Make all disks found till the moment take their places. */
do|do
block|{
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_NONE
condition|)
block|{
name|g_raid_md_intel_start_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|disk
operator|!=
name|NULL
condition|)
do|;
name|mdi
operator|->
name|mdio_started
operator|=
literal|1
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|0
argument_list|,
name|sc
argument_list|,
literal|"Array started."
argument_list|)
expr_stmt|;
name|g_raid_md_write_intel
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Pickup any STALE/SPARE disks to refill array if needed. */
name|g_raid_md_intel_refill
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vol
argument_list|,
argument|&sc->sc_volumes
argument_list|,
argument|v_next
argument_list|)
block|{
name|g_raid_event_send
argument_list|(
name|vol
argument_list|,
name|G_RAID_VOLUME_E_START
argument_list|,
name|G_RAID_EVENT_VOLUME
argument_list|)
expr_stmt|;
block|}
name|callout_stop
argument_list|(
operator|&
name|mdi
operator|->
name|mdio_start_co
argument_list|)
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"root_mount_rel %p"
argument_list|,
name|mdi
operator|->
name|mdio_rootmount
argument_list|)
expr_stmt|;
name|root_mount_rel
argument_list|(
name|mdi
operator|->
name|mdio_rootmount
argument_list|)
expr_stmt|;
name|mdi
operator|->
name|mdio_rootmount
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_md_intel_new_disk
parameter_list|(
name|struct
name|g_raid_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_md_object
modifier|*
name|md
decl_stmt|;
name|struct
name|g_raid_md_intel_object
modifier|*
name|mdi
decl_stmt|;
name|struct
name|intel_raid_conf
modifier|*
name|pdmeta
decl_stmt|;
name|struct
name|g_raid_md_intel_perdisk
modifier|*
name|pd
decl_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|md
operator|=
name|sc
operator|->
name|sc_md
expr_stmt|;
name|mdi
operator|=
operator|(
expr|struct
name|g_raid_md_intel_object
operator|*
operator|)
name|md
expr_stmt|;
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_intel_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
name|pdmeta
operator|=
name|pd
operator|->
name|pd_meta
expr_stmt|;
if|if
condition|(
name|mdi
operator|->
name|mdio_started
condition|)
block|{
if|if
condition|(
name|g_raid_md_intel_start_disk
argument_list|(
name|disk
argument_list|)
condition|)
name|g_raid_md_write_intel
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If we haven't started yet - check metadata freshness. */
if|if
condition|(
name|mdi
operator|->
name|mdio_meta
operator|==
name|NULL
operator|||
operator|(
call|(
name|int32_t
call|)
argument_list|(
name|pdmeta
operator|->
name|generation
operator|-
name|mdi
operator|->
name|mdio_generation
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"Newer disk"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdi
operator|->
name|mdio_meta
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|mdi
operator|->
name|mdio_meta
argument_list|,
name|M_MD_INTEL
argument_list|)
expr_stmt|;
name|mdi
operator|->
name|mdio_meta
operator|=
name|intel_meta_copy
argument_list|(
name|pdmeta
argument_list|)
expr_stmt|;
name|mdi
operator|->
name|mdio_generation
operator|=
name|mdi
operator|->
name|mdio_meta
operator|->
name|generation
expr_stmt|;
name|mdi
operator|->
name|mdio_disks_present
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pdmeta
operator|->
name|generation
operator|==
name|mdi
operator|->
name|mdio_generation
condition|)
block|{
name|mdi
operator|->
name|mdio_disks_present
operator|++
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"Matching disk (%d of %d up)"
argument_list|,
name|mdi
operator|->
name|mdio_disks_present
argument_list|,
name|mdi
operator|->
name|mdio_meta
operator|->
name|total_disks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"Older disk"
argument_list|)
expr_stmt|;
block|}
comment|/* If we collected all needed disks - start array. */
if|if
condition|(
name|mdi
operator|->
name|mdio_disks_present
operator|==
name|mdi
operator|->
name|mdio_meta
operator|->
name|total_disks
condition|)
name|g_raid_md_intel_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_intel_go
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_md_object
modifier|*
name|md
decl_stmt|;
name|struct
name|g_raid_md_intel_object
modifier|*
name|mdi
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|md
operator|=
name|sc
operator|->
name|sc_md
expr_stmt|;
name|mdi
operator|=
operator|(
expr|struct
name|g_raid_md_intel_object
operator|*
operator|)
name|md
expr_stmt|;
if|if
condition|(
operator|!
name|mdi
operator|->
name|mdio_started
condition|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|0
argument_list|,
name|sc
argument_list|,
literal|"Force array start due to timeout."
argument_list|)
expr_stmt|;
name|g_raid_event_send
argument_list|(
name|sc
argument_list|,
name|G_RAID_NODE_E_START
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_create_intel
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_geom
modifier|*
modifier|*
name|gp
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_md_intel_object
modifier|*
name|mdi
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|mdi
operator|=
operator|(
expr|struct
name|g_raid_md_intel_object
operator|*
operator|)
name|md
expr_stmt|;
name|mdi
operator|->
name|mdio_config_id
operator|=
name|mdi
operator|->
name|mdio_orig_config_id
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|mdi
operator|->
name|mdio_generation
operator|=
literal|0
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"Intel-%08x"
argument_list|,
name|mdi
operator|->
name|mdio_config_id
argument_list|)
expr_stmt|;
name|sc
operator|=
name|g_raid_create_node
argument_list|(
name|mp
argument_list|,
name|name
argument_list|,
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|G_RAID_MD_TASTE_FAIL
operator|)
return|;
name|md
operator|->
name|mdo_softc
operator|=
name|sc
expr_stmt|;
operator|*
name|gp
operator|=
name|sc
operator|->
name|sc_geom
expr_stmt|;
return|return
operator|(
name|G_RAID_MD_TASTE_NEW
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the last N characters of the serial label.  The Linux and  * ataraid(7) code always uses the last 16 characters of the label to  * store into the Intel meta format.  Generalize this to N characters  * since that's easy.  Labels can be up to 20 characters for SATA drives  * and up 251 characters for SAS drives.  Since intel controllers don't  * support SAS drives, just stick with the SATA limits for stack friendliness.  */
end_comment

begin_function
specifier|static
name|int
name|g_raid_md_get_label
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|char
modifier|*
name|serial
parameter_list|,
name|int
name|serlen
parameter_list|)
block|{
name|char
name|serial_buffer
index|[
literal|24
index|]
decl_stmt|;
name|int
name|len
decl_stmt|,
name|error
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|serial_buffer
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_io_getattr
argument_list|(
literal|"GEOM::ident"
argument_list|,
name|cp
argument_list|,
operator|&
name|len
argument_list|,
name|serial_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|len
operator|=
name|strlen
argument_list|(
name|serial_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|serlen
condition|)
name|len
operator|-=
name|serlen
expr_stmt|;
else|else
name|len
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|serial
argument_list|,
name|serial_buffer
operator|+
name|len
argument_list|,
name|serlen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_taste_intel
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_geom
modifier|*
modifier|*
name|gp
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|rcp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_raid_md_intel_object
modifier|*
name|mdi
decl_stmt|,
modifier|*
name|mdi1
decl_stmt|;
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|intel_raid_conf
modifier|*
name|meta
decl_stmt|;
name|struct
name|g_raid_md_intel_perdisk
modifier|*
name|pd
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|geom
decl_stmt|;
name|int
name|error
decl_stmt|,
name|disk_pos
decl_stmt|,
name|result
decl_stmt|,
name|spare
decl_stmt|,
name|len
decl_stmt|;
name|char
name|serial
index|[
name|INTEL_SERIAL_LEN
index|]
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|uint16_t
name|vendor
decl_stmt|;
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Tasting Intel on %s"
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
name|mdi
operator|=
operator|(
expr|struct
name|g_raid_md_intel_object
operator|*
operator|)
name|md
expr_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
comment|/* Read metadata from device. */
name|meta
operator|=
name|NULL
expr_stmt|;
name|vendor
operator|=
literal|0xffff
expr_stmt|;
name|disk_pos
operator|=
literal|0
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|error
operator|=
name|g_raid_md_get_label
argument_list|(
name|cp
argument_list|,
name|serial
argument_list|,
sizeof|sizeof
argument_list|(
name|serial
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Cannot get serial number from %s (error=%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|fail2
goto|;
block|}
name|len
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|geom
operator|->
name|rank
operator|==
literal|1
condition|)
name|g_io_getattr
argument_list|(
literal|"GEOM::hba_vendor"
argument_list|,
name|cp
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|vendor
argument_list|)
expr_stmt|;
name|meta
operator|=
name|intel_meta_read
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|meta
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|g_raid_aggressive_spare
condition|)
block|{
if|if
condition|(
name|vendor
operator|!=
literal|0x8086
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Intel vendor mismatch 0x%04x != 0x8086"
argument_list|,
name|vendor
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"No Intel metadata, forcing spare."
argument_list|)
expr_stmt|;
name|spare
operator|=
literal|2
expr_stmt|;
goto|goto
name|search
goto|;
block|}
block|}
return|return
operator|(
name|G_RAID_MD_TASTE_FAIL
operator|)
return|;
block|}
comment|/* Check this disk position in obtained metadata. */
name|disk_pos
operator|=
name|intel_meta_find_disk
argument_list|(
name|meta
argument_list|,
name|serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk_pos
operator|<
literal|0
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Intel serial '%s' not found"
argument_list|,
name|serial
argument_list|)
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
if|if
condition|(
name|intel_get_disk_sectors
argument_list|(
operator|&
name|meta
operator|->
name|disk
index|[
name|disk_pos
index|]
argument_list|)
operator|!=
operator|(
name|pp
operator|->
name|mediasize
operator|/
name|pp
operator|->
name|sectorsize
operator|)
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Intel size mismatch %ju != %ju"
argument_list|,
name|intel_get_disk_sectors
argument_list|(
operator|&
name|meta
operator|->
name|disk
index|[
name|disk_pos
index|]
argument_list|)
argument_list|,
call|(
name|off_t
call|)
argument_list|(
name|pp
operator|->
name|mediasize
operator|/
name|pp
operator|->
name|sectorsize
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Intel disk position %d"
argument_list|,
name|disk_pos
argument_list|)
expr_stmt|;
name|spare
operator|=
name|meta
operator|->
name|disk
index|[
name|disk_pos
index|]
operator|.
name|flags
operator|&
name|INTEL_F_SPARE
expr_stmt|;
name|search
label|:
comment|/* Search for matching node. */
name|sc
operator|=
name|NULL
expr_stmt|;
name|mdi1
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|geom
argument_list|,
argument|&mp->geom
argument_list|,
argument|geom
argument_list|)
block|{
name|sc
operator|=
name|geom
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|sc
operator|->
name|sc_stopping
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sc
operator|->
name|sc_md
operator|->
name|mdo_class
operator|!=
name|md
operator|->
name|mdo_class
condition|)
continue|continue;
name|mdi1
operator|=
operator|(
expr|struct
name|g_raid_md_intel_object
operator|*
operator|)
name|sc
operator|->
name|sc_md
expr_stmt|;
if|if
condition|(
name|spare
condition|)
block|{
if|if
condition|(
name|mdi1
operator|->
name|mdio_incomplete
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|mdi1
operator|->
name|mdio_config_id
operator|==
name|meta
operator|->
name|config_id
condition|)
break|break;
block|}
block|}
comment|/* Found matching node. */
if|if
condition|(
name|geom
operator|!=
name|NULL
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Found matching array %s"
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|result
operator|=
name|G_RAID_MD_TASTE_EXISTING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|spare
condition|)
block|{
comment|/* Not found needy node -- left for later. */
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Spare is not needed at this time"
argument_list|)
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
else|else
block|{
comment|/* Not found matching node -- create one. */
name|result
operator|=
name|G_RAID_MD_TASTE_NEW
expr_stmt|;
name|mdi
operator|->
name|mdio_config_id
operator|=
name|meta
operator|->
name|config_id
expr_stmt|;
name|mdi
operator|->
name|mdio_orig_config_id
operator|=
name|meta
operator|->
name|orig_config_id
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"Intel-%08x"
argument_list|,
name|meta
operator|->
name|config_id
argument_list|)
expr_stmt|;
name|sc
operator|=
name|g_raid_create_node
argument_list|(
name|mp
argument_list|,
name|name
argument_list|,
name|md
argument_list|)
expr_stmt|;
name|md
operator|->
name|mdo_softc
operator|=
name|sc
expr_stmt|;
name|geom
operator|=
name|sc
operator|->
name|sc_geom
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|mdi
operator|->
name|mdio_start_co
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|mdi
operator|->
name|mdio_start_co
argument_list|,
name|g_raid_start_timeout
operator|*
name|hz
argument_list|,
name|g_raid_intel_go
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|mdi
operator|->
name|mdio_rootmount
operator|=
name|root_mount_hold
argument_list|(
literal|"GRAID-Intel"
argument_list|)
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"root_mount_hold %p"
argument_list|,
name|mdi
operator|->
name|mdio_rootmount
argument_list|)
expr_stmt|;
block|}
comment|/* There is no return after this point, so we close passed consumer. */
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rcp
operator|=
name|g_new_consumer
argument_list|(
name|geom
argument_list|)
expr_stmt|;
name|rcp
operator|->
name|flags
operator||=
name|G_CF_DIRECT_RECEIVE
expr_stmt|;
name|g_attach
argument_list|(
name|rcp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_access
argument_list|(
name|rcp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
comment|//goto fail1;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|pd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pd
argument_list|)
argument_list|,
name|M_MD_INTEL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pd
operator|->
name|pd_meta
operator|=
name|meta
expr_stmt|;
name|pd
operator|->
name|pd_disk_pos
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|spare
operator|==
literal|2
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|pd
operator|->
name|pd_disk_meta
operator|.
name|serial
index|[
literal|0
index|]
argument_list|,
name|serial
argument_list|,
name|INTEL_SERIAL_LEN
argument_list|)
expr_stmt|;
name|intel_set_disk_sectors
argument_list|(
operator|&
name|pd
operator|->
name|pd_disk_meta
argument_list|,
name|pp
operator|->
name|mediasize
operator|/
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|pd
operator|->
name|pd_disk_meta
operator|.
name|id
operator|=
literal|0
expr_stmt|;
name|pd
operator|->
name|pd_disk_meta
operator|.
name|flags
operator|=
name|INTEL_F_SPARE
expr_stmt|;
block|}
else|else
block|{
name|pd
operator|->
name|pd_disk_meta
operator|=
name|meta
operator|->
name|disk
index|[
name|disk_pos
index|]
expr_stmt|;
block|}
name|disk
operator|=
name|g_raid_create_disk
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_md_data
operator|=
operator|(
name|void
operator|*
operator|)
name|pd
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|=
name|rcp
expr_stmt|;
name|rcp
operator|->
name|private
operator|=
name|disk
expr_stmt|;
name|g_raid_get_disk_info
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|g_raid_md_intel_new_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
operator|*
name|gp
operator|=
name|geom
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
name|fail2
label|:
name|g_topology_lock
argument_list|()
expr_stmt|;
name|fail1
label|:
name|free
argument_list|(
name|meta
argument_list|,
name|M_MD_INTEL
argument_list|)
expr_stmt|;
return|return
operator|(
name|G_RAID_MD_TASTE_FAIL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_event_intel
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|g_raid_disk
modifier|*
name|disk
parameter_list|,
name|u_int
name|event
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|struct
name|g_raid_md_intel_object
modifier|*
name|mdi
decl_stmt|;
name|struct
name|g_raid_md_intel_perdisk
modifier|*
name|pd
decl_stmt|;
name|sc
operator|=
name|md
operator|->
name|mdo_softc
expr_stmt|;
name|mdi
operator|=
operator|(
expr|struct
name|g_raid_md_intel_object
operator|*
operator|)
name|md
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|G_RAID_NODE_E_START
case|:
if|if
condition|(
operator|!
name|mdi
operator|->
name|mdio_started
condition|)
name|g_raid_md_intel_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_intel_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|G_RAID_DISK_E_DISCONNECTED
case|:
comment|/* If disk was assigned, just update statuses. */
if|if
condition|(
name|pd
operator|->
name|pd_disk_pos
operator|>=
literal|0
condition|)
block|{
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_OFFLINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_consumer
condition|)
block|{
name|g_raid_kill_consumer
argument_list|(
name|sc
argument_list|,
name|disk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|=
name|NULL
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|sd
argument_list|,
argument|&disk->d_subdisks
argument_list|,
argument|sd_next
argument_list|)
block|{
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_NONE
argument_list|)
expr_stmt|;
name|g_raid_event_send
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_E_DISCONNECTED
argument_list|,
name|G_RAID_EVENT_SUBDISK
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Otherwise -- delete. */
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_NONE
argument_list|)
expr_stmt|;
name|g_raid_destroy_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
comment|/* Write updated metadata to all disks. */
name|g_raid_md_write_intel
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Check if anything left except placeholders. */
if|if
condition|(
name|g_raid_ndisks
argument_list|(
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
name|g_raid_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID_DISK_S_OFFLINE
argument_list|)
condition|)
name|g_raid_destroy_node
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|g_raid_md_intel_refill
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_ctl_intel
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|,
modifier|*
name|vol1
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_raid_md_intel_object
modifier|*
name|mdi
decl_stmt|;
name|struct
name|g_raid_md_intel_pervolume
modifier|*
name|pv
decl_stmt|;
name|struct
name|g_raid_md_intel_perdisk
modifier|*
name|pd
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|char
name|arg
index|[
literal|16
index|]
decl_stmt|,
name|serial
index|[
name|INTEL_SERIAL_LEN
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|nodename
decl_stmt|,
modifier|*
name|verb
decl_stmt|,
modifier|*
name|volname
decl_stmt|,
modifier|*
name|levelname
decl_stmt|,
modifier|*
name|diskname
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|int
modifier|*
name|nargs
decl_stmt|,
modifier|*
name|force
decl_stmt|;
name|off_t
name|off
decl_stmt|,
name|size
decl_stmt|,
name|sectorsize
decl_stmt|,
name|strip
decl_stmt|,
name|disk_sectors
decl_stmt|;
name|intmax_t
modifier|*
name|sizearg
decl_stmt|,
modifier|*
name|striparg
decl_stmt|;
name|int
name|numdisks
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|,
name|level
decl_stmt|,
name|qual
decl_stmt|,
name|update
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|md
operator|->
name|mdo_softc
expr_stmt|;
name|mdi
operator|=
operator|(
expr|struct
name|g_raid_md_intel_object
operator|*
operator|)
name|md
expr_stmt|;
name|verb
operator|=
name|gctl_get_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|gctl_get_paraml
argument_list|(
name|req
argument_list|,
literal|"nargs"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nargs
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"label"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|nargs
operator|<
literal|4
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Invalid number of arguments."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|volname
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
literal|"arg1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volname
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No volume name."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|levelname
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
literal|"arg2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|levelname
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No RAID level."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|3
operator|)
return|;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
name|levelname
argument_list|,
literal|"RAID5"
argument_list|)
operator|==
literal|0
condition|)
name|levelname
operator|=
literal|"RAID5-LA"
expr_stmt|;
if|if
condition|(
name|g_raid_volume_str2level
argument_list|(
name|levelname
argument_list|,
operator|&
name|level
argument_list|,
operator|&
name|qual
argument_list|)
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Unknown RAID level '%s'."
argument_list|,
name|levelname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|4
operator|)
return|;
block|}
name|numdisks
operator|=
operator|*
name|nargs
operator|-
literal|3
expr_stmt|;
name|force
operator|=
name|gctl_get_paraml
argument_list|(
name|req
argument_list|,
literal|"force"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|force
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_raid_md_intel_supported
argument_list|(
name|level
argument_list|,
name|qual
argument_list|,
name|numdisks
argument_list|,
name|force
condition|?
operator|*
name|force
else|:
literal|0
argument_list|)
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Unsupported RAID level "
literal|"(0x%02x/0x%02x), or number of disks (%d)."
argument_list|,
name|level
argument_list|,
name|qual
argument_list|,
name|numdisks
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|5
operator|)
return|;
block|}
comment|/* Search for disks, connect them and probe. */
name|size
operator|=
literal|0x7fffffffffffffffllu
expr_stmt|;
name|sectorsize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdisks
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|"arg%d"
argument_list|,
name|i
operator|+
literal|3
argument_list|)
expr_stmt|;
name|diskname
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskname
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No disk name (%s)."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
literal|6
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|diskname
argument_list|,
literal|"NONE"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cp
operator|=
name|NULL
expr_stmt|;
name|pp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|g_topology_lock
argument_list|()
expr_stmt|;
name|cp
operator|=
name|g_raid_open_consumer
argument_list|(
name|sc
argument_list|,
name|diskname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Can't open disk '%s'."
argument_list|,
name|diskname
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|error
operator|=
operator|-
literal|7
expr_stmt|;
break|break;
block|}
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
block|}
name|pd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pd
argument_list|)
argument_list|,
name|M_MD_INTEL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pd
operator|->
name|pd_disk_pos
operator|=
name|i
expr_stmt|;
name|disk
operator|=
name|g_raid_create_disk
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_md_data
operator|=
operator|(
name|void
operator|*
operator|)
name|pd
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
operator|&
name|pd
operator|->
name|pd_disk_meta
operator|.
name|serial
index|[
literal|0
index|]
argument_list|,
literal|"NONE"
argument_list|)
expr_stmt|;
name|pd
operator|->
name|pd_disk_meta
operator|.
name|id
operator|=
literal|0xffffffff
expr_stmt|;
name|pd
operator|->
name|pd_disk_meta
operator|.
name|flags
operator|=
name|INTEL_F_ASSIGNED
expr_stmt|;
continue|continue;
block|}
name|cp
operator|->
name|private
operator|=
name|disk
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|error
operator|=
name|g_raid_md_get_label
argument_list|(
name|cp
argument_list|,
operator|&
name|pd
operator|->
name|pd_disk_meta
operator|.
name|serial
index|[
literal|0
index|]
argument_list|,
name|INTEL_SERIAL_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Can't get serial for provider '%s'."
argument_list|,
name|diskname
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
literal|8
expr_stmt|;
break|break;
block|}
name|g_raid_get_disk_info
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|intel_set_disk_sectors
argument_list|(
operator|&
name|pd
operator|->
name|pd_disk_meta
argument_list|,
name|pp
operator|->
name|mediasize
operator|/
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|pp
operator|->
name|mediasize
condition|)
name|size
operator|=
name|pp
operator|->
name|mediasize
expr_stmt|;
if|if
condition|(
name|sectorsize
operator|<
name|pp
operator|->
name|sectorsize
condition|)
name|sectorsize
operator|=
name|pp
operator|->
name|sectorsize
expr_stmt|;
name|pd
operator|->
name|pd_disk_meta
operator|.
name|id
operator|=
literal|0
expr_stmt|;
name|pd
operator|->
name|pd_disk_meta
operator|.
name|flags
operator|=
name|INTEL_F_ASSIGNED
operator||
name|INTEL_F_ONLINE
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|sectorsize
operator|<=
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Can't get sector size."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|8
operator|)
return|;
block|}
comment|/* Reserve some space for metadata. */
name|size
operator|-=
operator|(
operator|(
literal|4096
operator|+
name|sectorsize
operator|-
literal|1
operator|)
operator|/
name|sectorsize
operator|)
operator|*
name|sectorsize
expr_stmt|;
comment|/* Handle size argument. */
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sizearg
argument_list|)
expr_stmt|;
name|sizearg
operator|=
name|gctl_get_param
argument_list|(
name|req
argument_list|,
literal|"size"
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sizearg
operator|!=
name|NULL
operator|&&
name|len
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|sizearg
argument_list|)
operator|&&
operator|*
name|sizearg
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|sizearg
operator|>
name|size
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Size too big %lld> %lld."
argument_list|,
operator|(
name|long
name|long
operator|)
operator|*
name|sizearg
argument_list|,
operator|(
name|long
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
name|size
operator|=
operator|*
name|sizearg
expr_stmt|;
block|}
comment|/* Handle strip argument. */
name|strip
operator|=
literal|131072
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|striparg
argument_list|)
expr_stmt|;
name|striparg
operator|=
name|gctl_get_param
argument_list|(
name|req
argument_list|,
literal|"strip"
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|striparg
operator|!=
name|NULL
operator|&&
name|len
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|striparg
argument_list|)
operator|&&
operator|*
name|striparg
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|striparg
operator|<
name|sectorsize
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Strip size too small."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|10
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|striparg
operator|%
name|sectorsize
operator|!=
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Incorrect strip size."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|11
operator|)
return|;
block|}
if|if
condition|(
name|strip
operator|>
literal|65535
operator|*
name|sectorsize
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Strip size too big."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|12
operator|)
return|;
block|}
name|strip
operator|=
operator|*
name|striparg
expr_stmt|;
block|}
comment|/* Round size down to strip or sector. */
if|if
condition|(
name|level
operator|==
name|G_RAID_VOLUME_RL_RAID1
condition|)
name|size
operator|-=
operator|(
name|size
operator|%
name|sectorsize
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|==
name|G_RAID_VOLUME_RL_RAID1E
operator|&&
operator|(
name|numdisks
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|size
operator|-=
operator|(
name|size
operator|%
operator|(
literal|2
operator|*
name|strip
operator|)
operator|)
expr_stmt|;
else|else
name|size
operator|-=
operator|(
name|size
operator|%
name|strip
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Size too small."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|13
operator|)
return|;
block|}
comment|/* We have all we need, create things: volume, ... */
name|mdi
operator|->
name|mdio_started
operator|=
literal|1
expr_stmt|;
name|vol
operator|=
name|g_raid_create_volume
argument_list|(
name|sc
argument_list|,
name|volname
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pv
argument_list|)
argument_list|,
name|M_MD_INTEL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pv_volume_pos
operator|=
literal|0
expr_stmt|;
name|vol
operator|->
name|v_md_data
operator|=
name|pv
expr_stmt|;
name|vol
operator|->
name|v_raid_level
operator|=
name|level
expr_stmt|;
name|vol
operator|->
name|v_raid_level_qualifier
operator|=
name|qual
expr_stmt|;
name|vol
operator|->
name|v_strip_size
operator|=
name|strip
expr_stmt|;
name|vol
operator|->
name|v_disks_count
operator|=
name|numdisks
expr_stmt|;
if|if
condition|(
name|level
operator|==
name|G_RAID_VOLUME_RL_RAID0
condition|)
name|vol
operator|->
name|v_mediasize
operator|=
name|size
operator|*
name|numdisks
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|==
name|G_RAID_VOLUME_RL_RAID1
condition|)
name|vol
operator|->
name|v_mediasize
operator|=
name|size
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|==
name|G_RAID_VOLUME_RL_RAID5
condition|)
name|vol
operator|->
name|v_mediasize
operator|=
name|size
operator|*
operator|(
name|numdisks
operator|-
literal|1
operator|)
expr_stmt|;
else|else
block|{
comment|/* RAID1E */
name|vol
operator|->
name|v_mediasize
operator|=
operator|(
operator|(
name|size
operator|*
name|numdisks
operator|)
operator|/
name|strip
operator|/
literal|2
operator|)
operator|*
name|strip
expr_stmt|;
block|}
name|vol
operator|->
name|v_sectorsize
operator|=
name|sectorsize
expr_stmt|;
name|g_raid_start_volume
argument_list|(
name|vol
argument_list|)
expr_stmt|;
comment|/* , and subdisks. */
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_intel_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|pd
operator|->
name|pd_disk_pos
index|]
expr_stmt|;
name|sd
operator|->
name|sd_disk
operator|=
name|disk
expr_stmt|;
name|sd
operator|->
name|sd_offset
operator|=
literal|0
expr_stmt|;
name|sd
operator|->
name|sd_size
operator|=
name|size
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|disk
operator|->
name|d_subdisks
argument_list|,
name|sd
argument_list|,
name|sd_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_disk
operator|->
name|d_consumer
operator|!=
name|NULL
condition|)
block|{
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|level
operator|==
name|G_RAID_VOLUME_RL_RAID5
condition|)
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_UNINITIALIZED
argument_list|)
expr_stmt|;
else|else
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_ACTIVE
argument_list|)
expr_stmt|;
name|g_raid_event_send
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_E_NEW
argument_list|,
name|G_RAID_EVENT_SUBDISK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_OFFLINE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Write metadata based on created entities. */
name|G_RAID_DEBUG1
argument_list|(
literal|0
argument_list|,
name|sc
argument_list|,
literal|"Array started."
argument_list|)
expr_stmt|;
name|g_raid_md_write_intel
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Pickup any STALE/SPARE disks to refill array if needed. */
name|g_raid_md_intel_refill
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|g_raid_event_send
argument_list|(
name|vol
argument_list|,
name|G_RAID_VOLUME_E_START
argument_list|,
name|G_RAID_EVENT_VOLUME
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"add"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|nargs
operator|!=
literal|3
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Invalid number of arguments."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|volname
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
literal|"arg1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volname
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No volume name."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|levelname
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
literal|"arg2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|levelname
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No RAID level."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|3
operator|)
return|;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
name|levelname
argument_list|,
literal|"RAID5"
argument_list|)
operator|==
literal|0
condition|)
name|levelname
operator|=
literal|"RAID5-LA"
expr_stmt|;
if|if
condition|(
name|g_raid_volume_str2level
argument_list|(
name|levelname
argument_list|,
operator|&
name|level
argument_list|,
operator|&
name|qual
argument_list|)
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Unknown RAID level '%s'."
argument_list|,
name|levelname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|4
operator|)
return|;
block|}
comment|/* Look for existing volumes. */
name|i
operator|=
literal|0
expr_stmt|;
name|vol1
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vol
argument_list|,
argument|&sc->sc_volumes
argument_list|,
argument|v_next
argument_list|)
block|{
name|vol1
operator|=
name|vol
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Maximum two volumes supported."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|6
operator|)
return|;
block|}
if|if
condition|(
name|vol1
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"At least one volume must exist."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|7
operator|)
return|;
block|}
name|numdisks
operator|=
name|vol1
operator|->
name|v_disks_count
expr_stmt|;
name|force
operator|=
name|gctl_get_paraml
argument_list|(
name|req
argument_list|,
literal|"force"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|force
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_raid_md_intel_supported
argument_list|(
name|level
argument_list|,
name|qual
argument_list|,
name|numdisks
argument_list|,
name|force
condition|?
operator|*
name|force
else|:
literal|0
argument_list|)
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Unsupported RAID level "
literal|"(0x%02x/0x%02x), or number of disks (%d)."
argument_list|,
name|level
argument_list|,
name|qual
argument_list|,
name|numdisks
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|5
operator|)
return|;
block|}
comment|/* Collect info about present disks. */
name|size
operator|=
literal|0x7fffffffffffffffllu
expr_stmt|;
name|sectorsize
operator|=
literal|512
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdisks
condition|;
name|i
operator|++
control|)
block|{
name|disk
operator|=
name|vol1
operator|->
name|v_subdisks
index|[
name|i
index|]
operator|.
name|sd_disk
expr_stmt|;
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_intel_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
name|disk_sectors
operator|=
name|intel_get_disk_sectors
argument_list|(
operator|&
name|pd
operator|->
name|pd_disk_meta
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk_sectors
operator|*
literal|512
operator|<
name|size
condition|)
name|size
operator|=
name|disk_sectors
operator|*
literal|512
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_consumer
operator|!=
name|NULL
operator|&&
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|!=
name|NULL
operator|&&
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|->
name|sectorsize
operator|>
name|sectorsize
condition|)
block|{
name|sectorsize
operator|=
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|->
name|sectorsize
expr_stmt|;
block|}
block|}
comment|/* Reserve some space for metadata. */
name|size
operator|-=
operator|(
operator|(
literal|4096
operator|+
name|sectorsize
operator|-
literal|1
operator|)
operator|/
name|sectorsize
operator|)
operator|*
name|sectorsize
expr_stmt|;
comment|/* Decide insert before or after. */
name|sd
operator|=
operator|&
name|vol1
operator|->
name|v_subdisks
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_offset
operator|>
name|size
operator|-
operator|(
name|sd
operator|->
name|sd_offset
operator|+
name|sd
operator|->
name|sd_size
operator|)
condition|)
block|{
name|off
operator|=
literal|0
expr_stmt|;
name|size
operator|=
name|sd
operator|->
name|sd_offset
expr_stmt|;
block|}
else|else
block|{
name|off
operator|=
name|sd
operator|->
name|sd_offset
operator|+
name|sd
operator|->
name|sd_size
expr_stmt|;
name|size
operator|=
name|size
operator|-
operator|(
name|sd
operator|->
name|sd_offset
operator|+
name|sd
operator|->
name|sd_size
operator|)
expr_stmt|;
block|}
comment|/* Handle strip argument. */
name|strip
operator|=
literal|131072
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|striparg
argument_list|)
expr_stmt|;
name|striparg
operator|=
name|gctl_get_param
argument_list|(
name|req
argument_list|,
literal|"strip"
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|striparg
operator|!=
name|NULL
operator|&&
name|len
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|striparg
argument_list|)
operator|&&
operator|*
name|striparg
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|striparg
operator|<
name|sectorsize
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Strip size too small."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|10
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|striparg
operator|%
name|sectorsize
operator|!=
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Incorrect strip size."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|11
operator|)
return|;
block|}
if|if
condition|(
name|strip
operator|>
literal|65535
operator|*
name|sectorsize
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Strip size too big."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|12
operator|)
return|;
block|}
name|strip
operator|=
operator|*
name|striparg
expr_stmt|;
block|}
comment|/* Round offset up to strip. */
if|if
condition|(
name|off
operator|%
name|strip
operator|!=
literal|0
condition|)
block|{
name|size
operator|-=
name|strip
operator|-
name|off
operator|%
name|strip
expr_stmt|;
name|off
operator|+=
name|strip
operator|-
name|off
operator|%
name|strip
expr_stmt|;
block|}
comment|/* Handle size argument. */
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sizearg
argument_list|)
expr_stmt|;
name|sizearg
operator|=
name|gctl_get_param
argument_list|(
name|req
argument_list|,
literal|"size"
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sizearg
operator|!=
name|NULL
operator|&&
name|len
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|sizearg
argument_list|)
operator|&&
operator|*
name|sizearg
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|sizearg
operator|>
name|size
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Size too big %lld> %lld."
argument_list|,
operator|(
name|long
name|long
operator|)
operator|*
name|sizearg
argument_list|,
operator|(
name|long
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
name|size
operator|=
operator|*
name|sizearg
expr_stmt|;
block|}
comment|/* Round size down to strip or sector. */
if|if
condition|(
name|level
operator|==
name|G_RAID_VOLUME_RL_RAID1
condition|)
name|size
operator|-=
operator|(
name|size
operator|%
name|sectorsize
operator|)
expr_stmt|;
else|else
name|size
operator|-=
operator|(
name|size
operator|%
name|strip
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Size too small."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|13
operator|)
return|;
block|}
if|if
condition|(
name|size
operator|>
literal|0xffffffffllu
operator|*
name|sectorsize
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Size too big."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|14
operator|)
return|;
block|}
comment|/* We have all we need, create things: volume, ... */
name|vol
operator|=
name|g_raid_create_volume
argument_list|(
name|sc
argument_list|,
name|volname
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pv
argument_list|)
argument_list|,
name|M_MD_INTEL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pv_volume_pos
operator|=
name|i
expr_stmt|;
name|vol
operator|->
name|v_md_data
operator|=
name|pv
expr_stmt|;
name|vol
operator|->
name|v_raid_level
operator|=
name|level
expr_stmt|;
name|vol
operator|->
name|v_raid_level_qualifier
operator|=
name|qual
expr_stmt|;
name|vol
operator|->
name|v_strip_size
operator|=
name|strip
expr_stmt|;
name|vol
operator|->
name|v_disks_count
operator|=
name|numdisks
expr_stmt|;
if|if
condition|(
name|level
operator|==
name|G_RAID_VOLUME_RL_RAID0
condition|)
name|vol
operator|->
name|v_mediasize
operator|=
name|size
operator|*
name|numdisks
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|==
name|G_RAID_VOLUME_RL_RAID1
condition|)
name|vol
operator|->
name|v_mediasize
operator|=
name|size
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|==
name|G_RAID_VOLUME_RL_RAID5
condition|)
name|vol
operator|->
name|v_mediasize
operator|=
name|size
operator|*
operator|(
name|numdisks
operator|-
literal|1
operator|)
expr_stmt|;
else|else
block|{
comment|/* RAID1E */
name|vol
operator|->
name|v_mediasize
operator|=
operator|(
operator|(
name|size
operator|*
name|numdisks
operator|)
operator|/
name|strip
operator|/
literal|2
operator|)
operator|*
name|strip
expr_stmt|;
block|}
name|vol
operator|->
name|v_sectorsize
operator|=
name|sectorsize
expr_stmt|;
name|g_raid_start_volume
argument_list|(
name|vol
argument_list|)
expr_stmt|;
comment|/* , and subdisks. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdisks
condition|;
name|i
operator|++
control|)
block|{
name|disk
operator|=
name|vol1
operator|->
name|v_subdisks
index|[
name|i
index|]
operator|.
name|sd_disk
expr_stmt|;
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
expr_stmt|;
name|sd
operator|->
name|sd_disk
operator|=
name|disk
expr_stmt|;
name|sd
operator|->
name|sd_offset
operator|=
name|off
expr_stmt|;
name|sd
operator|->
name|sd_size
operator|=
name|size
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|disk
operator|->
name|d_subdisks
argument_list|,
name|sd
argument_list|,
name|sd_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_ACTIVE
condition|)
block|{
if|if
condition|(
name|level
operator|==
name|G_RAID_VOLUME_RL_RAID5
condition|)
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_UNINITIALIZED
argument_list|)
expr_stmt|;
else|else
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_ACTIVE
argument_list|)
expr_stmt|;
name|g_raid_event_send
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_E_NEW
argument_list|,
name|G_RAID_EVENT_SUBDISK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Write metadata based on created entities. */
name|g_raid_md_write_intel
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|g_raid_event_send
argument_list|(
name|vol
argument_list|,
name|G_RAID_VOLUME_E_START
argument_list|,
name|G_RAID_EVENT_VOLUME
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"delete"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nodename
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
literal|"arg0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodename
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|sc
operator|->
name|sc_name
argument_list|,
name|nodename
argument_list|)
operator|!=
literal|0
condition|)
name|nodename
operator|=
name|NULL
expr_stmt|;
comment|/* Full node destruction. */
if|if
condition|(
operator|*
name|nargs
operator|==
literal|1
operator|&&
name|nodename
operator|!=
name|NULL
condition|)
block|{
comment|/* Check if some volume is still open. */
name|force
operator|=
name|gctl_get_paraml
argument_list|(
name|req
argument_list|,
literal|"force"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|force
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|force
operator|!=
name|NULL
operator|&&
operator|*
name|force
operator|==
literal|0
operator|&&
name|g_raid_nopens
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Some volume is still open."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|4
operator|)
return|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_consumer
condition|)
name|intel_meta_erase
argument_list|(
name|disk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
block|}
name|g_raid_destroy_node
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Destroy specified volume. If it was last - all node. */
if|if
condition|(
operator|*
name|nargs
operator|>
literal|2
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Invalid number of arguments."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|volname
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
name|nodename
operator|!=
name|NULL
condition|?
literal|"arg1"
else|:
literal|"arg0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volname
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No volume name."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
comment|/* Search for volume. */
name|TAILQ_FOREACH
argument_list|(
argument|vol
argument_list|,
argument|&sc->sc_volumes
argument_list|,
argument|v_next
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|vol
operator|->
name|v_name
argument_list|,
name|volname
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|pp
operator|=
name|vol
operator|->
name|v_provider
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|pp
operator|->
name|name
argument_list|,
name|volname
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|strncmp
argument_list|(
name|pp
operator|->
name|name
argument_list|,
literal|"raid/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|pp
operator|->
name|name
operator|+
literal|5
argument_list|,
name|volname
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|vol
operator|==
name|NULL
condition|)
block|{
name|i
operator|=
name|strtol
argument_list|(
name|volname
argument_list|,
operator|&
name|tmp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|verb
operator|!=
name|volname
operator|&&
name|tmp
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|vol
argument_list|,
argument|&sc->sc_volumes
argument_list|,
argument|v_next
argument_list|)
block|{
if|if
condition|(
name|vol
operator|->
name|v_global_id
operator|==
name|i
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
name|vol
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Volume '%s' not found."
argument_list|,
name|volname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|3
operator|)
return|;
block|}
comment|/* Check if volume is still open. */
name|force
operator|=
name|gctl_get_paraml
argument_list|(
name|req
argument_list|,
literal|"force"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|force
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|force
operator|!=
name|NULL
operator|&&
operator|*
name|force
operator|==
literal|0
operator|&&
name|vol
operator|->
name|v_provider_open
operator|!=
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Volume is still open."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|4
operator|)
return|;
block|}
comment|/* Destroy volume and potentially node. */
name|i
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vol1
argument_list|,
argument|&sc->sc_volumes
argument_list|,
argument|v_next
argument_list|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|2
condition|)
block|{
name|g_raid_destroy_volume
argument_list|(
name|vol
argument_list|)
expr_stmt|;
name|g_raid_md_write_intel
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_consumer
condition|)
name|intel_meta_erase
argument_list|(
name|disk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
block|}
name|g_raid_destroy_node
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"remove"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"fail"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|nargs
operator|<
literal|2
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Invalid number of arguments."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|*
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|"arg%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|diskname
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskname
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No disk name (%s)."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|diskname
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|diskname
operator|+=
literal|5
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_consumer
operator|!=
name|NULL
operator|&&
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|->
name|name
argument_list|,
name|diskname
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Disk '%s' not found."
argument_list|,
name|diskname
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
literal|3
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"fail"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|g_raid_md_fail_disk_intel
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|disk
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_intel_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
comment|/* Erase metadata on deleting disk. */
name|intel_meta_erase
argument_list|(
name|disk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
comment|/* If disk was assigned, just update statuses. */
if|if
condition|(
name|pd
operator|->
name|pd_disk_pos
operator|>=
literal|0
condition|)
block|{
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_OFFLINE
argument_list|)
expr_stmt|;
name|g_raid_kill_consumer
argument_list|(
name|sc
argument_list|,
name|disk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sd
argument_list|,
argument|&disk->d_subdisks
argument_list|,
argument|sd_next
argument_list|)
block|{
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_NONE
argument_list|)
expr_stmt|;
name|g_raid_event_send
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_E_DISCONNECTED
argument_list|,
name|G_RAID_EVENT_SUBDISK
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Otherwise -- delete. */
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_NONE
argument_list|)
expr_stmt|;
name|g_raid_destroy_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Write updated metadata to remaining disks. */
name|g_raid_md_write_intel
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Check if anything left except placeholders. */
if|if
condition|(
name|g_raid_ndisks
argument_list|(
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
name|g_raid_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID_DISK_S_OFFLINE
argument_list|)
condition|)
name|g_raid_destroy_node
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|g_raid_md_intel_refill
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"insert"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|nargs
operator|<
literal|2
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Invalid number of arguments."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|update
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|*
name|nargs
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get disk name. */
name|snprintf
argument_list|(
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|"arg%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|diskname
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskname
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No disk name (%s)."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
literal|3
expr_stmt|;
break|break;
block|}
comment|/* Try to find provider with specified name. */
name|g_topology_lock
argument_list|()
expr_stmt|;
name|cp
operator|=
name|g_raid_open_consumer
argument_list|(
name|sc
argument_list|,
name|diskname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Can't open disk '%s'."
argument_list|,
name|diskname
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|error
operator|=
operator|-
literal|4
expr_stmt|;
break|break;
block|}
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
comment|/* Read disk serial. */
name|error
operator|=
name|g_raid_md_get_label
argument_list|(
name|cp
argument_list|,
operator|&
name|serial
index|[
literal|0
index|]
argument_list|,
name|INTEL_SERIAL_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Can't get serial for provider '%s'."
argument_list|,
name|diskname
argument_list|)
expr_stmt|;
name|g_raid_kill_consumer
argument_list|(
name|sc
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
literal|7
expr_stmt|;
break|break;
block|}
name|pd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pd
argument_list|)
argument_list|,
name|M_MD_INTEL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pd
operator|->
name|pd_disk_pos
operator|=
operator|-
literal|1
expr_stmt|;
name|disk
operator|=
name|g_raid_create_disk
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|=
name|cp
expr_stmt|;
name|disk
operator|->
name|d_md_data
operator|=
operator|(
name|void
operator|*
operator|)
name|pd
expr_stmt|;
name|cp
operator|->
name|private
operator|=
name|disk
expr_stmt|;
name|g_raid_get_disk_info
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|pd
operator|->
name|pd_disk_meta
operator|.
name|serial
index|[
literal|0
index|]
argument_list|,
operator|&
name|serial
index|[
literal|0
index|]
argument_list|,
name|INTEL_SERIAL_LEN
argument_list|)
expr_stmt|;
name|intel_set_disk_sectors
argument_list|(
operator|&
name|pd
operator|->
name|pd_disk_meta
argument_list|,
name|pp
operator|->
name|mediasize
operator|/
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|pd
operator|->
name|pd_disk_meta
operator|.
name|id
operator|=
literal|0
expr_stmt|;
name|pd
operator|->
name|pd_disk_meta
operator|.
name|flags
operator|=
name|INTEL_F_SPARE
expr_stmt|;
comment|/* Welcome the "new" disk. */
name|update
operator|+=
name|g_raid_md_intel_start_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_SPARE
condition|)
block|{
name|intel_meta_write_spare
argument_list|(
name|cp
argument_list|,
operator|&
name|pd
operator|->
name|pd_disk_meta
argument_list|)
expr_stmt|;
name|g_raid_destroy_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_RAID_DISK_S_ACTIVE
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Disk '%s' doesn't fit."
argument_list|,
name|diskname
argument_list|)
expr_stmt|;
name|g_raid_destroy_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
literal|8
expr_stmt|;
break|break;
block|}
block|}
comment|/* Write new metadata if we changed something. */
if|if
condition|(
name|update
condition|)
name|g_raid_md_write_intel
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|100
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_write_intel
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|g_raid_volume
modifier|*
name|tvol
parameter_list|,
name|struct
name|g_raid_subdisk
modifier|*
name|tsd
parameter_list|,
name|struct
name|g_raid_disk
modifier|*
name|tdisk
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_raid_md_intel_object
modifier|*
name|mdi
decl_stmt|;
name|struct
name|g_raid_md_intel_pervolume
modifier|*
name|pv
decl_stmt|;
name|struct
name|g_raid_md_intel_perdisk
modifier|*
name|pd
decl_stmt|;
name|struct
name|intel_raid_conf
modifier|*
name|meta
decl_stmt|;
name|struct
name|intel_raid_vol
modifier|*
name|mvol
decl_stmt|;
name|struct
name|intel_raid_map
modifier|*
name|mmap0
decl_stmt|,
modifier|*
name|mmap1
decl_stmt|;
name|off_t
name|sectorsize
init|=
literal|512
decl_stmt|,
name|pos
decl_stmt|;
specifier|const
name|char
modifier|*
name|version
decl_stmt|,
modifier|*
name|cv
decl_stmt|;
name|int
name|vi
decl_stmt|,
name|sdi
decl_stmt|,
name|numdisks
decl_stmt|,
name|len
decl_stmt|,
name|state
decl_stmt|,
name|stale
decl_stmt|;
name|sc
operator|=
name|md
operator|->
name|mdo_softc
expr_stmt|;
name|mdi
operator|=
operator|(
expr|struct
name|g_raid_md_intel_object
operator|*
operator|)
name|md
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_stopping
operator|==
name|G_RAID_DESTROY_HARD
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Bump generation. Newly written metadata may differ from previous. */
name|mdi
operator|->
name|mdio_generation
operator|++
expr_stmt|;
comment|/* Count number of disks. */
name|numdisks
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_intel_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|pd_disk_pos
operator|<
literal|0
condition|)
continue|continue;
name|numdisks
operator|++
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_ACTIVE
condition|)
block|{
name|pd
operator|->
name|pd_disk_meta
operator|.
name|flags
operator|=
name|INTEL_F_ONLINE
operator||
name|INTEL_F_ASSIGNED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_FAILED
condition|)
block|{
name|pd
operator|->
name|pd_disk_meta
operator|.
name|flags
operator|=
name|INTEL_F_FAILED
operator||
name|INTEL_F_ASSIGNED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_DISABLED
condition|)
block|{
name|pd
operator|->
name|pd_disk_meta
operator|.
name|flags
operator|=
name|INTEL_F_FAILED
operator||
name|INTEL_F_ASSIGNED
operator||
name|INTEL_F_DISABLED
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|pd
operator|->
name|pd_disk_meta
operator|.
name|flags
operator|&
name|INTEL_F_DISABLED
operator|)
condition|)
name|pd
operator|->
name|pd_disk_meta
operator|.
name|flags
operator|=
name|INTEL_F_ASSIGNED
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|pd_disk_meta
operator|.
name|id
operator|!=
literal|0xffffffff
condition|)
block|{
name|pd
operator|->
name|pd_disk_meta
operator|.
name|id
operator|=
literal|0xffffffff
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|pd
operator|->
name|pd_disk_meta
operator|.
name|serial
argument_list|)
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|INTEL_SERIAL_LEN
operator|-
literal|3
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|pd
operator|->
name|pd_disk_meta
operator|.
name|serial
operator|+
name|len
argument_list|,
literal|":0"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Fill anchor and disks. */
name|meta
operator|=
name|malloc
argument_list|(
name|INTEL_MAX_MD_SIZE
argument_list|(
name|numdisks
argument_list|)
argument_list|,
name|M_MD_INTEL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|meta
operator|->
name|intel_id
index|[
literal|0
index|]
argument_list|,
name|INTEL_MAGIC
argument_list|,
sizeof|sizeof
argument_list|(
name|INTEL_MAGIC
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|meta
operator|->
name|config_size
operator|=
name|INTEL_MAX_MD_SIZE
argument_list|(
name|numdisks
argument_list|)
expr_stmt|;
name|meta
operator|->
name|config_id
operator|=
name|mdi
operator|->
name|mdio_config_id
expr_stmt|;
name|meta
operator|->
name|orig_config_id
operator|=
name|mdi
operator|->
name|mdio_orig_config_id
expr_stmt|;
name|meta
operator|->
name|generation
operator|=
name|mdi
operator|->
name|mdio_generation
expr_stmt|;
name|meta
operator|->
name|attributes
operator|=
name|INTEL_ATTR_CHECKSUM
expr_stmt|;
name|meta
operator|->
name|total_disks
operator|=
name|numdisks
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_intel_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|pd_disk_pos
operator|<
literal|0
condition|)
continue|continue;
name|meta
operator|->
name|disk
index|[
name|pd
operator|->
name|pd_disk_pos
index|]
operator|=
name|pd
operator|->
name|pd_disk_meta
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|pd_disk_meta
operator|.
name|sectors_hi
operator|!=
literal|0
condition|)
name|meta
operator|->
name|attributes
operator||=
name|INTEL_ATTR_2TB_DISK
expr_stmt|;
block|}
comment|/* Fill volumes and maps. */
name|vi
operator|=
literal|0
expr_stmt|;
name|version
operator|=
name|INTEL_VERSION_1000
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vol
argument_list|,
argument|&sc->sc_volumes
argument_list|,
argument|v_next
argument_list|)
block|{
name|pv
operator|=
name|vol
operator|->
name|v_md_data
expr_stmt|;
if|if
condition|(
name|vol
operator|->
name|v_stopping
condition|)
continue|continue;
name|mvol
operator|=
name|intel_get_volume
argument_list|(
name|meta
argument_list|,
name|vi
argument_list|)
expr_stmt|;
comment|/* New metadata may have different volumes order. */
name|pv
operator|->
name|pv_volume_pos
operator|=
name|vi
expr_stmt|;
for|for
control|(
name|sdi
operator|=
literal|0
init|;
name|sdi
operator|<
name|vol
operator|->
name|v_disks_count
condition|;
name|sdi
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|sdi
index|]
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_disk
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|sdi
operator|>=
name|vol
operator|->
name|v_disks_count
condition|)
name|panic
argument_list|(
literal|"No any filled subdisk in volume"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vol
operator|->
name|v_mediasize
operator|>=
literal|0x20000000000llu
condition|)
name|meta
operator|->
name|attributes
operator||=
name|INTEL_ATTR_2TB
expr_stmt|;
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID0
condition|)
name|meta
operator|->
name|attributes
operator||=
name|INTEL_ATTR_RAID0
expr_stmt|;
elseif|else
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID1
condition|)
name|meta
operator|->
name|attributes
operator||=
name|INTEL_ATTR_RAID1
expr_stmt|;
elseif|else
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID5
condition|)
name|meta
operator|->
name|attributes
operator||=
name|INTEL_ATTR_RAID5
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|vol
operator|->
name|v_disks_count
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|meta
operator|->
name|attributes
operator||=
name|INTEL_ATTR_RAID10
expr_stmt|;
else|else
name|meta
operator|->
name|attributes
operator||=
name|INTEL_ATTR_RAID1E
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|pv_cng
condition|)
name|meta
operator|->
name|attributes
operator||=
name|INTEL_ATTR_RAIDCNG
expr_stmt|;
if|if
condition|(
name|vol
operator|->
name|v_strip_size
operator|>
literal|131072
condition|)
name|meta
operator|->
name|attributes
operator||=
name|INTEL_ATTR_EXT_STRIP
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|pv_cng
condition|)
name|cv
operator|=
name|INTEL_VERSION_1206
expr_stmt|;
elseif|else
if|if
condition|(
name|vol
operator|->
name|v_disks_count
operator|>
literal|4
condition|)
name|cv
operator|=
name|INTEL_VERSION_1204
expr_stmt|;
elseif|else
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID5
condition|)
name|cv
operator|=
name|INTEL_VERSION_1202
expr_stmt|;
elseif|else
if|if
condition|(
name|vol
operator|->
name|v_disks_count
operator|>
literal|2
condition|)
name|cv
operator|=
name|INTEL_VERSION_1201
expr_stmt|;
elseif|else
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID1
condition|)
name|cv
operator|=
name|INTEL_VERSION_1100
expr_stmt|;
else|else
name|cv
operator|=
name|INTEL_VERSION_1000
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cv
argument_list|,
name|version
argument_list|)
operator|>
literal|0
condition|)
name|version
operator|=
name|cv
expr_stmt|;
name|strlcpy
argument_list|(
operator|&
name|mvol
operator|->
name|name
index|[
literal|0
index|]
argument_list|,
name|vol
operator|->
name|v_name
argument_list|,
sizeof|sizeof
argument_list|(
name|mvol
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|mvol
operator|->
name|total_sectors
operator|=
name|vol
operator|->
name|v_mediasize
operator|/
name|sectorsize
expr_stmt|;
name|mvol
operator|->
name|state
operator|=
operator|(
name|INTEL_ST_READ_COALESCING
operator||
name|INTEL_ST_WRITE_COALESCING
operator|)
expr_stmt|;
name|mvol
operator|->
name|tid
operator|=
name|vol
operator|->
name|v_global_id
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|pv_cng
condition|)
block|{
name|mvol
operator|->
name|state
operator||=
name|INTEL_ST_CLONE_N_GO
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|pv_cng_man_sync
condition|)
name|mvol
operator|->
name|state
operator||=
name|INTEL_ST_CLONE_MAN_SYNC
expr_stmt|;
name|mvol
operator|->
name|cng_master_disk
operator|=
name|pv
operator|->
name|pv_cng_master_disk
expr_stmt|;
if|if
condition|(
name|vol
operator|->
name|v_subdisks
index|[
name|pv
operator|->
name|pv_cng_master_disk
index|]
operator|.
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_NONE
condition|)
name|mvol
operator|->
name|cng_state
operator|=
name|INTEL_CNGST_MASTER_MISSING
expr_stmt|;
elseif|else
if|if
condition|(
name|vol
operator|->
name|v_state
operator|!=
name|G_RAID_VOLUME_S_OPTIMAL
condition|)
name|mvol
operator|->
name|cng_state
operator|=
name|INTEL_CNGST_NEEDS_UPDATE
expr_stmt|;
else|else
name|mvol
operator|->
name|cng_state
operator|=
name|INTEL_CNGST_UPDATED
expr_stmt|;
block|}
comment|/* Check for any recovery in progress. */
name|state
operator|=
name|G_RAID_SUBDISK_S_ACTIVE
expr_stmt|;
name|pos
operator|=
literal|0x7fffffffffffffffllu
expr_stmt|;
name|stale
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sdi
operator|=
literal|0
init|;
name|sdi
operator|<
name|vol
operator|->
name|v_disks_count
condition|;
name|sdi
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|sdi
index|]
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_REBUILD
condition|)
name|state
operator|=
name|G_RAID_SUBDISK_S_REBUILD
expr_stmt|;
elseif|else
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_RESYNC
operator|&&
name|state
operator|!=
name|G_RAID_SUBDISK_S_REBUILD
condition|)
name|state
operator|=
name|G_RAID_SUBDISK_S_RESYNC
expr_stmt|;
elseif|else
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_STALE
condition|)
name|stale
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_REBUILD
operator|||
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_RESYNC
operator|)
operator|&&
name|sd
operator|->
name|sd_rebuild_pos
operator|<
name|pos
condition|)
name|pos
operator|=
name|sd
operator|->
name|sd_rebuild_pos
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|==
name|G_RAID_SUBDISK_S_REBUILD
condition|)
block|{
name|mvol
operator|->
name|migr_state
operator|=
literal|1
expr_stmt|;
name|mvol
operator|->
name|migr_type
operator|=
name|INTEL_MT_REBUILD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|==
name|G_RAID_SUBDISK_S_RESYNC
condition|)
block|{
name|mvol
operator|->
name|migr_state
operator|=
literal|1
expr_stmt|;
comment|/* mvol->migr_type = INTEL_MT_REPAIR; */
name|mvol
operator|->
name|migr_type
operator|=
name|INTEL_MT_VERIFY
expr_stmt|;
name|mvol
operator|->
name|state
operator||=
name|INTEL_ST_VERIFY_AND_FIX
expr_stmt|;
block|}
else|else
name|mvol
operator|->
name|migr_state
operator|=
literal|0
expr_stmt|;
name|mvol
operator|->
name|dirty
operator|=
operator|(
name|vol
operator|->
name|v_dirty
operator|||
name|stale
operator|)
expr_stmt|;
name|mmap0
operator|=
name|intel_get_map
argument_list|(
name|mvol
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Write map / common part of two maps. */
name|intel_set_map_offset
argument_list|(
name|mmap0
argument_list|,
name|sd
operator|->
name|sd_offset
operator|/
name|sectorsize
argument_list|)
expr_stmt|;
name|intel_set_map_disk_sectors
argument_list|(
name|mmap0
argument_list|,
name|sd
operator|->
name|sd_size
operator|/
name|sectorsize
argument_list|)
expr_stmt|;
name|mmap0
operator|->
name|strip_sectors
operator|=
name|vol
operator|->
name|v_strip_size
operator|/
name|sectorsize
expr_stmt|;
if|if
condition|(
name|vol
operator|->
name|v_state
operator|==
name|G_RAID_VOLUME_S_BROKEN
condition|)
name|mmap0
operator|->
name|status
operator|=
name|INTEL_S_FAILURE
expr_stmt|;
elseif|else
if|if
condition|(
name|vol
operator|->
name|v_state
operator|==
name|G_RAID_VOLUME_S_DEGRADED
condition|)
name|mmap0
operator|->
name|status
operator|=
name|INTEL_S_DEGRADED
expr_stmt|;
elseif|else
if|if
condition|(
name|g_raid_nsubdisks
argument_list|(
name|vol
argument_list|,
name|G_RAID_SUBDISK_S_UNINITIALIZED
argument_list|)
operator|==
name|g_raid_nsubdisks
argument_list|(
name|vol
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
name|mmap0
operator|->
name|status
operator|=
name|INTEL_S_UNINITIALIZED
expr_stmt|;
else|else
name|mmap0
operator|->
name|status
operator|=
name|INTEL_S_READY
expr_stmt|;
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID0
condition|)
name|mmap0
operator|->
name|type
operator|=
name|INTEL_T_RAID0
expr_stmt|;
elseif|else
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID1
operator|||
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID1E
condition|)
name|mmap0
operator|->
name|type
operator|=
name|INTEL_T_RAID1
expr_stmt|;
else|else
name|mmap0
operator|->
name|type
operator|=
name|INTEL_T_RAID5
expr_stmt|;
name|mmap0
operator|->
name|total_disks
operator|=
name|vol
operator|->
name|v_disks_count
expr_stmt|;
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID1
condition|)
name|mmap0
operator|->
name|total_domains
operator|=
name|vol
operator|->
name|v_disks_count
expr_stmt|;
elseif|else
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID1E
condition|)
name|mmap0
operator|->
name|total_domains
operator|=
literal|2
expr_stmt|;
else|else
name|mmap0
operator|->
name|total_domains
operator|=
literal|1
expr_stmt|;
name|intel_set_map_stripe_count
argument_list|(
name|mmap0
argument_list|,
name|sd
operator|->
name|sd_size
operator|/
name|vol
operator|->
name|v_strip_size
operator|/
name|mmap0
operator|->
name|total_domains
argument_list|)
expr_stmt|;
name|mmap0
operator|->
name|failed_disk_num
operator|=
literal|0xff
expr_stmt|;
name|mmap0
operator|->
name|ddf
operator|=
literal|1
expr_stmt|;
comment|/* If there are two maps - copy common and update. */
if|if
condition|(
name|mvol
operator|->
name|migr_state
condition|)
block|{
name|intel_set_vol_curr_migr_unit
argument_list|(
name|mvol
argument_list|,
name|pos
operator|/
name|vol
operator|->
name|v_strip_size
operator|/
name|mmap0
operator|->
name|total_domains
argument_list|)
expr_stmt|;
name|mmap1
operator|=
name|intel_get_map
argument_list|(
name|mvol
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|mmap1
argument_list|,
name|mmap0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|intel_raid_map
argument_list|)
argument_list|)
expr_stmt|;
name|mmap0
operator|->
name|status
operator|=
name|INTEL_S_READY
expr_stmt|;
block|}
else|else
name|mmap1
operator|=
name|NULL
expr_stmt|;
comment|/* Write disk indexes and put rebuild flags. */
for|for
control|(
name|sdi
operator|=
literal|0
init|;
name|sdi
operator|<
name|vol
operator|->
name|v_disks_count
condition|;
name|sdi
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|sdi
index|]
expr_stmt|;
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_intel_perdisk
operator|*
operator|)
name|sd
operator|->
name|sd_disk
operator|->
name|d_md_data
expr_stmt|;
name|mmap0
operator|->
name|disk_idx
index|[
name|sdi
index|]
operator|=
name|pd
operator|->
name|pd_disk_pos
expr_stmt|;
if|if
condition|(
name|mvol
operator|->
name|migr_state
condition|)
name|mmap1
operator|->
name|disk_idx
index|[
name|sdi
index|]
operator|=
name|pd
operator|->
name|pd_disk_pos
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_REBUILD
operator|||
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_RESYNC
condition|)
block|{
name|mmap1
operator|->
name|disk_idx
index|[
name|sdi
index|]
operator||=
name|INTEL_DI_RBLD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|!=
name|G_RAID_SUBDISK_S_ACTIVE
operator|&&
name|sd
operator|->
name|sd_state
operator|!=
name|G_RAID_SUBDISK_S_STALE
operator|&&
name|sd
operator|->
name|sd_state
operator|!=
name|G_RAID_SUBDISK_S_UNINITIALIZED
condition|)
block|{
name|mmap0
operator|->
name|disk_idx
index|[
name|sdi
index|]
operator||=
name|INTEL_DI_RBLD
expr_stmt|;
if|if
condition|(
name|mvol
operator|->
name|migr_state
condition|)
name|mmap1
operator|->
name|disk_idx
index|[
name|sdi
index|]
operator||=
name|INTEL_DI_RBLD
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_NONE
operator|||
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_FAILED
operator|||
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_REBUILD
operator|)
operator|&&
name|mmap0
operator|->
name|failed_disk_num
operator|==
literal|0xff
condition|)
block|{
name|mmap0
operator|->
name|failed_disk_num
operator|=
name|sdi
expr_stmt|;
if|if
condition|(
name|mvol
operator|->
name|migr_state
condition|)
name|mmap1
operator|->
name|failed_disk_num
operator|=
name|sdi
expr_stmt|;
block|}
block|}
name|vi
operator|++
expr_stmt|;
block|}
name|meta
operator|->
name|total_volumes
operator|=
name|vi
expr_stmt|;
if|if
condition|(
name|vi
operator|>
literal|1
operator|||
name|meta
operator|->
name|attributes
operator|&
operator|(
name|INTEL_ATTR_EXT_STRIP
operator||
name|INTEL_ATTR_2TB_DISK
operator||
name|INTEL_ATTR_2TB
operator|)
condition|)
name|version
operator|=
name|INTEL_VERSION_1300
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|version
argument_list|,
name|INTEL_VERSION_1300
argument_list|)
operator|<
literal|0
condition|)
name|meta
operator|->
name|attributes
operator|&=
name|INTEL_ATTR_CHECKSUM
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|meta
operator|->
name|version
index|[
literal|0
index|]
argument_list|,
name|version
argument_list|,
sizeof|sizeof
argument_list|(
name|INTEL_VERSION_1000
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* We are done. Print meta data and store them to disks. */
name|g_raid_md_intel_print
argument_list|(
name|meta
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdi
operator|->
name|mdio_meta
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|mdi
operator|->
name|mdio_meta
argument_list|,
name|M_MD_INTEL
argument_list|)
expr_stmt|;
name|mdi
operator|->
name|mdio_meta
operator|=
name|meta
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_intel_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_RAID_DISK_S_ACTIVE
condition|)
continue|continue;
if|if
condition|(
name|pd
operator|->
name|pd_meta
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|pd
operator|->
name|pd_meta
argument_list|,
name|M_MD_INTEL
argument_list|)
expr_stmt|;
name|pd
operator|->
name|pd_meta
operator|=
name|NULL
expr_stmt|;
block|}
name|pd
operator|->
name|pd_meta
operator|=
name|intel_meta_copy
argument_list|(
name|meta
argument_list|)
expr_stmt|;
name|intel_meta_write
argument_list|(
name|disk
operator|->
name|d_consumer
argument_list|,
name|meta
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_fail_disk_intel
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|g_raid_subdisk
modifier|*
name|tsd
parameter_list|,
name|struct
name|g_raid_disk
modifier|*
name|tdisk
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_md_intel_object
modifier|*
name|mdi
decl_stmt|;
name|struct
name|g_raid_md_intel_perdisk
modifier|*
name|pd
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|sc
operator|=
name|md
operator|->
name|mdo_softc
expr_stmt|;
name|mdi
operator|=
operator|(
expr|struct
name|g_raid_md_intel_object
operator|*
operator|)
name|md
expr_stmt|;
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_intel_perdisk
operator|*
operator|)
name|tdisk
operator|->
name|d_md_data
expr_stmt|;
comment|/* We can't fail disk that is not a part of array now. */
if|if
condition|(
name|pd
operator|->
name|pd_disk_pos
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Mark disk as failed in metadata and try to write that metadata 	 * to the disk itself to prevent it's later resurrection as STALE. 	 */
name|mdi
operator|->
name|mdio_meta
operator|->
name|disk
index|[
name|pd
operator|->
name|pd_disk_pos
index|]
operator|.
name|flags
operator|=
name|INTEL_F_FAILED
expr_stmt|;
name|pd
operator|->
name|pd_disk_meta
operator|.
name|flags
operator|=
name|INTEL_F_FAILED
expr_stmt|;
name|g_raid_md_intel_print
argument_list|(
name|mdi
operator|->
name|mdio_meta
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdisk
operator|->
name|d_consumer
condition|)
name|intel_meta_write
argument_list|(
name|tdisk
operator|->
name|d_consumer
argument_list|,
name|mdi
operator|->
name|mdio_meta
argument_list|)
expr_stmt|;
comment|/* Change states. */
name|g_raid_change_disk_state
argument_list|(
name|tdisk
argument_list|,
name|G_RAID_DISK_S_FAILED
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sd
argument_list|,
argument|&tdisk->d_subdisks
argument_list|,
argument|sd_next
argument_list|)
block|{
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_FAILED
argument_list|)
expr_stmt|;
name|g_raid_event_send
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_E_FAILED
argument_list|,
name|G_RAID_EVENT_SUBDISK
argument_list|)
expr_stmt|;
block|}
comment|/* Write updated metadata to remaining disks. */
name|g_raid_md_write_intel
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|tdisk
argument_list|)
expr_stmt|;
comment|/* Check if anything left except placeholders. */
if|if
condition|(
name|g_raid_ndisks
argument_list|(
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
name|g_raid_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID_DISK_S_OFFLINE
argument_list|)
condition|)
name|g_raid_destroy_node
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|g_raid_md_intel_refill
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_free_disk_intel
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|g_raid_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_raid_md_intel_perdisk
modifier|*
name|pd
decl_stmt|;
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_intel_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|pd_meta
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|pd
operator|->
name|pd_meta
argument_list|,
name|M_MD_INTEL
argument_list|)
expr_stmt|;
name|pd
operator|->
name|pd_meta
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|pd
argument_list|,
name|M_MD_INTEL
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_md_data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_free_volume_intel
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|g_raid_volume
modifier|*
name|vol
parameter_list|)
block|{
name|struct
name|g_raid_md_intel_pervolume
modifier|*
name|pv
decl_stmt|;
name|pv
operator|=
operator|(
expr|struct
name|g_raid_md_intel_pervolume
operator|*
operator|)
name|vol
operator|->
name|v_md_data
expr_stmt|;
name|free
argument_list|(
name|pv
argument_list|,
name|M_MD_INTEL
argument_list|)
expr_stmt|;
name|vol
operator|->
name|v_md_data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_free_intel
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|)
block|{
name|struct
name|g_raid_md_intel_object
modifier|*
name|mdi
decl_stmt|;
name|mdi
operator|=
operator|(
expr|struct
name|g_raid_md_intel_object
operator|*
operator|)
name|md
expr_stmt|;
if|if
condition|(
operator|!
name|mdi
operator|->
name|mdio_started
condition|)
block|{
name|mdi
operator|->
name|mdio_started
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|mdi
operator|->
name|mdio_start_co
argument_list|)
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|md
operator|->
name|mdo_softc
argument_list|,
literal|"root_mount_rel %p"
argument_list|,
name|mdi
operator|->
name|mdio_rootmount
argument_list|)
expr_stmt|;
name|root_mount_rel
argument_list|(
name|mdi
operator|->
name|mdio_rootmount
argument_list|)
expr_stmt|;
name|mdi
operator|->
name|mdio_rootmount
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mdi
operator|->
name|mdio_meta
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|mdi
operator|->
name|mdio_meta
argument_list|,
name|M_MD_INTEL
argument_list|)
expr_stmt|;
name|mdi
operator|->
name|mdio_meta
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|G_RAID_MD_DECLARE
argument_list|(
name|intel
argument_list|,
literal|"Intel"
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

