begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2011 Alexander Motin<mav@FreeBSD.org>  * Copyright (c) 2000 - 2008 SÃ¸ren Schmidt<sos@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|"geom/raid/g_raid.h"
end_include

begin_include
include|#
directive|include
file|"g_raid_md_if.h"
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_MD_PROMISE
argument_list|,
literal|"md_promise_data"
argument_list|,
literal|"GEOM_RAID Promise metadata"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PROMISE_MAX_DISKS
value|8
end_define

begin_define
define|#
directive|define
name|PROMISE_MAX_SUBDISKS
value|2
end_define

begin_define
define|#
directive|define
name|PROMISE_META_OFFSET
value|14
end_define

begin_struct
struct|struct
name|promise_raid_disk
block|{
name|uint8_t
name|flags
decl_stmt|;
comment|/* Subdisk status. */
define|#
directive|define
name|PROMISE_F_VALID
value|0x01
define|#
directive|define
name|PROMISE_F_ONLINE
value|0x02
define|#
directive|define
name|PROMISE_F_ASSIGNED
value|0x04
define|#
directive|define
name|PROMISE_F_SPARE
value|0x08
define|#
directive|define
name|PROMISE_F_DUPLICATE
value|0x10
define|#
directive|define
name|PROMISE_F_REDIR
value|0x20
define|#
directive|define
name|PROMISE_F_DOWN
value|0x40
define|#
directive|define
name|PROMISE_F_READY
value|0x80
name|uint8_t
name|number
decl_stmt|;
comment|/* Position in a volume. */
name|uint8_t
name|channel
decl_stmt|;
comment|/* ATA channel number. */
name|uint8_t
name|device
decl_stmt|;
comment|/* ATA device number. */
name|uint64_t
name|id
name|__packed
decl_stmt|;
comment|/* Subdisk ID. */
block|}
name|__packed
struct|;
end_struct

begin_struct
struct|struct
name|promise_raid_conf
block|{
name|char
name|promise_id
index|[
literal|24
index|]
decl_stmt|;
define|#
directive|define
name|PROMISE_MAGIC
value|"Promise Technology, Inc."
define|#
directive|define
name|FREEBSD_MAGIC
value|"FreeBSD ATA driver RAID "
name|uint32_t
name|dummy_0
decl_stmt|;
name|uint64_t
name|magic_0
decl_stmt|;
define|#
directive|define
name|PROMISE_MAGIC0
parameter_list|(
name|x
parameter_list|)
value|(((uint64_t)(x.channel)<< 48) | \ 				((uint64_t)(x.device != 0)<< 56))
name|uint16_t
name|magic_1
decl_stmt|;
name|uint32_t
name|magic_2
decl_stmt|;
name|uint8_t
name|filler1
index|[
literal|470
index|]
decl_stmt|;
name|uint32_t
name|integrity
decl_stmt|;
define|#
directive|define
name|PROMISE_I_VALID
value|0x00000080
name|struct
name|promise_raid_disk
name|disk
decl_stmt|;
comment|/* This subdisk info. */
name|uint32_t
name|disk_offset
decl_stmt|;
comment|/* Subdisk offset. */
name|uint32_t
name|disk_sectors
decl_stmt|;
comment|/* Subdisk size */
name|uint32_t
name|disk_rebuild
decl_stmt|;
comment|/* Rebuild position. */
name|uint16_t
name|generation
decl_stmt|;
comment|/* Generation number. */
name|uint8_t
name|status
decl_stmt|;
comment|/* Volume status. */
define|#
directive|define
name|PROMISE_S_VALID
value|0x01
define|#
directive|define
name|PROMISE_S_ONLINE
value|0x02
define|#
directive|define
name|PROMISE_S_INITED
value|0x04
define|#
directive|define
name|PROMISE_S_READY
value|0x08
define|#
directive|define
name|PROMISE_S_DEGRADED
value|0x10
define|#
directive|define
name|PROMISE_S_MARKED
value|0x20
define|#
directive|define
name|PROMISE_S_MIGRATING
value|0x40
define|#
directive|define
name|PROMISE_S_FUNCTIONAL
value|0x80
name|uint8_t
name|type
decl_stmt|;
comment|/* Voluem type. */
define|#
directive|define
name|PROMISE_T_RAID0
value|0x00
define|#
directive|define
name|PROMISE_T_RAID1
value|0x01
define|#
directive|define
name|PROMISE_T_RAID3
value|0x02
define|#
directive|define
name|PROMISE_T_RAID5
value|0x04
define|#
directive|define
name|PROMISE_T_SPAN
value|0x08
define|#
directive|define
name|PROMISE_T_JBOD
value|0x10
name|uint8_t
name|total_disks
decl_stmt|;
comment|/* Disks in this volume. */
name|uint8_t
name|stripe_shift
decl_stmt|;
comment|/* Strip size. */
name|uint8_t
name|array_width
decl_stmt|;
comment|/* Number of RAID0 stripes. */
name|uint8_t
name|array_number
decl_stmt|;
comment|/* Global volume number. */
name|uint32_t
name|total_sectors
decl_stmt|;
comment|/* Volume size. */
name|uint16_t
name|cylinders
decl_stmt|;
comment|/* Volume geometry: C. */
name|uint8_t
name|heads
decl_stmt|;
comment|/* Volume geometry: H. */
name|uint8_t
name|sectors
decl_stmt|;
comment|/* Volume geometry: S. */
name|uint64_t
name|volume_id
name|__packed
decl_stmt|;
comment|/* Volume ID, */
name|struct
name|promise_raid_disk
name|disks
index|[
name|PROMISE_MAX_DISKS
index|]
decl_stmt|;
comment|/* Subdisks in this volume. */
name|char
name|name
index|[
literal|32
index|]
decl_stmt|;
comment|/* Volume label. */
name|uint32_t
name|filler2
index|[
literal|8
index|]
decl_stmt|;
name|uint32_t
name|magic_3
decl_stmt|;
comment|/* Something related to rebuild. */
name|uint64_t
name|rebuild_lba64
decl_stmt|;
comment|/* Per-volume rebuild position. */
name|uint32_t
name|magic_4
decl_stmt|;
name|uint32_t
name|magic_5
decl_stmt|;
name|uint32_t
name|total_sectors_high
decl_stmt|;
name|uint8_t
name|magic_6
decl_stmt|;
name|uint8_t
name|sector_size
decl_stmt|;
name|uint16_t
name|magic_7
decl_stmt|;
name|uint32_t
name|magic_8
index|[
literal|31
index|]
decl_stmt|;
name|uint32_t
name|backup_time
decl_stmt|;
name|uint16_t
name|magic_9
decl_stmt|;
name|uint32_t
name|disk_offset_high
decl_stmt|;
name|uint32_t
name|disk_sectors_high
decl_stmt|;
name|uint32_t
name|disk_rebuild_high
decl_stmt|;
name|uint16_t
name|magic_10
decl_stmt|;
name|uint32_t
name|magic_11
index|[
literal|3
index|]
decl_stmt|;
name|uint32_t
name|filler3
index|[
literal|284
index|]
decl_stmt|;
name|uint32_t
name|checksum
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_struct
struct|struct
name|g_raid_md_promise_perdisk
block|{
name|int
name|pd_updated
decl_stmt|;
name|int
name|pd_subdisks
decl_stmt|;
name|struct
name|promise_raid_conf
modifier|*
name|pd_meta
index|[
name|PROMISE_MAX_SUBDISKS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|g_raid_md_promise_pervolume
block|{
name|struct
name|promise_raid_conf
modifier|*
name|pv_meta
decl_stmt|;
name|uint64_t
name|pv_id
decl_stmt|;
name|uint16_t
name|pv_generation
decl_stmt|;
name|int
name|pv_disks_present
decl_stmt|;
name|int
name|pv_started
decl_stmt|;
name|struct
name|callout
name|pv_start_co
decl_stmt|;
comment|/* STARTING state timer. */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|g_raid_md_create_t
name|g_raid_md_create_promise
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_taste_t
name|g_raid_md_taste_promise
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_event_t
name|g_raid_md_event_promise
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_volume_event_t
name|g_raid_md_volume_event_promise
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_ctl_t
name|g_raid_md_ctl_promise
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_write_t
name|g_raid_md_write_promise
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_fail_disk_t
name|g_raid_md_fail_disk_promise
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_free_disk_t
name|g_raid_md_free_disk_promise
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_free_volume_t
name|g_raid_md_free_volume_promise
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_free_t
name|g_raid_md_free_promise
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kobj_method_t
name|g_raid_md_promise_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|g_raid_md_create
argument_list|,
name|g_raid_md_create_promise
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_taste
argument_list|,
name|g_raid_md_taste_promise
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_event
argument_list|,
name|g_raid_md_event_promise
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_volume_event
argument_list|,
name|g_raid_md_volume_event_promise
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_ctl
argument_list|,
name|g_raid_md_ctl_promise
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_write
argument_list|,
name|g_raid_md_write_promise
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_fail_disk
argument_list|,
name|g_raid_md_fail_disk_promise
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_free_disk
argument_list|,
name|g_raid_md_free_disk_promise
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_free_volume
argument_list|,
name|g_raid_md_free_volume_promise
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_free
argument_list|,
name|g_raid_md_free_promise
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|g_raid_md_class
name|g_raid_md_promise_class
init|=
block|{
literal|"Promise"
block|,
name|g_raid_md_promise_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|g_raid_md_object
argument_list|)
block|,
operator|.
name|mdc_enable
operator|=
literal|1
block|,
operator|.
name|mdc_priority
operator|=
literal|100
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|g_raid_md_promise_print
parameter_list|(
name|struct
name|promise_raid_conf
modifier|*
name|meta
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|g_raid_debug
operator|<
literal|1
condition|)
return|return;
name|printf
argument_list|(
literal|"********* ATA Promise Metadata *********\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"promise_id<%.24s>\n"
argument_list|,
name|meta
operator|->
name|promise_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"disk                %02x %02x %02x %02x %016jx\n"
argument_list|,
name|meta
operator|->
name|disk
operator|.
name|flags
argument_list|,
name|meta
operator|->
name|disk
operator|.
name|number
argument_list|,
name|meta
operator|->
name|disk
operator|.
name|channel
argument_list|,
name|meta
operator|->
name|disk
operator|.
name|device
argument_list|,
name|meta
operator|->
name|disk
operator|.
name|id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"disk_offset         %u\n"
argument_list|,
name|meta
operator|->
name|disk_offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"disk_sectors        %u\n"
argument_list|,
name|meta
operator|->
name|disk_sectors
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"disk_rebuild        %u\n"
argument_list|,
name|meta
operator|->
name|disk_rebuild
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"generation          %u\n"
argument_list|,
name|meta
operator|->
name|generation
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"status              0x%02x\n"
argument_list|,
name|meta
operator|->
name|status
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"type                %u\n"
argument_list|,
name|meta
operator|->
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"total_disks         %u\n"
argument_list|,
name|meta
operator|->
name|total_disks
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"stripe_shift        %u\n"
argument_list|,
name|meta
operator|->
name|stripe_shift
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"array_width         %u\n"
argument_list|,
name|meta
operator|->
name|array_width
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"array_number        %u\n"
argument_list|,
name|meta
operator|->
name|array_number
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"total_sectors       %u\n"
argument_list|,
name|meta
operator|->
name|total_sectors
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cylinders           %u\n"
argument_list|,
name|meta
operator|->
name|cylinders
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"heads               %u\n"
argument_list|,
name|meta
operator|->
name|heads
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sectors             %u\n"
argument_list|,
name|meta
operator|->
name|sectors
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"volume_id           0x%016jx\n"
argument_list|,
name|meta
operator|->
name|volume_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"disks:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PROMISE_MAX_DISKS
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"                    %02x %02x %02x %02x %016jx\n"
argument_list|,
name|meta
operator|->
name|disks
index|[
name|i
index|]
operator|.
name|flags
argument_list|,
name|meta
operator|->
name|disks
index|[
name|i
index|]
operator|.
name|number
argument_list|,
name|meta
operator|->
name|disks
index|[
name|i
index|]
operator|.
name|channel
argument_list|,
name|meta
operator|->
name|disks
index|[
name|i
index|]
operator|.
name|device
argument_list|,
name|meta
operator|->
name|disks
index|[
name|i
index|]
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"name<%.32s>\n"
argument_list|,
name|meta
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"magic_3             0x%08x\n"
argument_list|,
name|meta
operator|->
name|magic_3
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rebuild_lba64       %ju\n"
argument_list|,
name|meta
operator|->
name|rebuild_lba64
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"magic_4             0x%08x\n"
argument_list|,
name|meta
operator|->
name|magic_4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"magic_5             0x%08x\n"
argument_list|,
name|meta
operator|->
name|magic_5
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"total_sectors_high  0x%08x\n"
argument_list|,
name|meta
operator|->
name|total_sectors_high
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sector_size         %u\n"
argument_list|,
name|meta
operator|->
name|sector_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"backup_time         %d\n"
argument_list|,
name|meta
operator|->
name|backup_time
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"disk_offset_high    0x%08x\n"
argument_list|,
name|meta
operator|->
name|disk_offset_high
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"disk_sectors_high   0x%08x\n"
argument_list|,
name|meta
operator|->
name|disk_sectors_high
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"disk_rebuild_high   0x%08x\n"
argument_list|,
name|meta
operator|->
name|disk_rebuild_high
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"=================================================\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|promise_raid_conf
modifier|*
name|promise_meta_copy
parameter_list|(
name|struct
name|promise_raid_conf
modifier|*
name|meta
parameter_list|)
block|{
name|struct
name|promise_raid_conf
modifier|*
name|nmeta
decl_stmt|;
name|nmeta
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nmeta
argument_list|)
argument_list|,
name|M_MD_PROMISE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nmeta
argument_list|,
name|meta
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nmeta
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|nmeta
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|promise_meta_find_disk
parameter_list|(
name|struct
name|promise_raid_conf
modifier|*
name|meta
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|int
name|pos
decl_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|meta
operator|->
name|total_disks
condition|;
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|meta
operator|->
name|disks
index|[
name|pos
index|]
operator|.
name|id
operator|==
name|id
condition|)
return|return
operator|(
name|pos
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|promise_meta_unused_range
parameter_list|(
name|struct
name|promise_raid_conf
modifier|*
modifier|*
name|metaarr
parameter_list|,
name|int
name|nsd
parameter_list|,
name|off_t
name|sectors
parameter_list|,
name|off_t
modifier|*
name|off
parameter_list|,
name|off_t
modifier|*
name|size
parameter_list|)
block|{
name|off_t
name|coff
decl_stmt|,
name|csize
decl_stmt|,
name|tmp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|sectors
operator|-=
literal|131072
expr_stmt|;
operator|*
name|off
operator|=
literal|0
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
name|coff
operator|=
literal|0
expr_stmt|;
name|csize
operator|=
name|sectors
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsd
condition|;
name|j
operator|++
control|)
block|{
name|tmp
operator|=
operator|(
operator|(
name|off_t
operator|)
name|metaarr
index|[
name|j
index|]
operator|->
name|disk_offset_high
operator|<<
literal|32
operator|)
operator|+
name|metaarr
index|[
name|j
index|]
operator|->
name|disk_offset
expr_stmt|;
if|if
condition|(
name|tmp
operator|>=
name|coff
condition|)
name|csize
operator|=
name|MIN
argument_list|(
name|csize
argument_list|,
name|tmp
operator|-
name|coff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|csize
operator|>
operator|*
name|size
condition|)
block|{
operator|*
name|off
operator|=
name|coff
expr_stmt|;
operator|*
name|size
operator|=
name|csize
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|nsd
condition|)
break|break;
name|coff
operator|=
operator|(
operator|(
name|off_t
operator|)
name|metaarr
index|[
name|i
index|]
operator|->
name|disk_offset_high
operator|<<
literal|32
operator|)
operator|+
name|metaarr
index|[
name|i
index|]
operator|->
name|disk_offset
operator|+
operator|(
operator|(
name|off_t
operator|)
name|metaarr
index|[
name|i
index|]
operator|->
name|disk_sectors_high
operator|<<
literal|32
operator|)
operator|+
name|metaarr
index|[
name|i
index|]
operator|->
name|disk_sectors
expr_stmt|;
name|csize
operator|=
name|sectors
operator|-
name|coff
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
empty_stmt|;
return|return
operator|(
operator|(
operator|*
name|size
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|promise_meta_translate_disk
parameter_list|(
name|struct
name|g_raid_volume
modifier|*
name|vol
parameter_list|,
name|int
name|md_disk_pos
parameter_list|)
block|{
name|int
name|disk_pos
decl_stmt|,
name|width
decl_stmt|;
if|if
condition|(
name|md_disk_pos
operator|>=
literal|0
operator|&&
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID1E
condition|)
block|{
name|width
operator|=
name|vol
operator|->
name|v_disks_count
operator|/
literal|2
expr_stmt|;
name|disk_pos
operator|=
operator|(
name|md_disk_pos
operator|/
name|width
operator|)
operator|+
operator|(
name|md_disk_pos
operator|%
name|width
operator|)
operator|*
name|width
expr_stmt|;
block|}
else|else
name|disk_pos
operator|=
name|md_disk_pos
expr_stmt|;
return|return
operator|(
name|disk_pos
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|promise_meta_get_name
parameter_list|(
name|struct
name|promise_raid_conf
modifier|*
name|meta
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|meta
operator|->
name|name
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|buf
index|[
literal|32
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|31
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|>
literal|0x20
condition|)
break|break;
name|buf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|promise_meta_put_name
parameter_list|(
name|struct
name|promise_raid_conf
modifier|*
name|meta
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|memset
argument_list|(
name|meta
operator|->
name|name
argument_list|,
literal|0x20
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|meta
operator|->
name|name
argument_list|,
name|buf
argument_list|,
name|MIN
argument_list|(
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|32
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|promise_meta_read
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|promise_raid_conf
modifier|*
modifier|*
name|metaarr
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|promise_raid_conf
modifier|*
name|meta
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|subdisks
decl_stmt|;
name|uint32_t
name|checksum
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|subdisks
operator|=
literal|0
expr_stmt|;
name|next
label|:
comment|/* Read metadata block. */
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|pp
operator|->
name|mediasize
operator|-
name|pp
operator|->
name|sectorsize
operator|*
operator|(
literal|63
operator|-
name|subdisks
operator|*
name|PROMISE_META_OFFSET
operator|)
argument_list|,
name|pp
operator|->
name|sectorsize
operator|*
literal|4
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Cannot read metadata from %s (error=%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|subdisks
operator|)
return|;
block|}
name|meta
operator|=
operator|(
expr|struct
name|promise_raid_conf
operator|*
operator|)
name|buf
expr_stmt|;
comment|/* Check if this is an Promise RAID struct */
if|if
condition|(
name|strncmp
argument_list|(
name|meta
operator|->
name|promise_id
argument_list|,
name|PROMISE_MAGIC
argument_list|,
name|strlen
argument_list|(
name|PROMISE_MAGIC
argument_list|)
argument_list|)
operator|&&
name|strncmp
argument_list|(
name|meta
operator|->
name|promise_id
argument_list|,
name|FREEBSD_MAGIC
argument_list|,
name|strlen
argument_list|(
name|FREEBSD_MAGIC
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|subdisks
operator|==
literal|0
condition|)
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Promise signature check failed on %s"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|subdisks
operator|)
return|;
block|}
name|meta
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|meta
argument_list|)
argument_list|,
name|M_MD_PROMISE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|meta
argument_list|,
name|buf
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|meta
argument_list|)
argument_list|,
name|pp
operator|->
name|sectorsize
operator|*
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Check metadata checksum. */
for|for
control|(
name|checksum
operator|=
literal|0
operator|,
name|ptr
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|meta
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|511
condition|;
name|i
operator|++
control|)
name|checksum
operator|+=
operator|*
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
name|checksum
operator|!=
name|meta
operator|->
name|checksum
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Promise checksum check failed on %s"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|meta
argument_list|,
name|M_MD_PROMISE
argument_list|)
expr_stmt|;
return|return
operator|(
name|subdisks
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|meta
operator|->
name|integrity
operator|&
name|PROMISE_I_VALID
operator|)
operator|==
literal|0
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Promise metadata is invalid on %s"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|meta
argument_list|,
name|M_MD_PROMISE
argument_list|)
expr_stmt|;
return|return
operator|(
name|subdisks
operator|)
return|;
block|}
if|if
condition|(
name|meta
operator|->
name|total_disks
operator|>
name|PROMISE_MAX_DISKS
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Wrong number of disks on %s (%d)"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|meta
operator|->
name|total_disks
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|meta
argument_list|,
name|M_MD_PROMISE
argument_list|)
expr_stmt|;
return|return
operator|(
name|subdisks
operator|)
return|;
block|}
comment|/* Remove filler garbage from fields used in newer metadata. */
if|if
condition|(
name|meta
operator|->
name|disk_offset_high
operator|==
literal|0x8b8c8d8e
operator|&&
name|meta
operator|->
name|disk_sectors_high
operator|==
literal|0x8788898a
operator|&&
name|meta
operator|->
name|disk_rebuild_high
operator|==
literal|0x83848586
condition|)
block|{
name|meta
operator|->
name|disk_offset_high
operator|=
literal|0
expr_stmt|;
name|meta
operator|->
name|disk_sectors_high
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|meta
operator|->
name|disk_rebuild
operator|==
name|UINT32_MAX
condition|)
name|meta
operator|->
name|disk_rebuild_high
operator|=
name|UINT32_MAX
expr_stmt|;
else|else
name|meta
operator|->
name|disk_rebuild_high
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|meta
operator|->
name|total_sectors_high
operator|==
literal|0x15161718
condition|)
block|{
name|meta
operator|->
name|total_sectors_high
operator|=
literal|0
expr_stmt|;
name|meta
operator|->
name|backup_time
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|meta
operator|->
name|rebuild_lba64
operator|==
literal|0x2122232425262728
condition|)
name|meta
operator|->
name|rebuild_lba64
operator|=
name|UINT64_MAX
expr_stmt|;
block|}
block|}
if|if
condition|(
name|meta
operator|->
name|sector_size
operator|<
literal|1
operator|||
name|meta
operator|->
name|sector_size
operator|>
literal|8
condition|)
name|meta
operator|->
name|sector_size
operator|=
literal|1
expr_stmt|;
comment|/* Save this part and look for next. */
operator|*
name|metaarr
operator|=
name|meta
expr_stmt|;
name|metaarr
operator|++
expr_stmt|;
name|subdisks
operator|++
expr_stmt|;
if|if
condition|(
name|subdisks
operator|<
name|PROMISE_MAX_SUBDISKS
condition|)
goto|goto
name|next
goto|;
return|return
operator|(
name|subdisks
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|promise_meta_write
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|promise_raid_conf
modifier|*
modifier|*
name|metaarr
parameter_list|,
name|int
name|nsd
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|promise_raid_conf
modifier|*
name|meta
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|off_t
name|off
decl_stmt|,
name|size
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|subdisk
decl_stmt|,
name|fake
decl_stmt|;
name|uint32_t
name|checksum
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|subdisk
operator|=
literal|0
expr_stmt|;
name|fake
operator|=
literal|0
expr_stmt|;
name|next
label|:
name|buf
operator|=
name|malloc
argument_list|(
name|pp
operator|->
name|sectorsize
operator|*
literal|4
argument_list|,
name|M_MD_PROMISE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|meta
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|subdisk
operator|<
name|nsd
condition|)
block|{
name|meta
operator|=
name|metaarr
index|[
name|subdisk
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|fake
operator|&&
name|promise_meta_unused_range
argument_list|(
name|metaarr
argument_list|,
name|nsd
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|mediasize
operator|/
name|cp
operator|->
name|provider
operator|->
name|sectorsize
argument_list|,
operator|&
name|off
argument_list|,
operator|&
name|size
argument_list|)
condition|)
block|{
comment|/* Optionally add record for unused space. */
name|meta
operator|=
operator|(
expr|struct
name|promise_raid_conf
operator|*
operator|)
name|buf
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|meta
operator|->
name|promise_id
index|[
literal|0
index|]
argument_list|,
name|PROMISE_MAGIC
argument_list|,
sizeof|sizeof
argument_list|(
name|PROMISE_MAGIC
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|meta
operator|->
name|dummy_0
operator|=
literal|0x00020000
expr_stmt|;
name|meta
operator|->
name|integrity
operator|=
name|PROMISE_I_VALID
expr_stmt|;
name|meta
operator|->
name|disk
operator|.
name|flags
operator|=
name|PROMISE_F_ONLINE
operator||
name|PROMISE_F_VALID
expr_stmt|;
name|meta
operator|->
name|disk
operator|.
name|number
operator|=
literal|0xff
expr_stmt|;
name|arc4rand
argument_list|(
operator|&
name|meta
operator|->
name|disk
operator|.
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|meta
operator|->
name|disk
operator|.
name|id
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|meta
operator|->
name|disk_offset_high
operator|=
name|off
operator|>>
literal|32
expr_stmt|;
name|meta
operator|->
name|disk_offset
operator|=
operator|(
name|uint32_t
operator|)
name|off
expr_stmt|;
name|meta
operator|->
name|disk_sectors_high
operator|=
name|size
operator|>>
literal|32
expr_stmt|;
name|meta
operator|->
name|disk_sectors
operator|=
operator|(
name|uint32_t
operator|)
name|size
expr_stmt|;
name|meta
operator|->
name|disk_rebuild_high
operator|=
name|UINT32_MAX
expr_stmt|;
name|meta
operator|->
name|disk_rebuild
operator|=
name|UINT32_MAX
expr_stmt|;
name|fake
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|meta
operator|!=
name|NULL
condition|)
block|{
comment|/* Recalculate checksum for case if metadata were changed. */
name|meta
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|checksum
operator|=
literal|0
operator|,
name|ptr
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|meta
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|511
condition|;
name|i
operator|++
control|)
name|checksum
operator|+=
operator|*
name|ptr
operator|++
expr_stmt|;
name|meta
operator|->
name|checksum
operator|=
name|checksum
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|meta
argument_list|,
name|MIN
argument_list|(
name|pp
operator|->
name|sectorsize
operator|*
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|meta
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|g_write_data
argument_list|(
name|cp
argument_list|,
name|pp
operator|->
name|mediasize
operator|-
name|pp
operator|->
name|sectorsize
operator|*
operator|(
literal|63
operator|-
name|subdisk
operator|*
name|PROMISE_META_OFFSET
operator|)
argument_list|,
name|buf
argument_list|,
name|pp
operator|->
name|sectorsize
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Cannot write metadata to %s (error=%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|,
name|M_MD_PROMISE
argument_list|)
expr_stmt|;
name|subdisk
operator|++
expr_stmt|;
if|if
condition|(
name|subdisk
operator|<
name|PROMISE_MAX_SUBDISKS
condition|)
goto|goto
name|next
goto|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|promise_meta_erase
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|subdisk
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
literal|4
operator|*
name|pp
operator|->
name|sectorsize
argument_list|,
name|M_MD_PROMISE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|subdisk
operator|=
literal|0
init|;
name|subdisk
operator|<
name|PROMISE_MAX_SUBDISKS
condition|;
name|subdisk
operator|++
control|)
block|{
name|error
operator|=
name|g_write_data
argument_list|(
name|cp
argument_list|,
name|pp
operator|->
name|mediasize
operator|-
name|pp
operator|->
name|sectorsize
operator|*
operator|(
literal|63
operator|-
name|subdisk
operator|*
name|PROMISE_META_OFFSET
operator|)
argument_list|,
name|buf
argument_list|,
literal|4
operator|*
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Cannot erase metadata on %s (error=%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|buf
argument_list|,
name|M_MD_PROMISE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|promise_meta_write_spare
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|promise_raid_conf
modifier|*
name|meta
decl_stmt|;
name|off_t
name|tmp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|meta
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|meta
argument_list|)
argument_list|,
name|M_MD_PROMISE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|meta
operator|->
name|promise_id
index|[
literal|0
index|]
argument_list|,
name|PROMISE_MAGIC
argument_list|,
sizeof|sizeof
argument_list|(
name|PROMISE_MAGIC
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|meta
operator|->
name|dummy_0
operator|=
literal|0x00020000
expr_stmt|;
name|meta
operator|->
name|integrity
operator|=
name|PROMISE_I_VALID
expr_stmt|;
name|meta
operator|->
name|disk
operator|.
name|flags
operator|=
name|PROMISE_F_SPARE
operator||
name|PROMISE_F_ONLINE
operator||
name|PROMISE_F_VALID
expr_stmt|;
name|meta
operator|->
name|disk
operator|.
name|number
operator|=
literal|0xff
expr_stmt|;
name|arc4rand
argument_list|(
operator|&
name|meta
operator|->
name|disk
operator|.
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|meta
operator|->
name|disk
operator|.
name|id
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|cp
operator|->
name|provider
operator|->
name|mediasize
operator|/
name|cp
operator|->
name|provider
operator|->
name|sectorsize
operator|-
literal|131072
expr_stmt|;
name|meta
operator|->
name|disk_sectors_high
operator|=
name|tmp
operator|>>
literal|32
expr_stmt|;
name|meta
operator|->
name|disk_sectors
operator|=
operator|(
name|uint32_t
operator|)
name|tmp
expr_stmt|;
name|meta
operator|->
name|disk_rebuild_high
operator|=
name|UINT32_MAX
expr_stmt|;
name|meta
operator|->
name|disk_rebuild
operator|=
name|UINT32_MAX
expr_stmt|;
name|error
operator|=
name|promise_meta_write
argument_list|(
name|cp
argument_list|,
operator|&
name|meta
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|meta
argument_list|,
name|M_MD_PROMISE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|g_raid_volume
modifier|*
name|g_raid_md_promise_get_volume
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|,
name|uint64_t
name|id
parameter_list|)
block|{
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|struct
name|g_raid_md_promise_pervolume
modifier|*
name|pv
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vol
argument_list|,
argument|&sc->sc_volumes
argument_list|,
argument|v_next
argument_list|)
block|{
name|pv
operator|=
name|vol
operator|->
name|v_md_data
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|pv_id
operator|==
name|id
condition|)
break|break;
block|}
return|return
operator|(
name|vol
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_promise_purge_volumes
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|,
modifier|*
name|tvol
decl_stmt|;
name|struct
name|g_raid_md_promise_pervolume
modifier|*
name|pv
decl_stmt|;
name|int
name|i
decl_stmt|,
name|res
decl_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|vol
argument_list|,
argument|&sc->sc_volumes
argument_list|,
argument|v_next
argument_list|,
argument|tvol
argument_list|)
block|{
name|pv
operator|=
name|vol
operator|->
name|v_md_data
expr_stmt|;
if|if
condition|(
operator|!
name|pv
operator|->
name|pv_started
operator|||
name|vol
operator|->
name|v_stopping
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vol
operator|->
name|v_disks_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
operator|.
name|sd_state
operator|!=
name|G_RAID_SUBDISK_S_NONE
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|vol
operator|->
name|v_disks_count
condition|)
block|{
name|g_raid_destroy_volume
argument_list|(
name|vol
argument_list|)
expr_stmt|;
name|res
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_promise_purge_disks
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|,
modifier|*
name|tdisk
decl_stmt|;
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|struct
name|g_raid_md_promise_perdisk
modifier|*
name|pd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|res
decl_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|,
argument|tdisk
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_SPARE
condition|)
continue|continue;
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_promise_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
comment|/* Scan for deleted volumes. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pd
operator|->
name|pd_subdisks
condition|;
control|)
block|{
name|vol
operator|=
name|g_raid_md_promise_get_volume
argument_list|(
name|sc
argument_list|,
name|pd
operator|->
name|pd_meta
index|[
name|i
index|]
operator|->
name|volume_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vol
operator|!=
name|NULL
operator|&&
operator|!
name|vol
operator|->
name|v_stopping
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
name|free
argument_list|(
name|pd
operator|->
name|pd_meta
index|[
name|i
index|]
argument_list|,
name|M_MD_PROMISE
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|pd
operator|->
name|pd_subdisks
operator|-
literal|1
condition|;
name|j
operator|++
control|)
name|pd
operator|->
name|pd_meta
index|[
name|j
index|]
operator|=
name|pd
operator|->
name|pd_meta
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
name|pd
operator|->
name|pd_meta
index|[
name|PROMISE_MAX_SUBDISKS
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|pd
operator|->
name|pd_subdisks
operator|--
expr_stmt|;
name|pd
operator|->
name|pd_updated
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If there is no metadata left - erase and delete disk. */
if|if
condition|(
name|pd
operator|->
name|pd_subdisks
operator|==
literal|0
condition|)
block|{
name|promise_meta_erase
argument_list|(
name|disk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
name|g_raid_destroy_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|res
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_promise_supported
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|qual
parameter_list|,
name|int
name|disks
parameter_list|,
name|int
name|force
parameter_list|)
block|{
if|if
condition|(
name|disks
operator|>
name|PROMISE_MAX_DISKS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|level
condition|)
block|{
case|case
name|G_RAID_VOLUME_RL_RAID0
case|:
if|if
condition|(
name|disks
operator|<
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|force
operator|&&
name|disks
operator|<
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|G_RAID_VOLUME_RL_RAID1
case|:
if|if
condition|(
name|disks
operator|<
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|force
operator|&&
operator|(
name|disks
operator|!=
literal|2
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|G_RAID_VOLUME_RL_RAID1E
case|:
if|if
condition|(
name|disks
operator|<
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|disks
operator|%
literal|2
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|force
operator|&&
operator|(
name|disks
operator|!=
literal|4
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|G_RAID_VOLUME_RL_SINGLE
case|:
if|if
condition|(
name|disks
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|G_RAID_VOLUME_RL_CONCAT
case|:
if|if
condition|(
name|disks
operator|<
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|G_RAID_VOLUME_RL_RAID5
case|:
if|if
condition|(
name|disks
operator|<
literal|3
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|qual
operator|!=
name|G_RAID_VOLUME_RLQ_R5LA
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|level
operator|!=
name|G_RAID_VOLUME_RL_RAID5
operator|&&
name|qual
operator|!=
name|G_RAID_VOLUME_RLQ_NONE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_promise_start_disk
parameter_list|(
name|struct
name|g_raid_disk
modifier|*
name|disk
parameter_list|,
name|int
name|sdn
parameter_list|,
name|struct
name|g_raid_volume
modifier|*
name|vol
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|struct
name|g_raid_md_promise_perdisk
modifier|*
name|pd
decl_stmt|;
name|struct
name|g_raid_md_promise_pervolume
modifier|*
name|pv
decl_stmt|;
name|struct
name|promise_raid_conf
modifier|*
name|meta
decl_stmt|;
name|off_t
name|eoff
decl_stmt|,
name|esize
decl_stmt|,
name|size
decl_stmt|;
name|int
name|disk_pos
decl_stmt|,
name|md_disk_pos
decl_stmt|,
name|i
decl_stmt|,
name|resurrection
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_promise_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
name|pv
operator|=
name|vol
operator|->
name|v_md_data
expr_stmt|;
name|meta
operator|=
name|pv
operator|->
name|pv_meta
expr_stmt|;
if|if
condition|(
name|sdn
operator|>=
literal|0
condition|)
block|{
comment|/* Find disk position in metadata by it's serial. */
name|md_disk_pos
operator|=
name|promise_meta_find_disk
argument_list|(
name|meta
argument_list|,
name|pd
operator|->
name|pd_meta
index|[
name|sdn
index|]
operator|->
name|disk
operator|.
name|id
argument_list|)
expr_stmt|;
comment|/* For RAID0+1 we need to translate order. */
name|disk_pos
operator|=
name|promise_meta_translate_disk
argument_list|(
name|vol
argument_list|,
name|md_disk_pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|md_disk_pos
operator|=
operator|-
literal|1
expr_stmt|;
name|disk_pos
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|disk_pos
operator|<
literal|0
condition|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"Disk %s is not part of the volume %s"
argument_list|,
name|g_raid_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|vol
operator|->
name|v_name
argument_list|)
expr_stmt|;
comment|/* Failed stale disk is useless for us. */
if|if
condition|(
name|sdn
operator|>=
literal|0
operator|&&
name|pd
operator|->
name|pd_meta
index|[
name|sdn
index|]
operator|->
name|disk
operator|.
name|flags
operator|&
name|PROMISE_F_DOWN
condition|)
block|{
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_STALE_FAILED
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* If we were given specific metadata subdisk - erase it. */
if|if
condition|(
name|sdn
operator|>=
literal|0
condition|)
block|{
name|free
argument_list|(
name|pd
operator|->
name|pd_meta
index|[
name|sdn
index|]
argument_list|,
name|M_MD_PROMISE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sdn
init|;
name|i
operator|<
name|pd
operator|->
name|pd_subdisks
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|pd
operator|->
name|pd_meta
index|[
name|i
index|]
operator|=
name|pd
operator|->
name|pd_meta
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|pd
operator|->
name|pd_meta
index|[
name|PROMISE_MAX_SUBDISKS
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|pd
operator|->
name|pd_subdisks
operator|--
expr_stmt|;
block|}
comment|/* If we are in the start process, that's all for now. */
if|if
condition|(
operator|!
name|pv
operator|->
name|pv_started
condition|)
goto|goto
name|nofit
goto|;
comment|/* 		 * If we have already started - try to get use of the disk. 		 * Try to replace OFFLINE disks first, then FAILED. 		 */
name|promise_meta_unused_range
argument_list|(
name|pd
operator|->
name|pd_meta
argument_list|,
name|pd
operator|->
name|pd_subdisks
argument_list|,
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|->
name|mediasize
operator|/
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|->
name|sectorsize
argument_list|,
operator|&
name|eoff
argument_list|,
operator|&
name|esize
argument_list|)
expr_stmt|;
if|if
condition|(
name|esize
operator|==
literal|0
condition|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"No free space on disk %s"
argument_list|,
name|g_raid_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|nofit
goto|;
block|}
name|size
operator|=
name|INT64_MAX
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vol
operator|->
name|v_disks_count
condition|;
name|i
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|!=
name|G_RAID_SUBDISK_S_NONE
condition|)
name|size
operator|=
name|sd
operator|->
name|sd_size
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|<=
name|G_RAID_SUBDISK_S_FAILED
operator|&&
operator|(
name|disk_pos
operator|<
literal|0
operator|||
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
operator|.
name|sd_state
operator|<
name|sd
operator|->
name|sd_state
operator|)
condition|)
name|disk_pos
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|disk_pos
operator|>=
literal|0
operator|&&
name|vol
operator|->
name|v_raid_level
operator|!=
name|G_RAID_VOLUME_RL_CONCAT
operator|&&
operator|(
name|off_t
operator|)
name|esize
operator|*
literal|512
operator|<
name|size
condition|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"Disk %s free space "
literal|"is too small (%ju< %ju)"
argument_list|,
name|g_raid_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
operator|(
name|off_t
operator|)
name|esize
operator|*
literal|512
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|disk_pos
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|disk_pos
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|!=
name|G_RAID_VOLUME_RL_CONCAT
condition|)
name|esize
operator|=
name|size
operator|/
literal|512
expr_stmt|;
comment|/* For RAID0+1 we need to translate order. */
name|md_disk_pos
operator|=
name|promise_meta_translate_disk
argument_list|(
name|vol
argument_list|,
name|disk_pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nofit
label|:
if|if
condition|(
name|pd
operator|->
name|pd_subdisks
operator|==
literal|0
condition|)
block|{
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_SPARE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"Disk %s takes pos %d in the volume %s"
argument_list|,
name|g_raid_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|disk_pos
argument_list|,
name|vol
operator|->
name|v_name
argument_list|)
expr_stmt|;
name|resurrection
operator|=
literal|1
expr_stmt|;
block|}
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|disk_pos
index|]
expr_stmt|;
if|if
condition|(
name|resurrection
operator|&&
name|sd
operator|->
name|sd_disk
operator|!=
name|NULL
condition|)
block|{
name|g_raid_change_disk_state
argument_list|(
name|sd
operator|->
name|sd_disk
argument_list|,
name|G_RAID_DISK_S_STALE_FAILED
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sd
operator|->
name|sd_disk
operator|->
name|d_subdisks
argument_list|,
name|sd
argument_list|,
name|sd_next
argument_list|)
expr_stmt|;
block|}
name|vol
operator|->
name|v_subdisks
index|[
name|disk_pos
index|]
operator|.
name|sd_disk
operator|=
name|disk
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|disk
operator|->
name|d_subdisks
argument_list|,
name|sd
argument_list|,
name|sd_next
argument_list|)
expr_stmt|;
comment|/* Welcome the new disk. */
if|if
condition|(
name|resurrection
condition|)
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_ACTIVE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|meta
operator|->
name|disks
index|[
name|md_disk_pos
index|]
operator|.
name|flags
operator|&
name|PROMISE_F_DOWN
condition|)
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_FAILED
argument_list|)
expr_stmt|;
else|else
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|resurrection
condition|)
block|{
name|sd
operator|->
name|sd_offset
operator|=
operator|(
name|off_t
operator|)
name|eoff
operator|*
literal|512
expr_stmt|;
name|sd
operator|->
name|sd_size
operator|=
operator|(
name|off_t
operator|)
name|esize
operator|*
literal|512
expr_stmt|;
block|}
else|else
block|{
name|sd
operator|->
name|sd_offset
operator|=
operator|(
operator|(
operator|(
name|off_t
operator|)
name|pd
operator|->
name|pd_meta
index|[
name|sdn
index|]
operator|->
name|disk_offset_high
operator|<<
literal|32
operator|)
operator|+
name|pd
operator|->
name|pd_meta
index|[
name|sdn
index|]
operator|->
name|disk_offset
operator|)
operator|*
literal|512
expr_stmt|;
name|sd
operator|->
name|sd_size
operator|=
operator|(
operator|(
operator|(
name|off_t
operator|)
name|pd
operator|->
name|pd_meta
index|[
name|sdn
index|]
operator|->
name|disk_sectors_high
operator|<<
literal|32
operator|)
operator|+
name|pd
operator|->
name|pd_meta
index|[
name|sdn
index|]
operator|->
name|disk_sectors
operator|)
operator|*
literal|512
expr_stmt|;
block|}
if|if
condition|(
name|resurrection
condition|)
block|{
comment|/* Stale disk, almost same as new. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_NEW
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|meta
operator|->
name|disks
index|[
name|md_disk_pos
index|]
operator|.
name|flags
operator|&
name|PROMISE_F_DOWN
condition|)
block|{
comment|/* Failed disk. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_FAILED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|meta
operator|->
name|disks
index|[
name|md_disk_pos
index|]
operator|.
name|flags
operator|&
name|PROMISE_F_REDIR
condition|)
block|{
comment|/* Rebuilding disk. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_REBUILD
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|pd_meta
index|[
name|sdn
index|]
operator|->
name|generation
operator|!=
name|meta
operator|->
name|generation
condition|)
name|sd
operator|->
name|sd_rebuild_pos
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|sd
operator|->
name|sd_rebuild_pos
operator|=
operator|(
operator|(
operator|(
name|off_t
operator|)
name|pd
operator|->
name|pd_meta
index|[
name|sdn
index|]
operator|->
name|disk_rebuild_high
operator|<<
literal|32
operator|)
operator|+
name|pd
operator|->
name|pd_meta
index|[
name|sdn
index|]
operator|->
name|disk_rebuild
operator|)
operator|*
literal|512
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|meta
operator|->
name|disks
index|[
name|md_disk_pos
index|]
operator|.
name|flags
operator|&
name|PROMISE_F_ONLINE
operator|)
condition|)
block|{
comment|/* Rebuilding disk. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_NEW
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pd
operator|->
name|pd_meta
index|[
name|sdn
index|]
operator|->
name|generation
operator|!=
name|meta
operator|->
name|generation
operator|||
operator|(
name|meta
operator|->
name|status
operator|&
name|PROMISE_S_MARKED
operator|)
condition|)
block|{
comment|/* Stale disk or dirty volume (unclean shutdown). */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_STALE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Up to date disk. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_ACTIVE
argument_list|)
expr_stmt|;
block|}
name|g_raid_event_send
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_E_NEW
argument_list|,
name|G_RAID_EVENT_SUBDISK
argument_list|)
expr_stmt|;
return|return
operator|(
name|resurrection
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_md_promise_refill
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_raid_md_object
modifier|*
name|md
decl_stmt|;
name|struct
name|g_raid_md_promise_perdisk
modifier|*
name|pd
decl_stmt|;
name|struct
name|g_raid_md_promise_pervolume
modifier|*
name|pv
decl_stmt|;
name|int
name|update
decl_stmt|,
name|updated
decl_stmt|,
name|i
decl_stmt|,
name|bad
decl_stmt|;
name|md
operator|=
name|sc
operator|->
name|sc_md
expr_stmt|;
name|restart
label|:
name|updated
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vol
argument_list|,
argument|&sc->sc_volumes
argument_list|,
argument|v_next
argument_list|)
block|{
name|pv
operator|=
name|vol
operator|->
name|v_md_data
expr_stmt|;
if|if
condition|(
operator|!
name|pv
operator|->
name|pv_started
operator|||
name|vol
operator|->
name|v_stopping
condition|)
continue|continue;
comment|/* Search for subdisk that needs replacement. */
name|bad
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vol
operator|->
name|v_disks_count
condition|;
name|i
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_NONE
operator|||
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_FAILED
condition|)
name|bad
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bad
condition|)
continue|continue;
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"Volume %s is not complete, "
literal|"trying to refill."
argument_list|,
name|vol
operator|->
name|v_name
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
comment|/* Skip failed. */
if|if
condition|(
name|disk
operator|->
name|d_state
operator|<
name|G_RAID_DISK_S_SPARE
condition|)
continue|continue;
comment|/* Skip already used by this volume. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vol
operator|->
name|v_disks_count
condition|;
name|i
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_disk
operator|==
name|disk
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|vol
operator|->
name|v_disks_count
condition|)
continue|continue;
comment|/* Try to use disk if it has empty extents. */
name|pd
operator|=
name|disk
operator|->
name|d_md_data
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|pd_subdisks
operator|<
name|PROMISE_MAX_SUBDISKS
condition|)
block|{
name|update
operator|=
name|g_raid_md_promise_start_disk
argument_list|(
name|disk
argument_list|,
operator|-
literal|1
argument_list|,
name|vol
argument_list|)
expr_stmt|;
block|}
else|else
name|update
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|update
condition|)
block|{
name|updated
operator|=
literal|1
expr_stmt|;
name|g_raid_md_write_promise
argument_list|(
name|md
argument_list|,
name|vol
argument_list|,
name|NULL
argument_list|,
name|disk
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|updated
condition|)
goto|goto
name|restart
goto|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_md_promise_start
parameter_list|(
name|struct
name|g_raid_volume
modifier|*
name|vol
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_raid_md_object
modifier|*
name|md
decl_stmt|;
name|struct
name|g_raid_md_promise_perdisk
modifier|*
name|pd
decl_stmt|;
name|struct
name|g_raid_md_promise_pervolume
modifier|*
name|pv
decl_stmt|;
name|struct
name|promise_raid_conf
modifier|*
name|meta
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|vol
operator|->
name|v_softc
expr_stmt|;
name|md
operator|=
name|sc
operator|->
name|sc_md
expr_stmt|;
name|pv
operator|=
name|vol
operator|->
name|v_md_data
expr_stmt|;
name|meta
operator|=
name|pv
operator|->
name|pv_meta
expr_stmt|;
name|vol
operator|->
name|v_raid_level_qualifier
operator|=
name|G_RAID_VOLUME_RLQ_NONE
expr_stmt|;
if|if
condition|(
name|meta
operator|->
name|type
operator|==
name|PROMISE_T_RAID0
condition|)
name|vol
operator|->
name|v_raid_level
operator|=
name|G_RAID_VOLUME_RL_RAID0
expr_stmt|;
elseif|else
if|if
condition|(
name|meta
operator|->
name|type
operator|==
name|PROMISE_T_RAID1
condition|)
block|{
if|if
condition|(
name|meta
operator|->
name|array_width
operator|==
literal|1
condition|)
name|vol
operator|->
name|v_raid_level
operator|=
name|G_RAID_VOLUME_RL_RAID1
expr_stmt|;
else|else
name|vol
operator|->
name|v_raid_level
operator|=
name|G_RAID_VOLUME_RL_RAID1E
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|meta
operator|->
name|type
operator|==
name|PROMISE_T_RAID3
condition|)
name|vol
operator|->
name|v_raid_level
operator|=
name|G_RAID_VOLUME_RL_RAID3
expr_stmt|;
elseif|else
if|if
condition|(
name|meta
operator|->
name|type
operator|==
name|PROMISE_T_RAID5
condition|)
block|{
name|vol
operator|->
name|v_raid_level
operator|=
name|G_RAID_VOLUME_RL_RAID5
expr_stmt|;
name|vol
operator|->
name|v_raid_level_qualifier
operator|=
name|G_RAID_VOLUME_RLQ_R5LA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|meta
operator|->
name|type
operator|==
name|PROMISE_T_SPAN
condition|)
name|vol
operator|->
name|v_raid_level
operator|=
name|G_RAID_VOLUME_RL_CONCAT
expr_stmt|;
elseif|else
if|if
condition|(
name|meta
operator|->
name|type
operator|==
name|PROMISE_T_JBOD
condition|)
name|vol
operator|->
name|v_raid_level
operator|=
name|G_RAID_VOLUME_RL_SINGLE
expr_stmt|;
else|else
name|vol
operator|->
name|v_raid_level
operator|=
name|G_RAID_VOLUME_RL_UNKNOWN
expr_stmt|;
name|vol
operator|->
name|v_strip_size
operator|=
literal|512
operator|<<
name|meta
operator|->
name|stripe_shift
expr_stmt|;
comment|//ZZZ
name|vol
operator|->
name|v_disks_count
operator|=
name|meta
operator|->
name|total_disks
expr_stmt|;
name|vol
operator|->
name|v_mediasize
operator|=
operator|(
name|off_t
operator|)
name|meta
operator|->
name|total_sectors
operator|*
literal|512
expr_stmt|;
comment|//ZZZ
if|if
condition|(
name|meta
operator|->
name|total_sectors_high
operator|<
literal|256
condition|)
comment|/* If value looks sane. */
name|vol
operator|->
name|v_mediasize
operator|+=
operator|(
operator|(
name|off_t
operator|)
name|meta
operator|->
name|total_sectors_high
operator|<<
literal|32
operator|)
operator|*
literal|512
expr_stmt|;
comment|//ZZZ
name|vol
operator|->
name|v_sectorsize
operator|=
literal|512
operator|*
name|meta
operator|->
name|sector_size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vol
operator|->
name|v_disks_count
condition|;
name|i
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
expr_stmt|;
name|sd
operator|->
name|sd_offset
operator|=
operator|(
operator|(
operator|(
name|off_t
operator|)
name|meta
operator|->
name|disk_offset_high
operator|<<
literal|32
operator|)
operator|+
name|meta
operator|->
name|disk_offset
operator|)
operator|*
literal|512
expr_stmt|;
name|sd
operator|->
name|sd_size
operator|=
operator|(
operator|(
operator|(
name|off_t
operator|)
name|meta
operator|->
name|disk_sectors_high
operator|<<
literal|32
operator|)
operator|+
name|meta
operator|->
name|disk_sectors
operator|)
operator|*
literal|512
expr_stmt|;
block|}
name|g_raid_start_volume
argument_list|(
name|vol
argument_list|)
expr_stmt|;
comment|/* Make all disks found till the moment take their places. */
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
name|pd
operator|=
name|disk
operator|->
name|d_md_data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pd
operator|->
name|pd_subdisks
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pd
operator|->
name|pd_meta
index|[
name|i
index|]
operator|->
name|volume_id
operator|==
name|meta
operator|->
name|volume_id
condition|)
name|g_raid_md_promise_start_disk
argument_list|(
name|disk
argument_list|,
name|i
argument_list|,
name|vol
argument_list|)
expr_stmt|;
block|}
block|}
name|pv
operator|->
name|pv_started
operator|=
literal|1
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|pv
operator|->
name|pv_start_co
argument_list|)
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|0
argument_list|,
name|sc
argument_list|,
literal|"Volume started."
argument_list|)
expr_stmt|;
name|g_raid_md_write_promise
argument_list|(
name|md
argument_list|,
name|vol
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Pickup any STALE/SPARE disks to refill array if needed. */
name|g_raid_md_promise_refill
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|g_raid_event_send
argument_list|(
name|vol
argument_list|,
name|G_RAID_VOLUME_E_START
argument_list|,
name|G_RAID_EVENT_VOLUME
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_promise_go
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_md_promise_pervolume
modifier|*
name|pv
decl_stmt|;
name|vol
operator|=
name|arg
expr_stmt|;
name|pv
operator|=
name|vol
operator|->
name|v_md_data
expr_stmt|;
name|sc
operator|=
name|vol
operator|->
name|v_softc
expr_stmt|;
if|if
condition|(
operator|!
name|pv
operator|->
name|pv_started
condition|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|0
argument_list|,
name|sc
argument_list|,
literal|"Force volume start due to timeout."
argument_list|)
expr_stmt|;
name|g_raid_event_send
argument_list|(
name|vol
argument_list|,
name|G_RAID_VOLUME_E_STARTMD
argument_list|,
name|G_RAID_EVENT_VOLUME
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_md_promise_new_disk
parameter_list|(
name|struct
name|g_raid_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_md_object
modifier|*
name|md
decl_stmt|;
name|struct
name|promise_raid_conf
modifier|*
name|pdmeta
decl_stmt|;
name|struct
name|g_raid_md_promise_perdisk
modifier|*
name|pd
decl_stmt|;
name|struct
name|g_raid_md_promise_pervolume
modifier|*
name|pv
decl_stmt|;
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|33
index|]
decl_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|md
operator|=
name|sc
operator|->
name|sc_md
expr_stmt|;
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_promise_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|pd_subdisks
operator|==
literal|0
condition|)
block|{
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_SPARE
argument_list|)
expr_stmt|;
name|g_raid_md_promise_refill
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pd
operator|->
name|pd_subdisks
condition|;
name|i
operator|++
control|)
block|{
name|pdmeta
operator|=
name|pd
operator|->
name|pd_meta
index|[
name|i
index|]
expr_stmt|;
comment|/* Look for volume with matching ID. */
name|vol
operator|=
name|g_raid_md_promise_get_volume
argument_list|(
name|sc
argument_list|,
name|pdmeta
operator|->
name|volume_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vol
operator|==
name|NULL
condition|)
block|{
name|promise_meta_get_name
argument_list|(
name|pdmeta
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|vol
operator|=
name|g_raid_create_volume
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
name|pdmeta
operator|->
name|array_number
argument_list|)
expr_stmt|;
name|pv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pv
argument_list|)
argument_list|,
name|M_MD_PROMISE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pv_id
operator|=
name|pdmeta
operator|->
name|volume_id
expr_stmt|;
name|vol
operator|->
name|v_md_data
operator|=
name|pv
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|pv
operator|->
name|pv_start_co
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|pv
operator|->
name|pv_start_co
argument_list|,
name|g_raid_start_timeout
operator|*
name|hz
argument_list|,
name|g_raid_promise_go
argument_list|,
name|vol
argument_list|)
expr_stmt|;
block|}
else|else
name|pv
operator|=
name|vol
operator|->
name|v_md_data
expr_stmt|;
comment|/* If we haven't started yet - check metadata freshness. */
if|if
condition|(
name|pv
operator|->
name|pv_meta
operator|==
name|NULL
operator|||
operator|!
name|pv
operator|->
name|pv_started
condition|)
block|{
if|if
condition|(
name|pv
operator|->
name|pv_meta
operator|==
name|NULL
operator|||
operator|(
call|(
name|int16_t
call|)
argument_list|(
name|pdmeta
operator|->
name|generation
operator|-
name|pv
operator|->
name|pv_generation
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"Newer disk"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|pv_meta
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|pv
operator|->
name|pv_meta
argument_list|,
name|M_MD_PROMISE
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pv_meta
operator|=
name|promise_meta_copy
argument_list|(
name|pdmeta
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pv_generation
operator|=
name|pv
operator|->
name|pv_meta
operator|->
name|generation
expr_stmt|;
name|pv
operator|->
name|pv_disks_present
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pdmeta
operator|->
name|generation
operator|==
name|pv
operator|->
name|pv_generation
condition|)
block|{
name|pv
operator|->
name|pv_disks_present
operator|++
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"Matching disk (%d of %d up)"
argument_list|,
name|pv
operator|->
name|pv_disks_present
argument_list|,
name|pv
operator|->
name|pv_meta
operator|->
name|total_disks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"Older disk"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pd
operator|->
name|pd_subdisks
condition|;
name|i
operator|++
control|)
block|{
name|pdmeta
operator|=
name|pd
operator|->
name|pd_meta
index|[
name|i
index|]
expr_stmt|;
comment|/* Look for volume with matching ID. */
name|vol
operator|=
name|g_raid_md_promise_get_volume
argument_list|(
name|sc
argument_list|,
name|pdmeta
operator|->
name|volume_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vol
operator|==
name|NULL
condition|)
continue|continue;
name|pv
operator|=
name|vol
operator|->
name|v_md_data
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|pv_started
condition|)
block|{
if|if
condition|(
name|g_raid_md_promise_start_disk
argument_list|(
name|disk
argument_list|,
name|i
argument_list|,
name|vol
argument_list|)
condition|)
name|g_raid_md_write_promise
argument_list|(
name|md
argument_list|,
name|vol
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If we collected all needed disks - start array. */
if|if
condition|(
name|pv
operator|->
name|pv_disks_present
operator|==
name|pv
operator|->
name|pv_meta
operator|->
name|total_disks
condition|)
name|g_raid_md_promise_start
argument_list|(
name|vol
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_create_promise
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_geom
modifier|*
modifier|*
name|gp
parameter_list|)
block|{
name|struct
name|g_geom
modifier|*
name|geom
decl_stmt|;
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
comment|/* Search for existing node. */
name|LIST_FOREACH
argument_list|(
argument|geom
argument_list|,
argument|&mp->geom
argument_list|,
argument|geom
argument_list|)
block|{
name|sc
operator|=
name|geom
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|sc
operator|->
name|sc_stopping
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sc
operator|->
name|sc_md
operator|->
name|mdo_class
operator|!=
name|md
operator|->
name|mdo_class
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|geom
operator|!=
name|NULL
condition|)
block|{
operator|*
name|gp
operator|=
name|geom
expr_stmt|;
return|return
operator|(
name|G_RAID_MD_TASTE_EXISTING
operator|)
return|;
block|}
comment|/* Create new one if not found. */
name|sc
operator|=
name|g_raid_create_node
argument_list|(
name|mp
argument_list|,
literal|"Promise"
argument_list|,
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|G_RAID_MD_TASTE_FAIL
operator|)
return|;
name|md
operator|->
name|mdo_softc
operator|=
name|sc
expr_stmt|;
operator|*
name|gp
operator|=
name|sc
operator|->
name|sc_geom
expr_stmt|;
return|return
operator|(
name|G_RAID_MD_TASTE_NEW
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_taste_promise
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_geom
modifier|*
modifier|*
name|gp
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|rcp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|promise_raid_conf
modifier|*
name|meta
decl_stmt|,
modifier|*
name|metaarr
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|g_raid_md_promise_perdisk
modifier|*
name|pd
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|geom
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|result
decl_stmt|,
name|len
decl_stmt|,
name|subdisks
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|uint16_t
name|vendor
decl_stmt|;
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Tasting Promise on %s"
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
comment|/* Read metadata from device. */
name|meta
operator|=
name|NULL
expr_stmt|;
name|vendor
operator|=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|g_access
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|G_RAID_MD_TASTE_FAIL
operator|)
return|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|len
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|geom
operator|->
name|rank
operator|==
literal|1
condition|)
name|g_io_getattr
argument_list|(
literal|"GEOM::hba_vendor"
argument_list|,
name|cp
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|vendor
argument_list|)
expr_stmt|;
name|subdisks
operator|=
name|promise_meta_read
argument_list|(
name|cp
argument_list|,
name|metaarr
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|subdisks
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|g_raid_aggressive_spare
condition|)
block|{
if|if
condition|(
name|vendor
operator|==
literal|0x105a
operator|||
name|vendor
operator|==
literal|0x1002
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"No Promise metadata, forcing spare."
argument_list|)
expr_stmt|;
goto|goto
name|search
goto|;
block|}
else|else
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Promise/ATI vendor mismatch "
literal|"0x%04x != 0x105a/0x1002"
argument_list|,
name|vendor
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|G_RAID_MD_TASTE_FAIL
operator|)
return|;
block|}
comment|/* Metadata valid. Print it. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|subdisks
condition|;
name|i
operator|++
control|)
name|g_raid_md_promise_print
argument_list|(
name|metaarr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Purge meaningless (empty/spare) records. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|subdisks
condition|;
control|)
block|{
if|if
condition|(
name|metaarr
index|[
name|i
index|]
operator|->
name|disk
operator|.
name|flags
operator|&
name|PROMISE_F_ASSIGNED
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
name|free
argument_list|(
name|metaarr
index|[
name|i
index|]
argument_list|,
name|M_MD_PROMISE
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|subdisks
operator|-
literal|1
condition|;
name|j
operator|++
control|)
name|metaarr
index|[
name|i
index|]
operator|=
name|metaarr
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
name|metaarr
index|[
name|PROMISE_MAX_SUBDISKS
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|subdisks
operator|--
expr_stmt|;
block|}
name|search
label|:
comment|/* Search for matching node. */
name|sc
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|geom
argument_list|,
argument|&mp->geom
argument_list|,
argument|geom
argument_list|)
block|{
name|sc
operator|=
name|geom
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|sc
operator|->
name|sc_stopping
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sc
operator|->
name|sc_md
operator|->
name|mdo_class
operator|!=
name|md
operator|->
name|mdo_class
condition|)
continue|continue;
break|break;
block|}
comment|/* Found matching node. */
if|if
condition|(
name|geom
operator|!=
name|NULL
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Found matching array %s"
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|result
operator|=
name|G_RAID_MD_TASTE_EXISTING
expr_stmt|;
block|}
else|else
block|{
comment|/* Not found matching node -- create one. */
name|result
operator|=
name|G_RAID_MD_TASTE_NEW
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"Promise"
argument_list|)
expr_stmt|;
name|sc
operator|=
name|g_raid_create_node
argument_list|(
name|mp
argument_list|,
name|name
argument_list|,
name|md
argument_list|)
expr_stmt|;
name|md
operator|->
name|mdo_softc
operator|=
name|sc
expr_stmt|;
name|geom
operator|=
name|sc
operator|->
name|sc_geom
expr_stmt|;
block|}
name|rcp
operator|=
name|g_new_consumer
argument_list|(
name|geom
argument_list|)
expr_stmt|;
name|g_attach
argument_list|(
name|rcp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_access
argument_list|(
name|rcp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
comment|//goto fail1;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|pd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pd
argument_list|)
argument_list|,
name|M_MD_PROMISE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pd
operator|->
name|pd_subdisks
operator|=
name|subdisks
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|subdisks
condition|;
name|i
operator|++
control|)
name|pd
operator|->
name|pd_meta
index|[
name|i
index|]
operator|=
name|metaarr
index|[
name|i
index|]
expr_stmt|;
name|disk
operator|=
name|g_raid_create_disk
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_md_data
operator|=
operator|(
name|void
operator|*
operator|)
name|pd
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|=
name|rcp
expr_stmt|;
name|rcp
operator|->
name|private
operator|=
name|disk
expr_stmt|;
name|g_raid_get_disk_info
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|g_raid_md_promise_new_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
operator|*
name|gp
operator|=
name|geom
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_event_promise
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|g_raid_disk
modifier|*
name|disk
parameter_list|,
name|u_int
name|event
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|md
operator|->
name|mdo_softc
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|G_RAID_DISK_E_DISCONNECTED
case|:
comment|/* Delete disk. */
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_NONE
argument_list|)
expr_stmt|;
name|g_raid_destroy_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|g_raid_md_promise_purge_volumes
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Write updated metadata to all disks. */
name|g_raid_md_write_promise
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Check if anything left. */
if|if
condition|(
name|g_raid_ndisks
argument_list|(
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|g_raid_destroy_node
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|g_raid_md_promise_refill
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_volume_event_promise
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|g_raid_volume
modifier|*
name|vol
parameter_list|,
name|u_int
name|event
parameter_list|)
block|{
name|struct
name|g_raid_md_promise_pervolume
modifier|*
name|pv
decl_stmt|;
name|pv
operator|=
operator|(
expr|struct
name|g_raid_md_promise_pervolume
operator|*
operator|)
name|vol
operator|->
name|v_md_data
expr_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|G_RAID_VOLUME_E_STARTMD
case|:
if|if
condition|(
operator|!
name|pv
operator|->
name|pv_started
condition|)
name|g_raid_md_promise_start
argument_list|(
name|vol
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_ctl_promise
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|,
modifier|*
name|vol1
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|,
modifier|*
name|disks
index|[
name|PROMISE_MAX_DISKS
index|]
decl_stmt|;
name|struct
name|g_raid_md_promise_perdisk
modifier|*
name|pd
decl_stmt|;
name|struct
name|g_raid_md_promise_pervolume
modifier|*
name|pv
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|char
name|arg
index|[
literal|16
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|nodename
decl_stmt|,
modifier|*
name|verb
decl_stmt|,
modifier|*
name|volname
decl_stmt|,
modifier|*
name|levelname
decl_stmt|,
modifier|*
name|diskname
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|int
modifier|*
name|nargs
decl_stmt|,
modifier|*
name|force
decl_stmt|;
name|off_t
name|esize
decl_stmt|,
name|offs
index|[
name|PROMISE_MAX_DISKS
index|]
decl_stmt|,
name|size
decl_stmt|,
name|sectorsize
decl_stmt|,
name|strip
decl_stmt|;
name|intmax_t
modifier|*
name|sizearg
decl_stmt|,
modifier|*
name|striparg
decl_stmt|;
name|int
name|numdisks
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|,
name|level
decl_stmt|,
name|qual
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|md
operator|->
name|mdo_softc
expr_stmt|;
name|verb
operator|=
name|gctl_get_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|gctl_get_paraml
argument_list|(
name|req
argument_list|,
literal|"nargs"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nargs
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"label"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|nargs
operator|<
literal|4
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Invalid number of arguments."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|volname
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
literal|"arg1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volname
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No volume name."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|levelname
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
literal|"arg2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|levelname
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No RAID level."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|3
operator|)
return|;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
name|levelname
argument_list|,
literal|"RAID5"
argument_list|)
operator|==
literal|0
condition|)
name|levelname
operator|=
literal|"RAID5-LA"
expr_stmt|;
if|if
condition|(
name|g_raid_volume_str2level
argument_list|(
name|levelname
argument_list|,
operator|&
name|level
argument_list|,
operator|&
name|qual
argument_list|)
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Unknown RAID level '%s'."
argument_list|,
name|levelname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|4
operator|)
return|;
block|}
name|numdisks
operator|=
operator|*
name|nargs
operator|-
literal|3
expr_stmt|;
name|force
operator|=
name|gctl_get_paraml
argument_list|(
name|req
argument_list|,
literal|"force"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|force
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_raid_md_promise_supported
argument_list|(
name|level
argument_list|,
name|qual
argument_list|,
name|numdisks
argument_list|,
name|force
condition|?
operator|*
name|force
else|:
literal|0
argument_list|)
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Unsupported RAID level "
literal|"(0x%02x/0x%02x), or number of disks (%d)."
argument_list|,
name|level
argument_list|,
name|qual
argument_list|,
name|numdisks
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|5
operator|)
return|;
block|}
comment|/* Search for disks, connect them and probe. */
name|size
operator|=
name|INT64_MAX
expr_stmt|;
name|sectorsize
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|disks
argument_list|,
sizeof|sizeof
argument_list|(
name|disks
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|offs
argument_list|,
sizeof|sizeof
argument_list|(
name|offs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdisks
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|"arg%d"
argument_list|,
name|i
operator|+
literal|3
argument_list|)
expr_stmt|;
name|diskname
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskname
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No disk name (%s)."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
literal|6
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|diskname
argument_list|,
literal|"NONE"
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_consumer
operator|!=
name|NULL
operator|&&
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|->
name|name
argument_list|,
name|diskname
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|disk
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_RAID_DISK_S_ACTIVE
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Disk '%s' is in a "
literal|"wrong state (%s)."
argument_list|,
name|diskname
argument_list|,
name|g_raid_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
literal|7
expr_stmt|;
break|break;
block|}
name|pd
operator|=
name|disk
operator|->
name|d_md_data
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|pd_subdisks
operator|>=
name|PROMISE_MAX_SUBDISKS
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Disk '%s' already "
literal|"used by %d volumes."
argument_list|,
name|diskname
argument_list|,
name|pd
operator|->
name|pd_subdisks
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
literal|7
expr_stmt|;
break|break;
block|}
name|pp
operator|=
name|disk
operator|->
name|d_consumer
operator|->
name|provider
expr_stmt|;
name|disks
index|[
name|i
index|]
operator|=
name|disk
expr_stmt|;
name|promise_meta_unused_range
argument_list|(
name|pd
operator|->
name|pd_meta
argument_list|,
name|pd
operator|->
name|pd_subdisks
argument_list|,
name|pp
operator|->
name|mediasize
operator|/
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|offs
index|[
name|i
index|]
argument_list|,
operator|&
name|esize
argument_list|)
expr_stmt|;
name|size
operator|=
name|MIN
argument_list|(
name|size
argument_list|,
operator|(
name|off_t
operator|)
name|esize
operator|*
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|sectorsize
operator|=
name|MAX
argument_list|(
name|sectorsize
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|g_topology_lock
argument_list|()
expr_stmt|;
name|cp
operator|=
name|g_raid_open_consumer
argument_list|(
name|sc
argument_list|,
name|diskname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Can't open disk '%s'."
argument_list|,
name|diskname
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|error
operator|=
operator|-
literal|8
expr_stmt|;
break|break;
block|}
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|pd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pd
argument_list|)
argument_list|,
name|M_MD_PROMISE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|disk
operator|=
name|g_raid_create_disk
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_md_data
operator|=
operator|(
name|void
operator|*
operator|)
name|pd
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|=
name|cp
expr_stmt|;
name|disks
index|[
name|i
index|]
operator|=
name|disk
expr_stmt|;
name|cp
operator|->
name|private
operator|=
name|disk
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|g_raid_get_disk_info
argument_list|(
name|disk
argument_list|)
expr_stmt|;
comment|/* Reserve some space for metadata. */
name|size
operator|=
name|MIN
argument_list|(
name|size
argument_list|,
name|pp
operator|->
name|mediasize
operator|-
literal|131072llu
operator|*
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
name|sectorsize
operator|=
name|MAX
argument_list|(
name|sectorsize
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdisks
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|disks
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|disks
index|[
name|i
index|]
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_NONE
condition|)
name|g_raid_destroy_disk
argument_list|(
name|disks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|sectorsize
operator|<=
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Can't get sector size."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|8
operator|)
return|;
block|}
comment|/* Handle size argument. */
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sizearg
argument_list|)
expr_stmt|;
name|sizearg
operator|=
name|gctl_get_param
argument_list|(
name|req
argument_list|,
literal|"size"
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sizearg
operator|!=
name|NULL
operator|&&
name|len
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|sizearg
argument_list|)
operator|&&
operator|*
name|sizearg
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|sizearg
operator|>
name|size
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Size too big %lld> %lld."
argument_list|,
operator|(
name|long
name|long
operator|)
operator|*
name|sizearg
argument_list|,
operator|(
name|long
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
name|size
operator|=
operator|*
name|sizearg
expr_stmt|;
block|}
comment|/* Handle strip argument. */
name|strip
operator|=
literal|131072
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|striparg
argument_list|)
expr_stmt|;
name|striparg
operator|=
name|gctl_get_param
argument_list|(
name|req
argument_list|,
literal|"strip"
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|striparg
operator|!=
name|NULL
operator|&&
name|len
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|striparg
argument_list|)
operator|&&
operator|*
name|striparg
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|striparg
operator|<
name|sectorsize
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Strip size too small."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|10
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|striparg
operator|%
name|sectorsize
operator|!=
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Incorrect strip size."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|11
operator|)
return|;
block|}
name|strip
operator|=
operator|*
name|striparg
expr_stmt|;
block|}
comment|/* Round size down to strip or sector. */
if|if
condition|(
name|level
operator|==
name|G_RAID_VOLUME_RL_RAID1
operator|||
name|level
operator|==
name|G_RAID_VOLUME_RL_SINGLE
operator|||
name|level
operator|==
name|G_RAID_VOLUME_RL_CONCAT
condition|)
name|size
operator|-=
operator|(
name|size
operator|%
name|sectorsize
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|==
name|G_RAID_VOLUME_RL_RAID1E
operator|&&
operator|(
name|numdisks
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|size
operator|-=
operator|(
name|size
operator|%
operator|(
literal|2
operator|*
name|strip
operator|)
operator|)
expr_stmt|;
else|else
name|size
operator|-=
operator|(
name|size
operator|%
name|strip
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Size too small."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|13
operator|)
return|;
block|}
comment|/* We have all we need, create things: volume, ... */
name|pv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pv
argument_list|)
argument_list|,
name|M_MD_PROMISE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|arc4rand
argument_list|(
operator|&
name|pv
operator|->
name|pv_id
argument_list|,
sizeof|sizeof
argument_list|(
name|pv
operator|->
name|pv_id
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pv_generation
operator|=
literal|0
expr_stmt|;
name|pv
operator|->
name|pv_started
operator|=
literal|1
expr_stmt|;
name|vol
operator|=
name|g_raid_create_volume
argument_list|(
name|sc
argument_list|,
name|volname
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|vol
operator|->
name|v_md_data
operator|=
name|pv
expr_stmt|;
name|vol
operator|->
name|v_raid_level
operator|=
name|level
expr_stmt|;
name|vol
operator|->
name|v_raid_level_qualifier
operator|=
name|qual
expr_stmt|;
name|vol
operator|->
name|v_strip_size
operator|=
name|strip
expr_stmt|;
name|vol
operator|->
name|v_disks_count
operator|=
name|numdisks
expr_stmt|;
if|if
condition|(
name|level
operator|==
name|G_RAID_VOLUME_RL_RAID0
operator|||
name|level
operator|==
name|G_RAID_VOLUME_RL_CONCAT
operator|||
name|level
operator|==
name|G_RAID_VOLUME_RL_SINGLE
condition|)
name|vol
operator|->
name|v_mediasize
operator|=
name|size
operator|*
name|numdisks
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|==
name|G_RAID_VOLUME_RL_RAID1
condition|)
name|vol
operator|->
name|v_mediasize
operator|=
name|size
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|==
name|G_RAID_VOLUME_RL_RAID3
operator|||
name|level
operator|==
name|G_RAID_VOLUME_RL_RAID5
condition|)
name|vol
operator|->
name|v_mediasize
operator|=
name|size
operator|*
operator|(
name|numdisks
operator|-
literal|1
operator|)
expr_stmt|;
else|else
block|{
comment|/* RAID1E */
name|vol
operator|->
name|v_mediasize
operator|=
operator|(
operator|(
name|size
operator|*
name|numdisks
operator|)
operator|/
name|strip
operator|/
literal|2
operator|)
operator|*
name|strip
expr_stmt|;
block|}
name|vol
operator|->
name|v_sectorsize
operator|=
name|sectorsize
expr_stmt|;
name|g_raid_start_volume
argument_list|(
name|vol
argument_list|)
expr_stmt|;
comment|/* , and subdisks. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdisks
condition|;
name|i
operator|++
control|)
block|{
name|disk
operator|=
name|disks
index|[
name|i
index|]
expr_stmt|;
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
expr_stmt|;
name|sd
operator|->
name|sd_disk
operator|=
name|disk
expr_stmt|;
name|sd
operator|->
name|sd_offset
operator|=
operator|(
name|off_t
operator|)
name|offs
index|[
name|i
index|]
operator|*
literal|512
expr_stmt|;
name|sd
operator|->
name|sd_size
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
continue|continue;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|disk
operator|->
name|d_subdisks
argument_list|,
name|sd
argument_list|,
name|sd_next
argument_list|)
expr_stmt|;
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_ACTIVE
argument_list|)
expr_stmt|;
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_ACTIVE
argument_list|)
expr_stmt|;
name|g_raid_event_send
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_E_NEW
argument_list|,
name|G_RAID_EVENT_SUBDISK
argument_list|)
expr_stmt|;
block|}
comment|/* Write metadata based on created entities. */
name|G_RAID_DEBUG1
argument_list|(
literal|0
argument_list|,
name|sc
argument_list|,
literal|"Array started."
argument_list|)
expr_stmt|;
name|g_raid_md_write_promise
argument_list|(
name|md
argument_list|,
name|vol
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Pickup any STALE/SPARE disks to refill array if needed. */
name|g_raid_md_promise_refill
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|g_raid_event_send
argument_list|(
name|vol
argument_list|,
name|G_RAID_VOLUME_E_START
argument_list|,
name|G_RAID_EVENT_VOLUME
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"add"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"`add` command is not applicable, "
literal|"use `label` instead."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|99
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"delete"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nodename
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
literal|"arg0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodename
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|sc
operator|->
name|sc_name
argument_list|,
name|nodename
argument_list|)
operator|!=
literal|0
condition|)
name|nodename
operator|=
name|NULL
expr_stmt|;
comment|/* Full node destruction. */
if|if
condition|(
operator|*
name|nargs
operator|==
literal|1
operator|&&
name|nodename
operator|!=
name|NULL
condition|)
block|{
comment|/* Check if some volume is still open. */
name|force
operator|=
name|gctl_get_paraml
argument_list|(
name|req
argument_list|,
literal|"force"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|force
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|force
operator|!=
name|NULL
operator|&&
operator|*
name|force
operator|==
literal|0
operator|&&
name|g_raid_nopens
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Some volume is still open."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|4
operator|)
return|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_consumer
condition|)
name|promise_meta_erase
argument_list|(
name|disk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
block|}
name|g_raid_destroy_node
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Destroy specified volume. If it was last - all node. */
if|if
condition|(
operator|*
name|nargs
operator|>
literal|2
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Invalid number of arguments."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|volname
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
name|nodename
operator|!=
name|NULL
condition|?
literal|"arg1"
else|:
literal|"arg0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volname
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No volume name."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
comment|/* Search for volume. */
name|TAILQ_FOREACH
argument_list|(
argument|vol
argument_list|,
argument|&sc->sc_volumes
argument_list|,
argument|v_next
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|vol
operator|->
name|v_name
argument_list|,
name|volname
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|pp
operator|=
name|vol
operator|->
name|v_provider
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|pp
operator|->
name|name
argument_list|,
name|volname
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|strncmp
argument_list|(
name|pp
operator|->
name|name
argument_list|,
literal|"raid/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|pp
operator|->
name|name
operator|+
literal|5
argument_list|,
name|volname
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|vol
operator|==
name|NULL
condition|)
block|{
name|i
operator|=
name|strtol
argument_list|(
name|volname
argument_list|,
operator|&
name|tmp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|verb
operator|!=
name|volname
operator|&&
name|tmp
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|vol
argument_list|,
argument|&sc->sc_volumes
argument_list|,
argument|v_next
argument_list|)
block|{
if|if
condition|(
name|vol
operator|->
name|v_global_id
operator|==
name|i
condition|)
break|break;
block|}
block|}
block|}
if|if
condition|(
name|vol
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Volume '%s' not found."
argument_list|,
name|volname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|3
operator|)
return|;
block|}
comment|/* Check if volume is still open. */
name|force
operator|=
name|gctl_get_paraml
argument_list|(
name|req
argument_list|,
literal|"force"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|force
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|force
operator|!=
name|NULL
operator|&&
operator|*
name|force
operator|==
literal|0
operator|&&
name|vol
operator|->
name|v_provider_open
operator|!=
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Volume is still open."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|4
operator|)
return|;
block|}
comment|/* Destroy volume and potentially node. */
name|i
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vol1
argument_list|,
argument|&sc->sc_volumes
argument_list|,
argument|v_next
argument_list|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|2
condition|)
block|{
name|g_raid_destroy_volume
argument_list|(
name|vol
argument_list|)
expr_stmt|;
name|g_raid_md_promise_purge_disks
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|g_raid_md_write_promise
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_consumer
condition|)
name|promise_meta_erase
argument_list|(
name|disk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
block|}
name|g_raid_destroy_node
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"remove"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"fail"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|nargs
operator|<
literal|2
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Invalid number of arguments."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|*
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|"arg%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|diskname
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskname
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No disk name (%s)."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|diskname
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|diskname
operator|+=
literal|5
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_consumer
operator|!=
name|NULL
operator|&&
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|->
name|name
argument_list|,
name|diskname
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Disk '%s' not found."
argument_list|,
name|diskname
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
literal|3
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"fail"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|g_raid_md_fail_disk_promise
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|disk
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Erase metadata on deleting disk and destroy it. */
name|promise_meta_erase
argument_list|(
name|disk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
name|g_raid_destroy_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
name|g_raid_md_promise_purge_volumes
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Write updated metadata to remaining disks. */
name|g_raid_md_write_promise
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Check if anything left. */
if|if
condition|(
name|g_raid_ndisks
argument_list|(
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|g_raid_destroy_node
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|g_raid_md_promise_refill
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"insert"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|nargs
operator|<
literal|2
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Invalid number of arguments."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|*
name|nargs
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get disk name. */
name|snprintf
argument_list|(
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|"arg%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|diskname
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskname
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No disk name (%s)."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
literal|3
expr_stmt|;
break|break;
block|}
comment|/* Try to find provider with specified name. */
name|g_topology_lock
argument_list|()
expr_stmt|;
name|cp
operator|=
name|g_raid_open_consumer
argument_list|(
name|sc
argument_list|,
name|diskname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Can't open disk '%s'."
argument_list|,
name|diskname
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|error
operator|=
operator|-
literal|4
expr_stmt|;
break|break;
block|}
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|pd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pd
argument_list|)
argument_list|,
name|M_MD_PROMISE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|disk
operator|=
name|g_raid_create_disk
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|=
name|cp
expr_stmt|;
name|disk
operator|->
name|d_md_data
operator|=
operator|(
name|void
operator|*
operator|)
name|pd
expr_stmt|;
name|cp
operator|->
name|private
operator|=
name|disk
expr_stmt|;
name|g_raid_get_disk_info
argument_list|(
name|disk
argument_list|)
expr_stmt|;
comment|/* Welcome the "new" disk. */
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_SPARE
argument_list|)
expr_stmt|;
name|promise_meta_write_spare
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_raid_md_promise_refill
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|100
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_write_promise
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|g_raid_volume
modifier|*
name|tvol
parameter_list|,
name|struct
name|g_raid_subdisk
modifier|*
name|tsd
parameter_list|,
name|struct
name|g_raid_disk
modifier|*
name|tdisk
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_raid_md_promise_perdisk
modifier|*
name|pd
decl_stmt|;
name|struct
name|g_raid_md_promise_pervolume
modifier|*
name|pv
decl_stmt|;
name|struct
name|promise_raid_conf
modifier|*
name|meta
decl_stmt|;
name|off_t
name|rebuild_lba64
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|pos
decl_stmt|,
name|rebuild
decl_stmt|;
name|sc
operator|=
name|md
operator|->
name|mdo_softc
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_stopping
operator|==
name|G_RAID_DESTROY_HARD
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Generate new per-volume metadata for affected volumes. */
name|TAILQ_FOREACH
argument_list|(
argument|vol
argument_list|,
argument|&sc->sc_volumes
argument_list|,
argument|v_next
argument_list|)
block|{
if|if
condition|(
name|vol
operator|->
name|v_stopping
condition|)
continue|continue;
comment|/* Skip volumes not related to specified targets. */
if|if
condition|(
name|tvol
operator|!=
name|NULL
operator|&&
name|vol
operator|!=
name|tvol
condition|)
continue|continue;
if|if
condition|(
name|tsd
operator|!=
name|NULL
operator|&&
name|vol
operator|!=
name|tsd
operator|->
name|sd_volume
condition|)
continue|continue;
if|if
condition|(
name|tdisk
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vol
operator|->
name|v_disks_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
operator|.
name|sd_disk
operator|==
name|tdisk
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|vol
operator|->
name|v_disks_count
condition|)
continue|continue;
block|}
name|pv
operator|=
operator|(
expr|struct
name|g_raid_md_promise_pervolume
operator|*
operator|)
name|vol
operator|->
name|v_md_data
expr_stmt|;
name|pv
operator|->
name|pv_generation
operator|++
expr_stmt|;
name|meta
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|meta
argument_list|)
argument_list|,
name|M_MD_PROMISE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|pv_meta
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
name|meta
argument_list|,
name|pv
operator|->
name|pv_meta
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|meta
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|meta
operator|->
name|promise_id
argument_list|,
name|PROMISE_MAGIC
argument_list|,
sizeof|sizeof
argument_list|(
name|PROMISE_MAGIC
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|meta
operator|->
name|dummy_0
operator|=
literal|0x00020000
expr_stmt|;
name|meta
operator|->
name|integrity
operator|=
name|PROMISE_I_VALID
expr_stmt|;
name|meta
operator|->
name|generation
operator|=
name|pv
operator|->
name|pv_generation
expr_stmt|;
name|meta
operator|->
name|status
operator|=
name|PROMISE_S_VALID
operator||
name|PROMISE_S_ONLINE
operator||
name|PROMISE_S_INITED
operator||
name|PROMISE_S_READY
expr_stmt|;
if|if
condition|(
name|vol
operator|->
name|v_state
operator|<=
name|G_RAID_VOLUME_S_DEGRADED
condition|)
name|meta
operator|->
name|status
operator||=
name|PROMISE_S_DEGRADED
expr_stmt|;
if|if
condition|(
name|vol
operator|->
name|v_dirty
condition|)
name|meta
operator|->
name|status
operator||=
name|PROMISE_S_MARKED
expr_stmt|;
comment|/* XXX: INVENTED! */
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID0
operator|||
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_SINGLE
condition|)
name|meta
operator|->
name|type
operator|=
name|PROMISE_T_RAID0
expr_stmt|;
elseif|else
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID1
operator|||
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID1E
condition|)
name|meta
operator|->
name|type
operator|=
name|PROMISE_T_RAID1
expr_stmt|;
elseif|else
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID3
condition|)
name|meta
operator|->
name|type
operator|=
name|PROMISE_T_RAID3
expr_stmt|;
elseif|else
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID5
condition|)
name|meta
operator|->
name|type
operator|=
name|PROMISE_T_RAID5
expr_stmt|;
elseif|else
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_CONCAT
condition|)
name|meta
operator|->
name|type
operator|=
name|PROMISE_T_SPAN
expr_stmt|;
else|else
name|meta
operator|->
name|type
operator|=
name|PROMISE_T_JBOD
expr_stmt|;
name|meta
operator|->
name|total_disks
operator|=
name|vol
operator|->
name|v_disks_count
expr_stmt|;
name|meta
operator|->
name|stripe_shift
operator|=
name|ffs
argument_list|(
name|vol
operator|->
name|v_strip_size
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|meta
operator|->
name|array_width
operator|=
name|vol
operator|->
name|v_disks_count
expr_stmt|;
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID1
operator|||
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID1E
condition|)
name|meta
operator|->
name|array_width
operator|/=
literal|2
expr_stmt|;
name|meta
operator|->
name|array_number
operator|=
name|vol
operator|->
name|v_global_id
expr_stmt|;
name|meta
operator|->
name|total_sectors
operator|=
name|vol
operator|->
name|v_mediasize
operator|/
literal|512
expr_stmt|;
name|meta
operator|->
name|total_sectors_high
operator|=
operator|(
name|vol
operator|->
name|v_mediasize
operator|/
literal|512
operator|)
operator|>>
literal|32
expr_stmt|;
name|meta
operator|->
name|sector_size
operator|=
name|vol
operator|->
name|v_sectorsize
operator|/
literal|512
expr_stmt|;
name|meta
operator|->
name|cylinders
operator|=
name|meta
operator|->
name|total_sectors
operator|/
operator|(
literal|255
operator|*
literal|63
operator|)
operator|-
literal|1
expr_stmt|;
name|meta
operator|->
name|heads
operator|=
literal|254
expr_stmt|;
name|meta
operator|->
name|sectors
operator|=
literal|63
expr_stmt|;
name|meta
operator|->
name|volume_id
operator|=
name|pv
operator|->
name|pv_id
expr_stmt|;
name|rebuild_lba64
operator|=
name|UINT64_MAX
expr_stmt|;
name|rebuild
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vol
operator|->
name|v_disks_count
condition|;
name|i
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
expr_stmt|;
comment|/* For RAID0+1 we need to translate order. */
name|pos
operator|=
name|promise_meta_translate_disk
argument_list|(
name|vol
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|meta
operator|->
name|disks
index|[
name|pos
index|]
operator|.
name|flags
operator|=
name|PROMISE_F_VALID
operator||
name|PROMISE_F_ASSIGNED
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_NONE
condition|)
block|{
name|meta
operator|->
name|disks
index|[
name|pos
index|]
operator|.
name|flags
operator||=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_FAILED
condition|)
block|{
name|meta
operator|->
name|disks
index|[
name|pos
index|]
operator|.
name|flags
operator||=
name|PROMISE_F_DOWN
operator||
name|PROMISE_F_REDIR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|<=
name|G_RAID_SUBDISK_S_REBUILD
condition|)
block|{
name|meta
operator|->
name|disks
index|[
name|pos
index|]
operator|.
name|flags
operator||=
name|PROMISE_F_ONLINE
operator||
name|PROMISE_F_REDIR
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_REBUILD
condition|)
block|{
name|rebuild_lba64
operator|=
name|MIN
argument_list|(
name|rebuild_lba64
argument_list|,
name|sd
operator|->
name|sd_rebuild_pos
operator|/
literal|512
argument_list|)
expr_stmt|;
block|}
else|else
name|rebuild_lba64
operator|=
literal|0
expr_stmt|;
name|rebuild
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|meta
operator|->
name|disks
index|[
name|pos
index|]
operator|.
name|flags
operator||=
name|PROMISE_F_ONLINE
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|<
name|G_RAID_SUBDISK_S_ACTIVE
condition|)
block|{
name|meta
operator|->
name|status
operator||=
name|PROMISE_S_MARKED
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_RESYNC
condition|)
block|{
name|rebuild_lba64
operator|=
name|MIN
argument_list|(
name|rebuild_lba64
argument_list|,
name|sd
operator|->
name|sd_rebuild_pos
operator|/
literal|512
argument_list|)
expr_stmt|;
block|}
else|else
name|rebuild_lba64
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pv
operator|->
name|pv_meta
operator|!=
name|NULL
condition|)
block|{
name|meta
operator|->
name|disks
index|[
name|pos
index|]
operator|.
name|id
operator|=
name|pv
operator|->
name|pv_meta
operator|->
name|disks
index|[
name|pos
index|]
operator|.
name|id
expr_stmt|;
block|}
else|else
block|{
name|meta
operator|->
name|disks
index|[
name|pos
index|]
operator|.
name|number
operator|=
name|i
operator|*
literal|2
expr_stmt|;
name|arc4rand
argument_list|(
operator|&
name|meta
operator|->
name|disks
index|[
name|pos
index|]
operator|.
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|meta
operator|->
name|disks
index|[
name|pos
index|]
operator|.
name|id
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|promise_meta_put_name
argument_list|(
name|meta
argument_list|,
name|vol
operator|->
name|v_name
argument_list|)
expr_stmt|;
comment|/* Try to mimic AMD BIOS rebuild/resync behavior. */
if|if
condition|(
name|rebuild_lba64
operator|!=
name|UINT64_MAX
condition|)
block|{
if|if
condition|(
name|rebuild
condition|)
name|meta
operator|->
name|magic_3
operator|=
literal|0x03040010UL
expr_stmt|;
comment|/* Rebuild? */
else|else
name|meta
operator|->
name|magic_3
operator|=
literal|0x03040008UL
expr_stmt|;
comment|/* Resync? */
comment|/* Translate from per-disk to per-volume LBA. */
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID1
operator|||
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID1E
condition|)
block|{
name|rebuild_lba64
operator|*=
name|meta
operator|->
name|array_width
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID3
operator|||
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID5
condition|)
block|{
name|rebuild_lba64
operator|*=
name|meta
operator|->
name|array_width
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|rebuild_lba64
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|meta
operator|->
name|magic_3
operator|=
literal|0x03000000UL
expr_stmt|;
name|meta
operator|->
name|rebuild_lba64
operator|=
name|rebuild_lba64
expr_stmt|;
name|meta
operator|->
name|magic_4
operator|=
literal|0x04010101UL
expr_stmt|;
comment|/* Replace per-volume metadata with new. */
if|if
condition|(
name|pv
operator|->
name|pv_meta
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|pv
operator|->
name|pv_meta
argument_list|,
name|M_MD_PROMISE
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pv_meta
operator|=
name|meta
expr_stmt|;
comment|/* Copy new metadata to the disks, adding or replacing old. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vol
operator|->
name|v_disks_count
condition|;
name|i
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
expr_stmt|;
name|disk
operator|=
name|sd
operator|->
name|sd_disk
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
continue|continue;
comment|/* For RAID0+1 we need to translate order. */
name|pos
operator|=
name|promise_meta_translate_disk
argument_list|(
name|vol
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_promise_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|pd
operator|->
name|pd_subdisks
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|pd
operator|->
name|pd_meta
index|[
name|j
index|]
operator|->
name|volume_id
operator|==
name|meta
operator|->
name|volume_id
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|pd
operator|->
name|pd_subdisks
condition|)
name|pd
operator|->
name|pd_subdisks
operator|++
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|pd_meta
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|pd
operator|->
name|pd_meta
index|[
name|j
index|]
argument_list|,
name|M_MD_PROMISE
argument_list|)
expr_stmt|;
name|pd
operator|->
name|pd_meta
index|[
name|j
index|]
operator|=
name|promise_meta_copy
argument_list|(
name|meta
argument_list|)
expr_stmt|;
name|pd
operator|->
name|pd_meta
index|[
name|j
index|]
operator|->
name|disk
operator|=
name|meta
operator|->
name|disks
index|[
name|pos
index|]
expr_stmt|;
name|pd
operator|->
name|pd_meta
index|[
name|j
index|]
operator|->
name|disk
operator|.
name|number
operator|=
name|pos
expr_stmt|;
name|pd
operator|->
name|pd_meta
index|[
name|j
index|]
operator|->
name|disk_offset_high
operator|=
operator|(
name|sd
operator|->
name|sd_offset
operator|/
literal|512
operator|)
operator|>>
literal|32
expr_stmt|;
name|pd
operator|->
name|pd_meta
index|[
name|j
index|]
operator|->
name|disk_offset
operator|=
name|sd
operator|->
name|sd_offset
operator|/
literal|512
expr_stmt|;
name|pd
operator|->
name|pd_meta
index|[
name|j
index|]
operator|->
name|disk_sectors_high
operator|=
operator|(
name|sd
operator|->
name|sd_size
operator|/
literal|512
operator|)
operator|>>
literal|32
expr_stmt|;
name|pd
operator|->
name|pd_meta
index|[
name|j
index|]
operator|->
name|disk_sectors
operator|=
name|sd
operator|->
name|sd_size
operator|/
literal|512
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_REBUILD
condition|)
block|{
name|pd
operator|->
name|pd_meta
index|[
name|j
index|]
operator|->
name|disk_rebuild_high
operator|=
operator|(
name|sd
operator|->
name|sd_rebuild_pos
operator|/
literal|512
operator|)
operator|>>
literal|32
expr_stmt|;
name|pd
operator|->
name|pd_meta
index|[
name|j
index|]
operator|->
name|disk_rebuild
operator|=
name|sd
operator|->
name|sd_rebuild_pos
operator|/
literal|512
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|<
name|G_RAID_SUBDISK_S_REBUILD
condition|)
block|{
name|pd
operator|->
name|pd_meta
index|[
name|j
index|]
operator|->
name|disk_rebuild_high
operator|=
literal|0
expr_stmt|;
name|pd
operator|->
name|pd_meta
index|[
name|j
index|]
operator|->
name|disk_rebuild
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|pd
operator|->
name|pd_meta
index|[
name|j
index|]
operator|->
name|disk_rebuild_high
operator|=
name|UINT32_MAX
expr_stmt|;
name|pd
operator|->
name|pd_meta
index|[
name|j
index|]
operator|->
name|disk_rebuild
operator|=
name|UINT32_MAX
expr_stmt|;
block|}
name|pd
operator|->
name|pd_updated
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_promise_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_RAID_DISK_S_ACTIVE
condition|)
continue|continue;
if|if
condition|(
operator|!
name|pd
operator|->
name|pd_updated
condition|)
continue|continue;
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Writing Promise metadata to %s"
argument_list|,
name|g_raid_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pd
operator|->
name|pd_subdisks
condition|;
name|i
operator|++
control|)
name|g_raid_md_promise_print
argument_list|(
name|pd
operator|->
name|pd_meta
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|promise_meta_write
argument_list|(
name|disk
operator|->
name|d_consumer
argument_list|,
name|pd
operator|->
name|pd_meta
argument_list|,
name|pd
operator|->
name|pd_subdisks
argument_list|)
expr_stmt|;
name|pd
operator|->
name|pd_updated
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_fail_disk_promise
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|g_raid_subdisk
modifier|*
name|tsd
parameter_list|,
name|struct
name|g_raid_disk
modifier|*
name|tdisk
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_md_promise_perdisk
modifier|*
name|pd
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pos
decl_stmt|;
name|sc
operator|=
name|md
operator|->
name|mdo_softc
expr_stmt|;
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_promise_perdisk
operator|*
operator|)
name|tdisk
operator|->
name|d_md_data
expr_stmt|;
comment|/* We can't fail disk that is not a part of array now. */
if|if
condition|(
name|tdisk
operator|->
name|d_state
operator|!=
name|G_RAID_DISK_S_ACTIVE
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Mark disk as failed in metadata and try to write that metadata 	 * to the disk itself to prevent it's later resurrection as STALE. 	 */
if|if
condition|(
name|pd
operator|->
name|pd_subdisks
operator|>
literal|0
operator|&&
name|tdisk
operator|->
name|d_consumer
operator|!=
name|NULL
condition|)
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Writing Promise metadata to %s"
argument_list|,
name|g_raid_get_diskname
argument_list|(
name|tdisk
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pd
operator|->
name|pd_subdisks
condition|;
name|i
operator|++
control|)
block|{
name|pd
operator|->
name|pd_meta
index|[
name|i
index|]
operator|->
name|disk
operator|.
name|flags
operator||=
name|PROMISE_F_DOWN
operator||
name|PROMISE_F_REDIR
expr_stmt|;
name|pos
operator|=
name|pd
operator|->
name|pd_meta
index|[
name|i
index|]
operator|->
name|disk
operator|.
name|number
expr_stmt|;
if|if
condition|(
name|pos
operator|>=
literal|0
operator|&&
name|pos
operator|<
name|PROMISE_MAX_DISKS
condition|)
block|{
name|pd
operator|->
name|pd_meta
index|[
name|i
index|]
operator|->
name|disks
index|[
name|pos
index|]
operator|.
name|flags
operator||=
name|PROMISE_F_DOWN
operator||
name|PROMISE_F_REDIR
expr_stmt|;
block|}
name|g_raid_md_promise_print
argument_list|(
name|pd
operator|->
name|pd_meta
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tdisk
operator|->
name|d_consumer
operator|!=
name|NULL
condition|)
name|promise_meta_write
argument_list|(
name|tdisk
operator|->
name|d_consumer
argument_list|,
name|pd
operator|->
name|pd_meta
argument_list|,
name|pd
operator|->
name|pd_subdisks
argument_list|)
expr_stmt|;
comment|/* Change states. */
name|g_raid_change_disk_state
argument_list|(
name|tdisk
argument_list|,
name|G_RAID_DISK_S_FAILED
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sd
argument_list|,
argument|&tdisk->d_subdisks
argument_list|,
argument|sd_next
argument_list|)
block|{
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_FAILED
argument_list|)
expr_stmt|;
name|g_raid_event_send
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_E_FAILED
argument_list|,
name|G_RAID_EVENT_SUBDISK
argument_list|)
expr_stmt|;
block|}
comment|/* Write updated metadata to remaining disks. */
name|g_raid_md_write_promise
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|tdisk
argument_list|)
expr_stmt|;
name|g_raid_md_promise_refill
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_free_disk_promise
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|g_raid_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_raid_md_promise_perdisk
modifier|*
name|pd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_promise_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pd
operator|->
name|pd_subdisks
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pd
operator|->
name|pd_meta
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|pd
operator|->
name|pd_meta
index|[
name|i
index|]
argument_list|,
name|M_MD_PROMISE
argument_list|)
expr_stmt|;
name|pd
operator|->
name|pd_meta
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|pd
argument_list|,
name|M_MD_PROMISE
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_md_data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_free_volume_promise
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|g_raid_volume
modifier|*
name|vol
parameter_list|)
block|{
name|struct
name|g_raid_md_promise_pervolume
modifier|*
name|pv
decl_stmt|;
name|pv
operator|=
operator|(
expr|struct
name|g_raid_md_promise_pervolume
operator|*
operator|)
name|vol
operator|->
name|v_md_data
expr_stmt|;
if|if
condition|(
name|pv
operator|&&
name|pv
operator|->
name|pv_meta
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|pv
operator|->
name|pv_meta
argument_list|,
name|M_MD_PROMISE
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pv_meta
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pv
operator|&&
operator|!
name|pv
operator|->
name|pv_started
condition|)
block|{
name|pv
operator|->
name|pv_started
operator|=
literal|1
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|pv
operator|->
name|pv_start_co
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pv
argument_list|,
name|M_MD_PROMISE
argument_list|)
expr_stmt|;
name|vol
operator|->
name|v_md_data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_free_promise
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|G_RAID_MD_DECLARE
argument_list|(
name|promise
argument_list|,
literal|"Promise"
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

