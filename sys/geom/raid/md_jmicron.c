begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010 Alexander Motin<mav@FreeBSD.org>  * Copyright (c) 2000 - 2008 SÃ¸ren Schmidt<sos@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|"geom/raid/g_raid.h"
end_include

begin_include
include|#
directive|include
file|"g_raid_md_if.h"
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_MD_JMICRON
argument_list|,
literal|"md_jmicron_data"
argument_list|,
literal|"GEOM_RAID JMicron metadata"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|JMICRON_MAX_DISKS
value|8
end_define

begin_define
define|#
directive|define
name|JMICRON_MAX_SPARE
value|2
end_define

begin_struct
struct|struct
name|jmicron_raid_conf
block|{
name|u_int8_t
name|signature
index|[
literal|2
index|]
decl_stmt|;
define|#
directive|define
name|JMICRON_MAGIC
value|"JM"
name|u_int16_t
name|version
decl_stmt|;
define|#
directive|define
name|JMICRON_VERSION
value|0x0001
name|u_int16_t
name|checksum
decl_stmt|;
name|u_int8_t
name|filler_1
index|[
literal|10
index|]
decl_stmt|;
name|u_int32_t
name|disk_id
decl_stmt|;
name|u_int32_t
name|offset
decl_stmt|;
name|u_int32_t
name|disk_sectors_high
decl_stmt|;
name|u_int16_t
name|disk_sectors_low
decl_stmt|;
name|u_int8_t
name|filler_2
index|[
literal|2
index|]
decl_stmt|;
name|u_int8_t
name|name
index|[
literal|16
index|]
decl_stmt|;
name|u_int8_t
name|type
decl_stmt|;
define|#
directive|define
name|JMICRON_T_RAID0
value|0
define|#
directive|define
name|JMICRON_T_RAID1
value|1
define|#
directive|define
name|JMICRON_T_RAID01
value|2
define|#
directive|define
name|JMICRON_T_CONCAT
value|3
define|#
directive|define
name|JMICRON_T_RAID5
value|5
name|u_int8_t
name|stripe_shift
decl_stmt|;
name|u_int16_t
name|flags
decl_stmt|;
define|#
directive|define
name|JMICRON_F_READY
value|0x0001
define|#
directive|define
name|JMICRON_F_BOOTABLE
value|0x0002
define|#
directive|define
name|JMICRON_F_BADSEC
value|0x0004
define|#
directive|define
name|JMICRON_F_ACTIVE
value|0x0010
define|#
directive|define
name|JMICRON_F_UNSYNC
value|0x0020
define|#
directive|define
name|JMICRON_F_NEWEST
value|0x0040
name|u_int8_t
name|filler_3
index|[
literal|4
index|]
decl_stmt|;
name|u_int32_t
name|spare
index|[
name|JMICRON_MAX_SPARE
index|]
decl_stmt|;
name|u_int32_t
name|disks
index|[
name|JMICRON_MAX_DISKS
index|]
decl_stmt|;
define|#
directive|define
name|JMICRON_DISK_MASK
value|0xFFFFFFF0
define|#
directive|define
name|JMICRON_SEG_MASK
value|0x0000000F
name|u_int8_t
name|filler_4
index|[
literal|32
index|]
decl_stmt|;
name|u_int8_t
name|filler_5
index|[
literal|384
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|g_raid_md_jmicron_perdisk
block|{
name|struct
name|jmicron_raid_conf
modifier|*
name|pd_meta
decl_stmt|;
name|int
name|pd_disk_pos
decl_stmt|;
name|int
name|pd_disk_id
decl_stmt|;
name|off_t
name|pd_disk_size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|g_raid_md_jmicron_object
block|{
name|struct
name|g_raid_md_object
name|mdio_base
decl_stmt|;
name|uint32_t
name|mdio_config_id
decl_stmt|;
name|struct
name|jmicron_raid_conf
modifier|*
name|mdio_meta
decl_stmt|;
name|struct
name|callout
name|mdio_start_co
decl_stmt|;
comment|/* STARTING state timer. */
name|int
name|mdio_total_disks
decl_stmt|;
name|int
name|mdio_disks_present
decl_stmt|;
name|int
name|mdio_started
decl_stmt|;
name|int
name|mdio_incomplete
decl_stmt|;
name|struct
name|root_hold_token
modifier|*
name|mdio_rootmount
decl_stmt|;
comment|/* Root mount delay token. */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|g_raid_md_create_t
name|g_raid_md_create_jmicron
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_taste_t
name|g_raid_md_taste_jmicron
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_event_t
name|g_raid_md_event_jmicron
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_ctl_t
name|g_raid_md_ctl_jmicron
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_write_t
name|g_raid_md_write_jmicron
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_fail_disk_t
name|g_raid_md_fail_disk_jmicron
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_free_disk_t
name|g_raid_md_free_disk_jmicron
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|g_raid_md_free_t
name|g_raid_md_free_jmicron
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kobj_method_t
name|g_raid_md_jmicron_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|g_raid_md_create
argument_list|,
name|g_raid_md_create_jmicron
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_taste
argument_list|,
name|g_raid_md_taste_jmicron
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_event
argument_list|,
name|g_raid_md_event_jmicron
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_ctl
argument_list|,
name|g_raid_md_ctl_jmicron
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_write
argument_list|,
name|g_raid_md_write_jmicron
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_fail_disk
argument_list|,
name|g_raid_md_fail_disk_jmicron
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_free_disk
argument_list|,
name|g_raid_md_free_disk_jmicron
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|g_raid_md_free
argument_list|,
name|g_raid_md_free_jmicron
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|g_raid_md_class
name|g_raid_md_jmicron_class
init|=
block|{
literal|"JMicron"
block|,
name|g_raid_md_jmicron_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|g_raid_md_jmicron_object
argument_list|)
block|,
operator|.
name|mdc_enable
operator|=
literal|1
block|,
operator|.
name|mdc_priority
operator|=
literal|100
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|g_raid_md_jmicron_print
parameter_list|(
name|struct
name|jmicron_raid_conf
modifier|*
name|meta
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
if|if
condition|(
name|g_raid_debug
operator|<
literal|1
condition|)
return|return;
name|printf
argument_list|(
literal|"********* ATA JMicron RAID Metadata *********\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"signature<%c%c>\n"
argument_list|,
name|meta
operator|->
name|signature
index|[
literal|0
index|]
argument_list|,
name|meta
operator|->
name|signature
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"version             %04x\n"
argument_list|,
name|meta
operator|->
name|version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"checksum            0x%04x\n"
argument_list|,
name|meta
operator|->
name|checksum
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"disk_id             0x%08x\n"
argument_list|,
name|meta
operator|->
name|disk_id
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"offset              0x%08x\n"
argument_list|,
name|meta
operator|->
name|offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"disk_sectors_high   0x%08x\n"
argument_list|,
name|meta
operator|->
name|disk_sectors_high
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"disk_sectors_low    0x%04x\n"
argument_list|,
name|meta
operator|->
name|disk_sectors_low
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"name<%.16s>\n"
argument_list|,
name|meta
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"type                %d\n"
argument_list|,
name|meta
operator|->
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"stripe_shift        %d\n"
argument_list|,
name|meta
operator|->
name|stripe_shift
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"flags               %04x\n"
argument_list|,
name|meta
operator|->
name|flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"spare              "
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|JMICRON_MAX_SPARE
condition|;
name|k
operator|++
control|)
name|printf
argument_list|(
literal|" 0x%08x"
argument_list|,
name|meta
operator|->
name|spare
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"disks              "
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|JMICRON_MAX_DISKS
condition|;
name|k
operator|++
control|)
name|printf
argument_list|(
literal|" 0x%08x"
argument_list|,
name|meta
operator|->
name|disks
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"=================================================\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|jmicron_raid_conf
modifier|*
name|jmicron_meta_copy
parameter_list|(
name|struct
name|jmicron_raid_conf
modifier|*
name|meta
parameter_list|)
block|{
name|struct
name|jmicron_raid_conf
modifier|*
name|nmeta
decl_stmt|;
name|nmeta
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|meta
argument_list|)
argument_list|,
name|M_MD_JMICRON
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nmeta
argument_list|,
name|meta
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|meta
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|nmeta
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|jmicron_meta_total_disks
parameter_list|(
name|struct
name|jmicron_raid_conf
modifier|*
name|meta
parameter_list|)
block|{
name|int
name|pos
decl_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|JMICRON_MAX_DISKS
condition|;
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|meta
operator|->
name|disks
index|[
name|pos
index|]
operator|==
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|pos
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|jmicron_meta_total_spare
parameter_list|(
name|struct
name|jmicron_raid_conf
modifier|*
name|meta
parameter_list|)
block|{
name|int
name|pos
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|JMICRON_MAX_SPARE
condition|;
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|meta
operator|->
name|spare
index|[
name|pos
index|]
operator|!=
literal|0
condition|)
name|n
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate fake Configuration ID based on disk IDs.  * Note: it will change after each disk set change.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|jmicron_meta_config_id
parameter_list|(
name|struct
name|jmicron_raid_conf
modifier|*
name|meta
parameter_list|)
block|{
name|int
name|pos
decl_stmt|;
name|uint32_t
name|config_id
decl_stmt|;
name|config_id
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|JMICRON_MAX_DISKS
condition|;
name|pos
operator|++
control|)
name|config_id
operator|+=
name|meta
operator|->
name|disks
index|[
name|pos
index|]
operator|<<
name|pos
expr_stmt|;
return|return
operator|(
name|config_id
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|jmicron_meta_get_name
parameter_list|(
name|struct
name|jmicron_raid_conf
modifier|*
name|meta
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|meta
operator|->
name|name
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|buf
index|[
literal|16
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|15
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|>
literal|0x20
condition|)
break|break;
name|buf
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|jmicron_meta_put_name
parameter_list|(
name|struct
name|jmicron_raid_conf
modifier|*
name|meta
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|memset
argument_list|(
name|meta
operator|->
name|name
argument_list|,
literal|0x20
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|meta
operator|->
name|name
argument_list|,
name|buf
argument_list|,
name|MIN
argument_list|(
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|jmicron_meta_find_disk
parameter_list|(
name|struct
name|jmicron_raid_conf
modifier|*
name|meta
parameter_list|,
name|uint32_t
name|id
parameter_list|)
block|{
name|int
name|pos
decl_stmt|;
name|id
operator|&=
name|JMICRON_DISK_MASK
expr_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|JMICRON_MAX_DISKS
condition|;
name|pos
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|meta
operator|->
name|disks
index|[
name|pos
index|]
operator|&
name|JMICRON_DISK_MASK
operator|)
operator|==
name|id
condition|)
return|return
operator|(
name|pos
operator|)
return|;
block|}
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|JMICRON_MAX_SPARE
condition|;
name|pos
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|meta
operator|->
name|spare
index|[
name|pos
index|]
operator|&
name|JMICRON_DISK_MASK
operator|)
operator|==
name|id
condition|)
return|return
operator|(
operator|-
literal|3
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|jmicron_raid_conf
modifier|*
name|jmicron_meta_read
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|jmicron_raid_conf
modifier|*
name|meta
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|uint16_t
name|checksum
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
comment|/* Read the anchor sector. */
name|buf
operator|=
name|g_read_data
argument_list|(
name|cp
argument_list|,
name|pp
operator|->
name|mediasize
operator|-
name|pp
operator|->
name|sectorsize
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Cannot read metadata from %s (error=%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|meta
operator|=
operator|(
expr|struct
name|jmicron_raid_conf
operator|*
operator|)
name|buf
expr_stmt|;
comment|/* Check if this is an JMicron RAID struct */
if|if
condition|(
name|strncmp
argument_list|(
name|meta
operator|->
name|signature
argument_list|,
name|JMICRON_MAGIC
argument_list|,
name|strlen
argument_list|(
name|JMICRON_MAGIC
argument_list|)
argument_list|)
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"JMicron signature check failed on %s"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|meta
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|meta
argument_list|)
argument_list|,
name|M_MD_JMICRON
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|meta
argument_list|,
name|buf
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|meta
argument_list|)
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|)
argument_list|)
expr_stmt|;
name|g_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Check metadata checksum. */
for|for
control|(
name|checksum
operator|=
literal|0
operator|,
name|ptr
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|meta
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|checksum
operator|+=
operator|*
name|ptr
operator|++
expr_stmt|;
if|if
condition|(
name|checksum
operator|!=
literal|0
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"JMicron checksum check failed on %s"
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|meta
argument_list|,
name|M_MD_JMICRON
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|meta
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|jmicron_meta_write
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|jmicron_raid_conf
modifier|*
name|meta
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|uint16_t
name|checksum
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
comment|/* Recalculate checksum for case if metadata were changed. */
name|meta
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|checksum
operator|=
literal|0
operator|,
name|ptr
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|meta
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|checksum
operator|+=
operator|*
name|ptr
operator|++
expr_stmt|;
name|meta
operator|->
name|checksum
operator|-=
name|checksum
expr_stmt|;
comment|/* Create and fill buffer. */
name|buf
operator|=
name|malloc
argument_list|(
name|pp
operator|->
name|sectorsize
argument_list|,
name|M_MD_JMICRON
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|meta
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|meta
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_write_data
argument_list|(
name|cp
argument_list|,
name|pp
operator|->
name|mediasize
operator|-
name|pp
operator|->
name|sectorsize
argument_list|,
name|buf
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Cannot write metadata to %s (error=%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|,
name|M_MD_JMICRON
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|jmicron_meta_erase
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|pp
operator|->
name|sectorsize
argument_list|,
name|M_MD_JMICRON
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_write_data
argument_list|(
name|cp
argument_list|,
name|pp
operator|->
name|mediasize
operator|-
name|pp
operator|->
name|sectorsize
argument_list|,
name|buf
argument_list|,
name|pp
operator|->
name|sectorsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Cannot erase metadata on %s (error=%d)."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|,
name|M_MD_JMICRON
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|g_raid_disk
modifier|*
name|g_raid_md_jmicron_get_disk
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_raid_md_jmicron_perdisk
modifier|*
name|pd
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|pd_disk_pos
operator|==
name|id
condition|)
break|break;
block|}
return|return
operator|(
name|disk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_jmicron_supported
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|qual
parameter_list|,
name|int
name|disks
parameter_list|,
name|int
name|force
parameter_list|)
block|{
if|if
condition|(
name|disks
operator|>
literal|8
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|level
condition|)
block|{
case|case
name|G_RAID_VOLUME_RL_RAID0
case|:
if|if
condition|(
name|disks
operator|<
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|force
operator|&&
operator|(
name|disks
operator|<
literal|2
operator|||
name|disks
operator|>
literal|6
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|G_RAID_VOLUME_RL_RAID1
case|:
if|if
condition|(
name|disks
operator|<
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|force
operator|&&
operator|(
name|disks
operator|!=
literal|2
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|G_RAID_VOLUME_RL_RAID1E
case|:
if|if
condition|(
name|disks
operator|<
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|force
operator|&&
operator|(
name|disks
operator|!=
literal|4
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|G_RAID_VOLUME_RL_SINGLE
case|:
if|if
condition|(
name|disks
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|force
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|G_RAID_VOLUME_RL_CONCAT
case|:
if|if
condition|(
name|disks
operator|<
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|G_RAID_VOLUME_RL_RAID5
case|:
if|if
condition|(
name|disks
operator|<
literal|3
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|qual
operator|!=
name|G_RAID_VOLUME_RLQ_R5LA
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|force
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|level
operator|!=
name|G_RAID_VOLUME_RL_RAID5
operator|&&
name|qual
operator|!=
name|G_RAID_VOLUME_RLQ_NONE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_jmicron_start_disk
parameter_list|(
name|struct
name|g_raid_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|,
modifier|*
name|tmpsd
decl_stmt|;
name|struct
name|g_raid_disk
modifier|*
name|olddisk
decl_stmt|,
modifier|*
name|tmpdisk
decl_stmt|;
name|struct
name|g_raid_md_object
modifier|*
name|md
decl_stmt|;
name|struct
name|g_raid_md_jmicron_object
modifier|*
name|mdi
decl_stmt|;
name|struct
name|g_raid_md_jmicron_perdisk
modifier|*
name|pd
decl_stmt|,
modifier|*
name|oldpd
decl_stmt|;
name|struct
name|jmicron_raid_conf
modifier|*
name|meta
decl_stmt|;
name|int
name|disk_pos
decl_stmt|,
name|resurrection
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|md
operator|=
name|sc
operator|->
name|sc_md
expr_stmt|;
name|mdi
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_object
operator|*
operator|)
name|md
expr_stmt|;
name|meta
operator|=
name|mdi
operator|->
name|mdio_meta
expr_stmt|;
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
name|olddisk
operator|=
name|NULL
expr_stmt|;
comment|/* Find disk position in metadata by its serial. */
if|if
condition|(
name|pd
operator|->
name|pd_meta
operator|!=
name|NULL
condition|)
name|disk_pos
operator|=
name|jmicron_meta_find_disk
argument_list|(
name|meta
argument_list|,
name|pd
operator|->
name|pd_disk_id
argument_list|)
expr_stmt|;
else|else
name|disk_pos
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|disk_pos
operator|<
literal|0
condition|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"Unknown, probably new or stale disk"
argument_list|)
expr_stmt|;
comment|/* If we are in the start process, that's all for now. */
if|if
condition|(
operator|!
name|mdi
operator|->
name|mdio_started
condition|)
goto|goto
name|nofit
goto|;
comment|/* 		 * If we have already started - try to get use of the disk. 		 * Try to replace OFFLINE disks first, then FAILED. 		 */
name|TAILQ_FOREACH
argument_list|(
argument|tmpdisk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|tmpdisk
operator|->
name|d_state
operator|!=
name|G_RAID_DISK_S_OFFLINE
operator|&&
name|tmpdisk
operator|->
name|d_state
operator|!=
name|G_RAID_DISK_S_FAILED
condition|)
continue|continue;
comment|/* Make sure this disk is big enough. */
name|TAILQ_FOREACH
argument_list|(
argument|sd
argument_list|,
argument|&tmpdisk->d_subdisks
argument_list|,
argument|sd_next
argument_list|)
block|{
if|if
condition|(
name|sd
operator|->
name|sd_offset
operator|+
name|sd
operator|->
name|sd_size
operator|+
literal|512
operator|>
name|pd
operator|->
name|pd_disk_size
condition|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"Disk too small (%ju< %ju)"
argument_list|,
name|pd
operator|->
name|pd_disk_size
argument_list|,
name|sd
operator|->
name|sd_offset
operator|+
name|sd
operator|->
name|sd_size
operator|+
literal|512
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|sd
operator|!=
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|tmpdisk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_OFFLINE
condition|)
block|{
name|olddisk
operator|=
name|tmpdisk
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|olddisk
operator|==
name|NULL
condition|)
name|olddisk
operator|=
name|tmpdisk
expr_stmt|;
block|}
if|if
condition|(
name|olddisk
operator|==
name|NULL
condition|)
block|{
name|nofit
label|:
if|if
condition|(
name|disk_pos
operator|==
operator|-
literal|3
operator|||
name|pd
operator|->
name|pd_disk_pos
operator|==
operator|-
literal|3
condition|)
block|{
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_SPARE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_STALE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|oldpd
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_perdisk
operator|*
operator|)
name|olddisk
operator|->
name|d_md_data
expr_stmt|;
name|disk_pos
operator|=
name|oldpd
operator|->
name|pd_disk_pos
expr_stmt|;
name|resurrection
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|olddisk
operator|==
name|NULL
condition|)
block|{
comment|/* Find placeholder by position. */
name|olddisk
operator|=
name|g_raid_md_jmicron_get_disk
argument_list|(
name|sc
argument_list|,
name|disk_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|olddisk
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"No disk at position %d!"
argument_list|,
name|disk_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|olddisk
operator|->
name|d_state
operator|!=
name|G_RAID_DISK_S_OFFLINE
condition|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"More than one disk for pos %d"
argument_list|,
name|disk_pos
argument_list|)
expr_stmt|;
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_STALE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|oldpd
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_perdisk
operator|*
operator|)
name|olddisk
operator|->
name|d_md_data
expr_stmt|;
block|}
comment|/* Replace failed disk or placeholder with new disk. */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|sd
argument_list|,
argument|&olddisk->d_subdisks
argument_list|,
argument|sd_next
argument_list|,
argument|tmpsd
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|olddisk
operator|->
name|d_subdisks
argument_list|,
name|sd
argument_list|,
name|sd_next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|disk
operator|->
name|d_subdisks
argument_list|,
name|sd
argument_list|,
name|sd_next
argument_list|)
expr_stmt|;
name|sd
operator|->
name|sd_disk
operator|=
name|disk
expr_stmt|;
block|}
name|oldpd
operator|->
name|pd_disk_pos
operator|=
operator|-
literal|2
expr_stmt|;
name|pd
operator|->
name|pd_disk_pos
operator|=
name|disk_pos
expr_stmt|;
comment|/* Update global metadata just in case. */
name|meta
operator|->
name|disks
index|[
name|disk_pos
index|]
operator|=
name|pd
operator|->
name|pd_disk_id
expr_stmt|;
comment|/* If it was placeholder -- destroy it. */
if|if
condition|(
name|olddisk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_OFFLINE
condition|)
block|{
name|g_raid_destroy_disk
argument_list|(
name|olddisk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, make it STALE_FAILED. */
name|g_raid_change_disk_state
argument_list|(
name|olddisk
argument_list|,
name|G_RAID_DISK_S_STALE_FAILED
argument_list|)
expr_stmt|;
block|}
comment|/* Welcome the new disk. */
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_ACTIVE
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sd
argument_list|,
argument|&disk->d_subdisks
argument_list|,
argument|sd_next
argument_list|)
block|{
comment|/* 		 * Different disks may have different sizes/offsets, 		 * especially in concat mode. Update. 		 */
if|if
condition|(
operator|!
name|resurrection
condition|)
block|{
name|sd
operator|->
name|sd_offset
operator|=
operator|(
name|off_t
operator|)
name|pd
operator|->
name|pd_meta
operator|->
name|offset
operator|*
literal|16
operator|*
literal|512
expr_stmt|;
comment|//ZZZ
name|sd
operator|->
name|sd_size
operator|=
operator|(
operator|(
operator|(
name|off_t
operator|)
name|pd
operator|->
name|pd_meta
operator|->
name|disk_sectors_high
operator|<<
literal|16
operator|)
operator|+
name|pd
operator|->
name|pd_meta
operator|->
name|disk_sectors_low
operator|)
operator|*
literal|512
expr_stmt|;
block|}
if|if
condition|(
name|resurrection
condition|)
block|{
comment|/* Stale disk, almost same as new. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_NEW
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|meta
operator|->
name|flags
operator|&
name|JMICRON_F_BADSEC
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|pd
operator|->
name|pd_meta
operator|->
name|flags
operator|&
name|JMICRON_F_BADSEC
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Cold-inserted or rebuilding disk. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_NEW
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pd
operator|->
name|pd_meta
operator|->
name|flags
operator|&
name|JMICRON_F_UNSYNC
condition|)
block|{
comment|/* Dirty or resyncing disk.. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_STALE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Up to date disk. */
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_ACTIVE
argument_list|)
expr_stmt|;
block|}
name|g_raid_event_send
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_E_NEW
argument_list|,
name|G_RAID_EVENT_SUBDISK
argument_list|)
expr_stmt|;
block|}
comment|/* Update status of our need for spare. */
if|if
condition|(
name|mdi
operator|->
name|mdio_started
condition|)
block|{
name|mdi
operator|->
name|mdio_incomplete
operator|=
operator|(
name|g_raid_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID_DISK_S_ACTIVE
argument_list|)
operator|<
name|mdi
operator|->
name|mdio_total_disks
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|resurrection
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_disk_md_jmicron_retaste
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Array is not complete, trying to retaste."
argument_list|)
expr_stmt|;
name|g_retaste
argument_list|(
operator|&
name|g_raid_class
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|arg
argument_list|,
name|M_MD_JMICRON
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_md_jmicron_refill
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_raid_md_object
modifier|*
name|md
decl_stmt|;
name|struct
name|g_raid_md_jmicron_object
modifier|*
name|mdi
decl_stmt|;
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|task
modifier|*
name|task
decl_stmt|;
name|int
name|update
decl_stmt|,
name|na
decl_stmt|;
name|md
operator|=
name|sc
operator|->
name|sc_md
expr_stmt|;
name|mdi
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_object
operator|*
operator|)
name|md
expr_stmt|;
name|update
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* Make sure we miss anything. */
name|na
operator|=
name|g_raid_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID_DISK_S_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|na
operator|==
name|mdi
operator|->
name|mdio_total_disks
condition|)
break|break;
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|md
operator|->
name|mdo_softc
argument_list|,
literal|"Array is not complete (%d of %d), "
literal|"trying to refill."
argument_list|,
name|na
argument_list|,
name|mdi
operator|->
name|mdio_total_disks
argument_list|)
expr_stmt|;
comment|/* Try to get use some of STALE disks. */
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_STALE
condition|)
block|{
name|update
operator|+=
name|g_raid_md_jmicron_start_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_ACTIVE
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|disk
operator|!=
name|NULL
condition|)
continue|continue;
comment|/* Try to get use some of SPARE disks. */
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_SPARE
condition|)
block|{
name|update
operator|+=
name|g_raid_md_jmicron_start_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_ACTIVE
condition|)
break|break;
block|}
block|}
block|}
do|while
condition|(
name|disk
operator|!=
name|NULL
condition|)
do|;
comment|/* Write new metadata if we changed something. */
if|if
condition|(
name|update
condition|)
name|g_raid_md_write_jmicron
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Update status of our need for spare. */
name|mdi
operator|->
name|mdio_incomplete
operator|=
operator|(
name|g_raid_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID_DISK_S_ACTIVE
argument_list|)
operator|<
name|mdi
operator|->
name|mdio_total_disks
operator|)
expr_stmt|;
comment|/* Request retaste hoping to find spare. */
if|if
condition|(
name|mdi
operator|->
name|mdio_incomplete
condition|)
block|{
name|task
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|task
argument_list|)
argument_list|,
name|M_MD_JMICRON
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
name|task
argument_list|,
literal|0
argument_list|,
name|g_disk_md_jmicron_retaste
argument_list|,
name|task
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
name|task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_md_jmicron_start
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_raid_md_object
modifier|*
name|md
decl_stmt|;
name|struct
name|g_raid_md_jmicron_object
modifier|*
name|mdi
decl_stmt|;
name|struct
name|g_raid_md_jmicron_perdisk
modifier|*
name|pd
decl_stmt|;
name|struct
name|jmicron_raid_conf
modifier|*
name|meta
decl_stmt|;
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|;
name|off_t
name|size
decl_stmt|;
name|int
name|j
decl_stmt|,
name|disk_pos
decl_stmt|;
name|char
name|buf
index|[
literal|17
index|]
decl_stmt|;
name|md
operator|=
name|sc
operator|->
name|sc_md
expr_stmt|;
name|mdi
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_object
operator|*
operator|)
name|md
expr_stmt|;
name|meta
operator|=
name|mdi
operator|->
name|mdio_meta
expr_stmt|;
comment|/* Create volumes and subdisks. */
name|jmicron_meta_get_name
argument_list|(
name|meta
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|vol
operator|=
name|g_raid_create_volume
argument_list|(
name|sc
argument_list|,
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
operator|(
name|off_t
operator|)
name|meta
operator|->
name|disk_sectors_high
operator|<<
literal|16
operator|)
operator|+
name|meta
operator|->
name|disk_sectors_low
expr_stmt|;
name|size
operator|*=
literal|512
expr_stmt|;
comment|//ZZZ
name|vol
operator|->
name|v_raid_level_qualifier
operator|=
name|G_RAID_VOLUME_RLQ_NONE
expr_stmt|;
if|if
condition|(
name|meta
operator|->
name|type
operator|==
name|JMICRON_T_RAID0
condition|)
block|{
name|vol
operator|->
name|v_raid_level
operator|=
name|G_RAID_VOLUME_RL_RAID0
expr_stmt|;
name|vol
operator|->
name|v_mediasize
operator|=
name|size
operator|*
name|mdi
operator|->
name|mdio_total_disks
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|meta
operator|->
name|type
operator|==
name|JMICRON_T_RAID1
condition|)
block|{
name|vol
operator|->
name|v_raid_level
operator|=
name|G_RAID_VOLUME_RL_RAID1
expr_stmt|;
name|vol
operator|->
name|v_mediasize
operator|=
name|size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|meta
operator|->
name|type
operator|==
name|JMICRON_T_RAID01
condition|)
block|{
name|vol
operator|->
name|v_raid_level
operator|=
name|G_RAID_VOLUME_RL_RAID1E
expr_stmt|;
name|vol
operator|->
name|v_mediasize
operator|=
name|size
operator|*
name|mdi
operator|->
name|mdio_total_disks
operator|/
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|meta
operator|->
name|type
operator|==
name|JMICRON_T_CONCAT
condition|)
block|{
if|if
condition|(
name|mdi
operator|->
name|mdio_total_disks
operator|==
literal|1
condition|)
name|vol
operator|->
name|v_raid_level
operator|=
name|G_RAID_VOLUME_RL_SINGLE
expr_stmt|;
else|else
name|vol
operator|->
name|v_raid_level
operator|=
name|G_RAID_VOLUME_RL_CONCAT
expr_stmt|;
name|vol
operator|->
name|v_mediasize
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|meta
operator|->
name|type
operator|==
name|JMICRON_T_RAID5
condition|)
block|{
name|vol
operator|->
name|v_raid_level
operator|=
name|G_RAID_VOLUME_RL_RAID5
expr_stmt|;
name|vol
operator|->
name|v_raid_level_qualifier
operator|=
name|G_RAID_VOLUME_RLQ_R5LA
expr_stmt|;
name|vol
operator|->
name|v_mediasize
operator|=
name|size
operator|*
operator|(
name|mdi
operator|->
name|mdio_total_disks
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|vol
operator|->
name|v_raid_level
operator|=
name|G_RAID_VOLUME_RL_UNKNOWN
expr_stmt|;
name|vol
operator|->
name|v_mediasize
operator|=
literal|0
expr_stmt|;
block|}
name|vol
operator|->
name|v_strip_size
operator|=
literal|1024
operator|<<
name|meta
operator|->
name|stripe_shift
expr_stmt|;
comment|//ZZZ
name|vol
operator|->
name|v_disks_count
operator|=
name|mdi
operator|->
name|mdio_total_disks
expr_stmt|;
name|vol
operator|->
name|v_sectorsize
operator|=
literal|512
expr_stmt|;
comment|//ZZZ
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|vol
operator|->
name|v_disks_count
condition|;
name|j
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|j
index|]
expr_stmt|;
name|sd
operator|->
name|sd_offset
operator|=
operator|(
name|off_t
operator|)
name|meta
operator|->
name|offset
operator|*
literal|16
operator|*
literal|512
expr_stmt|;
comment|//ZZZ
name|sd
operator|->
name|sd_size
operator|=
name|size
expr_stmt|;
block|}
name|g_raid_start_volume
argument_list|(
name|vol
argument_list|)
expr_stmt|;
comment|/* Create disk placeholders to store data for later writing. */
for|for
control|(
name|disk_pos
operator|=
literal|0
init|;
name|disk_pos
operator|<
name|mdi
operator|->
name|mdio_total_disks
condition|;
name|disk_pos
operator|++
control|)
block|{
name|pd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pd
argument_list|)
argument_list|,
name|M_MD_JMICRON
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pd
operator|->
name|pd_disk_pos
operator|=
name|disk_pos
expr_stmt|;
name|pd
operator|->
name|pd_disk_id
operator|=
name|meta
operator|->
name|disks
index|[
name|disk_pos
index|]
expr_stmt|;
name|disk
operator|=
name|g_raid_create_disk
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_md_data
operator|=
operator|(
name|void
operator|*
operator|)
name|pd
expr_stmt|;
name|disk
operator|->
name|d_state
operator|=
name|G_RAID_DISK_S_OFFLINE
expr_stmt|;
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|disk_pos
index|]
expr_stmt|;
name|sd
operator|->
name|sd_disk
operator|=
name|disk
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|disk
operator|->
name|d_subdisks
argument_list|,
name|sd
argument_list|,
name|sd_next
argument_list|)
expr_stmt|;
block|}
comment|/* Make all disks found till the moment take their places. */
do|do
block|{
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_NONE
condition|)
block|{
name|g_raid_md_jmicron_start_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|disk
operator|!=
name|NULL
condition|)
do|;
name|mdi
operator|->
name|mdio_started
operator|=
literal|1
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|0
argument_list|,
name|sc
argument_list|,
literal|"Array started."
argument_list|)
expr_stmt|;
name|g_raid_md_write_jmicron
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Pickup any STALE/SPARE disks to refill array if needed. */
name|g_raid_md_jmicron_refill
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|g_raid_event_send
argument_list|(
name|vol
argument_list|,
name|G_RAID_VOLUME_E_START
argument_list|,
name|G_RAID_EVENT_VOLUME
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|mdi
operator|->
name|mdio_start_co
argument_list|)
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"root_mount_rel %p"
argument_list|,
name|mdi
operator|->
name|mdio_rootmount
argument_list|)
expr_stmt|;
name|root_mount_rel
argument_list|(
name|mdi
operator|->
name|mdio_rootmount
argument_list|)
expr_stmt|;
name|mdi
operator|->
name|mdio_rootmount
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_md_jmicron_new_disk
parameter_list|(
name|struct
name|g_raid_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_md_object
modifier|*
name|md
decl_stmt|;
name|struct
name|g_raid_md_jmicron_object
modifier|*
name|mdi
decl_stmt|;
name|struct
name|jmicron_raid_conf
modifier|*
name|pdmeta
decl_stmt|;
name|struct
name|g_raid_md_jmicron_perdisk
modifier|*
name|pd
decl_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|md
operator|=
name|sc
operator|->
name|sc_md
expr_stmt|;
name|mdi
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_object
operator|*
operator|)
name|md
expr_stmt|;
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
name|pdmeta
operator|=
name|pd
operator|->
name|pd_meta
expr_stmt|;
if|if
condition|(
name|mdi
operator|->
name|mdio_started
condition|)
block|{
if|if
condition|(
name|g_raid_md_jmicron_start_disk
argument_list|(
name|disk
argument_list|)
condition|)
name|g_raid_md_write_jmicron
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If we haven't started yet - update common metadata 		 * to get subdisks details, avoiding data from spare disks. 		 */
if|if
condition|(
name|mdi
operator|->
name|mdio_meta
operator|==
name|NULL
operator|||
name|jmicron_meta_find_disk
argument_list|(
name|mdi
operator|->
name|mdio_meta
argument_list|,
name|mdi
operator|->
name|mdio_meta
operator|->
name|disk_id
argument_list|)
operator|==
operator|-
literal|3
condition|)
block|{
if|if
condition|(
name|mdi
operator|->
name|mdio_meta
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|mdi
operator|->
name|mdio_meta
argument_list|,
name|M_MD_JMICRON
argument_list|)
expr_stmt|;
name|mdi
operator|->
name|mdio_meta
operator|=
name|jmicron_meta_copy
argument_list|(
name|pdmeta
argument_list|)
expr_stmt|;
name|mdi
operator|->
name|mdio_total_disks
operator|=
name|jmicron_meta_total_disks
argument_list|(
name|pdmeta
argument_list|)
expr_stmt|;
block|}
name|mdi
operator|->
name|mdio_meta
operator|->
name|flags
operator||=
name|pdmeta
operator|->
name|flags
operator|&
name|JMICRON_F_BADSEC
expr_stmt|;
name|mdi
operator|->
name|mdio_disks_present
operator|++
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"Matching disk (%d of %d+%d up)"
argument_list|,
name|mdi
operator|->
name|mdio_disks_present
argument_list|,
name|mdi
operator|->
name|mdio_total_disks
argument_list|,
name|jmicron_meta_total_spare
argument_list|(
name|mdi
operator|->
name|mdio_meta
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we collected all needed disks - start array. */
if|if
condition|(
name|mdi
operator|->
name|mdio_disks_present
operator|==
name|mdi
operator|->
name|mdio_total_disks
operator|+
name|jmicron_meta_total_spare
argument_list|(
name|mdi
operator|->
name|mdio_meta
argument_list|)
condition|)
name|g_raid_md_jmicron_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_jmicron_go
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_md_object
modifier|*
name|md
decl_stmt|;
name|struct
name|g_raid_md_jmicron_object
modifier|*
name|mdi
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|md
operator|=
name|sc
operator|->
name|sc_md
expr_stmt|;
name|mdi
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_object
operator|*
operator|)
name|md
expr_stmt|;
if|if
condition|(
operator|!
name|mdi
operator|->
name|mdio_started
condition|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|0
argument_list|,
name|sc
argument_list|,
literal|"Force array start due to timeout."
argument_list|)
expr_stmt|;
name|g_raid_event_send
argument_list|(
name|sc
argument_list|,
name|G_RAID_NODE_E_START
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_create_jmicron
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_geom
modifier|*
modifier|*
name|gp
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_md_jmicron_object
modifier|*
name|mdi
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|mdi
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_object
operator|*
operator|)
name|md
expr_stmt|;
name|mdi
operator|->
name|mdio_config_id
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"JMicron-%08x"
argument_list|,
name|mdi
operator|->
name|mdio_config_id
argument_list|)
expr_stmt|;
name|sc
operator|=
name|g_raid_create_node
argument_list|(
name|mp
argument_list|,
name|name
argument_list|,
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|G_RAID_MD_TASTE_FAIL
operator|)
return|;
name|md
operator|->
name|mdo_softc
operator|=
name|sc
expr_stmt|;
operator|*
name|gp
operator|=
name|sc
operator|->
name|sc_geom
expr_stmt|;
return|return
operator|(
name|G_RAID_MD_TASTE_NEW
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_taste_jmicron
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_geom
modifier|*
modifier|*
name|gp
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|rcp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_raid_md_jmicron_object
modifier|*
name|mdi
decl_stmt|,
modifier|*
name|mdi1
decl_stmt|;
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|jmicron_raid_conf
modifier|*
name|meta
decl_stmt|;
name|struct
name|g_raid_md_jmicron_perdisk
modifier|*
name|pd
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|geom
decl_stmt|;
name|int
name|disk_pos
decl_stmt|,
name|result
decl_stmt|,
name|spare
decl_stmt|,
name|len
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|uint16_t
name|vendor
decl_stmt|;
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Tasting JMicron on %s"
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
name|mdi
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_object
operator|*
operator|)
name|md
expr_stmt|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
comment|/* Read metadata from device. */
name|meta
operator|=
name|NULL
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|vendor
operator|=
literal|0xffff
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|vendor
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|geom
operator|->
name|rank
operator|==
literal|1
condition|)
name|g_io_getattr
argument_list|(
literal|"GEOM::hba_vendor"
argument_list|,
name|cp
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|vendor
argument_list|)
expr_stmt|;
name|meta
operator|=
name|jmicron_meta_read
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
if|if
condition|(
name|meta
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|g_raid_aggressive_spare
condition|)
block|{
if|if
condition|(
name|vendor
operator|==
literal|0x197b
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"No JMicron metadata, forcing spare."
argument_list|)
expr_stmt|;
name|spare
operator|=
literal|2
expr_stmt|;
goto|goto
name|search
goto|;
block|}
else|else
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"JMicron vendor mismatch 0x%04x != 0x197b"
argument_list|,
name|vendor
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|G_RAID_MD_TASTE_FAIL
operator|)
return|;
block|}
comment|/* Check this disk position in obtained metadata. */
name|disk_pos
operator|=
name|jmicron_meta_find_disk
argument_list|(
name|meta
argument_list|,
name|meta
operator|->
name|disk_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk_pos
operator|==
operator|-
literal|1
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"JMicron disk_id %08x not found"
argument_list|,
name|meta
operator|->
name|disk_id
argument_list|)
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
comment|/* Metadata valid. Print it. */
name|g_raid_md_jmicron_print
argument_list|(
name|meta
argument_list|)
expr_stmt|;
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"JMicron disk position %d"
argument_list|,
name|disk_pos
argument_list|)
expr_stmt|;
name|spare
operator|=
operator|(
name|disk_pos
operator|==
operator|-
literal|2
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|search
label|:
comment|/* Search for matching node. */
name|sc
operator|=
name|NULL
expr_stmt|;
name|mdi1
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|geom
argument_list|,
argument|&mp->geom
argument_list|,
argument|geom
argument_list|)
block|{
name|sc
operator|=
name|geom
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|sc
operator|->
name|sc_stopping
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sc
operator|->
name|sc_md
operator|->
name|mdo_class
operator|!=
name|md
operator|->
name|mdo_class
condition|)
continue|continue;
name|mdi1
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_object
operator|*
operator|)
name|sc
operator|->
name|sc_md
expr_stmt|;
if|if
condition|(
name|spare
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|mdi1
operator|->
name|mdio_incomplete
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|mdi1
operator|->
name|mdio_config_id
operator|==
name|jmicron_meta_config_id
argument_list|(
name|meta
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* Found matching node. */
if|if
condition|(
name|geom
operator|!=
name|NULL
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Found matching array %s"
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|result
operator|=
name|G_RAID_MD_TASTE_EXISTING
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|spare
condition|)
block|{
comment|/* Not found needy node -- left for later. */
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Spare is not needed at this time"
argument_list|)
expr_stmt|;
goto|goto
name|fail1
goto|;
block|}
else|else
block|{
comment|/* Not found matching node -- create one. */
name|result
operator|=
name|G_RAID_MD_TASTE_NEW
expr_stmt|;
name|mdi
operator|->
name|mdio_config_id
operator|=
name|jmicron_meta_config_id
argument_list|(
name|meta
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"JMicron-%08x"
argument_list|,
name|mdi
operator|->
name|mdio_config_id
argument_list|)
expr_stmt|;
name|sc
operator|=
name|g_raid_create_node
argument_list|(
name|mp
argument_list|,
name|name
argument_list|,
name|md
argument_list|)
expr_stmt|;
name|md
operator|->
name|mdo_softc
operator|=
name|sc
expr_stmt|;
name|geom
operator|=
name|sc
operator|->
name|sc_geom
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|mdi
operator|->
name|mdio_start_co
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|mdi
operator|->
name|mdio_start_co
argument_list|,
name|g_raid_start_timeout
operator|*
name|hz
argument_list|,
name|g_raid_jmicron_go
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|mdi
operator|->
name|mdio_rootmount
operator|=
name|root_mount_hold
argument_list|(
literal|"GRAID-JMicron"
argument_list|)
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"root_mount_hold %p"
argument_list|,
name|mdi
operator|->
name|mdio_rootmount
argument_list|)
expr_stmt|;
block|}
comment|/* There is no return after this point, so we close passed consumer. */
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rcp
operator|=
name|g_new_consumer
argument_list|(
name|geom
argument_list|)
expr_stmt|;
name|rcp
operator|->
name|flags
operator||=
name|G_CF_DIRECT_RECEIVE
expr_stmt|;
name|g_attach
argument_list|(
name|rcp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_access
argument_list|(
name|rcp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
empty_stmt|;
comment|//goto fail1;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|pd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pd
argument_list|)
argument_list|,
name|M_MD_JMICRON
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pd
operator|->
name|pd_meta
operator|=
name|meta
expr_stmt|;
if|if
condition|(
name|spare
operator|==
literal|2
condition|)
block|{
name|pd
operator|->
name|pd_disk_pos
operator|=
operator|-
literal|3
expr_stmt|;
name|pd
operator|->
name|pd_disk_id
operator|=
name|arc4random
argument_list|()
operator|&
name|JMICRON_DISK_MASK
expr_stmt|;
block|}
else|else
block|{
name|pd
operator|->
name|pd_disk_pos
operator|=
operator|-
literal|1
expr_stmt|;
name|pd
operator|->
name|pd_disk_id
operator|=
name|meta
operator|->
name|disk_id
expr_stmt|;
block|}
name|pd
operator|->
name|pd_disk_size
operator|=
name|pp
operator|->
name|mediasize
expr_stmt|;
name|disk
operator|=
name|g_raid_create_disk
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_md_data
operator|=
operator|(
name|void
operator|*
operator|)
name|pd
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|=
name|rcp
expr_stmt|;
name|rcp
operator|->
name|private
operator|=
name|disk
expr_stmt|;
name|g_raid_get_disk_info
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|g_raid_md_jmicron_new_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
operator|*
name|gp
operator|=
name|geom
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
name|fail1
label|:
name|free
argument_list|(
name|meta
argument_list|,
name|M_MD_JMICRON
argument_list|)
expr_stmt|;
return|return
operator|(
name|G_RAID_MD_TASTE_FAIL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_event_jmicron
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|g_raid_disk
modifier|*
name|disk
parameter_list|,
name|u_int
name|event
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|struct
name|g_raid_md_jmicron_object
modifier|*
name|mdi
decl_stmt|;
name|struct
name|g_raid_md_jmicron_perdisk
modifier|*
name|pd
decl_stmt|;
name|sc
operator|=
name|md
operator|->
name|mdo_softc
expr_stmt|;
name|mdi
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_object
operator|*
operator|)
name|md
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|G_RAID_NODE_E_START
case|:
if|if
condition|(
operator|!
name|mdi
operator|->
name|mdio_started
condition|)
name|g_raid_md_jmicron_start
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|G_RAID_DISK_E_DISCONNECTED
case|:
comment|/* If disk was assigned, just update statuses. */
if|if
condition|(
name|pd
operator|->
name|pd_disk_pos
operator|>=
literal|0
condition|)
block|{
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_OFFLINE
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_consumer
condition|)
block|{
name|g_raid_kill_consumer
argument_list|(
name|sc
argument_list|,
name|disk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|=
name|NULL
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|sd
argument_list|,
argument|&disk->d_subdisks
argument_list|,
argument|sd_next
argument_list|)
block|{
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_NONE
argument_list|)
expr_stmt|;
name|g_raid_event_send
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_E_DISCONNECTED
argument_list|,
name|G_RAID_EVENT_SUBDISK
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Otherwise -- delete. */
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_NONE
argument_list|)
expr_stmt|;
name|g_raid_destroy_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
comment|/* Write updated metadata to all disks. */
name|g_raid_md_write_jmicron
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Check if anything left except placeholders. */
if|if
condition|(
name|g_raid_ndisks
argument_list|(
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
name|g_raid_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID_DISK_S_OFFLINE
argument_list|)
condition|)
name|g_raid_destroy_node
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|g_raid_md_jmicron_refill
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_ctl_jmicron
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_raid_md_jmicron_object
modifier|*
name|mdi
decl_stmt|;
name|struct
name|g_raid_md_jmicron_perdisk
modifier|*
name|pd
decl_stmt|;
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|char
name|arg
index|[
literal|16
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|verb
decl_stmt|,
modifier|*
name|volname
decl_stmt|,
modifier|*
name|levelname
decl_stmt|,
modifier|*
name|diskname
decl_stmt|;
name|int
modifier|*
name|nargs
decl_stmt|,
modifier|*
name|force
decl_stmt|;
name|off_t
name|size
decl_stmt|,
name|sectorsize
decl_stmt|,
name|strip
decl_stmt|;
name|intmax_t
modifier|*
name|sizearg
decl_stmt|,
modifier|*
name|striparg
decl_stmt|;
name|int
name|numdisks
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|,
name|level
decl_stmt|,
name|qual
decl_stmt|,
name|update
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|md
operator|->
name|mdo_softc
expr_stmt|;
name|mdi
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_object
operator|*
operator|)
name|md
expr_stmt|;
name|verb
operator|=
name|gctl_get_param
argument_list|(
name|req
argument_list|,
literal|"verb"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|gctl_get_paraml
argument_list|(
name|req
argument_list|,
literal|"nargs"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nargs
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"label"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|nargs
operator|<
literal|4
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Invalid number of arguments."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|volname
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
literal|"arg1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|volname
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No volume name."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|levelname
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
literal|"arg2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|levelname
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No RAID level."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|3
operator|)
return|;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
name|levelname
argument_list|,
literal|"RAID5"
argument_list|)
operator|==
literal|0
condition|)
name|levelname
operator|=
literal|"RAID5-LA"
expr_stmt|;
if|if
condition|(
name|g_raid_volume_str2level
argument_list|(
name|levelname
argument_list|,
operator|&
name|level
argument_list|,
operator|&
name|qual
argument_list|)
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Unknown RAID level '%s'."
argument_list|,
name|levelname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|4
operator|)
return|;
block|}
name|numdisks
operator|=
operator|*
name|nargs
operator|-
literal|3
expr_stmt|;
name|force
operator|=
name|gctl_get_paraml
argument_list|(
name|req
argument_list|,
literal|"force"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|force
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_raid_md_jmicron_supported
argument_list|(
name|level
argument_list|,
name|qual
argument_list|,
name|numdisks
argument_list|,
name|force
condition|?
operator|*
name|force
else|:
literal|0
argument_list|)
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Unsupported RAID level "
literal|"(0x%02x/0x%02x), or number of disks (%d)."
argument_list|,
name|level
argument_list|,
name|qual
argument_list|,
name|numdisks
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|5
operator|)
return|;
block|}
comment|/* Search for disks, connect them and probe. */
name|size
operator|=
literal|0x7fffffffffffffffllu
expr_stmt|;
name|sectorsize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdisks
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|"arg%d"
argument_list|,
name|i
operator|+
literal|3
argument_list|)
expr_stmt|;
name|diskname
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskname
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No disk name (%s)."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
literal|6
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|diskname
argument_list|,
literal|"NONE"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cp
operator|=
name|NULL
expr_stmt|;
name|pp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|g_topology_lock
argument_list|()
expr_stmt|;
name|cp
operator|=
name|g_raid_open_consumer
argument_list|(
name|sc
argument_list|,
name|diskname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Can't open '%s'."
argument_list|,
name|diskname
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|error
operator|=
operator|-
literal|7
expr_stmt|;
break|break;
block|}
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
block|}
name|pd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pd
argument_list|)
argument_list|,
name|M_MD_JMICRON
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pd
operator|->
name|pd_disk_pos
operator|=
name|i
expr_stmt|;
name|pd
operator|->
name|pd_disk_id
operator|=
name|arc4random
argument_list|()
operator|&
name|JMICRON_DISK_MASK
expr_stmt|;
name|disk
operator|=
name|g_raid_create_disk
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_md_data
operator|=
operator|(
name|void
operator|*
operator|)
name|pd
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
continue|continue;
name|cp
operator|->
name|private
operator|=
name|disk
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|g_raid_get_disk_info
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|pd
operator|->
name|pd_disk_size
operator|=
name|pp
operator|->
name|mediasize
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|pp
operator|->
name|mediasize
condition|)
name|size
operator|=
name|pp
operator|->
name|mediasize
expr_stmt|;
if|if
condition|(
name|sectorsize
operator|<
name|pp
operator|->
name|sectorsize
condition|)
name|sectorsize
operator|=
name|pp
operator|->
name|sectorsize
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|sectorsize
operator|<=
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Can't get sector size."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|8
operator|)
return|;
block|}
comment|/* Reserve space for metadata. */
name|size
operator|-=
name|sectorsize
expr_stmt|;
comment|/* Handle size argument. */
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sizearg
argument_list|)
expr_stmt|;
name|sizearg
operator|=
name|gctl_get_param
argument_list|(
name|req
argument_list|,
literal|"size"
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sizearg
operator|!=
name|NULL
operator|&&
name|len
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|sizearg
argument_list|)
operator|&&
operator|*
name|sizearg
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|sizearg
operator|>
name|size
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Size too big %lld> %lld."
argument_list|,
operator|(
name|long
name|long
operator|)
operator|*
name|sizearg
argument_list|,
operator|(
name|long
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|9
operator|)
return|;
block|}
name|size
operator|=
operator|*
name|sizearg
expr_stmt|;
block|}
comment|/* Handle strip argument. */
name|strip
operator|=
literal|131072
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|striparg
argument_list|)
expr_stmt|;
name|striparg
operator|=
name|gctl_get_param
argument_list|(
name|req
argument_list|,
literal|"strip"
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|striparg
operator|!=
name|NULL
operator|&&
name|len
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|striparg
argument_list|)
operator|&&
operator|*
name|striparg
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|striparg
operator|<
name|sectorsize
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Strip size too small."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|10
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|striparg
operator|%
name|sectorsize
operator|!=
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Incorrect strip size."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|11
operator|)
return|;
block|}
if|if
condition|(
name|strip
operator|>
literal|65535
operator|*
name|sectorsize
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Strip size too big."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|12
operator|)
return|;
block|}
name|strip
operator|=
operator|*
name|striparg
expr_stmt|;
block|}
comment|/* Round size down to strip or sector. */
if|if
condition|(
name|level
operator|==
name|G_RAID_VOLUME_RL_RAID1
condition|)
name|size
operator|-=
operator|(
name|size
operator|%
name|sectorsize
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|==
name|G_RAID_VOLUME_RL_RAID1E
operator|&&
operator|(
name|numdisks
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|size
operator|-=
operator|(
name|size
operator|%
operator|(
literal|2
operator|*
name|strip
operator|)
operator|)
expr_stmt|;
else|else
name|size
operator|-=
operator|(
name|size
operator|%
name|strip
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Size too small."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|13
operator|)
return|;
block|}
if|if
condition|(
name|size
operator|>
literal|0xffffffffffffllu
operator|*
name|sectorsize
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Size too big."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|14
operator|)
return|;
block|}
comment|/* We have all we need, create things: volume, ... */
name|mdi
operator|->
name|mdio_total_disks
operator|=
name|numdisks
expr_stmt|;
name|mdi
operator|->
name|mdio_started
operator|=
literal|1
expr_stmt|;
name|vol
operator|=
name|g_raid_create_volume
argument_list|(
name|sc
argument_list|,
name|volname
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|vol
operator|->
name|v_md_data
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
literal|0
expr_stmt|;
name|vol
operator|->
name|v_raid_level
operator|=
name|level
expr_stmt|;
name|vol
operator|->
name|v_raid_level_qualifier
operator|=
name|qual
expr_stmt|;
name|vol
operator|->
name|v_strip_size
operator|=
name|strip
expr_stmt|;
name|vol
operator|->
name|v_disks_count
operator|=
name|numdisks
expr_stmt|;
if|if
condition|(
name|level
operator|==
name|G_RAID_VOLUME_RL_RAID0
operator|||
name|level
operator|==
name|G_RAID_VOLUME_RL_CONCAT
operator|||
name|level
operator|==
name|G_RAID_VOLUME_RL_SINGLE
condition|)
name|vol
operator|->
name|v_mediasize
operator|=
name|size
operator|*
name|numdisks
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|==
name|G_RAID_VOLUME_RL_RAID1
condition|)
name|vol
operator|->
name|v_mediasize
operator|=
name|size
expr_stmt|;
elseif|else
if|if
condition|(
name|level
operator|==
name|G_RAID_VOLUME_RL_RAID5
condition|)
name|vol
operator|->
name|v_mediasize
operator|=
name|size
operator|*
operator|(
name|numdisks
operator|-
literal|1
operator|)
expr_stmt|;
else|else
block|{
comment|/* RAID1E */
name|vol
operator|->
name|v_mediasize
operator|=
operator|(
operator|(
name|size
operator|*
name|numdisks
operator|)
operator|/
name|strip
operator|/
literal|2
operator|)
operator|*
name|strip
expr_stmt|;
block|}
name|vol
operator|->
name|v_sectorsize
operator|=
name|sectorsize
expr_stmt|;
name|g_raid_start_volume
argument_list|(
name|vol
argument_list|)
expr_stmt|;
comment|/* , and subdisks. */
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|pd
operator|->
name|pd_disk_pos
index|]
expr_stmt|;
name|sd
operator|->
name|sd_disk
operator|=
name|disk
expr_stmt|;
name|sd
operator|->
name|sd_offset
operator|=
literal|0
expr_stmt|;
name|sd
operator|->
name|sd_size
operator|=
name|size
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|disk
operator|->
name|d_subdisks
argument_list|,
name|sd
argument_list|,
name|sd_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_disk
operator|->
name|d_consumer
operator|!=
name|NULL
condition|)
block|{
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_ACTIVE
argument_list|)
expr_stmt|;
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_ACTIVE
argument_list|)
expr_stmt|;
name|g_raid_event_send
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_E_NEW
argument_list|,
name|G_RAID_EVENT_SUBDISK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_OFFLINE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Write metadata based on created entities. */
name|G_RAID_DEBUG1
argument_list|(
literal|0
argument_list|,
name|sc
argument_list|,
literal|"Array started."
argument_list|)
expr_stmt|;
name|g_raid_md_write_jmicron
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Pickup any STALE/SPARE disks to refill array if needed. */
name|g_raid_md_jmicron_refill
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|g_raid_event_send
argument_list|(
name|vol
argument_list|,
name|G_RAID_VOLUME_E_START
argument_list|,
name|G_RAID_EVENT_VOLUME
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"delete"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Check if some volume is still open. */
name|force
operator|=
name|gctl_get_paraml
argument_list|(
name|req
argument_list|,
literal|"force"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|force
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|force
operator|!=
name|NULL
operator|&&
operator|*
name|force
operator|==
literal|0
operator|&&
name|g_raid_nopens
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Some volume is still open."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|4
operator|)
return|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_consumer
condition|)
name|jmicron_meta_erase
argument_list|(
name|disk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
block|}
name|g_raid_destroy_node
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"remove"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"fail"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|nargs
operator|<
literal|2
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Invalid number of arguments."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|*
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|"arg%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|diskname
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskname
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No disk name (%s)."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|diskname
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|diskname
operator|+=
literal|5
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_consumer
operator|!=
name|NULL
operator|&&
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|->
name|name
argument_list|,
name|diskname
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Disk '%s' not found."
argument_list|,
name|diskname
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
literal|3
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"fail"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|g_raid_md_fail_disk_jmicron
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|disk
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
comment|/* Erase metadata on deleting disk. */
name|jmicron_meta_erase
argument_list|(
name|disk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
comment|/* If disk was assigned, just update statuses. */
if|if
condition|(
name|pd
operator|->
name|pd_disk_pos
operator|>=
literal|0
condition|)
block|{
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_OFFLINE
argument_list|)
expr_stmt|;
name|g_raid_kill_consumer
argument_list|(
name|sc
argument_list|,
name|disk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sd
argument_list|,
argument|&disk->d_subdisks
argument_list|,
argument|sd_next
argument_list|)
block|{
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_NONE
argument_list|)
expr_stmt|;
name|g_raid_event_send
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_E_DISCONNECTED
argument_list|,
name|G_RAID_EVENT_SUBDISK
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Otherwise -- delete. */
name|g_raid_change_disk_state
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_S_NONE
argument_list|)
expr_stmt|;
name|g_raid_destroy_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Write updated metadata to remaining disks. */
name|g_raid_md_write_jmicron
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Check if anything left except placeholders. */
if|if
condition|(
name|g_raid_ndisks
argument_list|(
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
name|g_raid_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID_DISK_S_OFFLINE
argument_list|)
condition|)
name|g_raid_destroy_node
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|g_raid_md_jmicron_refill
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|verb
argument_list|,
literal|"insert"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|nargs
operator|<
literal|2
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Invalid number of arguments."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|update
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|*
name|nargs
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get disk name. */
name|snprintf
argument_list|(
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|"arg%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|diskname
operator|=
name|gctl_get_asciiparam
argument_list|(
name|req
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|diskname
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"No disk name (%s)."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
literal|3
expr_stmt|;
break|break;
block|}
comment|/* Try to find provider with specified name. */
name|g_topology_lock
argument_list|()
expr_stmt|;
name|cp
operator|=
name|g_raid_open_consumer
argument_list|(
name|sc
argument_list|,
name|diskname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Can't open disk '%s'."
argument_list|,
name|diskname
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|error
operator|=
operator|-
literal|4
expr_stmt|;
break|break;
block|}
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|pd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pd
argument_list|)
argument_list|,
name|M_MD_JMICRON
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pd
operator|->
name|pd_disk_pos
operator|=
operator|-
literal|3
expr_stmt|;
name|pd
operator|->
name|pd_disk_id
operator|=
name|arc4random
argument_list|()
operator|&
name|JMICRON_DISK_MASK
expr_stmt|;
name|pd
operator|->
name|pd_disk_size
operator|=
name|pp
operator|->
name|mediasize
expr_stmt|;
name|disk
operator|=
name|g_raid_create_disk
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|=
name|cp
expr_stmt|;
name|disk
operator|->
name|d_md_data
operator|=
operator|(
name|void
operator|*
operator|)
name|pd
expr_stmt|;
name|cp
operator|->
name|private
operator|=
name|disk
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|g_raid_get_disk_info
argument_list|(
name|disk
argument_list|)
expr_stmt|;
comment|/* Welcome the "new" disk. */
name|update
operator|+=
name|g_raid_md_jmicron_start_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_RAID_DISK_S_ACTIVE
operator|&&
name|disk
operator|->
name|d_state
operator|!=
name|G_RAID_DISK_S_SPARE
condition|)
block|{
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Disk '%s' doesn't fit."
argument_list|,
name|diskname
argument_list|)
expr_stmt|;
name|g_raid_destroy_disk
argument_list|(
name|disk
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
literal|8
expr_stmt|;
break|break;
block|}
block|}
comment|/* Write new metadata if we changed something. */
if|if
condition|(
name|update
condition|)
name|g_raid_md_write_jmicron
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|gctl_error
argument_list|(
name|req
argument_list|,
literal|"Command '%s' is not supported."
argument_list|,
name|verb
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|100
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_write_jmicron
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|g_raid_volume
modifier|*
name|tvol
parameter_list|,
name|struct
name|g_raid_subdisk
modifier|*
name|tsd
parameter_list|,
name|struct
name|g_raid_disk
modifier|*
name|tdisk
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_raid_md_jmicron_object
modifier|*
name|mdi
decl_stmt|;
name|struct
name|g_raid_md_jmicron_perdisk
modifier|*
name|pd
decl_stmt|;
name|struct
name|jmicron_raid_conf
modifier|*
name|meta
decl_stmt|;
name|int
name|i
decl_stmt|,
name|spares
decl_stmt|;
name|sc
operator|=
name|md
operator|->
name|mdo_softc
expr_stmt|;
name|mdi
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_object
operator|*
operator|)
name|md
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_stopping
operator|==
name|G_RAID_DESTROY_HARD
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* There is only one volume. */
name|vol
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_volumes
argument_list|)
expr_stmt|;
comment|/* Fill global fields. */
name|meta
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|meta
argument_list|)
argument_list|,
name|M_MD_JMICRON
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|meta
operator|->
name|signature
argument_list|,
name|JMICRON_MAGIC
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|meta
operator|->
name|version
operator|=
name|JMICRON_VERSION
expr_stmt|;
name|jmicron_meta_put_name
argument_list|(
name|meta
argument_list|,
name|vol
operator|->
name|v_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID0
condition|)
name|meta
operator|->
name|type
operator|=
name|JMICRON_T_RAID0
expr_stmt|;
elseif|else
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID1
condition|)
name|meta
operator|->
name|type
operator|=
name|JMICRON_T_RAID1
expr_stmt|;
elseif|else
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID1E
condition|)
name|meta
operator|->
name|type
operator|=
name|JMICRON_T_RAID01
expr_stmt|;
elseif|else
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_CONCAT
operator|||
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_SINGLE
condition|)
name|meta
operator|->
name|type
operator|=
name|JMICRON_T_CONCAT
expr_stmt|;
else|else
name|meta
operator|->
name|type
operator|=
name|JMICRON_T_RAID5
expr_stmt|;
name|meta
operator|->
name|stripe_shift
operator|=
name|fls
argument_list|(
name|vol
operator|->
name|v_strip_size
operator|/
literal|2048
argument_list|)
expr_stmt|;
name|meta
operator|->
name|flags
operator|=
name|JMICRON_F_READY
operator||
name|JMICRON_F_BOOTABLE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vol
operator|->
name|v_disks_count
condition|;
name|i
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_disk
operator|==
name|NULL
operator|||
name|sd
operator|->
name|sd_disk
operator|->
name|d_md_data
operator|==
name|NULL
condition|)
name|meta
operator|->
name|disks
index|[
name|i
index|]
operator|=
literal|0xffffffff
expr_stmt|;
else|else
block|{
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_perdisk
operator|*
operator|)
name|sd
operator|->
name|sd_disk
operator|->
name|d_md_data
expr_stmt|;
name|meta
operator|->
name|disks
index|[
name|i
index|]
operator|=
name|pd
operator|->
name|pd_disk_id
expr_stmt|;
block|}
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|<
name|G_RAID_SUBDISK_S_STALE
condition|)
name|meta
operator|->
name|flags
operator||=
name|JMICRON_F_BADSEC
expr_stmt|;
if|if
condition|(
name|vol
operator|->
name|v_dirty
condition|)
name|meta
operator|->
name|flags
operator||=
name|JMICRON_F_UNSYNC
expr_stmt|;
block|}
comment|/* Put spares to their slots. */
name|spares
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_RAID_DISK_S_SPARE
condition|)
continue|continue;
name|meta
operator|->
name|spare
index|[
name|spares
index|]
operator|=
name|pd
operator|->
name|pd_disk_id
expr_stmt|;
if|if
condition|(
operator|++
name|spares
operator|>=
literal|2
condition|)
break|break;
block|}
comment|/* We are done. Print meta data and store them to disks. */
if|if
condition|(
name|mdi
operator|->
name|mdio_meta
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|mdi
operator|->
name|mdio_meta
argument_list|,
name|M_MD_JMICRON
argument_list|)
expr_stmt|;
name|mdi
operator|->
name|mdio_meta
operator|=
name|meta
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_RAID_DISK_S_ACTIVE
operator|&&
name|disk
operator|->
name|d_state
operator|!=
name|G_RAID_DISK_S_SPARE
condition|)
continue|continue;
if|if
condition|(
name|pd
operator|->
name|pd_meta
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|pd
operator|->
name|pd_meta
argument_list|,
name|M_MD_JMICRON
argument_list|)
expr_stmt|;
name|pd
operator|->
name|pd_meta
operator|=
name|NULL
expr_stmt|;
block|}
name|pd
operator|->
name|pd_meta
operator|=
name|jmicron_meta_copy
argument_list|(
name|meta
argument_list|)
expr_stmt|;
name|pd
operator|->
name|pd_meta
operator|->
name|disk_id
operator|=
name|pd
operator|->
name|pd_disk_id
expr_stmt|;
if|if
condition|(
operator|(
name|sd
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|disk
operator|->
name|d_subdisks
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pd
operator|->
name|pd_meta
operator|->
name|offset
operator|=
operator|(
name|sd
operator|->
name|sd_offset
operator|/
literal|512
operator|)
operator|/
literal|16
expr_stmt|;
name|pd
operator|->
name|pd_meta
operator|->
name|disk_sectors_high
operator|=
operator|(
name|sd
operator|->
name|sd_size
operator|/
literal|512
operator|)
operator|>>
literal|16
expr_stmt|;
name|pd
operator|->
name|pd_meta
operator|->
name|disk_sectors_low
operator|=
operator|(
name|sd
operator|->
name|sd_size
operator|/
literal|512
operator|)
operator|&
literal|0xffff
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|<
name|G_RAID_SUBDISK_S_STALE
condition|)
name|pd
operator|->
name|pd_meta
operator|->
name|flags
operator|&=
operator|~
name|JMICRON_F_BADSEC
expr_stmt|;
elseif|else
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|<
name|G_RAID_SUBDISK_S_ACTIVE
condition|)
name|pd
operator|->
name|pd_meta
operator|->
name|flags
operator||=
name|JMICRON_F_UNSYNC
expr_stmt|;
block|}
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Writing JMicron metadata to %s"
argument_list|,
name|g_raid_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
name|g_raid_md_jmicron_print
argument_list|(
name|pd
operator|->
name|pd_meta
argument_list|)
expr_stmt|;
name|jmicron_meta_write
argument_list|(
name|disk
operator|->
name|d_consumer
argument_list|,
name|pd
operator|->
name|pd_meta
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_fail_disk_jmicron
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|g_raid_subdisk
modifier|*
name|tsd
parameter_list|,
name|struct
name|g_raid_disk
modifier|*
name|tdisk
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_md_jmicron_perdisk
modifier|*
name|pd
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|sc
operator|=
name|md
operator|->
name|mdo_softc
expr_stmt|;
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_perdisk
operator|*
operator|)
name|tdisk
operator|->
name|d_md_data
expr_stmt|;
comment|/* We can't fail disk that is not a part of array now. */
if|if
condition|(
name|pd
operator|->
name|pd_disk_pos
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|tdisk
operator|->
name|d_consumer
condition|)
name|jmicron_meta_erase
argument_list|(
name|tdisk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
comment|/* Change states. */
name|g_raid_change_disk_state
argument_list|(
name|tdisk
argument_list|,
name|G_RAID_DISK_S_FAILED
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sd
argument_list|,
argument|&tdisk->d_subdisks
argument_list|,
argument|sd_next
argument_list|)
block|{
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_FAILED
argument_list|)
expr_stmt|;
name|g_raid_event_send
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_E_FAILED
argument_list|,
name|G_RAID_EVENT_SUBDISK
argument_list|)
expr_stmt|;
block|}
comment|/* Write updated metadata to remaining disks. */
name|g_raid_md_write_jmicron
argument_list|(
name|md
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|tdisk
argument_list|)
expr_stmt|;
comment|/* Check if anything left except placeholders. */
if|if
condition|(
name|g_raid_ndisks
argument_list|(
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
name|g_raid_ndisks
argument_list|(
name|sc
argument_list|,
name|G_RAID_DISK_S_OFFLINE
argument_list|)
condition|)
name|g_raid_destroy_node
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|g_raid_md_jmicron_refill
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_free_disk_jmicron
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|,
name|struct
name|g_raid_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_raid_md_jmicron_perdisk
modifier|*
name|pd
decl_stmt|;
name|pd
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_perdisk
operator|*
operator|)
name|disk
operator|->
name|d_md_data
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|pd_meta
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|pd
operator|->
name|pd_meta
argument_list|,
name|M_MD_JMICRON
argument_list|)
expr_stmt|;
name|pd
operator|->
name|pd_meta
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|pd
argument_list|,
name|M_MD_JMICRON
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_md_data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_md_free_jmicron
parameter_list|(
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|)
block|{
name|struct
name|g_raid_md_jmicron_object
modifier|*
name|mdi
decl_stmt|;
name|mdi
operator|=
operator|(
expr|struct
name|g_raid_md_jmicron_object
operator|*
operator|)
name|md
expr_stmt|;
if|if
condition|(
operator|!
name|mdi
operator|->
name|mdio_started
condition|)
block|{
name|mdi
operator|->
name|mdio_started
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|mdi
operator|->
name|mdio_start_co
argument_list|)
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|md
operator|->
name|mdo_softc
argument_list|,
literal|"root_mount_rel %p"
argument_list|,
name|mdi
operator|->
name|mdio_rootmount
argument_list|)
expr_stmt|;
name|root_mount_rel
argument_list|(
name|mdi
operator|->
name|mdio_rootmount
argument_list|)
expr_stmt|;
name|mdi
operator|->
name|mdio_rootmount
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mdi
operator|->
name|mdio_meta
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|mdi
operator|->
name|mdio_meta
argument_list|,
name|M_MD_JMICRON
argument_list|)
expr_stmt|;
name|mdi
operator|->
name|mdio_meta
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|G_RAID_MD_DECLARE
argument_list|(
name|jmicron
argument_list|,
literal|"JMicron"
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

