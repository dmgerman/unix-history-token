begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010 Alexander Motin<mav@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<geom/raid/g_raid.h>
end_include

begin_include
include|#
directive|include
file|"g_raid_md_if.h"
end_include

begin_include
include|#
directive|include
file|"g_raid_tr_if.h"
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_RAID
argument_list|,
literal|"raid_data"
argument_list|,
literal|"GEOM_RAID Data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_kern_geom
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern_geom
argument_list|,
name|OID_AUTO
argument_list|,
name|raid
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"GEOM_RAID stuff"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|g_raid_enable
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_geom_raid
argument_list|,
name|OID_AUTO
argument_list|,
name|enable
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|g_raid_enable
argument_list|,
literal|0
argument_list|,
literal|"Enable on-disk metadata taste"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_int
name|g_raid_aggressive_spare
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_raid
argument_list|,
name|OID_AUTO
argument_list|,
name|aggressive_spare
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|g_raid_aggressive_spare
argument_list|,
literal|0
argument_list|,
literal|"Use disks without metadata as spare"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_int
name|g_raid_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_raid
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|g_raid_debug
argument_list|,
literal|0
argument_list|,
literal|"Debug level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|g_raid_read_err_thresh
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_raid
argument_list|,
name|OID_AUTO
argument_list|,
name|read_err_thresh
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|g_raid_read_err_thresh
argument_list|,
literal|0
argument_list|,
literal|"Number of read errors equated to disk failure"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_int
name|g_raid_start_timeout
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_raid
argument_list|,
name|OID_AUTO
argument_list|,
name|start_timeout
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|g_raid_start_timeout
argument_list|,
literal|0
argument_list|,
literal|"Time to wait for all array components"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_raid_clean_time
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_raid
argument_list|,
name|OID_AUTO
argument_list|,
name|clean_time
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|g_raid_clean_time
argument_list|,
literal|0
argument_list|,
literal|"Mark volume as clean when idling"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_raid_disconnect_on_failure
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_raid
argument_list|,
name|OID_AUTO
argument_list|,
name|disconnect_on_failure
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|g_raid_disconnect_on_failure
argument_list|,
literal|0
argument_list|,
literal|"Disconnect component on I/O failure."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_raid_name_format
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_raid
argument_list|,
name|OID_AUTO
argument_list|,
name|name_format
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|g_raid_name_format
argument_list|,
literal|0
argument_list|,
literal|"Providers name format."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|g_raid_idle_threshold
init|=
literal|1000000
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_geom_raid
argument_list|,
name|OID_AUTO
argument_list|,
name|idle_threshold
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|g_raid_idle_threshold
argument_list|,
literal|1000000
argument_list|,
literal|"Time in microseconds to consider a volume idle."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|ar_legacy_aliases
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_geom_raid
argument_list|,
name|OID_AUTO
argument_list|,
name|legacy_aliases
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|ar_legacy_aliases
argument_list|,
literal|0
argument_list|,
literal|"Create aliases named as the legacy ataraid style."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MSLEEP
parameter_list|(
name|rv
parameter_list|,
name|ident
parameter_list|,
name|mtx
parameter_list|,
name|priority
parameter_list|,
name|wmesg
parameter_list|,
name|timeout
parameter_list|)
value|do {	\ 	G_RAID_DEBUG(4, "%s: Sleeping %p.", __func__, (ident));		\ 	rv = msleep((ident), (mtx), (priority), (wmesg), (timeout));	\ 	G_RAID_DEBUG(4, "%s: Woken up %p.", __func__, (ident));		\ } while (0)
end_define

begin_macro
name|LIST_HEAD
argument_list|(
argument_list|,
argument|g_raid_md_class
argument_list|)
end_macro

begin_expr_stmt
name|g_raid_md_classes
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|g_raid_md_classes
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|LIST_HEAD
argument_list|(
argument_list|,
argument|g_raid_tr_class
argument_list|)
end_macro

begin_expr_stmt
name|g_raid_tr_classes
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|g_raid_tr_classes
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|LIST_HEAD
argument_list|(
argument_list|,
argument|g_raid_volume
argument_list|)
end_macro

begin_expr_stmt
name|g_raid_volumes
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|g_raid_volumes
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|g_raid_post_sync
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_raid_started
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|g_raid_shutdown
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|g_raid_destroy_geom
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|g_taste_t
name|g_raid_taste
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|g_raid_init
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_raid_fini
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|g_class
name|g_raid_class
init|=
block|{
operator|.
name|name
operator|=
name|G_RAID_CLASS_NAME
block|,
operator|.
name|version
operator|=
name|G_VERSION
block|,
operator|.
name|ctlreq
operator|=
name|g_raid_ctl
block|,
operator|.
name|taste
operator|=
name|g_raid_taste
block|,
operator|.
name|destroy_geom
operator|=
name|g_raid_destroy_geom
block|,
operator|.
name|init
operator|=
name|g_raid_init
block|,
operator|.
name|fini
operator|=
name|g_raid_fini
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|g_raid_destroy_provider
parameter_list|(
name|struct
name|g_raid_volume
modifier|*
name|vol
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_raid_update_disk
parameter_list|(
name|struct
name|g_raid_disk
modifier|*
name|disk
parameter_list|,
name|u_int
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_raid_update_subdisk
parameter_list|(
name|struct
name|g_raid_subdisk
modifier|*
name|subdisk
parameter_list|,
name|u_int
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_raid_update_volume
parameter_list|(
name|struct
name|g_raid_volume
modifier|*
name|vol
parameter_list|,
name|u_int
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|g_raid_update_node
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_raid_dumpconf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_raid_start
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_raid_start_request
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_raid_disk_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|g_raid_poll
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|g_raid_node_event2str
parameter_list|(
name|int
name|event
parameter_list|)
block|{
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|G_RAID_NODE_E_WAKE
case|:
return|return
operator|(
literal|"WAKE"
operator|)
return|;
case|case
name|G_RAID_NODE_E_START
case|:
return|return
operator|(
literal|"START"
operator|)
return|;
default|default:
return|return
operator|(
literal|"INVALID"
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|g_raid_disk_state2str
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|G_RAID_DISK_S_NONE
case|:
return|return
operator|(
literal|"NONE"
operator|)
return|;
case|case
name|G_RAID_DISK_S_OFFLINE
case|:
return|return
operator|(
literal|"OFFLINE"
operator|)
return|;
case|case
name|G_RAID_DISK_S_DISABLED
case|:
return|return
operator|(
literal|"DISABLED"
operator|)
return|;
case|case
name|G_RAID_DISK_S_FAILED
case|:
return|return
operator|(
literal|"FAILED"
operator|)
return|;
case|case
name|G_RAID_DISK_S_STALE_FAILED
case|:
return|return
operator|(
literal|"STALE_FAILED"
operator|)
return|;
case|case
name|G_RAID_DISK_S_SPARE
case|:
return|return
operator|(
literal|"SPARE"
operator|)
return|;
case|case
name|G_RAID_DISK_S_STALE
case|:
return|return
operator|(
literal|"STALE"
operator|)
return|;
case|case
name|G_RAID_DISK_S_ACTIVE
case|:
return|return
operator|(
literal|"ACTIVE"
operator|)
return|;
default|default:
return|return
operator|(
literal|"INVALID"
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|g_raid_disk_event2str
parameter_list|(
name|int
name|event
parameter_list|)
block|{
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|G_RAID_DISK_E_DISCONNECTED
case|:
return|return
operator|(
literal|"DISCONNECTED"
operator|)
return|;
default|default:
return|return
operator|(
literal|"INVALID"
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|g_raid_subdisk_state2str
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|G_RAID_SUBDISK_S_NONE
case|:
return|return
operator|(
literal|"NONE"
operator|)
return|;
case|case
name|G_RAID_SUBDISK_S_FAILED
case|:
return|return
operator|(
literal|"FAILED"
operator|)
return|;
case|case
name|G_RAID_SUBDISK_S_NEW
case|:
return|return
operator|(
literal|"NEW"
operator|)
return|;
case|case
name|G_RAID_SUBDISK_S_REBUILD
case|:
return|return
operator|(
literal|"REBUILD"
operator|)
return|;
case|case
name|G_RAID_SUBDISK_S_UNINITIALIZED
case|:
return|return
operator|(
literal|"UNINITIALIZED"
operator|)
return|;
case|case
name|G_RAID_SUBDISK_S_STALE
case|:
return|return
operator|(
literal|"STALE"
operator|)
return|;
case|case
name|G_RAID_SUBDISK_S_RESYNC
case|:
return|return
operator|(
literal|"RESYNC"
operator|)
return|;
case|case
name|G_RAID_SUBDISK_S_ACTIVE
case|:
return|return
operator|(
literal|"ACTIVE"
operator|)
return|;
default|default:
return|return
operator|(
literal|"INVALID"
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|g_raid_subdisk_event2str
parameter_list|(
name|int
name|event
parameter_list|)
block|{
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|G_RAID_SUBDISK_E_NEW
case|:
return|return
operator|(
literal|"NEW"
operator|)
return|;
case|case
name|G_RAID_SUBDISK_E_FAILED
case|:
return|return
operator|(
literal|"FAILED"
operator|)
return|;
case|case
name|G_RAID_SUBDISK_E_DISCONNECTED
case|:
return|return
operator|(
literal|"DISCONNECTED"
operator|)
return|;
default|default:
return|return
operator|(
literal|"INVALID"
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|g_raid_volume_state2str
parameter_list|(
name|int
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|G_RAID_VOLUME_S_STARTING
case|:
return|return
operator|(
literal|"STARTING"
operator|)
return|;
case|case
name|G_RAID_VOLUME_S_BROKEN
case|:
return|return
operator|(
literal|"BROKEN"
operator|)
return|;
case|case
name|G_RAID_VOLUME_S_DEGRADED
case|:
return|return
operator|(
literal|"DEGRADED"
operator|)
return|;
case|case
name|G_RAID_VOLUME_S_SUBOPTIMAL
case|:
return|return
operator|(
literal|"SUBOPTIMAL"
operator|)
return|;
case|case
name|G_RAID_VOLUME_S_OPTIMAL
case|:
return|return
operator|(
literal|"OPTIMAL"
operator|)
return|;
case|case
name|G_RAID_VOLUME_S_UNSUPPORTED
case|:
return|return
operator|(
literal|"UNSUPPORTED"
operator|)
return|;
case|case
name|G_RAID_VOLUME_S_STOPPED
case|:
return|return
operator|(
literal|"STOPPED"
operator|)
return|;
default|default:
return|return
operator|(
literal|"INVALID"
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|g_raid_volume_event2str
parameter_list|(
name|int
name|event
parameter_list|)
block|{
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|G_RAID_VOLUME_E_UP
case|:
return|return
operator|(
literal|"UP"
operator|)
return|;
case|case
name|G_RAID_VOLUME_E_DOWN
case|:
return|return
operator|(
literal|"DOWN"
operator|)
return|;
case|case
name|G_RAID_VOLUME_E_START
case|:
return|return
operator|(
literal|"START"
operator|)
return|;
case|case
name|G_RAID_VOLUME_E_STARTMD
case|:
return|return
operator|(
literal|"STARTMD"
operator|)
return|;
default|default:
return|return
operator|(
literal|"INVALID"
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|g_raid_volume_level2str
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|qual
parameter_list|)
block|{
switch|switch
condition|(
name|level
condition|)
block|{
case|case
name|G_RAID_VOLUME_RL_RAID0
case|:
return|return
operator|(
literal|"RAID0"
operator|)
return|;
case|case
name|G_RAID_VOLUME_RL_RAID1
case|:
return|return
operator|(
literal|"RAID1"
operator|)
return|;
case|case
name|G_RAID_VOLUME_RL_RAID3
case|:
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R3P0
condition|)
return|return
operator|(
literal|"RAID3-P0"
operator|)
return|;
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R3PN
condition|)
return|return
operator|(
literal|"RAID3-PN"
operator|)
return|;
return|return
operator|(
literal|"RAID3"
operator|)
return|;
case|case
name|G_RAID_VOLUME_RL_RAID4
case|:
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R4P0
condition|)
return|return
operator|(
literal|"RAID4-P0"
operator|)
return|;
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R4PN
condition|)
return|return
operator|(
literal|"RAID4-PN"
operator|)
return|;
return|return
operator|(
literal|"RAID4"
operator|)
return|;
case|case
name|G_RAID_VOLUME_RL_RAID5
case|:
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R5RA
condition|)
return|return
operator|(
literal|"RAID5-RA"
operator|)
return|;
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R5RS
condition|)
return|return
operator|(
literal|"RAID5-RS"
operator|)
return|;
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R5LA
condition|)
return|return
operator|(
literal|"RAID5-LA"
operator|)
return|;
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R5LS
condition|)
return|return
operator|(
literal|"RAID5-LS"
operator|)
return|;
return|return
operator|(
literal|"RAID5"
operator|)
return|;
case|case
name|G_RAID_VOLUME_RL_RAID6
case|:
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R6RA
condition|)
return|return
operator|(
literal|"RAID6-RA"
operator|)
return|;
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R6RS
condition|)
return|return
operator|(
literal|"RAID6-RS"
operator|)
return|;
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R6LA
condition|)
return|return
operator|(
literal|"RAID6-LA"
operator|)
return|;
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R6LS
condition|)
return|return
operator|(
literal|"RAID6-LS"
operator|)
return|;
return|return
operator|(
literal|"RAID6"
operator|)
return|;
case|case
name|G_RAID_VOLUME_RL_RAIDMDF
case|:
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_RMDFRA
condition|)
return|return
operator|(
literal|"RAIDMDF-RA"
operator|)
return|;
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_RMDFRS
condition|)
return|return
operator|(
literal|"RAIDMDF-RS"
operator|)
return|;
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_RMDFLA
condition|)
return|return
operator|(
literal|"RAIDMDF-LA"
operator|)
return|;
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_RMDFLS
condition|)
return|return
operator|(
literal|"RAIDMDF-LS"
operator|)
return|;
return|return
operator|(
literal|"RAIDMDF"
operator|)
return|;
case|case
name|G_RAID_VOLUME_RL_RAID1E
case|:
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R1EA
condition|)
return|return
operator|(
literal|"RAID1E-A"
operator|)
return|;
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R1EO
condition|)
return|return
operator|(
literal|"RAID1E-O"
operator|)
return|;
return|return
operator|(
literal|"RAID1E"
operator|)
return|;
case|case
name|G_RAID_VOLUME_RL_SINGLE
case|:
return|return
operator|(
literal|"SINGLE"
operator|)
return|;
case|case
name|G_RAID_VOLUME_RL_CONCAT
case|:
return|return
operator|(
literal|"CONCAT"
operator|)
return|;
case|case
name|G_RAID_VOLUME_RL_RAID5E
case|:
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R5ERA
condition|)
return|return
operator|(
literal|"RAID5E-RA"
operator|)
return|;
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R5ERS
condition|)
return|return
operator|(
literal|"RAID5E-RS"
operator|)
return|;
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R5ELA
condition|)
return|return
operator|(
literal|"RAID5E-LA"
operator|)
return|;
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R5ELS
condition|)
return|return
operator|(
literal|"RAID5E-LS"
operator|)
return|;
return|return
operator|(
literal|"RAID5E"
operator|)
return|;
case|case
name|G_RAID_VOLUME_RL_RAID5EE
case|:
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R5EERA
condition|)
return|return
operator|(
literal|"RAID5EE-RA"
operator|)
return|;
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R5EERS
condition|)
return|return
operator|(
literal|"RAID5EE-RS"
operator|)
return|;
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R5EELA
condition|)
return|return
operator|(
literal|"RAID5EE-LA"
operator|)
return|;
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R5EELS
condition|)
return|return
operator|(
literal|"RAID5EE-LS"
operator|)
return|;
return|return
operator|(
literal|"RAID5EE"
operator|)
return|;
case|case
name|G_RAID_VOLUME_RL_RAID5R
case|:
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R5RRA
condition|)
return|return
operator|(
literal|"RAID5R-RA"
operator|)
return|;
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R5RRS
condition|)
return|return
operator|(
literal|"RAID5R-RS"
operator|)
return|;
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R5RLA
condition|)
return|return
operator|(
literal|"RAID5R-LA"
operator|)
return|;
if|if
condition|(
name|qual
operator|==
name|G_RAID_VOLUME_RLQ_R5RLS
condition|)
return|return
operator|(
literal|"RAID5R-LS"
operator|)
return|;
return|return
operator|(
literal|"RAID5E"
operator|)
return|;
default|default:
return|return
operator|(
literal|"UNKNOWN"
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|g_raid_volume_str2level
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
modifier|*
name|level
parameter_list|,
name|int
modifier|*
name|qual
parameter_list|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_UNKNOWN
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_NONE
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID0"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID1"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID3-P0"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID3
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R3P0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID3-PN"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID3"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID3
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R3PN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID4-P0"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID4
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R4P0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID4-PN"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID4"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID4
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R4PN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID5-RA"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID5
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R5RA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID5-RS"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID5
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R5RS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID5"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID5-LA"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID5
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R5LA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID5-LS"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID5
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R5LS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID6-RA"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID6
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R6RA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID6-RS"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID6
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R6RS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID6"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID6-LA"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID6
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R6LA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID6-LS"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID6
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R6LS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAIDMDF-RA"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAIDMDF
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_RMDFRA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAIDMDF-RS"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAIDMDF
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_RMDFRS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAIDMDF"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAIDMDF-LA"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAIDMDF
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_RMDFLA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAIDMDF-LS"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAIDMDF
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_RMDFLS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID10"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID1E"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID1E-A"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID1E
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R1EA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID1E-O"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID1E
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R1EO
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"SINGLE"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_SINGLE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"CONCAT"
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_CONCAT
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID5E-RA"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID5E
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R5ERA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID5E-RS"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID5E
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R5ERS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID5E"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID5E-LA"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID5E
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R5ELA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID5E-LS"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID5E
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R5ELS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID5EE-RA"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID5EE
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R5EERA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID5EE-RS"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID5EE
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R5EERS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID5EE"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID5EE-LA"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID5EE
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R5EELA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID5EE-LS"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID5EE
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R5EELS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID5R-RA"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID5R
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R5RRA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID5R-RS"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID5R
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R5RRS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID5R"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID5R-LA"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID5R
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R5RLA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"RAID5R-LS"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|level
operator|=
name|G_RAID_VOLUME_RL_RAID5R
expr_stmt|;
operator|*
name|qual
operator|=
name|G_RAID_VOLUME_RLQ_R5RLS
expr_stmt|;
block|}
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|g_raid_get_diskname
parameter_list|(
name|struct
name|g_raid_disk
modifier|*
name|disk
parameter_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_consumer
operator|==
name|NULL
operator|||
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|==
name|NULL
condition|)
return|return
operator|(
literal|"[unknown]"
operator|)
return|;
return|return
operator|(
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|->
name|name
operator|)
return|;
block|}
end_function

begin_function
name|void
name|g_raid_get_disk_info
parameter_list|(
name|struct
name|g_raid_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
init|=
name|disk
operator|->
name|d_consumer
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|;
comment|/* Read kernel dumping information. */
name|disk
operator|->
name|d_kd
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|disk
operator|->
name|d_kd
operator|.
name|length
operator|=
name|OFF_MAX
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|disk
operator|->
name|d_kd
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_io_getattr
argument_list|(
literal|"GEOM::kerneldump"
argument_list|,
name|cp
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|disk
operator|->
name|d_kd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|disk
operator|->
name|d_kd
operator|.
name|di
operator|.
name|dumper
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_kd
operator|.
name|di
operator|.
name|dumper
operator|==
name|NULL
condition|)
name|G_RAID_DEBUG1
argument_list|(
literal|2
argument_list|,
name|disk
operator|->
name|d_softc
argument_list|,
literal|"Dumping not supported by %s: %d."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* Read BIO_DELETE support. */
name|error
operator|=
name|g_getattr
argument_list|(
literal|"GEOM::candelete"
argument_list|,
name|cp
argument_list|,
operator|&
name|disk
operator|->
name|d_candelete
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|disk
operator|->
name|d_candelete
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|disk
operator|->
name|d_candelete
condition|)
name|G_RAID_DEBUG1
argument_list|(
literal|2
argument_list|,
name|disk
operator|->
name|d_softc
argument_list|,
literal|"BIO_DELETE not supported by %s: %d."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|g_raid_report_disk_state
parameter_list|(
name|struct
name|g_raid_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|int
name|len
decl_stmt|,
name|state
decl_stmt|;
name|uint32_t
name|s
decl_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_consumer
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_DISABLED
condition|)
block|{
name|s
operator|=
name|G_STATE_ACTIVE
expr_stmt|;
comment|/* XXX */
block|}
elseif|else
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_FAILED
operator|||
name|disk
operator|->
name|d_state
operator|==
name|G_RAID_DISK_S_STALE_FAILED
condition|)
block|{
name|s
operator|=
name|G_STATE_FAILED
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
name|G_RAID_SUBDISK_S_ACTIVE
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sd
argument_list|,
argument|&disk->d_subdisks
argument_list|,
argument|sd_next
argument_list|)
block|{
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|<
name|state
condition|)
name|state
operator|=
name|sd
operator|->
name|sd_state
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|==
name|G_RAID_SUBDISK_S_FAILED
condition|)
name|s
operator|=
name|G_STATE_FAILED
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|==
name|G_RAID_SUBDISK_S_NEW
operator|||
name|state
operator|==
name|G_RAID_SUBDISK_S_REBUILD
condition|)
name|s
operator|=
name|G_STATE_REBUILD
expr_stmt|;
elseif|else
if|if
condition|(
name|state
operator|==
name|G_RAID_SUBDISK_S_STALE
operator|||
name|state
operator|==
name|G_RAID_SUBDISK_S_RESYNC
condition|)
name|s
operator|=
name|G_STATE_RESYNC
expr_stmt|;
else|else
name|s
operator|=
name|G_STATE_ACTIVE
expr_stmt|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|g_io_getattr
argument_list|(
literal|"GEOM::setstate"
argument_list|,
name|disk
operator|->
name|d_consumer
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|2
argument_list|,
name|disk
operator|->
name|d_softc
argument_list|,
literal|"Disk %s state reported as %d."
argument_list|,
name|g_raid_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|g_raid_change_disk_state
parameter_list|(
name|struct
name|g_raid_disk
modifier|*
name|disk
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|0
argument_list|,
name|disk
operator|->
name|d_softc
argument_list|,
literal|"Disk %s state changed from %s to %s."
argument_list|,
name|g_raid_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|,
name|g_raid_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
argument_list|,
name|g_raid_disk_state2str
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_state
operator|=
name|state
expr_stmt|;
name|g_raid_report_disk_state
argument_list|(
name|disk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|g_raid_change_subdisk_state
parameter_list|(
name|struct
name|g_raid_subdisk
modifier|*
name|sd
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|0
argument_list|,
name|sd
operator|->
name|sd_softc
argument_list|,
literal|"Subdisk %s:%d-%s state changed from %s to %s."
argument_list|,
name|sd
operator|->
name|sd_volume
operator|->
name|v_name
argument_list|,
name|sd
operator|->
name|sd_pos
argument_list|,
name|sd
operator|->
name|sd_disk
condition|?
name|g_raid_get_diskname
argument_list|(
name|sd
operator|->
name|sd_disk
argument_list|)
else|:
literal|"[none]"
argument_list|,
name|g_raid_subdisk_state2str
argument_list|(
name|sd
operator|->
name|sd_state
argument_list|)
argument_list|,
name|g_raid_subdisk_state2str
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|sd
operator|->
name|sd_state
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_disk
condition|)
name|g_raid_report_disk_state
argument_list|(
name|sd
operator|->
name|sd_disk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|g_raid_change_volume_state
parameter_list|(
name|struct
name|g_raid_volume
modifier|*
name|vol
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|0
argument_list|,
name|vol
operator|->
name|v_softc
argument_list|,
literal|"Volume %s state changed from %s to %s."
argument_list|,
name|vol
operator|->
name|v_name
argument_list|,
name|g_raid_volume_state2str
argument_list|(
name|vol
operator|->
name|v_state
argument_list|)
argument_list|,
name|g_raid_volume_state2str
argument_list|(
name|state
argument_list|)
argument_list|)
expr_stmt|;
name|vol
operator|->
name|v_state
operator|=
name|state
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * --- Events handling functions ---  * Events in geom_raid are used to maintain subdisks and volumes status  * from one thread to simplify locking.  */
end_comment

begin_function
specifier|static
name|void
name|g_raid_event_free
parameter_list|(
name|struct
name|g_raid_event
modifier|*
name|ep
parameter_list|)
block|{
name|free
argument_list|(
name|ep
argument_list|,
name|M_RAID
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|g_raid_event_send
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|event
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_event
modifier|*
name|ep
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|G_RAID_EVENT_VOLUME
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|=
operator|(
operator|(
expr|struct
name|g_raid_volume
operator|*
operator|)
name|arg
operator|)
operator|->
name|v_softc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|G_RAID_EVENT_DISK
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|=
operator|(
operator|(
expr|struct
name|g_raid_disk
operator|*
operator|)
name|arg
operator|)
operator|->
name|d_softc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|G_RAID_EVENT_SUBDISK
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|=
operator|(
operator|(
expr|struct
name|g_raid_subdisk
operator|*
operator|)
name|arg
operator|)
operator|->
name|sd_softc
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|=
name|arg
expr_stmt|;
block|}
name|ep
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ep
argument_list|)
argument_list|,
name|M_RAID
argument_list|,
name|sx_xlocked
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|ep
operator|->
name|e_tgt
operator|=
name|arg
expr_stmt|;
name|ep
operator|->
name|e_event
operator|=
name|event
expr_stmt|;
name|ep
operator|->
name|e_flags
operator|=
name|flags
expr_stmt|;
name|ep
operator|->
name|e_error
operator|=
literal|0
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|4
argument_list|,
name|sc
argument_list|,
literal|"Sending event %p. Waking up %p."
argument_list|,
name|ep
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_events
argument_list|,
name|ep
argument_list|,
name|e_next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|G_RAID_EVENT_WAIT
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|4
argument_list|,
name|sc
argument_list|,
literal|"Sleeping on %p."
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_RAID_EVENT_DONE
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|MSLEEP
argument_list|(
name|error
argument_list|,
name|ep
argument_list|,
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|,
name|PRIBIO
operator||
name|PDROP
argument_list|,
literal|"m:event"
argument_list|,
name|hz
operator|*
literal|5
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|ep
operator|->
name|e_error
expr_stmt|;
name|g_raid_event_free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_event_cancel
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|tgt
parameter_list|)
block|{
name|struct
name|g_raid_event
modifier|*
name|ep
decl_stmt|,
modifier|*
name|tmpep
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ep
argument_list|,
argument|&sc->sc_events
argument_list|,
argument|e_next
argument_list|,
argument|tmpep
argument_list|)
block|{
if|if
condition|(
name|ep
operator|->
name|e_tgt
operator|!=
name|tgt
condition|)
continue|continue;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_events
argument_list|,
name|ep
argument_list|,
name|e_next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_RAID_EVENT_WAIT
operator|)
operator|==
literal|0
condition|)
name|g_raid_event_free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
else|else
block|{
name|ep
operator|->
name|e_error
operator|=
name|ECANCELED
expr_stmt|;
name|wakeup
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_event_check
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|tgt
parameter_list|)
block|{
name|struct
name|g_raid_event
modifier|*
name|ep
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ep
argument_list|,
argument|&sc->sc_events
argument_list|,
argument|e_next
argument_list|)
block|{
if|if
condition|(
name|ep
operator|->
name|e_tgt
operator|!=
name|tgt
condition|)
continue|continue;
name|res
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of disks in given state.  * If state is equal to -1, count all connected disks.  */
end_comment

begin_function
name|u_int
name|g_raid_ndisks
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|;
name|u_int
name|n
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_state
operator|==
name|state
operator|||
name|state
operator|==
operator|-
literal|1
condition|)
name|n
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of subdisks in given state.  * If state is equal to -1, count all connected disks.  */
end_comment

begin_function
name|u_int
name|g_raid_nsubdisks
parameter_list|(
name|struct
name|g_raid_volume
modifier|*
name|vol
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|g_raid_subdisk
modifier|*
name|subdisk
decl_stmt|;
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|sc
operator|=
name|vol
operator|->
name|v_softc
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vol
operator|->
name|v_disks_count
condition|;
name|i
operator|++
control|)
block|{
name|subdisk
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|state
operator|==
operator|-
literal|1
operator|&&
name|subdisk
operator|->
name|sd_state
operator|!=
name|G_RAID_SUBDISK_S_NONE
operator|)
operator|||
name|subdisk
operator|->
name|sd_state
operator|==
name|state
condition|)
name|n
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the first subdisk in given state.  * If state is equal to -1, then the first connected disks.  */
end_comment

begin_function
name|struct
name|g_raid_subdisk
modifier|*
name|g_raid_get_subdisk
parameter_list|(
name|struct
name|g_raid_volume
modifier|*
name|vol
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|sc
operator|=
name|vol
operator|->
name|v_softc
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vol
operator|->
name|v_disks_count
condition|;
name|i
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|state
operator|==
operator|-
literal|1
operator|&&
name|sd
operator|->
name|sd_state
operator|!=
name|G_RAID_SUBDISK_S_NONE
operator|)
operator|||
name|sd
operator|->
name|sd_state
operator|==
name|state
condition|)
return|return
operator|(
name|sd
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|g_consumer
modifier|*
name|g_raid_open_consumer
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|name
operator|+=
literal|5
expr_stmt|;
name|pp
operator|=
name|g_provider_by_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cp
operator|=
name|g_new_consumer
argument_list|(
name|sc
operator|->
name|sc_geom
argument_list|)
expr_stmt|;
name|cp
operator|->
name|flags
operator||=
name|G_CF_DIRECT_RECEIVE
expr_stmt|;
if|if
condition|(
name|g_attach
argument_list|(
name|cp
argument_list|,
name|pp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|g_access
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|g_raid_nrequests
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|u_int
name|nreqs
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&sc->sc_queue.queue
argument_list|,
argument|bio_queue
argument_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_from
operator|==
name|cp
condition|)
name|nreqs
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|nreqs
operator|)
return|;
block|}
end_function

begin_function
name|u_int
name|g_raid_nopens
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|u_int
name|opens
decl_stmt|;
name|opens
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vol
argument_list|,
argument|&sc->sc_volumes
argument_list|,
argument|v_next
argument_list|)
block|{
if|if
condition|(
name|vol
operator|->
name|v_provider_open
operator|!=
literal|0
condition|)
name|opens
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|opens
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_consumer_is_busy
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
if|if
condition|(
name|cp
operator|->
name|index
operator|>
literal|0
condition|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|2
argument_list|,
name|sc
argument_list|,
literal|"I/O requests for %s exist, can't destroy it now."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|g_raid_nrequests
argument_list|(
name|sc
argument_list|,
name|cp
argument_list|)
operator|>
literal|0
condition|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|2
argument_list|,
name|sc
argument_list|,
literal|"I/O requests for %s in queue, can't destroy it now."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_destroy_consumer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
name|__unused
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|cp
operator|=
name|arg
expr_stmt|;
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Consumer %s destroyed."
argument_list|,
name|cp
operator|->
name|provider
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|g_raid_kill_consumer
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|int
name|retaste_wait
decl_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|cp
operator|->
name|private
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|g_raid_consumer_is_busy
argument_list|(
name|sc
argument_list|,
name|cp
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|pp
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|retaste_wait
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|acw
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|pp
operator|->
name|geom
operator|->
name|flags
operator|&
name|G_GEOM_WITHER
operator|)
operator|==
literal|0
condition|)
name|retaste_wait
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|->
name|acr
operator|>
literal|0
operator|||
name|cp
operator|->
name|acw
operator|>
literal|0
operator|||
name|cp
operator|->
name|ace
operator|>
literal|0
condition|)
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
name|cp
operator|->
name|acr
argument_list|,
operator|-
name|cp
operator|->
name|acw
argument_list|,
operator|-
name|cp
operator|->
name|ace
argument_list|)
expr_stmt|;
if|if
condition|(
name|retaste_wait
condition|)
block|{
comment|/* 		 * After retaste event was send (inside g_access()), we can send 		 * event to detach and destroy consumer. 		 * A class, which has consumer to the given provider connected 		 * will not receive retaste event for the provider. 		 * This is the way how I ignore retaste events when I close 		 * consumers opened for write: I detach and destroy consumer 		 * after retaste event is sent. 		 */
name|g_post_event
argument_list|(
name|g_raid_destroy_consumer
argument_list|,
name|cp
argument_list|,
name|M_WAITOK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Consumer %s destroyed."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|out
label|:
name|g_topology_unlock
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_orphan
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|disk
operator|=
name|cp
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
return|return;
name|g_raid_event_send
argument_list|(
name|disk
argument_list|,
name|G_RAID_DISK_E_DISCONNECTED
argument_list|,
name|G_RAID_EVENT_DISK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_clean
parameter_list|(
name|struct
name|g_raid_volume
modifier|*
name|vol
parameter_list|,
name|int
name|acw
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|sc
operator|=
name|vol
operator|->
name|v_softc
expr_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
comment|//	if ((sc->sc_flags& G_RAID_DEVICE_FLAG_NOFAILSYNC) != 0)
comment|//		return;
if|if
condition|(
operator|!
name|vol
operator|->
name|v_dirty
condition|)
return|return;
if|if
condition|(
name|vol
operator|->
name|v_writes
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|acw
operator|>
literal|0
operator|||
operator|(
name|acw
operator|==
operator|-
literal|1
operator|&&
name|vol
operator|->
name|v_provider
operator|!=
name|NULL
operator|&&
name|vol
operator|->
name|v_provider
operator|->
name|acw
operator|>
literal|0
operator|)
condition|)
block|{
name|timeout
operator|=
name|g_raid_clean_time
operator|-
operator|(
name|time_uptime
operator|-
name|vol
operator|->
name|v_last_write
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_raid_shutdown
operator|&&
name|timeout
operator|>
literal|0
condition|)
return|return;
block|}
name|vol
operator|->
name|v_dirty
operator|=
literal|0
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"Volume %s marked as clean."
argument_list|,
name|vol
operator|->
name|v_name
argument_list|)
expr_stmt|;
name|g_raid_write_metadata
argument_list|(
name|sc
argument_list|,
name|vol
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_dirty
parameter_list|(
name|struct
name|g_raid_volume
modifier|*
name|vol
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|vol
operator|->
name|v_softc
expr_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
comment|//	if ((sc->sc_flags& G_RAID_DEVICE_FLAG_NOFAILSYNC) != 0)
comment|//		return;
name|vol
operator|->
name|v_dirty
operator|=
literal|1
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"Volume %s marked as dirty."
argument_list|,
name|vol
operator|->
name|v_name
argument_list|)
expr_stmt|;
name|g_raid_write_metadata
argument_list|(
name|sc
argument_list|,
name|vol
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|g_raid_tr_flush_common
parameter_list|(
name|struct
name|g_raid_tr_object
modifier|*
name|tr
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|struct
name|bio_queue_head
name|queue
decl_stmt|;
name|struct
name|bio
modifier|*
name|cbp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vol
operator|=
name|tr
operator|->
name|tro_volume
expr_stmt|;
name|sc
operator|=
name|vol
operator|->
name|v_softc
expr_stmt|;
comment|/* 	 * Allocate all bios before sending any request, so we can return 	 * ENOMEM in nice and clean way. 	 */
name|bioq_init
argument_list|(
operator|&
name|queue
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vol
operator|->
name|v_disks_count
condition|;
name|i
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_NONE
operator|||
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_FAILED
condition|)
continue|continue;
name|cbp
operator|=
name|g_clone_bio
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cbp
operator|==
name|NULL
condition|)
goto|goto
name|failure
goto|;
name|cbp
operator|->
name|bio_caller1
operator|=
name|sd
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|queue
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|cbp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sd
operator|=
name|cbp
operator|->
name|bio_caller1
expr_stmt|;
name|cbp
operator|->
name|bio_caller1
operator|=
name|NULL
expr_stmt|;
name|g_raid_subdisk_iostart
argument_list|(
name|sd
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
block|}
return|return;
name|failure
label|:
while|while
condition|(
operator|(
name|cbp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|g_destroy_bio
argument_list|(
name|cbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_error
operator|==
literal|0
condition|)
name|bp
operator|->
name|bio_error
operator|=
name|ENOMEM
expr_stmt|;
name|g_raid_iodone
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_tr_kerneldump_common_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|bp
operator|->
name|bio_flags
operator||=
name|BIO_DONE
expr_stmt|;
block|}
end_function

begin_function
name|int
name|g_raid_tr_kerneldump_common
parameter_list|(
name|struct
name|g_raid_tr_object
modifier|*
name|tr
parameter_list|,
name|void
modifier|*
name|virtual
parameter_list|,
name|vm_offset_t
name|physical
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|struct
name|bio
name|bp
decl_stmt|;
name|vol
operator|=
name|tr
operator|->
name|tro_volume
expr_stmt|;
name|sc
operator|=
name|vol
operator|->
name|v_softc
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|bp
argument_list|,
sizeof|sizeof
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|.
name|bio_cmd
operator|=
name|BIO_WRITE
expr_stmt|;
name|bp
operator|.
name|bio_done
operator|=
name|g_raid_tr_kerneldump_common_done
expr_stmt|;
name|bp
operator|.
name|bio_attribute
operator|=
name|NULL
expr_stmt|;
name|bp
operator|.
name|bio_offset
operator|=
name|offset
expr_stmt|;
name|bp
operator|.
name|bio_length
operator|=
name|length
expr_stmt|;
name|bp
operator|.
name|bio_data
operator|=
name|virtual
expr_stmt|;
name|bp
operator|.
name|bio_to
operator|=
name|vol
operator|->
name|v_provider
expr_stmt|;
name|g_raid_start
argument_list|(
operator|&
name|bp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|bp
operator|.
name|bio_flags
operator|&
name|BIO_DONE
operator|)
condition|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|4
argument_list|,
name|sc
argument_list|,
literal|"Poll..."
argument_list|)
expr_stmt|;
name|g_raid_poll
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|bp
operator|.
name|bio_error
operator|!=
literal|0
condition|?
name|EIO
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_dump
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
name|virtual
parameter_list|,
name|vm_offset_t
name|physical
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vol
operator|=
operator|(
expr|struct
name|g_raid_volume
operator|*
operator|)
name|arg
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|3
argument_list|,
name|vol
operator|->
name|v_softc
argument_list|,
literal|"Dumping at off %llu len %llu."
argument_list|,
operator|(
name|long
name|long
name|unsigned
operator|)
name|offset
argument_list|,
operator|(
name|long
name|long
name|unsigned
operator|)
name|length
argument_list|)
expr_stmt|;
name|error
operator|=
name|G_RAID_TR_KERNELDUMP
argument_list|(
name|vol
operator|->
name|v_tr
argument_list|,
name|virtual
argument_list|,
name|physical
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_kerneldump
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_kerneldump
modifier|*
name|gkd
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|gkd
operator|=
operator|(
expr|struct
name|g_kerneldump
operator|*
operator|)
name|bp
operator|->
name|bio_data
expr_stmt|;
name|pp
operator|=
name|bp
operator|->
name|bio_to
expr_stmt|;
name|vol
operator|=
name|pp
operator|->
name|private
expr_stmt|;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"g_raid_kerneldump(%s, %jd, %jd)"
argument_list|,
name|pp
operator|->
name|name
argument_list|,
operator|(
name|intmax_t
operator|)
name|gkd
operator|->
name|offset
argument_list|,
operator|(
name|intmax_t
operator|)
name|gkd
operator|->
name|length
argument_list|)
expr_stmt|;
name|gkd
operator|->
name|di
operator|.
name|dumper
operator|=
name|g_raid_dump
expr_stmt|;
name|gkd
operator|->
name|di
operator|.
name|priv
operator|=
name|vol
expr_stmt|;
name|gkd
operator|->
name|di
operator|.
name|blocksize
operator|=
name|vol
operator|->
name|v_sectorsize
expr_stmt|;
name|gkd
operator|->
name|di
operator|.
name|maxiosize
operator|=
name|DFLTPHYS
expr_stmt|;
name|gkd
operator|->
name|di
operator|.
name|mediaoffset
operator|=
name|gkd
operator|->
name|offset
expr_stmt|;
if|if
condition|(
operator|(
name|gkd
operator|->
name|offset
operator|+
name|gkd
operator|->
name|length
operator|)
operator|>
name|vol
operator|->
name|v_mediasize
condition|)
name|gkd
operator|->
name|length
operator|=
name|vol
operator|->
name|v_mediasize
operator|-
name|gkd
operator|->
name|offset
expr_stmt|;
name|gkd
operator|->
name|di
operator|.
name|mediasize
operator|=
name|gkd
operator|->
name|length
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_candelete
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|int
modifier|*
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|val
operator|=
operator|(
name|int
operator|*
operator|)
name|bp
operator|->
name|bio_data
expr_stmt|;
name|pp
operator|=
name|bp
operator|->
name|bio_to
expr_stmt|;
name|vol
operator|=
name|pp
operator|->
name|private
expr_stmt|;
operator|*
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vol
operator|->
name|v_disks_count
condition|;
name|i
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_NONE
condition|)
continue|continue;
if|if
condition|(
name|sd
operator|->
name|sd_disk
operator|->
name|d_candelete
condition|)
block|{
operator|*
name|val
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_start
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
comment|/* 	 * If sc == NULL or there are no valid disks, provider's error 	 * should be set and g_raid_start() should not be called at all. 	 */
comment|//	KASSERT(sc != NULL&& sc->sc_state == G_RAID_VOLUME_S_RUNNING,
comment|//	    ("Provider's error should be set (error=%d)(mirror=%s).",
comment|//	    bp->bio_to->error, bp->bio_to->name));
name|G_RAID_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Request received."
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
case|case
name|BIO_WRITE
case|:
case|case
name|BIO_DELETE
case|:
case|case
name|BIO_FLUSH
case|:
break|break;
case|case
name|BIO_GETATTR
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|bp
operator|->
name|bio_attribute
argument_list|,
literal|"GEOM::candelete"
argument_list|)
condition|)
name|g_raid_candelete
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|bp
operator|->
name|bio_attribute
argument_list|,
literal|"GEOM::kerneldump"
argument_list|)
condition|)
name|g_raid_kerneldump
argument_list|(
name|sc
argument_list|,
name|bp
argument_list|)
expr_stmt|;
else|else
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
return|return;
default|default:
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
return|return;
block|}
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|bioq_disksort
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dumping
condition|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|4
argument_list|,
name|sc
argument_list|,
literal|"Waking up %p."
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_bio_overlaps
parameter_list|(
specifier|const
name|struct
name|bio
modifier|*
name|bp
parameter_list|,
name|off_t
name|lstart
parameter_list|,
name|off_t
name|len
parameter_list|)
block|{
comment|/* 	 * 5 cases: 	 * (1) bp entirely below NO 	 * (2) bp entirely above NO 	 * (3) bp start below, but end in range YES 	 * (4) bp entirely within YES 	 * (5) bp starts within, ends above YES 	 * 	 * lock range 10-19 (offset 10 length 10) 	 * (1) 1-5: first if kicks it out 	 * (2) 30-35: second if kicks it out 	 * (3) 5-15: passes both ifs 	 * (4) 12-14: passes both ifs 	 * (5) 19-20: passes both 	 */
name|off_t
name|lend
init|=
name|lstart
operator|+
name|len
operator|-
literal|1
decl_stmt|;
name|off_t
name|bstart
init|=
name|bp
operator|->
name|bio_offset
decl_stmt|;
name|off_t
name|bend
init|=
name|bp
operator|->
name|bio_offset
operator|+
name|bp
operator|->
name|bio_length
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|bend
operator|<
name|lstart
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|lend
operator|<
name|bstart
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_is_in_locked_range
parameter_list|(
name|struct
name|g_raid_volume
modifier|*
name|vol
parameter_list|,
specifier|const
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_raid_lock
modifier|*
name|lp
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|vol
operator|->
name|v_softc
operator|->
name|sc_lock
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&vol->v_locks
argument_list|,
argument|l_next
argument_list|)
block|{
if|if
condition|(
name|g_raid_bio_overlaps
argument_list|(
name|bp
argument_list|,
name|lp
operator|->
name|l_offset
argument_list|,
name|lp
operator|->
name|l_length
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_start_request
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
name|vol
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|private
expr_stmt|;
comment|/* 	 * Check to see if this item is in a locked range.  If so, 	 * queue it to our locked queue and return.  We'll requeue 	 * it when the range is unlocked.  Internal I/O for the 	 * rebuild/rescan/recovery process is excluded from this 	 * check so we can actually do the recovery. 	 */
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|bio_cflags
operator|&
name|G_RAID_BIO_FLAG_SPECIAL
operator|)
operator|&&
name|g_raid_is_in_locked_range
argument_list|(
name|vol
argument_list|,
name|bp
argument_list|)
condition|)
block|{
name|G_RAID_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Defer request."
argument_list|)
expr_stmt|;
name|bioq_insert_tail
argument_list|(
operator|&
name|vol
operator|->
name|v_locked
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we're actually going to do the write/delete, then 	 * update the idle stats for the volume. 	 */
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
operator|||
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_DELETE
condition|)
block|{
if|if
condition|(
operator|!
name|vol
operator|->
name|v_dirty
condition|)
name|g_raid_dirty
argument_list|(
name|vol
argument_list|)
expr_stmt|;
name|vol
operator|->
name|v_writes
operator|++
expr_stmt|;
block|}
comment|/* 	 * Put request onto inflight queue, so we can check if new 	 * synchronization requests don't collide with it.  Then tell 	 * the transformation layer to start the I/O. 	 */
name|bioq_insert_tail
argument_list|(
operator|&
name|vol
operator|->
name|v_inflight
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|G_RAID_LOGREQ
argument_list|(
literal|4
argument_list|,
name|bp
argument_list|,
literal|"Request started"
argument_list|)
expr_stmt|;
name|G_RAID_TR_IOSTART
argument_list|(
name|vol
operator|->
name|v_tr
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_finish_with_locked_ranges
parameter_list|(
name|struct
name|g_raid_volume
modifier|*
name|vol
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|off_t
name|off
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|bio
modifier|*
name|nbp
decl_stmt|;
name|struct
name|g_raid_lock
modifier|*
name|lp
decl_stmt|;
name|vol
operator|->
name|v_pending_lock
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&vol->v_locks
argument_list|,
argument|l_next
argument_list|)
block|{
if|if
condition|(
name|lp
operator|->
name|l_pending
condition|)
block|{
name|off
operator|=
name|lp
operator|->
name|l_offset
expr_stmt|;
name|len
operator|=
name|lp
operator|->
name|l_length
expr_stmt|;
name|lp
operator|->
name|l_pending
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|nbp
argument_list|,
argument|&vol->v_inflight.queue
argument_list|,
argument|bio_queue
argument_list|)
block|{
if|if
condition|(
name|g_raid_bio_overlaps
argument_list|(
name|nbp
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
condition|)
name|lp
operator|->
name|l_pending
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lp
operator|->
name|l_pending
condition|)
block|{
name|vol
operator|->
name|v_pending_lock
operator|=
literal|1
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|4
argument_list|,
name|vol
operator|->
name|v_softc
argument_list|,
literal|"Deferred lock(%jd, %jd) has %d pending"
argument_list|,
operator|(
name|intmax_t
operator|)
name|off
argument_list|,
call|(
name|intmax_t
call|)
argument_list|(
name|off
operator|+
name|len
argument_list|)
argument_list|,
name|lp
operator|->
name|l_pending
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|G_RAID_DEBUG1
argument_list|(
literal|4
argument_list|,
name|vol
operator|->
name|v_softc
argument_list|,
literal|"Deferred lock of %jd to %jd completed"
argument_list|,
operator|(
name|intmax_t
operator|)
name|off
argument_list|,
call|(
name|intmax_t
call|)
argument_list|(
name|off
operator|+
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|G_RAID_TR_LOCKED
argument_list|(
name|vol
operator|->
name|v_tr
argument_list|,
name|lp
operator|->
name|l_callback_arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|g_raid_iodone
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|sc
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
name|vol
operator|=
name|bp
operator|->
name|bio_to
operator|->
name|private
expr_stmt|;
name|G_RAID_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Request done: %d."
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* Update stats if we done write/delete. */
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
operator|||
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_DELETE
condition|)
block|{
name|vol
operator|->
name|v_writes
operator|--
expr_stmt|;
name|vol
operator|->
name|v_last_write
operator|=
name|time_uptime
expr_stmt|;
block|}
name|bioq_remove
argument_list|(
operator|&
name|vol
operator|->
name|v_inflight
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vol
operator|->
name|v_pending_lock
operator|&&
name|g_raid_is_in_locked_range
argument_list|(
name|vol
argument_list|,
name|bp
argument_list|)
condition|)
name|g_raid_finish_with_locked_ranges
argument_list|(
name|vol
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|getmicrouptime
argument_list|(
operator|&
name|vol
operator|->
name|v_last_done
argument_list|)
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|g_raid_lock_range
parameter_list|(
name|struct
name|g_raid_volume
modifier|*
name|vol
parameter_list|,
name|off_t
name|off
parameter_list|,
name|off_t
name|len
parameter_list|,
name|struct
name|bio
modifier|*
name|ignore
parameter_list|,
name|void
modifier|*
name|argp
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_lock
modifier|*
name|lp
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|sc
operator|=
name|vol
operator|->
name|v_softc
expr_stmt|;
name|lp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|lp
argument_list|)
argument_list|,
name|M_RAID
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|vol
operator|->
name|v_locks
argument_list|,
name|lp
argument_list|,
name|l_next
argument_list|)
expr_stmt|;
name|lp
operator|->
name|l_offset
operator|=
name|off
expr_stmt|;
name|lp
operator|->
name|l_length
operator|=
name|len
expr_stmt|;
name|lp
operator|->
name|l_callback_arg
operator|=
name|argp
expr_stmt|;
name|lp
operator|->
name|l_pending
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&vol->v_inflight.queue
argument_list|,
argument|bio_queue
argument_list|)
block|{
if|if
condition|(
name|bp
operator|!=
name|ignore
operator|&&
name|g_raid_bio_overlaps
argument_list|(
name|bp
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
condition|)
name|lp
operator|->
name|l_pending
operator|++
expr_stmt|;
block|}
comment|/* 	 * If there are any writes that are pending, we return EBUSY.  All 	 * callers will have to wait until all pending writes clear. 	 */
if|if
condition|(
name|lp
operator|->
name|l_pending
operator|>
literal|0
condition|)
block|{
name|vol
operator|->
name|v_pending_lock
operator|=
literal|1
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|4
argument_list|,
name|sc
argument_list|,
literal|"Locking range %jd to %jd deferred %d pend"
argument_list|,
operator|(
name|intmax_t
operator|)
name|off
argument_list|,
call|(
name|intmax_t
call|)
argument_list|(
name|off
operator|+
name|len
argument_list|)
argument_list|,
name|lp
operator|->
name|l_pending
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|G_RAID_DEBUG1
argument_list|(
literal|4
argument_list|,
name|sc
argument_list|,
literal|"Locking range %jd to %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|off
argument_list|,
call|(
name|intmax_t
call|)
argument_list|(
name|off
operator|+
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|G_RAID_TR_LOCKED
argument_list|(
name|vol
operator|->
name|v_tr
argument_list|,
name|lp
operator|->
name|l_callback_arg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|g_raid_unlock_range
parameter_list|(
name|struct
name|g_raid_volume
modifier|*
name|vol
parameter_list|,
name|off_t
name|off
parameter_list|,
name|off_t
name|len
parameter_list|)
block|{
name|struct
name|g_raid_lock
modifier|*
name|lp
decl_stmt|;
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|sc
operator|=
name|vol
operator|->
name|v_softc
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&vol->v_locks
argument_list|,
argument|l_next
argument_list|)
block|{
if|if
condition|(
name|lp
operator|->
name|l_offset
operator|==
name|off
operator|&&
name|lp
operator|->
name|l_length
operator|==
name|len
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|lp
argument_list|,
name|l_next
argument_list|)
expr_stmt|;
comment|/* XXX 			 * Right now we just put them all back on the queue 			 * and hope for the best.  We hope this because any 			 * locked ranges will go right back on this list 			 * when the worker thread runs. 			 * XXX 			 */
name|G_RAID_DEBUG1
argument_list|(
literal|4
argument_list|,
name|sc
argument_list|,
literal|"Unlocked %jd to %jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|lp
operator|->
name|l_offset
argument_list|,
call|(
name|intmax_t
call|)
argument_list|(
name|lp
operator|->
name|l_offset
operator|+
name|lp
operator|->
name|l_length
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|vol
operator|->
name|v_locked
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|bioq_disksort
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lp
argument_list|,
name|M_RAID
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|g_raid_subdisk_iostart
parameter_list|(
name|struct
name|g_raid_subdisk
modifier|*
name|sd
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|,
modifier|*
name|tdisk
decl_stmt|;
name|bp
operator|->
name|bio_caller1
operator|=
name|sd
expr_stmt|;
comment|/* 	 * Make sure that the disk is present. Generally it is a task of 	 * transformation layers to not send requests to absent disks, but 	 * it is better to be safe and report situation then sorry. 	 */
if|if
condition|(
name|sd
operator|->
name|sd_disk
operator|==
name|NULL
condition|)
block|{
name|G_RAID_LOGREQ
argument_list|(
literal|0
argument_list|,
name|bp
argument_list|,
literal|"Warning! I/O request to an absent disk!"
argument_list|)
expr_stmt|;
name|nodisk
label|:
name|bp
operator|->
name|bio_from
operator|=
name|NULL
expr_stmt|;
name|bp
operator|->
name|bio_to
operator|=
name|NULL
expr_stmt|;
name|bp
operator|->
name|bio_error
operator|=
name|ENXIO
expr_stmt|;
name|g_raid_disk_done
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|disk
operator|=
name|sd
operator|->
name|sd_disk
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_RAID_DISK_S_ACTIVE
operator|&&
name|disk
operator|->
name|d_state
operator|!=
name|G_RAID_DISK_S_FAILED
condition|)
block|{
name|G_RAID_LOGREQ
argument_list|(
literal|0
argument_list|,
name|bp
argument_list|,
literal|"Warning! I/O request to a disk in a "
literal|"wrong state (%s)!"
argument_list|,
name|g_raid_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|nodisk
goto|;
block|}
name|cp
operator|=
name|disk
operator|->
name|d_consumer
expr_stmt|;
name|bp
operator|->
name|bio_from
operator|=
name|cp
expr_stmt|;
name|bp
operator|->
name|bio_to
operator|=
name|cp
operator|->
name|provider
expr_stmt|;
name|cp
operator|->
name|index
operator|++
expr_stmt|;
comment|/* Update average disks load. */
name|TAILQ_FOREACH
argument_list|(
argument|tdisk
argument_list|,
argument|&sd->sd_softc->sc_disks
argument_list|,
argument|d_next
argument_list|)
block|{
if|if
condition|(
name|tdisk
operator|->
name|d_consumer
operator|==
name|NULL
condition|)
name|tdisk
operator|->
name|d_load
operator|=
literal|0
expr_stmt|;
else|else
name|tdisk
operator|->
name|d_load
operator|=
operator|(
name|tdisk
operator|->
name|d_consumer
operator|->
name|index
operator|*
name|G_RAID_SUBDISK_LOAD_SCALE
operator|+
name|tdisk
operator|->
name|d_load
operator|*
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
block|}
name|disk
operator|->
name|d_last_offset
operator|=
name|bp
operator|->
name|bio_offset
operator|+
name|bp
operator|->
name|bio_length
expr_stmt|;
if|if
condition|(
name|dumping
condition|)
block|{
name|G_RAID_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Sending dumping request."
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
condition|)
block|{
name|bp
operator|->
name|bio_error
operator|=
name|g_raid_subdisk_kerneldump
argument_list|(
name|sd
argument_list|,
name|bp
operator|->
name|bio_data
argument_list|,
literal|0
argument_list|,
name|bp
operator|->
name|bio_offset
argument_list|,
name|bp
operator|->
name|bio_length
argument_list|)
expr_stmt|;
block|}
else|else
name|bp
operator|->
name|bio_error
operator|=
name|EOPNOTSUPP
expr_stmt|;
name|g_raid_disk_done
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|bio_done
operator|=
name|g_raid_disk_done
expr_stmt|;
name|bp
operator|->
name|bio_offset
operator|+=
name|sd
operator|->
name|sd_offset
expr_stmt|;
name|G_RAID_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Sending request."
argument_list|)
expr_stmt|;
name|g_io_request
argument_list|(
name|bp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|g_raid_subdisk_kerneldump
parameter_list|(
name|struct
name|g_raid_subdisk
modifier|*
name|sd
parameter_list|,
name|void
modifier|*
name|virtual
parameter_list|,
name|vm_offset_t
name|physical
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
if|if
condition|(
name|sd
operator|->
name|sd_disk
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|sd
operator|->
name|sd_disk
operator|->
name|d_kd
operator|.
name|di
operator|.
name|dumper
operator|==
name|NULL
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
return|return
operator|(
name|dump_write
argument_list|(
operator|&
name|sd
operator|->
name|sd_disk
operator|->
name|d_kd
operator|.
name|di
argument_list|,
name|virtual
argument_list|,
name|physical
argument_list|,
name|sd
operator|->
name|sd_disk
operator|->
name|d_kd
operator|.
name|di
operator|.
name|mediaoffset
operator|+
name|sd
operator|->
name|sd_offset
operator|+
name|offset
argument_list|,
name|length
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_disk_done
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|sd
operator|=
name|bp
operator|->
name|bio_caller1
expr_stmt|;
name|sc
operator|=
name|sd
operator|->
name|sd_softc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|bioq_disksort
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dumping
condition|)
name|wakeup
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_disk_done_request
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|G_RAID_LOGREQ
argument_list|(
literal|3
argument_list|,
name|bp
argument_list|,
literal|"Disk request done: %d."
argument_list|,
name|bp
operator|->
name|bio_error
argument_list|)
expr_stmt|;
name|sd
operator|=
name|bp
operator|->
name|bio_caller1
expr_stmt|;
name|sc
operator|=
name|sd
operator|->
name|sd_softc
expr_stmt|;
name|vol
operator|=
name|sd
operator|->
name|sd_volume
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_from
operator|!=
name|NULL
condition|)
block|{
name|bp
operator|->
name|bio_from
operator|->
name|index
operator|--
expr_stmt|;
name|disk
operator|=
name|bp
operator|->
name|bio_from
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
name|g_raid_kill_consumer
argument_list|(
name|sc
argument_list|,
name|bp
operator|->
name|bio_from
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|bio_offset
operator|-=
name|sd
operator|->
name|sd_offset
expr_stmt|;
name|G_RAID_TR_IODONE
argument_list|(
name|vol
operator|->
name|v_tr
argument_list|,
name|sd
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_handle_event
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_raid_event
modifier|*
name|ep
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_RAID_EVENT_VOLUME
operator|)
operator|!=
literal|0
condition|)
name|ep
operator|->
name|e_error
operator|=
name|g_raid_update_volume
argument_list|(
name|ep
operator|->
name|e_tgt
argument_list|,
name|ep
operator|->
name|e_event
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_RAID_EVENT_DISK
operator|)
operator|!=
literal|0
condition|)
name|ep
operator|->
name|e_error
operator|=
name|g_raid_update_disk
argument_list|(
name|ep
operator|->
name|e_tgt
argument_list|,
name|ep
operator|->
name|e_event
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_RAID_EVENT_SUBDISK
operator|)
operator|!=
literal|0
condition|)
name|ep
operator|->
name|e_error
operator|=
name|g_raid_update_subdisk
argument_list|(
name|ep
operator|->
name|e_tgt
argument_list|,
name|ep
operator|->
name|e_event
argument_list|)
expr_stmt|;
else|else
name|ep
operator|->
name|e_error
operator|=
name|g_raid_update_node
argument_list|(
name|ep
operator|->
name|e_tgt
argument_list|,
name|ep
operator|->
name|e_event
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ep
operator|->
name|e_flags
operator|&
name|G_RAID_EVENT_WAIT
operator|)
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|ep
operator|->
name|e_error
operator|==
literal|0
argument_list|,
operator|(
literal|"Error cannot be handled."
operator|)
argument_list|)
expr_stmt|;
name|g_raid_event_free
argument_list|(
name|ep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ep
operator|->
name|e_flags
operator||=
name|G_RAID_EVENT_DONE
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|4
argument_list|,
name|sc
argument_list|,
literal|"Waking up %p."
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|ep
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Worker thread.  */
end_comment

begin_function
specifier|static
name|void
name|g_raid_worker
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_event
modifier|*
name|ep
decl_stmt|;
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|,
name|t
decl_stmt|;
name|int
name|timeout
decl_stmt|,
name|rv
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_prio
argument_list|(
name|curthread
argument_list|,
name|PRIBIO
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
comment|/* 		 * First take a look at events. 		 * This is important to handle events before any I/O requests. 		 */
name|bp
operator|=
name|NULL
expr_stmt|;
name|vol
operator|=
name|NULL
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
name|ep
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_events
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_events
argument_list|,
name|ep
argument_list|,
name|e_next
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|bp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
empty_stmt|;
else|else
block|{
name|getmicrouptime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|t
operator|=
name|now
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vol
argument_list|,
argument|&sc->sc_volumes
argument_list|,
argument|v_next
argument_list|)
block|{
if|if
condition|(
name|bioq_first
argument_list|(
operator|&
name|vol
operator|->
name|v_inflight
argument_list|)
operator|==
name|NULL
operator|&&
name|vol
operator|->
name|v_tr
operator|&&
name|timevalcmp
argument_list|(
operator|&
name|vol
operator|->
name|v_last_done
argument_list|,
operator|&
name|t
argument_list|,
operator|<
argument_list|)
condition|)
name|t
operator|=
name|vol
operator|->
name|v_last_done
expr_stmt|;
block|}
name|timevalsub
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|g_raid_idle_threshold
operator|+
name|t
operator|.
name|tv_sec
operator|*
literal|1000000
operator|+
name|t
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|timeout
operator|>
literal|0
condition|)
block|{
comment|/* 				 * Two steps to avoid overflows at HZ=1000 				 * and idle timeouts> 2.1s.  Some rounding 				 * errors can occur, but they are< 1tick, 				 * which is deemed to be close enough for 				 * this purpose. 				 */
name|int
name|micpertic
init|=
literal|1000000
operator|/
name|hz
decl_stmt|;
name|timeout
operator|=
operator|(
name|timeout
operator|+
name|micpertic
operator|-
literal|1
operator|)
operator|/
name|micpertic
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|MSLEEP
argument_list|(
name|rv
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|,
name|PRIBIO
operator||
name|PDROP
argument_list|,
literal|"-"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
goto|goto
name|process
goto|;
block|}
else|else
name|rv
operator|=
name|EWOULDBLOCK
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|process
label|:
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
block|{
name|g_raid_handle_event
argument_list|(
name|sc
argument_list|,
name|ep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_to
operator|!=
name|NULL
operator|&&
name|bp
operator|->
name|bio_to
operator|->
name|geom
operator|==
name|sc
operator|->
name|sc_geom
condition|)
name|g_raid_start_request
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
name|g_raid_disk_done_request
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rv
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|vol
argument_list|,
argument|&sc->sc_volumes
argument_list|,
argument|v_next
argument_list|)
block|{
name|g_raid_clean
argument_list|(
name|vol
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bioq_first
argument_list|(
operator|&
name|vol
operator|->
name|v_inflight
argument_list|)
operator|==
name|NULL
operator|&&
name|vol
operator|->
name|v_tr
condition|)
block|{
name|t
operator|.
name|tv_sec
operator|=
name|g_raid_idle_threshold
operator|/
literal|1000000
expr_stmt|;
name|t
operator|.
name|tv_usec
operator|=
name|g_raid_idle_threshold
operator|%
literal|1000000
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|vol
operator|->
name|v_last_done
argument_list|)
expr_stmt|;
name|getmicrouptime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|now
argument_list|,
operator|<=
argument_list|)
condition|)
block|{
name|G_RAID_TR_IDLE
argument_list|(
name|vol
operator|->
name|v_tr
argument_list|)
expr_stmt|;
name|vol
operator|->
name|v_last_done
operator|=
name|now
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sc_stopping
operator|==
name|G_RAID_DESTROY_HARD
condition|)
name|g_raid_destroy_node
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* May not return. */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_poll
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_raid_event
modifier|*
name|ep
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * First take a look at events. 	 * This is important to handle events before any I/O requests. 	 */
name|ep
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_events
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_events
argument_list|,
name|ep
argument_list|,
name|e_next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|g_raid_handle_event
argument_list|(
name|sc
argument_list|,
name|ep
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bp
operator|=
name|bioq_takefirst
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_from
operator|==
name|NULL
operator|||
name|bp
operator|->
name|bio_from
operator|->
name|geom
operator|!=
name|sc
operator|->
name|sc_geom
condition|)
name|g_raid_start_request
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
name|g_raid_disk_done_request
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_launch_provider
parameter_list|(
name|struct
name|g_raid_volume
modifier|*
name|vol
parameter_list|)
block|{
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|char
name|name
index|[
name|G_RAID_MAX_VOLUMENAME
index|]
decl_stmt|;
name|char
name|announce_buf
index|[
literal|80
index|]
decl_stmt|,
name|buf1
index|[
literal|32
index|]
decl_stmt|;
name|off_t
name|off
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|vol
operator|->
name|v_softc
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
comment|/* Try to name provider with volume name. */
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"raid/%s"
argument_list|,
name|vol
operator|->
name|v_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_raid_name_format
operator|==
literal|0
operator|||
name|vol
operator|->
name|v_name
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|g_provider_by_name
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Otherwise use sequential volume number. */
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"raid/r%d"
argument_list|,
name|vol
operator|->
name|v_global_id
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create a /dev/ar%d that the old ataraid(4) stack once 	 * created as an alias for /dev/raid/r%d if requested. 	 * This helps going from stable/7 ataraid devices to newer 	 * FreeBSD releases. sbruno 07 MAY 2013 	 */
if|if
condition|(
name|ar_legacy_aliases
condition|)
block|{
name|snprintf
argument_list|(
name|announce_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|announce_buf
argument_list|)
argument_list|,
literal|"kern.devalias.%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf1
argument_list|)
argument_list|,
literal|"ar%d"
argument_list|,
name|vol
operator|->
name|v_global_id
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
name|announce_buf
argument_list|,
name|buf1
argument_list|)
expr_stmt|;
block|}
name|pp
operator|=
name|g_new_providerf
argument_list|(
name|sc
operator|->
name|sc_geom
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pp
operator|->
name|flags
operator||=
name|G_PF_DIRECT_RECEIVE
expr_stmt|;
if|if
condition|(
name|vol
operator|->
name|v_tr
operator|->
name|tro_class
operator|->
name|trc_accept_unmapped
condition|)
block|{
name|pp
operator|->
name|flags
operator||=
name|G_PF_ACCEPT_UNMAPPED
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vol
operator|->
name|v_disks_count
condition|;
name|i
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_NONE
condition|)
continue|continue;
if|if
condition|(
operator|(
name|sd
operator|->
name|sd_disk
operator|->
name|d_consumer
operator|->
name|provider
operator|->
name|flags
operator|&
name|G_PF_ACCEPT_UNMAPPED
operator|)
operator|==
literal|0
condition|)
name|pp
operator|->
name|flags
operator|&=
operator|~
name|G_PF_ACCEPT_UNMAPPED
expr_stmt|;
block|}
block|}
name|pp
operator|->
name|private
operator|=
name|vol
expr_stmt|;
name|pp
operator|->
name|mediasize
operator|=
name|vol
operator|->
name|v_mediasize
expr_stmt|;
name|pp
operator|->
name|sectorsize
operator|=
name|vol
operator|->
name|v_sectorsize
expr_stmt|;
name|pp
operator|->
name|stripesize
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|stripeoffset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID1
operator|||
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID3
operator|||
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_SINGLE
operator|||
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_CONCAT
condition|)
block|{
if|if
condition|(
operator|(
name|disk
operator|=
name|vol
operator|->
name|v_subdisks
index|[
literal|0
index|]
operator|.
name|sd_disk
operator|)
operator|!=
name|NULL
operator|&&
name|disk
operator|->
name|d_consumer
operator|!=
name|NULL
operator|&&
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|!=
name|NULL
condition|)
block|{
name|pp
operator|->
name|stripesize
operator|=
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|->
name|stripesize
expr_stmt|;
name|off
operator|=
name|disk
operator|->
name|d_consumer
operator|->
name|provider
operator|->
name|stripeoffset
expr_stmt|;
name|pp
operator|->
name|stripeoffset
operator|=
name|off
operator|+
name|vol
operator|->
name|v_subdisks
index|[
literal|0
index|]
operator|.
name|sd_offset
expr_stmt|;
if|if
condition|(
name|off
operator|>
literal|0
condition|)
name|pp
operator|->
name|stripeoffset
operator|%=
name|off
expr_stmt|;
block|}
if|if
condition|(
name|vol
operator|->
name|v_raid_level
operator|==
name|G_RAID_VOLUME_RL_RAID3
condition|)
block|{
name|pp
operator|->
name|stripesize
operator|*=
operator|(
name|vol
operator|->
name|v_disks_count
operator|-
literal|1
operator|)
expr_stmt|;
name|pp
operator|->
name|stripeoffset
operator|*=
operator|(
name|vol
operator|->
name|v_disks_count
operator|-
literal|1
operator|)
expr_stmt|;
block|}
block|}
else|else
name|pp
operator|->
name|stripesize
operator|=
name|vol
operator|->
name|v_strip_size
expr_stmt|;
name|vol
operator|->
name|v_provider
operator|=
name|pp
expr_stmt|;
name|g_error_provider
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|0
argument_list|,
name|sc
argument_list|,
literal|"Provider %s for volume %s created."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|vol
operator|->
name|v_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_destroy_provider
parameter_list|(
name|struct
name|g_raid_volume
modifier|*
name|vol
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_provider
modifier|*
name|pp
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
name|sc
operator|=
name|vol
operator|->
name|v_softc
expr_stmt|;
name|pp
operator|=
name|vol
operator|->
name|v_provider
expr_stmt|;
name|KASSERT
argument_list|(
name|pp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL provider (volume=%s)."
operator|,
name|vol
operator|->
name|v_name
operator|)
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_error_provider
argument_list|(
name|pp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|bp
argument_list|,
argument|&sc->sc_queue.queue
argument_list|,
argument|bio_queue
argument_list|,
argument|tmp
argument_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_to
operator|!=
name|pp
condition|)
continue|continue;
name|bioq_remove
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|g_io_deliver
argument_list|(
name|bp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|0
argument_list|,
name|sc
argument_list|,
literal|"Provider %s for volume %s destroyed."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|vol
operator|->
name|v_name
argument_list|)
expr_stmt|;
name|g_wither_provider
argument_list|(
name|pp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|vol
operator|->
name|v_provider
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update device state.  */
end_comment

begin_function
specifier|static
name|int
name|g_raid_update_volume
parameter_list|(
name|struct
name|g_raid_volume
modifier|*
name|vol
parameter_list|,
name|u_int
name|event
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|vol
operator|->
name|v_softc
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|2
argument_list|,
name|sc
argument_list|,
literal|"Event %s for volume %s."
argument_list|,
name|g_raid_volume_event2str
argument_list|(
name|event
argument_list|)
argument_list|,
name|vol
operator|->
name|v_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
condition|)
block|{
case|case
name|G_RAID_VOLUME_E_DOWN
case|:
if|if
condition|(
name|vol
operator|->
name|v_provider
operator|!=
name|NULL
condition|)
name|g_raid_destroy_provider
argument_list|(
name|vol
argument_list|)
expr_stmt|;
break|break;
case|case
name|G_RAID_VOLUME_E_UP
case|:
if|if
condition|(
name|vol
operator|->
name|v_provider
operator|==
name|NULL
condition|)
name|g_raid_launch_provider
argument_list|(
name|vol
argument_list|)
expr_stmt|;
break|break;
case|case
name|G_RAID_VOLUME_E_START
case|:
if|if
condition|(
name|vol
operator|->
name|v_tr
condition|)
name|G_RAID_TR_START
argument_list|(
name|vol
operator|->
name|v_tr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
if|if
condition|(
name|sc
operator|->
name|sc_md
condition|)
name|G_RAID_MD_VOLUME_EVENT
argument_list|(
name|sc
operator|->
name|sc_md
argument_list|,
name|vol
argument_list|,
name|event
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Manage root mount release. */
if|if
condition|(
name|vol
operator|->
name|v_starting
condition|)
block|{
name|vol
operator|->
name|v_starting
operator|=
literal|0
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"root_mount_rel %p"
argument_list|,
name|vol
operator|->
name|v_rootmount
argument_list|)
expr_stmt|;
name|root_mount_rel
argument_list|(
name|vol
operator|->
name|v_rootmount
argument_list|)
expr_stmt|;
name|vol
operator|->
name|v_rootmount
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|vol
operator|->
name|v_stopping
operator|&&
name|vol
operator|->
name|v_provider_open
operator|==
literal|0
condition|)
name|g_raid_destroy_volume
argument_list|(
name|vol
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update subdisk state.  */
end_comment

begin_function
specifier|static
name|int
name|g_raid_update_subdisk
parameter_list|(
name|struct
name|g_raid_subdisk
modifier|*
name|sd
parameter_list|,
name|u_int
name|event
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|sc
operator|=
name|sd
operator|->
name|sd_softc
expr_stmt|;
name|vol
operator|=
name|sd
operator|->
name|sd_volume
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|2
argument_list|,
name|sc
argument_list|,
literal|"Event %s for subdisk %s:%d-%s."
argument_list|,
name|g_raid_subdisk_event2str
argument_list|(
name|event
argument_list|)
argument_list|,
name|vol
operator|->
name|v_name
argument_list|,
name|sd
operator|->
name|sd_pos
argument_list|,
name|sd
operator|->
name|sd_disk
condition|?
name|g_raid_get_diskname
argument_list|(
name|sd
operator|->
name|sd_disk
argument_list|)
else|:
literal|"[none]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vol
operator|->
name|v_tr
condition|)
name|G_RAID_TR_EVENT
argument_list|(
name|vol
operator|->
name|v_tr
argument_list|,
name|sd
argument_list|,
name|event
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update disk state.  */
end_comment

begin_function
specifier|static
name|int
name|g_raid_update_disk
parameter_list|(
name|struct
name|g_raid_disk
modifier|*
name|disk
parameter_list|,
name|u_int
name|event
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|2
argument_list|,
name|sc
argument_list|,
literal|"Event %s for disk %s."
argument_list|,
name|g_raid_disk_event2str
argument_list|(
name|event
argument_list|)
argument_list|,
name|g_raid_get_diskname
argument_list|(
name|disk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_md
condition|)
name|G_RAID_MD_EVENT
argument_list|(
name|sc
operator|->
name|sc_md
argument_list|,
name|disk
argument_list|,
name|event
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Node event.  */
end_comment

begin_function
specifier|static
name|int
name|g_raid_update_node
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|event
parameter_list|)
block|{
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|2
argument_list|,
name|sc
argument_list|,
literal|"Event %s for the array."
argument_list|,
name|g_raid_node_event2str
argument_list|(
name|event
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|G_RAID_NODE_E_WAKE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_md
condition|)
name|G_RAID_MD_EVENT
argument_list|(
name|sc
operator|->
name|sc_md
argument_list|,
name|NULL
argument_list|,
name|event
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_access
parameter_list|(
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|acr
parameter_list|,
name|int
name|acw
parameter_list|,
name|int
name|ace
parameter_list|)
block|{
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|dcw
decl_stmt|,
name|opens
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|sc
operator|=
name|pp
operator|->
name|geom
operator|->
name|softc
expr_stmt|;
name|vol
operator|=
name|pp
operator|->
name|private
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL softc (provider=%s)."
operator|,
name|pp
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vol
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL volume (provider=%s)."
operator|,
name|pp
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|2
argument_list|,
name|sc
argument_list|,
literal|"Access request for %s: r%dw%de%d."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|acr
argument_list|,
name|acw
argument_list|,
name|ace
argument_list|)
expr_stmt|;
name|dcw
operator|=
name|pp
operator|->
name|acw
operator|+
name|acw
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
comment|/* Deny new opens while dying. */
if|if
condition|(
name|sc
operator|->
name|sc_stopping
operator|!=
literal|0
operator|&&
operator|(
name|acr
operator|>
literal|0
operator|||
name|acw
operator|>
literal|0
operator|||
name|ace
operator|>
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Deny write opens for read-only volumes. */
if|if
condition|(
name|vol
operator|->
name|v_read_only
operator|&&
name|acw
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|dcw
operator|==
literal|0
condition|)
name|g_raid_clean
argument_list|(
name|vol
argument_list|,
name|dcw
argument_list|)
expr_stmt|;
name|vol
operator|->
name|v_provider_open
operator|+=
name|acr
operator|+
name|acw
operator|+
name|ace
expr_stmt|;
comment|/* Handle delayed node destruction. */
if|if
condition|(
name|sc
operator|->
name|sc_stopping
operator|==
name|G_RAID_DESTROY_DELAYED
operator|&&
name|vol
operator|->
name|v_provider_open
operator|==
literal|0
condition|)
block|{
comment|/* Count open volumes. */
name|opens
operator|=
name|g_raid_nopens
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|opens
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_stopping
operator|=
name|G_RAID_DESTROY_HARD
expr_stmt|;
comment|/* Wake up worker to make it selfdestruct. */
name|g_raid_event_send
argument_list|(
name|sc
argument_list|,
name|G_RAID_NODE_E_WAKE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Handle open volume destruction. */
if|if
condition|(
name|vol
operator|->
name|v_stopping
operator|&&
name|vol
operator|->
name|v_provider_open
operator|==
literal|0
condition|)
name|g_raid_destroy_volume
argument_list|(
name|vol
argument_list|)
expr_stmt|;
name|out
label|:
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|g_raid_softc
modifier|*
name|g_raid_create_node
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|g_raid_md_object
modifier|*
name|md
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Creating array %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|gp
operator|=
name|g_new_geomf
argument_list|(
name|mp
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_RAID
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|gp
operator|->
name|start
operator|=
name|g_raid_start
expr_stmt|;
name|gp
operator|->
name|orphan
operator|=
name|g_raid_orphan
expr_stmt|;
name|gp
operator|->
name|access
operator|=
name|g_raid_access
expr_stmt|;
name|gp
operator|->
name|dumpconf
operator|=
name|g_raid_dumpconf
expr_stmt|;
name|sc
operator|->
name|sc_md
operator|=
name|md
expr_stmt|;
name|sc
operator|->
name|sc_geom
operator|=
name|gp
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_volumes
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_disks
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
literal|"graid:lock"
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|,
literal|"graid:queue"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_events
argument_list|)
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue
argument_list|)
expr_stmt|;
name|gp
operator|->
name|softc
operator|=
name|sc
expr_stmt|;
name|error
operator|=
name|kproc_create
argument_list|(
name|g_raid_worker
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|sc_worker
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"g_raid %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Cannot create kernel thread for %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|g_destroy_geom
argument_list|(
name|sc
operator|->
name|sc_geom
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_RAID
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|G_RAID_DEBUG1
argument_list|(
literal|0
argument_list|,
name|sc
argument_list|,
literal|"Array %s created."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|g_raid_volume
modifier|*
name|g_raid_create_volume
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|id
parameter_list|)
block|{
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|,
modifier|*
name|vol1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"Creating volume %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|vol
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vol
argument_list|)
argument_list|,
name|M_RAID
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|vol
operator|->
name|v_softc
operator|=
name|sc
expr_stmt|;
name|strlcpy
argument_list|(
name|vol
operator|->
name|v_name
argument_list|,
name|name
argument_list|,
name|G_RAID_MAX_VOLUMENAME
argument_list|)
expr_stmt|;
name|vol
operator|->
name|v_state
operator|=
name|G_RAID_VOLUME_S_STARTING
expr_stmt|;
name|vol
operator|->
name|v_raid_level
operator|=
name|G_RAID_VOLUME_RL_UNKNOWN
expr_stmt|;
name|vol
operator|->
name|v_raid_level_qualifier
operator|=
name|G_RAID_VOLUME_RLQ_UNKNOWN
expr_stmt|;
name|vol
operator|->
name|v_rotate_parity
operator|=
literal|1
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|vol
operator|->
name|v_inflight
argument_list|)
expr_stmt|;
name|bioq_init
argument_list|(
operator|&
name|vol
operator|->
name|v_locked
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|vol
operator|->
name|v_locks
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|G_RAID_MAX_SUBDISKS
condition|;
name|i
operator|++
control|)
block|{
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
operator|.
name|sd_softc
operator|=
name|sc
expr_stmt|;
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
operator|.
name|sd_volume
operator|=
name|vol
expr_stmt|;
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
operator|.
name|sd_pos
operator|=
name|i
expr_stmt|;
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
operator|.
name|sd_state
operator|=
name|G_RAID_DISK_S_NONE
expr_stmt|;
block|}
comment|/* Find free ID for this volume. */
name|g_topology_lock
argument_list|()
expr_stmt|;
name|vol1
operator|=
name|vol
expr_stmt|;
if|if
condition|(
name|id
operator|>=
literal|0
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|vol1
argument_list|,
argument|&g_raid_volumes
argument_list|,
argument|v_global_next
argument_list|)
block|{
if|if
condition|(
name|vol1
operator|->
name|v_global_id
operator|==
name|id
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|vol1
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|id
operator|=
literal|0
init|;
condition|;
name|id
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|vol1
argument_list|,
argument|&g_raid_volumes
argument_list|,
argument|v_global_next
argument_list|)
block|{
if|if
condition|(
name|vol1
operator|->
name|v_global_id
operator|==
name|id
condition|)
break|break;
block|}
if|if
condition|(
name|vol1
operator|==
name|NULL
condition|)
break|break;
block|}
block|}
name|vol
operator|->
name|v_global_id
operator|=
name|id
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|g_raid_volumes
argument_list|,
name|vol
argument_list|,
name|v_global_next
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
comment|/* Delay root mounting. */
name|vol
operator|->
name|v_rootmount
operator|=
name|root_mount_hold
argument_list|(
literal|"GRAID"
argument_list|)
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"root_mount_hold %p"
argument_list|,
name|vol
operator|->
name|v_rootmount
argument_list|)
expr_stmt|;
name|vol
operator|->
name|v_starting
operator|=
literal|1
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_volumes
argument_list|,
name|vol
argument_list|,
name|v_next
argument_list|)
expr_stmt|;
return|return
operator|(
name|vol
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|g_raid_disk
modifier|*
name|g_raid_create_disk
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"Creating disk."
argument_list|)
expr_stmt|;
name|disk
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|disk
argument_list|)
argument_list|,
name|M_RAID
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_softc
operator|=
name|sc
expr_stmt|;
name|disk
operator|->
name|d_state
operator|=
name|G_RAID_DISK_S_NONE
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|disk
operator|->
name|d_subdisks
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_disks
argument_list|,
name|disk
argument_list|,
name|d_next
argument_list|)
expr_stmt|;
return|return
operator|(
name|disk
operator|)
return|;
block|}
end_function

begin_function
name|int
name|g_raid_start_volume
parameter_list|(
name|struct
name|g_raid_volume
modifier|*
name|vol
parameter_list|)
block|{
name|struct
name|g_raid_tr_class
modifier|*
name|class
decl_stmt|;
name|struct
name|g_raid_tr_object
modifier|*
name|obj
decl_stmt|;
name|int
name|status
decl_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|2
argument_list|,
name|vol
operator|->
name|v_softc
argument_list|,
literal|"Starting volume %s."
argument_list|,
name|vol
operator|->
name|v_name
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|class
argument_list|,
argument|&g_raid_tr_classes
argument_list|,
argument|trc_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|class
operator|->
name|trc_enable
condition|)
continue|continue;
name|G_RAID_DEBUG1
argument_list|(
literal|2
argument_list|,
name|vol
operator|->
name|v_softc
argument_list|,
literal|"Tasting volume %s for %s transformation."
argument_list|,
name|vol
operator|->
name|v_name
argument_list|,
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
name|obj
operator|=
operator|(
name|void
operator|*
operator|)
name|kobj_create
argument_list|(
operator|(
name|kobj_class_t
operator|)
name|class
argument_list|,
name|M_RAID
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|obj
operator|->
name|tro_class
operator|=
name|class
expr_stmt|;
name|obj
operator|->
name|tro_volume
operator|=
name|vol
expr_stmt|;
name|status
operator|=
name|G_RAID_TR_TASTE
argument_list|(
name|obj
argument_list|,
name|vol
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|G_RAID_TR_TASTE_FAIL
condition|)
break|break;
name|kobj_delete
argument_list|(
operator|(
name|kobj_t
operator|)
name|obj
argument_list|,
name|M_RAID
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|class
operator|==
name|NULL
condition|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|0
argument_list|,
name|vol
operator|->
name|v_softc
argument_list|,
literal|"No transformation module found for %s."
argument_list|,
name|vol
operator|->
name|v_name
argument_list|)
expr_stmt|;
name|vol
operator|->
name|v_tr
operator|=
name|NULL
expr_stmt|;
name|g_raid_change_volume_state
argument_list|(
name|vol
argument_list|,
name|G_RAID_VOLUME_S_UNSUPPORTED
argument_list|)
expr_stmt|;
name|g_raid_event_send
argument_list|(
name|vol
argument_list|,
name|G_RAID_VOLUME_E_DOWN
argument_list|,
name|G_RAID_EVENT_VOLUME
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|G_RAID_DEBUG1
argument_list|(
literal|2
argument_list|,
name|vol
operator|->
name|v_softc
argument_list|,
literal|"Transformation module %s chosen for %s."
argument_list|,
name|class
operator|->
name|name
argument_list|,
name|vol
operator|->
name|v_name
argument_list|)
expr_stmt|;
name|vol
operator|->
name|v_tr
operator|=
name|obj
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|g_raid_destroy_node
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|,
name|int
name|worker
parameter_list|)
block|{
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|,
modifier|*
name|tmpv
decl_stmt|;
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|,
modifier|*
name|tmpd
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|sc
operator|->
name|sc_stopping
operator|=
name|G_RAID_DESTROY_HARD
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|vol
argument_list|,
argument|&sc->sc_volumes
argument_list|,
argument|v_next
argument_list|,
argument|tmpv
argument_list|)
block|{
if|if
condition|(
name|g_raid_destroy_volume
argument_list|(
name|vol
argument_list|)
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|disk
argument_list|,
argument|&sc->sc_disks
argument_list|,
argument|d_next
argument_list|,
argument|tmpd
argument_list|)
block|{
if|if
condition|(
name|g_raid_destroy_disk
argument_list|(
name|disk
argument_list|)
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_md
condition|)
block|{
name|G_RAID_MD_FREE
argument_list|(
name|sc
operator|->
name|sc_md
argument_list|)
expr_stmt|;
name|kobj_delete
argument_list|(
operator|(
name|kobj_t
operator|)
name|sc
operator|->
name|sc_md
argument_list|,
name|M_RAID
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_md
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_geom
operator|!=
name|NULL
condition|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|0
argument_list|,
name|sc
argument_list|,
literal|"Array %s destroyed."
argument_list|,
name|sc
operator|->
name|sc_name
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_geom
operator|->
name|softc
operator|=
name|NULL
expr_stmt|;
name|g_wither_geom
argument_list|(
name|sc
operator|->
name|sc_geom
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_geom
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Array destroyed."
argument_list|)
expr_stmt|;
if|if
condition|(
name|worker
condition|)
block|{
name|g_raid_event_cancel
argument_list|(
name|sc
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_queue_mtx
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|sc
operator|->
name|sc_stopping
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_RAID
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|td_pflags
operator|&=
operator|~
name|TDP_GEOM
expr_stmt|;
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"Thread exiting."
argument_list|)
expr_stmt|;
name|kproc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Wake up worker to make it selfdestruct. */
name|g_raid_event_send
argument_list|(
name|sc
argument_list|,
name|G_RAID_NODE_E_WAKE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|g_raid_destroy_volume
parameter_list|(
name|struct
name|g_raid_volume
modifier|*
name|vol
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|vol
operator|->
name|v_softc
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|2
argument_list|,
name|sc
argument_list|,
literal|"Destroying volume %s."
argument_list|,
name|vol
operator|->
name|v_name
argument_list|)
expr_stmt|;
name|vol
operator|->
name|v_stopping
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|vol
operator|->
name|v_state
operator|!=
name|G_RAID_VOLUME_S_STOPPED
condition|)
block|{
if|if
condition|(
name|vol
operator|->
name|v_tr
condition|)
block|{
name|G_RAID_TR_STOP
argument_list|(
name|vol
operator|->
name|v_tr
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
else|else
name|vol
operator|->
name|v_state
operator|=
name|G_RAID_VOLUME_S_STOPPED
expr_stmt|;
block|}
if|if
condition|(
name|g_raid_event_check
argument_list|(
name|sc
argument_list|,
name|vol
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|vol
operator|->
name|v_provider
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|vol
operator|->
name|v_provider_open
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|vol
operator|->
name|v_tr
condition|)
block|{
name|G_RAID_TR_FREE
argument_list|(
name|vol
operator|->
name|v_tr
argument_list|)
expr_stmt|;
name|kobj_delete
argument_list|(
operator|(
name|kobj_t
operator|)
name|vol
operator|->
name|v_tr
argument_list|,
name|M_RAID
argument_list|)
expr_stmt|;
name|vol
operator|->
name|v_tr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|vol
operator|->
name|v_rootmount
condition|)
name|root_mount_rel
argument_list|(
name|vol
operator|->
name|v_rootmount
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|vol
argument_list|,
name|v_global_next
argument_list|)
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_volumes
argument_list|,
name|vol
argument_list|,
name|v_next
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|G_RAID_MAX_SUBDISKS
condition|;
name|i
operator|++
control|)
block|{
name|g_raid_event_cancel
argument_list|(
name|sc
argument_list|,
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|disk
operator|=
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
operator|.
name|sd_disk
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
continue|continue;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|disk
operator|->
name|d_subdisks
argument_list|,
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
argument_list|,
name|sd_next
argument_list|)
expr_stmt|;
block|}
name|G_RAID_DEBUG1
argument_list|(
literal|2
argument_list|,
name|sc
argument_list|,
literal|"Volume %s destroyed."
argument_list|,
name|vol
operator|->
name|v_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_md
condition|)
name|G_RAID_MD_FREE_VOLUME
argument_list|(
name|sc
operator|->
name|sc_md
argument_list|,
name|vol
argument_list|)
expr_stmt|;
name|g_raid_event_cancel
argument_list|(
name|sc
argument_list|,
name|vol
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vol
argument_list|,
name|M_RAID
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_stopping
operator|==
name|G_RAID_DESTROY_HARD
condition|)
block|{
comment|/* Wake up worker to let it selfdestruct. */
name|g_raid_event_send
argument_list|(
name|sc
argument_list|,
name|G_RAID_NODE_E_WAKE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|g_raid_destroy_disk
parameter_list|(
name|struct
name|g_raid_disk
modifier|*
name|disk
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|sc
operator|=
name|disk
operator|->
name|d_softc
expr_stmt|;
name|G_RAID_DEBUG1
argument_list|(
literal|2
argument_list|,
name|sc
argument_list|,
literal|"Destroying disk."
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk
operator|->
name|d_consumer
condition|)
block|{
name|g_raid_kill_consumer
argument_list|(
name|sc
argument_list|,
name|disk
operator|->
name|d_consumer
argument_list|)
expr_stmt|;
name|disk
operator|->
name|d_consumer
operator|=
name|NULL
expr_stmt|;
block|}
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|sd
argument_list|,
argument|&disk->d_subdisks
argument_list|,
argument|sd_next
argument_list|,
argument|tmp
argument_list|)
block|{
name|g_raid_change_subdisk_state
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_S_NONE
argument_list|)
expr_stmt|;
name|g_raid_event_send
argument_list|(
name|sd
argument_list|,
name|G_RAID_SUBDISK_E_DISCONNECTED
argument_list|,
name|G_RAID_EVENT_SUBDISK
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|disk
operator|->
name|d_subdisks
argument_list|,
name|sd
argument_list|,
name|sd_next
argument_list|)
expr_stmt|;
name|sd
operator|->
name|sd_disk
operator|=
name|NULL
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_disks
argument_list|,
name|disk
argument_list|,
name|d_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_md
condition|)
name|G_RAID_MD_FREE_DISK
argument_list|(
name|sc
operator|->
name|sc_md
argument_list|,
name|disk
argument_list|)
expr_stmt|;
name|g_raid_event_cancel
argument_list|(
name|sc
argument_list|,
name|disk
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|disk
argument_list|,
name|M_RAID
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|g_raid_destroy
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|opens
decl_stmt|;
name|g_topology_assert_not
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
comment|/* Count open volumes. */
name|opens
operator|=
name|g_raid_nopens
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* React on some opened volumes. */
if|if
condition|(
name|opens
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|how
condition|)
block|{
case|case
name|G_RAID_DESTROY_SOFT
case|:
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"%d volumes are still open."
argument_list|,
name|opens
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
case|case
name|G_RAID_DESTROY_DELAYED
case|:
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"Array will be destroyed on last close."
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stopping
operator|=
name|G_RAID_DESTROY_DELAYED
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
case|case
name|G_RAID_DESTROY_HARD
case|:
name|G_RAID_DEBUG1
argument_list|(
literal|1
argument_list|,
name|sc
argument_list|,
literal|"%d volumes are still open."
argument_list|,
name|opens
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Mark node for destruction. */
name|sc
operator|->
name|sc_stopping
operator|=
name|G_RAID_DESTROY_HARD
expr_stmt|;
comment|/* Wake up worker to let it selfdestruct. */
name|g_raid_event_send
argument_list|(
name|sc
argument_list|,
name|G_RAID_NODE_E_WAKE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Sleep until node destroyed. */
name|error
operator|=
name|sx_sleep
argument_list|(
operator|&
name|sc
operator|->
name|sc_stopping
argument_list|,
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|PRIBIO
operator||
name|PDROP
argument_list|,
literal|"r:destroy"
argument_list|,
name|hz
operator|*
literal|3
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|==
name|EWOULDBLOCK
condition|?
name|EBUSY
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_taste_orphan
parameter_list|(
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|)
block|{
name|KASSERT
argument_list|(
literal|1
operator|==
literal|0
argument_list|,
operator|(
literal|"%s called while tasting %s."
operator|,
name|__func__
operator|,
name|cp
operator|->
name|provider
operator|->
name|name
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|g_geom
modifier|*
name|g_raid_taste
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|,
name|int
name|flags
name|__unused
parameter_list|)
block|{
name|struct
name|g_consumer
modifier|*
name|cp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|,
modifier|*
name|geom
decl_stmt|;
name|struct
name|g_raid_md_class
modifier|*
name|class
decl_stmt|;
name|struct
name|g_raid_md_object
modifier|*
name|obj
decl_stmt|;
name|int
name|status
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|g_trace
argument_list|(
name|G_T_TOPOLOGY
argument_list|,
literal|"%s(%s, %s)"
argument_list|,
name|__func__
argument_list|,
name|mp
operator|->
name|name
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|g_raid_enable
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|G_RAID_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Tasting provider %s."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
name|geom
operator|=
name|NULL
expr_stmt|;
name|status
operator|=
name|G_RAID_MD_TASTE_FAIL
expr_stmt|;
name|gp
operator|=
name|g_new_geomf
argument_list|(
name|mp
argument_list|,
literal|"raid:taste"
argument_list|)
expr_stmt|;
comment|/* 	 * This orphan function should be never called. 	 */
name|gp
operator|->
name|orphan
operator|=
name|g_raid_taste_orphan
expr_stmt|;
name|cp
operator|=
name|g_new_consumer
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|cp
operator|->
name|flags
operator||=
name|G_CF_DIRECT_RECEIVE
expr_stmt|;
name|g_attach
argument_list|(
name|cp
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_access
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|ofail
goto|;
name|LIST_FOREACH
argument_list|(
argument|class
argument_list|,
argument|&g_raid_md_classes
argument_list|,
argument|mdc_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|class
operator|->
name|mdc_enable
condition|)
continue|continue;
name|G_RAID_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Tasting provider %s for %s metadata."
argument_list|,
name|pp
operator|->
name|name
argument_list|,
name|class
operator|->
name|name
argument_list|)
expr_stmt|;
name|obj
operator|=
operator|(
name|void
operator|*
operator|)
name|kobj_create
argument_list|(
operator|(
name|kobj_class_t
operator|)
name|class
argument_list|,
name|M_RAID
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|obj
operator|->
name|mdo_class
operator|=
name|class
expr_stmt|;
name|status
operator|=
name|G_RAID_MD_TASTE
argument_list|(
name|obj
argument_list|,
name|mp
argument_list|,
name|cp
argument_list|,
operator|&
name|geom
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|G_RAID_MD_TASTE_NEW
condition|)
name|kobj_delete
argument_list|(
operator|(
name|kobj_t
operator|)
name|obj
argument_list|,
name|M_RAID
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|G_RAID_MD_TASTE_FAIL
condition|)
break|break;
block|}
if|if
condition|(
name|status
operator|==
name|G_RAID_MD_TASTE_FAIL
condition|)
operator|(
name|void
operator|)
name|g_access
argument_list|(
name|cp
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ofail
label|:
name|g_detach
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_consumer
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|g_destroy_geom
argument_list|(
name|gp
argument_list|)
expr_stmt|;
name|G_RAID_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Tasting provider %s done."
argument_list|,
name|pp
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|geom
operator|)
return|;
block|}
end_function

begin_function
name|int
name|g_raid_create_node_format
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|struct
name|gctl_req
modifier|*
name|req
parameter_list|,
name|struct
name|g_geom
modifier|*
modifier|*
name|gp
parameter_list|)
block|{
name|struct
name|g_raid_md_class
modifier|*
name|class
decl_stmt|;
name|struct
name|g_raid_md_object
modifier|*
name|obj
decl_stmt|;
name|int
name|status
decl_stmt|;
name|G_RAID_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"Creating array for %s metadata."
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|class
argument_list|,
argument|&g_raid_md_classes
argument_list|,
argument|mdc_list
argument_list|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|class
operator|->
name|name
argument_list|,
name|format
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|class
operator|==
name|NULL
condition|)
block|{
name|G_RAID_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"No support for %s metadata."
argument_list|,
name|format
argument_list|)
expr_stmt|;
return|return
operator|(
name|G_RAID_MD_TASTE_FAIL
operator|)
return|;
block|}
name|obj
operator|=
operator|(
name|void
operator|*
operator|)
name|kobj_create
argument_list|(
operator|(
name|kobj_class_t
operator|)
name|class
argument_list|,
name|M_RAID
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|obj
operator|->
name|mdo_class
operator|=
name|class
expr_stmt|;
name|status
operator|=
name|G_RAID_MD_CREATE_REQ
argument_list|(
name|obj
argument_list|,
operator|&
name|g_raid_class
argument_list|,
name|req
argument_list|,
name|gp
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|G_RAID_MD_TASTE_NEW
condition|)
name|kobj_delete
argument_list|(
operator|(
name|kobj_t
operator|)
name|obj
argument_list|,
name|M_RAID
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|g_raid_destroy_geom
parameter_list|(
name|struct
name|gctl_req
modifier|*
name|req
name|__unused
parameter_list|,
name|struct
name|g_class
modifier|*
name|mp
name|__unused
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|g_cancel_event
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|g_raid_destroy
argument_list|(
name|gp
operator|->
name|softc
argument_list|,
name|G_RAID_DESTROY_SOFT
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|g_raid_write_metadata
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_raid_volume
modifier|*
name|vol
parameter_list|,
name|struct
name|g_raid_subdisk
modifier|*
name|sd
parameter_list|,
name|struct
name|g_raid_disk
modifier|*
name|disk
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_stopping
operator|==
name|G_RAID_DESTROY_HARD
condition|)
return|return;
if|if
condition|(
name|sc
operator|->
name|sc_md
condition|)
name|G_RAID_MD_WRITE
argument_list|(
name|sc
operator|->
name|sc_md
argument_list|,
name|vol
argument_list|,
name|sd
argument_list|,
name|disk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|g_raid_fail_disk
parameter_list|(
name|struct
name|g_raid_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|g_raid_subdisk
modifier|*
name|sd
parameter_list|,
name|struct
name|g_raid_disk
modifier|*
name|disk
parameter_list|)
block|{
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
name|disk
operator|=
name|sd
operator|->
name|sd_disk
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|0
argument_list|,
name|sc
argument_list|,
literal|"Warning! Fail request to an absent disk!"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|disk
operator|->
name|d_state
operator|!=
name|G_RAID_DISK_S_ACTIVE
condition|)
block|{
name|G_RAID_DEBUG1
argument_list|(
literal|0
argument_list|,
name|sc
argument_list|,
literal|"Warning! Fail request to a disk in a "
literal|"wrong state (%s)!"
argument_list|,
name|g_raid_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_md
condition|)
name|G_RAID_MD_FAIL_DISK
argument_list|(
name|sc
operator|->
name|sc_md
argument_list|,
name|sd
argument_list|,
name|disk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_dumpconf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|char
modifier|*
name|indent
parameter_list|,
name|struct
name|g_geom
modifier|*
name|gp
parameter_list|,
name|struct
name|g_consumer
modifier|*
name|cp
parameter_list|,
name|struct
name|g_provider
modifier|*
name|pp
parameter_list|)
block|{
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|struct
name|g_raid_subdisk
modifier|*
name|sd
decl_stmt|;
name|struct
name|g_raid_disk
modifier|*
name|disk
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|g_topology_assert
argument_list|()
expr_stmt|;
name|sc
operator|=
name|gp
operator|->
name|softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|pp
operator|!=
name|NULL
condition|)
block|{
name|vol
operator|=
name|pp
operator|->
name|private
expr_stmt|;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<descr>%s %s volume</descr>\n"
argument_list|,
name|indent
argument_list|,
name|sc
operator|->
name|sc_md
operator|->
name|mdo_class
operator|->
name|name
argument_list|,
name|g_raid_volume_level2str
argument_list|(
name|vol
operator|->
name|v_raid_level
argument_list|,
name|vol
operator|->
name|v_raid_level_qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Label>%s</Label>\n"
argument_list|,
name|indent
argument_list|,
name|vol
operator|->
name|v_name
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<RAIDLevel>%s</RAIDLevel>\n"
argument_list|,
name|indent
argument_list|,
name|g_raid_volume_level2str
argument_list|(
name|vol
operator|->
name|v_raid_level
argument_list|,
name|vol
operator|->
name|v_raid_level_qualifier
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Transformation>%s</Transformation>\n"
argument_list|,
name|indent
argument_list|,
name|vol
operator|->
name|v_tr
condition|?
name|vol
operator|->
name|v_tr
operator|->
name|tro_class
operator|->
name|name
else|:
literal|"NONE"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Components>%u</Components>\n"
argument_list|,
name|indent
argument_list|,
name|vol
operator|->
name|v_disks_count
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Strip>%u</Strip>\n"
argument_list|,
name|indent
argument_list|,
name|vol
operator|->
name|v_strip_size
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<State>%s</State>\n"
argument_list|,
name|indent
argument_list|,
name|g_raid_volume_state2str
argument_list|(
name|vol
operator|->
name|v_state
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Dirty>%s</Dirty>\n"
argument_list|,
name|indent
argument_list|,
name|vol
operator|->
name|v_dirty
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Subdisks>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vol
operator|->
name|v_disks_count
condition|;
name|i
operator|++
control|)
block|{
name|sd
operator|=
operator|&
name|vol
operator|->
name|v_subdisks
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_disk
operator|!=
name|NULL
operator|&&
name|sd
operator|->
name|sd_disk
operator|->
name|d_consumer
operator|!=
name|NULL
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s "
argument_list|,
name|g_raid_get_diskname
argument_list|(
name|sd
operator|->
name|sd_disk
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"NONE "
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"(%s"
argument_list|,
name|g_raid_subdisk_state2str
argument_list|(
name|sd
operator|->
name|sd_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_REBUILD
operator|||
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_RESYNC
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" %d%%"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|sd
operator|->
name|sd_rebuild_pos
operator|*
literal|100
operator|/
name|sd
operator|->
name|sd_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|vol
operator|->
name|v_disks_count
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</Subdisks>\n"
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|disk
operator|=
name|cp
operator|->
name|private
expr_stmt|;
if|if
condition|(
name|disk
operator|==
name|NULL
condition|)
return|return;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<State>%s"
argument_list|,
name|indent
argument_list|,
name|g_raid_disk_state2str
argument_list|(
name|disk
operator|->
name|d_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|disk
operator|->
name|d_subdisks
argument_list|)
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sd
argument_list|,
argument|&disk->d_subdisks
argument_list|,
argument|sd_next
argument_list|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s"
argument_list|,
name|g_raid_subdisk_state2str
argument_list|(
name|sd
operator|->
name|sd_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_REBUILD
operator|||
name|sd
operator|->
name|sd_state
operator|==
name|G_RAID_SUBDISK_S_RESYNC
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" %d%%"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|sd
operator|->
name|sd_rebuild_pos
operator|*
literal|100
operator|/
name|sd
operator|->
name|sd_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TAILQ_NEXT
argument_list|(
name|sd
argument_list|,
name|sd_next
argument_list|)
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</State>\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Subdisks>"
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sd
argument_list|,
argument|&disk->d_subdisks
argument_list|,
argument|sd_next
argument_list|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"r%d(%s):%d@%ju"
argument_list|,
name|sd
operator|->
name|sd_volume
operator|->
name|v_global_id
argument_list|,
name|sd
operator|->
name|sd_volume
operator|->
name|v_name
argument_list|,
name|sd
operator|->
name|sd_pos
argument_list|,
name|sd
operator|->
name|sd_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_NEXT
argument_list|(
name|sd
argument_list|,
name|sd_next
argument_list|)
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"</Subdisks>\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<ReadErrors>%d</ReadErrors>\n"
argument_list|,
name|indent
argument_list|,
name|disk
operator|->
name|d_read_errs
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_md
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<Metadata>%s</Metadata>\n"
argument_list|,
name|indent
argument_list|,
name|sc
operator|->
name|sc_md
operator|->
name|mdo_class
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_volumes
argument_list|)
condition|)
block|{
name|s
operator|=
literal|0xff
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vol
argument_list|,
argument|&sc->sc_volumes
argument_list|,
argument|v_next
argument_list|)
block|{
if|if
condition|(
name|vol
operator|->
name|v_state
operator|<
name|s
condition|)
name|s
operator|=
name|vol
operator|->
name|v_state
expr_stmt|;
block|}
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s<State>%s</State>\n"
argument_list|,
name|indent
argument_list|,
name|g_raid_volume_state2str
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_shutdown_post_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
block|{
name|struct
name|g_class
modifier|*
name|mp
decl_stmt|;
name|struct
name|g_geom
modifier|*
name|gp
decl_stmt|,
modifier|*
name|gp2
decl_stmt|;
name|struct
name|g_raid_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|g_raid_volume
modifier|*
name|vol
decl_stmt|;
name|mp
operator|=
name|arg
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
name|g_raid_shutdown
operator|=
literal|1
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|gp
argument_list|,
argument|&mp->geom
argument_list|,
argument|geom
argument_list|,
argument|gp2
argument_list|)
block|{
if|if
condition|(
operator|(
name|sc
operator|=
name|gp
operator|->
name|softc
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vol
argument_list|,
argument|&sc->sc_volumes
argument_list|,
argument|v_next
argument_list|)
name|g_raid_clean
argument_list|(
name|vol
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|g_cancel_event
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|g_raid_destroy
argument_list|(
name|sc
argument_list|,
name|G_RAID_DESTROY_DELAYED
argument_list|)
expr_stmt|;
name|g_topology_lock
argument_list|()
expr_stmt|;
block|}
name|g_topology_unlock
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_init
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
block|{
name|g_raid_post_sync
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_post_sync
argument_list|,
name|g_raid_shutdown_post_sync
argument_list|,
name|mp
argument_list|,
name|SHUTDOWN_PRI_FIRST
argument_list|)
expr_stmt|;
if|if
condition|(
name|g_raid_post_sync
operator|==
name|NULL
condition|)
name|G_RAID_DEBUG
argument_list|(
literal|0
argument_list|,
literal|"Warning! Cannot register shutdown event."
argument_list|)
expr_stmt|;
name|g_raid_started
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|g_raid_fini
parameter_list|(
name|struct
name|g_class
modifier|*
name|mp
parameter_list|)
block|{
if|if
condition|(
name|g_raid_post_sync
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|shutdown_post_sync
argument_list|,
name|g_raid_post_sync
argument_list|)
expr_stmt|;
name|g_raid_started
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|g_raid_md_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|g_raid_md_class
modifier|*
name|class
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|nc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|class
operator|=
name|arg
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|c
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|g_raid_md_classes
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|mdc_priority
operator|>
name|class
operator|->
name|mdc_priority
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|g_raid_md_classes
argument_list|,
name|class
argument_list|,
name|mdc_list
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|(
name|nc
operator|=
name|LIST_NEXT
argument_list|(
name|c
argument_list|,
name|mdc_list
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|nc
operator|->
name|mdc_priority
operator|<
name|class
operator|->
name|mdc_priority
condition|)
name|c
operator|=
name|nc
expr_stmt|;
name|LIST_INSERT_AFTER
argument_list|(
name|c
argument_list|,
name|class
argument_list|,
name|mdc_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|g_raid_started
condition|)
name|g_retaste
argument_list|(
operator|&
name|g_raid_class
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|LIST_REMOVE
argument_list|(
name|class
argument_list|,
name|mdc_list
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|g_raid_tr_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|g_raid_tr_class
modifier|*
name|class
decl_stmt|,
modifier|*
name|c
decl_stmt|,
modifier|*
name|nc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|class
operator|=
name|arg
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|c
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|g_raid_tr_classes
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|c
operator|->
name|trc_priority
operator|>
name|class
operator|->
name|trc_priority
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|g_raid_tr_classes
argument_list|,
name|class
argument_list|,
name|trc_list
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|(
name|nc
operator|=
name|LIST_NEXT
argument_list|(
name|c
argument_list|,
name|trc_list
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|nc
operator|->
name|trc_priority
operator|<
name|class
operator|->
name|trc_priority
condition|)
name|c
operator|=
name|nc
expr_stmt|;
name|LIST_INSERT_AFTER
argument_list|(
name|c
argument_list|,
name|class
argument_list|,
name|trc_list
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MOD_UNLOAD
case|:
name|LIST_REMOVE
argument_list|(
name|class
argument_list|,
name|trc_list
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Use local implementation of DECLARE_GEOM_CLASS(g_raid_class, g_raid)  * to reduce module priority, allowing submodules to register them first.  */
end_comment

begin_decl_stmt
specifier|static
name|moduledata_t
name|g_raid_mod
init|=
block|{
literal|"g_raid"
block|,
name|g_modevent
block|,
operator|&
name|g_raid_class
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|g_raid
argument_list|,
name|g_raid_mod
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_THIRD
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|geom_raid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

