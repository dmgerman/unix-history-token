begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Isilon Inc http://www.isilon.com/  * Authors: Doug Rabson<dfr@rabson.org>  * Developed with Red Inc: Alfred Perlstein<alfred@freebsd.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Scooter Morris at Genentech Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)ufs_lockf.c	8.3 (Berkeley) 1/6/94  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_debug_lockf.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/hash.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/lockf.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/quota.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/inode.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|lockf_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* control debug output */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|lockf_debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|lockf_debug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_LOCKF
argument_list|,
literal|"lockf"
argument_list|,
literal|"Byte-range locking structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct_decl
struct_decl|struct
name|owner_edge
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|owner_vertex
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|owner_vertex_list
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|owner_graph
struct_decl|;
end_struct_decl

begin_define
define|#
directive|define
name|NOLOCKF
value|(struct lockf_entry *)0
end_define

begin_define
define|#
directive|define
name|SELF
value|0x1
end_define

begin_define
define|#
directive|define
name|OTHERS
value|0x2
end_define

begin_function_decl
specifier|static
name|void
name|lf_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lf_hash_owner
parameter_list|(
name|caddr_t
parameter_list|,
name|struct
name|flock
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lf_owner_matches
parameter_list|(
name|struct
name|lock_owner
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|struct
name|flock
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|lockf_entry
modifier|*
name|lf_alloc_lock
parameter_list|(
name|struct
name|lock_owner
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lf_free_lock
parameter_list|(
name|struct
name|lockf_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lf_clearlock
parameter_list|(
name|struct
name|lockf
modifier|*
parameter_list|,
name|struct
name|lockf_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lf_overlaps
parameter_list|(
name|struct
name|lockf_entry
modifier|*
parameter_list|,
name|struct
name|lockf_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lf_blocks
parameter_list|(
name|struct
name|lockf_entry
modifier|*
parameter_list|,
name|struct
name|lockf_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lf_free_edge
parameter_list|(
name|struct
name|lockf_edge
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|lockf_edge
modifier|*
name|lf_alloc_edge
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lf_alloc_vertex
parameter_list|(
name|struct
name|lockf_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lf_add_edge
parameter_list|(
name|struct
name|lockf_entry
modifier|*
parameter_list|,
name|struct
name|lockf_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lf_remove_edge
parameter_list|(
name|struct
name|lockf_edge
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lf_remove_outgoing
parameter_list|(
name|struct
name|lockf_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lf_remove_incoming
parameter_list|(
name|struct
name|lockf_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lf_add_outgoing
parameter_list|(
name|struct
name|lockf
modifier|*
parameter_list|,
name|struct
name|lockf_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lf_add_incoming
parameter_list|(
name|struct
name|lockf
modifier|*
parameter_list|,
name|struct
name|lockf_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lf_findoverlap
parameter_list|(
name|struct
name|lockf_entry
modifier|*
modifier|*
parameter_list|,
name|struct
name|lockf_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|lockf_entry
modifier|*
name|lf_getblock
parameter_list|(
name|struct
name|lockf
modifier|*
parameter_list|,
name|struct
name|lockf_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lf_getlock
parameter_list|(
name|struct
name|lockf
modifier|*
parameter_list|,
name|struct
name|lockf_entry
modifier|*
parameter_list|,
name|struct
name|flock
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lf_insert_lock
parameter_list|(
name|struct
name|lockf
modifier|*
parameter_list|,
name|struct
name|lockf_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lf_wakeup_lock
parameter_list|(
name|struct
name|lockf
modifier|*
parameter_list|,
name|struct
name|lockf_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lf_update_dependancies
parameter_list|(
name|struct
name|lockf
modifier|*
parameter_list|,
name|struct
name|lockf_entry
modifier|*
parameter_list|,
name|int
name|all
parameter_list|,
name|struct
name|lockf_entry_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lf_set_start
parameter_list|(
name|struct
name|lockf
modifier|*
parameter_list|,
name|struct
name|lockf_entry
modifier|*
parameter_list|,
name|off_t
parameter_list|,
name|struct
name|lockf_entry_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lf_set_end
parameter_list|(
name|struct
name|lockf
modifier|*
parameter_list|,
name|struct
name|lockf_entry
modifier|*
parameter_list|,
name|off_t
parameter_list|,
name|struct
name|lockf_entry_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lf_setlock
parameter_list|(
name|struct
name|lockf
modifier|*
parameter_list|,
name|struct
name|lockf_entry
modifier|*
parameter_list|,
name|struct
name|vnode
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lf_cancel
parameter_list|(
name|struct
name|lockf
modifier|*
parameter_list|,
name|struct
name|lockf_entry
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lf_split
parameter_list|(
name|struct
name|lockf
modifier|*
parameter_list|,
name|struct
name|lockf_entry
modifier|*
parameter_list|,
name|struct
name|lockf_entry
modifier|*
parameter_list|,
name|struct
name|lockf_entry_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|int
name|graph_reaches
parameter_list|(
name|struct
name|owner_vertex
modifier|*
name|x
parameter_list|,
name|struct
name|owner_vertex
modifier|*
name|y
parameter_list|,
name|struct
name|owner_vertex_list
modifier|*
name|path
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|graph_check
parameter_list|(
name|struct
name|owner_graph
modifier|*
name|g
parameter_list|,
name|int
name|checkorder
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|graph_print_vertices
parameter_list|(
name|struct
name|owner_vertex_list
modifier|*
name|set
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|graph_delta_forward
parameter_list|(
name|struct
name|owner_graph
modifier|*
name|g
parameter_list|,
name|struct
name|owner_vertex
modifier|*
name|x
parameter_list|,
name|struct
name|owner_vertex
modifier|*
name|y
parameter_list|,
name|struct
name|owner_vertex_list
modifier|*
name|delta
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|graph_delta_backward
parameter_list|(
name|struct
name|owner_graph
modifier|*
name|g
parameter_list|,
name|struct
name|owner_vertex
modifier|*
name|x
parameter_list|,
name|struct
name|owner_vertex
modifier|*
name|y
parameter_list|,
name|struct
name|owner_vertex_list
modifier|*
name|delta
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|graph_add_indices
parameter_list|(
name|int
modifier|*
name|indices
parameter_list|,
name|int
name|n
parameter_list|,
name|struct
name|owner_vertex_list
modifier|*
name|set
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|graph_assign_indices
parameter_list|(
name|struct
name|owner_graph
modifier|*
name|g
parameter_list|,
name|int
modifier|*
name|indices
parameter_list|,
name|int
name|nextunused
parameter_list|,
name|struct
name|owner_vertex_list
modifier|*
name|set
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|graph_add_edge
parameter_list|(
name|struct
name|owner_graph
modifier|*
name|g
parameter_list|,
name|struct
name|owner_vertex
modifier|*
name|x
parameter_list|,
name|struct
name|owner_vertex
modifier|*
name|y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|graph_remove_edge
parameter_list|(
name|struct
name|owner_graph
modifier|*
name|g
parameter_list|,
name|struct
name|owner_vertex
modifier|*
name|x
parameter_list|,
name|struct
name|owner_vertex
modifier|*
name|y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|owner_vertex
modifier|*
name|graph_alloc_vertex
parameter_list|(
name|struct
name|owner_graph
modifier|*
name|g
parameter_list|,
name|struct
name|lock_owner
modifier|*
name|lo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|graph_free_vertex
parameter_list|(
name|struct
name|owner_graph
modifier|*
name|g
parameter_list|,
name|struct
name|owner_vertex
modifier|*
name|v
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|owner_graph
modifier|*
name|graph_init
parameter_list|(
name|struct
name|owner_graph
modifier|*
name|g
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|lf_print
parameter_list|(
name|char
modifier|*
parameter_list|,
name|struct
name|lockf_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lf_printlist
parameter_list|(
name|char
modifier|*
parameter_list|,
name|struct
name|lockf_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lf_print_owner
parameter_list|(
name|struct
name|lock_owner
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This structure is used to keep track of both local and remote lock  * owners. The lf_owner field of the struct lockf_entry points back at  * the lock owner structure. Each possible lock owner (local proc for  * POSIX fcntl locks, local file for BSD flock locks or<pid,sysid>  * pair for remote locks) is represented by a unique instance of  * struct lock_owner.  *  * If a lock owner has a lock that blocks some other lock or a lock  * that is waiting for some other lock, it also has a vertex in the  * owner_graph below.  *  * Locks:  * (s)		locked by state->ls_lock  * (S)		locked by lf_lock_states_lock  * (l)		locked by lf_lock_owners_lock  * (g)		locked by lf_owner_graph_lock  * (c)		const until freeing  */
end_comment

begin_define
define|#
directive|define
name|LOCK_OWNER_HASH_SIZE
value|256
end_define

begin_struct
struct|struct
name|lock_owner
block|{
name|LIST_ENTRY
argument_list|(
argument|lock_owner
argument_list|)
name|lo_link
expr_stmt|;
comment|/* (l) hash chain */
name|int
name|lo_refs
decl_stmt|;
comment|/* (l) Number of locks referring to this */
name|int
name|lo_flags
decl_stmt|;
comment|/* (c) Flags passwd to lf_advlock */
name|caddr_t
name|lo_id
decl_stmt|;
comment|/* (c) Id value passed to lf_advlock */
name|pid_t
name|lo_pid
decl_stmt|;
comment|/* (c) Process Id of the lock owner */
name|int
name|lo_sysid
decl_stmt|;
comment|/* (c) System Id of the lock owner */
name|struct
name|owner_vertex
modifier|*
name|lo_vertex
decl_stmt|;
comment|/* (g) entry in deadlock graph */
block|}
struct|;
end_struct

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|lock_owner_list
argument_list|,
name|lock_owner
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|sx
name|lf_lock_states_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lockf_list
name|lf_lock_states
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (S) */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sx
name|lf_lock_owners_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|lock_owner_list
name|lf_lock_owners
index|[
name|LOCK_OWNER_HASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (l) */
end_comment

begin_comment
comment|/*  * Structures for deadlock detection.  *  * We have two types of directed graph, the first is the set of locks,  * both active and pending on a vnode. Within this graph, active locks  * are terminal nodes in the graph (i.e. have no out-going  * edges). Pending locks have out-going edges to each blocking active  * lock that prevents the lock from being granted and also to each  * older pending lock that would block them if it was active. The  * graph for each vnode is naturally acyclic; new edges are only ever  * added to or from new nodes (either new pending locks which only add  * out-going edges or new active locks which only add in-coming edges)  * therefore they cannot create loops in the lock graph.  *  * The second graph is a global graph of lock owners. Each lock owner  * is a vertex in that graph and an edge is added to the graph  * whenever an edge is added to a vnode graph, with end points  * corresponding to owner of the new pending lock and the owner of the  * lock upon which it waits. In order to prevent deadlock, we only add  * an edge to this graph if the new edge would not create a cycle.  *   * The lock owner graph is topologically sorted, i.e. if a node has  * any outgoing edges, then it has an order strictly less than any  * node to which it has an outgoing edge. We preserve this ordering  * (and detect cycles) on edge insertion using Algorithm PK from the  * paper "A Dynamic Topological Sort Algorithm for Directed Acyclic  * Graphs" (ACM Journal of Experimental Algorithms, Vol 11, Article  * No. 1.7)  */
end_comment

begin_struct_decl
struct_decl|struct
name|owner_vertex
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|owner_edge
block|{
name|LIST_ENTRY
argument_list|(
argument|owner_edge
argument_list|)
name|e_outlink
expr_stmt|;
comment|/* (g) link from's out-edge list */
name|LIST_ENTRY
argument_list|(
argument|owner_edge
argument_list|)
name|e_inlink
expr_stmt|;
comment|/* (g) link to's in-edge list */
name|int
name|e_refs
decl_stmt|;
comment|/* (g) number of times added */
name|struct
name|owner_vertex
modifier|*
name|e_from
decl_stmt|;
comment|/* (c) out-going from here */
name|struct
name|owner_vertex
modifier|*
name|e_to
decl_stmt|;
comment|/* (c) in-coming to here */
block|}
struct|;
end_struct

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|owner_edge_list
argument_list|,
name|owner_edge
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|owner_vertex
block|{
name|TAILQ_ENTRY
argument_list|(
argument|owner_vertex
argument_list|)
name|v_link
expr_stmt|;
comment|/* (g) workspace for edge insertion */
name|uint32_t
name|v_gen
decl_stmt|;
comment|/* (g) workspace for edge insertion */
name|int
name|v_order
decl_stmt|;
comment|/* (g) order of vertex in graph */
name|struct
name|owner_edge_list
name|v_outedges
decl_stmt|;
comment|/* (g) list of out-edges */
name|struct
name|owner_edge_list
name|v_inedges
decl_stmt|;
comment|/* (g) list of in-edges */
name|struct
name|lock_owner
modifier|*
name|v_owner
decl_stmt|;
comment|/* (c) corresponding lock owner */
block|}
struct|;
end_struct

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|owner_vertex_list
argument_list|,
name|owner_vertex
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|owner_graph
block|{
name|struct
name|owner_vertex
modifier|*
modifier|*
name|g_vertices
decl_stmt|;
comment|/* (g) pointers to vertices */
name|int
name|g_size
decl_stmt|;
comment|/* (g) number of vertices */
name|int
name|g_space
decl_stmt|;
comment|/* (g) space allocated for vertices */
name|int
modifier|*
name|g_indexbuf
decl_stmt|;
comment|/* (g) workspace for loop detection */
name|uint32_t
name|g_gen
decl_stmt|;
comment|/* (g) increment when re-ordering */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|sx
name|lf_owner_graph_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|owner_graph
name|lf_owner_graph
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialise various structures and locks.  */
end_comment

begin_function
specifier|static
name|void
name|lf_init
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|sx_init
argument_list|(
operator|&
name|lf_lock_states_lock
argument_list|,
literal|"lock states lock"
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|lf_lock_states
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|lf_lock_owners_lock
argument_list|,
literal|"lock owners lock"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LOCK_OWNER_HASH_SIZE
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|lf_lock_owners
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|lf_owner_graph_lock
argument_list|,
literal|"owner graph lock"
argument_list|)
expr_stmt|;
name|graph_init
argument_list|(
operator|&
name|lf_owner_graph
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|lf_init
argument_list|,
name|SI_SUB_LOCK
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|lf_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Generate a hash value for a lock owner.  */
end_comment

begin_function
specifier|static
name|int
name|lf_hash_owner
parameter_list|(
name|caddr_t
name|id
parameter_list|,
name|struct
name|flock
modifier|*
name|fl
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|uint32_t
name|h
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|F_REMOTE
condition|)
block|{
name|h
operator|=
name|HASHSTEP
argument_list|(
literal|0
argument_list|,
name|fl
operator|->
name|l_pid
argument_list|)
expr_stmt|;
name|h
operator|=
name|HASHSTEP
argument_list|(
name|h
argument_list|,
name|fl
operator|->
name|l_sysid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_FLOCK
condition|)
block|{
name|h
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|id
operator|)
operator|>>
literal|7
expr_stmt|;
block|}
else|else
block|{
name|struct
name|proc
modifier|*
name|p
init|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|id
decl_stmt|;
name|h
operator|=
name|HASHSTEP
argument_list|(
literal|0
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|h
operator|=
name|HASHSTEP
argument_list|(
name|h
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|h
operator|%
name|LOCK_OWNER_HASH_SIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return true if a lock owner matches the details passed to  * lf_advlock.  */
end_comment

begin_function
specifier|static
name|int
name|lf_owner_matches
parameter_list|(
name|struct
name|lock_owner
modifier|*
name|lo
parameter_list|,
name|caddr_t
name|id
parameter_list|,
name|struct
name|flock
modifier|*
name|fl
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|F_REMOTE
condition|)
block|{
return|return
name|lo
operator|->
name|lo_pid
operator|==
name|fl
operator|->
name|l_pid
operator|&&
name|lo
operator|->
name|lo_sysid
operator|==
name|fl
operator|->
name|l_sysid
return|;
block|}
else|else
block|{
return|return
name|lo
operator|->
name|lo_id
operator|==
name|id
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|lockf_entry
modifier|*
name|lf_alloc_lock
parameter_list|(
name|struct
name|lock_owner
modifier|*
name|lo
parameter_list|)
block|{
name|struct
name|lockf_entry
modifier|*
name|lf
decl_stmt|;
name|lf
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lockf_entry
argument_list|)
argument_list|,
name|M_LOCKF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|4
condition|)
name|printf
argument_list|(
literal|"Allocated lock %p\n"
argument_list|,
name|lf
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lo
condition|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|lf_lock_owners_lock
argument_list|)
expr_stmt|;
name|lo
operator|->
name|lo_refs
operator|++
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|lf_lock_owners_lock
argument_list|)
expr_stmt|;
name|lf
operator|->
name|lf_owner
operator|=
name|lo
expr_stmt|;
block|}
return|return
operator|(
name|lf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lf_free_lock
parameter_list|(
name|struct
name|lockf_entry
modifier|*
name|lock
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|lock
operator|->
name|lf_refs
operator|>
literal|0
argument_list|,
operator|(
literal|"lockf_entry negative ref count %p"
operator|,
name|lock
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|lock
operator|->
name|lf_refs
operator|>
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Adjust the lock_owner reference count and 	 * reclaim the entry if this is the last lock 	 * for that owner. 	 */
name|struct
name|lock_owner
modifier|*
name|lo
init|=
name|lock
operator|->
name|lf_owner
decl_stmt|;
if|if
condition|(
name|lo
condition|)
block|{
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|lock
operator|->
name|lf_outedges
argument_list|)
argument_list|,
operator|(
literal|"freeing lock with dependancies"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|lock
operator|->
name|lf_inedges
argument_list|)
argument_list|,
operator|(
literal|"freeing lock with dependants"
operator|)
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|lf_lock_owners_lock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lo
operator|->
name|lo_refs
operator|>
literal|0
argument_list|,
operator|(
literal|"lock owner refcount"
operator|)
argument_list|)
expr_stmt|;
name|lo
operator|->
name|lo_refs
operator|--
expr_stmt|;
if|if
condition|(
name|lo
operator|->
name|lo_refs
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|1
condition|)
name|printf
argument_list|(
literal|"lf_free_lock: freeing lock owner %p\n"
argument_list|,
name|lo
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lo
operator|->
name|lo_vertex
condition|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|lf_owner_graph_lock
argument_list|)
expr_stmt|;
name|graph_free_vertex
argument_list|(
operator|&
name|lf_owner_graph
argument_list|,
name|lo
operator|->
name|lo_vertex
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|lf_owner_graph_lock
argument_list|)
expr_stmt|;
block|}
name|LIST_REMOVE
argument_list|(
name|lo
argument_list|,
name|lo_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lo
argument_list|,
name|M_LOCKF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|4
condition|)
name|printf
argument_list|(
literal|"Freed lock owner %p\n"
argument_list|,
name|lo
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|sx_unlock
argument_list|(
operator|&
name|lf_lock_owners_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lock
operator|->
name|lf_flags
operator|&
name|F_REMOTE
operator|)
operator|&&
name|lock
operator|->
name|lf_vnode
condition|)
block|{
name|vrele
argument_list|(
name|lock
operator|->
name|lf_vnode
argument_list|)
expr_stmt|;
name|lock
operator|->
name|lf_vnode
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|4
condition|)
name|printf
argument_list|(
literal|"Freed lock %p\n"
argument_list|,
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|lock
argument_list|,
name|M_LOCKF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Advisory record locking support  */
end_comment

begin_function
name|int
name|lf_advlockasync
parameter_list|(
name|struct
name|vop_advlockasync_args
modifier|*
name|ap
parameter_list|,
name|struct
name|lockf
modifier|*
modifier|*
name|statep
parameter_list|,
name|u_quad_t
name|size
parameter_list|)
block|{
name|struct
name|lockf
modifier|*
name|state
decl_stmt|,
modifier|*
name|freestate
init|=
name|NULL
decl_stmt|;
name|struct
name|flock
modifier|*
name|fl
init|=
name|ap
operator|->
name|a_fl
decl_stmt|;
name|struct
name|lockf_entry
modifier|*
name|lock
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|caddr_t
name|id
init|=
name|ap
operator|->
name|a_id
decl_stmt|;
name|int
name|flags
init|=
name|ap
operator|->
name|a_flags
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|struct
name|lock_owner
modifier|*
name|lo
decl_stmt|;
name|off_t
name|start
decl_stmt|,
name|end
decl_stmt|,
name|oadd
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Handle the F_UNLKSYS case first - no need to mess about 	 * creating a lock owner for this one. 	 */
if|if
condition|(
name|ap
operator|->
name|a_op
operator|==
name|F_UNLCKSYS
condition|)
block|{
name|lf_clearremotesys
argument_list|(
name|fl
operator|->
name|l_sysid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Convert the flock structure into a start and end. 	 */
switch|switch
condition|(
name|fl
operator|->
name|l_whence
condition|)
block|{
case|case
name|SEEK_SET
case|:
case|case
name|SEEK_CUR
case|:
comment|/* 		 * Caller is responsible for adding any necessary offset 		 * when SEEK_CUR is used. 		 */
name|start
operator|=
name|fl
operator|->
name|l_start
expr_stmt|;
break|break;
case|case
name|SEEK_END
case|:
if|if
condition|(
name|size
operator|>
name|OFF_MAX
operator|||
operator|(
name|fl
operator|->
name|l_start
operator|>
literal|0
operator|&&
name|size
operator|>
name|OFF_MAX
operator|-
name|fl
operator|->
name|l_start
operator|)
condition|)
return|return
operator|(
name|EOVERFLOW
operator|)
return|;
name|start
operator|=
name|size
operator|+
name|fl
operator|->
name|l_start
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|start
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|fl
operator|->
name|l_len
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|start
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|end
operator|=
name|start
operator|-
literal|1
expr_stmt|;
name|start
operator|+=
name|fl
operator|->
name|l_len
expr_stmt|;
if|if
condition|(
name|start
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|fl
operator|->
name|l_len
operator|==
literal|0
condition|)
block|{
name|end
operator|=
name|OFF_MAX
expr_stmt|;
block|}
else|else
block|{
name|oadd
operator|=
name|fl
operator|->
name|l_len
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|oadd
operator|>
name|OFF_MAX
operator|-
name|start
condition|)
return|return
operator|(
name|EOVERFLOW
operator|)
return|;
name|end
operator|=
name|start
operator|+
name|oadd
expr_stmt|;
block|}
name|retry_setlock
label|:
comment|/* 	 * Avoid the common case of unlocking when inode has no locks. 	 */
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|statep
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ap
operator|->
name|a_op
operator|!=
name|F_SETLK
condition|)
block|{
name|fl
operator|->
name|l_type
operator|=
name|F_UNLCK
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 	 * Map our arguments to an existing lock owner or create one 	 * if this is the first time we have seen this owner. 	 */
name|hash
operator|=
name|lf_hash_owner
argument_list|(
name|id
argument_list|,
name|fl
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|lf_lock_owners_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lo
argument_list|,
argument|&lf_lock_owners[hash]
argument_list|,
argument|lo_link
argument_list|)
if|if
condition|(
name|lf_owner_matches
argument_list|(
name|lo
argument_list|,
name|id
argument_list|,
name|fl
argument_list|,
name|flags
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|lo
condition|)
block|{
comment|/* 		 * We initialise the lock with a reference 		 * count which matches the new lockf_entry 		 * structure created below. 		 */
name|lo
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lock_owner
argument_list|)
argument_list|,
name|M_LOCKF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|4
condition|)
name|printf
argument_list|(
literal|"Allocated lock owner %p\n"
argument_list|,
name|lo
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lo
operator|->
name|lo_refs
operator|=
literal|1
expr_stmt|;
name|lo
operator|->
name|lo_flags
operator|=
name|flags
expr_stmt|;
name|lo
operator|->
name|lo_id
operator|=
name|id
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|F_REMOTE
condition|)
block|{
name|lo
operator|->
name|lo_pid
operator|=
name|fl
operator|->
name|l_pid
expr_stmt|;
name|lo
operator|->
name|lo_sysid
operator|=
name|fl
operator|->
name|l_sysid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_FLOCK
condition|)
block|{
name|lo
operator|->
name|lo_pid
operator|=
operator|-
literal|1
expr_stmt|;
name|lo
operator|->
name|lo_sysid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|struct
name|proc
modifier|*
name|p
init|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|id
decl_stmt|;
name|lo
operator|->
name|lo_pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|lo
operator|->
name|lo_sysid
operator|=
literal|0
expr_stmt|;
block|}
name|lo
operator|->
name|lo_vertex
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"lf_advlockasync: new lock owner %p "
argument_list|,
name|lo
argument_list|)
expr_stmt|;
name|lf_print_owner
argument_list|(
name|lo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|lf_lock_owners
index|[
name|hash
index|]
argument_list|,
name|lo
argument_list|,
name|lo_link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We have seen this lock owner before, increase its 		 * reference count to account for the new lockf_entry 		 * structure we create below. 		 */
name|lo
operator|->
name|lo_refs
operator|++
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|lf_lock_owners_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Create the lockf structure. We initialise the lf_owner 	 * field here instead of in lf_alloc_lock() to avoid paying 	 * the lf_lock_owners_lock tax twice. 	 */
name|lock
operator|=
name|lf_alloc_lock
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|lock
operator|->
name|lf_refs
operator|=
literal|1
expr_stmt|;
name|lock
operator|->
name|lf_start
operator|=
name|start
expr_stmt|;
name|lock
operator|->
name|lf_end
operator|=
name|end
expr_stmt|;
name|lock
operator|->
name|lf_owner
operator|=
name|lo
expr_stmt|;
name|lock
operator|->
name|lf_vnode
operator|=
name|vp
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|F_REMOTE
condition|)
block|{
comment|/* 		 * For remote locks, the caller may release its ref to 		 * the vnode at any time - we have to ref it here to 		 * prevent it from being recycled unexpectedly. 		 */
name|vref
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX The problem is that VTOI is ufs specific, so it will 	 * break LOCKF_DEBUG for all other FS's other than UFS because 	 * it casts the vnode->data ptr to struct inode *. 	 */
comment|/*	lock->lf_inode = VTOI(ap->a_vp); */
name|lock
operator|->
name|lf_inode
operator|=
operator|(
expr|struct
name|inode
operator|*
operator|)
literal|0
expr_stmt|;
name|lock
operator|->
name|lf_type
operator|=
name|fl
operator|->
name|l_type
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|lock
operator|->
name|lf_outedges
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|lock
operator|->
name|lf_inedges
argument_list|)
expr_stmt|;
name|lock
operator|->
name|lf_async_task
operator|=
name|ap
operator|->
name|a_task
expr_stmt|;
name|lock
operator|->
name|lf_flags
operator|=
name|ap
operator|->
name|a_flags
expr_stmt|;
comment|/* 	 * Do the requested operation. First find our state structure 	 * and create a new one if necessary - the caller's *statep 	 * variable and the state's ls_threads count is protected by 	 * the vnode interlock. 	 */
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
condition|)
block|{
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|lf_free_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* 	 * Allocate a state structure if necessary. 	 */
name|state
operator|=
operator|*
name|statep
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|NULL
condition|)
block|{
name|struct
name|lockf
modifier|*
name|ls
decl_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ls
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lockf
argument_list|)
argument_list|,
name|M_LOCKF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|ls
operator|->
name|ls_lock
argument_list|,
literal|"ls_lock"
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ls
operator|->
name|ls_active
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ls
operator|->
name|ls_pending
argument_list|)
expr_stmt|;
name|ls
operator|->
name|ls_threads
operator|=
literal|1
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|lf_lock_states_lock
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|lf_lock_states
argument_list|,
name|ls
argument_list|,
name|ls_link
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|lf_lock_states_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Cope if we lost a race with some other thread while 		 * trying to allocate memory. 		 */
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
condition|)
block|{
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|lf_lock_states_lock
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|ls
argument_list|,
name|ls_link
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|lf_lock_states_lock
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|ls
operator|->
name|ls_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ls
argument_list|,
name|M_LOCKF
argument_list|)
expr_stmt|;
name|lf_free_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|statep
operator|)
operator|==
name|NULL
condition|)
block|{
name|state
operator|=
operator|*
name|statep
operator|=
name|ls
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|state
operator|=
operator|*
name|statep
expr_stmt|;
name|state
operator|->
name|ls_threads
operator|++
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|lf_lock_states_lock
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|ls
argument_list|,
name|ls_link
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|lf_lock_states_lock
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|ls
operator|->
name|ls_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ls
argument_list|,
name|M_LOCKF
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|state
operator|->
name|ls_threads
operator|++
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|sx_xlock
argument_list|(
operator|&
name|state
operator|->
name|ls_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Recheck the doomed vnode after state->ls_lock is 	 * locked. lf_purgelocks() requires that no new threads add 	 * pending locks when vnode is marked by VI_DOOMED flag. 	 */
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
condition|)
block|{
name|state
operator|->
name|ls_threads
operator|--
expr_stmt|;
name|wakeup
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|state
operator|->
name|ls_lock
argument_list|)
expr_stmt|;
name|lf_free_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ap
operator|->
name|a_op
condition|)
block|{
case|case
name|F_SETLK
case|:
name|error
operator|=
name|lf_setlock
argument_list|(
name|state
argument_list|,
name|lock
argument_list|,
name|vp
argument_list|,
name|ap
operator|->
name|a_cookiep
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_UNLCK
case|:
name|error
operator|=
name|lf_clearlock
argument_list|(
name|state
argument_list|,
name|lock
argument_list|)
expr_stmt|;
name|lf_free_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_GETLK
case|:
name|error
operator|=
name|lf_getlock
argument_list|(
name|state
argument_list|,
name|lock
argument_list|,
name|fl
argument_list|)
expr_stmt|;
name|lf_free_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_CANCEL
case|:
if|if
condition|(
name|ap
operator|->
name|a_cookiep
condition|)
name|error
operator|=
name|lf_cancel
argument_list|(
name|state
argument_list|,
name|lock
argument_list|,
operator|*
name|ap
operator|->
name|a_cookiep
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
name|lf_free_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
break|break;
default|default:
name|lf_free_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
comment|/* 	 * Check for some can't happen stuff. In this case, the active 	 * lock list becoming disordered or containing mutually 	 * blocking locks. We also check the pending list for locks 	 * which should be active (i.e. have no out-going edges). 	 */
name|LIST_FOREACH
argument_list|(
argument|lock
argument_list|,
argument|&state->ls_active
argument_list|,
argument|lf_link
argument_list|)
block|{
name|struct
name|lockf_entry
modifier|*
name|lf
decl_stmt|;
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|lock
argument_list|,
name|lf_link
argument_list|)
condition|)
name|KASSERT
argument_list|(
operator|(
name|lock
operator|->
name|lf_start
operator|<=
name|LIST_NEXT
argument_list|(
name|lock
argument_list|,
name|lf_link
argument_list|)
operator|->
name|lf_start
operator|)
argument_list|,
operator|(
literal|"locks disordered"
operator|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lf
argument_list|,
argument|&state->ls_active
argument_list|,
argument|lf_link
argument_list|)
block|{
if|if
condition|(
name|lock
operator|==
name|lf
condition|)
break|break;
name|KASSERT
argument_list|(
operator|!
name|lf_blocks
argument_list|(
name|lock
argument_list|,
name|lf
argument_list|)
argument_list|,
operator|(
literal|"two conflicting active locks"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|->
name|lf_owner
operator|==
name|lf
operator|->
name|lf_owner
condition|)
name|KASSERT
argument_list|(
operator|!
name|lf_overlaps
argument_list|(
name|lock
argument_list|,
name|lf
argument_list|)
argument_list|,
operator|(
literal|"two overlapping locks from same owner"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|LIST_FOREACH
argument_list|(
argument|lock
argument_list|,
argument|&state->ls_pending
argument_list|,
argument|lf_link
argument_list|)
block|{
name|KASSERT
argument_list|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|lock
operator|->
name|lf_outedges
argument_list|)
argument_list|,
operator|(
literal|"pending lock which should be active"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sx_xunlock
argument_list|(
operator|&
name|state
operator|->
name|ls_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If we have removed the last active lock on the vnode and 	 * this is the last thread that was in-progress, we can free 	 * the state structure. We update the caller's pointer inside 	 * the vnode interlock but call free outside. 	 * 	 * XXX alternatively, keep the state structure around until 	 * the filesystem recycles - requires a callback from the 	 * filesystem. 	 */
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|state
operator|->
name|ls_threads
operator|--
expr_stmt|;
name|wakeup
argument_list|(
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|state
operator|->
name|ls_active
argument_list|)
operator|&&
name|state
operator|->
name|ls_threads
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|state
operator|->
name|ls_pending
argument_list|)
argument_list|,
operator|(
literal|"freeing state with pending locks"
operator|)
argument_list|)
expr_stmt|;
name|freestate
operator|=
name|state
expr_stmt|;
operator|*
name|statep
operator|=
name|NULL
expr_stmt|;
block|}
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|freestate
condition|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|lf_lock_states_lock
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|freestate
argument_list|,
name|ls_link
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|lf_lock_states_lock
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|freestate
operator|->
name|ls_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|freestate
argument_list|,
name|M_LOCKF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|EDOOFUS
condition|)
block|{
name|KASSERT
argument_list|(
name|ap
operator|->
name|a_op
operator|==
name|F_SETLK
argument_list|,
operator|(
literal|"EDOOFUS"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|retry_setlock
goto|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lf_advlock
parameter_list|(
name|struct
name|vop_advlock_args
modifier|*
name|ap
parameter_list|,
name|struct
name|lockf
modifier|*
modifier|*
name|statep
parameter_list|,
name|u_quad_t
name|size
parameter_list|)
block|{
name|struct
name|vop_advlockasync_args
name|a
decl_stmt|;
name|a
operator|.
name|a_vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
name|a
operator|.
name|a_id
operator|=
name|ap
operator|->
name|a_id
expr_stmt|;
name|a
operator|.
name|a_op
operator|=
name|ap
operator|->
name|a_op
expr_stmt|;
name|a
operator|.
name|a_fl
operator|=
name|ap
operator|->
name|a_fl
expr_stmt|;
name|a
operator|.
name|a_flags
operator|=
name|ap
operator|->
name|a_flags
expr_stmt|;
name|a
operator|.
name|a_task
operator|=
name|NULL
expr_stmt|;
name|a
operator|.
name|a_cookiep
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|lf_advlockasync
argument_list|(
operator|&
name|a
argument_list|,
name|statep
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lf_purgelocks
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|lockf
modifier|*
modifier|*
name|statep
parameter_list|)
block|{
name|struct
name|lockf
modifier|*
name|state
decl_stmt|;
name|struct
name|lockf_entry
modifier|*
name|lock
decl_stmt|,
modifier|*
name|nlock
decl_stmt|;
comment|/* 	 * For this to work correctly, the caller must ensure that no 	 * other threads enter the locking system for this vnode, 	 * e.g. by checking VI_DOOMED. We wake up any threads that are 	 * sleeping waiting for locks on this vnode and then free all 	 * the remaining locks. 	 */
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
argument_list|,
operator|(
literal|"lf_purgelocks: vp %p has not vgone yet"
operator|,
name|vp
operator|)
argument_list|)
expr_stmt|;
name|state
operator|=
operator|*
name|statep
expr_stmt|;
if|if
condition|(
name|state
condition|)
block|{
operator|*
name|statep
operator|=
name|NULL
expr_stmt|;
name|state
operator|->
name|ls_threads
operator|++
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|state
operator|->
name|ls_lock
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|lf_owner_graph_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|lock
argument_list|,
argument|&state->ls_pending
argument_list|,
argument|lf_link
argument_list|,
argument|nlock
argument_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|lock
argument_list|,
name|lf_link
argument_list|)
expr_stmt|;
name|lf_remove_outgoing
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|lf_remove_incoming
argument_list|(
name|lock
argument_list|)
expr_stmt|;
comment|/* 			 * If its an async lock, we can just free it 			 * here, otherwise we let the sleeping thread 			 * free it. 			 */
if|if
condition|(
name|lock
operator|->
name|lf_async_task
condition|)
block|{
name|lf_free_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lock
operator|->
name|lf_flags
operator||=
name|F_INTR
expr_stmt|;
name|wakeup
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
name|sx_xunlock
argument_list|(
operator|&
name|lf_owner_graph_lock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|state
operator|->
name|ls_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Wait for all other threads, sleeping and otherwise 		 * to leave. 		 */
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|->
name|ls_threads
operator|>
literal|1
condition|)
name|msleep
argument_list|(
name|state
argument_list|,
name|VI_MTX
argument_list|(
name|vp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"purgelocks"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 		 * We can just free all the active locks since they 		 * will have no dependancies (we removed them all 		 * above). We don't need to bother locking since we 		 * are the last thread using this state structure. 		 */
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|state
operator|->
name|ls_pending
argument_list|)
argument_list|,
operator|(
literal|"lock pending for %p"
operator|,
name|state
operator|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|lock
argument_list|,
argument|&state->ls_active
argument_list|,
argument|lf_link
argument_list|,
argument|nlock
argument_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|lock
argument_list|,
name|lf_link
argument_list|)
expr_stmt|;
name|lf_free_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
name|sx_xlock
argument_list|(
operator|&
name|lf_lock_states_lock
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|state
argument_list|,
name|ls_link
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|lf_lock_states_lock
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|state
operator|->
name|ls_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|state
argument_list|,
name|M_LOCKF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return non-zero if locks 'x' and 'y' overlap.  */
end_comment

begin_function
specifier|static
name|int
name|lf_overlaps
parameter_list|(
name|struct
name|lockf_entry
modifier|*
name|x
parameter_list|,
name|struct
name|lockf_entry
modifier|*
name|y
parameter_list|)
block|{
return|return
operator|(
name|x
operator|->
name|lf_start
operator|<=
name|y
operator|->
name|lf_end
operator|&&
name|x
operator|->
name|lf_end
operator|>=
name|y
operator|->
name|lf_start
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return non-zero if lock 'x' is blocked by lock 'y' (or vice versa).  */
end_comment

begin_function
specifier|static
name|int
name|lf_blocks
parameter_list|(
name|struct
name|lockf_entry
modifier|*
name|x
parameter_list|,
name|struct
name|lockf_entry
modifier|*
name|y
parameter_list|)
block|{
return|return
name|x
operator|->
name|lf_owner
operator|!=
name|y
operator|->
name|lf_owner
operator|&&
operator|(
name|x
operator|->
name|lf_type
operator|==
name|F_WRLCK
operator|||
name|y
operator|->
name|lf_type
operator|==
name|F_WRLCK
operator|)
operator|&&
name|lf_overlaps
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a lock edge from the free list  */
end_comment

begin_function
specifier|static
name|struct
name|lockf_edge
modifier|*
name|lf_alloc_edge
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lockf_edge
argument_list|)
argument_list|,
name|M_LOCKF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a lock edge.  */
end_comment

begin_function
specifier|static
name|void
name|lf_free_edge
parameter_list|(
name|struct
name|lockf_edge
modifier|*
name|e
parameter_list|)
block|{
name|free
argument_list|(
name|e
argument_list|,
name|M_LOCKF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Ensure that the lock's owner has a corresponding vertex in the  * owner graph.  */
end_comment

begin_function
specifier|static
name|void
name|lf_alloc_vertex
parameter_list|(
name|struct
name|lockf_entry
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|owner_graph
modifier|*
name|g
init|=
operator|&
name|lf_owner_graph
decl_stmt|;
if|if
condition|(
operator|!
name|lock
operator|->
name|lf_owner
operator|->
name|lo_vertex
condition|)
name|lock
operator|->
name|lf_owner
operator|->
name|lo_vertex
operator|=
name|graph_alloc_vertex
argument_list|(
name|g
argument_list|,
name|lock
operator|->
name|lf_owner
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attempt to record an edge from lock x to lock y. Return EDEADLK if  * the new edge would cause a cycle in the owner graph.  */
end_comment

begin_function
specifier|static
name|int
name|lf_add_edge
parameter_list|(
name|struct
name|lockf_entry
modifier|*
name|x
parameter_list|,
name|struct
name|lockf_entry
modifier|*
name|y
parameter_list|)
block|{
name|struct
name|owner_graph
modifier|*
name|g
init|=
operator|&
name|lf_owner_graph
decl_stmt|;
name|struct
name|lockf_edge
modifier|*
name|e
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|LIST_FOREACH
argument_list|(
argument|e
argument_list|,
argument|&x->lf_outedges
argument_list|,
argument|le_outlink
argument_list|)
name|KASSERT
argument_list|(
name|e
operator|->
name|le_to
operator|!=
name|y
argument_list|,
operator|(
literal|"adding lock edge twice"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Make sure the two owners have entries in the owner graph. 	 */
name|lf_alloc_vertex
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|lf_alloc_vertex
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|error
operator|=
name|graph_add_edge
argument_list|(
name|g
argument_list|,
name|x
operator|->
name|lf_owner
operator|->
name|lo_vertex
argument_list|,
name|y
operator|->
name|lf_owner
operator|->
name|lo_vertex
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|e
operator|=
name|lf_alloc_edge
argument_list|()
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|x
operator|->
name|lf_outedges
argument_list|,
name|e
argument_list|,
name|le_outlink
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|y
operator|->
name|lf_inedges
argument_list|,
name|e
argument_list|,
name|le_inlink
argument_list|)
expr_stmt|;
name|e
operator|->
name|le_from
operator|=
name|x
expr_stmt|;
name|e
operator|->
name|le_to
operator|=
name|y
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove an edge from the lock graph.  */
end_comment

begin_function
specifier|static
name|void
name|lf_remove_edge
parameter_list|(
name|struct
name|lockf_edge
modifier|*
name|e
parameter_list|)
block|{
name|struct
name|owner_graph
modifier|*
name|g
init|=
operator|&
name|lf_owner_graph
decl_stmt|;
name|struct
name|lockf_entry
modifier|*
name|x
init|=
name|e
operator|->
name|le_from
decl_stmt|;
name|struct
name|lockf_entry
modifier|*
name|y
init|=
name|e
operator|->
name|le_to
decl_stmt|;
name|graph_remove_edge
argument_list|(
name|g
argument_list|,
name|x
operator|->
name|lf_owner
operator|->
name|lo_vertex
argument_list|,
name|y
operator|->
name|lf_owner
operator|->
name|lo_vertex
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|e
argument_list|,
name|le_outlink
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|e
argument_list|,
name|le_inlink
argument_list|)
expr_stmt|;
name|e
operator|->
name|le_from
operator|=
name|NULL
expr_stmt|;
name|e
operator|->
name|le_to
operator|=
name|NULL
expr_stmt|;
name|lf_free_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove all out-going edges from lock x.  */
end_comment

begin_function
specifier|static
name|void
name|lf_remove_outgoing
parameter_list|(
name|struct
name|lockf_entry
modifier|*
name|x
parameter_list|)
block|{
name|struct
name|lockf_edge
modifier|*
name|e
decl_stmt|;
while|while
condition|(
operator|(
name|e
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|x
operator|->
name|lf_outedges
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|lf_remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Remove all in-coming edges from lock x.  */
end_comment

begin_function
specifier|static
name|void
name|lf_remove_incoming
parameter_list|(
name|struct
name|lockf_entry
modifier|*
name|x
parameter_list|)
block|{
name|struct
name|lockf_edge
modifier|*
name|e
decl_stmt|;
while|while
condition|(
operator|(
name|e
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|x
operator|->
name|lf_inedges
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|lf_remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Walk the list of locks for the file and create an out-going edge  * from lock to each blocking lock.  */
end_comment

begin_function
specifier|static
name|int
name|lf_add_outgoing
parameter_list|(
name|struct
name|lockf
modifier|*
name|state
parameter_list|,
name|struct
name|lockf_entry
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|lockf_entry
modifier|*
name|overlap
decl_stmt|;
name|int
name|error
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|overlap
argument_list|,
argument|&state->ls_active
argument_list|,
argument|lf_link
argument_list|)
block|{
comment|/* 		 * We may assume that the active list is sorted by 		 * lf_start. 		 */
if|if
condition|(
name|overlap
operator|->
name|lf_start
operator|>
name|lock
operator|->
name|lf_end
condition|)
break|break;
if|if
condition|(
operator|!
name|lf_blocks
argument_list|(
name|lock
argument_list|,
name|overlap
argument_list|)
condition|)
continue|continue;
comment|/* 		 * We've found a blocking lock. Add the corresponding 		 * edge to the graphs and see if it would cause a 		 * deadlock. 		 */
name|error
operator|=
name|lf_add_edge
argument_list|(
name|lock
argument_list|,
name|overlap
argument_list|)
expr_stmt|;
comment|/* 		 * The only error that lf_add_edge returns is EDEADLK. 		 * Remove any edges we added and return the error. 		 */
if|if
condition|(
name|error
condition|)
block|{
name|lf_remove_outgoing
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * We also need to add edges to sleeping locks that block 	 * us. This ensures that lf_wakeup_lock cannot grant two 	 * mutually blocking locks simultaneously and also enforces a 	 * 'first come, first served' fairness model. Note that this 	 * only happens if we are blocked by at least one active lock 	 * due to the call to lf_getblock in lf_setlock below. 	 */
name|LIST_FOREACH
argument_list|(
argument|overlap
argument_list|,
argument|&state->ls_pending
argument_list|,
argument|lf_link
argument_list|)
block|{
if|if
condition|(
operator|!
name|lf_blocks
argument_list|(
name|lock
argument_list|,
name|overlap
argument_list|)
condition|)
continue|continue;
comment|/* 		 * We've found a blocking lock. Add the corresponding 		 * edge to the graphs and see if it would cause a 		 * deadlock. 		 */
name|error
operator|=
name|lf_add_edge
argument_list|(
name|lock
argument_list|,
name|overlap
argument_list|)
expr_stmt|;
comment|/* 		 * The only error that lf_add_edge returns is EDEADLK. 		 * Remove any edges we added and return the error. 		 */
if|if
condition|(
name|error
condition|)
block|{
name|lf_remove_outgoing
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Walk the list of pending locks for the file and create an in-coming  * edge from lock to each blocking lock.  */
end_comment

begin_function
specifier|static
name|int
name|lf_add_incoming
parameter_list|(
name|struct
name|lockf
modifier|*
name|state
parameter_list|,
name|struct
name|lockf_entry
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|lockf_entry
modifier|*
name|overlap
decl_stmt|;
name|int
name|error
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|overlap
argument_list|,
argument|&state->ls_pending
argument_list|,
argument|lf_link
argument_list|)
block|{
if|if
condition|(
operator|!
name|lf_blocks
argument_list|(
name|lock
argument_list|,
name|overlap
argument_list|)
condition|)
continue|continue;
comment|/* 		 * We've found a blocking lock. Add the corresponding 		 * edge to the graphs and see if it would cause a 		 * deadlock. 		 */
name|error
operator|=
name|lf_add_edge
argument_list|(
name|overlap
argument_list|,
name|lock
argument_list|)
expr_stmt|;
comment|/* 		 * The only error that lf_add_edge returns is EDEADLK. 		 * Remove any edges we added and return the error. 		 */
if|if
condition|(
name|error
condition|)
block|{
name|lf_remove_incoming
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert lock into the active list, keeping list entries ordered by  * increasing values of lf_start.  */
end_comment

begin_function
specifier|static
name|void
name|lf_insert_lock
parameter_list|(
name|struct
name|lockf
modifier|*
name|state
parameter_list|,
name|struct
name|lockf_entry
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|lockf_entry
modifier|*
name|lf
decl_stmt|,
modifier|*
name|lfprev
decl_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|state
operator|->
name|ls_active
argument_list|)
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|state
operator|->
name|ls_active
argument_list|,
name|lock
argument_list|,
name|lf_link
argument_list|)
expr_stmt|;
return|return;
block|}
name|lfprev
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lf
argument_list|,
argument|&state->ls_active
argument_list|,
argument|lf_link
argument_list|)
block|{
if|if
condition|(
name|lf
operator|->
name|lf_start
operator|>
name|lock
operator|->
name|lf_start
condition|)
block|{
name|LIST_INSERT_BEFORE
argument_list|(
name|lf
argument_list|,
name|lock
argument_list|,
name|lf_link
argument_list|)
expr_stmt|;
return|return;
block|}
name|lfprev
operator|=
name|lf
expr_stmt|;
block|}
name|LIST_INSERT_AFTER
argument_list|(
name|lfprev
argument_list|,
name|lock
argument_list|,
name|lf_link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wake up a sleeping lock and remove it from the pending list now  * that all its dependancies have been resolved. The caller should  * arrange for the lock to be added to the active list, adjusting any  * existing locks for the same owner as needed.  */
end_comment

begin_function
specifier|static
name|void
name|lf_wakeup_lock
parameter_list|(
name|struct
name|lockf
modifier|*
name|state
parameter_list|,
name|struct
name|lockf_entry
modifier|*
name|wakelock
parameter_list|)
block|{
comment|/* 	 * Remove from ls_pending list and wake up the caller 	 * or start the async notification, as appropriate. 	 */
name|LIST_REMOVE
argument_list|(
name|wakelock
argument_list|,
name|lf_link
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|1
condition|)
name|lf_print
argument_list|(
literal|"lf_wakeup_lock: awakening"
argument_list|,
name|wakelock
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOCKF_DEBUG */
if|if
condition|(
name|wakelock
operator|->
name|lf_async_task
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
name|wakelock
operator|->
name|lf_async_task
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wakeup
argument_list|(
name|wakelock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Re-check all dependant locks and remove edges to locks that we no  * longer block. If 'all' is non-zero, the lock has been removed and  * we must remove all the dependancies, otherwise it has simply been  * reduced but remains active. Any pending locks which have been been  * unblocked are added to 'granted'  */
end_comment

begin_function
specifier|static
name|void
name|lf_update_dependancies
parameter_list|(
name|struct
name|lockf
modifier|*
name|state
parameter_list|,
name|struct
name|lockf_entry
modifier|*
name|lock
parameter_list|,
name|int
name|all
parameter_list|,
name|struct
name|lockf_entry_list
modifier|*
name|granted
parameter_list|)
block|{
name|struct
name|lockf_edge
modifier|*
name|e
decl_stmt|,
modifier|*
name|ne
decl_stmt|;
name|struct
name|lockf_entry
modifier|*
name|deplock
decl_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|e
argument_list|,
argument|&lock->lf_inedges
argument_list|,
argument|le_inlink
argument_list|,
argument|ne
argument_list|)
block|{
name|deplock
operator|=
name|e
operator|->
name|le_from
expr_stmt|;
if|if
condition|(
name|all
operator|||
operator|!
name|lf_blocks
argument_list|(
name|lock
argument_list|,
name|deplock
argument_list|)
condition|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|lf_owner_graph_lock
argument_list|)
expr_stmt|;
name|lf_remove_edge
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|lf_owner_graph_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|deplock
operator|->
name|lf_outedges
argument_list|)
condition|)
block|{
name|lf_wakeup_lock
argument_list|(
name|state
argument_list|,
name|deplock
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|granted
argument_list|,
name|deplock
argument_list|,
name|lf_link
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Set the start of an existing active lock, updating dependancies and  * adding any newly woken locks to 'granted'.  */
end_comment

begin_function
specifier|static
name|void
name|lf_set_start
parameter_list|(
name|struct
name|lockf
modifier|*
name|state
parameter_list|,
name|struct
name|lockf_entry
modifier|*
name|lock
parameter_list|,
name|off_t
name|new_start
parameter_list|,
name|struct
name|lockf_entry_list
modifier|*
name|granted
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|new_start
operator|>=
name|lock
operator|->
name|lf_start
argument_list|,
operator|(
literal|"can't increase lock"
operator|)
argument_list|)
expr_stmt|;
name|lock
operator|->
name|lf_start
operator|=
name|new_start
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|lock
argument_list|,
name|lf_link
argument_list|)
expr_stmt|;
name|lf_insert_lock
argument_list|(
name|state
argument_list|,
name|lock
argument_list|)
expr_stmt|;
name|lf_update_dependancies
argument_list|(
name|state
argument_list|,
name|lock
argument_list|,
name|FALSE
argument_list|,
name|granted
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the end of an existing active lock, updating dependancies and  * adding any newly woken locks to 'granted'.  */
end_comment

begin_function
specifier|static
name|void
name|lf_set_end
parameter_list|(
name|struct
name|lockf
modifier|*
name|state
parameter_list|,
name|struct
name|lockf_entry
modifier|*
name|lock
parameter_list|,
name|off_t
name|new_end
parameter_list|,
name|struct
name|lockf_entry_list
modifier|*
name|granted
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|new_end
operator|<=
name|lock
operator|->
name|lf_end
argument_list|,
operator|(
literal|"can't increase lock"
operator|)
argument_list|)
expr_stmt|;
name|lock
operator|->
name|lf_end
operator|=
name|new_end
expr_stmt|;
name|lf_update_dependancies
argument_list|(
name|state
argument_list|,
name|lock
argument_list|,
name|FALSE
argument_list|,
name|granted
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a lock to the active list, updating or removing any current  * locks owned by the same owner and processing any pending locks that  * become unblocked as a result. This code is also used for unlock  * since the logic for updating existing locks is identical.  *  * As a result of processing the new lock, we may unblock existing  * pending locks as a result of downgrading/unlocking. We simply  * activate the newly granted locks by looping.  *  * Since the new lock already has its dependancies set up, we always  * add it to the list (unless its an unlock request). This may  * fragment the lock list in some pathological cases but its probably  * not a real problem.  */
end_comment

begin_function
specifier|static
name|void
name|lf_activate_lock
parameter_list|(
name|struct
name|lockf
modifier|*
name|state
parameter_list|,
name|struct
name|lockf_entry
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|lockf_entry
modifier|*
name|overlap
decl_stmt|,
modifier|*
name|lf
decl_stmt|;
name|struct
name|lockf_entry_list
name|granted
decl_stmt|;
name|int
name|ovcase
decl_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|granted
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|granted
argument_list|,
name|lock
argument_list|,
name|lf_link
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|granted
argument_list|)
condition|)
block|{
name|lock
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|granted
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|lock
argument_list|,
name|lf_link
argument_list|)
expr_stmt|;
comment|/* 		 * Skip over locks owned by other processes.  Handle 		 * any locks that overlap and are owned by ourselves. 		 */
name|overlap
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|state
operator|->
name|ls_active
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ovcase
operator|=
name|lf_findoverlap
argument_list|(
operator|&
name|overlap
argument_list|,
name|lock
argument_list|,
name|SELF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|ovcase
operator|&&
operator|(
name|lockf_debug
operator|&
literal|2
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"lf_setlock: overlap %d"
argument_list|,
name|ovcase
argument_list|)
expr_stmt|;
name|lf_print
argument_list|(
literal|""
argument_list|,
name|overlap
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 			 * Six cases: 			 *	0) no overlap 			 *	1) overlap == lock 			 *	2) overlap contains lock 			 *	3) lock contains overlap 			 *	4) overlap starts before lock 			 *	5) overlap ends after lock 			 */
switch|switch
condition|(
name|ovcase
condition|)
block|{
case|case
literal|0
case|:
comment|/* no overlap */
break|break;
case|case
literal|1
case|:
comment|/* overlap == lock */
comment|/* 				 * We have already setup the 				 * dependants for the new lock, taking 				 * into account a possible downgrade 				 * or unlock. Remove the old lock. 				 */
name|LIST_REMOVE
argument_list|(
name|overlap
argument_list|,
name|lf_link
argument_list|)
expr_stmt|;
name|lf_update_dependancies
argument_list|(
name|state
argument_list|,
name|overlap
argument_list|,
name|TRUE
argument_list|,
operator|&
name|granted
argument_list|)
expr_stmt|;
name|lf_free_lock
argument_list|(
name|overlap
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* overlap contains lock */
comment|/* 				 * Just split the existing lock. 				 */
name|lf_split
argument_list|(
name|state
argument_list|,
name|overlap
argument_list|,
name|lock
argument_list|,
operator|&
name|granted
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* lock contains overlap */
comment|/* 				 * Delete the overlap and advance to 				 * the next entry in the list. 				 */
name|lf
operator|=
name|LIST_NEXT
argument_list|(
name|overlap
argument_list|,
name|lf_link
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|overlap
argument_list|,
name|lf_link
argument_list|)
expr_stmt|;
name|lf_update_dependancies
argument_list|(
name|state
argument_list|,
name|overlap
argument_list|,
name|TRUE
argument_list|,
operator|&
name|granted
argument_list|)
expr_stmt|;
name|lf_free_lock
argument_list|(
name|overlap
argument_list|)
expr_stmt|;
name|overlap
operator|=
name|lf
expr_stmt|;
continue|continue;
case|case
literal|4
case|:
comment|/* overlap starts before lock */
comment|/* 				 * Just update the overlap end and 				 * move on. 				 */
name|lf_set_end
argument_list|(
name|state
argument_list|,
name|overlap
argument_list|,
name|lock
operator|->
name|lf_start
operator|-
literal|1
argument_list|,
operator|&
name|granted
argument_list|)
expr_stmt|;
name|overlap
operator|=
name|LIST_NEXT
argument_list|(
name|overlap
argument_list|,
name|lf_link
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|5
case|:
comment|/* overlap ends after lock */
comment|/* 				 * Change the start of overlap and 				 * re-insert. 				 */
name|lf_set_start
argument_list|(
name|state
argument_list|,
name|overlap
argument_list|,
name|lock
operator|->
name|lf_end
operator|+
literal|1
argument_list|,
operator|&
name|granted
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|lock
operator|->
name|lf_type
operator|!=
name|F_UNLCK
condition|)
name|lf_print
argument_list|(
literal|"lf_activate_lock: activated"
argument_list|,
name|lock
argument_list|)
expr_stmt|;
else|else
name|lf_print
argument_list|(
literal|"lf_activate_lock: unlocked"
argument_list|,
name|lock
argument_list|)
expr_stmt|;
name|lf_printlist
argument_list|(
literal|"lf_activate_lock"
argument_list|,
name|lock
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LOCKF_DEBUG */
if|if
condition|(
name|lock
operator|->
name|lf_type
operator|!=
name|F_UNLCK
condition|)
name|lf_insert_lock
argument_list|(
name|state
argument_list|,
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Cancel a pending lock request, either as a result of a signal or a  * cancel request for an async lock.  */
end_comment

begin_function
specifier|static
name|void
name|lf_cancel_lock
parameter_list|(
name|struct
name|lockf
modifier|*
name|state
parameter_list|,
name|struct
name|lockf_entry
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|lockf_entry_list
name|granted
decl_stmt|;
comment|/* 	 * Note it is theoretically possible that cancelling this lock 	 * may allow some other pending lock to become 	 * active. Consider this case: 	 * 	 * Owner	Action		Result		Dependancies 	 *  	 * A:		lock [0..0]	succeeds	 	 * B:		lock [2..2]	succeeds	 	 * C:		lock [1..2]	blocked		C->B 	 * D:		lock [0..1]	blocked		C->B,D->A,D->C 	 * A:		unlock [0..0]			C->B,D->C 	 * C:		cancel [1..2]	 	 */
name|LIST_REMOVE
argument_list|(
name|lock
argument_list|,
name|lf_link
argument_list|)
expr_stmt|;
comment|/* 	 * Removing out-going edges is simple. 	 */
name|sx_xlock
argument_list|(
operator|&
name|lf_owner_graph_lock
argument_list|)
expr_stmt|;
name|lf_remove_outgoing
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|lf_owner_graph_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Removing in-coming edges may allow some other lock to 	 * become active - we use lf_update_dependancies to figure 	 * this out. 	 */
name|LIST_INIT
argument_list|(
operator|&
name|granted
argument_list|)
expr_stmt|;
name|lf_update_dependancies
argument_list|(
name|state
argument_list|,
name|lock
argument_list|,
name|TRUE
argument_list|,
operator|&
name|granted
argument_list|)
expr_stmt|;
name|lf_free_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Feed any newly active locks to lf_activate_lock. 	 */
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|granted
argument_list|)
condition|)
block|{
name|lock
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|granted
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|lock
argument_list|,
name|lf_link
argument_list|)
expr_stmt|;
name|lf_activate_lock
argument_list|(
name|state
argument_list|,
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set a byte-range lock.  */
end_comment

begin_function
specifier|static
name|int
name|lf_setlock
parameter_list|(
name|struct
name|lockf
modifier|*
name|state
parameter_list|,
name|struct
name|lockf_entry
modifier|*
name|lock
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
specifier|static
name|char
name|lockstr
index|[]
init|=
literal|"lockf"
decl_stmt|;
name|int
name|priority
decl_stmt|,
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|1
condition|)
name|lf_print
argument_list|(
literal|"lf_setlock"
argument_list|,
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOCKF_DEBUG */
comment|/* 	 * Set the priority 	 */
name|priority
operator|=
name|PLOCK
expr_stmt|;
if|if
condition|(
name|lock
operator|->
name|lf_type
operator|==
name|F_WRLCK
condition|)
name|priority
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|lock
operator|->
name|lf_flags
operator|&
name|F_NOINTR
operator|)
condition|)
name|priority
operator||=
name|PCATCH
expr_stmt|;
comment|/* 	 * Scan lock list for this file looking for locks that would block us. 	 */
if|if
condition|(
name|lf_getblock
argument_list|(
name|state
argument_list|,
name|lock
argument_list|)
condition|)
block|{
comment|/* 		 * Free the structure and return if nonblocking. 		 */
if|if
condition|(
operator|(
name|lock
operator|->
name|lf_flags
operator|&
name|F_WAIT
operator|)
operator|==
literal|0
operator|&&
name|lock
operator|->
name|lf_async_task
operator|==
name|NULL
condition|)
block|{
name|lf_free_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * For flock type locks, we must first remove 		 * any shared locks that we hold before we sleep 		 * waiting for an exclusive lock. 		 */
if|if
condition|(
operator|(
name|lock
operator|->
name|lf_flags
operator|&
name|F_FLOCK
operator|)
operator|&&
name|lock
operator|->
name|lf_type
operator|==
name|F_WRLCK
condition|)
block|{
name|lock
operator|->
name|lf_type
operator|=
name|F_UNLCK
expr_stmt|;
name|lf_activate_lock
argument_list|(
name|state
argument_list|,
name|lock
argument_list|)
expr_stmt|;
name|lock
operator|->
name|lf_type
operator|=
name|F_WRLCK
expr_stmt|;
block|}
comment|/* 		 * We are blocked. Create edges to each blocking lock, 		 * checking for deadlock using the owner graph. For 		 * simplicity, we run deadlock detection for all 		 * locks, posix and otherwise. 		 */
name|sx_xlock
argument_list|(
operator|&
name|lf_owner_graph_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|lf_add_outgoing
argument_list|(
name|state
argument_list|,
name|lock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|lf_owner_graph_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|1
condition|)
name|lf_print
argument_list|(
literal|"lf_setlock: deadlock"
argument_list|,
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lf_free_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * We have added edges to everything that blocks 		 * us. Sleep until they all go away. 		 */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|state
operator|->
name|ls_pending
argument_list|,
name|lock
argument_list|,
name|lf_link
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|1
condition|)
block|{
name|struct
name|lockf_edge
modifier|*
name|e
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|e
argument_list|,
argument|&lock->lf_outedges
argument_list|,
argument|le_outlink
argument_list|)
block|{
name|lf_print
argument_list|(
literal|"lf_setlock: blocking on"
argument_list|,
name|e
operator|->
name|le_to
argument_list|)
expr_stmt|;
name|lf_printlist
argument_list|(
literal|"lf_setlock"
argument_list|,
name|e
operator|->
name|le_to
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* LOCKF_DEBUG */
if|if
condition|(
operator|(
name|lock
operator|->
name|lf_flags
operator|&
name|F_WAIT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The caller requested async notification - 			 * this callback happens when the blocking 			 * lock is released, allowing the caller to 			 * make another attempt to take the lock. 			 */
operator|*
name|cookiep
operator|=
operator|(
name|void
operator|*
operator|)
name|lock
expr_stmt|;
name|error
operator|=
name|EINPROGRESS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|lock
operator|->
name|lf_refs
operator|++
expr_stmt|;
name|error
operator|=
name|sx_sleep
argument_list|(
name|lock
argument_list|,
operator|&
name|state
operator|->
name|ls_lock
argument_list|,
name|priority
argument_list|,
name|lockstr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lf_free_lock
argument_list|(
name|lock
argument_list|)
condition|)
block|{
name|error
operator|=
name|EDOOFUS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * We may have been awakened by a signal and/or by a 		 * debugger continuing us (in which cases we must 		 * remove our lock graph edges) and/or by another 		 * process releasing a lock (in which case our edges 		 * have already been removed and we have been moved to 		 * the active list). We may also have been woken by 		 * lf_purgelocks which we report to the caller as 		 * EINTR. In that case, lf_purgelocks will have 		 * removed our lock graph edges. 		 * 		 * Note that it is possible to receive a signal after 		 * we were successfully woken (and moved to the active 		 * list) but before we resumed execution. In this 		 * case, our lf_outedges list will be clear. We 		 * pretend there was no error. 		 * 		 * Note also, if we have been sleeping long enough, we 		 * may now have incoming edges from some newer lock 		 * which is waiting behind us in the queue. 		 */
if|if
condition|(
name|lock
operator|->
name|lf_flags
operator|&
name|F_INTR
condition|)
block|{
name|error
operator|=
name|EINTR
expr_stmt|;
name|lf_free_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|lock
operator|->
name|lf_outedges
argument_list|)
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|lf_cancel_lock
argument_list|(
name|state
argument_list|,
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|1
condition|)
block|{
name|lf_print
argument_list|(
literal|"lf_setlock: granted"
argument_list|,
name|lock
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
goto|goto
name|out
goto|;
block|}
comment|/* 	 * It looks like we are going to grant the lock. First add 	 * edges from any currently pending lock that the new lock 	 * would block. 	 */
name|sx_xlock
argument_list|(
operator|&
name|lf_owner_graph_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|lf_add_incoming
argument_list|(
name|state
argument_list|,
name|lock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|lf_owner_graph_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|1
condition|)
name|lf_print
argument_list|(
literal|"lf_setlock: deadlock"
argument_list|,
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lf_free_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * No blocks!!  Add the lock.  Note that we will 	 * downgrade or upgrade any overlapping locks this 	 * process already owns. 	 */
name|lf_activate_lock
argument_list|(
name|state
argument_list|,
name|lock
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a byte-range lock on an inode.  *  * Generally, find the lock (or an overlap to that lock)  * and remove it (or shrink it), then wakeup anyone we can.  */
end_comment

begin_function
specifier|static
name|int
name|lf_clearlock
parameter_list|(
name|struct
name|lockf
modifier|*
name|state
parameter_list|,
name|struct
name|lockf_entry
modifier|*
name|unlock
parameter_list|)
block|{
name|struct
name|lockf_entry
modifier|*
name|overlap
decl_stmt|;
name|overlap
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|state
operator|->
name|ls_active
argument_list|)
expr_stmt|;
if|if
condition|(
name|overlap
operator|==
name|NOLOCKF
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|unlock
operator|->
name|lf_type
operator|!=
name|F_UNLCK
condition|)
name|panic
argument_list|(
literal|"lf_clearlock: bad type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockf_debug
operator|&
literal|1
condition|)
name|lf_print
argument_list|(
literal|"lf_clearlock"
argument_list|,
name|unlock
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOCKF_DEBUG */
name|lf_activate_lock
argument_list|(
name|state
argument_list|,
name|unlock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check whether there is a blocking lock, and if so return its  * details in '*fl'.  */
end_comment

begin_function
specifier|static
name|int
name|lf_getlock
parameter_list|(
name|struct
name|lockf
modifier|*
name|state
parameter_list|,
name|struct
name|lockf_entry
modifier|*
name|lock
parameter_list|,
name|struct
name|flock
modifier|*
name|fl
parameter_list|)
block|{
name|struct
name|lockf_entry
modifier|*
name|block
decl_stmt|;
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|1
condition|)
name|lf_print
argument_list|(
literal|"lf_getlock"
argument_list|,
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOCKF_DEBUG */
if|if
condition|(
operator|(
name|block
operator|=
name|lf_getblock
argument_list|(
name|state
argument_list|,
name|lock
argument_list|)
operator|)
condition|)
block|{
name|fl
operator|->
name|l_type
operator|=
name|block
operator|->
name|lf_type
expr_stmt|;
name|fl
operator|->
name|l_whence
operator|=
name|SEEK_SET
expr_stmt|;
name|fl
operator|->
name|l_start
operator|=
name|block
operator|->
name|lf_start
expr_stmt|;
if|if
condition|(
name|block
operator|->
name|lf_end
operator|==
name|OFF_MAX
condition|)
name|fl
operator|->
name|l_len
operator|=
literal|0
expr_stmt|;
else|else
name|fl
operator|->
name|l_len
operator|=
name|block
operator|->
name|lf_end
operator|-
name|block
operator|->
name|lf_start
operator|+
literal|1
expr_stmt|;
name|fl
operator|->
name|l_pid
operator|=
name|block
operator|->
name|lf_owner
operator|->
name|lo_pid
expr_stmt|;
name|fl
operator|->
name|l_sysid
operator|=
name|block
operator|->
name|lf_owner
operator|->
name|lo_sysid
expr_stmt|;
block|}
else|else
block|{
name|fl
operator|->
name|l_type
operator|=
name|F_UNLCK
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Cancel an async lock request.  */
end_comment

begin_function
specifier|static
name|int
name|lf_cancel
parameter_list|(
name|struct
name|lockf
modifier|*
name|state
parameter_list|,
name|struct
name|lockf_entry
modifier|*
name|lock
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|lockf_entry
modifier|*
name|reallock
decl_stmt|;
comment|/* 	 * We need to match this request with an existing lock 	 * request. 	 */
name|LIST_FOREACH
argument_list|(
argument|reallock
argument_list|,
argument|&state->ls_pending
argument_list|,
argument|lf_link
argument_list|)
block|{
if|if
condition|(
operator|(
name|void
operator|*
operator|)
name|reallock
operator|==
name|cookie
condition|)
block|{
comment|/* 			 * Double-check that this lock looks right 			 * (maybe use a rolling ID for the cancel 			 * cookie instead?) 			 */
if|if
condition|(
operator|!
operator|(
name|reallock
operator|->
name|lf_vnode
operator|==
name|lock
operator|->
name|lf_vnode
operator|&&
name|reallock
operator|->
name|lf_start
operator|==
name|lock
operator|->
name|lf_start
operator|&&
name|reallock
operator|->
name|lf_end
operator|==
name|lock
operator|->
name|lf_end
operator|)
condition|)
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* 			 * Make sure this lock was async and then just 			 * remove it from its wait lists. 			 */
if|if
condition|(
operator|!
name|reallock
operator|->
name|lf_async_task
condition|)
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* 			 * Note that since any other thread must take 			 * state->ls_lock before it can possibly 			 * trigger the async callback, we are safe 			 * from a race with lf_wakeup_lock, i.e. we 			 * can free the lock (actually our caller does 			 * this). 			 */
name|lf_cancel_lock
argument_list|(
name|state
argument_list|,
name|reallock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * We didn't find a matching lock - not much we can do here. 	 */
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Walk the list of locks for an inode and  * return the first blocking lock.  */
end_comment

begin_function
specifier|static
name|struct
name|lockf_entry
modifier|*
name|lf_getblock
parameter_list|(
name|struct
name|lockf
modifier|*
name|state
parameter_list|,
name|struct
name|lockf_entry
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|lockf_entry
modifier|*
name|overlap
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|overlap
argument_list|,
argument|&state->ls_active
argument_list|,
argument|lf_link
argument_list|)
block|{
comment|/* 		 * We may assume that the active list is sorted by 		 * lf_start. 		 */
if|if
condition|(
name|overlap
operator|->
name|lf_start
operator|>
name|lock
operator|->
name|lf_end
condition|)
break|break;
if|if
condition|(
operator|!
name|lf_blocks
argument_list|(
name|lock
argument_list|,
name|overlap
argument_list|)
condition|)
continue|continue;
return|return
operator|(
name|overlap
operator|)
return|;
block|}
return|return
operator|(
name|NOLOCKF
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Walk the list of locks for an inode to find an overlapping lock (if  * any) and return a classification of that overlap.  *  * Arguments:  *	*overlap	The place in the lock list to start looking  *	lock		The lock which is being tested  *	type		Pass 'SELF' to test only locks with the same  *			owner as lock, or 'OTHER' to test only locks  *			with a different owner  *  * Returns one of six values:  *	0) no overlap  *	1) overlap == lock  *	2) overlap contains lock  *	3) lock contains overlap  *	4) overlap starts before lock  *	5) overlap ends after lock  *  * If there is an overlapping lock, '*overlap' is set to point at the  * overlapping lock.  *  * NOTE: this returns only the FIRST overlapping lock.  There  *	 may be more than one.  */
end_comment

begin_function
specifier|static
name|int
name|lf_findoverlap
parameter_list|(
name|struct
name|lockf_entry
modifier|*
modifier|*
name|overlap
parameter_list|,
name|struct
name|lockf_entry
modifier|*
name|lock
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|lockf_entry
modifier|*
name|lf
decl_stmt|;
name|off_t
name|start
decl_stmt|,
name|end
decl_stmt|;
name|int
name|res
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|overlap
operator|)
operator|==
name|NOLOCKF
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|2
condition|)
name|lf_print
argument_list|(
literal|"lf_findoverlap: looking for overlap in"
argument_list|,
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOCKF_DEBUG */
name|start
operator|=
name|lock
operator|->
name|lf_start
expr_stmt|;
name|end
operator|=
name|lock
operator|->
name|lf_end
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|overlap
condition|)
block|{
name|lf
operator|=
operator|*
name|overlap
expr_stmt|;
if|if
condition|(
name|lf
operator|->
name|lf_start
operator|>
name|end
condition|)
break|break;
if|if
condition|(
operator|(
operator|(
name|type
operator|&
name|SELF
operator|)
operator|&&
name|lf
operator|->
name|lf_owner
operator|!=
name|lock
operator|->
name|lf_owner
operator|)
operator|||
operator|(
operator|(
name|type
operator|&
name|OTHERS
operator|)
operator|&&
name|lf
operator|->
name|lf_owner
operator|==
name|lock
operator|->
name|lf_owner
operator|)
condition|)
block|{
operator|*
name|overlap
operator|=
name|LIST_NEXT
argument_list|(
name|lf
argument_list|,
name|lf_link
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|2
condition|)
name|lf_print
argument_list|(
literal|"\tchecking"
argument_list|,
name|lf
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOCKF_DEBUG */
comment|/* 		 * OK, check for overlap 		 * 		 * Six cases: 		 *	0) no overlap 		 *	1) overlap == lock 		 *	2) overlap contains lock 		 *	3) lock contains overlap 		 *	4) overlap starts before lock 		 *	5) overlap ends after lock 		 */
if|if
condition|(
name|start
operator|>
name|lf
operator|->
name|lf_end
condition|)
block|{
comment|/* Case 0 */
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|2
condition|)
name|printf
argument_list|(
literal|"no overlap\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOCKF_DEBUG */
operator|*
name|overlap
operator|=
name|LIST_NEXT
argument_list|(
name|lf
argument_list|,
name|lf_link
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|lf
operator|->
name|lf_start
operator|==
name|start
operator|&&
name|lf
operator|->
name|lf_end
operator|==
name|end
condition|)
block|{
comment|/* Case 1 */
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|2
condition|)
name|printf
argument_list|(
literal|"overlap == lock\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOCKF_DEBUG */
name|res
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|lf
operator|->
name|lf_start
operator|<=
name|start
operator|&&
name|lf
operator|->
name|lf_end
operator|>=
name|end
condition|)
block|{
comment|/* Case 2 */
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|2
condition|)
name|printf
argument_list|(
literal|"overlap contains lock\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOCKF_DEBUG */
name|res
operator|=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|start
operator|<=
name|lf
operator|->
name|lf_start
operator|&&
name|end
operator|>=
name|lf
operator|->
name|lf_end
condition|)
block|{
comment|/* Case 3 */
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|2
condition|)
name|printf
argument_list|(
literal|"lock contains overlap\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOCKF_DEBUG */
name|res
operator|=
literal|3
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|lf
operator|->
name|lf_start
operator|<
name|start
operator|&&
name|lf
operator|->
name|lf_end
operator|>=
name|start
condition|)
block|{
comment|/* Case 4 */
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|2
condition|)
name|printf
argument_list|(
literal|"overlap starts before lock\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOCKF_DEBUG */
name|res
operator|=
literal|4
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|lf
operator|->
name|lf_start
operator|>
name|start
operator|&&
name|lf
operator|->
name|lf_end
operator|>
name|end
condition|)
block|{
comment|/* Case 5 */
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|2
condition|)
name|printf
argument_list|(
literal|"overlap ends after lock\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* LOCKF_DEBUG */
name|res
operator|=
literal|5
expr_stmt|;
break|break;
block|}
name|panic
argument_list|(
literal|"lf_findoverlap: default"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Split an the existing 'lock1', based on the extent of the lock  * described by 'lock2'. The existing lock should cover 'lock2'  * entirely.  *  * Any pending locks which have been been unblocked are added to  * 'granted'  */
end_comment

begin_function
specifier|static
name|void
name|lf_split
parameter_list|(
name|struct
name|lockf
modifier|*
name|state
parameter_list|,
name|struct
name|lockf_entry
modifier|*
name|lock1
parameter_list|,
name|struct
name|lockf_entry
modifier|*
name|lock2
parameter_list|,
name|struct
name|lockf_entry_list
modifier|*
name|granted
parameter_list|)
block|{
name|struct
name|lockf_entry
modifier|*
name|splitlock
decl_stmt|;
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|2
condition|)
block|{
name|lf_print
argument_list|(
literal|"lf_split"
argument_list|,
name|lock1
argument_list|)
expr_stmt|;
name|lf_print
argument_list|(
literal|"splitting from"
argument_list|,
name|lock2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LOCKF_DEBUG */
comment|/* 	 * Check to see if we don't need to split at all. 	 */
if|if
condition|(
name|lock1
operator|->
name|lf_start
operator|==
name|lock2
operator|->
name|lf_start
condition|)
block|{
name|lf_set_start
argument_list|(
name|state
argument_list|,
name|lock1
argument_list|,
name|lock2
operator|->
name|lf_end
operator|+
literal|1
argument_list|,
name|granted
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|lock1
operator|->
name|lf_end
operator|==
name|lock2
operator|->
name|lf_end
condition|)
block|{
name|lf_set_end
argument_list|(
name|state
argument_list|,
name|lock1
argument_list|,
name|lock2
operator|->
name|lf_start
operator|-
literal|1
argument_list|,
name|granted
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Make a new lock consisting of the last part of 	 * the encompassing lock. 	 */
name|splitlock
operator|=
name|lf_alloc_lock
argument_list|(
name|lock1
operator|->
name|lf_owner
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|splitlock
argument_list|,
name|lock1
argument_list|,
sizeof|sizeof
expr|*
name|splitlock
argument_list|)
expr_stmt|;
name|splitlock
operator|->
name|lf_refs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|splitlock
operator|->
name|lf_flags
operator|&
name|F_REMOTE
condition|)
name|vref
argument_list|(
name|splitlock
operator|->
name|lf_vnode
argument_list|)
expr_stmt|;
comment|/* 	 * This cannot cause a deadlock since any edges we would add 	 * to splitlock already exist in lock1. We must be sure to add 	 * necessary dependancies to splitlock before we reduce lock1 	 * otherwise we may accidentally grant a pending lock that 	 * was blocked by the tail end of lock1. 	 */
name|splitlock
operator|->
name|lf_start
operator|=
name|lock2
operator|->
name|lf_end
operator|+
literal|1
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|splitlock
operator|->
name|lf_outedges
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|splitlock
operator|->
name|lf_inedges
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|lf_owner_graph_lock
argument_list|)
expr_stmt|;
name|lf_add_incoming
argument_list|(
name|state
argument_list|,
name|splitlock
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|lf_owner_graph_lock
argument_list|)
expr_stmt|;
name|lf_set_end
argument_list|(
name|state
argument_list|,
name|lock1
argument_list|,
name|lock2
operator|->
name|lf_start
operator|-
literal|1
argument_list|,
name|granted
argument_list|)
expr_stmt|;
comment|/* 	 * OK, now link it in 	 */
name|lf_insert_lock
argument_list|(
name|state
argument_list|,
name|splitlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|lockdesc
block|{
name|STAILQ_ENTRY
argument_list|(
argument|lockdesc
argument_list|)
name|link
expr_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|flock
name|fl
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|STAILQ_HEAD
argument_list|(
name|lockdesclist
argument_list|,
name|lockdesc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|lf_iteratelocks_sysid
parameter_list|(
name|int
name|sysid
parameter_list|,
name|lf_iterator
modifier|*
name|fn
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|lockf
modifier|*
name|ls
decl_stmt|;
name|struct
name|lockf_entry
modifier|*
name|lf
decl_stmt|;
name|struct
name|lockdesc
modifier|*
name|ldesc
decl_stmt|;
name|struct
name|lockdesclist
name|locks
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * In order to keep the locking simple, we iterate over the 	 * active lock lists to build a list of locks that need 	 * releasing. We then call the iterator for each one in turn. 	 * 	 * We take an extra reference to the vnode for the duration to 	 * make sure it doesn't go away before we are finished. 	 */
name|STAILQ_INIT
argument_list|(
operator|&
name|locks
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|lf_lock_states_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ls
argument_list|,
argument|&lf_lock_states
argument_list|,
argument|ls_link
argument_list|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|ls
operator|->
name|ls_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lf
argument_list|,
argument|&ls->ls_active
argument_list|,
argument|lf_link
argument_list|)
block|{
if|if
condition|(
name|lf
operator|->
name|lf_owner
operator|->
name|lo_sysid
operator|!=
name|sysid
condition|)
continue|continue;
name|ldesc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lockdesc
argument_list|)
argument_list|,
name|M_LOCKF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ldesc
operator|->
name|vp
operator|=
name|lf
operator|->
name|lf_vnode
expr_stmt|;
name|vref
argument_list|(
name|ldesc
operator|->
name|vp
argument_list|)
expr_stmt|;
name|ldesc
operator|->
name|fl
operator|.
name|l_start
operator|=
name|lf
operator|->
name|lf_start
expr_stmt|;
if|if
condition|(
name|lf
operator|->
name|lf_end
operator|==
name|OFF_MAX
condition|)
name|ldesc
operator|->
name|fl
operator|.
name|l_len
operator|=
literal|0
expr_stmt|;
else|else
name|ldesc
operator|->
name|fl
operator|.
name|l_len
operator|=
name|lf
operator|->
name|lf_end
operator|-
name|lf
operator|->
name|lf_start
operator|+
literal|1
expr_stmt|;
name|ldesc
operator|->
name|fl
operator|.
name|l_whence
operator|=
name|SEEK_SET
expr_stmt|;
name|ldesc
operator|->
name|fl
operator|.
name|l_type
operator|=
name|F_UNLCK
expr_stmt|;
name|ldesc
operator|->
name|fl
operator|.
name|l_pid
operator|=
name|lf
operator|->
name|lf_owner
operator|->
name|lo_pid
expr_stmt|;
name|ldesc
operator|->
name|fl
operator|.
name|l_sysid
operator|=
name|sysid
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|locks
argument_list|,
name|ldesc
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|ls
operator|->
name|ls_lock
argument_list|)
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|lf_lock_states_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Call the iterator function for each lock in turn. If the 	 * iterator returns an error code, just free the rest of the 	 * lockdesc structures. 	 */
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ldesc
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|locks
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|locks
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|fn
argument_list|(
name|ldesc
operator|->
name|vp
argument_list|,
operator|&
name|ldesc
operator|->
name|fl
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ldesc
operator|->
name|vp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ldesc
argument_list|,
name|M_LOCKF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lf_iteratelocks_vnode
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|lf_iterator
modifier|*
name|fn
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|lockf
modifier|*
name|ls
decl_stmt|;
name|struct
name|lockf_entry
modifier|*
name|lf
decl_stmt|;
name|struct
name|lockdesc
modifier|*
name|ldesc
decl_stmt|;
name|struct
name|lockdesclist
name|locks
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * In order to keep the locking simple, we iterate over the 	 * active lock lists to build a list of locks that need 	 * releasing. We then call the iterator for each one in turn. 	 * 	 * We take an extra reference to the vnode for the duration to 	 * make sure it doesn't go away before we are finished. 	 */
name|STAILQ_INIT
argument_list|(
operator|&
name|locks
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ls
operator|=
name|vp
operator|->
name|v_lockf
expr_stmt|;
if|if
condition|(
operator|!
name|ls
condition|)
block|{
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ls
operator|->
name|ls_threads
operator|++
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|ls
operator|->
name|ls_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lf
argument_list|,
argument|&ls->ls_active
argument_list|,
argument|lf_link
argument_list|)
block|{
name|ldesc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lockdesc
argument_list|)
argument_list|,
name|M_LOCKF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ldesc
operator|->
name|vp
operator|=
name|lf
operator|->
name|lf_vnode
expr_stmt|;
name|vref
argument_list|(
name|ldesc
operator|->
name|vp
argument_list|)
expr_stmt|;
name|ldesc
operator|->
name|fl
operator|.
name|l_start
operator|=
name|lf
operator|->
name|lf_start
expr_stmt|;
if|if
condition|(
name|lf
operator|->
name|lf_end
operator|==
name|OFF_MAX
condition|)
name|ldesc
operator|->
name|fl
operator|.
name|l_len
operator|=
literal|0
expr_stmt|;
else|else
name|ldesc
operator|->
name|fl
operator|.
name|l_len
operator|=
name|lf
operator|->
name|lf_end
operator|-
name|lf
operator|->
name|lf_start
operator|+
literal|1
expr_stmt|;
name|ldesc
operator|->
name|fl
operator|.
name|l_whence
operator|=
name|SEEK_SET
expr_stmt|;
name|ldesc
operator|->
name|fl
operator|.
name|l_type
operator|=
name|F_UNLCK
expr_stmt|;
name|ldesc
operator|->
name|fl
operator|.
name|l_pid
operator|=
name|lf
operator|->
name|lf_owner
operator|->
name|lo_pid
expr_stmt|;
name|ldesc
operator|->
name|fl
operator|.
name|l_sysid
operator|=
name|lf
operator|->
name|lf_owner
operator|->
name|lo_sysid
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|locks
argument_list|,
name|ldesc
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|ls
operator|->
name|ls_lock
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ls
operator|->
name|ls_threads
operator|--
expr_stmt|;
name|wakeup
argument_list|(
name|ls
argument_list|)
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 	 * Call the iterator function for each lock in turn. If the 	 * iterator returns an error code, just free the rest of the 	 * lockdesc structures. 	 */
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ldesc
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|locks
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|locks
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|fn
argument_list|(
name|ldesc
operator|->
name|vp
argument_list|,
operator|&
name|ldesc
operator|->
name|fl
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ldesc
operator|->
name|vp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ldesc
argument_list|,
name|M_LOCKF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lf_clearremotesys_iterator
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|flock
modifier|*
name|fl
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|VOP_ADVLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|F_UNLCK
argument_list|,
name|fl
argument_list|,
name|F_REMOTE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lf_clearremotesys
parameter_list|(
name|int
name|sysid
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|sysid
operator|!=
literal|0
argument_list|,
operator|(
literal|"Can't clear local locks with F_UNLCKSYS"
operator|)
argument_list|)
expr_stmt|;
name|lf_iteratelocks_sysid
argument_list|(
name|sysid
argument_list|,
name|lf_clearremotesys_iterator
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|lf_countlocks
parameter_list|(
name|int
name|sysid
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|lock_owner
modifier|*
name|lo
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|lf_lock_owners_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LOCK_OWNER_HASH_SIZE
condition|;
name|i
operator|++
control|)
name|LIST_FOREACH
argument_list|(
argument|lo
argument_list|,
argument|&lf_lock_owners[i]
argument_list|,
argument|lo_link
argument_list|)
if|if
condition|(
name|lo
operator|->
name|lo_sysid
operator|==
name|sysid
condition|)
name|count
operator|+=
name|lo
operator|->
name|lo_refs
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|lf_lock_owners_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
end_ifdef

begin_comment
comment|/*  * Return non-zero if y is reachable from x using a brute force  * search. If reachable and path is non-null, return the route taken  * in path.  */
end_comment

begin_function
specifier|static
name|int
name|graph_reaches
parameter_list|(
name|struct
name|owner_vertex
modifier|*
name|x
parameter_list|,
name|struct
name|owner_vertex
modifier|*
name|y
parameter_list|,
name|struct
name|owner_vertex_list
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|owner_edge
modifier|*
name|e
decl_stmt|;
if|if
condition|(
name|x
operator|==
name|y
condition|)
block|{
if|if
condition|(
name|path
condition|)
name|TAILQ_INSERT_HEAD
argument_list|(
name|path
argument_list|,
name|x
argument_list|,
name|v_link
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|LIST_FOREACH
argument_list|(
argument|e
argument_list|,
argument|&x->v_outedges
argument_list|,
argument|e_outlink
argument_list|)
block|{
if|if
condition|(
name|graph_reaches
argument_list|(
name|e
operator|->
name|e_to
argument_list|,
name|y
argument_list|,
name|path
argument_list|)
condition|)
block|{
if|if
condition|(
name|path
condition|)
name|TAILQ_INSERT_HEAD
argument_list|(
name|path
argument_list|,
name|x
argument_list|,
name|v_link
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Perform consistency checks on the graph. Make sure the values of  * v_order are correct. If checkorder is non-zero, check no vertex can  * reach any other vertex with a smaller order.  */
end_comment

begin_function
specifier|static
name|void
name|graph_check
parameter_list|(
name|struct
name|owner_graph
modifier|*
name|g
parameter_list|,
name|int
name|checkorder
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|g_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|g
operator|->
name|g_vertices
index|[
name|i
index|]
operator|->
name|v_owner
condition|)
continue|continue;
name|KASSERT
argument_list|(
name|g
operator|->
name|g_vertices
index|[
name|i
index|]
operator|->
name|v_order
operator|==
name|i
argument_list|,
operator|(
literal|"lock graph vertices disordered"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|checkorder
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|g
operator|->
name|g_vertices
index|[
name|j
index|]
operator|->
name|v_owner
condition|)
continue|continue;
name|KASSERT
argument_list|(
operator|!
name|graph_reaches
argument_list|(
name|g
operator|->
name|g_vertices
index|[
name|i
index|]
argument_list|,
name|g
operator|->
name|g_vertices
index|[
name|j
index|]
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|(
literal|"lock graph vertices disordered"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|graph_print_vertices
parameter_list|(
name|struct
name|owner_vertex_list
modifier|*
name|set
parameter_list|)
block|{
name|struct
name|owner_vertex
modifier|*
name|v
decl_stmt|;
name|printf
argument_list|(
literal|"{ "
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|v
argument_list|,
argument|set
argument_list|,
argument|v_link
argument_list|)
block|{
name|printf
argument_list|(
literal|"%d:"
argument_list|,
name|v
operator|->
name|v_order
argument_list|)
expr_stmt|;
name|lf_print_owner
argument_list|(
name|v
operator|->
name|v_owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_NEXT
argument_list|(
name|v
argument_list|,
name|v_link
argument_list|)
condition|)
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" }\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Calculate the sub-set of vertices v from the affected region [y..x]  * where v is reachable from y. Return -1 if a loop was detected  * (i.e. x is reachable from y, otherwise the number of vertices in  * this subset.  */
end_comment

begin_function
specifier|static
name|int
name|graph_delta_forward
parameter_list|(
name|struct
name|owner_graph
modifier|*
name|g
parameter_list|,
name|struct
name|owner_vertex
modifier|*
name|x
parameter_list|,
name|struct
name|owner_vertex
modifier|*
name|y
parameter_list|,
name|struct
name|owner_vertex_list
modifier|*
name|delta
parameter_list|)
block|{
name|uint32_t
name|gen
decl_stmt|;
name|struct
name|owner_vertex
modifier|*
name|v
decl_stmt|;
name|struct
name|owner_edge
modifier|*
name|e
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* 	 * We start with a set containing just y. Then for each vertex 	 * v in the set so far unprocessed, we add each vertex that v 	 * has an out-edge to and that is within the affected region 	 * [y..x]. If we see the vertex x on our travels, stop 	 * immediately. 	 */
name|TAILQ_INIT
argument_list|(
name|delta
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|delta
argument_list|,
name|y
argument_list|,
name|v_link
argument_list|)
expr_stmt|;
name|v
operator|=
name|y
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
name|gen
operator|=
name|g
operator|->
name|g_gen
expr_stmt|;
while|while
condition|(
name|v
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|e
argument_list|,
argument|&v->v_outedges
argument_list|,
argument|e_outlink
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|e_to
operator|==
name|x
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|e
operator|->
name|e_to
operator|->
name|v_order
operator|<
name|x
operator|->
name|v_order
operator|&&
name|e
operator|->
name|e_to
operator|->
name|v_gen
operator|!=
name|gen
condition|)
block|{
name|e
operator|->
name|e_to
operator|->
name|v_gen
operator|=
name|gen
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|delta
argument_list|,
name|e
operator|->
name|e_to
argument_list|,
name|v_link
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
name|v
operator|=
name|TAILQ_NEXT
argument_list|(
name|v
argument_list|,
name|v_link
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the sub-set of vertices v from the affected region [y..x]  * where v reaches x. Return the number of vertices in this subset.  */
end_comment

begin_function
specifier|static
name|int
name|graph_delta_backward
parameter_list|(
name|struct
name|owner_graph
modifier|*
name|g
parameter_list|,
name|struct
name|owner_vertex
modifier|*
name|x
parameter_list|,
name|struct
name|owner_vertex
modifier|*
name|y
parameter_list|,
name|struct
name|owner_vertex_list
modifier|*
name|delta
parameter_list|)
block|{
name|uint32_t
name|gen
decl_stmt|;
name|struct
name|owner_vertex
modifier|*
name|v
decl_stmt|;
name|struct
name|owner_edge
modifier|*
name|e
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* 	 * We start with a set containing just x. Then for each vertex 	 * v in the set so far unprocessed, we add each vertex that v 	 * has an in-edge from and that is within the affected region 	 * [y..x]. 	 */
name|TAILQ_INIT
argument_list|(
name|delta
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|delta
argument_list|,
name|x
argument_list|,
name|v_link
argument_list|)
expr_stmt|;
name|v
operator|=
name|x
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
name|gen
operator|=
name|g
operator|->
name|g_gen
expr_stmt|;
while|while
condition|(
name|v
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|e
argument_list|,
argument|&v->v_inedges
argument_list|,
argument|e_inlink
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|e_from
operator|->
name|v_order
operator|>
name|y
operator|->
name|v_order
operator|&&
name|e
operator|->
name|e_from
operator|->
name|v_gen
operator|!=
name|gen
condition|)
block|{
name|e
operator|->
name|e_from
operator|->
name|v_gen
operator|=
name|gen
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
name|delta
argument_list|,
name|e
operator|->
name|e_from
argument_list|,
name|v_link
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
block|}
name|v
operator|=
name|TAILQ_PREV
argument_list|(
name|v
argument_list|,
name|owner_vertex_list
argument_list|,
name|v_link
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|graph_add_indices
parameter_list|(
name|int
modifier|*
name|indices
parameter_list|,
name|int
name|n
parameter_list|,
name|struct
name|owner_vertex_list
modifier|*
name|set
parameter_list|)
block|{
name|struct
name|owner_vertex
modifier|*
name|v
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|v
argument_list|,
argument|set
argument_list|,
argument|v_link
argument_list|)
block|{
for|for
control|(
name|i
operator|=
name|n
init|;
name|i
operator|>
literal|0
operator|&&
name|indices
index|[
name|i
operator|-
literal|1
index|]
operator|>
name|v
operator|->
name|v_order
condition|;
name|i
operator|--
control|)
empty_stmt|;
for|for
control|(
name|j
operator|=
name|n
operator|-
literal|1
init|;
name|j
operator|>=
name|i
condition|;
name|j
operator|--
control|)
name|indices
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|indices
index|[
name|j
index|]
expr_stmt|;
name|indices
index|[
name|i
index|]
operator|=
name|v
operator|->
name|v_order
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|graph_assign_indices
parameter_list|(
name|struct
name|owner_graph
modifier|*
name|g
parameter_list|,
name|int
modifier|*
name|indices
parameter_list|,
name|int
name|nextunused
parameter_list|,
name|struct
name|owner_vertex_list
modifier|*
name|set
parameter_list|)
block|{
name|struct
name|owner_vertex
modifier|*
name|v
decl_stmt|,
modifier|*
name|vlowest
decl_stmt|;
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
name|set
argument_list|)
condition|)
block|{
name|vlowest
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|v
argument_list|,
argument|set
argument_list|,
argument|v_link
argument_list|)
block|{
if|if
condition|(
operator|!
name|vlowest
operator|||
name|v
operator|->
name|v_order
operator|<
name|vlowest
operator|->
name|v_order
condition|)
name|vlowest
operator|=
name|v
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
name|set
argument_list|,
name|vlowest
argument_list|,
name|v_link
argument_list|)
expr_stmt|;
name|vlowest
operator|->
name|v_order
operator|=
name|indices
index|[
name|nextunused
index|]
expr_stmt|;
name|g
operator|->
name|g_vertices
index|[
name|vlowest
operator|->
name|v_order
index|]
operator|=
name|vlowest
expr_stmt|;
name|nextunused
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|nextunused
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|graph_add_edge
parameter_list|(
name|struct
name|owner_graph
modifier|*
name|g
parameter_list|,
name|struct
name|owner_vertex
modifier|*
name|x
parameter_list|,
name|struct
name|owner_vertex
modifier|*
name|y
parameter_list|)
block|{
name|struct
name|owner_edge
modifier|*
name|e
decl_stmt|;
name|struct
name|owner_vertex_list
name|deltaF
decl_stmt|,
name|deltaB
decl_stmt|;
name|int
name|nF
decl_stmt|,
name|nB
decl_stmt|,
name|n
decl_stmt|,
name|vi
decl_stmt|,
name|i
decl_stmt|;
name|int
modifier|*
name|indices
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|lf_owner_graph_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|e
argument_list|,
argument|&x->v_outedges
argument_list|,
argument|e_outlink
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|e_to
operator|==
name|y
condition|)
block|{
name|e
operator|->
name|e_refs
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|"adding edge %d:"
argument_list|,
name|x
operator|->
name|v_order
argument_list|)
expr_stmt|;
name|lf_print_owner
argument_list|(
name|x
operator|->
name|v_owner
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -> %d:"
argument_list|,
name|y
operator|->
name|v_order
argument_list|)
expr_stmt|;
name|lf_print_owner
argument_list|(
name|y
operator|->
name|v_owner
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|y
operator|->
name|v_order
operator|<
name|x
operator|->
name|v_order
condition|)
block|{
comment|/* 		 * The new edge violates the order. First find the set 		 * of affected vertices reachable from y (deltaF) and 		 * the set of affect vertices affected that reach x 		 * (deltaB), using the graph generation number to 		 * detect whether we have visited a given vertex 		 * already. We re-order the graph so that each vertex 		 * in deltaB appears before each vertex in deltaF. 		 * 		 * If x is a member of deltaF, then the new edge would 		 * create a cycle. Otherwise, we may assume that 		 * deltaF and deltaB are disjoint. 		 */
name|g
operator|->
name|g_gen
operator|++
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|g_gen
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Generation wrap. 			 */
for|for
control|(
name|vi
operator|=
literal|0
init|;
name|vi
operator|<
name|g
operator|->
name|g_size
condition|;
name|vi
operator|++
control|)
block|{
name|g
operator|->
name|g_vertices
index|[
name|vi
index|]
operator|->
name|v_gen
operator|=
literal|0
expr_stmt|;
block|}
name|g
operator|->
name|g_gen
operator|++
expr_stmt|;
block|}
name|nF
operator|=
name|graph_delta_forward
argument_list|(
name|g
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|deltaF
argument_list|)
expr_stmt|;
if|if
condition|(
name|nF
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|8
condition|)
block|{
name|struct
name|owner_vertex_list
name|path
decl_stmt|;
name|printf
argument_list|(
literal|"deadlock: "
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
name|graph_reaches
argument_list|(
name|y
argument_list|,
name|x
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
name|graph_print_vertices
argument_list|(
operator|&
name|path
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|EDEADLK
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|"re-ordering graph vertices\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"deltaF = "
argument_list|)
expr_stmt|;
name|graph_print_vertices
argument_list|(
operator|&
name|deltaF
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|nB
operator|=
name|graph_delta_backward
argument_list|(
name|g
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|deltaB
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|"deltaB = "
argument_list|)
expr_stmt|;
name|graph_print_vertices
argument_list|(
operator|&
name|deltaB
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * We first build a set of vertex indices (vertex 		 * order values) that we may use, then we re-assign 		 * orders first to those vertices in deltaB, then to 		 * deltaF. Note that the contents of deltaF and deltaB 		 * may be partially disordered - we perform an 		 * insertion sort while building our index set. 		 */
name|indices
operator|=
name|g
operator|->
name|g_indexbuf
expr_stmt|;
name|n
operator|=
name|graph_add_indices
argument_list|(
name|indices
argument_list|,
literal|0
argument_list|,
operator|&
name|deltaF
argument_list|)
expr_stmt|;
name|graph_add_indices
argument_list|(
name|indices
argument_list|,
name|n
argument_list|,
operator|&
name|deltaB
argument_list|)
expr_stmt|;
comment|/* 		 * We must also be sure to maintain the relative 		 * ordering of deltaF and deltaB when re-assigning 		 * vertices. We do this by iteratively removing the 		 * lowest ordered element from the set and assigning 		 * it the next value from our new ordering. 		 */
name|i
operator|=
name|graph_assign_indices
argument_list|(
name|g
argument_list|,
name|indices
argument_list|,
literal|0
argument_list|,
operator|&
name|deltaB
argument_list|)
expr_stmt|;
name|graph_assign_indices
argument_list|(
name|g
argument_list|,
name|indices
argument_list|,
name|i
argument_list|,
operator|&
name|deltaF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|8
condition|)
block|{
name|struct
name|owner_vertex_list
name|set
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nB
operator|+
name|nF
condition|;
name|i
operator|++
control|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|set
argument_list|,
name|g
operator|->
name|g_vertices
index|[
name|indices
index|[
name|i
index|]
index|]
argument_list|,
name|v_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"new ordering = "
argument_list|)
expr_stmt|;
name|graph_print_vertices
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|KASSERT
argument_list|(
name|x
operator|->
name|v_order
operator|<
name|y
operator|->
name|v_order
argument_list|,
operator|(
literal|"Failed to re-order graph"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|8
condition|)
block|{
name|graph_check
argument_list|(
name|g
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|e
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|owner_edge
argument_list|)
argument_list|,
name|M_LOCKF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|x
operator|->
name|v_outedges
argument_list|,
name|e
argument_list|,
name|e_outlink
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|y
operator|->
name|v_inedges
argument_list|,
name|e
argument_list|,
name|e_inlink
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_refs
operator|=
literal|1
expr_stmt|;
name|e
operator|->
name|e_from
operator|=
name|x
expr_stmt|;
name|e
operator|->
name|e_to
operator|=
name|y
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove an edge x->y from the graph.  */
end_comment

begin_function
specifier|static
name|void
name|graph_remove_edge
parameter_list|(
name|struct
name|owner_graph
modifier|*
name|g
parameter_list|,
name|struct
name|owner_vertex
modifier|*
name|x
parameter_list|,
name|struct
name|owner_vertex
modifier|*
name|y
parameter_list|)
block|{
name|struct
name|owner_edge
modifier|*
name|e
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|lf_owner_graph_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|e
argument_list|,
argument|&x->v_outedges
argument_list|,
argument|e_outlink
argument_list|)
block|{
if|if
condition|(
name|e
operator|->
name|e_to
operator|==
name|y
condition|)
break|break;
block|}
name|KASSERT
argument_list|(
name|e
argument_list|,
operator|(
literal|"Removing non-existent edge from deadlock graph"
operator|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|e_refs
operator|--
expr_stmt|;
if|if
condition|(
name|e
operator|->
name|e_refs
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
if|if
condition|(
name|lockf_debug
operator|&
literal|8
condition|)
block|{
name|printf
argument_list|(
literal|"removing edge %d:"
argument_list|,
name|x
operator|->
name|v_order
argument_list|)
expr_stmt|;
name|lf_print_owner
argument_list|(
name|x
operator|->
name|v_owner
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" -> %d:"
argument_list|,
name|y
operator|->
name|v_order
argument_list|)
expr_stmt|;
name|lf_print_owner
argument_list|(
name|y
operator|->
name|v_owner
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|LIST_REMOVE
argument_list|(
name|e
argument_list|,
name|e_outlink
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|e
argument_list|,
name|e_inlink
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|,
name|M_LOCKF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a vertex from the free list. Return ENOMEM if there are  * none.  */
end_comment

begin_function
specifier|static
name|struct
name|owner_vertex
modifier|*
name|graph_alloc_vertex
parameter_list|(
name|struct
name|owner_graph
modifier|*
name|g
parameter_list|,
name|struct
name|lock_owner
modifier|*
name|lo
parameter_list|)
block|{
name|struct
name|owner_vertex
modifier|*
name|v
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|lf_owner_graph_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|v
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|owner_vertex
argument_list|)
argument_list|,
name|M_LOCKF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|g_size
operator|==
name|g
operator|->
name|g_space
condition|)
block|{
name|g
operator|->
name|g_vertices
operator|=
name|realloc
argument_list|(
name|g
operator|->
name|g_vertices
argument_list|,
literal|2
operator|*
name|g
operator|->
name|g_space
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|owner_vertex
operator|*
argument_list|)
argument_list|,
name|M_LOCKF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|g
operator|->
name|g_indexbuf
argument_list|,
name|M_LOCKF
argument_list|)
expr_stmt|;
name|g
operator|->
name|g_indexbuf
operator|=
name|malloc
argument_list|(
literal|2
operator|*
name|g
operator|->
name|g_space
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|M_LOCKF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|g
operator|->
name|g_space
operator|=
literal|2
operator|*
name|g
operator|->
name|g_space
expr_stmt|;
block|}
name|v
operator|->
name|v_order
operator|=
name|g
operator|->
name|g_size
expr_stmt|;
name|v
operator|->
name|v_gen
operator|=
name|g
operator|->
name|g_gen
expr_stmt|;
name|g
operator|->
name|g_vertices
index|[
name|g
operator|->
name|g_size
index|]
operator|=
name|v
expr_stmt|;
name|g
operator|->
name|g_size
operator|++
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|v
operator|->
name|v_outedges
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|v
operator|->
name|v_inedges
argument_list|)
expr_stmt|;
name|v
operator|->
name|v_owner
operator|=
name|lo
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|graph_free_vertex
parameter_list|(
name|struct
name|owner_graph
modifier|*
name|g
parameter_list|,
name|struct
name|owner_vertex
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|owner_vertex
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|lf_owner_graph_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|v
operator|->
name|v_outedges
argument_list|)
argument_list|,
operator|(
literal|"Freeing vertex with edges"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|v
operator|->
name|v_inedges
argument_list|)
argument_list|,
operator|(
literal|"Freeing vertex with edges"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Remove from the graph's array and close up the gap, 	 * renumbering the other vertices. 	 */
for|for
control|(
name|i
operator|=
name|v
operator|->
name|v_order
operator|+
literal|1
init|;
name|i
operator|<
name|g
operator|->
name|g_size
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|=
name|g
operator|->
name|g_vertices
index|[
name|i
index|]
expr_stmt|;
name|w
operator|->
name|v_order
operator|--
expr_stmt|;
name|g
operator|->
name|g_vertices
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|w
expr_stmt|;
block|}
name|g
operator|->
name|g_size
operator|--
expr_stmt|;
name|free
argument_list|(
name|v
argument_list|,
name|M_LOCKF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|owner_graph
modifier|*
name|graph_init
parameter_list|(
name|struct
name|owner_graph
modifier|*
name|g
parameter_list|)
block|{
name|g
operator|->
name|g_vertices
operator|=
name|malloc
argument_list|(
literal|10
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|owner_vertex
operator|*
argument_list|)
argument_list|,
name|M_LOCKF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|g
operator|->
name|g_size
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|g_space
operator|=
literal|10
expr_stmt|;
name|g
operator|->
name|g_indexbuf
operator|=
name|malloc
argument_list|(
name|g
operator|->
name|g_space
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|M_LOCKF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|g
operator|->
name|g_gen
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|g
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LOCKF_DEBUG
end_ifdef

begin_comment
comment|/*  * Print description of a lock owner  */
end_comment

begin_function
specifier|static
name|void
name|lf_print_owner
parameter_list|(
name|struct
name|lock_owner
modifier|*
name|lo
parameter_list|)
block|{
if|if
condition|(
name|lo
operator|->
name|lo_flags
operator|&
name|F_REMOTE
condition|)
block|{
name|printf
argument_list|(
literal|"remote pid %d, system %d"
argument_list|,
name|lo
operator|->
name|lo_pid
argument_list|,
name|lo
operator|->
name|lo_sysid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lo
operator|->
name|lo_flags
operator|&
name|F_FLOCK
condition|)
block|{
name|printf
argument_list|(
literal|"file %p"
argument_list|,
name|lo
operator|->
name|lo_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"local pid %d"
argument_list|,
name|lo
operator|->
name|lo_pid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print out a lock.  */
end_comment

begin_function
specifier|static
name|void
name|lf_print
parameter_list|(
name|char
modifier|*
name|tag
parameter_list|,
name|struct
name|lockf_entry
modifier|*
name|lock
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s: lock %p for "
argument_list|,
name|tag
argument_list|,
operator|(
name|void
operator|*
operator|)
name|lock
argument_list|)
expr_stmt|;
name|lf_print_owner
argument_list|(
name|lock
operator|->
name|lf_owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|->
name|lf_inode
operator|!=
operator|(
expr|struct
name|inode
operator|*
operator|)
literal|0
condition|)
name|printf
argument_list|(
literal|" in ino %ju on dev<%s>,"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lock
operator|->
name|lf_inode
operator|->
name|i_number
argument_list|,
name|devtoname
argument_list|(
name|lock
operator|->
name|lf_inode
operator|->
name|i_dev
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s, start %jd, end "
argument_list|,
name|lock
operator|->
name|lf_type
operator|==
name|F_RDLCK
condition|?
literal|"shared"
else|:
name|lock
operator|->
name|lf_type
operator|==
name|F_WRLCK
condition|?
literal|"exclusive"
else|:
name|lock
operator|->
name|lf_type
operator|==
name|F_UNLCK
condition|?
literal|"unlock"
else|:
literal|"unknown"
argument_list|,
operator|(
name|intmax_t
operator|)
name|lock
operator|->
name|lf_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|->
name|lf_end
operator|==
name|OFF_MAX
condition|)
name|printf
argument_list|(
literal|"EOF"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|lock
operator|->
name|lf_end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|lock
operator|->
name|lf_outedges
argument_list|)
condition|)
name|printf
argument_list|(
literal|" block %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|LIST_FIRST
argument_list|(
operator|&
name|lock
operator|->
name|lf_outedges
argument_list|)
operator|->
name|le_to
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lf_printlist
parameter_list|(
name|char
modifier|*
name|tag
parameter_list|,
name|struct
name|lockf_entry
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|lockf_entry
modifier|*
name|lf
decl_stmt|,
modifier|*
name|blk
decl_stmt|;
name|struct
name|lockf_edge
modifier|*
name|e
decl_stmt|;
if|if
condition|(
name|lock
operator|->
name|lf_inode
operator|==
operator|(
expr|struct
name|inode
operator|*
operator|)
literal|0
condition|)
return|return;
name|printf
argument_list|(
literal|"%s: Lock list for ino %ju on dev<%s>:\n"
argument_list|,
name|tag
argument_list|,
operator|(
name|uintmax_t
operator|)
name|lock
operator|->
name|lf_inode
operator|->
name|i_number
argument_list|,
name|devtoname
argument_list|(
name|lock
operator|->
name|lf_inode
operator|->
name|i_dev
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lf
argument_list|,
argument|&lock->lf_vnode->v_lockf->ls_active
argument_list|,
argument|lf_link
argument_list|)
block|{
name|printf
argument_list|(
literal|"\tlock %p for "
argument_list|,
operator|(
name|void
operator|*
operator|)
name|lf
argument_list|)
expr_stmt|;
name|lf_print_owner
argument_list|(
name|lock
operator|->
name|lf_owner
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %s, start %jd, end %jd"
argument_list|,
name|lf
operator|->
name|lf_type
operator|==
name|F_RDLCK
condition|?
literal|"shared"
else|:
name|lf
operator|->
name|lf_type
operator|==
name|F_WRLCK
condition|?
literal|"exclusive"
else|:
name|lf
operator|->
name|lf_type
operator|==
name|F_UNLCK
condition|?
literal|"unlock"
else|:
literal|"unknown"
argument_list|,
operator|(
name|intmax_t
operator|)
name|lf
operator|->
name|lf_start
argument_list|,
operator|(
name|intmax_t
operator|)
name|lf
operator|->
name|lf_end
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|e
argument_list|,
argument|&lf->lf_outedges
argument_list|,
argument|le_outlink
argument_list|)
block|{
name|blk
operator|=
name|e
operator|->
name|le_to
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t\tlock request %p for "
argument_list|,
operator|(
name|void
operator|*
operator|)
name|blk
argument_list|)
expr_stmt|;
name|lf_print_owner
argument_list|(
name|blk
operator|->
name|lf_owner
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|", %s, start %jd, end %jd"
argument_list|,
name|blk
operator|->
name|lf_type
operator|==
name|F_RDLCK
condition|?
literal|"shared"
else|:
name|blk
operator|->
name|lf_type
operator|==
name|F_WRLCK
condition|?
literal|"exclusive"
else|:
name|blk
operator|->
name|lf_type
operator|==
name|F_UNLCK
condition|?
literal|"unlock"
else|:
literal|"unknown"
argument_list|,
operator|(
name|intmax_t
operator|)
name|blk
operator|->
name|lf_start
argument_list|,
operator|(
name|intmax_t
operator|)
name|blk
operator|->
name|lf_end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|blk
operator|->
name|lf_inedges
argument_list|)
condition|)
name|panic
argument_list|(
literal|"lf_printlist: bad list"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LOCKF_DEBUG */
end_comment

end_unit

