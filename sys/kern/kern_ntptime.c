begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  ***********************************************************************  *								       *  * Copyright (c) David L. Mills 1993-2001			       *  *								       *  * Permission to use, copy, modify, and distribute this software and   *  * its documentation for any purpose and without fee is hereby	       *  * granted, provided that the above copyright notice appears in all    *  * copies and that both the copyright notice and this permission       *  * notice appear in supporting documentation, and that the name	       *  * University of Delaware not be used in advertising or publicity      *  * pertaining to distribution of the software without specific,	       *  * written prior permission. The University of Delaware makes no       *  * representations about the suitability this software for any	       *  * purpose. It is provided "as is" without express or implied	       *  * warranty.							       *  *								       *  **********************************************************************/
end_comment

begin_comment
comment|/*  * Adapted from the original sources for FreeBSD and timecounters by:  * Poul-Henning Kamp<phk@FreeBSD.org>.  *  * The 32bit version of the "LP" macros seems a bit past its "sell by"   * date so I have retained only the 64bit version and included it directly  * in this file.  *  * Only minor changes done to interface with the timecounters over in  * sys/kern/kern_clock.c.   Some of the comments below may be (even more)  * confusing and/or plain wrong in that context.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ntp.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/timex.h>
end_include

begin_include
include|#
directive|include
file|<sys/timetc.h>
end_include

begin_include
include|#
directive|include
file|<sys/timepps.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_comment
comment|/*  * Single-precision macros for 64-bit machines  */
end_comment

begin_typedef
typedef|typedef
name|int64_t
name|l_fp
typedef|;
end_typedef

begin_define
define|#
directive|define
name|L_ADD
parameter_list|(
name|v
parameter_list|,
name|u
parameter_list|)
value|((v) += (u))
end_define

begin_define
define|#
directive|define
name|L_SUB
parameter_list|(
name|v
parameter_list|,
name|u
parameter_list|)
value|((v) -= (u))
end_define

begin_define
define|#
directive|define
name|L_ADDHI
parameter_list|(
name|v
parameter_list|,
name|a
parameter_list|)
value|((v) += (int64_t)(a)<< 32)
end_define

begin_define
define|#
directive|define
name|L_NEG
parameter_list|(
name|v
parameter_list|)
value|((v) = -(v))
end_define

begin_define
define|#
directive|define
name|L_RSHIFT
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
define|\
value|do { \ 		if ((v)< 0) \ 			(v) = -(-(v)>> (n)); \ 		else \ 			(v) = (v)>> (n); \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|L_MPY
parameter_list|(
name|v
parameter_list|,
name|a
parameter_list|)
value|((v) *= (a))
end_define

begin_define
define|#
directive|define
name|L_CLR
parameter_list|(
name|v
parameter_list|)
value|((v) = 0)
end_define

begin_define
define|#
directive|define
name|L_ISNEG
parameter_list|(
name|v
parameter_list|)
value|((v)< 0)
end_define

begin_define
define|#
directive|define
name|L_LINT
parameter_list|(
name|v
parameter_list|,
name|a
parameter_list|)
value|((v) = (int64_t)(a)<< 32)
end_define

begin_define
define|#
directive|define
name|L_GINT
parameter_list|(
name|v
parameter_list|)
value|((v)< 0 ? -(-(v)>> 32) : (v)>> 32)
end_define

begin_comment
comment|/*  * Generic NTP kernel interface  *  * These routines constitute the Network Time Protocol (NTP) interfaces  * for user and daemon application programs. The ntp_gettime() routine  * provides the time, maximum error (synch distance) and estimated error  * (dispersion) to client user application programs. The ntp_adjtime()  * routine is used by the NTP daemon to adjust the system clock to an  * externally derived time. The time offset and related variables set by  * this routine are used by other routines in this module to adjust the  * phase and frequency of the clock discipline loop which controls the  * system clock.  *  * When the kernel time is reckoned directly in nanoseconds (NTP_NANO  * defined), the time at each tick interrupt is derived directly from  * the kernel time variable. When the kernel time is reckoned in  * microseconds, (NTP_NANO undefined), the time is derived from the  * kernel time variable together with a variable representing the  * leftover nanoseconds at the last tick interrupt. In either case, the  * current nanosecond time is reckoned from these values plus an  * interpolated value derived by the clock routines in another  * architecture-specific module. The interpolation can use either a  * dedicated counter or a processor cycle counter (PCC) implemented in  * some architectures.  *  * Note that all routines must run at priority splclock or higher.  */
end_comment

begin_comment
comment|/*  * Phase/frequency-lock loop (PLL/FLL) definitions  *  * The nanosecond clock discipline uses two variable types, time  * variables and frequency variables. Both types are represented as 64-  * bit fixed-point quantities with the decimal point between two 32-bit  * halves. On a 32-bit machine, each half is represented as a single  * word and mathematical operations are done using multiple-precision  * arithmetic. On a 64-bit machine, ordinary computer arithmetic is  * used.  *  * A time variable is a signed 64-bit fixed-point number in ns and  * fraction. It represents the remaining time offset to be amortized  * over succeeding tick interrupts. The maximum time offset is about  * 0.5 s and the resolution is about 2.3e-10 ns.  *  *			1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3  *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |s s s|			 ns				   |  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |			    fraction				   |  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  *  * A frequency variable is a signed 64-bit fixed-point number in ns/s  * and fraction. It represents the ns and fraction to be added to the  * kernel time variable at each second. The maximum frequency offset is  * about +-500000 ns/s and the resolution is about 2.3e-10 ns/s.  *  *			1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3  *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |s s s s s s s s s s s s s|	          ns/s			   |  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |			    fraction				   |  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  */
end_comment

begin_comment
comment|/*  * The following variables establish the state of the PLL/FLL and the  * residual time and frequency offset of the local clock.  */
end_comment

begin_define
define|#
directive|define
name|SHIFT_PLL
value|4
end_define

begin_comment
comment|/* PLL loop gain (shift) */
end_comment

begin_define
define|#
directive|define
name|SHIFT_FLL
value|2
end_define

begin_comment
comment|/* FLL loop gain (shift) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|time_state
init|=
name|TIME_OK
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clock state */
end_comment

begin_decl_stmt
specifier|static
name|int
name|time_status
init|=
name|STA_UNSYNC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clock status bits */
end_comment

begin_decl_stmt
specifier|static
name|long
name|time_tai
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TAI offset (s) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|time_monitor
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last time offset scaled (ns) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|time_constant
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* poll interval (shift) (s) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|time_precision
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clock precision (ns) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|time_maxerror
init|=
name|MAXPHASE
operator|/
literal|1000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum error (us) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|time_esterror
init|=
name|MAXPHASE
operator|/
literal|1000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* estimated error (us) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|time_reftime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time at last adjustment (s) */
end_comment

begin_decl_stmt
specifier|static
name|l_fp
name|time_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time offset (ns) */
end_comment

begin_decl_stmt
specifier|static
name|l_fp
name|time_freq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* frequency offset (ns/s) */
end_comment

begin_decl_stmt
specifier|static
name|l_fp
name|time_adj
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tick adjust (ns/s) */
end_comment

begin_decl_stmt
specifier|static
name|int64_t
name|time_adjtime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* correction from adjtime(2) (usec) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PPS_SYNC
end_ifdef

begin_comment
comment|/*  * The following variables are used when a pulse-per-second (PPS) signal  * is available and connected via a modem control lead. They establish  * the engineering parameters of the clock discipline loop when  * controlled by the PPS signal.  */
end_comment

begin_define
define|#
directive|define
name|PPS_FAVG
value|2
end_define

begin_comment
comment|/* min freq avg interval (s) (shift) */
end_comment

begin_define
define|#
directive|define
name|PPS_FAVGDEF
value|8
end_define

begin_comment
comment|/* default freq avg int (s) (shift) */
end_comment

begin_define
define|#
directive|define
name|PPS_FAVGMAX
value|15
end_define

begin_comment
comment|/* max freq avg interval (s) (shift) */
end_comment

begin_define
define|#
directive|define
name|PPS_PAVG
value|4
end_define

begin_comment
comment|/* phase avg interval (s) (shift) */
end_comment

begin_define
define|#
directive|define
name|PPS_VALID
value|120
end_define

begin_comment
comment|/* PPS signal watchdog max (s) */
end_comment

begin_define
define|#
directive|define
name|PPS_MAXWANDER
value|100000
end_define

begin_comment
comment|/* max PPS wander (ns/s) */
end_comment

begin_define
define|#
directive|define
name|PPS_POPCORN
value|2
end_define

begin_comment
comment|/* popcorn spike threshold (shift) */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|timespec
name|pps_tf
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* phase median filter */
end_comment

begin_decl_stmt
specifier|static
name|l_fp
name|pps_freq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scaled frequency offset (ns/s) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|pps_fcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* frequency accumulator */
end_comment

begin_decl_stmt
specifier|static
name|long
name|pps_jitter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nominal jitter (ns) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|pps_stabil
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nominal stability (scaled ns/s) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|pps_lastsec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time at last calibration (s) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pps_valid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* signal watchdog counter */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pps_shift
init|=
name|PPS_FAVG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interval duration (s) (shift) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pps_shiftmax
init|=
name|PPS_FAVGDEF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max interval duration (s) (shift) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pps_intcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* wander counter */
end_comment

begin_comment
comment|/*  * PPS signal quality monitors  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|pps_calcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calibration intervals */
end_comment

begin_decl_stmt
specifier|static
name|long
name|pps_jitcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* jitter limit exceeded */
end_comment

begin_decl_stmt
specifier|static
name|long
name|pps_stbcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stability limit exceeded */
end_comment

begin_decl_stmt
specifier|static
name|long
name|pps_errcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calibration errors */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPS_SYNC */
end_comment

begin_comment
comment|/*  * End of phase/frequency-lock loop (PLL/FLL) definitions  */
end_comment

begin_function_decl
specifier|static
name|void
name|ntp_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hardupdate
parameter_list|(
name|long
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntp_gettime1
parameter_list|(
name|struct
name|ntptimeval
modifier|*
name|ntvp
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|ntp_gettime1
parameter_list|(
name|struct
name|ntptimeval
modifier|*
name|ntvp
parameter_list|)
block|{
name|struct
name|timespec
name|atv
decl_stmt|;
comment|/* nanosecond time */
name|GIANT_REQUIRED
expr_stmt|;
name|nanotime
argument_list|(
operator|&
name|atv
argument_list|)
expr_stmt|;
name|ntvp
operator|->
name|time
operator|.
name|tv_sec
operator|=
name|atv
operator|.
name|tv_sec
expr_stmt|;
name|ntvp
operator|->
name|time
operator|.
name|tv_nsec
operator|=
name|atv
operator|.
name|tv_nsec
expr_stmt|;
name|ntvp
operator|->
name|maxerror
operator|=
name|time_maxerror
expr_stmt|;
name|ntvp
operator|->
name|esterror
operator|=
name|time_esterror
expr_stmt|;
name|ntvp
operator|->
name|tai
operator|=
name|time_tai
expr_stmt|;
name|ntvp
operator|->
name|time_state
operator|=
name|time_state
expr_stmt|;
comment|/* 	 * Status word error decode. If any of these conditions occur, 	 * an error is returned, instead of the status word. Most 	 * applications will care only about the fact the system clock 	 * may not be trusted, not about the details. 	 * 	 * Hardware or software error 	 */
if|if
condition|(
operator|(
name|time_status
operator|&
operator|(
name|STA_UNSYNC
operator||
name|STA_CLOCKERR
operator|)
operator|)
operator|||
comment|/* 	 * PPS signal lost when either time or frequency synchronization 	 * requested 	 */
operator|(
name|time_status
operator|&
operator|(
name|STA_PPSFREQ
operator||
name|STA_PPSTIME
operator|)
operator|&&
operator|!
operator|(
name|time_status
operator|&
name|STA_PPSSIGNAL
operator|)
operator|)
operator|||
comment|/* 	 * PPS jitter exceeded when time synchronization requested 	 */
operator|(
name|time_status
operator|&
name|STA_PPSTIME
operator|&&
name|time_status
operator|&
name|STA_PPSJITTER
operator|)
operator|||
comment|/* 	 * PPS wander exceeded or calibration error when frequency 	 * synchronization requested 	 */
operator|(
name|time_status
operator|&
name|STA_PPSFREQ
operator|&&
name|time_status
operator|&
operator|(
name|STA_PPSWANDER
operator||
name|STA_PPSERROR
operator|)
operator|)
condition|)
name|ntvp
operator|->
name|time_state
operator|=
name|TIME_ERROR
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ntp_gettime() - NTP user application interface  *  * See the timex.h header file for synopsis and API description. Note  * that the TAI offset is returned in the ntvtimeval.tai structure  * member.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|ntp_gettime_args
block|{
name|struct
name|ntptimeval
modifier|*
name|ntvp
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|ntp_gettime
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|ntp_gettime_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|ntptimeval
name|ntv
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|ntp_gettime1
argument_list|(
operator|&
name|ntv
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|ntv
operator|.
name|time_state
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|ntv
argument_list|,
name|uap
operator|->
name|ntvp
argument_list|,
sizeof|sizeof
argument_list|(
name|ntv
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntp_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ntptimeval
name|ntv
decl_stmt|;
comment|/* temporary structure */
name|ntp_gettime1
argument_list|(
operator|&
name|ntv
argument_list|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_opaque
argument_list|(
name|oidp
argument_list|,
operator|&
name|ntv
argument_list|,
sizeof|sizeof
argument_list|(
name|ntv
argument_list|)
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|ntp_pll
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_ntp_pll
argument_list|,
name|OID_AUTO
argument_list|,
name|gettime
argument_list|,
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ntptimeval
argument_list|)
argument_list|,
name|ntp_sysctl
argument_list|,
literal|"S,ntptimeval"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PPS_SYNC
end_ifdef

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ntp_pll
argument_list|,
name|OID_AUTO
argument_list|,
name|pps_shiftmax
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pps_shiftmax
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ntp_pll
argument_list|,
name|OID_AUTO
argument_list|,
name|pps_shift
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pps_shift
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ntp_pll
argument_list|,
name|OID_AUTO
argument_list|,
name|time_monitor
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|time_monitor
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_OPAQUE
argument_list|(
name|_kern_ntp_pll
argument_list|,
name|OID_AUTO
argument_list|,
name|pps_freq
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pps_freq
argument_list|,
sizeof|sizeof
argument_list|(
name|pps_freq
argument_list|)
argument_list|,
literal|"I"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_OPAQUE
argument_list|(
name|_kern_ntp_pll
argument_list|,
name|OID_AUTO
argument_list|,
name|time_freq
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|time_freq
argument_list|,
sizeof|sizeof
argument_list|(
name|time_freq
argument_list|)
argument_list|,
literal|"I"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * ntp_adjtime() - NTP daemon application interface  *  * See the timex.h header file for synopsis and API description. Note  * that the timex.constant structure member has a dual purpose to set  * the time constant and to set the TAI offset.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|ntp_adjtime_args
block|{
name|struct
name|timex
modifier|*
name|tp
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
name|int
name|ntp_adjtime
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|ntp_adjtime_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timex
name|ntv
decl_stmt|;
comment|/* temporary structure */
name|long
name|freq
decl_stmt|;
comment|/* frequency ns/s) */
name|int
name|modes
decl_stmt|;
comment|/* mode bits from structure */
name|int
name|s
decl_stmt|;
comment|/* caller priority */
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|tp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ntv
argument_list|,
sizeof|sizeof
argument_list|(
name|ntv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Update selected clock variables - only the superuser can 	 * change anything. Note that there is no error checking here on 	 * the assumption the superuser should know what it is doing. 	 * Note that either the time constant or TAI offset are loaded 	 * from the ntv.constant member, depending on the mode bits. If 	 * the STA_PLL bit in the status word is cleared, the state and 	 * status words are reset to the initial values at boot. 	 */
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|modes
operator|=
name|ntv
operator|.
name|modes
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NTP_ADJTIME
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done2
goto|;
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
if|if
condition|(
name|modes
operator|&
name|MOD_MAXERROR
condition|)
name|time_maxerror
operator|=
name|ntv
operator|.
name|maxerror
expr_stmt|;
if|if
condition|(
name|modes
operator|&
name|MOD_ESTERROR
condition|)
name|time_esterror
operator|=
name|ntv
operator|.
name|esterror
expr_stmt|;
if|if
condition|(
name|modes
operator|&
name|MOD_STATUS
condition|)
block|{
if|if
condition|(
name|time_status
operator|&
name|STA_PLL
operator|&&
operator|!
operator|(
name|ntv
operator|.
name|status
operator|&
name|STA_PLL
operator|)
condition|)
block|{
name|time_state
operator|=
name|TIME_OK
expr_stmt|;
name|time_status
operator|=
name|STA_UNSYNC
expr_stmt|;
ifdef|#
directive|ifdef
name|PPS_SYNC
name|pps_shift
operator|=
name|PPS_FAVG
expr_stmt|;
endif|#
directive|endif
comment|/* PPS_SYNC */
block|}
name|time_status
operator|&=
name|STA_RONLY
expr_stmt|;
name|time_status
operator||=
name|ntv
operator|.
name|status
operator|&
operator|~
name|STA_RONLY
expr_stmt|;
block|}
if|if
condition|(
name|modes
operator|&
name|MOD_TIMECONST
condition|)
block|{
if|if
condition|(
name|ntv
operator|.
name|constant
operator|<
literal|0
condition|)
name|time_constant
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|ntv
operator|.
name|constant
operator|>
name|MAXTC
condition|)
name|time_constant
operator|=
name|MAXTC
expr_stmt|;
else|else
name|time_constant
operator|=
name|ntv
operator|.
name|constant
expr_stmt|;
block|}
if|if
condition|(
name|modes
operator|&
name|MOD_TAI
condition|)
block|{
if|if
condition|(
name|ntv
operator|.
name|constant
operator|>
literal|0
condition|)
comment|/* XXX zero& negative numbers ? */
name|time_tai
operator|=
name|ntv
operator|.
name|constant
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PPS_SYNC
if|if
condition|(
name|modes
operator|&
name|MOD_PPSMAX
condition|)
block|{
if|if
condition|(
name|ntv
operator|.
name|shift
operator|<
name|PPS_FAVG
condition|)
name|pps_shiftmax
operator|=
name|PPS_FAVG
expr_stmt|;
elseif|else
if|if
condition|(
name|ntv
operator|.
name|shift
operator|>
name|PPS_FAVGMAX
condition|)
name|pps_shiftmax
operator|=
name|PPS_FAVGMAX
expr_stmt|;
else|else
name|pps_shiftmax
operator|=
name|ntv
operator|.
name|shift
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PPS_SYNC */
if|if
condition|(
name|modes
operator|&
name|MOD_NANO
condition|)
name|time_status
operator||=
name|STA_NANO
expr_stmt|;
if|if
condition|(
name|modes
operator|&
name|MOD_MICRO
condition|)
name|time_status
operator|&=
operator|~
name|STA_NANO
expr_stmt|;
if|if
condition|(
name|modes
operator|&
name|MOD_CLKB
condition|)
name|time_status
operator||=
name|STA_CLK
expr_stmt|;
if|if
condition|(
name|modes
operator|&
name|MOD_CLKA
condition|)
name|time_status
operator|&=
operator|~
name|STA_CLK
expr_stmt|;
if|if
condition|(
name|modes
operator|&
name|MOD_FREQUENCY
condition|)
block|{
name|freq
operator|=
operator|(
name|ntv
operator|.
name|freq
operator|*
literal|1000LL
operator|)
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|freq
operator|>
name|MAXFREQ
condition|)
name|L_LINT
argument_list|(
name|time_freq
argument_list|,
name|MAXFREQ
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|freq
operator|<
operator|-
name|MAXFREQ
condition|)
name|L_LINT
argument_list|(
name|time_freq
argument_list|,
operator|-
name|MAXFREQ
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 			 * ntv.freq is [PPM * 2^16] = [us/s * 2^16] 			 * time_freq is [ns/s * 2^32] 			 */
name|time_freq
operator|=
name|ntv
operator|.
name|freq
operator|*
literal|1000LL
operator|*
literal|65536LL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PPS_SYNC
name|pps_freq
operator|=
name|time_freq
expr_stmt|;
endif|#
directive|endif
comment|/* PPS_SYNC */
block|}
if|if
condition|(
name|modes
operator|&
name|MOD_OFFSET
condition|)
block|{
if|if
condition|(
name|time_status
operator|&
name|STA_NANO
condition|)
name|hardupdate
argument_list|(
name|ntv
operator|.
name|offset
argument_list|)
expr_stmt|;
else|else
name|hardupdate
argument_list|(
name|ntv
operator|.
name|offset
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Retrieve all clock variables. Note that the TAI offset is 	 * returned only by ntp_gettime(); 	 */
if|if
condition|(
name|time_status
operator|&
name|STA_NANO
condition|)
name|ntv
operator|.
name|offset
operator|=
name|L_GINT
argument_list|(
name|time_offset
argument_list|)
expr_stmt|;
else|else
name|ntv
operator|.
name|offset
operator|=
name|L_GINT
argument_list|(
name|time_offset
argument_list|)
operator|/
literal|1000
expr_stmt|;
comment|/* XXX rounding ? */
name|ntv
operator|.
name|freq
operator|=
name|L_GINT
argument_list|(
operator|(
name|time_freq
operator|/
literal|1000LL
operator|)
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|ntv
operator|.
name|maxerror
operator|=
name|time_maxerror
expr_stmt|;
name|ntv
operator|.
name|esterror
operator|=
name|time_esterror
expr_stmt|;
name|ntv
operator|.
name|status
operator|=
name|time_status
expr_stmt|;
name|ntv
operator|.
name|constant
operator|=
name|time_constant
expr_stmt|;
if|if
condition|(
name|time_status
operator|&
name|STA_NANO
condition|)
name|ntv
operator|.
name|precision
operator|=
name|time_precision
expr_stmt|;
else|else
name|ntv
operator|.
name|precision
operator|=
name|time_precision
operator|/
literal|1000
expr_stmt|;
name|ntv
operator|.
name|tolerance
operator|=
name|MAXFREQ
operator|*
name|SCALE_PPM
expr_stmt|;
ifdef|#
directive|ifdef
name|PPS_SYNC
name|ntv
operator|.
name|shift
operator|=
name|pps_shift
expr_stmt|;
name|ntv
operator|.
name|ppsfreq
operator|=
name|L_GINT
argument_list|(
operator|(
name|pps_freq
operator|/
literal|1000LL
operator|)
operator|<<
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_status
operator|&
name|STA_NANO
condition|)
name|ntv
operator|.
name|jitter
operator|=
name|pps_jitter
expr_stmt|;
else|else
name|ntv
operator|.
name|jitter
operator|=
name|pps_jitter
operator|/
literal|1000
expr_stmt|;
name|ntv
operator|.
name|stabil
operator|=
name|pps_stabil
expr_stmt|;
name|ntv
operator|.
name|calcnt
operator|=
name|pps_calcnt
expr_stmt|;
name|ntv
operator|.
name|errcnt
operator|=
name|pps_errcnt
expr_stmt|;
name|ntv
operator|.
name|jitcnt
operator|=
name|pps_jitcnt
expr_stmt|;
name|ntv
operator|.
name|stbcnt
operator|=
name|pps_stbcnt
expr_stmt|;
endif|#
directive|endif
comment|/* PPS_SYNC */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ntv
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|tp
argument_list|,
sizeof|sizeof
argument_list|(
name|ntv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done2
goto|;
comment|/* 	 * Status word error decode. See comments in 	 * ntp_gettime() routine. 	 */
if|if
condition|(
operator|(
name|time_status
operator|&
operator|(
name|STA_UNSYNC
operator||
name|STA_CLOCKERR
operator|)
operator|)
operator|||
operator|(
name|time_status
operator|&
operator|(
name|STA_PPSFREQ
operator||
name|STA_PPSTIME
operator|)
operator|&&
operator|!
operator|(
name|time_status
operator|&
name|STA_PPSSIGNAL
operator|)
operator|)
operator|||
operator|(
name|time_status
operator|&
name|STA_PPSTIME
operator|&&
name|time_status
operator|&
name|STA_PPSJITTER
operator|)
operator|||
operator|(
name|time_status
operator|&
name|STA_PPSFREQ
operator|&&
name|time_status
operator|&
operator|(
name|STA_PPSWANDER
operator||
name|STA_PPSERROR
operator|)
operator|)
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|TIME_ERROR
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|time_state
expr_stmt|;
block|}
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * second_overflow() - called after ntp_tick_adjust()  *  * This routine is ordinarily called immediately following the above  * routine ntp_tick_adjust(). While these two routines are normally  * combined, they are separated here only for the purposes of  * simulation.  */
end_comment

begin_function
name|void
name|ntp_update_second
parameter_list|(
name|int64_t
modifier|*
name|adjustment
parameter_list|,
name|time_t
modifier|*
name|newsec
parameter_list|)
block|{
name|int
name|tickrate
decl_stmt|;
name|l_fp
name|ftemp
decl_stmt|;
comment|/* 32/64-bit temporary */
comment|/* 	 * On rollover of the second both the nanosecond and microsecond 	 * clocks are updated and the state machine cranked as 	 * necessary. The phase adjustment to be used for the next 	 * second is calculated and the maximum error is increased by 	 * the tolerance. 	 */
name|time_maxerror
operator|+=
name|MAXFREQ
operator|/
literal|1000
expr_stmt|;
comment|/* 	 * Leap second processing. If in leap-insert state at 	 * the end of the day, the system clock is set back one 	 * second; if in leap-delete state, the system clock is 	 * set ahead one second. The nano_time() routine or 	 * external clock driver will insure that reported time 	 * is always monotonic. 	 */
switch|switch
condition|(
name|time_state
condition|)
block|{
comment|/* 		 * No warning. 		 */
case|case
name|TIME_OK
case|:
if|if
condition|(
name|time_status
operator|&
name|STA_INS
condition|)
name|time_state
operator|=
name|TIME_INS
expr_stmt|;
elseif|else
if|if
condition|(
name|time_status
operator|&
name|STA_DEL
condition|)
name|time_state
operator|=
name|TIME_DEL
expr_stmt|;
break|break;
comment|/* 		 * Insert second 23:59:60 following second 		 * 23:59:59. 		 */
case|case
name|TIME_INS
case|:
if|if
condition|(
operator|!
operator|(
name|time_status
operator|&
name|STA_INS
operator|)
condition|)
name|time_state
operator|=
name|TIME_OK
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|newsec
operator|)
operator|%
literal|86400
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|newsec
operator|)
operator|--
expr_stmt|;
name|time_state
operator|=
name|TIME_OOP
expr_stmt|;
name|time_tai
operator|++
expr_stmt|;
block|}
break|break;
comment|/* 		 * Delete second 23:59:59. 		 */
case|case
name|TIME_DEL
case|:
if|if
condition|(
operator|!
operator|(
name|time_status
operator|&
name|STA_DEL
operator|)
condition|)
name|time_state
operator|=
name|TIME_OK
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
operator|*
name|newsec
operator|)
operator|+
literal|1
operator|)
operator|%
literal|86400
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|newsec
operator|)
operator|++
expr_stmt|;
name|time_tai
operator|--
expr_stmt|;
name|time_state
operator|=
name|TIME_WAIT
expr_stmt|;
block|}
break|break;
comment|/* 		 * Insert second in progress. 		 */
case|case
name|TIME_OOP
case|:
name|time_state
operator|=
name|TIME_WAIT
expr_stmt|;
break|break;
comment|/* 		 * Wait for status bits to clear. 		 */
case|case
name|TIME_WAIT
case|:
if|if
condition|(
operator|!
operator|(
name|time_status
operator|&
operator|(
name|STA_INS
operator||
name|STA_DEL
operator|)
operator|)
condition|)
name|time_state
operator|=
name|TIME_OK
expr_stmt|;
block|}
comment|/* 	 * Compute the total time adjustment for the next second 	 * in ns. The offset is reduced by a factor depending on 	 * whether the PPS signal is operating. Note that the 	 * value is in effect scaled by the clock frequency, 	 * since the adjustment is added at each tick interrupt. 	 */
name|ftemp
operator|=
name|time_offset
expr_stmt|;
ifdef|#
directive|ifdef
name|PPS_SYNC
comment|/* XXX even if PPS signal dies we should finish adjustment ? */
if|if
condition|(
name|time_status
operator|&
name|STA_PPSTIME
operator|&&
name|time_status
operator|&
name|STA_PPSSIGNAL
condition|)
name|L_RSHIFT
argument_list|(
name|ftemp
argument_list|,
name|pps_shift
argument_list|)
expr_stmt|;
else|else
name|L_RSHIFT
argument_list|(
name|ftemp
argument_list|,
name|SHIFT_PLL
operator|+
name|time_constant
argument_list|)
expr_stmt|;
else|#
directive|else
name|L_RSHIFT
argument_list|(
name|ftemp
argument_list|,
name|SHIFT_PLL
operator|+
name|time_constant
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PPS_SYNC */
name|time_adj
operator|=
name|ftemp
expr_stmt|;
name|L_SUB
argument_list|(
name|time_offset
argument_list|,
name|ftemp
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
name|time_adj
argument_list|,
name|time_freq
argument_list|)
expr_stmt|;
comment|/* 	 * Apply any correction from adjtime(2).  If more than one second 	 * off we slew at a rate of 5ms/s (5000 PPM) else 500us/s (500PPM) 	 * until the last second is slewed the final< 500 usecs. 	 */
if|if
condition|(
name|time_adjtime
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|time_adjtime
operator|>
literal|1000000
condition|)
name|tickrate
operator|=
literal|5000
expr_stmt|;
elseif|else
if|if
condition|(
name|time_adjtime
operator|<
operator|-
literal|1000000
condition|)
name|tickrate
operator|=
operator|-
literal|5000
expr_stmt|;
elseif|else
if|if
condition|(
name|time_adjtime
operator|>
literal|500
condition|)
name|tickrate
operator|=
literal|500
expr_stmt|;
elseif|else
if|if
condition|(
name|time_adjtime
operator|<
operator|-
literal|500
condition|)
name|tickrate
operator|=
operator|-
literal|500
expr_stmt|;
else|else
name|tickrate
operator|=
name|time_adjtime
expr_stmt|;
name|time_adjtime
operator|-=
name|tickrate
expr_stmt|;
name|L_LINT
argument_list|(
name|ftemp
argument_list|,
name|tickrate
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
name|time_adj
argument_list|,
name|ftemp
argument_list|)
expr_stmt|;
block|}
operator|*
name|adjustment
operator|=
name|time_adj
expr_stmt|;
ifdef|#
directive|ifdef
name|PPS_SYNC
if|if
condition|(
name|pps_valid
operator|>
literal|0
condition|)
name|pps_valid
operator|--
expr_stmt|;
else|else
name|time_status
operator|&=
operator|~
name|STA_PPSSIGNAL
expr_stmt|;
endif|#
directive|endif
comment|/* PPS_SYNC */
block|}
end_function

begin_comment
comment|/*  * ntp_init() - initialize variables and structures  *  * This routine must be called after the kernel variables hz and tick  * are set or changed and before the next tick interrupt. In this  * particular implementation, these values are assumed set elsewhere in  * the kernel. The design allows the clock frequency and tick interval  * to be changed while the system is running. So, this routine should  * probably be integrated with the code that does that.  */
end_comment

begin_function
specifier|static
name|void
name|ntp_init
parameter_list|()
block|{
comment|/* 	 * The following variables are initialized only at startup. Only 	 * those structures not cleared by the compiler need to be 	 * initialized, and these only in the simulator. In the actual 	 * kernel, any nonzero values here will quickly evaporate. 	 */
name|L_CLR
argument_list|(
name|time_offset
argument_list|)
expr_stmt|;
name|L_CLR
argument_list|(
name|time_freq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PPS_SYNC
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|pps_tf
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|pps_tf
index|[
literal|1
index|]
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_sec
operator|=
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|pps_fcount
operator|=
literal|0
expr_stmt|;
name|L_CLR
argument_list|(
name|pps_freq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PPS_SYNC */
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|ntpclocks
argument_list|,
argument|SI_SUB_CLOCKS
argument_list|,
argument|SI_ORDER_MIDDLE
argument_list|,
argument|ntp_init
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_comment
comment|/*  * hardupdate() - local clock update  *  * This routine is called by ntp_adjtime() to update the local clock  * phase and frequency. The implementation is of an adaptive-parameter,  * hybrid phase/frequency-lock loop (PLL/FLL). The routine computes new  * time and frequency offset estimates for each call. If the kernel PPS  * discipline code is configured (PPS_SYNC), the PPS signal itself  * determines the new time offset, instead of the calling argument.  * Presumably, calls to ntp_adjtime() occur only when the caller  * believes the local clock is valid within some bound (+-128 ms with  * NTP). If the caller's time is far different than the PPS time, an  * argument will ensue, and it's not clear who will lose.  *  * For uncompensated quartz crystal oscillators and nominal update  * intervals less than 256 s, operation should be in phase-lock mode,  * where the loop is disciplined to phase. For update intervals greater  * than 1024 s, operation should be in frequency-lock mode, where the  * loop is disciplined to frequency. Between 256 s and 1024 s, the mode  * is selected by the STA_MODE status bit.  */
end_comment

begin_function
specifier|static
name|void
name|hardupdate
parameter_list|(
name|offset
parameter_list|)
name|long
name|offset
decl_stmt|;
comment|/* clock offset (ns) */
block|{
name|long
name|mtemp
decl_stmt|;
name|l_fp
name|ftemp
decl_stmt|;
comment|/* 	 * Select how the phase is to be controlled and from which 	 * source. If the PPS signal is present and enabled to 	 * discipline the time, the PPS offset is used; otherwise, the 	 * argument offset is used. 	 */
if|if
condition|(
operator|!
operator|(
name|time_status
operator|&
name|STA_PLL
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|time_status
operator|&
name|STA_PPSTIME
operator|&&
name|time_status
operator|&
name|STA_PPSSIGNAL
operator|)
condition|)
block|{
if|if
condition|(
name|offset
operator|>
name|MAXPHASE
condition|)
name|time_monitor
operator|=
name|MAXPHASE
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|<
operator|-
name|MAXPHASE
condition|)
name|time_monitor
operator|=
operator|-
name|MAXPHASE
expr_stmt|;
else|else
name|time_monitor
operator|=
name|offset
expr_stmt|;
name|L_LINT
argument_list|(
name|time_offset
argument_list|,
name|time_monitor
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Select how the frequency is to be controlled and in which 	 * mode (PLL or FLL). If the PPS signal is present and enabled 	 * to discipline the frequency, the PPS frequency is used; 	 * otherwise, the argument offset is used to compute it. 	 */
if|if
condition|(
name|time_status
operator|&
name|STA_PPSFREQ
operator|&&
name|time_status
operator|&
name|STA_PPSSIGNAL
condition|)
block|{
name|time_reftime
operator|=
name|time_second
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|time_status
operator|&
name|STA_FREQHOLD
operator|||
name|time_reftime
operator|==
literal|0
condition|)
name|time_reftime
operator|=
name|time_second
expr_stmt|;
name|mtemp
operator|=
name|time_second
operator|-
name|time_reftime
expr_stmt|;
name|L_LINT
argument_list|(
name|ftemp
argument_list|,
name|time_monitor
argument_list|)
expr_stmt|;
name|L_RSHIFT
argument_list|(
name|ftemp
argument_list|,
operator|(
name|SHIFT_PLL
operator|+
literal|2
operator|+
name|time_constant
operator|)
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|L_MPY
argument_list|(
name|ftemp
argument_list|,
name|mtemp
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
name|time_freq
argument_list|,
name|ftemp
argument_list|)
expr_stmt|;
name|time_status
operator|&=
operator|~
name|STA_MODE
expr_stmt|;
if|if
condition|(
name|mtemp
operator|>=
name|MINSEC
operator|&&
operator|(
name|time_status
operator|&
name|STA_FLL
operator|||
name|mtemp
operator|>
name|MAXSEC
operator|)
condition|)
block|{
name|L_LINT
argument_list|(
name|ftemp
argument_list|,
operator|(
name|time_monitor
operator|<<
literal|4
operator|)
operator|/
name|mtemp
argument_list|)
expr_stmt|;
name|L_RSHIFT
argument_list|(
name|ftemp
argument_list|,
name|SHIFT_FLL
operator|+
literal|4
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
name|time_freq
argument_list|,
name|ftemp
argument_list|)
expr_stmt|;
name|time_status
operator||=
name|STA_MODE
expr_stmt|;
block|}
name|time_reftime
operator|=
name|time_second
expr_stmt|;
if|if
condition|(
name|L_GINT
argument_list|(
name|time_freq
argument_list|)
operator|>
name|MAXFREQ
condition|)
name|L_LINT
argument_list|(
name|time_freq
argument_list|,
name|MAXFREQ
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|L_GINT
argument_list|(
name|time_freq
argument_list|)
operator|<
operator|-
name|MAXFREQ
condition|)
name|L_LINT
argument_list|(
name|time_freq
argument_list|,
operator|-
name|MAXFREQ
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PPS_SYNC
end_ifdef

begin_comment
comment|/*  * hardpps() - discipline CPU clock oscillator to external PPS signal  *  * This routine is called at each PPS interrupt in order to discipline  * the CPU clock oscillator to the PPS signal. There are two independent  * first-order feedback loops, one for the phase, the other for the  * frequency. The phase loop measures and grooms the PPS phase offset  * and leaves it in a handy spot for the seconds overflow routine. The  * frequency loop averages successive PPS phase differences and  * calculates the PPS frequency offset, which is also processed by the  * seconds overflow routine. The code requires the caller to capture the  * time and architecture-dependent hardware counter values in  * nanoseconds at the on-time PPS signal transition.  *  * Note that, on some Unix systems this routine runs at an interrupt  * priority level higher than the timer interrupt routine hardclock().  * Therefore, the variables used are distinct from the hardclock()  * variables, except for the actual time and frequency variables, which  * are determined by this routine and updated atomically.  */
end_comment

begin_function
name|void
name|hardpps
parameter_list|(
name|tsp
parameter_list|,
name|nsec
parameter_list|)
name|struct
name|timespec
modifier|*
name|tsp
decl_stmt|;
comment|/* time at PPS */
name|long
name|nsec
decl_stmt|;
comment|/* hardware counter at PPS */
block|{
name|long
name|u_sec
decl_stmt|,
name|u_nsec
decl_stmt|,
name|v_nsec
decl_stmt|;
comment|/* temps */
name|l_fp
name|ftemp
decl_stmt|;
comment|/* 	 * The signal is first processed by a range gate and frequency 	 * discriminator. The range gate rejects noise spikes outside 	 * the range +-500 us. The frequency discriminator rejects input 	 * signals with apparent frequency outside the range 1 +-500 	 * PPM. If two hits occur in the same second, we ignore the 	 * later hit; if not and a hit occurs outside the range gate, 	 * keep the later hit for later comparison, but do not process 	 * it. 	 */
name|time_status
operator||=
name|STA_PPSSIGNAL
operator||
name|STA_PPSJITTER
expr_stmt|;
name|time_status
operator|&=
operator|~
operator|(
name|STA_PPSWANDER
operator||
name|STA_PPSERROR
operator|)
expr_stmt|;
name|pps_valid
operator|=
name|PPS_VALID
expr_stmt|;
name|u_sec
operator|=
name|tsp
operator|->
name|tv_sec
expr_stmt|;
name|u_nsec
operator|=
name|tsp
operator|->
name|tv_nsec
expr_stmt|;
if|if
condition|(
name|u_nsec
operator|>=
operator|(
name|NANOSECOND
operator|>>
literal|1
operator|)
condition|)
block|{
name|u_nsec
operator|-=
name|NANOSECOND
expr_stmt|;
name|u_sec
operator|++
expr_stmt|;
block|}
name|v_nsec
operator|=
name|u_nsec
operator|-
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
expr_stmt|;
if|if
condition|(
name|u_sec
operator|==
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|&&
name|v_nsec
operator|<
name|NANOSECOND
operator|-
name|MAXFREQ
condition|)
return|return;
name|pps_tf
index|[
literal|2
index|]
operator|=
name|pps_tf
index|[
literal|1
index|]
expr_stmt|;
name|pps_tf
index|[
literal|1
index|]
operator|=
name|pps_tf
index|[
literal|0
index|]
expr_stmt|;
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|u_sec
expr_stmt|;
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
operator|=
name|u_nsec
expr_stmt|;
comment|/* 	 * Compute the difference between the current and previous 	 * counter values. If the difference exceeds 0.5 s, assume it 	 * has wrapped around, so correct 1.0 s. If the result exceeds 	 * the tick interval, the sample point has crossed a tick 	 * boundary during the last second, so correct the tick. Very 	 * intricate. 	 */
name|u_nsec
operator|=
name|nsec
expr_stmt|;
if|if
condition|(
name|u_nsec
operator|>
operator|(
name|NANOSECOND
operator|>>
literal|1
operator|)
condition|)
name|u_nsec
operator|-=
name|NANOSECOND
expr_stmt|;
elseif|else
if|if
condition|(
name|u_nsec
operator|<
operator|-
operator|(
name|NANOSECOND
operator|>>
literal|1
operator|)
condition|)
name|u_nsec
operator|+=
name|NANOSECOND
expr_stmt|;
name|pps_fcount
operator|+=
name|u_nsec
expr_stmt|;
if|if
condition|(
name|v_nsec
operator|>
name|MAXFREQ
operator|||
name|v_nsec
operator|<
operator|-
name|MAXFREQ
condition|)
return|return;
name|time_status
operator|&=
operator|~
name|STA_PPSJITTER
expr_stmt|;
comment|/* 	 * A three-stage median filter is used to help denoise the PPS 	 * time. The median sample becomes the time offset estimate; the 	 * difference between the other two samples becomes the time 	 * dispersion (jitter) estimate. 	 */
if|if
condition|(
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
operator|>
name|pps_tf
index|[
literal|1
index|]
operator|.
name|tv_nsec
condition|)
block|{
if|if
condition|(
name|pps_tf
index|[
literal|1
index|]
operator|.
name|tv_nsec
operator|>
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_nsec
condition|)
block|{
name|v_nsec
operator|=
name|pps_tf
index|[
literal|1
index|]
operator|.
name|tv_nsec
expr_stmt|;
comment|/* 0 1 2 */
name|u_nsec
operator|=
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
operator|-
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_nsec
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_nsec
operator|>
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
condition|)
block|{
name|v_nsec
operator|=
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
expr_stmt|;
comment|/* 2 0 1 */
name|u_nsec
operator|=
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_nsec
operator|-
name|pps_tf
index|[
literal|1
index|]
operator|.
name|tv_nsec
expr_stmt|;
block|}
else|else
block|{
name|v_nsec
operator|=
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_nsec
expr_stmt|;
comment|/* 0 2 1 */
name|u_nsec
operator|=
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
operator|-
name|pps_tf
index|[
literal|1
index|]
operator|.
name|tv_nsec
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|pps_tf
index|[
literal|1
index|]
operator|.
name|tv_nsec
operator|<
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_nsec
condition|)
block|{
name|v_nsec
operator|=
name|pps_tf
index|[
literal|1
index|]
operator|.
name|tv_nsec
expr_stmt|;
comment|/* 2 1 0 */
name|u_nsec
operator|=
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_nsec
operator|-
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_nsec
operator|<
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
condition|)
block|{
name|v_nsec
operator|=
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
expr_stmt|;
comment|/* 1 0 2 */
name|u_nsec
operator|=
name|pps_tf
index|[
literal|1
index|]
operator|.
name|tv_nsec
operator|-
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_nsec
expr_stmt|;
block|}
else|else
block|{
name|v_nsec
operator|=
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_nsec
expr_stmt|;
comment|/* 1 2 0 */
name|u_nsec
operator|=
name|pps_tf
index|[
literal|1
index|]
operator|.
name|tv_nsec
operator|-
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
expr_stmt|;
block|}
block|}
comment|/* 	 * Nominal jitter is due to PPS signal noise and interrupt 	 * latency. If it exceeds the popcorn threshold, the sample is 	 * discarded. otherwise, if so enabled, the time offset is 	 * updated. We can tolerate a modest loss of data here without 	 * much degrading time accuracy. 	 */
if|if
condition|(
name|u_nsec
operator|>
operator|(
name|pps_jitter
operator|<<
name|PPS_POPCORN
operator|)
condition|)
block|{
name|time_status
operator||=
name|STA_PPSJITTER
expr_stmt|;
name|pps_jitcnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|time_status
operator|&
name|STA_PPSTIME
condition|)
block|{
name|time_monitor
operator|=
operator|-
name|v_nsec
expr_stmt|;
name|L_LINT
argument_list|(
name|time_offset
argument_list|,
name|time_monitor
argument_list|)
expr_stmt|;
block|}
name|pps_jitter
operator|+=
operator|(
name|u_nsec
operator|-
name|pps_jitter
operator|)
operator|>>
name|PPS_FAVG
expr_stmt|;
name|u_sec
operator|=
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|-
name|pps_lastsec
expr_stmt|;
if|if
condition|(
name|u_sec
operator|<
operator|(
literal|1
operator|<<
name|pps_shift
operator|)
condition|)
return|return;
comment|/* 	 * At the end of the calibration interval the difference between 	 * the first and last counter values becomes the scaled 	 * frequency. It will later be divided by the length of the 	 * interval to determine the frequency update. If the frequency 	 * exceeds a sanity threshold, or if the actual calibration 	 * interval is not equal to the expected length, the data are 	 * discarded. We can tolerate a modest loss of data here without 	 * much degrading frequency accuracy. 	 */
name|pps_calcnt
operator|++
expr_stmt|;
name|v_nsec
operator|=
operator|-
name|pps_fcount
expr_stmt|;
name|pps_lastsec
operator|=
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_sec
expr_stmt|;
name|pps_fcount
operator|=
literal|0
expr_stmt|;
name|u_nsec
operator|=
name|MAXFREQ
operator|<<
name|pps_shift
expr_stmt|;
if|if
condition|(
name|v_nsec
operator|>
name|u_nsec
operator|||
name|v_nsec
operator|<
operator|-
name|u_nsec
operator|||
name|u_sec
operator|!=
operator|(
literal|1
operator|<<
name|pps_shift
operator|)
condition|)
block|{
name|time_status
operator||=
name|STA_PPSERROR
expr_stmt|;
name|pps_errcnt
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * Here the raw frequency offset and wander (stability) is 	 * calculated. If the wander is less than the wander threshold 	 * for four consecutive averaging intervals, the interval is 	 * doubled; if it is greater than the threshold for four 	 * consecutive intervals, the interval is halved. The scaled 	 * frequency offset is converted to frequency offset. The 	 * stability metric is calculated as the average of recent 	 * frequency changes, but is used only for performance 	 * monitoring. 	 */
name|L_LINT
argument_list|(
name|ftemp
argument_list|,
name|v_nsec
argument_list|)
expr_stmt|;
name|L_RSHIFT
argument_list|(
name|ftemp
argument_list|,
name|pps_shift
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
name|ftemp
argument_list|,
name|pps_freq
argument_list|)
expr_stmt|;
name|u_nsec
operator|=
name|L_GINT
argument_list|(
name|ftemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|u_nsec
operator|>
name|PPS_MAXWANDER
condition|)
block|{
name|L_LINT
argument_list|(
name|ftemp
argument_list|,
name|PPS_MAXWANDER
argument_list|)
expr_stmt|;
name|pps_intcnt
operator|--
expr_stmt|;
name|time_status
operator||=
name|STA_PPSWANDER
expr_stmt|;
name|pps_stbcnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u_nsec
operator|<
operator|-
name|PPS_MAXWANDER
condition|)
block|{
name|L_LINT
argument_list|(
name|ftemp
argument_list|,
operator|-
name|PPS_MAXWANDER
argument_list|)
expr_stmt|;
name|pps_intcnt
operator|--
expr_stmt|;
name|time_status
operator||=
name|STA_PPSWANDER
expr_stmt|;
name|pps_stbcnt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|pps_intcnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pps_intcnt
operator|>=
literal|4
condition|)
block|{
name|pps_intcnt
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|pps_shift
operator|<
name|pps_shiftmax
condition|)
block|{
name|pps_shift
operator|++
expr_stmt|;
name|pps_intcnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pps_intcnt
operator|<=
operator|-
literal|4
operator|||
name|pps_shift
operator|>
name|pps_shiftmax
condition|)
block|{
name|pps_intcnt
operator|=
operator|-
literal|4
expr_stmt|;
if|if
condition|(
name|pps_shift
operator|>
name|PPS_FAVG
condition|)
block|{
name|pps_shift
operator|--
expr_stmt|;
name|pps_intcnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|u_nsec
operator|<
literal|0
condition|)
name|u_nsec
operator|=
operator|-
name|u_nsec
expr_stmt|;
name|pps_stabil
operator|+=
operator|(
name|u_nsec
operator|*
name|SCALE_PPM
operator|-
name|pps_stabil
operator|)
operator|>>
name|PPS_FAVG
expr_stmt|;
comment|/* 	 * The PPS frequency is recalculated and clamped to the maximum 	 * MAXFREQ. If enabled, the system clock frequency is updated as 	 * well. 	 */
name|L_ADD
argument_list|(
name|pps_freq
argument_list|,
name|ftemp
argument_list|)
expr_stmt|;
name|u_nsec
operator|=
name|L_GINT
argument_list|(
name|pps_freq
argument_list|)
expr_stmt|;
if|if
condition|(
name|u_nsec
operator|>
name|MAXFREQ
condition|)
name|L_LINT
argument_list|(
name|pps_freq
argument_list|,
name|MAXFREQ
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|u_nsec
operator|<
operator|-
name|MAXFREQ
condition|)
name|L_LINT
argument_list|(
name|pps_freq
argument_list|,
operator|-
name|MAXFREQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_status
operator|&
name|STA_PPSFREQ
condition|)
name|time_freq
operator|=
name|pps_freq
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPS_SYNC */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|adjtime_args
block|{
name|struct
name|timeval
modifier|*
name|delta
decl_stmt|;
name|struct
name|timeval
modifier|*
name|olddelta
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|adjtime
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|adjtime_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timeval
name|delta
decl_stmt|,
name|olddelta
decl_stmt|,
modifier|*
name|deltap
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|delta
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|delta
argument_list|,
operator|&
name|delta
argument_list|,
sizeof|sizeof
argument_list|(
name|delta
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|deltap
operator|=
operator|&
name|delta
expr_stmt|;
block|}
else|else
name|deltap
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|kern_adjtime
argument_list|(
name|td
argument_list|,
name|deltap
argument_list|,
operator|&
name|olddelta
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|olddelta
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|olddelta
argument_list|,
name|uap
operator|->
name|olddelta
argument_list|,
sizeof|sizeof
argument_list|(
name|olddelta
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kern_adjtime
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|timeval
modifier|*
name|delta
parameter_list|,
name|struct
name|timeval
modifier|*
name|olddelta
parameter_list|)
block|{
name|struct
name|timeval
name|atv
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_ADJTIME
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|olddelta
condition|)
block|{
name|atv
operator|.
name|tv_sec
operator|=
name|time_adjtime
operator|/
literal|1000000
expr_stmt|;
name|atv
operator|.
name|tv_usec
operator|=
name|time_adjtime
operator|%
literal|1000000
expr_stmt|;
if|if
condition|(
name|atv
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|atv
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
name|atv
operator|.
name|tv_sec
operator|--
expr_stmt|;
block|}
operator|*
name|olddelta
operator|=
name|atv
expr_stmt|;
block|}
if|if
condition|(
name|delta
condition|)
name|time_adjtime
operator|=
operator|(
name|int64_t
operator|)
name|delta
operator|->
name|tv_sec
operator|*
literal|1000000
operator|+
name|delta
operator|->
name|tv_usec
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

