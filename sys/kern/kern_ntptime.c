begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************************************************************  *								       *  * Copyright (c) David L. Mills 1993-1999			       *  *								       *  * Permission to use, copy, modify, and distribute this software and   *  * its documentation for any purpose and without fee is hereby	       *  * granted, provided that the above copyright notice appears in all    *  * copies and that both the copyright notice and this permission       *  * notice appear in supporting documentation, and that the name	       *  * University of Delaware not be used in advertising or publicity      *  * pertaining to distribution of the software without specific,	       *  * written prior permission. The University of Delaware makes no       *  * representations about the suitability this software for any	       *  * purpose. It is provided "as is" without express or implied	       *  * warranty.							       *  *								       *  **********************************************************************/
end_comment

begin_comment
comment|/*  * Adapted from the original sources for FreeBSD and timecounters by:  * Poul-Henning Kamp<phk@FreeBSD.org>.  *  * The 32bit version of the "LP" macros seems a bit past its "sell by"   * date so I have retained only the 64bit version and included it directly  * in this file.  *  * Only minor changes done to interface with the timecounters over in  * sys/kern/kern_clock.c.   Some of the comments below may be (even more)  * confusing and/or plain wrong in that context.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ntp.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/timex.h>
end_include

begin_include
include|#
directive|include
file|<sys/timepps.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_comment
comment|/*  * Single-precision macros for 64-bit machines  */
end_comment

begin_typedef
typedef|typedef
name|long
name|long
name|l_fp
typedef|;
end_typedef

begin_define
define|#
directive|define
name|L_ADD
parameter_list|(
name|v
parameter_list|,
name|u
parameter_list|)
value|((v) += (u))
end_define

begin_define
define|#
directive|define
name|L_SUB
parameter_list|(
name|v
parameter_list|,
name|u
parameter_list|)
value|((v) -= (u))
end_define

begin_define
define|#
directive|define
name|L_ADDHI
parameter_list|(
name|v
parameter_list|,
name|a
parameter_list|)
value|((v) += (long long)(a)<< 32)
end_define

begin_define
define|#
directive|define
name|L_NEG
parameter_list|(
name|v
parameter_list|)
value|((v) = -(v))
end_define

begin_define
define|#
directive|define
name|L_RSHIFT
parameter_list|(
name|v
parameter_list|,
name|n
parameter_list|)
define|\
value|do { \ 		if ((v)< 0) \ 			(v) = -(-(v)>> (n)); \ 		else \ 			(v) = (v)>> (n); \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|L_MPY
parameter_list|(
name|v
parameter_list|,
name|a
parameter_list|)
value|((v) *= (a))
end_define

begin_define
define|#
directive|define
name|L_CLR
parameter_list|(
name|v
parameter_list|)
value|((v) = 0)
end_define

begin_define
define|#
directive|define
name|L_ISNEG
parameter_list|(
name|v
parameter_list|)
value|((v)< 0)
end_define

begin_define
define|#
directive|define
name|L_LINT
parameter_list|(
name|v
parameter_list|,
name|a
parameter_list|)
value|((v) = (long long)(a)<< 32)
end_define

begin_define
define|#
directive|define
name|L_GINT
parameter_list|(
name|v
parameter_list|)
value|((v)< 0 ? -(-(v)>> 32) : (v)>> 32)
end_define

begin_comment
comment|/*  * Generic NTP kernel interface  *  * These routines constitute the Network Time Protocol (NTP) interfaces  * for user and daemon application programs. The ntp_gettime() routine  * provides the time, maximum error (synch distance) and estimated error  * (dispersion) to client user application programs. The ntp_adjtime()  * routine is used by the NTP daemon to adjust the system clock to an  * externally derived time. The time offset and related variables set by  * this routine are used by other routines in this module to adjust the  * phase and frequency of the clock discipline loop which controls the  * system clock.  *  * When the kernel time is reckoned directly in nanoseconds (NTP_NANO  * defined), the time at each tick interrupt is derived directly from  * the kernel time variable. When the kernel time is reckoned in  * microseconds, (NTP_NANO undefined), the time is derived from the  * kernel time variable together with a variable representing the  * leftover nanoseconds at the last tick interrupt. In either case, the  * current nanosecond time is reckoned from these values plus an  * interpolated value derived by the clock routines in another  * architecture-specific module. The interpolation can use either a  * dedicated counter or a processor cycle counter (PCC) implemented in  * some architectures.  *  * Note that all routines must run at priority splclock or higher.  */
end_comment

begin_comment
comment|/*  * Phase/frequency-lock loop (PLL/FLL) definitions  *  * The nanosecond clock discipline uses two variable types, time  * variables and frequency variables. Both types are represented as 64-  * bit fixed-point quantities with the decimal point between two 32-bit  * halves. On a 32-bit machine, each half is represented as a single  * word and mathematical operations are done using multiple-precision  * arithmetic. On a 64-bit machine, ordinary computer arithmetic is  * used.  *  * A time variable is a signed 64-bit fixed-point number in ns and  * fraction. It represents the remaining time offset to be amortized  * over succeeding tick interrupts. The maximum time offset is about  * 0.5 s and the resolution is about 2.3e-10 ns.  *  *			1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3  *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |s s s|			 ns				   |  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |			    fraction				   |  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  *  * A frequency variable is a signed 64-bit fixed-point number in ns/s  * and fraction. It represents the ns and fraction to be added to the  * kernel time variable at each second. The maximum frequency offset is  * about +-500000 ns/s and the resolution is about 2.3e-10 ns/s.  *  *			1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3  *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |s s s s s s s s s s s s s|	          ns/s			   |  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |			    fraction				   |  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  */
end_comment

begin_comment
comment|/*  * The following variables establish the state of the PLL/FLL and the  * residual time and frequency offset of the local clock.  */
end_comment

begin_define
define|#
directive|define
name|SHIFT_PLL
value|4
end_define

begin_comment
comment|/* PLL loop gain (shift) */
end_comment

begin_define
define|#
directive|define
name|SHIFT_FLL
value|2
end_define

begin_comment
comment|/* FLL loop gain (shift) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|time_state
init|=
name|TIME_OK
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clock state */
end_comment

begin_decl_stmt
specifier|static
name|int
name|time_status
init|=
name|STA_UNSYNC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clock status bits */
end_comment

begin_decl_stmt
specifier|static
name|long
name|time_constant
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* poll interval (shift) (s) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|time_precision
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* clock precision (ns) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|time_maxerror
init|=
name|MAXPHASE
operator|/
literal|1000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum error (us) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|time_esterror
init|=
name|MAXPHASE
operator|/
literal|1000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* estimated error (us) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|time_reftime
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time at last adjustment (s) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|time_tick
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nanoseconds per tick (ns) */
end_comment

begin_decl_stmt
specifier|static
name|l_fp
name|time_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time offset (ns) */
end_comment

begin_decl_stmt
specifier|static
name|l_fp
name|time_freq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* frequency offset (ns/s) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PPS_SYNC
end_ifdef

begin_comment
comment|/*  * The following variables are used when a pulse-per-second (PPS) signal  * is available and connected via a modem control lead. They establish  * the engineering parameters of the clock discipline loop when  * controlled by the PPS signal.  */
end_comment

begin_define
define|#
directive|define
name|PPS_FAVG
value|2
end_define

begin_comment
comment|/* min freq avg interval (s) (shift) */
end_comment

begin_define
define|#
directive|define
name|PPS_FAVGDEF
value|7
end_define

begin_comment
comment|/* default freq avg int (s) (shift) */
end_comment

begin_define
define|#
directive|define
name|PPS_FAVGMAX
value|15
end_define

begin_comment
comment|/* max freq avg interval (s) (shift) */
end_comment

begin_define
define|#
directive|define
name|PPS_PAVG
value|4
end_define

begin_comment
comment|/* phase avg interval (s) (shift) */
end_comment

begin_define
define|#
directive|define
name|PPS_VALID
value|120
end_define

begin_comment
comment|/* PPS signal watchdog max (s) */
end_comment

begin_define
define|#
directive|define
name|PPS_MAXWANDER
value|100000
end_define

begin_comment
comment|/* max PPS wander (ns/s) */
end_comment

begin_define
define|#
directive|define
name|PPS_POPCORN
value|2
end_define

begin_comment
comment|/* popcorn spike threshold (shift) */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|timespec
name|pps_tf
index|[
literal|3
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* phase median filter */
end_comment

begin_decl_stmt
specifier|static
name|l_fp
name|pps_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time offset (ns) */
end_comment

begin_decl_stmt
specifier|static
name|l_fp
name|pps_freq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scaled frequency offset (ns/s) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|pps_fcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* frequency accumulator */
end_comment

begin_decl_stmt
specifier|static
name|long
name|pps_jitter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nominal jitter (ns) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|pps_stabil
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nominal stability (scaled ns/s) */
end_comment

begin_decl_stmt
specifier|static
name|long
name|pps_lastsec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time at last calibration (s) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pps_valid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* signal watchdog counter */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pps_shift
init|=
name|PPS_FAVG
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interval duration (s) (shift) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pps_shiftmax
init|=
name|PPS_FAVGDEF
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max interval duration (s) (shift) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pps_intcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* wander counter */
end_comment

begin_comment
comment|/*  * PPS signal quality monitors  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|pps_calcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calibration intervals */
end_comment

begin_decl_stmt
specifier|static
name|long
name|pps_jitcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* jitter limit exceeded */
end_comment

begin_decl_stmt
specifier|static
name|long
name|pps_stbcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stability limit exceeded */
end_comment

begin_decl_stmt
specifier|static
name|long
name|pps_errcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* calibration errors */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPS_SYNC */
end_comment

begin_comment
comment|/*  * End of phase/frequency-lock loop (PLL/FLL) definitions  */
end_comment

begin_function_decl
specifier|static
name|void
name|ntp_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hardupdate
parameter_list|(
name|long
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * ntp_gettime() - NTP user application interface  *  * See the timex.h header file for synopsis and API description.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ntp_sysctl
name|SYSCTL_HANDLER_ARGS
block|{
name|struct
name|ntptimeval
name|ntv
decl_stmt|;
comment|/* temporary structure */
name|struct
name|timespec
name|atv
decl_stmt|;
comment|/* nanosecond time */
name|nanotime
argument_list|(
operator|&
name|atv
argument_list|)
expr_stmt|;
name|ntv
operator|.
name|time
operator|.
name|tv_sec
operator|=
name|atv
operator|.
name|tv_sec
expr_stmt|;
name|ntv
operator|.
name|time
operator|.
name|tv_nsec
operator|=
name|atv
operator|.
name|tv_nsec
expr_stmt|;
name|ntv
operator|.
name|maxerror
operator|=
name|time_maxerror
expr_stmt|;
name|ntv
operator|.
name|esterror
operator|=
name|time_esterror
expr_stmt|;
name|ntv
operator|.
name|time_state
operator|=
name|time_state
expr_stmt|;
comment|/* 	 * Status word error decode. If any of these conditions occur, 	 * an error is returned, instead of the status word. Most 	 * applications will care only about the fact the system clock 	 * may not be trusted, not about the details. 	 * 	 * Hardware or software error 	 */
if|if
condition|(
operator|(
name|time_status
operator|&
operator|(
name|STA_UNSYNC
operator||
name|STA_CLOCKERR
operator|)
operator|)
operator|||
comment|/* 	 * PPS signal lost when either time or frequency synchronization 	 * requested 	 */
operator|(
name|time_status
operator|&
operator|(
name|STA_PPSFREQ
operator||
name|STA_PPSTIME
operator|)
operator|&&
operator|!
operator|(
name|time_status
operator|&
name|STA_PPSSIGNAL
operator|)
operator|)
operator|||
comment|/* 	 * PPS jitter exceeded when time synchronization requested 	 */
operator|(
name|time_status
operator|&
name|STA_PPSTIME
operator|&&
name|time_status
operator|&
name|STA_PPSJITTER
operator|)
operator|||
comment|/* 	 * PPS wander exceeded or calibration error when frequency 	 * synchronization requested 	 */
operator|(
name|time_status
operator|&
name|STA_PPSFREQ
operator|&&
name|time_status
operator|&
operator|(
name|STA_PPSWANDER
operator||
name|STA_PPSERROR
operator|)
operator|)
condition|)
name|ntv
operator|.
name|time_state
operator|=
name|TIME_ERROR
expr_stmt|;
return|return
operator|(
name|sysctl_handle_opaque
argument_list|(
name|oidp
argument_list|,
operator|&
name|ntv
argument_list|,
sizeof|sizeof
name|ntv
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|ntp_pll
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_ntp_pll
argument_list|,
name|OID_AUTO
argument_list|,
name|gettime
argument_list|,
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ntptimeval
argument_list|)
argument_list|,
name|ntp_sysctl
argument_list|,
literal|"S,ntptimeval"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PPS_SYNC
end_ifdef

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ntp_pll
argument_list|,
name|OID_AUTO
argument_list|,
name|pps_shiftmax
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pps_shiftmax
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ntp_pll
argument_list|,
name|OID_AUTO
argument_list|,
name|pps_shift
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pps_shift
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * ntp_adjtime() - NTP daemon application interface  *  * See the timex.h header file for synopsis and API description.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|ntp_adjtime_args
block|{
name|struct
name|timex
modifier|*
name|tp
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|ntp_adjtime
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ntp_adjtime_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timex
name|ntv
decl_stmt|;
comment|/* temporary structure */
name|long
name|freq
decl_stmt|;
comment|/* frequency ns/s) */
name|int
name|modes
decl_stmt|;
comment|/* mode bits from structure */
name|int
name|s
decl_stmt|;
comment|/* caller priority */
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|tp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ntv
argument_list|,
sizeof|sizeof
argument_list|(
name|ntv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Update selected clock variables - only the superuser can 	 * change anything. Note that there is no error checking here on 	 * the assumption the superuser should know what it is doing. 	 */
name|modes
operator|=
name|ntv
operator|.
name|modes
expr_stmt|;
if|if
condition|(
name|modes
condition|)
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|s
operator|=
name|splclock
argument_list|()
expr_stmt|;
if|if
condition|(
name|modes
operator|&
name|MOD_FREQUENCY
condition|)
block|{
name|freq
operator|=
operator|(
name|ntv
operator|.
name|freq
operator|*
literal|1000LL
operator|)
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|freq
operator|>
name|MAXFREQ
condition|)
name|L_LINT
argument_list|(
name|time_freq
argument_list|,
name|MAXFREQ
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|freq
operator|<
operator|-
name|MAXFREQ
condition|)
name|L_LINT
argument_list|(
name|time_freq
argument_list|,
operator|-
name|MAXFREQ
argument_list|)
expr_stmt|;
else|else
name|L_LINT
argument_list|(
name|time_freq
argument_list|,
name|freq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PPS_SYNC
name|pps_freq
operator|=
name|time_freq
expr_stmt|;
endif|#
directive|endif
comment|/* PPS_SYNC */
block|}
if|if
condition|(
name|modes
operator|&
name|MOD_MAXERROR
condition|)
name|time_maxerror
operator|=
name|ntv
operator|.
name|maxerror
expr_stmt|;
if|if
condition|(
name|modes
operator|&
name|MOD_ESTERROR
condition|)
name|time_esterror
operator|=
name|ntv
operator|.
name|esterror
expr_stmt|;
if|if
condition|(
name|modes
operator|&
name|MOD_STATUS
condition|)
block|{
name|time_status
operator|&=
name|STA_RONLY
expr_stmt|;
name|time_status
operator||=
name|ntv
operator|.
name|status
operator|&
operator|~
name|STA_RONLY
expr_stmt|;
block|}
if|if
condition|(
name|modes
operator|&
name|MOD_TIMECONST
condition|)
block|{
if|if
condition|(
name|ntv
operator|.
name|constant
operator|<
literal|0
condition|)
name|time_constant
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|ntv
operator|.
name|constant
operator|>
name|MAXTC
condition|)
name|time_constant
operator|=
name|MAXTC
expr_stmt|;
else|else
name|time_constant
operator|=
name|ntv
operator|.
name|constant
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PPS_SYNC
if|if
condition|(
name|modes
operator|&
name|MOD_PPSMAX
condition|)
block|{
if|if
condition|(
name|ntv
operator|.
name|shift
operator|<
name|PPS_FAVG
condition|)
name|pps_shiftmax
operator|=
name|PPS_FAVG
expr_stmt|;
elseif|else
if|if
condition|(
name|ntv
operator|.
name|shift
operator|>
name|PPS_FAVGMAX
condition|)
name|pps_shiftmax
operator|=
name|PPS_FAVGMAX
expr_stmt|;
else|else
name|pps_shiftmax
operator|=
name|ntv
operator|.
name|shift
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PPS_SYNC */
if|if
condition|(
name|modes
operator|&
name|MOD_NANO
condition|)
name|time_status
operator||=
name|STA_NANO
expr_stmt|;
if|if
condition|(
name|modes
operator|&
name|MOD_MICRO
condition|)
name|time_status
operator|&=
operator|~
name|STA_NANO
expr_stmt|;
if|if
condition|(
name|modes
operator|&
name|MOD_CLKB
condition|)
name|time_status
operator||=
name|STA_CLK
expr_stmt|;
if|if
condition|(
name|modes
operator|&
name|MOD_CLKA
condition|)
name|time_status
operator|&=
operator|~
name|STA_CLK
expr_stmt|;
if|if
condition|(
name|modes
operator|&
name|MOD_OFFSET
condition|)
block|{
if|if
condition|(
name|time_status
operator|&
name|STA_NANO
condition|)
name|hardupdate
argument_list|(
name|ntv
operator|.
name|offset
argument_list|)
expr_stmt|;
else|else
name|hardupdate
argument_list|(
name|ntv
operator|.
name|offset
operator|*
literal|1000
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Retrieve all clock variables 	 */
if|if
condition|(
name|time_status
operator|&
name|STA_NANO
condition|)
name|ntv
operator|.
name|offset
operator|=
name|L_GINT
argument_list|(
name|time_offset
argument_list|)
expr_stmt|;
else|else
name|ntv
operator|.
name|offset
operator|=
name|L_GINT
argument_list|(
name|time_offset
argument_list|)
operator|/
literal|1000
expr_stmt|;
name|ntv
operator|.
name|freq
operator|=
name|L_GINT
argument_list|(
operator|(
name|time_freq
operator|/
literal|1000LL
operator|)
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|ntv
operator|.
name|maxerror
operator|=
name|time_maxerror
expr_stmt|;
name|ntv
operator|.
name|esterror
operator|=
name|time_esterror
expr_stmt|;
name|ntv
operator|.
name|status
operator|=
name|time_status
expr_stmt|;
name|ntv
operator|.
name|constant
operator|=
name|time_constant
expr_stmt|;
if|if
condition|(
name|time_status
operator|&
name|STA_NANO
condition|)
name|ntv
operator|.
name|precision
operator|=
name|time_precision
expr_stmt|;
else|else
name|ntv
operator|.
name|precision
operator|=
name|time_precision
operator|/
literal|1000
expr_stmt|;
name|ntv
operator|.
name|tolerance
operator|=
name|MAXFREQ
operator|*
name|SCALE_PPM
expr_stmt|;
ifdef|#
directive|ifdef
name|PPS_SYNC
name|ntv
operator|.
name|shift
operator|=
name|pps_shift
expr_stmt|;
name|ntv
operator|.
name|ppsfreq
operator|=
name|L_GINT
argument_list|(
operator|(
name|pps_freq
operator|/
literal|1000LL
operator|)
operator|<<
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_status
operator|&
name|STA_NANO
condition|)
name|ntv
operator|.
name|jitter
operator|=
name|pps_jitter
expr_stmt|;
else|else
name|ntv
operator|.
name|jitter
operator|=
name|pps_jitter
operator|/
literal|1000
expr_stmt|;
name|ntv
operator|.
name|stabil
operator|=
name|pps_stabil
expr_stmt|;
name|ntv
operator|.
name|calcnt
operator|=
name|pps_calcnt
expr_stmt|;
name|ntv
operator|.
name|errcnt
operator|=
name|pps_errcnt
expr_stmt|;
name|ntv
operator|.
name|jitcnt
operator|=
name|pps_jitcnt
expr_stmt|;
name|ntv
operator|.
name|stbcnt
operator|=
name|pps_stbcnt
expr_stmt|;
endif|#
directive|endif
comment|/* PPS_SYNC */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ntv
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|tp
argument_list|,
sizeof|sizeof
argument_list|(
name|ntv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Status word error decode. See comments in 	 * ntp_gettime() routine. 	 */
if|if
condition|(
operator|(
name|time_status
operator|&
operator|(
name|STA_UNSYNC
operator||
name|STA_CLOCKERR
operator|)
operator|)
operator|||
operator|(
name|time_status
operator|&
operator|(
name|STA_PPSFREQ
operator||
name|STA_PPSTIME
operator|)
operator|&&
operator|!
operator|(
name|time_status
operator|&
name|STA_PPSSIGNAL
operator|)
operator|)
operator|||
operator|(
name|time_status
operator|&
name|STA_PPSTIME
operator|&&
name|time_status
operator|&
name|STA_PPSJITTER
operator|)
operator|||
operator|(
name|time_status
operator|&
name|STA_PPSFREQ
operator|&&
name|time_status
operator|&
operator|(
name|STA_PPSWANDER
operator||
name|STA_PPSERROR
operator|)
operator|)
condition|)
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|TIME_ERROR
expr_stmt|;
else|else
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|time_state
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * second_overflow() - called after ntp_tick_adjust()  *  * This routine is ordinarily called immediately following the above  * routine ntp_tick_adjust(). While these two routines are normally  * combined, they are separated here only for the purposes of  * simulation.  */
end_comment

begin_function
name|void
name|ntp_update_second
parameter_list|(
name|struct
name|timecounter
modifier|*
name|tcp
parameter_list|)
block|{
name|u_int32_t
modifier|*
name|newsec
decl_stmt|;
name|l_fp
name|time_adj
decl_stmt|;
comment|/* 32/64-bit temporaries */
name|newsec
operator|=
operator|&
name|tcp
operator|->
name|tc_offset_sec
expr_stmt|;
comment|/* 	 * On rollover of the second both the nanosecond and microsecond 	 * clocks are updated and the state machine cranked as 	 * necessary. The phase adjustment to be used for the next 	 * second is calculated and the maximum error is increased by 	 * the tolerance. 	 */
name|time_maxerror
operator|+=
name|MAXFREQ
operator|/
literal|1000
expr_stmt|;
comment|/* 	 * Leap second processing. If in leap-insert state at 	 * the end of the day, the system clock is set back one 	 * second; if in leap-delete state, the system clock is 	 * set ahead one second. The nano_time() routine or 	 * external clock driver will insure that reported time 	 * is always monotonic. 	 */
switch|switch
condition|(
name|time_state
condition|)
block|{
comment|/* 		 * No warning. 		 */
case|case
name|TIME_OK
case|:
if|if
condition|(
name|time_status
operator|&
name|STA_INS
condition|)
name|time_state
operator|=
name|TIME_INS
expr_stmt|;
elseif|else
if|if
condition|(
name|time_status
operator|&
name|STA_DEL
condition|)
name|time_state
operator|=
name|TIME_DEL
expr_stmt|;
break|break;
comment|/* 		 * Insert second 23:59:60 following second 		 * 23:59:59. 		 */
case|case
name|TIME_INS
case|:
if|if
condition|(
operator|!
operator|(
name|time_status
operator|&
name|STA_INS
operator|)
condition|)
name|time_state
operator|=
name|TIME_OK
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|newsec
operator|)
operator|%
literal|86400
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|newsec
operator|)
operator|--
expr_stmt|;
name|time_state
operator|=
name|TIME_OOP
expr_stmt|;
block|}
break|break;
comment|/* 		 * Delete second 23:59:59. 		 */
case|case
name|TIME_DEL
case|:
if|if
condition|(
operator|!
operator|(
name|time_status
operator|&
name|STA_DEL
operator|)
condition|)
name|time_state
operator|=
name|TIME_OK
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
operator|*
name|newsec
operator|)
operator|+
literal|1
operator|)
operator|%
literal|86400
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|newsec
operator|)
operator|++
expr_stmt|;
name|time_state
operator|=
name|TIME_WAIT
expr_stmt|;
block|}
break|break;
comment|/* 		 * Insert second in progress. 		 */
case|case
name|TIME_OOP
case|:
name|time_state
operator|=
name|TIME_WAIT
expr_stmt|;
break|break;
comment|/* 		 * Wait for status bits to clear. 		 */
case|case
name|TIME_WAIT
case|:
if|if
condition|(
operator|!
operator|(
name|time_status
operator|&
operator|(
name|STA_INS
operator||
name|STA_DEL
operator|)
operator|)
condition|)
name|time_state
operator|=
name|TIME_OK
expr_stmt|;
block|}
comment|/* 	 * Compute the total time adjustment for the next second 	 * in ns. The offset is reduced by a factor depending on 	 * whether the PPS signal is operating. Note that the 	 * value is in effect scaled by the clock frequency, 	 * since the adjustment is added at each tick interrupt. 	 */
ifdef|#
directive|ifdef
name|PPS_SYNC
comment|/* XXX even if signal dies we should finish adjustment ? */
if|if
condition|(
name|time_status
operator|&
name|STA_PPSTIME
operator|&&
name|time_status
operator|&
name|STA_PPSSIGNAL
condition|)
block|{
name|time_adj
operator|=
name|pps_offset
expr_stmt|;
name|L_RSHIFT
argument_list|(
name|time_adj
argument_list|,
name|pps_shift
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
name|pps_offset
argument_list|,
name|time_adj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|time_adj
operator|=
name|time_offset
expr_stmt|;
name|L_RSHIFT
argument_list|(
name|time_adj
argument_list|,
name|SHIFT_PLL
operator|+
name|time_constant
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
name|time_offset
argument_list|,
name|time_adj
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|time_adj
operator|=
name|time_offset
expr_stmt|;
name|L_RSHIFT
argument_list|(
name|time_adj
argument_list|,
name|SHIFT_PLL
operator|+
name|time_constant
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
name|time_offset
argument_list|,
name|time_adj
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PPS_SYNC */
name|L_ADD
argument_list|(
name|time_adj
argument_list|,
name|time_freq
argument_list|)
expr_stmt|;
name|tcp
operator|->
name|tc_adjustment
operator|=
name|time_adj
expr_stmt|;
ifdef|#
directive|ifdef
name|PPS_SYNC
if|if
condition|(
name|pps_valid
operator|>
literal|0
condition|)
name|pps_valid
operator|--
expr_stmt|;
else|else
name|time_status
operator|&=
operator|~
operator|(
name|STA_PPSSIGNAL
operator||
name|STA_PPSJITTER
operator||
name|STA_PPSWANDER
operator||
name|STA_PPSERROR
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* PPS_SYNC */
block|}
end_function

begin_comment
comment|/*  * ntp_init() - initialize variables and structures  *  * This routine must be called after the kernel variables hz and tick  * are set or changed and before the next tick interrupt. In this  * particular implementation, these values are assumed set elsewhere in  * the kernel. The design allows the clock frequency and tick interval  * to be changed while the system is running. So, this routine should  * probably be integrated with the code that does that.  */
end_comment

begin_function
specifier|static
name|void
name|ntp_init
parameter_list|()
block|{
comment|/* 	 * The following variable must be initialized any time the 	 * kernel variable hz is changed. 	 */
name|time_tick
operator|=
name|NANOSECOND
operator|/
name|hz
expr_stmt|;
comment|/* 	 * The following variables are initialized only at startup. Only 	 * those structures not cleared by the compiler need to be 	 * initialized, and these only in the simulator. In the actual 	 * kernel, any nonzero values here will quickly evaporate. 	 */
name|L_CLR
argument_list|(
name|time_offset
argument_list|)
expr_stmt|;
name|L_CLR
argument_list|(
name|time_freq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PPS_SYNC
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|pps_tf
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|pps_tf
index|[
literal|1
index|]
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_sec
operator|=
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|pps_fcount
operator|=
literal|0
expr_stmt|;
name|L_CLR
argument_list|(
name|pps_freq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PPS_SYNC */
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|ntpclocks
argument_list|,
argument|SI_SUB_CLOCKS
argument_list|,
argument|SI_ORDER_FIRST
argument_list|,
argument|ntp_init
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_comment
comment|/*  * hardupdate() - local clock update  *  * This routine is called by ntp_adjtime() to update the local clock  * phase and frequency. The implementation is of an adaptive-parameter,  * hybrid phase/frequency-lock loop (PLL/FLL). The routine computes new  * time and frequency offset estimates for each call. If the kernel PPS  * discipline code is configured (PPS_SYNC), the PPS signal itself  * determines the new time offset, instead of the calling argument.  * Presumably, calls to ntp_adjtime() occur only when the caller  * believes the local clock is valid within some bound (+-128 ms with  * NTP). If the caller's time is far different than the PPS time, an  * argument will ensue, and it's not clear who will lose.  *  * For uncompensated quartz crystal oscillators and nominal update  * intervals less than 256 s, operation should be in phase-lock mode,  * where the loop is disciplined to phase. For update intervals greater  * than 1024 s, operation should be in frequency-lock mode, where the  * loop is disciplined to frequency. Between 256 s and 1024 s, the mode  * is selected by the STA_MODE status bit.  */
end_comment

begin_function
specifier|static
name|void
name|hardupdate
parameter_list|(
name|offset
parameter_list|)
name|long
name|offset
decl_stmt|;
comment|/* clock offset (ns) */
block|{
name|long
name|ltemp
decl_stmt|,
name|mtemp
decl_stmt|;
name|l_fp
name|ftemp
decl_stmt|;
comment|/* 	 * Select how the phase is to be controlled and from which 	 * source. If the PPS signal is present and enabled to 	 * discipline the time, the PPS offset is used; otherwise, the 	 * argument offset is used. 	 */
if|if
condition|(
operator|!
operator|(
name|time_status
operator|&
name|STA_PLL
operator|)
condition|)
return|return;
name|ltemp
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|ltemp
operator|>
name|MAXPHASE
condition|)
name|ltemp
operator|=
name|MAXPHASE
expr_stmt|;
elseif|else
if|if
condition|(
name|ltemp
operator|<
operator|-
name|MAXPHASE
condition|)
name|ltemp
operator|=
operator|-
name|MAXPHASE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|time_status
operator|&
name|STA_PPSTIME
operator|&&
name|time_status
operator|&
name|STA_PPSSIGNAL
operator|)
condition|)
name|L_LINT
argument_list|(
name|time_offset
argument_list|,
name|ltemp
argument_list|)
expr_stmt|;
comment|/* 	 * Select how the frequency is to be controlled and in which 	 * mode (PLL or FLL). If the PPS signal is present and enabled 	 * to discipline the frequency, the PPS frequency is used; 	 * otherwise, the argument offset is used to compute it. 	 */
if|if
condition|(
name|time_status
operator|&
name|STA_PPSFREQ
operator|&&
name|time_status
operator|&
name|STA_PPSSIGNAL
condition|)
block|{
name|time_reftime
operator|=
name|time_second
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|time_status
operator|&
name|STA_FREQHOLD
operator|||
name|time_reftime
operator|==
literal|0
condition|)
name|time_reftime
operator|=
name|time_second
expr_stmt|;
name|mtemp
operator|=
name|time_second
operator|-
name|time_reftime
expr_stmt|;
name|L_LINT
argument_list|(
name|ftemp
argument_list|,
name|ltemp
argument_list|)
expr_stmt|;
name|L_RSHIFT
argument_list|(
name|ftemp
argument_list|,
operator|(
name|SHIFT_PLL
operator|+
literal|2
operator|+
name|time_constant
operator|)
operator|<<
literal|1
argument_list|)
expr_stmt|;
name|L_MPY
argument_list|(
name|ftemp
argument_list|,
name|mtemp
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
name|time_freq
argument_list|,
name|ftemp
argument_list|)
expr_stmt|;
name|time_status
operator|&=
operator|~
name|STA_MODE
expr_stmt|;
if|if
condition|(
name|mtemp
operator|>=
name|MINSEC
operator|&&
operator|(
name|time_status
operator|&
name|STA_FLL
operator|||
name|mtemp
operator|>
name|MAXSEC
operator|)
condition|)
block|{
name|L_LINT
argument_list|(
name|ftemp
argument_list|,
operator|(
name|ltemp
operator|<<
literal|4
operator|)
operator|/
name|mtemp
argument_list|)
expr_stmt|;
name|L_RSHIFT
argument_list|(
name|ftemp
argument_list|,
name|SHIFT_FLL
operator|+
literal|4
argument_list|)
expr_stmt|;
name|L_ADD
argument_list|(
name|time_freq
argument_list|,
name|ftemp
argument_list|)
expr_stmt|;
name|time_status
operator||=
name|STA_MODE
expr_stmt|;
block|}
name|time_reftime
operator|=
name|time_second
expr_stmt|;
if|if
condition|(
name|L_GINT
argument_list|(
name|time_freq
argument_list|)
operator|>
name|MAXFREQ
condition|)
name|L_LINT
argument_list|(
name|time_freq
argument_list|,
name|MAXFREQ
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|L_GINT
argument_list|(
name|time_freq
argument_list|)
operator|<
operator|-
name|MAXFREQ
condition|)
name|L_LINT
argument_list|(
name|time_freq
argument_list|,
operator|-
name|MAXFREQ
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PPS_SYNC
end_ifdef

begin_comment
comment|/*  * hardpps() - discipline CPU clock oscillator to external PPS signal  *  * This routine is called at each PPS interrupt in order to discipline  * the CPU clock oscillator to the PPS signal. It measures the PPS phase  * and leaves it in a handy spot for the hardclock() routine. It  * integrates successive PPS phase differences and calculates the  * frequency offset. This is used in hardclock() to discipline the CPU  * clock oscillator so that the intrinsic frequency error is cancelled  * out. The code requires the caller to capture the time and  * architecture-dependent hardware counter values in nanoseconds at the  * on-time PPS signal transition.  *  * Note that, on some Unix systems this routine runs at an interrupt  * priority level higher than the timer interrupt routine hardclock().  * Therefore, the variables used are distinct from the hardclock()  * variables, except for the actual time and frequency variables, which  * are determined by this routine and updated atomically.  */
end_comment

begin_function
name|void
name|hardpps
parameter_list|(
name|tsp
parameter_list|,
name|nsec
parameter_list|)
name|struct
name|timespec
modifier|*
name|tsp
decl_stmt|;
comment|/* time at PPS */
name|long
name|nsec
decl_stmt|;
comment|/* hardware counter at PPS */
block|{
name|long
name|u_sec
decl_stmt|,
name|u_nsec
decl_stmt|,
name|v_nsec
decl_stmt|;
comment|/* temps */
name|l_fp
name|ftemp
decl_stmt|;
comment|/* 	 * The signal is first processed by a frequency discriminator 	 * which rejects noise and input signals with frequencies 	 * outside the range 1 +-MAXFREQ PPS. If two hits occur in the 	 * same second, we ignore the later hit; if not and a hit occurs 	 * outside the range gate, keep the later hit but do not 	 * process it. 	 */
name|time_status
operator||=
name|STA_PPSSIGNAL
operator||
name|STA_PPSJITTER
expr_stmt|;
name|time_status
operator|&=
operator|~
operator|(
name|STA_PPSWANDER
operator||
name|STA_PPSERROR
operator|)
expr_stmt|;
name|pps_valid
operator|=
name|PPS_VALID
expr_stmt|;
name|u_sec
operator|=
name|tsp
operator|->
name|tv_sec
expr_stmt|;
name|u_nsec
operator|=
name|tsp
operator|->
name|tv_nsec
expr_stmt|;
if|if
condition|(
name|u_nsec
operator|>=
operator|(
name|NANOSECOND
operator|>>
literal|1
operator|)
condition|)
block|{
name|u_nsec
operator|-=
name|NANOSECOND
expr_stmt|;
name|u_sec
operator|++
expr_stmt|;
block|}
name|v_nsec
operator|=
name|u_nsec
operator|-
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
expr_stmt|;
if|if
condition|(
name|u_sec
operator|==
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|&&
name|v_nsec
operator|<
operator|-
name|MAXFREQ
condition|)
block|{
return|return;
block|}
name|pps_tf
index|[
literal|2
index|]
operator|=
name|pps_tf
index|[
literal|1
index|]
expr_stmt|;
name|pps_tf
index|[
literal|1
index|]
operator|=
name|pps_tf
index|[
literal|0
index|]
expr_stmt|;
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|u_sec
expr_stmt|;
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
operator|=
name|u_nsec
expr_stmt|;
comment|/* 	 * Compute the difference between the current and previous 	 * counter values. If the difference exceeds 0.5 s, assume it 	 * has wrapped around, so correct 1.0 s. If the result exceeds 	 * the tick interval, the sample point has crossed a tick 	 * boundary during the last second, so correct the tick. Very 	 * intricate. 	 */
name|u_nsec
operator|=
name|nsec
expr_stmt|;
if|if
condition|(
name|u_nsec
operator|>
operator|(
name|NANOSECOND
operator|>>
literal|1
operator|)
condition|)
name|u_nsec
operator|-=
name|NANOSECOND
expr_stmt|;
elseif|else
if|if
condition|(
name|u_nsec
operator|<
operator|-
operator|(
name|NANOSECOND
operator|>>
literal|1
operator|)
condition|)
name|u_nsec
operator|+=
name|NANOSECOND
expr_stmt|;
name|pps_fcount
operator|+=
name|u_nsec
expr_stmt|;
if|if
condition|(
name|v_nsec
operator|>
name|MAXFREQ
operator|||
name|v_nsec
operator|<
operator|-
name|MAXFREQ
condition|)
block|{
return|return;
block|}
name|time_status
operator|&=
operator|~
name|STA_PPSJITTER
expr_stmt|;
comment|/* 	 * A three-stage median filter is used to help denoise the PPS 	 * time. The median sample becomes the time offset estimate; the 	 * difference between the other two samples becomes the time 	 * dispersion (jitter) estimate. 	 */
if|if
condition|(
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
operator|>
name|pps_tf
index|[
literal|1
index|]
operator|.
name|tv_nsec
condition|)
block|{
if|if
condition|(
name|pps_tf
index|[
literal|1
index|]
operator|.
name|tv_nsec
operator|>
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_nsec
condition|)
block|{
name|v_nsec
operator|=
name|pps_tf
index|[
literal|1
index|]
operator|.
name|tv_nsec
expr_stmt|;
comment|/* 0 1 2 */
name|u_nsec
operator|=
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
operator|-
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_nsec
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_nsec
operator|>
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
condition|)
block|{
name|v_nsec
operator|=
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
expr_stmt|;
comment|/* 2 0 1 */
name|u_nsec
operator|=
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_nsec
operator|-
name|pps_tf
index|[
literal|1
index|]
operator|.
name|tv_nsec
expr_stmt|;
block|}
else|else
block|{
name|v_nsec
operator|=
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_nsec
expr_stmt|;
comment|/* 0 2 1 */
name|u_nsec
operator|=
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
operator|-
name|pps_tf
index|[
literal|1
index|]
operator|.
name|tv_nsec
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|pps_tf
index|[
literal|1
index|]
operator|.
name|tv_nsec
operator|<
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_nsec
condition|)
block|{
name|v_nsec
operator|=
name|pps_tf
index|[
literal|1
index|]
operator|.
name|tv_nsec
expr_stmt|;
comment|/* 2 1 0 */
name|u_nsec
operator|=
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_nsec
operator|-
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_nsec
operator|<
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
condition|)
block|{
name|v_nsec
operator|=
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
expr_stmt|;
comment|/* 1 0 2 */
name|u_nsec
operator|=
name|pps_tf
index|[
literal|1
index|]
operator|.
name|tv_nsec
operator|-
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_nsec
expr_stmt|;
block|}
else|else
block|{
name|v_nsec
operator|=
name|pps_tf
index|[
literal|2
index|]
operator|.
name|tv_nsec
expr_stmt|;
comment|/* 1 2 0 */
name|u_nsec
operator|=
name|pps_tf
index|[
literal|1
index|]
operator|.
name|tv_nsec
operator|-
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_nsec
expr_stmt|;
block|}
block|}
comment|/* 	 * Nominal jitter is due to PPS signal noise and  interrupt 	 * latency. If it exceeds the popcorn threshold, 	 * the sample is discarded. otherwise, if so enabled, the time 	 * offset is updated. We can tolerate a modest loss of data here 	 * without degrading time accuracy. 	 */
if|if
condition|(
name|u_nsec
operator|>
operator|(
name|pps_jitter
operator|<<
name|PPS_POPCORN
operator|)
condition|)
block|{
name|time_status
operator||=
name|STA_PPSJITTER
expr_stmt|;
name|pps_jitcnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|time_status
operator|&
name|STA_PPSTIME
condition|)
block|{
name|L_LINT
argument_list|(
name|time_offset
argument_list|,
operator|-
name|v_nsec
argument_list|)
expr_stmt|;
name|L_LINT
argument_list|(
name|pps_offset
argument_list|,
operator|-
name|v_nsec
argument_list|)
expr_stmt|;
block|}
name|pps_jitter
operator|+=
operator|(
name|u_nsec
operator|-
name|pps_jitter
operator|)
operator|>>
name|PPS_FAVG
expr_stmt|;
name|u_sec
operator|=
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|-
name|pps_lastsec
expr_stmt|;
if|if
condition|(
name|u_sec
operator|<
operator|(
literal|1
operator|<<
name|pps_shift
operator|)
condition|)
return|return;
comment|/* 	 * At the end of the calibration interval the difference between 	 * the first and last counter values becomes the scaled 	 * frequency. It will later be divided by the length of the 	 * interval to determine the frequency update. If the frequency 	 * exceeds a sanity threshold, or if the actual calibration 	 * interval is not equal to the expected length, the data are 	 * discarded. We can tolerate a modest loss of data here without 	 * degrading frequency ccuracy. 	 */
name|pps_calcnt
operator|++
expr_stmt|;
name|v_nsec
operator|=
operator|-
name|pps_fcount
expr_stmt|;
name|pps_lastsec
operator|=
name|pps_tf
index|[
literal|0
index|]
operator|.
name|tv_sec
expr_stmt|;
name|pps_fcount
operator|=
literal|0
expr_stmt|;
name|u_nsec
operator|=
name|MAXFREQ
operator|<<
name|pps_shift
expr_stmt|;
if|if
condition|(
name|v_nsec
operator|>
name|u_nsec
operator|||
name|v_nsec
operator|<
operator|-
name|u_nsec
operator|||
name|u_sec
operator|!=
operator|(
literal|1
operator|<<
name|pps_shift
operator|)
condition|)
block|{
name|time_status
operator||=
name|STA_PPSERROR
expr_stmt|;
name|pps_errcnt
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * Here the raw frequency offset and wander (stability) is 	 * calculated. If the wander is less than the wander threshold 	 * for four consecutive averaging intervals, the interval is 	 * doubled; if it is greater than the threshold for four 	 * consecutive intervals, the interval is halved. The scaled 	 * frequency offset is converted to frequency offset. The 	 * stability metric is calculated as the average of recent 	 * frequency changes, but is used only for performance 	 * monitoring. 	 */
name|L_LINT
argument_list|(
name|ftemp
argument_list|,
name|v_nsec
argument_list|)
expr_stmt|;
name|L_RSHIFT
argument_list|(
name|ftemp
argument_list|,
name|pps_shift
argument_list|)
expr_stmt|;
name|L_SUB
argument_list|(
name|ftemp
argument_list|,
name|pps_freq
argument_list|)
expr_stmt|;
name|u_nsec
operator|=
name|L_GINT
argument_list|(
name|ftemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|u_nsec
operator|>
name|PPS_MAXWANDER
condition|)
block|{
name|L_LINT
argument_list|(
name|ftemp
argument_list|,
name|PPS_MAXWANDER
argument_list|)
expr_stmt|;
name|pps_intcnt
operator|--
expr_stmt|;
name|time_status
operator||=
name|STA_PPSWANDER
expr_stmt|;
name|pps_stbcnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|u_nsec
operator|<
operator|-
name|PPS_MAXWANDER
condition|)
block|{
name|L_LINT
argument_list|(
name|ftemp
argument_list|,
operator|-
name|PPS_MAXWANDER
argument_list|)
expr_stmt|;
name|pps_intcnt
operator|--
expr_stmt|;
name|time_status
operator||=
name|STA_PPSWANDER
expr_stmt|;
name|pps_stbcnt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|pps_intcnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pps_shift
operator|>
name|pps_shiftmax
condition|)
block|{
comment|/* If we lowered pps_shiftmax */
name|pps_shift
operator|=
name|pps_shiftmax
expr_stmt|;
name|pps_intcnt
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pps_intcnt
operator|>=
literal|4
condition|)
block|{
name|pps_intcnt
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|pps_shift
operator|<
name|pps_shiftmax
condition|)
block|{
name|pps_shift
operator|++
expr_stmt|;
name|pps_intcnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pps_intcnt
operator|<=
operator|-
literal|4
condition|)
block|{
name|pps_intcnt
operator|=
operator|-
literal|4
expr_stmt|;
if|if
condition|(
name|pps_shift
operator|>
name|PPS_FAVG
condition|)
block|{
name|pps_shift
operator|--
expr_stmt|;
name|pps_intcnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|u_nsec
operator|<
literal|0
condition|)
name|u_nsec
operator|=
operator|-
name|u_nsec
expr_stmt|;
name|pps_stabil
operator|+=
operator|(
name|u_nsec
operator|*
name|SCALE_PPM
operator|-
name|pps_stabil
operator|)
operator|>>
name|PPS_FAVG
expr_stmt|;
comment|/* 	 * The PPS frequency is recalculated and clamped to the maximum 	 * MAXFREQ. If enabled, the system clock frequency is updated as 	 * well. 	 */
name|L_ADD
argument_list|(
name|pps_freq
argument_list|,
name|ftemp
argument_list|)
expr_stmt|;
name|u_nsec
operator|=
name|L_GINT
argument_list|(
name|pps_freq
argument_list|)
expr_stmt|;
if|if
condition|(
name|u_nsec
operator|>
name|MAXFREQ
condition|)
name|L_LINT
argument_list|(
name|pps_freq
argument_list|,
name|MAXFREQ
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|u_nsec
operator|<
operator|-
name|MAXFREQ
condition|)
name|L_LINT
argument_list|(
name|pps_freq
argument_list|,
operator|-
name|MAXFREQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_status
operator|&
name|STA_PPSFREQ
condition|)
name|time_freq
operator|=
name|pps_freq
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPS_SYNC */
end_comment

end_unit

