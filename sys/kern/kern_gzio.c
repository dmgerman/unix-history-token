begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $Id: kern_gzio.c,v 1.6 2008-10-18 22:54:45 lbazinet Exp $  *  * core_gzip.c -- gzip routines used in compressing user process cores  *  * This file is derived from src/lib/libz/gzio.c in FreeBSD.  */
end_comment

begin_comment
comment|/* gzio.c -- IO on .gz files  * Copyright (C) 1995-1998 Jean-loup Gailly.  * For conditions of distribution and use, see copyright notice in zlib.h  *  */
end_comment

begin_comment
comment|/* @(#) $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<net/zutil.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_define
define|#
directive|define
name|GZ_HEADER_LEN
value|10
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|Z_BUFSIZE
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|MAXSEG_64K
end_ifdef

begin_define
define|#
directive|define
name|Z_BUFSIZE
value|4096
end_define

begin_comment
comment|/* minimize memory usage for 16-bit DOS */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Z_BUFSIZE
value|16384
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|Z_PRINTF_BUFSIZE
end_ifndef

begin_define
define|#
directive|define
name|Z_PRINTF_BUFSIZE
value|4096
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ALLOC
parameter_list|(
name|size
parameter_list|)
value|malloc(size, M_TEMP, M_WAITOK | M_ZERO)
end_define

begin_define
define|#
directive|define
name|TRYFREE
parameter_list|(
name|p
parameter_list|)
value|{if (p) free(p, M_TEMP);}
end_define

begin_decl_stmt
specifier|static
name|int
name|gz_magic
index|[
literal|2
index|]
init|=
block|{
literal|0x1f
block|,
literal|0x8b
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* gzip magic header */
end_comment

begin_comment
comment|/* gzip flag byte */
end_comment

begin_define
define|#
directive|define
name|ASCII_FLAG
value|0x01
end_define

begin_comment
comment|/* bit 0 set: file probably ascii text */
end_comment

begin_define
define|#
directive|define
name|HEAD_CRC
value|0x02
end_define

begin_comment
comment|/* bit 1 set: header CRC present */
end_comment

begin_define
define|#
directive|define
name|EXTRA_FIELD
value|0x04
end_define

begin_comment
comment|/* bit 2 set: extra field present */
end_comment

begin_define
define|#
directive|define
name|ORIG_NAME
value|0x08
end_define

begin_comment
comment|/* bit 3 set: original file name present */
end_comment

begin_define
define|#
directive|define
name|COMMENT
value|0x10
end_define

begin_comment
comment|/* bit 4 set: file comment present */
end_comment

begin_define
define|#
directive|define
name|RESERVED
value|0xE0
end_define

begin_comment
comment|/* bits 5..7: reserved */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|gz_stream
block|{
name|z_stream
name|stream
decl_stmt|;
name|int
name|z_err
decl_stmt|;
comment|/* error code for last stream operation */
name|int
name|z_eof
decl_stmt|;
comment|/* set if end of input file */
name|struct
name|vnode
modifier|*
name|file
decl_stmt|;
comment|/* vnode pointer of .gz file */
name|Byte
modifier|*
name|inbuf
decl_stmt|;
comment|/* input buffer */
name|Byte
modifier|*
name|outbuf
decl_stmt|;
comment|/* output buffer */
name|uLong
name|crc
decl_stmt|;
comment|/* crc32 of uncompressed data */
name|char
modifier|*
name|msg
decl_stmt|;
comment|/* error message */
name|char
modifier|*
name|path
decl_stmt|;
comment|/* path name for debugging only */
name|int
name|transparent
decl_stmt|;
comment|/* 1 if input file is not a .gz file */
name|char
name|mode
decl_stmt|;
comment|/* 'w' or 'r' */
name|long
name|startpos
decl_stmt|;
comment|/* start of compressed data in file (header skipped) */
name|off_t
name|outoff
decl_stmt|;
comment|/* current offset in output file */
name|int
name|flags
decl_stmt|;
block|}
name|gz_stream
typedef|;
end_typedef

begin_decl_stmt
name|local
name|int
name|do_flush
name|OF
argument_list|(
operator|(
name|gzFile
name|file
operator|,
name|int
name|flush
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|destroy
name|OF
argument_list|(
operator|(
name|gz_stream
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|putU32
name|OF
argument_list|(
operator|(
name|gz_stream
operator|*
name|file
operator|,
name|uint32_t
name|x
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
modifier|*
name|gz_alloc
name|OF
argument_list|(
operator|(
name|void
operator|*
name|notused
operator|,
name|u_int
name|items
operator|,
name|u_int
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|gz_free
name|OF
argument_list|(
operator|(
name|void
operator|*
name|notused
operator|,
name|void
operator|*
name|ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ===========================================================================      Opens a gzip (.gz) file for reading or writing. The mode parameter    is as in fopen ("rb" or "wb"). The file is given either by file descriptor    or path name (if fd == -1).      gz_open return NULL if the file could not be opened or if there was    insufficient memory to allocate the (de)compression state; errno    can be checked to distinguish the two cases (if errno is zero, the    zlib error is Z_MEM_ERROR). */
end_comment

begin_function
name|gzFile
name|gz_open
parameter_list|(
name|path
parameter_list|,
name|mode
parameter_list|,
name|vp
parameter_list|)
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|mode
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
name|int
name|level
init|=
name|Z_DEFAULT_COMPRESSION
decl_stmt|;
comment|/* compression level */
name|int
name|strategy
init|=
name|Z_DEFAULT_STRATEGY
decl_stmt|;
comment|/* compression strategy */
specifier|const
name|char
modifier|*
name|p
init|=
name|mode
decl_stmt|;
name|gz_stream
modifier|*
name|s
decl_stmt|;
name|char
name|fmode
index|[
literal|80
index|]
decl_stmt|;
comment|/* copy of mode, without the compression level */
name|char
modifier|*
name|m
init|=
name|fmode
decl_stmt|;
name|ssize_t
name|resid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|buf
index|[
name|GZ_HEADER_LEN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|path
operator|||
operator|!
name|mode
condition|)
return|return
name|Z_NULL
return|;
name|s
operator|=
operator|(
name|gz_stream
operator|*
operator|)
name|ALLOC
argument_list|(
sizeof|sizeof
argument_list|(
name|gz_stream
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
name|Z_NULL
return|;
name|s
operator|->
name|stream
operator|.
name|zalloc
operator|=
operator|(
name|alloc_func
operator|)
name|gz_alloc
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|zfree
operator|=
operator|(
name|free_func
operator|)
name|gz_free
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|opaque
operator|=
operator|(
name|voidpf
operator|)
literal|0
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|next_in
operator|=
name|s
operator|->
name|inbuf
operator|=
name|Z_NULL
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|next_out
operator|=
name|s
operator|->
name|outbuf
operator|=
name|Z_NULL
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|=
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|file
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|z_err
operator|=
name|Z_OK
expr_stmt|;
name|s
operator|->
name|z_eof
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|crc
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|msg
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|transparent
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|outoff
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|ALLOC
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|path
operator|==
name|NULL
condition|)
block|{
return|return
name|destroy
argument_list|(
name|s
argument_list|)
operator|,
operator|(
name|gzFile
operator|)
name|Z_NULL
return|;
block|}
name|strcpy
argument_list|(
name|s
operator|->
name|path
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* do this early for debugging */
name|s
operator|->
name|mode
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'r'
condition|)
name|s
operator|->
name|mode
operator|=
literal|'r'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'w'
operator|||
operator|*
name|p
operator|==
literal|'a'
condition|)
name|s
operator|->
name|mode
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
block|{
name|level
operator|=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'f'
condition|)
block|{
name|strategy
operator|=
name|Z_FILTERED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'h'
condition|)
block|{
name|strategy
operator|=
name|Z_HUFFMAN_ONLY
expr_stmt|;
block|}
else|else
block|{
operator|*
name|m
operator|++
operator|=
operator|*
name|p
expr_stmt|;
comment|/* copy the mode */
block|}
block|}
do|while
condition|(
operator|*
name|p
operator|++
operator|&&
name|m
operator|!=
name|fmode
operator|+
sizeof|sizeof
argument_list|(
name|fmode
argument_list|)
condition|)
do|;
if|if
condition|(
name|s
operator|->
name|mode
operator|!=
literal|'w'
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gz_open: mode is not w (%c)\n"
argument_list|,
name|s
operator|->
name|mode
argument_list|)
expr_stmt|;
return|return
name|destroy
argument_list|(
name|s
argument_list|)
operator|,
operator|(
name|gzFile
operator|)
name|Z_NULL
return|;
block|}
name|err
operator|=
name|deflateInit2
argument_list|(
operator|&
operator|(
name|s
operator|->
name|stream
operator|)
argument_list|,
name|level
argument_list|,
name|Z_DEFLATED
argument_list|,
operator|-
name|MAX_WBITS
argument_list|,
name|DEF_MEM_LEVEL
argument_list|,
name|strategy
argument_list|)
expr_stmt|;
comment|/* windowBits is passed< 0 to suppress zlib header */
name|s
operator|->
name|stream
operator|.
name|next_out
operator|=
name|s
operator|->
name|outbuf
operator|=
operator|(
name|Byte
operator|*
operator|)
name|ALLOC
argument_list|(
name|Z_BUFSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|Z_OK
operator|||
name|s
operator|->
name|outbuf
operator|==
name|Z_NULL
condition|)
block|{
return|return
name|destroy
argument_list|(
name|s
argument_list|)
operator|,
operator|(
name|gzFile
operator|)
name|Z_NULL
return|;
block|}
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|=
name|Z_BUFSIZE
expr_stmt|;
name|s
operator|->
name|file
operator|=
name|vp
expr_stmt|;
comment|/* Write a very simple .gz header:      */
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%c%c%c%c%c%c%c%c%c%c"
argument_list|,
name|gz_magic
index|[
literal|0
index|]
argument_list|,
name|gz_magic
index|[
literal|1
index|]
argument_list|,
name|Z_DEFLATED
argument_list|,
literal|0
comment|/*flags*/
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
comment|/*time*/
argument_list|,
literal|0
comment|/*xflags*/
argument_list|,
name|OS_CODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_WRITE
argument_list|,
name|s
operator|->
name|file
argument_list|,
name|buf
argument_list|,
name|GZ_HEADER_LEN
argument_list|,
name|s
operator|->
name|outoff
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_UNIT
argument_list|,
name|curproc
operator|->
name|p_ucred
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|resid
argument_list|,
name|curthread
argument_list|)
operator|)
condition|)
block|{
name|s
operator|->
name|outoff
operator|+=
name|GZ_HEADER_LEN
operator|-
name|resid
expr_stmt|;
return|return
name|destroy
argument_list|(
name|s
argument_list|)
operator|,
operator|(
name|gzFile
operator|)
name|Z_NULL
return|;
block|}
name|s
operator|->
name|outoff
operator|+=
name|GZ_HEADER_LEN
expr_stmt|;
name|s
operator|->
name|startpos
operator|=
literal|10L
expr_stmt|;
return|return
operator|(
name|gzFile
operator|)
name|s
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Cleanup then free the given gz_stream. Return a zlib error code.    Try freeing in the reverse order of allocations.  */
end_comment

begin_function
name|local
name|int
name|destroy
parameter_list|(
name|s
parameter_list|)
name|gz_stream
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|err
init|=
name|Z_OK
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|TRYFREE
argument_list|(
name|s
operator|->
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|stream
operator|.
name|state
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|mode
operator|==
literal|'w'
condition|)
block|{
name|err
operator|=
name|deflateEnd
argument_list|(
operator|&
operator|(
name|s
operator|->
name|stream
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s
operator|->
name|z_err
operator|<
literal|0
condition|)
name|err
operator|=
name|s
operator|->
name|z_err
expr_stmt|;
name|TRYFREE
argument_list|(
name|s
operator|->
name|inbuf
argument_list|)
expr_stmt|;
name|TRYFREE
argument_list|(
name|s
operator|->
name|outbuf
argument_list|)
expr_stmt|;
name|TRYFREE
argument_list|(
name|s
operator|->
name|path
argument_list|)
expr_stmt|;
name|TRYFREE
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================      Writes the given number of uncompressed bytes into the compressed file.    gzwrite returns the number of bytes actually written (0 in case of error). */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzwrite
parameter_list|(
name|file
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|gzFile
name|file
decl_stmt|;
specifier|const
name|voidp
name|buf
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
name|gz_stream
modifier|*
name|s
init|=
operator|(
name|gz_stream
operator|*
operator|)
name|file
decl_stmt|;
name|off_t
name|curoff
decl_stmt|;
name|size_t
name|resid
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
name|s
operator|->
name|mode
operator|!=
literal|'w'
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|s
operator|->
name|stream
operator|.
name|next_in
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|buf
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|=
name|len
expr_stmt|;
name|curoff
operator|=
name|s
operator|->
name|outoff
expr_stmt|;
while|while
condition|(
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|==
literal|0
condition|)
block|{
name|s
operator|->
name|stream
operator|.
name|next_out
operator|=
name|s
operator|->
name|outbuf
expr_stmt|;
name|error
operator|=
name|vn_rdwr_inchunks
argument_list|(
name|UIO_WRITE
argument_list|,
name|s
operator|->
name|file
argument_list|,
name|s
operator|->
name|outbuf
argument_list|,
name|Z_BUFSIZE
argument_list|,
name|curoff
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_UNIT
argument_list|,
name|curproc
operator|->
name|p_ucred
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|resid
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gzwrite: vn_rdwr return %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|curoff
operator|+=
name|Z_BUFSIZE
operator|-
name|resid
expr_stmt|;
name|s
operator|->
name|z_err
operator|=
name|Z_ERRNO
expr_stmt|;
break|break;
block|}
name|curoff
operator|+=
name|Z_BUFSIZE
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|=
name|Z_BUFSIZE
expr_stmt|;
block|}
name|s
operator|->
name|z_err
operator|=
name|deflate
argument_list|(
operator|&
operator|(
name|s
operator|->
name|stream
operator|)
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|z_err
operator|!=
name|Z_OK
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gzwrite: deflate returned error %d\n"
argument_list|,
name|s
operator|->
name|z_err
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|s
operator|->
name|crc
operator|=
operator|~
name|crc32_raw
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
operator|~
name|s
operator|->
name|crc
argument_list|)
expr_stmt|;
name|s
operator|->
name|outoff
operator|=
name|curoff
expr_stmt|;
return|return
call|(
name|int
call|)
argument_list|(
name|len
operator|-
name|s
operator|->
name|stream
operator|.
name|avail_in
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================      Flushes all pending output into the compressed file. The parameter    flush is as in the deflate() function. */
end_comment

begin_function
name|local
name|int
name|do_flush
parameter_list|(
name|file
parameter_list|,
name|flush
parameter_list|)
name|gzFile
name|file
decl_stmt|;
name|int
name|flush
decl_stmt|;
block|{
name|uInt
name|len
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|gz_stream
modifier|*
name|s
init|=
operator|(
name|gz_stream
operator|*
operator|)
name|file
decl_stmt|;
name|off_t
name|curoff
init|=
name|s
operator|->
name|outoff
decl_stmt|;
name|size_t
name|resid
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
name|s
operator|->
name|mode
operator|!=
literal|'w'
condition|)
return|return
name|Z_STREAM_ERROR
return|;
if|if
condition|(
name|s
operator|->
name|stream
operator|.
name|avail_in
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"do_flush: avail_in non-zero on entry\n"
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|stream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
comment|/* should be zero already anyway */
for|for
control|(
init|;
condition|;
control|)
block|{
name|len
operator|=
name|Z_BUFSIZE
operator|-
name|s
operator|->
name|stream
operator|.
name|avail_out
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|vn_rdwr_inchunks
argument_list|(
name|UIO_WRITE
argument_list|,
name|s
operator|->
name|file
argument_list|,
name|s
operator|->
name|outbuf
argument_list|,
name|len
argument_list|,
name|curoff
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_UNIT
argument_list|,
name|curproc
operator|->
name|p_ucred
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|resid
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|s
operator|->
name|z_err
operator|=
name|Z_ERRNO
expr_stmt|;
name|s
operator|->
name|outoff
operator|=
name|curoff
operator|+
name|len
operator|-
name|resid
expr_stmt|;
return|return
name|Z_ERRNO
return|;
block|}
name|s
operator|->
name|stream
operator|.
name|next_out
operator|=
name|s
operator|->
name|outbuf
expr_stmt|;
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|=
name|Z_BUFSIZE
expr_stmt|;
name|curoff
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|done
condition|)
break|break;
name|s
operator|->
name|z_err
operator|=
name|deflate
argument_list|(
operator|&
operator|(
name|s
operator|->
name|stream
operator|)
argument_list|,
name|flush
argument_list|)
expr_stmt|;
comment|/* Ignore the second of two consecutive flushes: */
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
name|s
operator|->
name|z_err
operator|==
name|Z_BUF_ERROR
condition|)
name|s
operator|->
name|z_err
operator|=
name|Z_OK
expr_stmt|;
comment|/* deflate has finished flushing only when it hasn't used up          * all the available space in the output buffer:           */
name|done
operator|=
operator|(
name|s
operator|->
name|stream
operator|.
name|avail_out
operator|!=
literal|0
operator|||
name|s
operator|->
name|z_err
operator|==
name|Z_STREAM_END
operator|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|z_err
operator|!=
name|Z_OK
operator|&&
name|s
operator|->
name|z_err
operator|!=
name|Z_STREAM_END
condition|)
break|break;
block|}
name|s
operator|->
name|outoff
operator|=
name|curoff
expr_stmt|;
return|return
name|s
operator|->
name|z_err
operator|==
name|Z_STREAM_END
condition|?
name|Z_OK
else|:
name|s
operator|->
name|z_err
return|;
block|}
end_function

begin_function
name|int
name|ZEXPORT
name|gzflush
parameter_list|(
name|file
parameter_list|,
name|flush
parameter_list|)
name|gzFile
name|file
decl_stmt|;
name|int
name|flush
decl_stmt|;
block|{
name|gz_stream
modifier|*
name|s
init|=
operator|(
name|gz_stream
operator|*
operator|)
name|file
decl_stmt|;
name|int
name|err
init|=
name|do_flush
argument_list|(
name|file
argument_list|,
name|flush
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
return|return
name|s
operator|->
name|z_err
operator|==
name|Z_STREAM_END
condition|?
name|Z_OK
else|:
name|s
operator|->
name|z_err
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================    Outputs a long in LSB order to the given file */
end_comment

begin_function
name|local
name|void
name|putU32
parameter_list|(
name|s
parameter_list|,
name|x
parameter_list|)
name|gz_stream
modifier|*
name|s
decl_stmt|;
name|uint32_t
name|x
decl_stmt|;
block|{
name|uint32_t
name|xx
decl_stmt|;
name|off_t
name|curoff
init|=
name|s
operator|->
name|outoff
decl_stmt|;
name|ssize_t
name|resid
decl_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|xx
operator|=
name|bswap32
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|#
directive|else
name|xx
operator|=
name|x
expr_stmt|;
endif|#
directive|endif
name|vn_rdwr
argument_list|(
name|UIO_WRITE
argument_list|,
name|s
operator|->
name|file
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|xx
argument_list|,
sizeof|sizeof
argument_list|(
name|xx
argument_list|)
argument_list|,
name|curoff
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_UNIT
argument_list|,
name|curproc
operator|->
name|p_ucred
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|resid
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|s
operator|->
name|outoff
operator|+=
sizeof|sizeof
argument_list|(
name|xx
argument_list|)
operator|-
name|resid
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ===========================================================================      Flushes all pending output if necessary, closes the compressed file    and deallocates all the (de)compression state. */
end_comment

begin_function
name|int
name|ZEXPORT
name|gzclose
parameter_list|(
name|file
parameter_list|)
name|gzFile
name|file
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
name|gz_stream
modifier|*
name|s
init|=
operator|(
name|gz_stream
operator|*
operator|)
name|file
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
if|if
condition|(
name|s
operator|->
name|mode
operator|==
literal|'w'
condition|)
block|{
name|err
operator|=
name|do_flush
argument_list|(
name|file
argument_list|,
name|Z_FINISH
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|Z_OK
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gzclose: do_flush failed (err %d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|destroy
argument_list|(
operator|(
name|gz_stream
operator|*
operator|)
name|file
argument_list|)
return|;
block|}
if|#
directive|if
literal|0
block|printf("gzclose: putting crc: %lld total: %lld\n", 	    (long long)s->crc, (long long)s->stream.total_in); 	printf("sizeof uLong = %d\n", (int)sizeof(uLong));
endif|#
directive|endif
name|putU32
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|crc
argument_list|)
expr_stmt|;
name|putU32
argument_list|(
name|s
argument_list|,
operator|(
name|uint32_t
operator|)
name|s
operator|->
name|stream
operator|.
name|total_in
argument_list|)
expr_stmt|;
block|}
return|return
name|destroy
argument_list|(
operator|(
name|gz_stream
operator|*
operator|)
name|file
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Space allocation and freeing routines for use by zlib routines when called  * from gzip modules.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|gz_alloc
parameter_list|(
name|void
modifier|*
name|notused
name|__unused
parameter_list|,
name|u_int
name|items
parameter_list|,
name|u_int
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|MALLOC
argument_list|(
name|ptr
argument_list|,
name|void
operator|*
argument_list|,
name|items
operator|*
name|size
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gz_free
parameter_list|(
name|void
modifier|*
name|opaque
name|__unused
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|FREE
argument_list|(
name|ptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

