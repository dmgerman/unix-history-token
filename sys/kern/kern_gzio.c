begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2014 Mark Johnston<markj@FreeBSD.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/gzio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/zutil.h>
end_include

begin_define
define|#
directive|define
name|KERN_GZ_HDRLEN
value|10
end_define

begin_comment
comment|/* gzip header length */
end_comment

begin_define
define|#
directive|define
name|KERN_GZ_TRAILERLEN
value|8
end_define

begin_comment
comment|/* gzip trailer length */
end_comment

begin_define
define|#
directive|define
name|KERN_GZ_MAGIC1
value|0x1f
end_define

begin_comment
comment|/* first magic byte */
end_comment

begin_define
define|#
directive|define
name|KERN_GZ_MAGIC2
value|0x8b
end_define

begin_comment
comment|/* second magic byte */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_GZIO
argument_list|,
literal|"gzio"
argument_list|,
literal|"zlib state"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|gzio_stream
block|{
name|uint8_t
modifier|*
name|gz_buffer
decl_stmt|;
comment|/* output buffer */
name|size_t
name|gz_bufsz
decl_stmt|;
comment|/* total buffer size */
name|off_t
name|gz_off
decl_stmt|;
comment|/* offset into the output stream */
name|enum
name|gzio_mode
name|gz_mode
decl_stmt|;
comment|/* stream mode */
name|uint32_t
name|gz_crc
decl_stmt|;
comment|/* stream CRC32 */
name|gzio_cb
name|gz_cb
decl_stmt|;
comment|/* output callback */
name|void
modifier|*
name|gz_arg
decl_stmt|;
comment|/* private callback arg */
name|z_stream
name|gz_stream
decl_stmt|;
comment|/* zlib state */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
modifier|*
name|gz_alloc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gz_free
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gz_write
parameter_list|(
name|struct
name|gzio_stream
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|struct
name|gzio_stream
modifier|*
name|gzio_init
parameter_list|(
name|gzio_cb
name|cb
parameter_list|,
name|enum
name|gzio_mode
name|mode
parameter_list|,
name|size_t
name|bufsz
parameter_list|,
name|int
name|level
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|gzio_stream
modifier|*
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|bufsz
operator|<
name|KERN_GZ_HDRLEN
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|mode
operator|!=
name|GZIO_DEFLATE
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|s
operator|=
name|gz_alloc
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|gz_bufsz
operator|=
name|bufsz
expr_stmt|;
name|s
operator|->
name|gz_buffer
operator|=
name|gz_alloc
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|,
name|s
operator|->
name|gz_bufsz
argument_list|)
expr_stmt|;
name|s
operator|->
name|gz_mode
operator|=
name|mode
expr_stmt|;
name|s
operator|->
name|gz_cb
operator|=
name|cb
expr_stmt|;
name|s
operator|->
name|gz_arg
operator|=
name|arg
expr_stmt|;
name|s
operator|->
name|gz_stream
operator|.
name|zalloc
operator|=
name|gz_alloc
expr_stmt|;
name|s
operator|->
name|gz_stream
operator|.
name|zfree
operator|=
name|gz_free
expr_stmt|;
name|s
operator|->
name|gz_stream
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|gz_stream
operator|.
name|next_in
operator|=
name|Z_NULL
expr_stmt|;
name|s
operator|->
name|gz_stream
operator|.
name|avail_in
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|deflateInit2
argument_list|(
operator|&
name|s
operator|->
name|gz_stream
argument_list|,
name|level
argument_list|,
name|Z_DEFLATED
argument_list|,
operator|-
name|MAX_WBITS
argument_list|,
name|DEF_MEM_LEVEL
argument_list|,
name|Z_DEFAULT_STRATEGY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|gzio_reset
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
name|fail
label|:
name|gz_free
argument_list|(
name|NULL
argument_list|,
name|s
operator|->
name|gz_buffer
argument_list|)
expr_stmt|;
name|gz_free
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gzio_reset
parameter_list|(
name|struct
name|gzio_stream
modifier|*
name|s
parameter_list|)
block|{
name|uint8_t
modifier|*
name|hdr
decl_stmt|;
operator|(
name|void
operator|)
name|deflateReset
argument_list|(
operator|&
name|s
operator|->
name|gz_stream
argument_list|)
expr_stmt|;
name|s
operator|->
name|gz_off
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|gz_crc
operator|=
operator|~
literal|0U
expr_stmt|;
name|s
operator|->
name|gz_stream
operator|.
name|avail_out
operator|=
name|s
operator|->
name|gz_bufsz
expr_stmt|;
name|s
operator|->
name|gz_stream
operator|.
name|next_out
operator|=
name|s
operator|->
name|gz_buffer
expr_stmt|;
comment|/* Write the gzip header to the output buffer. */
name|hdr
operator|=
name|s
operator|->
name|gz_buffer
expr_stmt|;
name|memset
argument_list|(
name|hdr
argument_list|,
literal|0
argument_list|,
name|KERN_GZ_HDRLEN
argument_list|)
expr_stmt|;
name|hdr
index|[
literal|0
index|]
operator|=
name|KERN_GZ_MAGIC1
expr_stmt|;
name|hdr
index|[
literal|1
index|]
operator|=
name|KERN_GZ_MAGIC2
expr_stmt|;
name|hdr
index|[
literal|2
index|]
operator|=
name|Z_DEFLATED
expr_stmt|;
name|hdr
index|[
literal|9
index|]
operator|=
name|OS_CODE
expr_stmt|;
name|s
operator|->
name|gz_stream
operator|.
name|next_out
operator|+=
name|KERN_GZ_HDRLEN
expr_stmt|;
name|s
operator|->
name|gz_stream
operator|.
name|avail_out
operator|-=
name|KERN_GZ_HDRLEN
expr_stmt|;
block|}
end_function

begin_function
name|int
name|gzio_write
parameter_list|(
name|struct
name|gzio_stream
modifier|*
name|s
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
return|return
operator|(
name|gz_write
argument_list|(
name|s
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|Z_NO_FLUSH
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gzio_flush
parameter_list|(
name|struct
name|gzio_stream
modifier|*
name|s
parameter_list|)
block|{
return|return
operator|(
name|gz_write
argument_list|(
name|s
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|Z_FINISH
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gzio_fini
parameter_list|(
name|struct
name|gzio_stream
modifier|*
name|s
parameter_list|)
block|{
operator|(
name|void
operator|)
name|deflateEnd
argument_list|(
operator|&
name|s
operator|->
name|gz_stream
argument_list|)
expr_stmt|;
name|gz_free
argument_list|(
name|NULL
argument_list|,
name|s
operator|->
name|gz_buffer
argument_list|)
expr_stmt|;
name|gz_free
argument_list|(
name|NULL
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|gz_alloc
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|u_int
name|n
parameter_list|,
name|u_int
name|sz
parameter_list|)
block|{
comment|/* 	 * Memory for zlib state is allocated using M_NODUMP since it may be 	 * used to compress a kernel dump, and we don't want zlib to attempt to 	 * compress its own state. 	 */
return|return
operator|(
name|malloc
argument_list|(
name|n
operator|*
name|sz
argument_list|,
name|M_GZIO
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
operator||
name|M_NODUMP
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gz_free
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|free
argument_list|(
name|ptr
argument_list|,
name|M_GZIO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gz_write
parameter_list|(
name|struct
name|gzio_stream
modifier|*
name|s
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|,
name|int
name|zflag
parameter_list|)
block|{
name|uint8_t
name|trailer
index|[
name|KERN_GZ_TRAILERLEN
index|]
decl_stmt|;
name|size_t
name|room
decl_stmt|;
name|int
name|error
decl_stmt|,
name|zerror
decl_stmt|;
name|KASSERT
argument_list|(
name|zflag
operator|==
name|Z_FINISH
operator|||
name|zflag
operator|==
name|Z_NO_FLUSH
argument_list|,
operator|(
literal|"unexpected flag %d"
operator|,
name|zflag
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|s
operator|->
name|gz_mode
operator|==
name|GZIO_DEFLATE
argument_list|,
operator|(
literal|"invalid stream mode %d"
operator|,
name|s
operator|->
name|gz_mode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|s
operator|->
name|gz_stream
operator|.
name|avail_in
operator|=
name|len
expr_stmt|;
name|s
operator|->
name|gz_stream
operator|.
name|next_in
operator|=
name|buf
expr_stmt|;
name|s
operator|->
name|gz_crc
operator|=
name|crc32_raw
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|s
operator|->
name|gz_crc
argument_list|)
expr_stmt|;
block|}
else|else
name|s
operator|->
name|gz_crc
operator|^=
operator|~
literal|0U
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|zerror
operator|=
name|deflate
argument_list|(
operator|&
name|s
operator|->
name|gz_stream
argument_list|,
name|zflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|zerror
operator|!=
name|Z_OK
operator|&&
name|zerror
operator|!=
name|Z_STREAM_END
condition|)
block|{
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|s
operator|->
name|gz_stream
operator|.
name|avail_out
operator|==
literal|0
operator|||
name|zerror
operator|==
name|Z_STREAM_END
condition|)
block|{
comment|/* 			 * Our output buffer is full or there's nothing left 			 * to produce, so we're flushing the buffer. 			 */
name|len
operator|=
name|s
operator|->
name|gz_bufsz
operator|-
name|s
operator|->
name|gz_stream
operator|.
name|avail_out
expr_stmt|;
if|if
condition|(
name|zerror
operator|==
name|Z_STREAM_END
condition|)
block|{
comment|/* 				 * Try to pack as much of the trailer into the 				 * output buffer as we can. 				 */
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|trailer
operator|)
index|[
literal|0
index|]
operator|=
name|s
operator|->
name|gz_crc
expr_stmt|;
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|trailer
operator|)
index|[
literal|1
index|]
operator|=
name|s
operator|->
name|gz_stream
operator|.
name|total_in
expr_stmt|;
name|room
operator|=
name|MIN
argument_list|(
name|KERN_GZ_TRAILERLEN
argument_list|,
name|s
operator|->
name|gz_bufsz
operator|-
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s
operator|->
name|gz_buffer
operator|+
name|len
argument_list|,
name|trailer
argument_list|,
name|room
argument_list|)
expr_stmt|;
name|len
operator|+=
name|room
expr_stmt|;
block|}
name|error
operator|=
name|s
operator|->
name|gz_cb
argument_list|(
name|s
operator|->
name|gz_buffer
argument_list|,
name|len
argument_list|,
name|s
operator|->
name|gz_off
argument_list|,
name|s
operator|->
name|gz_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|s
operator|->
name|gz_off
operator|+=
name|len
expr_stmt|;
name|s
operator|->
name|gz_stream
operator|.
name|next_out
operator|=
name|s
operator|->
name|gz_buffer
expr_stmt|;
name|s
operator|->
name|gz_stream
operator|.
name|avail_out
operator|=
name|s
operator|->
name|gz_bufsz
expr_stmt|;
comment|/* 			 * If we couldn't pack the trailer into the output 			 * buffer, write it out now. 			 */
if|if
condition|(
name|zerror
operator|==
name|Z_STREAM_END
operator|&&
name|room
operator|<
name|KERN_GZ_TRAILERLEN
condition|)
name|error
operator|=
name|s
operator|->
name|gz_cb
argument_list|(
name|trailer
operator|+
name|room
argument_list|,
name|KERN_GZ_TRAILERLEN
operator|-
name|room
argument_list|,
name|s
operator|->
name|gz_off
argument_list|,
name|s
operator|->
name|gz_arg
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|zerror
operator|!=
name|Z_STREAM_END
operator|&&
operator|(
name|zflag
operator|==
name|Z_FINISH
operator|||
name|s
operator|->
name|gz_stream
operator|.
name|avail_in
operator|>
literal|0
operator|)
condition|)
do|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

