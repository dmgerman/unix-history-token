begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Edward Tomasz NapieraÅa<trasz@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * ACL support routines specific to NFSv4 access control lists.  These are  * utility routines for code common across file systems implementing NFSv4  * ACLs.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/acl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<sys/acl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_define
define|#
directive|define
name|KASSERT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|assert(a)
end_define

begin_define
define|#
directive|define
name|CTASSERT
parameter_list|(
name|a
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|_acl_entry_matches
parameter_list|(
name|struct
name|acl_entry
modifier|*
name|entry
parameter_list|,
name|acl_tag_t
name|tag
parameter_list|,
name|acl_perm_t
name|perm
parameter_list|,
name|acl_entry_type_t
name|entry_type
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|ae_tag
operator|!=
name|tag
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|entry
operator|->
name|ae_id
operator|!=
name|ACL_UNDEFINED_ID
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|entry
operator|->
name|ae_perm
operator|!=
name|perm
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|!=
name|entry_type
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|entry
operator|->
name|ae_flags
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|acl_entry
modifier|*
name|_acl_append
parameter_list|(
name|struct
name|acl
modifier|*
name|aclp
parameter_list|,
name|acl_tag_t
name|tag
parameter_list|,
name|acl_perm_t
name|perm
parameter_list|,
name|acl_entry_type_t
name|entry_type
parameter_list|)
block|{
name|struct
name|acl_entry
modifier|*
name|entry
decl_stmt|;
name|KASSERT
argument_list|(
name|aclp
operator|->
name|acl_cnt
operator|+
literal|1
operator|<=
name|ACL_MAX_ENTRIES
argument_list|,
operator|(
literal|"aclp->acl_cnt + 1<= ACL_MAX_ENTRIES"
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|aclp
operator|->
name|acl_cnt
index|]
operator|)
expr_stmt|;
name|aclp
operator|->
name|acl_cnt
operator|++
expr_stmt|;
name|entry
operator|->
name|ae_tag
operator|=
name|tag
expr_stmt|;
name|entry
operator|->
name|ae_id
operator|=
name|ACL_UNDEFINED_ID
expr_stmt|;
name|entry
operator|->
name|ae_perm
operator|=
name|perm
expr_stmt|;
name|entry
operator|->
name|ae_entry_type
operator|=
name|entry_type
expr_stmt|;
name|entry
operator|->
name|ae_flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|entry
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|acl_entry
modifier|*
name|_acl_duplicate_entry
parameter_list|(
name|struct
name|acl
modifier|*
name|aclp
parameter_list|,
name|int
name|entry_index
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|aclp
operator|->
name|acl_cnt
operator|+
literal|1
operator|<=
name|ACL_MAX_ENTRIES
argument_list|,
operator|(
literal|"aclp->acl_cnt + 1<= ACL_MAX_ENTRIES"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|aclp
operator|->
name|acl_cnt
init|;
name|i
operator|>
name|entry_index
condition|;
name|i
operator|--
control|)
name|aclp
operator|->
name|acl_entry
index|[
name|i
index|]
operator|=
name|aclp
operator|->
name|acl_entry
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|aclp
operator|->
name|acl_cnt
operator|++
expr_stmt|;
return|return
operator|(
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|entry_index
operator|+
literal|1
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|acl_nfs4_sync_acl_from_mode
parameter_list|(
name|struct
name|acl
modifier|*
name|aclp
parameter_list|,
name|mode_t
name|mode
parameter_list|,
name|int
name|file_owner_id
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|meets
decl_stmt|,
name|must_append
decl_stmt|;
name|struct
name|acl_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|copy
decl_stmt|,
modifier|*
name|previous
decl_stmt|,
modifier|*
name|a1
decl_stmt|,
modifier|*
name|a2
decl_stmt|,
modifier|*
name|a3
decl_stmt|,
modifier|*
name|a4
decl_stmt|,
modifier|*
name|a5
decl_stmt|,
modifier|*
name|a6
decl_stmt|;
name|mode_t
name|amode
decl_stmt|;
specifier|const
name|int
name|READ
init|=
literal|04
decl_stmt|;
specifier|const
name|int
name|WRITE
init|=
literal|02
decl_stmt|;
specifier|const
name|int
name|EXEC
init|=
literal|01
decl_stmt|;
name|KASSERT
argument_list|(
name|aclp
operator|->
name|acl_cnt
operator|>=
literal|0
argument_list|,
operator|(
literal|"aclp->acl_cnt>= 0"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|aclp
operator|->
name|acl_cnt
operator|<=
name|ACL_MAX_ENTRIES
argument_list|,
operator|(
literal|"aclp->acl_cnt<= ACL_MAX_ENTRIES"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * NFSv4 Minor Version 1, draft-ietf-nfsv4-minorversion1-03.txt 	 * 	 * 3.16.6.3. Applying a Mode to an Existing ACL 	 */
comment|/* 	 * 1. For each ACE: 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|aclp
operator|->
name|acl_cnt
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|i
index|]
operator|)
expr_stmt|;
comment|/* 		 * 1.1. If the type is neither ALLOW or DENY - skip. 		 */
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|!=
name|ACL_ENTRY_TYPE_ALLOW
operator|&&
name|entry
operator|->
name|ae_entry_type
operator|!=
name|ACL_ENTRY_TYPE_DENY
condition|)
continue|continue;
comment|/* 		 * 1.2. If ACL_ENTRY_INHERIT_ONLY is set - skip. 		 */
if|if
condition|(
name|entry
operator|->
name|ae_flags
operator|&
name|ACL_ENTRY_INHERIT_ONLY
condition|)
continue|continue;
comment|/* 		 * 1.3. If ACL_ENTRY_FILE_INHERIT or ACL_ENTRY_DIRECTORY_INHERIT 		 *      are set: 		 */
if|if
condition|(
name|entry
operator|->
name|ae_flags
operator|&
operator|(
name|ACL_ENTRY_FILE_INHERIT
operator||
name|ACL_ENTRY_DIRECTORY_INHERIT
operator|)
condition|)
block|{
comment|/* 			 * 1.3.1. A copy of the current ACE is made, and placed 			 *        in the ACL immediately following the current 			 *        ACE. 			 */
name|copy
operator|=
name|_acl_duplicate_entry
argument_list|(
name|aclp
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 			 * 1.3.2. In the first ACE, the flag 			 *        ACL_ENTRY_INHERIT_ONLY is set. 			 */
name|entry
operator|->
name|ae_flags
operator||=
name|ACL_ENTRY_INHERIT_ONLY
expr_stmt|;
comment|/* 			 * 1.3.3. In the second ACE, the following flags 			 *        are cleared: 			 *        ACL_ENTRY_FILE_INHERIT, 			 *        ACL_ENTRY_DIRECTORY_INHERIT, 			 *        ACL_ENTRY_NO_PROPAGATE_INHERIT. 			 */
name|copy
operator|->
name|ae_flags
operator|&=
operator|~
operator|(
name|ACL_ENTRY_FILE_INHERIT
operator||
name|ACL_ENTRY_DIRECTORY_INHERIT
operator||
name|ACL_ENTRY_NO_PROPAGATE_INHERIT
operator|)
expr_stmt|;
comment|/* 			 * The algorithm continues on with the second ACE. 			 */
name|i
operator|++
expr_stmt|;
name|entry
operator|=
name|copy
expr_stmt|;
block|}
comment|/* 		 * 1.4. If it's owner@, group@ or everyone@ entry, clear 		 *      ACL_READ_DATA, ACL_WRITE_DATA, ACL_APPEND_DATA 		 *      and ACL_EXECUTE.  Continue to the next entry. 		 */
if|if
condition|(
name|entry
operator|->
name|ae_tag
operator|==
name|ACL_USER_OBJ
operator|||
name|entry
operator|->
name|ae_tag
operator|==
name|ACL_GROUP_OBJ
operator|||
name|entry
operator|->
name|ae_tag
operator|==
name|ACL_EVERYONE
condition|)
block|{
name|entry
operator|->
name|ae_perm
operator|&=
operator|~
operator|(
name|ACL_READ_DATA
operator||
name|ACL_WRITE_DATA
operator||
name|ACL_APPEND_DATA
operator||
name|ACL_EXECUTE
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * 1.5. Otherwise, if the "who" field did not match one 		 *      of OWNER@, GROUP@, EVERYONE@: 		 * 		 * 1.5.1. If the type is ALLOW, check the preceding ACE. 		 *        If it does not meet all of the following criteria: 		 */
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|!=
name|ACL_ENTRY_TYPE_ALLOW
condition|)
continue|continue;
name|meets
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|meets
operator|=
literal|1
expr_stmt|;
name|previous
operator|=
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|i
operator|-
literal|1
index|]
operator|)
expr_stmt|;
comment|/* 			 * 1.5.1.1. The type field is DENY, 			 */
if|if
condition|(
name|previous
operator|->
name|ae_entry_type
operator|!=
name|ACL_ENTRY_TYPE_DENY
condition|)
name|meets
operator|=
literal|0
expr_stmt|;
comment|/* 			 * 1.5.1.2. The "who" field is the same as the current 			 *          ACE, 			 * 			 * 1.5.1.3. The flag bit ACE4_IDENTIFIER_GROUP 			 *          is the same as it is in the current ACE, 			 *          and no other flag bits are set, 			 */
if|if
condition|(
name|previous
operator|->
name|ae_id
operator|!=
name|entry
operator|->
name|ae_id
operator|||
name|previous
operator|->
name|ae_tag
operator|!=
name|entry
operator|->
name|ae_tag
condition|)
name|meets
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|previous
operator|->
name|ae_flags
condition|)
name|meets
operator|=
literal|0
expr_stmt|;
comment|/* 			 * 1.5.1.4. The mask bits are a subset of the mask bits 			 *          of the current ACE, and are also subset of 			 *          the following: ACL_READ_DATA, 			 *          ACL_WRITE_DATA, ACL_APPEND_DATA, ACL_EXECUTE 			 */
if|if
condition|(
name|previous
operator|->
name|ae_perm
operator|&
operator|~
operator|(
name|entry
operator|->
name|ae_perm
operator|)
condition|)
name|meets
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|previous
operator|->
name|ae_perm
operator|&
operator|~
operator|(
name|ACL_READ_DATA
operator||
name|ACL_WRITE_DATA
operator||
name|ACL_APPEND_DATA
operator||
name|ACL_EXECUTE
operator|)
condition|)
name|meets
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|meets
condition|)
block|{
comment|/* 		 	 * Then the ACE of type DENY, with a who equal 			 * to the current ACE, flag bits equal to 			 * (<current ACE flags>&<ACE_IDENTIFIER_GROUP>) 			 * and no mask bits, is prepended. 			 */
name|previous
operator|=
name|entry
expr_stmt|;
name|entry
operator|=
name|_acl_duplicate_entry
argument_list|(
name|aclp
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Adjust counter, as we've just added an entry. */
name|i
operator|++
expr_stmt|;
name|previous
operator|->
name|ae_tag
operator|=
name|entry
operator|->
name|ae_tag
expr_stmt|;
name|previous
operator|->
name|ae_id
operator|=
name|entry
operator|->
name|ae_id
expr_stmt|;
name|previous
operator|->
name|ae_flags
operator|=
name|entry
operator|->
name|ae_flags
expr_stmt|;
name|previous
operator|->
name|ae_perm
operator|=
literal|0
expr_stmt|;
name|previous
operator|->
name|ae_entry_type
operator|=
name|ACL_ENTRY_TYPE_DENY
expr_stmt|;
block|}
comment|/* 		 * 1.5.2. The following modifications are made to the prepended 		 *        ACE.  The intent is to mask the following ACE 		 *        to disallow ACL_READ_DATA, ACL_WRITE_DATA, 		 *        ACL_APPEND_DATA, or ACL_EXECUTE, based upon the group 		 *        permissions of the new mode.  As a special case, 		 *        if the ACE matches the current owner of the file, 		 *        the owner bits are used, rather than the group bits. 		 *        This is reflected in the algorithm below. 		 */
name|amode
operator|=
name|mode
operator|>>
literal|3
expr_stmt|;
comment|/* 		 * If ACE4_IDENTIFIER_GROUP is not set, and the "who" field 		 * in ACE matches the owner of the file, we shift amode three 		 * more bits, in order to have the owner permission bits 		 * placed in the three low order bits of amode. 		 */
if|if
condition|(
name|entry
operator|->
name|ae_tag
operator|==
name|ACL_USER
operator|&&
name|entry
operator|->
name|ae_id
operator|==
name|file_owner_id
condition|)
name|amode
operator|=
name|amode
operator|>>
literal|3
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_READ_DATA
condition|)
block|{
if|if
condition|(
name|amode
operator|&
name|READ
condition|)
name|previous
operator|->
name|ae_perm
operator|&=
operator|~
name|ACL_READ_DATA
expr_stmt|;
else|else
name|previous
operator|->
name|ae_perm
operator||=
name|ACL_READ_DATA
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_WRITE_DATA
condition|)
block|{
if|if
condition|(
name|amode
operator|&
name|WRITE
condition|)
name|previous
operator|->
name|ae_perm
operator|&=
operator|~
name|ACL_WRITE_DATA
expr_stmt|;
else|else
name|previous
operator|->
name|ae_perm
operator||=
name|ACL_WRITE_DATA
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_APPEND_DATA
condition|)
block|{
if|if
condition|(
name|amode
operator|&
name|WRITE
condition|)
name|previous
operator|->
name|ae_perm
operator|&=
operator|~
name|ACL_APPEND_DATA
expr_stmt|;
else|else
name|previous
operator|->
name|ae_perm
operator||=
name|ACL_APPEND_DATA
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
block|{
if|if
condition|(
name|amode
operator|&
name|EXEC
condition|)
name|previous
operator|->
name|ae_perm
operator|&=
operator|~
name|ACL_EXECUTE
expr_stmt|;
else|else
name|previous
operator|->
name|ae_perm
operator||=
name|ACL_EXECUTE
expr_stmt|;
block|}
comment|/* 		 * 1.5.3. If ACE4_IDENTIFIER_GROUP is set in the flags 		 *        of the ALLOW ace: 		 * 		 * XXX: This point is not there in the Falkner's draft. 		 */
if|if
condition|(
name|entry
operator|->
name|ae_tag
operator|==
name|ACL_GROUP
operator|&&
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
block|{
name|mode_t
name|extramode
decl_stmt|,
name|ownermode
decl_stmt|;
name|extramode
operator|=
operator|(
name|mode
operator|>>
literal|3
operator|)
operator|&
literal|07
expr_stmt|;
name|ownermode
operator|=
name|mode
operator|>>
literal|6
expr_stmt|;
name|extramode
operator|&=
operator|~
name|ownermode
expr_stmt|;
if|if
condition|(
name|extramode
condition|)
block|{
if|if
condition|(
name|extramode
operator|&
name|READ
condition|)
block|{
name|entry
operator|->
name|ae_perm
operator|&=
operator|~
name|ACL_READ_DATA
expr_stmt|;
name|previous
operator|->
name|ae_perm
operator|&=
operator|~
name|ACL_READ_DATA
expr_stmt|;
block|}
if|if
condition|(
name|extramode
operator|&
name|WRITE
condition|)
block|{
name|entry
operator|->
name|ae_perm
operator|&=
operator|~
operator|(
name|ACL_WRITE_DATA
operator||
name|ACL_APPEND_DATA
operator|)
expr_stmt|;
name|previous
operator|->
name|ae_perm
operator|&=
operator|~
operator|(
name|ACL_WRITE_DATA
operator||
name|ACL_APPEND_DATA
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|extramode
operator|&
name|EXEC
condition|)
block|{
name|entry
operator|->
name|ae_perm
operator|&=
operator|~
name|ACL_EXECUTE
expr_stmt|;
name|previous
operator|->
name|ae_perm
operator|&=
operator|~
name|ACL_EXECUTE
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * 2. If there at least six ACEs, the final six ACEs are examined. 	 *    If they are not equal to what we want, append six ACEs. 	 */
name|must_append
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aclp
operator|->
name|acl_cnt
operator|<
literal|6
condition|)
block|{
name|must_append
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|a6
operator|=
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|aclp
operator|->
name|acl_cnt
operator|-
literal|1
index|]
operator|)
expr_stmt|;
name|a5
operator|=
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|aclp
operator|->
name|acl_cnt
operator|-
literal|2
index|]
operator|)
expr_stmt|;
name|a4
operator|=
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|aclp
operator|->
name|acl_cnt
operator|-
literal|3
index|]
operator|)
expr_stmt|;
name|a3
operator|=
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|aclp
operator|->
name|acl_cnt
operator|-
literal|4
index|]
operator|)
expr_stmt|;
name|a2
operator|=
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|aclp
operator|->
name|acl_cnt
operator|-
literal|5
index|]
operator|)
expr_stmt|;
name|a1
operator|=
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|aclp
operator|->
name|acl_cnt
operator|-
literal|6
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|_acl_entry_matches
argument_list|(
name|a1
argument_list|,
name|ACL_USER_OBJ
argument_list|,
literal|0
argument_list|,
name|ACL_ENTRY_TYPE_DENY
argument_list|)
condition|)
name|must_append
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|_acl_entry_matches
argument_list|(
name|a2
argument_list|,
name|ACL_USER_OBJ
argument_list|,
name|ACL_WRITE_ACL
operator||
name|ACL_WRITE_OWNER
operator||
name|ACL_WRITE_ATTRIBUTES
operator||
name|ACL_WRITE_NAMED_ATTRS
argument_list|,
name|ACL_ENTRY_TYPE_ALLOW
argument_list|)
condition|)
name|must_append
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|_acl_entry_matches
argument_list|(
name|a3
argument_list|,
name|ACL_GROUP_OBJ
argument_list|,
literal|0
argument_list|,
name|ACL_ENTRY_TYPE_DENY
argument_list|)
condition|)
name|must_append
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|_acl_entry_matches
argument_list|(
name|a4
argument_list|,
name|ACL_GROUP_OBJ
argument_list|,
literal|0
argument_list|,
name|ACL_ENTRY_TYPE_ALLOW
argument_list|)
condition|)
name|must_append
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|_acl_entry_matches
argument_list|(
name|a5
argument_list|,
name|ACL_EVERYONE
argument_list|,
name|ACL_WRITE_ACL
operator||
name|ACL_WRITE_OWNER
operator||
name|ACL_WRITE_ATTRIBUTES
operator||
name|ACL_WRITE_NAMED_ATTRS
argument_list|,
name|ACL_ENTRY_TYPE_DENY
argument_list|)
condition|)
name|must_append
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|_acl_entry_matches
argument_list|(
name|a6
argument_list|,
name|ACL_EVERYONE
argument_list|,
name|ACL_READ_ACL
operator||
name|ACL_READ_ATTRIBUTES
operator||
name|ACL_READ_NAMED_ATTRS
operator||
name|ACL_SYNCHRONIZE
argument_list|,
name|ACL_ENTRY_TYPE_ALLOW
argument_list|)
condition|)
name|must_append
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|must_append
condition|)
block|{
name|KASSERT
argument_list|(
name|aclp
operator|->
name|acl_cnt
operator|+
literal|6
operator|<=
name|ACL_MAX_ENTRIES
argument_list|,
operator|(
literal|"aclp->acl_cnt<= ACL_MAX_ENTRIES"
operator|)
argument_list|)
expr_stmt|;
name|a1
operator|=
name|_acl_append
argument_list|(
name|aclp
argument_list|,
name|ACL_USER_OBJ
argument_list|,
literal|0
argument_list|,
name|ACL_ENTRY_TYPE_DENY
argument_list|)
expr_stmt|;
name|a2
operator|=
name|_acl_append
argument_list|(
name|aclp
argument_list|,
name|ACL_USER_OBJ
argument_list|,
name|ACL_WRITE_ACL
operator||
name|ACL_WRITE_OWNER
operator||
name|ACL_WRITE_ATTRIBUTES
operator||
name|ACL_WRITE_NAMED_ATTRS
argument_list|,
name|ACL_ENTRY_TYPE_ALLOW
argument_list|)
expr_stmt|;
name|a3
operator|=
name|_acl_append
argument_list|(
name|aclp
argument_list|,
name|ACL_GROUP_OBJ
argument_list|,
literal|0
argument_list|,
name|ACL_ENTRY_TYPE_DENY
argument_list|)
expr_stmt|;
name|a4
operator|=
name|_acl_append
argument_list|(
name|aclp
argument_list|,
name|ACL_GROUP_OBJ
argument_list|,
literal|0
argument_list|,
name|ACL_ENTRY_TYPE_ALLOW
argument_list|)
expr_stmt|;
name|a5
operator|=
name|_acl_append
argument_list|(
name|aclp
argument_list|,
name|ACL_EVERYONE
argument_list|,
name|ACL_WRITE_ACL
operator||
name|ACL_WRITE_OWNER
operator||
name|ACL_WRITE_ATTRIBUTES
operator||
name|ACL_WRITE_NAMED_ATTRS
argument_list|,
name|ACL_ENTRY_TYPE_DENY
argument_list|)
expr_stmt|;
name|a6
operator|=
name|_acl_append
argument_list|(
name|aclp
argument_list|,
name|ACL_EVERYONE
argument_list|,
name|ACL_READ_ACL
operator||
name|ACL_READ_ATTRIBUTES
operator||
name|ACL_READ_NAMED_ATTRS
operator||
name|ACL_SYNCHRONIZE
argument_list|,
name|ACL_ENTRY_TYPE_ALLOW
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|a1
operator|!=
name|NULL
operator|&&
name|a2
operator|!=
name|NULL
operator|&&
name|a3
operator|!=
name|NULL
operator|&&
name|a4
operator|!=
name|NULL
operator|&&
name|a5
operator|!=
name|NULL
operator|&&
name|a6
operator|!=
name|NULL
argument_list|,
operator|(
literal|"couldn't append to ACL."
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * 3. The final six ACEs are adjusted according to the incoming mode. 	 */
if|if
condition|(
name|mode
operator|&
name|S_IRUSR
condition|)
name|a2
operator|->
name|ae_perm
operator||=
name|ACL_READ_DATA
expr_stmt|;
else|else
name|a1
operator|->
name|ae_perm
operator||=
name|ACL_READ_DATA
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWUSR
condition|)
name|a2
operator|->
name|ae_perm
operator||=
operator|(
name|ACL_WRITE_DATA
operator||
name|ACL_APPEND_DATA
operator|)
expr_stmt|;
else|else
name|a1
operator|->
name|ae_perm
operator||=
operator|(
name|ACL_WRITE_DATA
operator||
name|ACL_APPEND_DATA
operator|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IXUSR
condition|)
name|a2
operator|->
name|ae_perm
operator||=
name|ACL_EXECUTE
expr_stmt|;
else|else
name|a1
operator|->
name|ae_perm
operator||=
name|ACL_EXECUTE
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IRGRP
condition|)
name|a4
operator|->
name|ae_perm
operator||=
name|ACL_READ_DATA
expr_stmt|;
else|else
name|a3
operator|->
name|ae_perm
operator||=
name|ACL_READ_DATA
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWGRP
condition|)
name|a4
operator|->
name|ae_perm
operator||=
operator|(
name|ACL_WRITE_DATA
operator||
name|ACL_APPEND_DATA
operator|)
expr_stmt|;
else|else
name|a3
operator|->
name|ae_perm
operator||=
operator|(
name|ACL_WRITE_DATA
operator||
name|ACL_APPEND_DATA
operator|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IXGRP
condition|)
name|a4
operator|->
name|ae_perm
operator||=
name|ACL_EXECUTE
expr_stmt|;
else|else
name|a3
operator|->
name|ae_perm
operator||=
name|ACL_EXECUTE
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IROTH
condition|)
name|a6
operator|->
name|ae_perm
operator||=
name|ACL_READ_DATA
expr_stmt|;
else|else
name|a5
operator|->
name|ae_perm
operator||=
name|ACL_READ_DATA
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWOTH
condition|)
name|a6
operator|->
name|ae_perm
operator||=
operator|(
name|ACL_WRITE_DATA
operator||
name|ACL_APPEND_DATA
operator|)
expr_stmt|;
else|else
name|a5
operator|->
name|ae_perm
operator||=
operator|(
name|ACL_WRITE_DATA
operator||
name|ACL_APPEND_DATA
operator|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IXOTH
condition|)
name|a6
operator|->
name|ae_perm
operator||=
name|ACL_EXECUTE
expr_stmt|;
else|else
name|a5
operator|->
name|ae_perm
operator||=
name|ACL_EXECUTE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|acl_nfs4_sync_mode_from_acl
parameter_list|(
name|mode_t
modifier|*
name|_mode
parameter_list|,
specifier|const
name|struct
name|acl
modifier|*
name|aclp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|mode_t
name|old_mode
init|=
operator|*
name|_mode
decl_stmt|,
name|mode
init|=
literal|0
decl_stmt|,
name|seen
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|acl_entry
modifier|*
name|entry
decl_stmt|;
name|KASSERT
argument_list|(
name|aclp
operator|->
name|acl_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"aclp->acl_cnt> 0"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|aclp
operator|->
name|acl_cnt
operator|<=
name|ACL_MAX_ENTRIES
argument_list|,
operator|(
literal|"aclp->acl_cnt<= ACL_MAX_ENTRIES"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * NFSv4 Minor Version 1, draft-ietf-nfsv4-minorversion1-03.txt 	 * 	 * 3.16.6.1. Recomputing mode upon SETATTR of ACL 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|aclp
operator|->
name|acl_cnt
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|!=
name|ACL_ENTRY_TYPE_ALLOW
operator|&&
name|entry
operator|->
name|ae_entry_type
operator|!=
name|ACL_ENTRY_TYPE_DENY
condition|)
continue|continue;
if|if
condition|(
name|entry
operator|->
name|ae_flags
operator|&
name|ACL_ENTRY_INHERIT_ONLY
condition|)
continue|continue;
if|if
condition|(
name|entry
operator|->
name|ae_tag
operator|==
name|ACL_USER_OBJ
condition|)
block|{
if|if
condition|(
operator|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_READ_DATA
operator|)
operator|&&
operator|(
operator|(
name|seen
operator|&
name|S_IRUSR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IRUSR
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IRUSR
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_WRITE_DATA
operator|)
operator|&&
operator|(
operator|(
name|seen
operator|&
name|S_IWUSR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IWUSR
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IWUSR
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_EXECUTE
operator|)
operator|&&
operator|(
operator|(
name|seen
operator|&
name|S_IXUSR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IXUSR
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IXUSR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|ae_tag
operator|==
name|ACL_GROUP_OBJ
condition|)
block|{
if|if
condition|(
operator|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_READ_DATA
operator|)
operator|&&
operator|(
operator|(
name|seen
operator|&
name|S_IRGRP
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IRGRP
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IRGRP
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_WRITE_DATA
operator|)
operator|&&
operator|(
operator|(
name|seen
operator|&
name|S_IWGRP
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IWGRP
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IWGRP
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_EXECUTE
operator|)
operator|&&
operator|(
operator|(
name|seen
operator|&
name|S_IXGRP
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IXGRP
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IXGRP
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|ae_tag
operator|==
name|ACL_EVERYONE
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_READ_DATA
condition|)
block|{
if|if
condition|(
operator|(
name|seen
operator|&
name|S_IRUSR
operator|)
operator|==
literal|0
condition|)
block|{
name|seen
operator||=
name|S_IRUSR
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IRUSR
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|seen
operator|&
name|S_IRGRP
operator|)
operator|==
literal|0
condition|)
block|{
name|seen
operator||=
name|S_IRGRP
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IRGRP
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|seen
operator|&
name|S_IROTH
operator|)
operator|==
literal|0
condition|)
block|{
name|seen
operator||=
name|S_IROTH
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IROTH
expr_stmt|;
block|}
block|}
if|if
condition|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_WRITE_DATA
condition|)
block|{
if|if
condition|(
operator|(
name|seen
operator|&
name|S_IWUSR
operator|)
operator|==
literal|0
condition|)
block|{
name|seen
operator||=
name|S_IWUSR
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IWUSR
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|seen
operator|&
name|S_IWGRP
operator|)
operator|==
literal|0
condition|)
block|{
name|seen
operator||=
name|S_IWGRP
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IWGRP
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|seen
operator|&
name|S_IWOTH
operator|)
operator|==
literal|0
condition|)
block|{
name|seen
operator||=
name|S_IWOTH
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IWOTH
expr_stmt|;
block|}
block|}
if|if
condition|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
block|{
if|if
condition|(
operator|(
name|seen
operator|&
name|S_IXUSR
operator|)
operator|==
literal|0
condition|)
block|{
name|seen
operator||=
name|S_IXUSR
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IXUSR
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|seen
operator|&
name|S_IXGRP
operator|)
operator|==
literal|0
condition|)
block|{
name|seen
operator||=
name|S_IXGRP
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IXGRP
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|seen
operator|&
name|S_IXOTH
operator|)
operator|==
literal|0
condition|)
block|{
name|seen
operator||=
name|S_IXOTH
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IXOTH
expr_stmt|;
block|}
block|}
block|}
block|}
operator|*
name|_mode
operator|=
name|mode
operator||
operator|(
name|old_mode
operator|&
name|ACL_PRESERVE_MASK
operator|)
expr_stmt|;
block|}
end_function

end_unit

