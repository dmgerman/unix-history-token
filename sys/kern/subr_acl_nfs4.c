begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008-2009 Edward Tomasz NapieraÅa<trasz@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * ACL support routines specific to NFSv4 access control lists.  These are  * utility routines for code common across file systems implementing NFSv4  * ACLs.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/acl.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<sys/acl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_define
define|#
directive|define
name|KASSERT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|assert(a)
end_define

begin_define
define|#
directive|define
name|CTASSERT
parameter_list|(
name|a
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_struct
specifier|static
struct|struct
block|{
name|accmode_t
name|accmode
decl_stmt|;
name|int
name|mask
decl_stmt|;
block|}
name|accmode2mask
index|[]
init|=
block|{
block|{
name|VREAD
block|,
name|ACL_READ_DATA
block|}
block|,
block|{
name|VWRITE
block|,
name|ACL_WRITE_DATA
block|}
block|,
block|{
name|VAPPEND
block|,
name|ACL_APPEND_DATA
block|}
block|,
block|{
name|VEXEC
block|,
name|ACL_EXECUTE
block|}
block|,
block|{
name|VREAD_NAMED_ATTRS
block|,
name|ACL_READ_NAMED_ATTRS
block|}
block|,
block|{
name|VWRITE_NAMED_ATTRS
block|,
name|ACL_WRITE_NAMED_ATTRS
block|}
block|,
block|{
name|VDELETE_CHILD
block|,
name|ACL_DELETE_CHILD
block|}
block|,
block|{
name|VREAD_ATTRIBUTES
block|,
name|ACL_READ_ATTRIBUTES
block|}
block|,
block|{
name|VWRITE_ATTRIBUTES
block|,
name|ACL_WRITE_ATTRIBUTES
block|}
block|,
block|{
name|VDELETE
block|,
name|ACL_DELETE
block|}
block|,
block|{
name|VREAD_ACL
block|,
name|ACL_READ_ACL
block|}
block|,
block|{
name|VWRITE_ACL
block|,
name|ACL_WRITE_ACL
block|}
block|,
block|{
name|VWRITE_OWNER
block|,
name|ACL_WRITE_OWNER
block|}
block|,
block|{
name|VSYNCHRONIZE
block|,
name|ACL_SYNCHRONIZE
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|_access_mask_from_accmode
parameter_list|(
name|accmode_t
name|accmode
parameter_list|)
block|{
name|int
name|access_mask
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|accmode2mask
index|[
name|i
index|]
operator|.
name|accmode
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|accmode
operator|&
name|accmode2mask
index|[
name|i
index|]
operator|.
name|accmode
condition|)
name|access_mask
operator||=
name|accmode2mask
index|[
name|i
index|]
operator|.
name|mask
expr_stmt|;
block|}
return|return
operator|(
name|access_mask
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return 0, iff access is allowed, 1 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|_acl_denies
parameter_list|(
specifier|const
name|struct
name|acl
modifier|*
name|aclp
parameter_list|,
name|int
name|access_mask
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|file_uid
parameter_list|,
name|int
name|file_gid
parameter_list|,
name|int
modifier|*
name|denied_explicitly
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|struct
name|acl_entry
modifier|*
name|entry
decl_stmt|;
if|if
condition|(
name|denied_explicitly
operator|!=
name|NULL
condition|)
operator|*
name|denied_explicitly
operator|=
literal|0
expr_stmt|;
name|KASSERT
argument_list|(
name|aclp
operator|->
name|acl_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"aclp->acl_cnt> 0"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|aclp
operator|->
name|acl_cnt
operator|<=
name|ACL_MAX_ENTRIES
argument_list|,
operator|(
literal|"aclp->acl_cnt<= ACL_MAX_ENTRIES"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|aclp
operator|->
name|acl_cnt
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|!=
name|ACL_ENTRY_TYPE_ALLOW
operator|&&
name|entry
operator|->
name|ae_entry_type
operator|!=
name|ACL_ENTRY_TYPE_DENY
condition|)
continue|continue;
if|if
condition|(
name|entry
operator|->
name|ae_flags
operator|&
name|ACL_ENTRY_INHERIT_ONLY
condition|)
continue|continue;
switch|switch
condition|(
name|entry
operator|->
name|ae_tag
condition|)
block|{
case|case
name|ACL_USER_OBJ
case|:
if|if
condition|(
name|file_uid
operator|!=
name|cred
operator|->
name|cr_uid
condition|)
continue|continue;
break|break;
case|case
name|ACL_USER
case|:
if|if
condition|(
name|entry
operator|->
name|ae_id
operator|!=
name|cred
operator|->
name|cr_uid
condition|)
continue|continue;
break|break;
case|case
name|ACL_GROUP_OBJ
case|:
if|if
condition|(
operator|!
name|groupmember
argument_list|(
name|file_gid
argument_list|,
name|cred
argument_list|)
condition|)
continue|continue;
break|break;
case|case
name|ACL_GROUP
case|:
if|if
condition|(
operator|!
name|groupmember
argument_list|(
name|entry
operator|->
name|ae_id
argument_list|,
name|cred
argument_list|)
condition|)
continue|continue;
break|break;
default|default:
name|KASSERT
argument_list|(
name|entry
operator|->
name|ae_tag
operator|==
name|ACL_EVERYONE
argument_list|,
operator|(
literal|"entry->ae_tag == ACL_EVERYONE"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_DENY
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|ae_perm
operator|&
name|access_mask
condition|)
block|{
if|if
condition|(
name|denied_explicitly
operator|!=
name|NULL
condition|)
operator|*
name|denied_explicitly
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|access_mask
operator|&=
operator|~
operator|(
name|entry
operator|->
name|ae_perm
operator|)
expr_stmt|;
if|if
condition|(
name|access_mask
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vaccess_acl_nfs4
parameter_list|(
name|enum
name|vtype
name|type
parameter_list|,
name|uid_t
name|file_uid
parameter_list|,
name|gid_t
name|file_gid
parameter_list|,
name|struct
name|acl
modifier|*
name|aclp
parameter_list|,
name|accmode_t
name|accmode
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
modifier|*
name|privused
parameter_list|)
block|{
name|accmode_t
name|priv_granted
init|=
literal|0
decl_stmt|;
name|int
name|denied
decl_stmt|,
name|explicitly_denied
decl_stmt|,
name|access_mask
decl_stmt|,
name|is_directory
decl_stmt|,
name|must_be_owner
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|accmode
operator|&
name|VADMIN
condition|)
name|must_be_owner
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Ignore VSYNCHRONIZE permission. 	 */
name|accmode
operator|&=
operator|~
name|VSYNCHRONIZE
expr_stmt|;
name|access_mask
operator|=
name|_access_mask_from_accmode
argument_list|(
name|accmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|VDIR
condition|)
name|is_directory
operator|=
literal|1
expr_stmt|;
else|else
name|is_directory
operator|=
literal|0
expr_stmt|;
comment|/* 	 * File owner is always allowed to read and write the ACL 	 * and basic attributes.  This is to prevent a situation 	 * where user would change ACL in a way that prevents him 	 * from undoing the change. 	 */
if|if
condition|(
name|file_uid
operator|==
name|cred
operator|->
name|cr_uid
condition|)
name|access_mask
operator|&=
operator|~
operator|(
name|ACL_READ_ACL
operator||
name|ACL_WRITE_ACL
operator||
name|ACL_READ_ATTRIBUTES
operator||
name|ACL_WRITE_ATTRIBUTES
operator|)
expr_stmt|;
comment|/* 	 * Ignore append permission for regular files; use write 	 * permission instead. 	 */
if|if
condition|(
operator|!
name|is_directory
operator|&&
operator|(
name|access_mask
operator|&
name|ACL_APPEND_DATA
operator|)
condition|)
block|{
name|access_mask
operator|&=
operator|~
name|ACL_APPEND_DATA
expr_stmt|;
name|access_mask
operator||=
name|ACL_WRITE_DATA
expr_stmt|;
block|}
name|denied
operator|=
name|_acl_denies
argument_list|(
name|aclp
argument_list|,
name|access_mask
argument_list|,
name|cred
argument_list|,
name|file_uid
argument_list|,
name|file_gid
argument_list|,
operator|&
name|explicitly_denied
argument_list|)
expr_stmt|;
if|if
condition|(
name|must_be_owner
condition|)
block|{
if|if
condition|(
name|file_uid
operator|!=
name|cred
operator|->
name|cr_uid
condition|)
name|denied
operator|=
name|EPERM
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|denied
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Access failed.  Iff it was not denied explicitly and 	 * VEXPLICIT_DENY flag was specified, allow access. 	 */
if|if
condition|(
operator|(
name|accmode
operator|&
name|VEXPLICIT_DENY
operator|)
operator|&&
name|explicitly_denied
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|accmode
operator|&=
operator|~
name|VEXPLICIT_DENY
expr_stmt|;
comment|/* 	 * No match.  Try to use privileges, if there are any. 	 */
if|if
condition|(
name|is_directory
condition|)
block|{
if|if
condition|(
operator|(
name|accmode
operator|&
name|VEXEC
operator|)
operator|&&
operator|!
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_LOOKUP
argument_list|,
literal|0
argument_list|)
condition|)
name|priv_granted
operator||=
name|VEXEC
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|accmode
operator|&
name|VEXEC
operator|)
operator|&&
operator|!
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_EXEC
argument_list|,
literal|0
argument_list|)
condition|)
name|priv_granted
operator||=
name|VEXEC
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|accmode
operator|&
name|VREAD
operator|)
operator|&&
operator|!
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_READ
argument_list|,
literal|0
argument_list|)
condition|)
name|priv_granted
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
operator|(
name|accmode
operator|&
operator|(
name|VWRITE
operator||
name|VAPPEND
operator||
name|VDELETE_CHILD
operator|)
operator|)
operator|&&
operator|!
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_WRITE
argument_list|,
literal|0
argument_list|)
condition|)
name|priv_granted
operator||=
operator|(
name|VWRITE
operator||
name|VAPPEND
operator||
name|VDELETE_CHILD
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|accmode
operator|&
name|VADMIN_PERMS
operator|)
operator|&&
operator|!
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_ADMIN
argument_list|,
literal|0
argument_list|)
condition|)
name|priv_granted
operator||=
name|VADMIN_PERMS
expr_stmt|;
if|if
condition|(
operator|(
name|accmode
operator|&
name|VSTAT_PERMS
operator|)
operator|&&
operator|!
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_STAT
argument_list|,
literal|0
argument_list|)
condition|)
name|priv_granted
operator||=
name|VSTAT_PERMS
expr_stmt|;
if|if
condition|(
operator|(
name|accmode
operator|&
name|priv_granted
operator|)
operator|==
name|accmode
condition|)
block|{
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|accmode
operator|&
operator|(
name|VADMIN_PERMS
operator||
name|VDELETE_CHILD
operator||
name|VDELETE
operator|)
condition|)
name|denied
operator|=
name|EPERM
expr_stmt|;
else|else
name|denied
operator|=
name|EACCES
expr_stmt|;
return|return
operator|(
name|denied
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_function
specifier|static
name|int
name|_acl_entry_matches
parameter_list|(
name|struct
name|acl_entry
modifier|*
name|entry
parameter_list|,
name|acl_tag_t
name|tag
parameter_list|,
name|acl_perm_t
name|perm
parameter_list|,
name|acl_entry_type_t
name|entry_type
parameter_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|ae_tag
operator|!=
name|tag
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|entry
operator|->
name|ae_id
operator|!=
name|ACL_UNDEFINED_ID
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|entry
operator|->
name|ae_perm
operator|!=
name|perm
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|!=
name|entry_type
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|entry
operator|->
name|ae_flags
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|acl_entry
modifier|*
name|_acl_append
parameter_list|(
name|struct
name|acl
modifier|*
name|aclp
parameter_list|,
name|acl_tag_t
name|tag
parameter_list|,
name|acl_perm_t
name|perm
parameter_list|,
name|acl_entry_type_t
name|entry_type
parameter_list|)
block|{
name|struct
name|acl_entry
modifier|*
name|entry
decl_stmt|;
name|KASSERT
argument_list|(
name|aclp
operator|->
name|acl_cnt
operator|+
literal|1
operator|<=
name|ACL_MAX_ENTRIES
argument_list|,
operator|(
literal|"aclp->acl_cnt + 1<= ACL_MAX_ENTRIES"
operator|)
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|aclp
operator|->
name|acl_cnt
index|]
operator|)
expr_stmt|;
name|aclp
operator|->
name|acl_cnt
operator|++
expr_stmt|;
name|entry
operator|->
name|ae_tag
operator|=
name|tag
expr_stmt|;
name|entry
operator|->
name|ae_id
operator|=
name|ACL_UNDEFINED_ID
expr_stmt|;
name|entry
operator|->
name|ae_perm
operator|=
name|perm
expr_stmt|;
name|entry
operator|->
name|ae_entry_type
operator|=
name|entry_type
expr_stmt|;
name|entry
operator|->
name|ae_flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|entry
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|acl_entry
modifier|*
name|_acl_duplicate_entry
parameter_list|(
name|struct
name|acl
modifier|*
name|aclp
parameter_list|,
name|int
name|entry_index
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|aclp
operator|->
name|acl_cnt
operator|+
literal|1
operator|<=
name|ACL_MAX_ENTRIES
argument_list|,
operator|(
literal|"aclp->acl_cnt + 1<= ACL_MAX_ENTRIES"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|aclp
operator|->
name|acl_cnt
init|;
name|i
operator|>
name|entry_index
condition|;
name|i
operator|--
control|)
name|aclp
operator|->
name|acl_entry
index|[
name|i
index|]
operator|=
name|aclp
operator|->
name|acl_entry
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|aclp
operator|->
name|acl_cnt
operator|++
expr_stmt|;
return|return
operator|(
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|entry_index
operator|+
literal|1
index|]
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|acl_nfs4_sync_acl_from_mode
parameter_list|(
name|struct
name|acl
modifier|*
name|aclp
parameter_list|,
name|mode_t
name|mode
parameter_list|,
name|int
name|file_owner_id
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|meets
decl_stmt|,
name|must_append
decl_stmt|;
name|struct
name|acl_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|copy
decl_stmt|,
modifier|*
name|previous
decl_stmt|,
modifier|*
name|a1
decl_stmt|,
modifier|*
name|a2
decl_stmt|,
modifier|*
name|a3
decl_stmt|,
modifier|*
name|a4
decl_stmt|,
modifier|*
name|a5
decl_stmt|,
modifier|*
name|a6
decl_stmt|;
name|mode_t
name|amode
decl_stmt|;
specifier|const
name|int
name|READ
init|=
literal|04
decl_stmt|;
specifier|const
name|int
name|WRITE
init|=
literal|02
decl_stmt|;
specifier|const
name|int
name|EXEC
init|=
literal|01
decl_stmt|;
name|KASSERT
argument_list|(
name|aclp
operator|->
name|acl_cnt
operator|>=
literal|0
argument_list|,
operator|(
literal|"aclp->acl_cnt>= 0"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|aclp
operator|->
name|acl_cnt
operator|<=
name|ACL_MAX_ENTRIES
argument_list|,
operator|(
literal|"aclp->acl_cnt<= ACL_MAX_ENTRIES"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * NFSv4 Minor Version 1, draft-ietf-nfsv4-minorversion1-03.txt 	 * 	 * 3.16.6.3. Applying a Mode to an Existing ACL 	 */
comment|/* 	 * 1. For each ACE: 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|aclp
operator|->
name|acl_cnt
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|i
index|]
operator|)
expr_stmt|;
comment|/* 		 * 1.1. If the type is neither ALLOW or DENY - skip. 		 */
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|!=
name|ACL_ENTRY_TYPE_ALLOW
operator|&&
name|entry
operator|->
name|ae_entry_type
operator|!=
name|ACL_ENTRY_TYPE_DENY
condition|)
continue|continue;
comment|/* 		 * 1.2. If ACL_ENTRY_INHERIT_ONLY is set - skip. 		 */
if|if
condition|(
name|entry
operator|->
name|ae_flags
operator|&
name|ACL_ENTRY_INHERIT_ONLY
condition|)
continue|continue;
comment|/* 		 * 1.3. If ACL_ENTRY_FILE_INHERIT or ACL_ENTRY_DIRECTORY_INHERIT 		 *      are set: 		 */
if|if
condition|(
name|entry
operator|->
name|ae_flags
operator|&
operator|(
name|ACL_ENTRY_FILE_INHERIT
operator||
name|ACL_ENTRY_DIRECTORY_INHERIT
operator|)
condition|)
block|{
comment|/* 			 * 1.3.1. A copy of the current ACE is made, and placed 			 *        in the ACL immediately following the current 			 *        ACE. 			 */
name|copy
operator|=
name|_acl_duplicate_entry
argument_list|(
name|aclp
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 			 * 1.3.2. In the first ACE, the flag 			 *        ACL_ENTRY_INHERIT_ONLY is set. 			 */
name|entry
operator|->
name|ae_flags
operator||=
name|ACL_ENTRY_INHERIT_ONLY
expr_stmt|;
comment|/* 			 * 1.3.3. In the second ACE, the following flags 			 *        are cleared: 			 *        ACL_ENTRY_FILE_INHERIT, 			 *        ACL_ENTRY_DIRECTORY_INHERIT, 			 *        ACL_ENTRY_NO_PROPAGATE_INHERIT. 			 */
name|copy
operator|->
name|ae_flags
operator|&=
operator|~
operator|(
name|ACL_ENTRY_FILE_INHERIT
operator||
name|ACL_ENTRY_DIRECTORY_INHERIT
operator||
name|ACL_ENTRY_NO_PROPAGATE_INHERIT
operator|)
expr_stmt|;
comment|/* 			 * The algorithm continues on with the second ACE. 			 */
name|i
operator|++
expr_stmt|;
name|entry
operator|=
name|copy
expr_stmt|;
block|}
comment|/* 		 * 1.4. If it's owner@, group@ or everyone@ entry, clear 		 *      ACL_READ_DATA, ACL_WRITE_DATA, ACL_APPEND_DATA 		 *      and ACL_EXECUTE.  Continue to the next entry. 		 */
if|if
condition|(
name|entry
operator|->
name|ae_tag
operator|==
name|ACL_USER_OBJ
operator|||
name|entry
operator|->
name|ae_tag
operator|==
name|ACL_GROUP_OBJ
operator|||
name|entry
operator|->
name|ae_tag
operator|==
name|ACL_EVERYONE
condition|)
block|{
name|entry
operator|->
name|ae_perm
operator|&=
operator|~
operator|(
name|ACL_READ_DATA
operator||
name|ACL_WRITE_DATA
operator||
name|ACL_APPEND_DATA
operator||
name|ACL_EXECUTE
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * 1.5. Otherwise, if the "who" field did not match one 		 *      of OWNER@, GROUP@, EVERYONE@: 		 * 		 * 1.5.1. If the type is ALLOW, check the preceding ACE. 		 *        If it does not meet all of the following criteria: 		 */
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|!=
name|ACL_ENTRY_TYPE_ALLOW
condition|)
continue|continue;
name|meets
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|meets
operator|=
literal|1
expr_stmt|;
name|previous
operator|=
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|i
operator|-
literal|1
index|]
operator|)
expr_stmt|;
comment|/* 			 * 1.5.1.1. The type field is DENY, 			 */
if|if
condition|(
name|previous
operator|->
name|ae_entry_type
operator|!=
name|ACL_ENTRY_TYPE_DENY
condition|)
name|meets
operator|=
literal|0
expr_stmt|;
comment|/* 			 * 1.5.1.2. The "who" field is the same as the current 			 *          ACE, 			 * 			 * 1.5.1.3. The flag bit ACE4_IDENTIFIER_GROUP 			 *          is the same as it is in the current ACE, 			 *          and no other flag bits are set, 			 */
if|if
condition|(
name|previous
operator|->
name|ae_id
operator|!=
name|entry
operator|->
name|ae_id
operator|||
name|previous
operator|->
name|ae_tag
operator|!=
name|entry
operator|->
name|ae_tag
condition|)
name|meets
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|previous
operator|->
name|ae_flags
condition|)
name|meets
operator|=
literal|0
expr_stmt|;
comment|/* 			 * 1.5.1.4. The mask bits are a subset of the mask bits 			 *          of the current ACE, and are also subset of 			 *          the following: ACL_READ_DATA, 			 *          ACL_WRITE_DATA, ACL_APPEND_DATA, ACL_EXECUTE 			 */
if|if
condition|(
name|previous
operator|->
name|ae_perm
operator|&
operator|~
operator|(
name|entry
operator|->
name|ae_perm
operator|)
condition|)
name|meets
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|previous
operator|->
name|ae_perm
operator|&
operator|~
operator|(
name|ACL_READ_DATA
operator||
name|ACL_WRITE_DATA
operator||
name|ACL_APPEND_DATA
operator||
name|ACL_EXECUTE
operator|)
condition|)
name|meets
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|meets
condition|)
block|{
comment|/* 		 	 * Then the ACE of type DENY, with a who equal 			 * to the current ACE, flag bits equal to 			 * (<current ACE flags>&<ACE_IDENTIFIER_GROUP>) 			 * and no mask bits, is prepended. 			 */
name|previous
operator|=
name|entry
expr_stmt|;
name|entry
operator|=
name|_acl_duplicate_entry
argument_list|(
name|aclp
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Adjust counter, as we've just added an entry. */
name|i
operator|++
expr_stmt|;
name|previous
operator|->
name|ae_tag
operator|=
name|entry
operator|->
name|ae_tag
expr_stmt|;
name|previous
operator|->
name|ae_id
operator|=
name|entry
operator|->
name|ae_id
expr_stmt|;
name|previous
operator|->
name|ae_flags
operator|=
name|entry
operator|->
name|ae_flags
expr_stmt|;
name|previous
operator|->
name|ae_perm
operator|=
literal|0
expr_stmt|;
name|previous
operator|->
name|ae_entry_type
operator|=
name|ACL_ENTRY_TYPE_DENY
expr_stmt|;
block|}
comment|/* 		 * 1.5.2. The following modifications are made to the prepended 		 *        ACE.  The intent is to mask the following ACE 		 *        to disallow ACL_READ_DATA, ACL_WRITE_DATA, 		 *        ACL_APPEND_DATA, or ACL_EXECUTE, based upon the group 		 *        permissions of the new mode.  As a special case, 		 *        if the ACE matches the current owner of the file, 		 *        the owner bits are used, rather than the group bits. 		 *        This is reflected in the algorithm below. 		 */
name|amode
operator|=
name|mode
operator|>>
literal|3
expr_stmt|;
comment|/* 		 * If ACE4_IDENTIFIER_GROUP is not set, and the "who" field 		 * in ACE matches the owner of the file, we shift amode three 		 * more bits, in order to have the owner permission bits 		 * placed in the three low order bits of amode. 		 */
if|if
condition|(
name|entry
operator|->
name|ae_tag
operator|==
name|ACL_USER
operator|&&
name|entry
operator|->
name|ae_id
operator|==
name|file_owner_id
condition|)
name|amode
operator|=
name|amode
operator|>>
literal|3
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_READ_DATA
condition|)
block|{
if|if
condition|(
name|amode
operator|&
name|READ
condition|)
name|previous
operator|->
name|ae_perm
operator|&=
operator|~
name|ACL_READ_DATA
expr_stmt|;
else|else
name|previous
operator|->
name|ae_perm
operator||=
name|ACL_READ_DATA
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_WRITE_DATA
condition|)
block|{
if|if
condition|(
name|amode
operator|&
name|WRITE
condition|)
name|previous
operator|->
name|ae_perm
operator|&=
operator|~
name|ACL_WRITE_DATA
expr_stmt|;
else|else
name|previous
operator|->
name|ae_perm
operator||=
name|ACL_WRITE_DATA
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_APPEND_DATA
condition|)
block|{
if|if
condition|(
name|amode
operator|&
name|WRITE
condition|)
name|previous
operator|->
name|ae_perm
operator|&=
operator|~
name|ACL_APPEND_DATA
expr_stmt|;
else|else
name|previous
operator|->
name|ae_perm
operator||=
name|ACL_APPEND_DATA
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
block|{
if|if
condition|(
name|amode
operator|&
name|EXEC
condition|)
name|previous
operator|->
name|ae_perm
operator|&=
operator|~
name|ACL_EXECUTE
expr_stmt|;
else|else
name|previous
operator|->
name|ae_perm
operator||=
name|ACL_EXECUTE
expr_stmt|;
block|}
comment|/* 		 * 1.5.3. If ACE4_IDENTIFIER_GROUP is set in the flags 		 *        of the ALLOW ace: 		 * 		 * XXX: This point is not there in the Falkner's draft. 		 */
if|if
condition|(
name|entry
operator|->
name|ae_tag
operator|==
name|ACL_GROUP
operator|&&
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
block|{
name|mode_t
name|extramode
decl_stmt|,
name|ownermode
decl_stmt|;
name|extramode
operator|=
operator|(
name|mode
operator|>>
literal|3
operator|)
operator|&
literal|07
expr_stmt|;
name|ownermode
operator|=
name|mode
operator|>>
literal|6
expr_stmt|;
name|extramode
operator|&=
operator|~
name|ownermode
expr_stmt|;
if|if
condition|(
name|extramode
condition|)
block|{
if|if
condition|(
name|extramode
operator|&
name|READ
condition|)
block|{
name|entry
operator|->
name|ae_perm
operator|&=
operator|~
name|ACL_READ_DATA
expr_stmt|;
name|previous
operator|->
name|ae_perm
operator|&=
operator|~
name|ACL_READ_DATA
expr_stmt|;
block|}
if|if
condition|(
name|extramode
operator|&
name|WRITE
condition|)
block|{
name|entry
operator|->
name|ae_perm
operator|&=
operator|~
operator|(
name|ACL_WRITE_DATA
operator||
name|ACL_APPEND_DATA
operator|)
expr_stmt|;
name|previous
operator|->
name|ae_perm
operator|&=
operator|~
operator|(
name|ACL_WRITE_DATA
operator||
name|ACL_APPEND_DATA
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|extramode
operator|&
name|EXEC
condition|)
block|{
name|entry
operator|->
name|ae_perm
operator|&=
operator|~
name|ACL_EXECUTE
expr_stmt|;
name|previous
operator|->
name|ae_perm
operator|&=
operator|~
name|ACL_EXECUTE
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * 2. If there at least six ACEs, the final six ACEs are examined. 	 *    If they are not equal to what we want, append six ACEs. 	 */
name|must_append
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aclp
operator|->
name|acl_cnt
operator|<
literal|6
condition|)
block|{
name|must_append
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|a6
operator|=
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|aclp
operator|->
name|acl_cnt
operator|-
literal|1
index|]
operator|)
expr_stmt|;
name|a5
operator|=
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|aclp
operator|->
name|acl_cnt
operator|-
literal|2
index|]
operator|)
expr_stmt|;
name|a4
operator|=
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|aclp
operator|->
name|acl_cnt
operator|-
literal|3
index|]
operator|)
expr_stmt|;
name|a3
operator|=
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|aclp
operator|->
name|acl_cnt
operator|-
literal|4
index|]
operator|)
expr_stmt|;
name|a2
operator|=
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|aclp
operator|->
name|acl_cnt
operator|-
literal|5
index|]
operator|)
expr_stmt|;
name|a1
operator|=
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|aclp
operator|->
name|acl_cnt
operator|-
literal|6
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|_acl_entry_matches
argument_list|(
name|a1
argument_list|,
name|ACL_USER_OBJ
argument_list|,
literal|0
argument_list|,
name|ACL_ENTRY_TYPE_DENY
argument_list|)
condition|)
name|must_append
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|_acl_entry_matches
argument_list|(
name|a2
argument_list|,
name|ACL_USER_OBJ
argument_list|,
name|ACL_WRITE_ACL
operator||
name|ACL_WRITE_OWNER
operator||
name|ACL_WRITE_ATTRIBUTES
operator||
name|ACL_WRITE_NAMED_ATTRS
argument_list|,
name|ACL_ENTRY_TYPE_ALLOW
argument_list|)
condition|)
name|must_append
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|_acl_entry_matches
argument_list|(
name|a3
argument_list|,
name|ACL_GROUP_OBJ
argument_list|,
literal|0
argument_list|,
name|ACL_ENTRY_TYPE_DENY
argument_list|)
condition|)
name|must_append
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|_acl_entry_matches
argument_list|(
name|a4
argument_list|,
name|ACL_GROUP_OBJ
argument_list|,
literal|0
argument_list|,
name|ACL_ENTRY_TYPE_ALLOW
argument_list|)
condition|)
name|must_append
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|_acl_entry_matches
argument_list|(
name|a5
argument_list|,
name|ACL_EVERYONE
argument_list|,
name|ACL_WRITE_ACL
operator||
name|ACL_WRITE_OWNER
operator||
name|ACL_WRITE_ATTRIBUTES
operator||
name|ACL_WRITE_NAMED_ATTRS
argument_list|,
name|ACL_ENTRY_TYPE_DENY
argument_list|)
condition|)
name|must_append
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|_acl_entry_matches
argument_list|(
name|a6
argument_list|,
name|ACL_EVERYONE
argument_list|,
name|ACL_READ_ACL
operator||
name|ACL_READ_ATTRIBUTES
operator||
name|ACL_READ_NAMED_ATTRS
operator||
name|ACL_SYNCHRONIZE
argument_list|,
name|ACL_ENTRY_TYPE_ALLOW
argument_list|)
condition|)
name|must_append
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|must_append
condition|)
block|{
name|KASSERT
argument_list|(
name|aclp
operator|->
name|acl_cnt
operator|+
literal|6
operator|<=
name|ACL_MAX_ENTRIES
argument_list|,
operator|(
literal|"aclp->acl_cnt<= ACL_MAX_ENTRIES"
operator|)
argument_list|)
expr_stmt|;
name|a1
operator|=
name|_acl_append
argument_list|(
name|aclp
argument_list|,
name|ACL_USER_OBJ
argument_list|,
literal|0
argument_list|,
name|ACL_ENTRY_TYPE_DENY
argument_list|)
expr_stmt|;
name|a2
operator|=
name|_acl_append
argument_list|(
name|aclp
argument_list|,
name|ACL_USER_OBJ
argument_list|,
name|ACL_WRITE_ACL
operator||
name|ACL_WRITE_OWNER
operator||
name|ACL_WRITE_ATTRIBUTES
operator||
name|ACL_WRITE_NAMED_ATTRS
argument_list|,
name|ACL_ENTRY_TYPE_ALLOW
argument_list|)
expr_stmt|;
name|a3
operator|=
name|_acl_append
argument_list|(
name|aclp
argument_list|,
name|ACL_GROUP_OBJ
argument_list|,
literal|0
argument_list|,
name|ACL_ENTRY_TYPE_DENY
argument_list|)
expr_stmt|;
name|a4
operator|=
name|_acl_append
argument_list|(
name|aclp
argument_list|,
name|ACL_GROUP_OBJ
argument_list|,
literal|0
argument_list|,
name|ACL_ENTRY_TYPE_ALLOW
argument_list|)
expr_stmt|;
name|a5
operator|=
name|_acl_append
argument_list|(
name|aclp
argument_list|,
name|ACL_EVERYONE
argument_list|,
name|ACL_WRITE_ACL
operator||
name|ACL_WRITE_OWNER
operator||
name|ACL_WRITE_ATTRIBUTES
operator||
name|ACL_WRITE_NAMED_ATTRS
argument_list|,
name|ACL_ENTRY_TYPE_DENY
argument_list|)
expr_stmt|;
name|a6
operator|=
name|_acl_append
argument_list|(
name|aclp
argument_list|,
name|ACL_EVERYONE
argument_list|,
name|ACL_READ_ACL
operator||
name|ACL_READ_ATTRIBUTES
operator||
name|ACL_READ_NAMED_ATTRS
operator||
name|ACL_SYNCHRONIZE
argument_list|,
name|ACL_ENTRY_TYPE_ALLOW
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|a1
operator|!=
name|NULL
operator|&&
name|a2
operator|!=
name|NULL
operator|&&
name|a3
operator|!=
name|NULL
operator|&&
name|a4
operator|!=
name|NULL
operator|&&
name|a5
operator|!=
name|NULL
operator|&&
name|a6
operator|!=
name|NULL
argument_list|,
operator|(
literal|"couldn't append to ACL."
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * 3. The final six ACEs are adjusted according to the incoming mode. 	 */
if|if
condition|(
name|mode
operator|&
name|S_IRUSR
condition|)
name|a2
operator|->
name|ae_perm
operator||=
name|ACL_READ_DATA
expr_stmt|;
else|else
name|a1
operator|->
name|ae_perm
operator||=
name|ACL_READ_DATA
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWUSR
condition|)
name|a2
operator|->
name|ae_perm
operator||=
operator|(
name|ACL_WRITE_DATA
operator||
name|ACL_APPEND_DATA
operator|)
expr_stmt|;
else|else
name|a1
operator|->
name|ae_perm
operator||=
operator|(
name|ACL_WRITE_DATA
operator||
name|ACL_APPEND_DATA
operator|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IXUSR
condition|)
name|a2
operator|->
name|ae_perm
operator||=
name|ACL_EXECUTE
expr_stmt|;
else|else
name|a1
operator|->
name|ae_perm
operator||=
name|ACL_EXECUTE
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IRGRP
condition|)
name|a4
operator|->
name|ae_perm
operator||=
name|ACL_READ_DATA
expr_stmt|;
else|else
name|a3
operator|->
name|ae_perm
operator||=
name|ACL_READ_DATA
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWGRP
condition|)
name|a4
operator|->
name|ae_perm
operator||=
operator|(
name|ACL_WRITE_DATA
operator||
name|ACL_APPEND_DATA
operator|)
expr_stmt|;
else|else
name|a3
operator|->
name|ae_perm
operator||=
operator|(
name|ACL_WRITE_DATA
operator||
name|ACL_APPEND_DATA
operator|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IXGRP
condition|)
name|a4
operator|->
name|ae_perm
operator||=
name|ACL_EXECUTE
expr_stmt|;
else|else
name|a3
operator|->
name|ae_perm
operator||=
name|ACL_EXECUTE
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IROTH
condition|)
name|a6
operator|->
name|ae_perm
operator||=
name|ACL_READ_DATA
expr_stmt|;
else|else
name|a5
operator|->
name|ae_perm
operator||=
name|ACL_READ_DATA
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWOTH
condition|)
name|a6
operator|->
name|ae_perm
operator||=
operator|(
name|ACL_WRITE_DATA
operator||
name|ACL_APPEND_DATA
operator|)
expr_stmt|;
else|else
name|a5
operator|->
name|ae_perm
operator||=
operator|(
name|ACL_WRITE_DATA
operator||
name|ACL_APPEND_DATA
operator|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IXOTH
condition|)
name|a6
operator|->
name|ae_perm
operator||=
name|ACL_EXECUTE
expr_stmt|;
else|else
name|a5
operator|->
name|ae_perm
operator||=
name|ACL_EXECUTE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|acl_nfs4_sync_mode_from_acl
parameter_list|(
name|mode_t
modifier|*
name|_mode
parameter_list|,
specifier|const
name|struct
name|acl
modifier|*
name|aclp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|mode_t
name|old_mode
init|=
operator|*
name|_mode
decl_stmt|,
name|mode
init|=
literal|0
decl_stmt|,
name|seen
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|acl_entry
modifier|*
name|entry
decl_stmt|;
name|KASSERT
argument_list|(
name|aclp
operator|->
name|acl_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"aclp->acl_cnt> 0"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|aclp
operator|->
name|acl_cnt
operator|<=
name|ACL_MAX_ENTRIES
argument_list|,
operator|(
literal|"aclp->acl_cnt<= ACL_MAX_ENTRIES"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * NFSv4 Minor Version 1, draft-ietf-nfsv4-minorversion1-03.txt 	 * 	 * 3.16.6.1. Recomputing mode upon SETATTR of ACL 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|aclp
operator|->
name|acl_cnt
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|!=
name|ACL_ENTRY_TYPE_ALLOW
operator|&&
name|entry
operator|->
name|ae_entry_type
operator|!=
name|ACL_ENTRY_TYPE_DENY
condition|)
continue|continue;
if|if
condition|(
name|entry
operator|->
name|ae_flags
operator|&
name|ACL_ENTRY_INHERIT_ONLY
condition|)
continue|continue;
if|if
condition|(
name|entry
operator|->
name|ae_tag
operator|==
name|ACL_USER_OBJ
condition|)
block|{
if|if
condition|(
operator|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_READ_DATA
operator|)
operator|&&
operator|(
operator|(
name|seen
operator|&
name|S_IRUSR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IRUSR
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IRUSR
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_WRITE_DATA
operator|)
operator|&&
operator|(
operator|(
name|seen
operator|&
name|S_IWUSR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IWUSR
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IWUSR
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_EXECUTE
operator|)
operator|&&
operator|(
operator|(
name|seen
operator|&
name|S_IXUSR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IXUSR
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IXUSR
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|ae_tag
operator|==
name|ACL_GROUP_OBJ
condition|)
block|{
if|if
condition|(
operator|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_READ_DATA
operator|)
operator|&&
operator|(
operator|(
name|seen
operator|&
name|S_IRGRP
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IRGRP
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IRGRP
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_WRITE_DATA
operator|)
operator|&&
operator|(
operator|(
name|seen
operator|&
name|S_IWGRP
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IWGRP
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IWGRP
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_EXECUTE
operator|)
operator|&&
operator|(
operator|(
name|seen
operator|&
name|S_IXGRP
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|seen
operator||=
name|S_IXGRP
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IXGRP
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|ae_tag
operator|==
name|ACL_EVERYONE
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_READ_DATA
condition|)
block|{
if|if
condition|(
operator|(
name|seen
operator|&
name|S_IRUSR
operator|)
operator|==
literal|0
condition|)
block|{
name|seen
operator||=
name|S_IRUSR
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IRUSR
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|seen
operator|&
name|S_IRGRP
operator|)
operator|==
literal|0
condition|)
block|{
name|seen
operator||=
name|S_IRGRP
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IRGRP
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|seen
operator|&
name|S_IROTH
operator|)
operator|==
literal|0
condition|)
block|{
name|seen
operator||=
name|S_IROTH
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IROTH
expr_stmt|;
block|}
block|}
if|if
condition|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_WRITE_DATA
condition|)
block|{
if|if
condition|(
operator|(
name|seen
operator|&
name|S_IWUSR
operator|)
operator|==
literal|0
condition|)
block|{
name|seen
operator||=
name|S_IWUSR
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IWUSR
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|seen
operator|&
name|S_IWGRP
operator|)
operator|==
literal|0
condition|)
block|{
name|seen
operator||=
name|S_IWGRP
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IWGRP
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|seen
operator|&
name|S_IWOTH
operator|)
operator|==
literal|0
condition|)
block|{
name|seen
operator||=
name|S_IWOTH
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IWOTH
expr_stmt|;
block|}
block|}
if|if
condition|(
name|entry
operator|->
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
block|{
if|if
condition|(
operator|(
name|seen
operator|&
name|S_IXUSR
operator|)
operator|==
literal|0
condition|)
block|{
name|seen
operator||=
name|S_IXUSR
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IXUSR
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|seen
operator|&
name|S_IXGRP
operator|)
operator|==
literal|0
condition|)
block|{
name|seen
operator||=
name|S_IXGRP
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IXGRP
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|seen
operator|&
name|S_IXOTH
operator|)
operator|==
literal|0
condition|)
block|{
name|seen
operator||=
name|S_IXOTH
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|mode
operator||=
name|S_IXOTH
expr_stmt|;
block|}
block|}
block|}
block|}
operator|*
name|_mode
operator|=
name|mode
operator||
operator|(
name|old_mode
operator|&
name|ACL_PRESERVE_MASK
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|acl_nfs4_compute_inherited_acl
parameter_list|(
specifier|const
name|struct
name|acl
modifier|*
name|parent_aclp
parameter_list|,
name|struct
name|acl
modifier|*
name|child_aclp
parameter_list|,
name|mode_t
name|mode
parameter_list|,
name|int
name|file_owner_id
parameter_list|,
name|int
name|is_directory
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|flags
decl_stmt|;
specifier|const
name|struct
name|acl_entry
modifier|*
name|parent_entry
decl_stmt|;
name|struct
name|acl_entry
modifier|*
name|entry
decl_stmt|,
modifier|*
name|copy
decl_stmt|;
name|KASSERT
argument_list|(
name|child_aclp
operator|->
name|acl_cnt
operator|==
literal|0
argument_list|,
operator|(
literal|"child_aclp->acl_cnt == 0"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|parent_aclp
operator|->
name|acl_cnt
operator|>
literal|0
argument_list|,
operator|(
literal|"parent_aclp->acl_cnt> 0"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|parent_aclp
operator|->
name|acl_cnt
operator|<=
name|ACL_MAX_ENTRIES
argument_list|,
operator|(
literal|"parent_aclp->acl_cnt<= ACL_MAX_ENTRIES"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * NFSv4 Minor Version 1, draft-ietf-nfsv4-minorversion1-03.txt 	 * 	 * 3.16.6.2. Applying the mode given to CREATE or OPEN 	 *           to an inherited ACL 	 */
comment|/* 	 * 1. Form an ACL that is the concatenation of all inheritable ACEs. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|parent_aclp
operator|->
name|acl_cnt
condition|;
name|i
operator|++
control|)
block|{
name|parent_entry
operator|=
operator|&
operator|(
name|parent_aclp
operator|->
name|acl_entry
index|[
name|i
index|]
operator|)
expr_stmt|;
name|flags
operator|=
name|parent_entry
operator|->
name|ae_flags
expr_stmt|;
comment|/* 		 * Entry is not inheritable at all. 		 */
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|ACL_ENTRY_DIRECTORY_INHERIT
operator||
name|ACL_ENTRY_FILE_INHERIT
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * We're creating a file, but entry is not inheritable 		 * by files. 		 */
if|if
condition|(
operator|!
name|is_directory
operator|&&
operator|(
name|flags
operator|&
name|ACL_ENTRY_FILE_INHERIT
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Entry is inheritable only by files, but has NO_PROPAGATE 		 * flag set, and we're creating a directory, so it wouldn't 		 * propagate to any file in that directory anyway. 		 */
if|if
condition|(
name|is_directory
operator|&&
operator|(
name|flags
operator|&
name|ACL_ENTRY_DIRECTORY_INHERIT
operator|)
operator|==
literal|0
operator|&&
operator|(
name|flags
operator|&
name|ACL_ENTRY_NO_PROPAGATE_INHERIT
operator|)
condition|)
continue|continue;
name|KASSERT
argument_list|(
name|child_aclp
operator|->
name|acl_cnt
operator|+
literal|1
operator|<=
name|ACL_MAX_ENTRIES
argument_list|,
operator|(
literal|"child_aclp->acl_cnt + 1<= ACL_MAX_ENTRIES"
operator|)
argument_list|)
expr_stmt|;
name|child_aclp
operator|->
name|acl_entry
index|[
name|child_aclp
operator|->
name|acl_cnt
index|]
operator|=
operator|*
name|parent_entry
expr_stmt|;
name|child_aclp
operator|->
name|acl_cnt
operator|++
expr_stmt|;
block|}
comment|/* 	 * 2. For each entry in the new ACL, adjust its flags, possibly 	 *    creating two entries in place of one. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|child_aclp
operator|->
name|acl_cnt
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
operator|&
operator|(
name|child_aclp
operator|->
name|acl_entry
index|[
name|i
index|]
operator|)
expr_stmt|;
comment|/* 		 * This is not in the specification, but SunOS 		 * apparently does that. 		 */
if|if
condition|(
operator|(
operator|(
name|entry
operator|->
name|ae_flags
operator|&
name|ACL_ENTRY_NO_PROPAGATE_INHERIT
operator|)
operator|||
operator|!
name|is_directory
operator|)
operator|&&
name|entry
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|entry
operator|->
name|ae_perm
operator|&=
operator|~
operator|(
name|ACL_WRITE_ACL
operator||
name|ACL_WRITE_OWNER
operator|)
expr_stmt|;
comment|/* 		 * 2.A. If the ACL_ENTRY_NO_PROPAGATE_INHERIT is set, or if the object 		 *      being created is not a directory, then clear the 		 *      following flags: ACL_ENTRY_NO_PROPAGATE_INHERIT, 		 *      ACL_ENTRY_FILE_INHERIT, ACL_ENTRY_DIRECTORY_INHERIT, 		 *      ACL_ENTRY_INHERIT_ONLY. 		 */
if|if
condition|(
name|entry
operator|->
name|ae_flags
operator|&
name|ACL_ENTRY_NO_PROPAGATE_INHERIT
operator|||
operator|!
name|is_directory
condition|)
block|{
name|entry
operator|->
name|ae_flags
operator|&=
operator|~
operator|(
name|ACL_ENTRY_NO_PROPAGATE_INHERIT
operator||
name|ACL_ENTRY_FILE_INHERIT
operator||
name|ACL_ENTRY_DIRECTORY_INHERIT
operator||
name|ACL_ENTRY_INHERIT_ONLY
operator|)
expr_stmt|;
comment|/* 			 * Continue on to the next ACE. 			 */
continue|continue;
block|}
comment|/* 		 * 2.B. If the object is a directory and ACL_ENTRY_FILE_INHERIT 		 *      is set, but ACL_ENTRY_NO_PROPAGATE_INHERIT is not set, ensure 		 *      that ACL_ENTRY_INHERIT_ONLY is set.  Continue to the 		 *      next ACE.  Otherwise... 		 */
comment|/* 		 * XXX: Read it again and make sure what does the "otherwise" 		 *      apply to. 		 */
if|if
condition|(
name|is_directory
operator|&&
operator|(
name|entry
operator|->
name|ae_flags
operator|&
name|ACL_ENTRY_FILE_INHERIT
operator|)
operator|&&
operator|(
operator|(
name|entry
operator|->
name|ae_flags
operator|&
name|ACL_ENTRY_DIRECTORY_INHERIT
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|entry
operator|->
name|ae_flags
operator||=
name|ACL_ENTRY_INHERIT_ONLY
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * 2.C. If the type of the ACE is neither ALLOW nor deny, 		 *      then continue. 		 */
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|!=
name|ACL_ENTRY_TYPE_ALLOW
operator|&&
name|entry
operator|->
name|ae_entry_type
operator|!=
name|ACL_ENTRY_TYPE_DENY
condition|)
continue|continue;
comment|/* 		 * 2.D. Copy the original ACE into a second, adjacent ACE. 		 */
name|copy
operator|=
name|_acl_duplicate_entry
argument_list|(
name|child_aclp
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 		 * 2.E. On the first ACE, ensure that ACL_ENTRY_INHERIT_ONLY 		 *      is set. 		 */
name|entry
operator|->
name|ae_flags
operator||=
name|ACL_ENTRY_INHERIT_ONLY
expr_stmt|;
comment|/* 		 * 2.F. On the second ACE, clear the following flags: 		 *      ACL_ENTRY_NO_PROPAGATE_INHERIT, ACL_ENTRY_FILE_INHERIT, 		 *      ACL_ENTRY_DIRECTORY_INHERIT, ACL_ENTRY_INHERIT_ONLY. 		 */
name|copy
operator|->
name|ae_flags
operator|&=
operator|~
operator|(
name|ACL_ENTRY_NO_PROPAGATE_INHERIT
operator||
name|ACL_ENTRY_FILE_INHERIT
operator||
name|ACL_ENTRY_DIRECTORY_INHERIT
operator||
name|ACL_ENTRY_INHERIT_ONLY
operator|)
expr_stmt|;
comment|/* 		 * 2.G. On the second ACE, if the type is ALLOW, 		 *      an implementation MAY clear the following 		 *      mask bits: ACL_WRITE_ACL, ACL_WRITE_OWNER. 		 */
if|if
condition|(
name|copy
operator|->
name|ae_entry_type
operator|==
name|ACL_ENTRY_TYPE_ALLOW
condition|)
name|copy
operator|->
name|ae_perm
operator|&=
operator|~
operator|(
name|ACL_WRITE_ACL
operator||
name|ACL_WRITE_OWNER
operator|)
expr_stmt|;
comment|/* 		 * Increment the counter to skip the copied entry. 		 */
name|i
operator|++
expr_stmt|;
block|}
comment|/* 	 * 3. To ensure that the mode is honored, apply the algorithm describe 	 *    in Section 2.16.6.3, using the mode that is to be used for file 	 *    creation. 	 */
name|acl_nfs4_sync_acl_from_mode
argument_list|(
name|child_aclp
argument_list|,
name|mode
argument_list|,
name|file_owner_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_function
specifier|static
name|int
name|_acls_are_equal
parameter_list|(
specifier|const
name|struct
name|acl
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|acl
modifier|*
name|b
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|struct
name|acl_entry
modifier|*
name|entrya
decl_stmt|,
modifier|*
name|entryb
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|acl_cnt
operator|!=
name|b
operator|->
name|acl_cnt
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|b
operator|->
name|acl_cnt
condition|;
name|i
operator|++
control|)
block|{
name|entrya
operator|=
operator|&
operator|(
name|a
operator|->
name|acl_entry
index|[
name|i
index|]
operator|)
expr_stmt|;
name|entryb
operator|=
operator|&
operator|(
name|b
operator|->
name|acl_entry
index|[
name|i
index|]
operator|)
expr_stmt|;
if|if
condition|(
name|entrya
operator|->
name|ae_tag
operator|!=
name|entryb
operator|->
name|ae_tag
operator|||
name|entrya
operator|->
name|ae_id
operator|!=
name|entryb
operator|->
name|ae_id
operator|||
name|entrya
operator|->
name|ae_perm
operator|!=
name|entryb
operator|->
name|ae_perm
operator|||
name|entrya
operator|->
name|ae_entry_type
operator|!=
name|entryb
operator|->
name|ae_entry_type
operator|||
name|entrya
operator|->
name|ae_flags
operator|!=
name|entryb
operator|->
name|ae_flags
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine is used to determine whether to remove entry_type attribute  * that stores ACL contents.  */
end_comment

begin_function
name|int
name|acl_nfs4_is_trivial
parameter_list|(
specifier|const
name|struct
name|acl
modifier|*
name|aclp
parameter_list|,
name|int
name|file_owner_id
parameter_list|)
block|{
name|int
name|trivial
decl_stmt|;
name|mode_t
name|tmpmode
init|=
literal|0
decl_stmt|;
name|struct
name|acl
modifier|*
name|tmpaclp
decl_stmt|;
if|if
condition|(
name|aclp
operator|->
name|acl_cnt
operator|!=
literal|6
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Compute the mode from the ACL, then compute new ACL from that mode. 	 * If the ACLs are identical, then the ACL is trivial. 	 * 	 * XXX: I guess there is a faster way to do this.  However, even 	 *      this slow implementation significantly speeds things up 	 *      for files that don't have any entry_type ACL entries - it's 	 *      critical for performance to not use EA when they are not 	 *      needed. 	 */
name|tmpaclp
operator|=
name|acl_alloc
argument_list|(
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|acl_nfs4_sync_mode_from_acl
argument_list|(
operator|&
name|tmpmode
argument_list|,
name|aclp
argument_list|)
expr_stmt|;
name|acl_nfs4_sync_acl_from_mode
argument_list|(
name|tmpaclp
argument_list|,
name|tmpmode
argument_list|,
name|file_owner_id
argument_list|)
expr_stmt|;
name|trivial
operator|=
name|_acls_are_equal
argument_list|(
name|aclp
argument_list|,
name|tmpaclp
argument_list|)
expr_stmt|;
name|acl_free
argument_list|(
name|tmpaclp
argument_list|)
expr_stmt|;
return|return
operator|(
name|trivial
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_function
name|int
name|acl_nfs4_check
parameter_list|(
specifier|const
name|struct
name|acl
modifier|*
name|aclp
parameter_list|,
name|int
name|is_directory
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|struct
name|acl_entry
modifier|*
name|entry
decl_stmt|;
comment|/* 	 * The spec doesn't seem to say anything about ACL validity. 	 * It seems there is not much to do here.  There is even no need 	 * to count "owner@" or "everyone@" (ACL_USER_OBJ and ACL_EVERYONE) 	 * entries, as there can be several of them and that's perfectly 	 * valid.  There can be none of them too.  Really. 	 */
if|if
condition|(
name|aclp
operator|->
name|acl_cnt
operator|>
name|ACL_MAX_ENTRIES
operator|||
name|aclp
operator|->
name|acl_cnt
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|aclp
operator|->
name|acl_cnt
condition|;
name|i
operator|++
control|)
block|{
name|entry
operator|=
operator|&
operator|(
name|aclp
operator|->
name|acl_entry
index|[
name|i
index|]
operator|)
expr_stmt|;
switch|switch
condition|(
name|entry
operator|->
name|ae_tag
condition|)
block|{
case|case
name|ACL_USER_OBJ
case|:
case|case
name|ACL_GROUP_OBJ
case|:
case|case
name|ACL_EVERYONE
case|:
if|if
condition|(
name|entry
operator|->
name|ae_id
operator|!=
name|ACL_UNDEFINED_ID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
case|case
name|ACL_USER
case|:
case|case
name|ACL_GROUP
case|:
if|if
condition|(
name|entry
operator|->
name|ae_id
operator|==
name|ACL_UNDEFINED_ID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|entry
operator|->
name|ae_perm
operator||
name|ACL_NFS4_PERM_BITS
operator|)
operator|!=
name|ACL_NFS4_PERM_BITS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 		 * Disallow ACL_ENTRY_TYPE_AUDIT and ACL_ENTRY_TYPE_ALARM for now. 		 */
if|if
condition|(
name|entry
operator|->
name|ae_entry_type
operator|!=
name|ACL_ENTRY_TYPE_ALLOW
operator|&&
name|entry
operator|->
name|ae_entry_type
operator|!=
name|ACL_ENTRY_TYPE_DENY
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|entry
operator|->
name|ae_flags
operator||
name|ACL_FLAGS_BITS
operator|)
operator|!=
name|ACL_FLAGS_BITS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Disallow unimplemented flags. */
if|if
condition|(
name|entry
operator|->
name|ae_flags
operator|&
operator|(
name|ACL_ENTRY_SUCCESSFUL_ACCESS
operator||
name|ACL_ENTRY_FAILED_ACCESS
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Disallow flags not allowed for ordinary files. */
if|if
condition|(
operator|!
name|is_directory
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|ae_flags
operator|&
operator|(
name|ACL_ENTRY_FILE_INHERIT
operator||
name|ACL_ENTRY_DIRECTORY_INHERIT
operator||
name|ACL_ENTRY_NO_PROPAGATE_INHERIT
operator||
name|ACL_ENTRY_INHERIT_ONLY
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

