begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002, Jeffrey Roberson<jeff@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/thr.h>
end_include

begin_include
include|#
directive|include
file|<sys/umtx.h>
end_include

begin_struct
struct|struct
name|umtx_q
block|{
name|LIST_ENTRY
argument_list|(
argument|umtx_q
argument_list|)
name|uq_next
expr_stmt|;
comment|/* Linked list for the hash. */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|thread
argument_list|)
name|uq_tdq
expr_stmt|;
comment|/* List of threads blocked here. */
name|struct
name|umtx
modifier|*
name|uq_umtx
decl_stmt|;
comment|/* Pointer key component. */
name|pid_t
name|uq_pid
decl_stmt|;
comment|/* Pid key component. */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|UMTX_QUEUES
value|128
end_define

begin_define
define|#
directive|define
name|UMTX_HASH
parameter_list|(
name|pid
parameter_list|,
name|umtx
parameter_list|)
define|\
value|(((uintptr_t)pid + ((uintptr_t)umtx& ~65535)) % UMTX_QUEUES)
end_define

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|umtx_head
argument_list|,
name|umtx_q
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|umtx_head
name|queues
index|[
name|UMTX_QUEUES
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_UMTX
argument_list|,
literal|"umtx"
argument_list|,
literal|"UMTX queue memory"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|umtx_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|umtx
argument_list|,
operator|&
name|umtx_lock
argument_list|,
literal|"umtx"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|UMTX_LOCK
parameter_list|()
value|mtx_lock(&umtx_lock);
end_define

begin_define
define|#
directive|define
name|UMTX_UNLOCK
parameter_list|()
value|mtx_unlock(&umtx_lock);
end_define

begin_function_decl
specifier|static
name|struct
name|umtx_q
modifier|*
name|umtx_lookup
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|struct
name|umtx
modifier|*
name|umtx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|umtx_q
modifier|*
name|umtx_insert
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|struct
name|umtx
modifier|*
name|umtx
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|struct
name|umtx_q
modifier|*
name|umtx_lookup
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umtx
modifier|*
name|umtx
parameter_list|)
block|{
name|struct
name|umtx_head
modifier|*
name|head
decl_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|pid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
name|head
operator|=
operator|&
name|queues
index|[
name|UMTX_HASH
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|umtx
argument_list|)
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|uq
argument_list|,
argument|head
argument_list|,
argument|uq_next
argument_list|)
block|{
if|if
condition|(
name|uq
operator|->
name|uq_pid
operator|==
name|pid
operator|&&
name|uq
operator|->
name|uq_umtx
operator|==
name|umtx
condition|)
return|return
operator|(
name|uq
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert a thread onto the umtx queue.  */
end_comment

begin_function
specifier|static
name|struct
name|umtx_q
modifier|*
name|umtx_insert
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umtx
modifier|*
name|umtx
parameter_list|)
block|{
name|struct
name|umtx_head
modifier|*
name|head
decl_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|pid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
if|if
condition|(
operator|(
name|uq
operator|=
name|umtx_lookup
argument_list|(
name|td
argument_list|,
name|umtx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|struct
name|umtx_q
modifier|*
name|ins
decl_stmt|;
name|UMTX_UNLOCK
argument_list|()
expr_stmt|;
name|ins
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|uq
argument_list|)
argument_list|,
name|M_UMTX
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|UMTX_LOCK
argument_list|()
expr_stmt|;
comment|/* 		 * Some one else could have succeeded while we were blocked 		 * waiting on memory. 		 */
if|if
condition|(
operator|(
name|uq
operator|=
name|umtx_lookup
argument_list|(
name|td
argument_list|,
name|umtx
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|head
operator|=
operator|&
name|queues
index|[
name|UMTX_HASH
argument_list|(
name|pid
argument_list|,
name|umtx
argument_list|)
index|]
expr_stmt|;
name|uq
operator|=
name|ins
expr_stmt|;
name|uq
operator|->
name|uq_pid
operator|=
name|pid
expr_stmt|;
name|uq
operator|->
name|uq_umtx
operator|=
name|umtx
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|uq
argument_list|,
name|uq_next
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|uq
operator|->
name|uq_tdq
argument_list|)
expr_stmt|;
block|}
else|else
name|free
argument_list|(
name|ins
argument_list|,
name|M_UMTX
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Insert us onto the end of the TAILQ. 	 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|uq
operator|->
name|uq_tdq
argument_list|,
name|td
argument_list|,
name|td_umtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|uq
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|umtx_remove
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|uq
operator|->
name|uq_tdq
argument_list|,
name|td
argument_list|,
name|td_umtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|uq
operator|->
name|uq_tdq
argument_list|)
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|uq
argument_list|,
name|uq_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|uq
argument_list|,
name|M_UMTX
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|_umtx_lock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_lock_args
modifier|*
name|uap
parameter_list|)
comment|/* struct umtx *umtx */
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|struct
name|umtx
modifier|*
name|umtx
decl_stmt|;
name|intptr_t
name|owner
decl_stmt|;
name|intptr_t
name|old
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uq
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Care must be exercised when dealing with this structure.  It 	 * can fault on any access. 	 */
name|umtx
operator|=
name|uap
operator|->
name|umtx
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Try the uncontested case.  This should be done in userland. 		 */
name|owner
operator|=
name|casuptr
argument_list|(
operator|(
name|intptr_t
operator|*
operator|)
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
name|UMTX_UNOWNED
argument_list|,
operator|(
name|intptr_t
operator|)
name|td
argument_list|)
expr_stmt|;
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* The acquire succeeded. */
if|if
condition|(
name|owner
operator|==
name|UMTX_UNOWNED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* If no one owns it but it is contested try to acquire it. */
if|if
condition|(
name|owner
operator|==
name|UMTX_CONTESTED
condition|)
block|{
name|owner
operator|=
name|casuptr
argument_list|(
operator|(
name|intptr_t
operator|*
operator|)
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
name|UMTX_CONTESTED
argument_list|,
operator|(
operator|(
name|intptr_t
operator|)
name|td
operator||
name|UMTX_CONTESTED
operator|)
argument_list|)
expr_stmt|;
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|owner
operator|==
name|UMTX_CONTESTED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* If this failed the lock has changed, restart. */
continue|continue;
block|}
name|UMTX_LOCK
argument_list|()
expr_stmt|;
name|uq
operator|=
name|umtx_insert
argument_list|(
name|td
argument_list|,
name|umtx
argument_list|)
expr_stmt|;
name|UMTX_UNLOCK
argument_list|()
expr_stmt|;
comment|/* 		 * Set the contested bit so that a release in user space 		 * knows to use the system call for unlock.  If this fails 		 * either some one else has acquired the lock or it has been 		 * released. 		 */
name|old
operator|=
name|casuptr
argument_list|(
operator|(
name|intptr_t
operator|*
operator|)
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
name|owner
argument_list|,
name|owner
operator||
name|UMTX_CONTESTED
argument_list|)
expr_stmt|;
comment|/* The address was invalid. */
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
block|{
name|UMTX_LOCK
argument_list|()
expr_stmt|;
name|umtx_remove
argument_list|(
name|uq
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|UMTX_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
comment|/* 		 * We set the contested bit, sleep. Otherwise the lock changed 		 * and we need to retry or we lost a race to the thread 		 * unlocking the umtx. 		 */
name|UMTX_LOCK
argument_list|()
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|owner
operator|&&
operator|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_UMTXWAKEUP
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
name|td
argument_list|,
operator|&
name|umtx_lock
argument_list|,
name|td
operator|->
name|td_priority
operator||
name|PCATCH
argument_list|,
literal|"umtx"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_UMTXWAKEUP
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|umtx_remove
argument_list|(
name|uq
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|UMTX_UNLOCK
argument_list|()
expr_stmt|;
comment|/* 		 * If we caught a signal we might have to retry or exit  		 * immediately. 		 */
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_umtx_unlock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_unlock_args
modifier|*
name|uap
parameter_list|)
comment|/* struct umtx *umtx */
block|{
name|struct
name|thread
modifier|*
name|blocked
decl_stmt|;
name|struct
name|umtx
modifier|*
name|umtx
decl_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|intptr_t
name|owner
decl_stmt|;
name|intptr_t
name|old
decl_stmt|;
name|umtx
operator|=
name|uap
operator|->
name|umtx
expr_stmt|;
comment|/* 	 * Make sure we own this mtx. 	 * 	 * XXX Need a {fu,su}ptr this is not correct on arch where 	 * sizeof(intptr_t) != sizeof(long). 	 */
if|if
condition|(
operator|(
name|owner
operator|=
name|fuword
argument_list|(
operator|&
name|umtx
operator|->
name|u_owner
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
operator|(
expr|struct
name|thread
operator|*
operator|)
operator|(
name|owner
operator|&
operator|~
name|UMTX_CONTESTED
operator|)
operator|!=
name|td
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* We should only ever be in here for contested locks */
name|KASSERT
argument_list|(
operator|(
name|owner
operator|&
name|UMTX_CONTESTED
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"contested umtx is not."
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * When unlocking the umtx, it must be marked as unowned if 	 * there is zero or one thread only waiting for it. 	 * Otherwise, it must be marked as contested. 	 */
name|UMTX_LOCK
argument_list|()
expr_stmt|;
name|uq
operator|=
name|umtx_lookup
argument_list|(
name|td
argument_list|,
name|umtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq
operator|==
name|NULL
operator|||
operator|(
name|uq
operator|!=
name|NULL
operator|&&
operator|(
name|blocked
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|uq
operator|->
name|uq_tdq
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|TAILQ_NEXT
argument_list|(
name|blocked
argument_list|,
name|td_umtx
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|UMTX_UNLOCK
argument_list|()
expr_stmt|;
name|old
operator|=
name|casuptr
argument_list|(
operator|(
name|intptr_t
operator|*
operator|)
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
name|owner
argument_list|,
name|UMTX_UNOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|KASSERT
argument_list|(
name|old
operator|!=
name|owner
argument_list|,
operator|(
literal|"improper umtx access"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Recheck the umtx queue to make sure another thread 		 * didn't put itself on it after it was unlocked. 		 */
name|UMTX_LOCK
argument_list|()
expr_stmt|;
name|uq
operator|=
name|umtx_lookup
argument_list|(
name|td
argument_list|,
name|umtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|blocked
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|uq
operator|->
name|uq_tdq
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|TAILQ_NEXT
argument_list|(
name|blocked
argument_list|,
name|td_umtx
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
name|old
operator|=
name|casuptr
argument_list|(
operator|(
name|intptr_t
operator|*
operator|)
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
name|UMTX_UNOWNED
argument_list|,
name|UMTX_CONTESTED
argument_list|)
expr_stmt|;
name|UMTX_UNLOCK
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|UMTX_UNLOCK
argument_list|()
expr_stmt|;
name|old
operator|=
name|casuptr
argument_list|(
operator|(
name|intptr_t
operator|*
operator|)
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
name|owner
argument_list|,
name|UMTX_CONTESTED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|old
operator|!=
operator|-
literal|1
operator|&&
name|old
operator|!=
name|owner
argument_list|,
operator|(
literal|"improper umtx access"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* 	 * If there is a thread waiting on the umtx, wake it up. 	 */
if|if
condition|(
name|blocked
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|blocked
operator|->
name|td_flags
operator||=
name|TDF_UMTXWAKEUP
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|blocked
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

