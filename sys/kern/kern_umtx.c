begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002, Jeffrey Roberson<jeff@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/thr.h>
end_include

begin_include
include|#
directive|include
file|<sys/umtx.h>
end_include

begin_define
define|#
directive|define
name|UMTX_LOCK
parameter_list|()
value|mtx_lock(&umtx_lock);
end_define

begin_define
define|#
directive|define
name|UMTX_UNLOCK
parameter_list|()
value|mtx_unlock(&umtx_lock);
end_define

begin_decl_stmt
name|struct
name|mtx
name|umtx_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|umtx
argument_list|,
operator|&
name|umtx_lock
argument_list|,
literal|"User-land mutex lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|_umtx_lock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_lock_args
modifier|*
name|uap
parameter_list|)
comment|/* struct umtx *umtx */
block|{
name|struct
name|umtx
modifier|*
name|umtx
decl_stmt|;
name|struct
name|thread
modifier|*
name|blocked
decl_stmt|;
name|intptr_t
name|owner
decl_stmt|;
name|intptr_t
name|old
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Care must be exercised when dealing with this structure.  It 	 * can fault on any access. 	 */
name|umtx
operator|=
name|uap
operator|->
name|umtx
expr_stmt|;
name|UMTX_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Try the uncontested case.  This should be done in userland. 		 */
name|owner
operator|=
name|casuptr
argument_list|(
operator|(
name|intptr_t
operator|*
operator|)
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
name|UMTX_UNOWNED
argument_list|,
operator|(
name|intptr_t
operator|)
name|td
argument_list|)
expr_stmt|;
comment|/* The acquire succeeded. */
if|if
condition|(
name|owner
operator|==
name|UMTX_UNOWNED
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|owner
operator|&
name|UMTX_CONTESTED
condition|)
break|break;
comment|/* 		 * Set the contested bit so that a release in user space 		 * knows to use the system call for unlock.  If this fails 		 * either some one else has acquired the lock or it has been 		 * released. 		 */
name|old
operator|=
name|casuptr
argument_list|(
operator|(
name|intptr_t
operator|*
operator|)
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
name|owner
argument_list|,
name|owner
operator||
name|UMTX_CONTESTED
argument_list|)
expr_stmt|;
comment|/* We set the contested bit. */
if|if
condition|(
name|old
operator|==
name|owner
condition|)
break|break;
comment|/* The address was invalid. */
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* We didn't set the contested bit, try again. */
block|}
comment|/* 	 * We are now protected from further races via umtx_lock. 	 * If userland messes with their mutex without using cmpset 	 * they will deadlock themselves but they will still be 	 * killable via signals. 	 */
if|if
condition|(
operator|(
name|owner
operator|=
name|fuword
argument_list|(
operator|&
name|umtx
operator|->
name|u_blocked
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|owner
operator|==
name|UMTX_UNOWNED
condition|)
block|{
if|if
condition|(
name|suword
argument_list|(
operator|&
name|umtx
operator|->
name|u_blocked
argument_list|,
operator|(
name|long
operator|)
name|td
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Other blocked threads will reside here. 		 */
name|STAILQ_INIT
argument_list|(
operator|&
name|td
operator|->
name|td_umtxq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FOREACH_THREAD_IN_PROC
argument_list|(
argument|td->td_proc
argument_list|,
argument|blocked
argument_list|)
if|if
condition|(
name|blocked
operator|==
operator|(
expr|struct
name|thread
operator|*
operator|)
operator|(
name|owner
operator|)
condition|)
break|break;
if|if
condition|(
name|blocked
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Insert us onto the end of the TAILQ. 		 */
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|blocked
operator|->
name|td_umtxq
argument_list|,
name|td
argument_list|,
name|td_umtx
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Sleep until we can acquire the lock.  We must still deliver 		 * signals so that they are not deferred until we acquire the 		 * lock which may be never.  The threads actual priority is 		 * used to maintain proper ordering. 		 */
name|error
operator|=
name|msleep
argument_list|(
operator|&
name|td
operator|->
name|td_umtx
argument_list|,
operator|&
name|umtx_lock
argument_list|,
name|td
operator|->
name|td_priority
operator||
name|PCATCH
argument_list|,
literal|"umtx"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * When we are woken up we need to see if we now own the lock 		 * even if a signal was delivered. 		 */
if|if
condition|(
operator|(
name|owner
operator|=
name|fuword
argument_list|(
operator|&
name|umtx
operator|->
name|u_owner
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
name|owner
operator|&=
operator|~
name|UMTX_CONTESTED
expr_stmt|;
if|if
condition|(
operator|(
expr|struct
name|thread
operator|*
operator|)
name|owner
operator|==
name|td
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 		 * We may have signals to deliver. 		 */
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|out
label|:
name|UMTX_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_umtx_unlock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_unlock_args
modifier|*
name|uap
parameter_list|)
comment|/* struct umtx *umtx */
block|{
name|struct
name|thread
modifier|*
name|td0
decl_stmt|;
name|struct
name|umtx
modifier|*
name|umtx
decl_stmt|;
name|intptr_t
name|owner
decl_stmt|;
name|intptr_t
name|blocked
decl_stmt|;
name|intptr_t
name|old
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|umtx
operator|=
name|uap
operator|->
name|umtx
expr_stmt|;
name|UMTX_LOCK
argument_list|()
expr_stmt|;
comment|/* 	 * Make sure we own this mtx. 	 * 	 * XXX Need a {fu,su}ptr this is not correct on arch where 	 * sizeof(intptr_t) != sizeof(long). 	 */
if|if
condition|(
operator|(
name|owner
operator|=
name|fuword
argument_list|(
operator|&
name|umtx
operator|->
name|u_owner
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
expr|struct
name|thread
operator|*
operator|)
operator|(
name|owner
operator|&
operator|~
name|UMTX_CONTESTED
operator|)
operator|!=
name|td
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * If we own it but it isn't contested then we can just release and 	 * return. 	 */
if|if
condition|(
operator|(
name|owner
operator|&
name|UMTX_CONTESTED
operator|)
operator|==
literal|0
condition|)
block|{
name|owner
operator|=
name|casuptr
argument_list|(
operator|(
name|intptr_t
operator|*
operator|)
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
operator|(
name|intptr_t
operator|)
name|td
argument_list|,
name|UMTX_UNOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
name|error
operator|=
name|EFAULT
expr_stmt|;
comment|/* 		 * If this failed someone modified the memory without going 		 * through this api. 		 */
elseif|else
if|if
condition|(
name|owner
operator|!=
operator|(
name|intptr_t
operator|)
name|td
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Since we own the mutex and the proc lock we are free to inspect 	 * the blocked queue.  It must have one valid entry since the 	 * CONTESTED bit was set. 	 */
name|blocked
operator|=
name|fuword
argument_list|(
operator|&
name|umtx
operator|->
name|u_blocked
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocked
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|blocked
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|FOREACH_THREAD_IN_PROC
argument_list|(
argument|td->td_proc
argument_list|,
argument|td0
argument_list|)
if|if
condition|(
name|td0
operator|==
operator|(
expr|struct
name|thread
operator|*
operator|)
name|blocked
condition|)
break|break;
if|if
condition|(
name|td0
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|td0
operator|->
name|td_umtxq
argument_list|)
condition|)
block|{
name|struct
name|thread
modifier|*
name|next
decl_stmt|;
name|blocked
operator||=
name|UMTX_CONTESTED
expr_stmt|;
name|next
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|td0
operator|->
name|td_umtxq
argument_list|)
expr_stmt|;
if|if
condition|(
name|suword
argument_list|(
operator|&
name|umtx
operator|->
name|u_blocked
argument_list|,
operator|(
name|long
operator|)
name|next
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|td0
operator|->
name|td_umtxq
argument_list|,
name|td_umtx
argument_list|)
expr_stmt|;
comment|/* 		 * Switch the queue over to the next blocked thread. 		 */
if|if
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|td0
operator|->
name|td_umtxq
argument_list|)
condition|)
block|{
name|next
operator|->
name|td_umtxq
operator|=
name|td0
operator|->
name|td_umtxq
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|td0
operator|->
name|td_umtxq
argument_list|)
expr_stmt|;
block|}
else|else
name|STAILQ_INIT
argument_list|(
operator|&
name|next
operator|->
name|td_umtxq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|suword
argument_list|(
operator|&
name|umtx
operator|->
name|u_blocked
argument_list|,
name|UMTX_UNOWNED
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * Now directly assign this mutex to the first thread that was 	 * blocked on it. 	 */
name|old
operator|=
name|casuptr
argument_list|(
operator|(
name|intptr_t
operator|*
operator|)
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
name|owner
argument_list|,
name|blocked
argument_list|)
expr_stmt|;
comment|/* 	 * This will only happen if someone modifies the lock without going 	 * through this api. 	 */
if|if
condition|(
name|old
operator|!=
name|owner
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Success. */
name|error
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|td0
operator|->
name|td_umtx
argument_list|)
expr_stmt|;
name|out
label|:
name|UMTX_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

