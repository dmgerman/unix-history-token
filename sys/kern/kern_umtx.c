begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004, David Xu<davidxu@freebsd.org>  * Copyright (c) 2002, Jeffrey Roberson<jeff@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_umtx_profiling.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/umtx.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
end_ifdef

begin_include
include|#
directive|include
file|<compat/freebsd32/freebsd32_proto.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|_UMUTEX_TRY
value|1
end_define

begin_define
define|#
directive|define
name|_UMUTEX_WAIT
value|2
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|UMTX_PROFILING
end_ifdef

begin_define
define|#
directive|define
name|UPROF_PERC_BIGGER
parameter_list|(
name|w
parameter_list|,
name|f
parameter_list|,
name|sw
parameter_list|,
name|sf
parameter_list|)
define|\
value|(((w)> (sw)) || ((w) == (sw)&& (f)> (sf)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Priority inheritance mutex info. */
end_comment

begin_struct
struct|struct
name|umtx_pi
block|{
comment|/* Owner thread */
name|struct
name|thread
modifier|*
name|pi_owner
decl_stmt|;
comment|/* Reference count */
name|int
name|pi_refcount
decl_stmt|;
comment|/* List entry to link umtx holding by thread */
name|TAILQ_ENTRY
argument_list|(
argument|umtx_pi
argument_list|)
name|pi_link
expr_stmt|;
comment|/* List entry in hash */
name|TAILQ_ENTRY
argument_list|(
argument|umtx_pi
argument_list|)
name|pi_hashlink
expr_stmt|;
comment|/* List for waiters */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|umtx_q
argument_list|)
name|pi_blocked
expr_stmt|;
comment|/* Identify a userland lock object */
name|struct
name|umtx_key
name|pi_key
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A userland synchronous object user. */
end_comment

begin_struct
struct|struct
name|umtx_q
block|{
comment|/* Linked list for the hash. */
name|TAILQ_ENTRY
argument_list|(
argument|umtx_q
argument_list|)
name|uq_link
expr_stmt|;
comment|/* Umtx key. */
name|struct
name|umtx_key
name|uq_key
decl_stmt|;
comment|/* Umtx flags. */
name|int
name|uq_flags
decl_stmt|;
define|#
directive|define
name|UQF_UMTXQ
value|0x0001
comment|/* The thread waits on. */
name|struct
name|thread
modifier|*
name|uq_thread
decl_stmt|;
comment|/* 	 * Blocked on PI mutex. read can use chain lock 	 * or umtx_lock, write must have both chain lock and 	 * umtx_lock being hold. 	 */
name|struct
name|umtx_pi
modifier|*
name|uq_pi_blocked
decl_stmt|;
comment|/* On blocked list */
name|TAILQ_ENTRY
argument_list|(
argument|umtx_q
argument_list|)
name|uq_lockq
expr_stmt|;
comment|/* Thread contending with us */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|umtx_pi
argument_list|)
name|uq_pi_contested
expr_stmt|;
comment|/* Inherited priority from PP mutex */
name|u_char
name|uq_inherited_pri
decl_stmt|;
comment|/* Spare queue ready to be reused */
name|struct
name|umtxq_queue
modifier|*
name|uq_spare_queue
decl_stmt|;
comment|/* The queue we on */
name|struct
name|umtxq_queue
modifier|*
name|uq_cur_queue
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|umtxq_head
argument_list|,
name|umtx_q
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Per-key wait-queue */
end_comment

begin_struct
struct|struct
name|umtxq_queue
block|{
name|struct
name|umtxq_head
name|head
decl_stmt|;
name|struct
name|umtx_key
name|key
decl_stmt|;
name|LIST_ENTRY
argument_list|(
argument|umtxq_queue
argument_list|)
name|link
expr_stmt|;
name|int
name|length
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|umtxq_list
argument_list|,
name|umtxq_queue
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Userland lock object's wait-queue chain */
end_comment

begin_struct
struct|struct
name|umtxq_chain
block|{
comment|/* Lock for this chain. */
name|struct
name|mtx
name|uc_lock
decl_stmt|;
comment|/* List of sleep queues. */
name|struct
name|umtxq_list
name|uc_queue
index|[
literal|2
index|]
decl_stmt|;
define|#
directive|define
name|UMTX_SHARED_QUEUE
value|0
define|#
directive|define
name|UMTX_EXCLUSIVE_QUEUE
value|1
name|LIST_HEAD
argument_list|(
argument_list|,
argument|umtxq_queue
argument_list|)
name|uc_spare_queue
expr_stmt|;
comment|/* Busy flag */
name|char
name|uc_busy
decl_stmt|;
comment|/* Chain lock waiters */
name|int
name|uc_waiters
decl_stmt|;
comment|/* All PI in the list */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|umtx_pi
argument_list|)
name|uc_pi_list
expr_stmt|;
ifdef|#
directive|ifdef
name|UMTX_PROFILING
name|u_int
name|length
decl_stmt|;
name|u_int
name|max_length
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|UMTXQ_LOCKED_ASSERT
parameter_list|(
name|uc
parameter_list|)
value|mtx_assert(&(uc)->uc_lock, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|UMTXQ_BUSY_ASSERT
parameter_list|(
name|uc
parameter_list|)
value|KASSERT(&(uc)->uc_busy, ("umtx chain is not busy"))
end_define

begin_comment
comment|/*  * Don't propagate time-sharing priority, there is a security reason,  * a user can simply introduce PI-mutex, let thread A lock the mutex,  * and let another thread B block on the mutex, because B is  * sleeping, its priority will be boosted, this causes A's priority to  * be boosted via priority propagating too and will never be lowered even  * if it is using 100%CPU, this is unfair to other processes.  */
end_comment

begin_define
define|#
directive|define
name|UPRI
parameter_list|(
name|td
parameter_list|)
value|(((td)->td_user_pri>= PRI_MIN_TIMESHARE&&\ 			  (td)->td_user_pri<= PRI_MAX_TIMESHARE) ?\ 			 PRI_MAX_TIMESHARE : (td)->td_user_pri)
end_define

begin_define
define|#
directive|define
name|GOLDEN_RATIO_PRIME
value|2654404609U
end_define

begin_define
define|#
directive|define
name|UMTX_CHAINS
value|512
end_define

begin_define
define|#
directive|define
name|UMTX_SHIFTS
value|(__WORD_BIT - 9)
end_define

begin_define
define|#
directive|define
name|GET_SHARE
parameter_list|(
name|flags
parameter_list|)
define|\
value|(((flags)& USYNC_PROCESS_SHARED) == 0 ? THREAD_SHARE : PROCESS_SHARE)
end_define

begin_define
define|#
directive|define
name|BUSY_SPINS
value|200
end_define

begin_struct
struct|struct
name|abs_timeout
block|{
name|int
name|clockid
decl_stmt|;
name|struct
name|timespec
name|cur
decl_stmt|;
name|struct
name|timespec
name|end
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|uma_zone_t
name|umtx_pi_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|umtxq_chain
name|umtxq_chains
index|[
literal|2
index|]
index|[
name|UMTX_CHAINS
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_UMTX
argument_list|,
literal|"umtx"
argument_list|,
literal|"UMTX queue memory"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|umtx_pi_allocated
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|umtx
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"umtx debug"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_umtx
argument_list|,
name|OID_AUTO
argument_list|,
name|umtx_pi_allocated
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|umtx_pi_allocated
argument_list|,
literal|0
argument_list|,
literal|"Allocated umtx_pi"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|UMTX_PROFILING
end_ifdef

begin_decl_stmt
specifier|static
name|long
name|max_length
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_debug_umtx
argument_list|,
name|OID_AUTO
argument_list|,
name|max_length
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|max_length
argument_list|,
literal|0
argument_list|,
literal|"max_length"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_debug_umtx
argument_list|,
name|OID_AUTO
argument_list|,
name|chains
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"umtx chain stats"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|umtxq_sysinit
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtxq_hash
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|umtxq_chain
modifier|*
name|umtxq_getchain
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtxq_lock
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtxq_unlock
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtxq_busy
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtxq_unbusy
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtxq_insert_queue
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|,
name|int
name|q
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtxq_remove_queue
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|,
name|int
name|q
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|umtxq_sleep
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|,
specifier|const
name|char
modifier|*
name|wmesg
parameter_list|,
name|struct
name|abs_timeout
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|umtxq_count
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|umtx_pi
modifier|*
name|umtx_pi_alloc
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtx_pi_free
parameter_list|(
name|struct
name|umtx_pi
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_unlock_pp
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtx_thread_cleanup
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtx_exec_hook
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|proc
modifier|*
name|p
name|__unused
parameter_list|,
name|struct
name|image_params
modifier|*
name|imgp
name|__unused
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSINIT
argument_list|(
name|umtx
argument_list|,
name|SI_SUB_EVENTHANDLER
operator|+
literal|1
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|umtxq_sysinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|umtxq_signal
parameter_list|(
name|key
parameter_list|,
name|nwake
parameter_list|)
value|umtxq_signal_queue((key), (nwake), UMTX_SHARED_QUEUE)
end_define

begin_define
define|#
directive|define
name|umtxq_insert
parameter_list|(
name|uq
parameter_list|)
value|umtxq_insert_queue((uq), UMTX_SHARED_QUEUE)
end_define

begin_define
define|#
directive|define
name|umtxq_remove
parameter_list|(
name|uq
parameter_list|)
value|umtxq_remove_queue((uq), UMTX_SHARED_QUEUE)
end_define

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|umtx_lock
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|UMTX_PROFILING
end_ifdef

begin_function
specifier|static
name|void
name|umtx_init_profiling
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sysctl_oid
modifier|*
name|chain_oid
decl_stmt|;
name|char
name|chain_name
index|[
literal|10
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UMTX_CHAINS
condition|;
operator|++
name|i
control|)
block|{
name|snprintf
argument_list|(
name|chain_name
argument_list|,
sizeof|sizeof
argument_list|(
name|chain_name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|chain_oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|NULL
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_debug_umtx_chains
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|chain_name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"umtx hash stats"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|NULL
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|chain_oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"max_length0"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|umtxq_chains
index|[
literal|0
index|]
index|[
name|i
index|]
operator|.
name|max_length
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|NULL
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|chain_oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"max_length1"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|umtxq_chains
index|[
literal|1
index|]
index|[
name|i
index|]
operator|.
name|max_length
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_debug_umtx_chains_peaks
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|u_int
name|fract
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|tot
decl_stmt|,
name|whole
decl_stmt|;
name|u_int
name|sf0
decl_stmt|,
name|sf1
decl_stmt|,
name|sf2
decl_stmt|,
name|sf3
decl_stmt|,
name|sf4
decl_stmt|;
name|u_int
name|si0
decl_stmt|,
name|si1
decl_stmt|,
name|si2
decl_stmt|,
name|si3
decl_stmt|,
name|si4
decl_stmt|;
name|u_int
name|sw0
decl_stmt|,
name|sw1
decl_stmt|,
name|sw2
decl_stmt|,
name|sw3
decl_stmt|,
name|sw4
decl_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|tot
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|UMTX_CHAINS
condition|;
operator|++
name|j
control|)
block|{
name|uc
operator|=
operator|&
name|umtxq_chains
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|uc
operator|->
name|uc_lock
argument_list|)
expr_stmt|;
name|tot
operator|+=
name|uc
operator|->
name|max_length
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|uc
operator|->
name|uc_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tot
operator|==
literal|0
condition|)
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%u) Empty "
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
block|{
name|sf0
operator|=
name|sf1
operator|=
name|sf2
operator|=
name|sf3
operator|=
name|sf4
operator|=
literal|0
expr_stmt|;
name|si0
operator|=
name|si1
operator|=
name|si2
operator|=
name|si3
operator|=
name|si4
operator|=
literal|0
expr_stmt|;
name|sw0
operator|=
name|sw1
operator|=
name|sw2
operator|=
name|sw3
operator|=
name|sw4
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|UMTX_CHAINS
condition|;
name|j
operator|++
control|)
block|{
name|uc
operator|=
operator|&
name|umtxq_chains
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|uc
operator|->
name|uc_lock
argument_list|)
expr_stmt|;
name|whole
operator|=
name|uc
operator|->
name|max_length
operator|*
literal|100
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|uc
operator|->
name|uc_lock
argument_list|)
expr_stmt|;
name|fract
operator|=
operator|(
name|whole
operator|%
name|tot
operator|)
operator|*
literal|100
expr_stmt|;
if|if
condition|(
name|UPROF_PERC_BIGGER
argument_list|(
name|whole
argument_list|,
name|fract
argument_list|,
name|sw0
argument_list|,
name|sf0
argument_list|)
condition|)
block|{
name|sf0
operator|=
name|fract
expr_stmt|;
name|si0
operator|=
name|j
expr_stmt|;
name|sw0
operator|=
name|whole
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|UPROF_PERC_BIGGER
argument_list|(
name|whole
argument_list|,
name|fract
argument_list|,
name|sw1
argument_list|,
name|sf1
argument_list|)
condition|)
block|{
name|sf1
operator|=
name|fract
expr_stmt|;
name|si1
operator|=
name|j
expr_stmt|;
name|sw1
operator|=
name|whole
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|UPROF_PERC_BIGGER
argument_list|(
name|whole
argument_list|,
name|fract
argument_list|,
name|sw2
argument_list|,
name|sf2
argument_list|)
condition|)
block|{
name|sf2
operator|=
name|fract
expr_stmt|;
name|si2
operator|=
name|j
expr_stmt|;
name|sw2
operator|=
name|whole
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|UPROF_PERC_BIGGER
argument_list|(
name|whole
argument_list|,
name|fract
argument_list|,
name|sw3
argument_list|,
name|sf3
argument_list|)
condition|)
block|{
name|sf3
operator|=
name|fract
expr_stmt|;
name|si3
operator|=
name|j
expr_stmt|;
name|sw3
operator|=
name|whole
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|UPROF_PERC_BIGGER
argument_list|(
name|whole
argument_list|,
name|fract
argument_list|,
name|sw4
argument_list|,
name|sf4
argument_list|)
condition|)
block|{
name|sf4
operator|=
name|fract
expr_stmt|;
name|si4
operator|=
name|j
expr_stmt|;
name|sw4
operator|=
name|whole
expr_stmt|;
block|}
block|}
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"queue %u:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"1st: %u.%u%% idx: %u\n"
argument_list|,
name|sw0
operator|/
name|tot
argument_list|,
name|sf0
operator|/
name|tot
argument_list|,
name|si0
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"2nd: %u.%u%% idx: %u\n"
argument_list|,
name|sw1
operator|/
name|tot
argument_list|,
name|sf1
operator|/
name|tot
argument_list|,
name|si1
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"3rd: %u.%u%% idx: %u\n"
argument_list|,
name|sw2
operator|/
name|tot
argument_list|,
name|sf2
operator|/
name|tot
argument_list|,
name|si2
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"4th: %u.%u%% idx: %u\n"
argument_list|,
name|sw3
operator|/
name|tot
argument_list|,
name|sf3
operator|/
name|tot
argument_list|,
name|si3
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"5th: %u.%u%% idx: %u\n"
argument_list|,
name|sw4
operator|/
name|tot
argument_list|,
name|sf4
operator|/
name|tot
argument_list|,
name|si4
argument_list|)
expr_stmt|;
block|}
block|}
name|sbuf_trim
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_debug_umtx_chains_clear
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|clear
decl_stmt|,
name|error
decl_stmt|;
name|clear
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|clear
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|clear
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|UMTX_CHAINS
condition|;
operator|++
name|j
control|)
block|{
name|uc
operator|=
operator|&
name|umtxq_chains
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|uc
operator|->
name|uc_lock
argument_list|)
expr_stmt|;
name|uc
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|uc
operator|->
name|max_length
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|uc
operator|->
name|uc_lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_debug_umtx_chains
argument_list|,
name|OID_AUTO
argument_list|,
name|clear
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_debug_umtx_chains_clear
argument_list|,
literal|"I"
argument_list|,
literal|"Clear umtx chains statistics"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_debug_umtx_chains
argument_list|,
name|OID_AUTO
argument_list|,
name|peaks
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_debug_umtx_chains_peaks
argument_list|,
literal|"A"
argument_list|,
literal|"Highest peaks in chains max length"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|umtxq_sysinit
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|umtx_pi_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"umtx pi"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|umtx_pi
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|UMTX_CHAINS
condition|;
operator|++
name|j
control|)
block|{
name|mtx_init
argument_list|(
operator|&
name|umtxq_chains
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|uc_lock
argument_list|,
literal|"umtxql"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_DUPOK
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|umtxq_chains
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|uc_queue
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|umtxq_chains
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|uc_queue
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|umtxq_chains
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|uc_spare_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|umtxq_chains
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|uc_pi_list
argument_list|)
expr_stmt|;
name|umtxq_chains
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|uc_busy
operator|=
literal|0
expr_stmt|;
name|umtxq_chains
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|uc_waiters
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|UMTX_PROFILING
name|umtxq_chains
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|umtxq_chains
index|[
name|i
index|]
index|[
name|j
index|]
operator|.
name|max_length
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
block|}
ifdef|#
directive|ifdef
name|UMTX_PROFILING
name|umtx_init_profiling
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|mtx_init
argument_list|(
operator|&
name|umtx_lock
argument_list|,
literal|"umtx lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|EVENTHANDLER_REGISTER
argument_list|(
name|process_exec
argument_list|,
name|umtx_exec_hook
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|umtx_q
modifier|*
name|umtxq_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|uq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|umtx_q
argument_list|)
argument_list|,
name|M_UMTX
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|uq
operator|->
name|uq_spare_queue
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|umtxq_queue
argument_list|)
argument_list|,
name|M_UMTX
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|uq
operator|->
name|uq_spare_queue
operator|->
name|head
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|uq
operator|->
name|uq_pi_contested
argument_list|)
expr_stmt|;
name|uq
operator|->
name|uq_inherited_pri
operator|=
name|PRI_MAX
expr_stmt|;
return|return
operator|(
name|uq
operator|)
return|;
block|}
end_function

begin_function
name|void
name|umtxq_free
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|)
block|{
name|MPASS
argument_list|(
name|uq
operator|->
name|uq_spare_queue
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|uq
operator|->
name|uq_spare_queue
argument_list|,
name|M_UMTX
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|uq
argument_list|,
name|M_UMTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|umtxq_hash
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
name|unsigned
name|n
init|=
operator|(
name|uintptr_t
operator|)
name|key
operator|->
name|info
operator|.
name|both
operator|.
name|a
operator|+
name|key
operator|->
name|info
operator|.
name|both
operator|.
name|b
decl_stmt|;
name|key
operator|->
name|hash
operator|=
operator|(
operator|(
name|n
operator|*
name|GOLDEN_RATIO_PRIME
operator|)
operator|>>
name|UMTX_SHIFTS
operator|)
operator|%
name|UMTX_CHAINS
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|umtxq_chain
modifier|*
name|umtxq_getchain
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|->
name|type
operator|<=
name|TYPE_SEM
condition|)
return|return
operator|(
operator|&
name|umtxq_chains
index|[
literal|1
index|]
index|[
name|key
operator|->
name|hash
index|]
operator|)
return|;
return|return
operator|(
operator|&
name|umtxq_chains
index|[
literal|0
index|]
index|[
name|key
operator|->
name|hash
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock a chain.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|umtxq_lock
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|uc
operator|->
name|uc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unlock a chain.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|umtxq_unlock
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|uc
operator|->
name|uc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set chain to busy state when following operation  * may be blocked (kernel mutex can not be used).  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|umtxq_busy
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|uc
operator|->
name|uc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|uc
operator|->
name|uc_busy
condition|)
block|{
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|smp_cpus
operator|>
literal|1
condition|)
block|{
name|int
name|count
init|=
name|BUSY_SPINS
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|umtxq_unlock
argument_list|(
name|key
argument_list|)
expr_stmt|;
while|while
condition|(
name|uc
operator|->
name|uc_busy
operator|&&
operator|--
name|count
operator|>
literal|0
condition|)
name|cpu_spinwait
argument_list|()
expr_stmt|;
name|umtxq_lock
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
while|while
condition|(
name|uc
operator|->
name|uc_busy
condition|)
block|{
name|uc
operator|->
name|uc_waiters
operator|++
expr_stmt|;
name|msleep
argument_list|(
name|uc
argument_list|,
operator|&
name|uc
operator|->
name|uc_lock
argument_list|,
literal|0
argument_list|,
literal|"umtxqb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uc
operator|->
name|uc_waiters
operator|--
expr_stmt|;
block|}
block|}
name|uc
operator|->
name|uc_busy
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unbusy a chain.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|umtxq_unbusy
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|uc
operator|->
name|uc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|uc
operator|->
name|uc_busy
operator|!=
literal|0
argument_list|,
operator|(
literal|"not busy"
operator|)
argument_list|)
expr_stmt|;
name|uc
operator|->
name|uc_busy
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|uc
operator|->
name|uc_waiters
condition|)
name|wakeup_one
argument_list|(
name|uc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|umtxq_queue
modifier|*
name|umtxq_queue_lookup
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|struct
name|umtxq_queue
modifier|*
name|uh
decl_stmt|;
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|uh
argument_list|,
argument|&uc->uc_queue[q]
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|umtx_key_match
argument_list|(
operator|&
name|uh
operator|->
name|key
argument_list|,
name|key
argument_list|)
condition|)
return|return
operator|(
name|uh
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|umtxq_insert_queue
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|struct
name|umtxq_queue
modifier|*
name|uh
decl_stmt|;
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|uq
operator|->
name|uq_flags
operator|&
name|UQF_UMTXQ
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"umtx_q is already on queue"
operator|)
argument_list|)
expr_stmt|;
name|uh
operator|=
name|umtxq_queue_lookup
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|uh
operator|!=
name|NULL
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|uc
operator|->
name|uc_spare_queue
argument_list|,
name|uq
operator|->
name|uq_spare_queue
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uh
operator|=
name|uq
operator|->
name|uq_spare_queue
expr_stmt|;
name|uh
operator|->
name|key
operator|=
name|uq
operator|->
name|uq_key
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|uc
operator|->
name|uc_queue
index|[
name|q
index|]
argument_list|,
name|uh
argument_list|,
name|link
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UMTX_PROFILING
name|uc
operator|->
name|length
operator|++
expr_stmt|;
if|if
condition|(
name|uc
operator|->
name|length
operator|>
name|uc
operator|->
name|max_length
condition|)
block|{
name|uc
operator|->
name|max_length
operator|=
name|uc
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|uc
operator|->
name|max_length
operator|>
name|max_length
condition|)
name|max_length
operator|=
name|uc
operator|->
name|max_length
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|uq
operator|->
name|uq_spare_queue
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|uh
operator|->
name|head
argument_list|,
name|uq
argument_list|,
name|uq_link
argument_list|)
expr_stmt|;
name|uh
operator|->
name|length
operator|++
expr_stmt|;
name|uq
operator|->
name|uq_flags
operator||=
name|UQF_UMTXQ
expr_stmt|;
name|uq
operator|->
name|uq_cur_queue
operator|=
name|uh
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|umtxq_remove_queue
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|struct
name|umtxq_queue
modifier|*
name|uh
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq
operator|->
name|uq_flags
operator|&
name|UQF_UMTXQ
condition|)
block|{
name|uh
operator|=
name|uq
operator|->
name|uq_cur_queue
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|uh
operator|->
name|head
argument_list|,
name|uq
argument_list|,
name|uq_link
argument_list|)
expr_stmt|;
name|uh
operator|->
name|length
operator|--
expr_stmt|;
name|uq
operator|->
name|uq_flags
operator|&=
operator|~
name|UQF_UMTXQ
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|uh
operator|->
name|head
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
name|uh
operator|->
name|length
operator|==
literal|0
argument_list|,
operator|(
literal|"inconsistent umtxq_queue length"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UMTX_PROFILING
name|uc
operator|->
name|length
operator|--
expr_stmt|;
endif|#
directive|endif
name|LIST_REMOVE
argument_list|(
name|uh
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uh
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|uc
operator|->
name|uc_spare_queue
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|uh
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uc_spare_queue is empty"
operator|)
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|uh
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|uq
operator|->
name|uq_spare_queue
operator|=
name|uh
expr_stmt|;
name|uq
operator|->
name|uq_cur_queue
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check if there are multiple waiters  */
end_comment

begin_function
specifier|static
name|int
name|umtxq_count
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|struct
name|umtxq_queue
modifier|*
name|uh
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|uh
operator|=
name|umtxq_queue_lookup
argument_list|(
name|key
argument_list|,
name|UMTX_SHARED_QUEUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|uh
operator|!=
name|NULL
condition|)
return|return
operator|(
name|uh
operator|->
name|length
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if there are multiple PI waiters and returns first  * waiter.  */
end_comment

begin_function
specifier|static
name|int
name|umtxq_count_pi
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|,
name|struct
name|umtx_q
modifier|*
modifier|*
name|first
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|struct
name|umtxq_queue
modifier|*
name|uh
decl_stmt|;
operator|*
name|first
operator|=
name|NULL
expr_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|uh
operator|=
name|umtxq_queue_lookup
argument_list|(
name|key
argument_list|,
name|UMTX_SHARED_QUEUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|uh
operator|!=
name|NULL
condition|)
block|{
operator|*
name|first
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|uh
operator|->
name|head
argument_list|)
expr_stmt|;
return|return
operator|(
name|uh
operator|->
name|length
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|umtxq_check_susp
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * The check for TDF_NEEDSUSPCHK is racy, but it is enough to 	 * eventually break the lockstep loop. 	 */
if|if
condition|(
operator|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_NEEDSUSPCHK
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|P_SHOULDSTOP
argument_list|(
name|p
argument_list|)
operator|||
operator|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_TRACED
operator|)
operator|&&
operator|(
name|td
operator|->
name|td_dbgflags
operator|&
name|TDB_SUSPEND
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_SINGLE_EXIT
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
else|else
name|error
operator|=
name|ERESTART
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wake up threads waiting on an userland object.  */
end_comment

begin_function
specifier|static
name|int
name|umtxq_signal_queue
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|,
name|int
name|n_wake
parameter_list|,
name|int
name|q
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|struct
name|umtxq_queue
modifier|*
name|uh
decl_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|uh
operator|=
name|umtxq_queue_lookup
argument_list|(
name|key
argument_list|,
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|uh
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|uq
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|uh
operator|->
name|head
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|umtxq_remove_queue
argument_list|(
name|uq
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|uq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|ret
operator|>=
name|n_wake
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wake up specified thread.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|umtxq_signal_thread
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|uq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|tstohz
parameter_list|(
specifier|const
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|,
name|tsp
argument_list|)
expr_stmt|;
return|return
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|abs_timeout_init
parameter_list|(
name|struct
name|abs_timeout
modifier|*
name|timo
parameter_list|,
name|int
name|clockid
parameter_list|,
name|int
name|absolute
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|)
block|{
name|timo
operator|->
name|clockid
operator|=
name|clockid
expr_stmt|;
if|if
condition|(
operator|!
name|absolute
condition|)
block|{
name|kern_clock_gettime
argument_list|(
name|curthread
argument_list|,
name|clockid
argument_list|,
operator|&
name|timo
operator|->
name|end
argument_list|)
expr_stmt|;
name|timo
operator|->
name|cur
operator|=
name|timo
operator|->
name|end
expr_stmt|;
name|timespecadd
argument_list|(
operator|&
name|timo
operator|->
name|end
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|timo
operator|->
name|end
operator|=
operator|*
name|timeout
expr_stmt|;
name|kern_clock_gettime
argument_list|(
name|curthread
argument_list|,
name|clockid
argument_list|,
operator|&
name|timo
operator|->
name|cur
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|abs_timeout_init2
parameter_list|(
name|struct
name|abs_timeout
modifier|*
name|timo
parameter_list|,
specifier|const
name|struct
name|_umtx_time
modifier|*
name|umtxtime
parameter_list|)
block|{
name|abs_timeout_init
argument_list|(
name|timo
argument_list|,
name|umtxtime
operator|->
name|_clockid
argument_list|,
operator|(
name|umtxtime
operator|->
name|_flags
operator|&
name|UMTX_ABSTIME
operator|)
operator|!=
literal|0
argument_list|,
operator|&
name|umtxtime
operator|->
name|_timeout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|abs_timeout_update
parameter_list|(
name|struct
name|abs_timeout
modifier|*
name|timo
parameter_list|)
block|{
name|kern_clock_gettime
argument_list|(
name|curthread
argument_list|,
name|timo
operator|->
name|clockid
argument_list|,
operator|&
name|timo
operator|->
name|cur
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|abs_timeout_gethz
parameter_list|(
name|struct
name|abs_timeout
modifier|*
name|timo
parameter_list|)
block|{
name|struct
name|timespec
name|tts
decl_stmt|;
if|if
condition|(
name|timespeccmp
argument_list|(
operator|&
name|timo
operator|->
name|end
argument_list|,
operator|&
name|timo
operator|->
name|cur
argument_list|,
operator|<=
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|tts
operator|=
name|timo
operator|->
name|end
expr_stmt|;
name|timespecsub
argument_list|(
operator|&
name|tts
argument_list|,
operator|&
name|timo
operator|->
name|cur
argument_list|)
expr_stmt|;
return|return
operator|(
name|tstohz
argument_list|(
operator|&
name|tts
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Put thread into sleep state, before sleeping, check if  * thread was removed from umtx queue.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|umtxq_sleep
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|,
specifier|const
name|char
modifier|*
name|wmesg
parameter_list|,
name|struct
name|abs_timeout
modifier|*
name|abstime
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|timo
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|uq
operator|->
name|uq_flags
operator|&
name|UQF_UMTXQ
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|abstime
operator|!=
name|NULL
condition|)
block|{
name|timo
operator|=
name|abs_timeout_gethz
argument_list|(
name|abstime
argument_list|)
expr_stmt|;
if|if
condition|(
name|timo
operator|<
literal|0
condition|)
return|return
operator|(
name|ETIMEDOUT
operator|)
return|;
block|}
else|else
name|timo
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
name|uq
argument_list|,
operator|&
name|uc
operator|->
name|uc_lock
argument_list|,
name|PCATCH
operator||
name|PDROP
argument_list|,
name|wmesg
argument_list|,
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EWOULDBLOCK
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|abstime
operator|!=
name|NULL
condition|)
name|abs_timeout_update
argument_list|(
name|abstime
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert userspace address into unique logical address.  */
end_comment

begin_function
name|int
name|umtx_key_get
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|share
parameter_list|,
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|boolean_t
name|wired
decl_stmt|;
name|key
operator|->
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|share
operator|==
name|THREAD_SHARE
condition|)
block|{
name|key
operator|->
name|shared
operator|=
literal|0
expr_stmt|;
name|key
operator|->
name|info
operator|.
name|private
operator|.
name|vs
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
expr_stmt|;
name|key
operator|->
name|info
operator|.
name|private
operator|.
name|addr
operator|=
operator|(
name|uintptr_t
operator|)
name|addr
expr_stmt|;
block|}
else|else
block|{
name|MPASS
argument_list|(
name|share
operator|==
name|PROCESS_SHARE
operator|||
name|share
operator|==
name|AUTO_SHARE
argument_list|)
expr_stmt|;
name|map
operator|=
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
if|if
condition|(
name|vm_map_lookup
argument_list|(
operator|&
name|map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|addr
argument_list|,
name|VM_PROT_WRITE
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|key
operator|->
name|info
operator|.
name|shared
operator|.
name|object
argument_list|,
operator|&
name|pindex
argument_list|,
operator|&
name|prot
argument_list|,
operator|&
name|wired
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
block|{
return|return
name|EFAULT
return|;
block|}
if|if
condition|(
operator|(
name|share
operator|==
name|PROCESS_SHARE
operator|)
operator|||
operator|(
name|share
operator|==
name|AUTO_SHARE
operator|&&
name|VM_INHERIT_SHARE
operator|==
name|entry
operator|->
name|inheritance
operator|)
condition|)
block|{
name|key
operator|->
name|shared
operator|=
literal|1
expr_stmt|;
name|key
operator|->
name|info
operator|.
name|shared
operator|.
name|offset
operator|=
name|entry
operator|->
name|offset
operator|+
name|entry
operator|->
name|start
operator|-
operator|(
name|vm_offset_t
operator|)
name|addr
expr_stmt|;
name|vm_object_reference
argument_list|(
name|key
operator|->
name|info
operator|.
name|shared
operator|.
name|object
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|key
operator|->
name|shared
operator|=
literal|0
expr_stmt|;
name|key
operator|->
name|info
operator|.
name|private
operator|.
name|vs
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
expr_stmt|;
name|key
operator|->
name|info
operator|.
name|private
operator|.
name|addr
operator|=
operator|(
name|uintptr_t
operator|)
name|addr
expr_stmt|;
block|}
name|vm_map_lookup_done
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|umtxq_hash
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release key.  */
end_comment

begin_function
name|void
name|umtx_key_release
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|->
name|shared
condition|)
name|vm_object_deallocate
argument_list|(
name|key
operator|->
name|info
operator|.
name|shared
operator|.
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lock a umtx object.  */
end_comment

begin_function
specifier|static
name|int
name|do_lock_umtx
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umtx
modifier|*
name|umtx
parameter_list|,
name|u_long
name|id
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|)
block|{
name|struct
name|abs_timeout
name|timo
decl_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|u_long
name|owner
decl_stmt|;
name|u_long
name|old
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
if|if
condition|(
name|timeout
operator|!=
name|NULL
condition|)
name|abs_timeout_init
argument_list|(
operator|&
name|timo
argument_list|,
name|CLOCK_REALTIME
argument_list|,
literal|0
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
comment|/* 	 * Care must be exercised when dealing with umtx structure. It 	 * can fault on any access. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Try the uncontested case.  This should be done in userland. 		 */
name|owner
operator|=
name|casuword
argument_list|(
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
name|UMTX_UNOWNED
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* The acquire succeeded. */
if|if
condition|(
name|owner
operator|==
name|UMTX_UNOWNED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* If no one owns it but it is contested try to acquire it. */
if|if
condition|(
name|owner
operator|==
name|UMTX_CONTESTED
condition|)
block|{
name|owner
operator|=
name|casuword
argument_list|(
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
name|UMTX_CONTESTED
argument_list|,
name|id
operator||
name|UMTX_CONTESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
name|UMTX_CONTESTED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|error
operator|=
name|umtxq_check_susp
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
comment|/* If this failed the lock has changed, restart. */
continue|continue;
block|}
comment|/* 		 * If we caught a signal, we have retried and now 		 * exit immediately. 		 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|umtx
argument_list|,
name|TYPE_SIMPLE_LOCK
argument_list|,
name|AUTO_SHARE
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_insert
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
comment|/* 		 * Set the contested bit so that a release in user space 		 * knows to use the system call for unlock.  If this fails 		 * either some one else has acquired the lock or it has been 		 * released. 		 */
name|old
operator|=
name|casuword
argument_list|(
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
name|owner
argument_list|,
name|owner
operator||
name|UMTX_CONTESTED
argument_list|)
expr_stmt|;
comment|/* The address was invalid. */
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
comment|/* 		 * We set the contested bit, sleep. Otherwise the lock changed 		 * and we need to retry or we lost a race to the thread 		 * unlocking the umtx. 		 */
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|owner
condition|)
name|error
operator|=
name|umtxq_sleep
argument_list|(
name|uq
argument_list|,
literal|"umtx"
argument_list|,
name|timeout
operator|==
name|NULL
condition|?
name|NULL
else|:
operator|&
name|timo
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|umtxq_check_susp
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|==
name|NULL
condition|)
block|{
comment|/* Mutex locking is restarted if it is interrupted. */
if|if
condition|(
name|error
operator|==
name|EINTR
condition|)
name|error
operator|=
name|ERESTART
expr_stmt|;
block|}
else|else
block|{
comment|/* Timed-locking is not restarted. */
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock a umtx object.  */
end_comment

begin_function
specifier|static
name|int
name|do_unlock_umtx
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umtx
modifier|*
name|umtx
parameter_list|,
name|u_long
name|id
parameter_list|)
block|{
name|struct
name|umtx_key
name|key
decl_stmt|;
name|u_long
name|owner
decl_stmt|;
name|u_long
name|old
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* 	 * Make sure we own this mtx. 	 */
name|owner
operator|=
name|fuword
argument_list|(
name|__DEVOLATILE
argument_list|(
name|u_long
operator|*
argument_list|,
operator|&
name|umtx
operator|->
name|u_owner
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
operator|(
name|owner
operator|&
operator|~
name|UMTX_CONTESTED
operator|)
operator|!=
name|id
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* This should be done in userland */
if|if
condition|(
operator|(
name|owner
operator|&
name|UMTX_CONTESTED
operator|)
operator|==
literal|0
condition|)
block|{
name|old
operator|=
name|casuword
argument_list|(
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
name|owner
argument_list|,
name|UMTX_UNOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|old
operator|==
name|owner
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|owner
operator|=
name|old
expr_stmt|;
block|}
comment|/* We should only ever be in here for contested locks */
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|umtx
argument_list|,
name|TYPE_SIMPLE_LOCK
argument_list|,
name|AUTO_SHARE
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|count
operator|=
name|umtxq_count
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
comment|/* 	 * When unlocking the umtx, it must be marked as unowned if 	 * there is zero or one thread only waiting for it. 	 * Otherwise, it must be marked as contested. 	 */
name|old
operator|=
name|casuword
argument_list|(
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
name|owner
argument_list|,
name|count
operator|<=
literal|1
condition|?
name|UMTX_UNOWNED
else|:
name|UMTX_CONTESTED
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_signal
argument_list|(
operator|&
name|key
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|old
operator|!=
name|owner
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
end_ifdef

begin_comment
comment|/*  * Lock a umtx object.  */
end_comment

begin_function
specifier|static
name|int
name|do_lock_umtx32
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|uint32_t
modifier|*
name|m
parameter_list|,
name|uint32_t
name|id
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|)
block|{
name|struct
name|abs_timeout
name|timo
decl_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|uint32_t
name|owner
decl_stmt|;
name|uint32_t
name|old
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
if|if
condition|(
name|timeout
operator|!=
name|NULL
condition|)
name|abs_timeout_init
argument_list|(
operator|&
name|timo
argument_list|,
name|CLOCK_REALTIME
argument_list|,
literal|0
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
comment|/* 	 * Care must be exercised when dealing with umtx structure. It 	 * can fault on any access. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Try the uncontested case.  This should be done in userland. 		 */
name|owner
operator|=
name|casuword32
argument_list|(
name|m
argument_list|,
name|UMUTEX_UNOWNED
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* The acquire succeeded. */
if|if
condition|(
name|owner
operator|==
name|UMUTEX_UNOWNED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* If no one owns it but it is contested try to acquire it. */
if|if
condition|(
name|owner
operator|==
name|UMUTEX_CONTESTED
condition|)
block|{
name|owner
operator|=
name|casuword32
argument_list|(
name|m
argument_list|,
name|UMUTEX_CONTESTED
argument_list|,
name|id
operator||
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
name|UMUTEX_CONTESTED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|error
operator|=
name|umtxq_check_susp
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
comment|/* If this failed the lock has changed, restart. */
continue|continue;
block|}
comment|/* 		 * If we caught a signal, we have retried and now 		 * exit immediately. 		 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|m
argument_list|,
name|TYPE_SIMPLE_LOCK
argument_list|,
name|AUTO_SHARE
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_insert
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
comment|/* 		 * Set the contested bit so that a release in user space 		 * knows to use the system call for unlock.  If this fails 		 * either some one else has acquired the lock or it has been 		 * released. 		 */
name|old
operator|=
name|casuword32
argument_list|(
name|m
argument_list|,
name|owner
argument_list|,
name|owner
operator||
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
comment|/* The address was invalid. */
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
comment|/* 		 * We set the contested bit, sleep. Otherwise the lock changed 		 * and we need to retry or we lost a race to the thread 		 * unlocking the umtx. 		 */
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|owner
condition|)
name|error
operator|=
name|umtxq_sleep
argument_list|(
name|uq
argument_list|,
literal|"umtx"
argument_list|,
name|timeout
operator|==
name|NULL
condition|?
name|NULL
else|:
operator|&
name|timo
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|umtxq_check_susp
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timeout
operator|==
name|NULL
condition|)
block|{
comment|/* Mutex locking is restarted if it is interrupted. */
if|if
condition|(
name|error
operator|==
name|EINTR
condition|)
name|error
operator|=
name|ERESTART
expr_stmt|;
block|}
else|else
block|{
comment|/* Timed-locking is not restarted. */
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock a umtx object.  */
end_comment

begin_function
specifier|static
name|int
name|do_unlock_umtx32
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|uint32_t
modifier|*
name|m
parameter_list|,
name|uint32_t
name|id
parameter_list|)
block|{
name|struct
name|umtx_key
name|key
decl_stmt|;
name|uint32_t
name|owner
decl_stmt|;
name|uint32_t
name|old
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* 	 * Make sure we own this mtx. 	 */
name|owner
operator|=
name|fuword32
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|!=
name|id
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* This should be done in userland */
if|if
condition|(
operator|(
name|owner
operator|&
name|UMUTEX_CONTESTED
operator|)
operator|==
literal|0
condition|)
block|{
name|old
operator|=
name|casuword32
argument_list|(
name|m
argument_list|,
name|owner
argument_list|,
name|UMUTEX_UNOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|old
operator|==
name|owner
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|owner
operator|=
name|old
expr_stmt|;
block|}
comment|/* We should only ever be in here for contested locks */
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|m
argument_list|,
name|TYPE_SIMPLE_LOCK
argument_list|,
name|AUTO_SHARE
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|count
operator|=
name|umtxq_count
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
comment|/* 	 * When unlocking the umtx, it must be marked as unowned if 	 * there is zero or one thread only waiting for it. 	 * Otherwise, it must be marked as contested. 	 */
name|old
operator|=
name|casuword32
argument_list|(
name|m
argument_list|,
name|owner
argument_list|,
name|count
operator|<=
literal|1
condition|?
name|UMUTEX_UNOWNED
else|:
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_signal
argument_list|(
operator|&
name|key
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|old
operator|!=
name|owner
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Fetch and compare value, sleep on the address if value is not changed.  */
end_comment

begin_function
specifier|static
name|int
name|do_wait
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|u_long
name|id
parameter_list|,
name|struct
name|_umtx_time
modifier|*
name|timeout
parameter_list|,
name|int
name|compat32
parameter_list|,
name|int
name|is_private
parameter_list|)
block|{
name|struct
name|abs_timeout
name|timo
decl_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|u_long
name|tmp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|addr
argument_list|,
name|TYPE_SIMPLE_WAIT
argument_list|,
name|is_private
condition|?
name|THREAD_SHARE
else|:
name|AUTO_SHARE
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|timeout
operator|!=
name|NULL
condition|)
name|abs_timeout_init2
argument_list|(
operator|&
name|timo
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_insert
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat32
operator|==
literal|0
condition|)
name|tmp
operator|=
name|fuword
argument_list|(
name|addr
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
operator|(
name|unsigned
name|int
operator|)
name|fuword32
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|id
condition|)
name|error
operator|=
name|umtxq_sleep
argument_list|(
name|uq
argument_list|,
literal|"uwait"
argument_list|,
name|timeout
operator|==
name|NULL
condition|?
name|NULL
else|:
operator|&
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uq
operator|->
name|uq_flags
operator|&
name|UQF_UMTXQ
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
literal|0
expr_stmt|;
else|else
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wake up threads sleeping on the specified address.  */
end_comment

begin_function
name|int
name|kern_umtx_wake
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|uaddr
parameter_list|,
name|int
name|n_wake
parameter_list|,
name|int
name|is_private
parameter_list|)
block|{
name|struct
name|umtx_key
name|key
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|umtx_key_get
argument_list|(
name|uaddr
argument_list|,
name|TYPE_SIMPLE_WAIT
argument_list|,
name|is_private
condition|?
name|THREAD_SHARE
else|:
name|AUTO_SHARE
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|ret
operator|=
name|umtxq_signal
argument_list|(
operator|&
name|key
argument_list|,
name|n_wake
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock PTHREAD_PRIO_NONE protocol POSIX mutex.  */
end_comment

begin_function
specifier|static
name|int
name|do_lock_normal
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
name|struct
name|_umtx_time
modifier|*
name|timeout
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|abs_timeout
name|timo
decl_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|uint32_t
name|owner
decl_stmt|,
name|old
decl_stmt|,
name|id
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|id
operator|=
name|td
operator|->
name|td_tid
expr_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
if|if
condition|(
name|timeout
operator|!=
name|NULL
condition|)
name|abs_timeout_init2
argument_list|(
operator|&
name|timo
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
comment|/* 	 * Care must be exercised when dealing with umtx structure. It 	 * can fault on any access. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|owner
operator|=
name|fuword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|void
operator|*
argument_list|,
operator|&
name|m
operator|->
name|m_owner
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|_UMUTEX_WAIT
condition|)
block|{
if|if
condition|(
name|owner
operator|==
name|UMUTEX_UNOWNED
operator|||
name|owner
operator|==
name|UMUTEX_CONTESTED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* 			 * Try the uncontested case.  This should be done in userland. 			 */
name|owner
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|UMUTEX_UNOWNED
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* The acquire succeeded. */
if|if
condition|(
name|owner
operator|==
name|UMUTEX_UNOWNED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* If no one owns it but it is contested try to acquire it. */
if|if
condition|(
name|owner
operator|==
name|UMUTEX_CONTESTED
condition|)
block|{
name|owner
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|UMUTEX_CONTESTED
argument_list|,
name|id
operator||
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
name|UMUTEX_CONTESTED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|error
operator|=
name|umtxq_check_susp
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* If this failed the lock has changed, restart. */
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|UMUTEX_ERROR_CHECK
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|==
name|id
condition|)
return|return
operator|(
name|EDEADLK
operator|)
return|;
if|if
condition|(
name|mode
operator|==
name|_UMUTEX_TRY
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* 		 * If we caught a signal, we have retried and now 		 * exit immediately. 		 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|m
argument_list|,
name|TYPE_NORMAL_UMUTEX
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_insert
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
comment|/* 		 * Set the contested bit so that a release in user space 		 * knows to use the system call for unlock.  If this fails 		 * either some one else has acquired the lock or it has been 		 * released. 		 */
name|old
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|owner
argument_list|,
name|owner
operator||
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
comment|/* The address was invalid. */
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
comment|/* 		 * We set the contested bit, sleep. Otherwise the lock changed 		 * and we need to retry or we lost a race to the thread 		 * unlocking the umtx. 		 */
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|owner
condition|)
name|error
operator|=
name|umtxq_sleep
argument_list|(
name|uq
argument_list|,
literal|"umtxn"
argument_list|,
name|timeout
operator|==
name|NULL
condition|?
name|NULL
else|:
operator|&
name|timo
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|umtxq_check_susp
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock PTHREAD_PRIO_NONE protocol POSIX mutex.  */
end_comment

begin_function
specifier|static
name|int
name|do_unlock_normal
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|umtx_key
name|key
decl_stmt|;
name|uint32_t
name|owner
decl_stmt|,
name|old
decl_stmt|,
name|id
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|count
decl_stmt|;
name|id
operator|=
name|td
operator|->
name|td_tid
expr_stmt|;
comment|/* 	 * Make sure we own this mtx. 	 */
name|owner
operator|=
name|fuword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|m
operator|->
name|m_owner
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|!=
name|id
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
operator|(
name|owner
operator|&
name|UMUTEX_CONTESTED
operator|)
operator|==
literal|0
condition|)
block|{
name|old
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|owner
argument_list|,
name|UMUTEX_UNOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|old
operator|==
name|owner
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|owner
operator|=
name|old
expr_stmt|;
block|}
comment|/* We should only ever be in here for contested locks */
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|m
argument_list|,
name|TYPE_NORMAL_UMUTEX
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|count
operator|=
name|umtxq_count
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
comment|/* 	 * When unlocking the umtx, it must be marked as unowned if 	 * there is zero or one thread only waiting for it. 	 * Otherwise, it must be marked as contested. 	 */
name|old
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|owner
argument_list|,
name|count
operator|<=
literal|1
condition|?
name|UMUTEX_UNOWNED
else|:
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_signal
argument_list|(
operator|&
name|key
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|old
operator|!=
name|owner
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the mutex is available and wake up a waiter,  * only for simple mutex.  */
end_comment

begin_function
specifier|static
name|int
name|do_wake_umutex
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|umtx_key
name|key
decl_stmt|;
name|uint32_t
name|owner
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|count
decl_stmt|;
name|owner
operator|=
name|fuword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|m
operator|->
name|m_owner
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|flags
operator|=
name|fuword32
argument_list|(
operator|&
name|m
operator|->
name|m_flags
argument_list|)
expr_stmt|;
comment|/* We should only ever be in here for contested locks */
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|m
argument_list|,
name|TYPE_NORMAL_UMUTEX
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|count
operator|=
name|umtxq_count
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|1
condition|)
name|owner
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|UMUTEX_CONTESTED
argument_list|,
name|UMUTEX_UNOWNED
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
operator|&&
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|==
literal|0
condition|)
name|umtxq_signal
argument_list|(
operator|&
name|key
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the mutex has waiters and tries to fix contention bit.  */
end_comment

begin_function
specifier|static
name|int
name|do_wake2_umutex
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|umtx_key
name|key
decl_stmt|;
name|uint32_t
name|owner
decl_stmt|,
name|old
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|count
decl_stmt|;
switch|switch
condition|(
name|flags
operator|&
operator|(
name|UMUTEX_PRIO_INHERIT
operator||
name|UMUTEX_PRIO_PROTECT
operator|)
condition|)
block|{
case|case
literal|0
case|:
name|type
operator|=
name|TYPE_NORMAL_UMUTEX
expr_stmt|;
break|break;
case|case
name|UMUTEX_PRIO_INHERIT
case|:
name|type
operator|=
name|TYPE_PI_UMUTEX
expr_stmt|;
break|break;
case|case
name|UMUTEX_PRIO_PROTECT
case|:
name|type
operator|=
name|TYPE_PP_UMUTEX
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|m
argument_list|,
name|type
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|owner
operator|=
literal|0
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|count
operator|=
name|umtxq_count
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
comment|/* 	 * Only repair contention bit if there is a waiter, this means the mutex 	 * is still being referenced by userland code, otherwise don't update 	 * any memory. 	 */
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
name|owner
operator|=
name|fuword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|m
operator|->
name|m_owner
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|owner
operator|&
name|UMUTEX_CONTESTED
operator|)
operator|==
literal|0
condition|)
block|{
name|old
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|owner
argument_list|,
name|owner
operator||
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|owner
condition|)
break|break;
name|owner
operator|=
name|old
expr_stmt|;
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
break|break;
name|error
operator|=
name|umtxq_check_susp
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|count
operator|==
literal|1
condition|)
block|{
name|owner
operator|=
name|fuword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|m
operator|->
name|m_owner
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|owner
operator|&
name|UMUTEX_CONTESTED
operator|)
operator|==
literal|0
condition|)
block|{
name|old
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|owner
argument_list|,
name|owner
operator||
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|owner
condition|)
break|break;
name|owner
operator|=
name|old
expr_stmt|;
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
break|break;
name|error
operator|=
name|umtxq_check_susp
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
name|umtxq_signal
argument_list|(
operator|&
name|key
argument_list|,
name|INT_MAX
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|!=
literal|0
operator|&&
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|==
literal|0
condition|)
name|umtxq_signal
argument_list|(
operator|&
name|key
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|umtx_pi
modifier|*
name|umtx_pi_alloc
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|struct
name|umtx_pi
modifier|*
name|pi
decl_stmt|;
name|pi
operator|=
name|uma_zalloc
argument_list|(
name|umtx_pi_zone
argument_list|,
name|M_ZERO
operator||
name|flags
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pi
operator|->
name|pi_blocked
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|umtx_pi_allocated
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|pi
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|umtx_pi_free
parameter_list|(
name|struct
name|umtx_pi
modifier|*
name|pi
parameter_list|)
block|{
name|uma_zfree
argument_list|(
name|umtx_pi_zone
argument_list|,
name|pi
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|umtx_pi_allocated
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Adjust the thread's position on a pi_state after its priority has been  * changed.  */
end_comment

begin_function
specifier|static
name|int
name|umtx_pi_adjust_thread
parameter_list|(
name|struct
name|umtx_pi
modifier|*
name|pi
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|,
modifier|*
name|uq1
decl_stmt|,
modifier|*
name|uq2
decl_stmt|;
name|struct
name|thread
modifier|*
name|td1
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|umtx_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
comment|/* 	 * Check if the thread needs to be moved on the blocked chain. 	 * It needs to be moved if either its priority is lower than 	 * the previous thread or higher than the next thread. 	 */
name|uq1
operator|=
name|TAILQ_PREV
argument_list|(
name|uq
argument_list|,
name|umtxq_head
argument_list|,
name|uq_lockq
argument_list|)
expr_stmt|;
name|uq2
operator|=
name|TAILQ_NEXT
argument_list|(
name|uq
argument_list|,
name|uq_lockq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uq1
operator|!=
name|NULL
operator|&&
name|UPRI
argument_list|(
name|td
argument_list|)
operator|<
name|UPRI
argument_list|(
name|uq1
operator|->
name|uq_thread
argument_list|)
operator|)
operator|||
operator|(
name|uq2
operator|!=
name|NULL
operator|&&
name|UPRI
argument_list|(
name|td
argument_list|)
operator|>
name|UPRI
argument_list|(
name|uq2
operator|->
name|uq_thread
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * Remove thread from blocked chain and determine where 		 * it should be moved to. 		 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pi
operator|->
name|pi_blocked
argument_list|,
name|uq
argument_list|,
name|uq_lockq
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|uq1
argument_list|,
argument|&pi->pi_blocked
argument_list|,
argument|uq_lockq
argument_list|)
block|{
name|td1
operator|=
name|uq1
operator|->
name|uq_thread
expr_stmt|;
name|MPASS
argument_list|(
name|td1
operator|->
name|td_proc
operator|->
name|p_magic
operator|==
name|P_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|UPRI
argument_list|(
name|td1
argument_list|)
operator|>
name|UPRI
argument_list|(
name|td
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|uq1
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pi
operator|->
name|pi_blocked
argument_list|,
name|uq
argument_list|,
name|uq_lockq
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_BEFORE
argument_list|(
name|uq1
argument_list|,
name|uq
argument_list|,
name|uq_lockq
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Propagate priority when a thread is blocked on POSIX  * PI mutex.  */
end_comment

begin_function
specifier|static
name|void
name|umtx_propagate_priority
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|struct
name|umtx_pi
modifier|*
name|pi
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|umtx_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|pri
operator|=
name|UPRI
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
name|pi
operator|=
name|uq
operator|->
name|uq_pi_blocked
expr_stmt|;
if|if
condition|(
name|pi
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
name|td
operator|=
name|pi
operator|->
name|pi_owner
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
operator|||
name|td
operator|==
name|curthread
condition|)
return|return;
name|MPASS
argument_list|(
name|td
operator|->
name|td_proc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_magic
operator|==
name|P_MAGIC
argument_list|)
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_lend_user_pri
operator|>
name|pri
condition|)
name|sched_lend_user_prio
argument_list|(
name|td
argument_list|,
name|pri
argument_list|)
expr_stmt|;
else|else
block|{
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
break|break;
block|}
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* 		 * Pick up the lock that td is blocked on. 		 */
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
name|pi
operator|=
name|uq
operator|->
name|uq_pi_blocked
expr_stmt|;
if|if
condition|(
name|pi
operator|==
name|NULL
condition|)
break|break;
comment|/* Resort td on the list if needed. */
name|umtx_pi_adjust_thread
argument_list|(
name|pi
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Unpropagate priority for a PI mutex when a thread blocked on  * it is interrupted by signal or resumed by others.  */
end_comment

begin_function
specifier|static
name|void
name|umtx_repropagate_priority
parameter_list|(
name|struct
name|umtx_pi
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|,
modifier|*
name|uq_owner
decl_stmt|;
name|struct
name|umtx_pi
modifier|*
name|pi2
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|umtx_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
while|while
condition|(
name|pi
operator|!=
name|NULL
operator|&&
name|pi
operator|->
name|pi_owner
operator|!=
name|NULL
condition|)
block|{
name|pri
operator|=
name|PRI_MAX
expr_stmt|;
name|uq_owner
operator|=
name|pi
operator|->
name|pi_owner
operator|->
name|td_umtxq
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pi2
argument_list|,
argument|&uq_owner->uq_pi_contested
argument_list|,
argument|pi_link
argument_list|)
block|{
name|uq
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pi2
operator|->
name|pi_blocked
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pri
operator|>
name|UPRI
argument_list|(
name|uq
operator|->
name|uq_thread
argument_list|)
condition|)
name|pri
operator|=
name|UPRI
argument_list|(
name|uq
operator|->
name|uq_thread
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pri
operator|>
name|uq_owner
operator|->
name|uq_inherited_pri
condition|)
name|pri
operator|=
name|uq_owner
operator|->
name|uq_inherited_pri
expr_stmt|;
name|thread_lock
argument_list|(
name|pi
operator|->
name|pi_owner
argument_list|)
expr_stmt|;
name|sched_lend_user_prio
argument_list|(
name|pi
operator|->
name|pi_owner
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|pi
operator|->
name|pi_owner
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pi
operator|=
name|uq_owner
operator|->
name|uq_pi_blocked
operator|)
operator|!=
name|NULL
condition|)
name|umtx_pi_adjust_thread
argument_list|(
name|pi
argument_list|,
name|uq_owner
operator|->
name|uq_thread
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Insert a PI mutex into owned list.  */
end_comment

begin_function
specifier|static
name|void
name|umtx_pi_setowner
parameter_list|(
name|struct
name|umtx_pi
modifier|*
name|pi
parameter_list|,
name|struct
name|thread
modifier|*
name|owner
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq_owner
decl_stmt|;
name|uq_owner
operator|=
name|owner
operator|->
name|td_umtxq
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|umtx_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pi_owner
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"pi_ower != NULL"
argument_list|)
expr_stmt|;
name|pi
operator|->
name|pi_owner
operator|=
name|owner
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|uq_owner
operator|->
name|uq_pi_contested
argument_list|,
name|pi
argument_list|,
name|pi_link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Claim ownership of a PI mutex.  */
end_comment

begin_function
specifier|static
name|int
name|umtx_pi_claim
parameter_list|(
name|struct
name|umtx_pi
modifier|*
name|pi
parameter_list|,
name|struct
name|thread
modifier|*
name|owner
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|,
modifier|*
name|uq_owner
decl_stmt|;
name|uq_owner
operator|=
name|owner
operator|->
name|td_umtxq
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pi_owner
operator|==
name|owner
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|pi
operator|->
name|pi_owner
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * userland may have already messed the mutex, sigh. 		 */
name|mtx_unlock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|umtx_pi_setowner
argument_list|(
name|pi
argument_list|,
name|owner
argument_list|)
expr_stmt|;
name|uq
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pi
operator|->
name|pi_blocked
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq
operator|!=
name|NULL
condition|)
block|{
name|int
name|pri
decl_stmt|;
name|pri
operator|=
name|UPRI
argument_list|(
name|uq
operator|->
name|uq_thread
argument_list|)
expr_stmt|;
name|thread_lock
argument_list|(
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|pri
operator|<
name|UPRI
argument_list|(
name|owner
argument_list|)
condition|)
name|sched_lend_user_prio
argument_list|(
name|owner
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|owner
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Adjust a thread's order position in its blocked PI mutex,  * this may result new priority propagating process.  */
end_comment

begin_function
name|void
name|umtx_pi_adjust
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|u_char
name|oldpri
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|struct
name|umtx_pi
modifier|*
name|pi
decl_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Pick up the lock that td is blocked on. 	 */
name|pi
operator|=
name|uq
operator|->
name|uq_pi_blocked
expr_stmt|;
if|if
condition|(
name|pi
operator|!=
name|NULL
condition|)
block|{
name|umtx_pi_adjust_thread
argument_list|(
name|pi
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|umtx_repropagate_priority
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sleep on a PI mutex.  */
end_comment

begin_function
specifier|static
name|int
name|umtxq_sleep_pi
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|,
name|struct
name|umtx_pi
modifier|*
name|pi
parameter_list|,
name|uint32_t
name|owner
parameter_list|,
specifier|const
name|char
modifier|*
name|wmesg
parameter_list|,
name|struct
name|abs_timeout
modifier|*
name|timo
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|,
modifier|*
name|td1
decl_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq1
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|td
operator|=
name|uq
operator|->
name|uq_thread
expr_stmt|;
name|KASSERT
argument_list|(
name|td
operator|==
name|curthread
argument_list|,
operator|(
literal|"inconsistent uq_thread"
operator|)
argument_list|)
expr_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|UMTXQ_BUSY_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|umtxq_insert
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pi_owner
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
comment|/* XXX Only look up thread in current process. */
name|td1
operator|=
name|tdfind
argument_list|(
name|owner
argument_list|,
name|curproc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|td1
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pi
operator|->
name|pi_owner
operator|==
name|NULL
condition|)
name|umtx_pi_setowner
argument_list|(
name|pi
argument_list|,
name|td1
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td1
operator|->
name|td_proc
argument_list|)
expr_stmt|;
block|}
block|}
name|TAILQ_FOREACH
argument_list|(
argument|uq1
argument_list|,
argument|&pi->pi_blocked
argument_list|,
argument|uq_lockq
argument_list|)
block|{
name|pri
operator|=
name|UPRI
argument_list|(
name|uq1
operator|->
name|uq_thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|pri
operator|>
name|UPRI
argument_list|(
name|td
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|uq1
operator|!=
name|NULL
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|uq1
argument_list|,
name|uq
argument_list|,
name|uq_lockq
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pi
operator|->
name|pi_blocked
argument_list|,
name|uq
argument_list|,
name|uq_lockq
argument_list|)
expr_stmt|;
name|uq
operator|->
name|uq_pi_blocked
operator|=
name|pi
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_flags
operator||=
name|TDF_UPIBLOCKED
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|umtx_propagate_priority
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|error
operator|=
name|umtxq_sleep
argument_list|(
name|uq
argument_list|,
name|wmesg
argument_list|,
name|timo
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
name|uq
operator|->
name|uq_pi_blocked
operator|=
name|NULL
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_UPIBLOCKED
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pi
operator|->
name|pi_blocked
argument_list|,
name|uq
argument_list|,
name|uq_lockq
argument_list|)
expr_stmt|;
name|umtx_repropagate_priority
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add reference count for a PI mutex.  */
end_comment

begin_function
specifier|static
name|void
name|umtx_pi_ref
parameter_list|(
name|struct
name|umtx_pi
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
operator|&
name|pi
operator|->
name|pi_key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|pi
operator|->
name|pi_refcount
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Decrease reference count for a PI mutex, if the counter  * is decreased to zero, its memory space is freed.  */
end_comment

begin_function
specifier|static
name|void
name|umtx_pi_unref
parameter_list|(
name|struct
name|umtx_pi
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
operator|&
name|pi
operator|->
name|pi_key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pi
operator|->
name|pi_refcount
operator|>
literal|0
argument_list|,
operator|(
literal|"invalid reference count"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|pi
operator|->
name|pi_refcount
operator|==
literal|0
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pi_owner
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pi
operator|->
name|pi_owner
operator|->
name|td_umtxq
operator|->
name|uq_pi_contested
argument_list|,
name|pi
argument_list|,
name|pi_link
argument_list|)
expr_stmt|;
name|pi
operator|->
name|pi_owner
operator|=
name|NULL
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|pi
operator|->
name|pi_blocked
argument_list|)
argument_list|,
operator|(
literal|"blocked queue not empty"
operator|)
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|uc
operator|->
name|uc_pi_list
argument_list|,
name|pi
argument_list|,
name|pi_hashlink
argument_list|)
expr_stmt|;
name|umtx_pi_free
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Find a PI mutex in hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|umtx_pi
modifier|*
name|umtx_pi_lookup
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|struct
name|umtx_pi
modifier|*
name|pi
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pi
argument_list|,
argument|&uc->uc_pi_list
argument_list|,
argument|pi_hashlink
argument_list|)
block|{
if|if
condition|(
name|umtx_key_match
argument_list|(
operator|&
name|pi
operator|->
name|pi_key
argument_list|,
name|key
argument_list|)
condition|)
block|{
return|return
operator|(
name|pi
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert a PI mutex into hash table.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|umtx_pi_insert
parameter_list|(
name|struct
name|umtx_pi
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
operator|&
name|pi
operator|->
name|pi_key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|uc
operator|->
name|uc_pi_list
argument_list|,
name|pi
argument_list|,
name|pi_hashlink
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lock a PI mutex.  */
end_comment

begin_function
specifier|static
name|int
name|do_lock_pi
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
name|struct
name|_umtx_time
modifier|*
name|timeout
parameter_list|,
name|int
name|try
parameter_list|)
block|{
name|struct
name|abs_timeout
name|timo
decl_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|struct
name|umtx_pi
modifier|*
name|pi
decl_stmt|,
modifier|*
name|new_pi
decl_stmt|;
name|uint32_t
name|id
decl_stmt|,
name|owner
decl_stmt|,
name|old
decl_stmt|;
name|int
name|error
decl_stmt|;
name|id
operator|=
name|td
operator|->
name|td_tid
expr_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|m
argument_list|,
name|TYPE_PI_UMUTEX
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|timeout
operator|!=
name|NULL
condition|)
name|abs_timeout_init2
argument_list|(
operator|&
name|timo
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|pi
operator|=
name|umtx_pi_lookup
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|==
name|NULL
condition|)
block|{
name|new_pi
operator|=
name|umtx_pi_alloc
argument_list|(
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_pi
operator|==
name|NULL
condition|)
block|{
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|new_pi
operator|=
name|umtx_pi_alloc
argument_list|(
name|M_WAITOK
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|pi
operator|=
name|umtx_pi_lookup
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|!=
name|NULL
condition|)
block|{
name|umtx_pi_free
argument_list|(
name|new_pi
argument_list|)
expr_stmt|;
name|new_pi
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|new_pi
operator|!=
name|NULL
condition|)
block|{
name|new_pi
operator|->
name|pi_key
operator|=
name|uq
operator|->
name|uq_key
expr_stmt|;
name|umtx_pi_insert
argument_list|(
name|new_pi
argument_list|)
expr_stmt|;
name|pi
operator|=
name|new_pi
expr_stmt|;
block|}
block|}
name|umtx_pi_ref
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
comment|/* 	 * Care must be exercised when dealing with umtx structure.  It 	 * can fault on any access. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Try the uncontested case.  This should be done in userland. 		 */
name|owner
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|UMUTEX_UNOWNED
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* The acquire succeeded. */
if|if
condition|(
name|owner
operator|==
name|UMUTEX_UNOWNED
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
comment|/* If no one owns it but it is contested try to acquire it. */
if|if
condition|(
name|owner
operator|==
name|UMUTEX_CONTESTED
condition|)
block|{
name|owner
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|UMUTEX_CONTESTED
argument_list|,
name|id
operator||
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
name|UMUTEX_CONTESTED
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|error
operator|=
name|umtx_pi_claim
argument_list|(
name|pi
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|umtxq_check_susp
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
comment|/* If this failed the lock has changed, restart. */
continue|continue;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|UMUTEX_ERROR_CHECK
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|==
name|id
condition|)
block|{
name|error
operator|=
name|EDEADLK
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|try
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
comment|/* 		 * If we caught a signal, we have retried and now 		 * exit immediately. 		 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
comment|/* 		 * Set the contested bit so that a release in user space 		 * knows to use the system call for unlock.  If this fails 		 * either some one else has acquired the lock or it has been 		 * released. 		 */
name|old
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|owner
argument_list|,
name|owner
operator||
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
comment|/* The address was invalid. */
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
comment|/* 		 * We set the contested bit, sleep. Otherwise the lock changed 		 * and we need to retry or we lost a race to the thread 		 * unlocking the umtx. 		 */
if|if
condition|(
name|old
operator|==
name|owner
condition|)
block|{
name|error
operator|=
name|umtxq_sleep_pi
argument_list|(
name|uq
argument_list|,
name|pi
argument_list|,
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
argument_list|,
literal|"umtxpi"
argument_list|,
name|timeout
operator|==
name|NULL
condition|?
name|NULL
else|:
operator|&
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
continue|continue;
block|}
else|else
block|{
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|umtxq_check_susp
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_pi_unref
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock a PI mutex.  */
end_comment

begin_function
specifier|static
name|int
name|do_unlock_pi
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|umtx_key
name|key
decl_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq_first
decl_stmt|,
modifier|*
name|uq_first2
decl_stmt|,
modifier|*
name|uq_me
decl_stmt|;
name|struct
name|umtx_pi
modifier|*
name|pi
decl_stmt|,
modifier|*
name|pi2
decl_stmt|;
name|uint32_t
name|owner
decl_stmt|,
name|old
decl_stmt|,
name|id
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|id
operator|=
name|td
operator|->
name|td_tid
expr_stmt|;
comment|/* 	 * Make sure we own this mtx. 	 */
name|owner
operator|=
name|fuword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|m
operator|->
name|m_owner
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|!=
name|id
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* This should be done in userland */
if|if
condition|(
operator|(
name|owner
operator|&
name|UMUTEX_CONTESTED
operator|)
operator|==
literal|0
condition|)
block|{
name|old
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|owner
argument_list|,
name|UMUTEX_UNOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|old
operator|==
name|owner
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|owner
operator|=
name|old
expr_stmt|;
block|}
comment|/* We should only ever be in here for contested locks */
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|m
argument_list|,
name|TYPE_PI_UMUTEX
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|count
operator|=
name|umtxq_count_pi
argument_list|(
operator|&
name|key
argument_list|,
operator|&
name|uq_first
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq_first
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
name|pi
operator|=
name|uq_first
operator|->
name|uq_pi_blocked
expr_stmt|;
name|KASSERT
argument_list|(
name|pi
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pi == NULL?"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pi_owner
operator|!=
name|curthread
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
comment|/* userland messed the mutex */
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|uq_me
operator|=
name|curthread
operator|->
name|td_umtxq
expr_stmt|;
name|pi
operator|->
name|pi_owner
operator|=
name|NULL
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|uq_me
operator|->
name|uq_pi_contested
argument_list|,
name|pi
argument_list|,
name|pi_link
argument_list|)
expr_stmt|;
comment|/* get highest priority thread which is still sleeping. */
name|uq_first
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pi
operator|->
name|pi_blocked
argument_list|)
expr_stmt|;
while|while
condition|(
name|uq_first
operator|!=
name|NULL
operator|&&
operator|(
name|uq_first
operator|->
name|uq_flags
operator|&
name|UQF_UMTXQ
operator|)
operator|==
literal|0
condition|)
block|{
name|uq_first
operator|=
name|TAILQ_NEXT
argument_list|(
name|uq_first
argument_list|,
name|uq_lockq
argument_list|)
expr_stmt|;
block|}
name|pri
operator|=
name|PRI_MAX
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pi2
argument_list|,
argument|&uq_me->uq_pi_contested
argument_list|,
argument|pi_link
argument_list|)
block|{
name|uq_first2
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pi2
operator|->
name|pi_blocked
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq_first2
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pri
operator|>
name|UPRI
argument_list|(
name|uq_first2
operator|->
name|uq_thread
argument_list|)
condition|)
name|pri
operator|=
name|UPRI
argument_list|(
name|uq_first2
operator|->
name|uq_thread
argument_list|)
expr_stmt|;
block|}
block|}
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_lend_user_prio
argument_list|(
name|curthread
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq_first
condition|)
name|umtxq_signal_thread
argument_list|(
name|uq_first
argument_list|)
expr_stmt|;
block|}
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
comment|/* 	 * When unlocking the umtx, it must be marked as unowned if 	 * there is zero or one thread only waiting for it. 	 * Otherwise, it must be marked as contested. 	 */
name|old
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|owner
argument_list|,
name|count
operator|<=
literal|1
condition|?
name|UMUTEX_UNOWNED
else|:
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|old
operator|!=
name|owner
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock a PP mutex.  */
end_comment

begin_function
specifier|static
name|int
name|do_lock_pp
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
name|struct
name|_umtx_time
modifier|*
name|timeout
parameter_list|,
name|int
name|try
parameter_list|)
block|{
name|struct
name|abs_timeout
name|timo
decl_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|,
modifier|*
name|uq2
decl_stmt|;
name|struct
name|umtx_pi
modifier|*
name|pi
decl_stmt|;
name|uint32_t
name|ceiling
decl_stmt|;
name|uint32_t
name|owner
decl_stmt|,
name|id
decl_stmt|;
name|int
name|error
decl_stmt|,
name|pri
decl_stmt|,
name|old_inherited_pri
decl_stmt|,
name|su
decl_stmt|;
name|id
operator|=
name|td
operator|->
name|td_tid
expr_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|m
argument_list|,
name|TYPE_PP_UMUTEX
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|timeout
operator|!=
name|NULL
condition|)
name|abs_timeout_init2
argument_list|(
operator|&
name|timo
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|su
operator|=
operator|(
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_SCHED_RTPRIO
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|old_inherited_pri
operator|=
name|uq
operator|->
name|uq_inherited_pri
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|ceiling
operator|=
name|RTP_PRIO_MAX
operator|-
name|fuword32
argument_list|(
operator|&
name|m
operator|->
name|m_ceilings
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ceiling
operator|>
name|RTP_PRIO_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mtx_lock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|UPRI
argument_list|(
name|td
argument_list|)
operator|<
name|PRI_MIN_REALTIME
operator|+
name|ceiling
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|su
operator|&&
name|PRI_MIN_REALTIME
operator|+
name|ceiling
operator|<
name|uq
operator|->
name|uq_inherited_pri
condition|)
block|{
name|uq
operator|->
name|uq_inherited_pri
operator|=
name|PRI_MIN_REALTIME
operator|+
name|ceiling
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq
operator|->
name|uq_inherited_pri
operator|<
name|UPRI
argument_list|(
name|td
argument_list|)
condition|)
name|sched_lend_user_prio
argument_list|(
name|td
argument_list|,
name|uq
operator|->
name|uq_inherited_pri
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
name|owner
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|UMUTEX_CONTESTED
argument_list|,
name|id
operator||
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
name|UMUTEX_CONTESTED
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|UMUTEX_ERROR_CHECK
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|==
name|id
condition|)
block|{
name|error
operator|=
name|EDEADLK
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|try
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
comment|/* 		 * If we caught a signal, we have retried and now 		 * exit immediately. 		 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_insert
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|error
operator|=
name|umtxq_sleep
argument_list|(
name|uq
argument_list|,
literal|"umtxpp"
argument_list|,
name|timeout
operator|==
name|NULL
condition|?
name|NULL
else|:
operator|&
name|timo
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
name|uq
operator|->
name|uq_inherited_pri
operator|=
name|old_inherited_pri
expr_stmt|;
name|pri
operator|=
name|PRI_MAX
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pi
argument_list|,
argument|&uq->uq_pi_contested
argument_list|,
argument|pi_link
argument_list|)
block|{
name|uq2
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pi
operator|->
name|pi_blocked
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq2
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pri
operator|>
name|UPRI
argument_list|(
name|uq2
operator|->
name|uq_thread
argument_list|)
condition|)
name|pri
operator|=
name|UPRI
argument_list|(
name|uq2
operator|->
name|uq_thread
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pri
operator|>
name|uq
operator|->
name|uq_inherited_pri
condition|)
name|pri
operator|=
name|uq
operator|->
name|uq_inherited_pri
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|sched_lend_user_prio
argument_list|(
name|td
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
name|uq
operator|->
name|uq_inherited_pri
operator|=
name|old_inherited_pri
expr_stmt|;
name|pri
operator|=
name|PRI_MAX
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pi
argument_list|,
argument|&uq->uq_pi_contested
argument_list|,
argument|pi_link
argument_list|)
block|{
name|uq2
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pi
operator|->
name|pi_blocked
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq2
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pri
operator|>
name|UPRI
argument_list|(
name|uq2
operator|->
name|uq_thread
argument_list|)
condition|)
name|pri
operator|=
name|UPRI
argument_list|(
name|uq2
operator|->
name|uq_thread
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pri
operator|>
name|uq
operator|->
name|uq_inherited_pri
condition|)
name|pri
operator|=
name|uq
operator|->
name|uq_inherited_pri
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|sched_lend_user_prio
argument_list|(
name|td
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock a PP mutex.  */
end_comment

begin_function
specifier|static
name|int
name|do_unlock_pp
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|umtx_key
name|key
decl_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|,
modifier|*
name|uq2
decl_stmt|;
name|struct
name|umtx_pi
modifier|*
name|pi
decl_stmt|;
name|uint32_t
name|owner
decl_stmt|,
name|id
decl_stmt|;
name|uint32_t
name|rceiling
decl_stmt|;
name|int
name|error
decl_stmt|,
name|pri
decl_stmt|,
name|new_inherited_pri
decl_stmt|,
name|su
decl_stmt|;
name|id
operator|=
name|td
operator|->
name|td_tid
expr_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
name|su
operator|=
operator|(
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_SCHED_RTPRIO
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* 	 * Make sure we own this mtx. 	 */
name|owner
operator|=
name|fuword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|m
operator|->
name|m_owner
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|!=
name|id
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
operator|&
name|m
operator|->
name|m_ceilings
index|[
literal|1
index|]
argument_list|,
operator|&
name|rceiling
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|rceiling
operator|==
operator|-
literal|1
condition|)
name|new_inherited_pri
operator|=
name|PRI_MAX
expr_stmt|;
else|else
block|{
name|rceiling
operator|=
name|RTP_PRIO_MAX
operator|-
name|rceiling
expr_stmt|;
if|if
condition|(
name|rceiling
operator|>
name|RTP_PRIO_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|new_inherited_pri
operator|=
name|PRI_MIN_REALTIME
operator|+
name|rceiling
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|m
argument_list|,
name|TYPE_PP_UMUTEX
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
comment|/* 	 * For priority protected mutex, always set unlocked state 	 * to UMUTEX_CONTESTED, so that userland always enters kernel 	 * to lock the mutex, it is necessary because thread priority 	 * has to be adjusted for such mutex. 	 */
name|error
operator|=
name|suword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|m
operator|->
name|m_owner
argument_list|)
argument_list|,
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|umtxq_signal
argument_list|(
operator|&
name|key
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
name|error
operator|=
name|EFAULT
expr_stmt|;
else|else
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|su
operator|!=
literal|0
condition|)
name|uq
operator|->
name|uq_inherited_pri
operator|=
name|new_inherited_pri
expr_stmt|;
name|pri
operator|=
name|PRI_MAX
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pi
argument_list|,
argument|&uq->uq_pi_contested
argument_list|,
argument|pi_link
argument_list|)
block|{
name|uq2
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pi
operator|->
name|pi_blocked
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq2
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pri
operator|>
name|UPRI
argument_list|(
name|uq2
operator|->
name|uq_thread
argument_list|)
condition|)
name|pri
operator|=
name|UPRI
argument_list|(
name|uq2
operator|->
name|uq_thread
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pri
operator|>
name|uq
operator|->
name|uq_inherited_pri
condition|)
name|pri
operator|=
name|uq
operator|->
name|uq_inherited_pri
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|sched_lend_user_prio
argument_list|(
name|td
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
block|}
name|umtx_key_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_set_ceiling
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|,
name|uint32_t
name|ceiling
parameter_list|,
name|uint32_t
modifier|*
name|old_ceiling
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|uint32_t
name|save_ceiling
decl_stmt|;
name|uint32_t
name|owner
decl_stmt|,
name|id
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|int
name|error
decl_stmt|;
name|flags
operator|=
name|fuword32
argument_list|(
operator|&
name|m
operator|->
name|m_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|UMUTEX_PRIO_PROTECT
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ceiling
operator|>
name|RTP_PRIO_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|id
operator|=
name|td
operator|->
name|td_tid
expr_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|m
argument_list|,
name|TYPE_PP_UMUTEX
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|save_ceiling
operator|=
name|fuword32
argument_list|(
operator|&
name|m
operator|->
name|m_ceilings
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|owner
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|UMUTEX_CONTESTED
argument_list|,
name|id
operator||
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
name|UMUTEX_CONTESTED
condition|)
block|{
name|suword32
argument_list|(
operator|&
name|m
operator|->
name|m_ceilings
index|[
literal|0
index|]
argument_list|,
name|ceiling
argument_list|)
expr_stmt|;
name|suword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|m
operator|->
name|m_owner
argument_list|)
argument_list|,
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|==
name|id
condition|)
block|{
name|suword32
argument_list|(
operator|&
name|m
operator|->
name|m_ceilings
index|[
literal|0
index|]
argument_list|,
name|ceiling
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 		 * If we caught a signal, we have retried and now 		 * exit immediately. 		 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
comment|/* 		 * We set the contested bit, sleep. Otherwise the lock changed 		 * and we need to retry or we lost a race to the thread 		 * unlocking the umtx. 		 */
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_insert
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|error
operator|=
name|umtxq_sleep
argument_list|(
name|uq
argument_list|,
literal|"umtxpp"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
block|}
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|umtxq_signal
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|,
name|INT_MAX
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|old_ceiling
operator|!=
name|NULL
condition|)
name|suword32
argument_list|(
name|old_ceiling
argument_list|,
name|save_ceiling
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock a userland POSIX mutex.  */
end_comment

begin_function
specifier|static
name|int
name|do_lock_umutex
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|,
name|struct
name|_umtx_time
modifier|*
name|timeout
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|uint32_t
name|flags
decl_stmt|;
name|int
name|error
decl_stmt|;
name|flags
operator|=
name|fuword32
argument_list|(
operator|&
name|m
operator|->
name|m_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
switch|switch
condition|(
name|flags
operator|&
operator|(
name|UMUTEX_PRIO_INHERIT
operator||
name|UMUTEX_PRIO_PROTECT
operator|)
condition|)
block|{
case|case
literal|0
case|:
name|error
operator|=
name|do_lock_normal
argument_list|(
name|td
argument_list|,
name|m
argument_list|,
name|flags
argument_list|,
name|timeout
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMUTEX_PRIO_INHERIT
case|:
name|error
operator|=
name|do_lock_pi
argument_list|(
name|td
argument_list|,
name|m
argument_list|,
name|flags
argument_list|,
name|timeout
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMUTEX_PRIO_PROTECT
case|:
name|error
operator|=
name|do_lock_pp
argument_list|(
name|td
argument_list|,
name|m
argument_list|,
name|flags
argument_list|,
name|timeout
argument_list|,
name|mode
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|timeout
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EINTR
operator|&&
name|mode
operator|!=
name|_UMUTEX_WAIT
condition|)
name|error
operator|=
name|ERESTART
expr_stmt|;
block|}
else|else
block|{
comment|/* Timed-locking is not restarted. */
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock a userland POSIX mutex.  */
end_comment

begin_function
specifier|static
name|int
name|do_unlock_umutex
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|)
block|{
name|uint32_t
name|flags
decl_stmt|;
name|flags
operator|=
name|fuword32
argument_list|(
operator|&
name|m
operator|->
name|m_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
switch|switch
condition|(
name|flags
operator|&
operator|(
name|UMUTEX_PRIO_INHERIT
operator||
name|UMUTEX_PRIO_PROTECT
operator|)
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
name|do_unlock_normal
argument_list|(
name|td
argument_list|,
name|m
argument_list|,
name|flags
argument_list|)
operator|)
return|;
case|case
name|UMUTEX_PRIO_INHERIT
case|:
return|return
operator|(
name|do_unlock_pi
argument_list|(
name|td
argument_list|,
name|m
argument_list|,
name|flags
argument_list|)
operator|)
return|;
case|case
name|UMUTEX_PRIO_PROTECT
case|:
return|return
operator|(
name|do_unlock_pp
argument_list|(
name|td
argument_list|,
name|m
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_cv_wait
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|ucond
modifier|*
name|cv
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|,
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|,
name|u_long
name|wflags
parameter_list|)
block|{
name|struct
name|abs_timeout
name|timo
decl_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|uint32_t
name|clockid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
name|flags
operator|=
name|fuword32
argument_list|(
operator|&
name|cv
operator|->
name|c_flags
argument_list|)
expr_stmt|;
name|error
operator|=
name|umtx_key_get
argument_list|(
name|cv
argument_list|,
name|TYPE_CV
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|wflags
operator|&
name|CVWAIT_CLOCKID
operator|)
operator|!=
literal|0
condition|)
block|{
name|clockid
operator|=
name|fuword32
argument_list|(
operator|&
name|cv
operator|->
name|c_clockid
argument_list|)
expr_stmt|;
if|if
condition|(
name|clockid
operator|<
name|CLOCK_REALTIME
operator|||
name|clockid
operator|>=
name|CLOCK_THREAD_CPUTIME_ID
condition|)
block|{
comment|/* hmm, only HW clock id will work. */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
else|else
block|{
name|clockid
operator|=
name|CLOCK_REALTIME
expr_stmt|;
block|}
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_insert
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
comment|/* 	 * Set c_has_waiters to 1 before releasing user mutex, also 	 * don't modify cache line when unnecessary. 	 */
if|if
condition|(
name|fuword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|cv
operator|->
name|c_has_waiters
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|suword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|cv
operator|->
name|c_has_waiters
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|error
operator|=
name|do_unlock_umutex
argument_list|(
name|td
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|!=
name|NULL
condition|)
name|abs_timeout_init
argument_list|(
operator|&
name|timo
argument_list|,
name|clockid
argument_list|,
operator|(
operator|(
name|wflags
operator|&
name|CVWAIT_ABSTIME
operator|)
operator|!=
literal|0
operator|)
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|umtxq_sleep
argument_list|(
name|uq
argument_list|,
literal|"ucond"
argument_list|,
name|timeout
operator|==
name|NULL
condition|?
name|NULL
else|:
operator|&
name|timo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|uq
operator|->
name|uq_flags
operator|&
name|UQF_UMTXQ
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* 		 * This must be timeout,interrupted by signal or 		 * surprious wakeup, clear c_has_waiter flag when 		 * necessary. 		 */
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uq
operator|->
name|uq_flags
operator|&
name|UQF_UMTXQ
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|oldlen
init|=
name|uq
operator|->
name|uq_cur_queue
operator|->
name|length
decl_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldlen
operator|==
literal|1
condition|)
block|{
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|suword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|cv
operator|->
name|c_has_waiters
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
block|}
block|}
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
block|}
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Signal a userland condition variable.  */
end_comment

begin_function
specifier|static
name|int
name|do_cv_signal
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|ucond
modifier|*
name|cv
parameter_list|)
block|{
name|struct
name|umtx_key
name|key
decl_stmt|;
name|int
name|error
decl_stmt|,
name|cnt
decl_stmt|,
name|nwake
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|flags
operator|=
name|fuword32
argument_list|(
operator|&
name|cv
operator|->
name|c_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|cv
argument_list|,
name|TYPE_CV
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|umtxq_count
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|nwake
operator|=
name|umtxq_signal
argument_list|(
operator|&
name|key
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<=
name|nwake
condition|)
block|{
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|error
operator|=
name|suword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|cv
operator|->
name|c_has_waiters
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
block|}
name|umtxq_unbusy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_cv_broadcast
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|ucond
modifier|*
name|cv
parameter_list|)
block|{
name|struct
name|umtx_key
name|key
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|flags
operator|=
name|fuword32
argument_list|(
operator|&
name|cv
operator|->
name|c_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|cv
argument_list|,
name|TYPE_CV
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_signal
argument_list|(
operator|&
name|key
argument_list|,
name|INT_MAX
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|error
operator|=
name|suword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|cv
operator|->
name|c_has_waiters
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_rw_rdlock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|urwlock
modifier|*
name|rwlock
parameter_list|,
name|long
name|fflag
parameter_list|,
name|struct
name|_umtx_time
modifier|*
name|timeout
parameter_list|)
block|{
name|struct
name|abs_timeout
name|timo
decl_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|,
name|wrflags
decl_stmt|;
name|int32_t
name|state
decl_stmt|,
name|oldstate
decl_stmt|;
name|int32_t
name|blocked_readers
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
name|flags
operator|=
name|fuword32
argument_list|(
operator|&
name|rwlock
operator|->
name|rw_flags
argument_list|)
expr_stmt|;
name|error
operator|=
name|umtx_key_get
argument_list|(
name|rwlock
argument_list|,
name|TYPE_RWLOCK
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|timeout
operator|!=
name|NULL
condition|)
name|abs_timeout_init2
argument_list|(
operator|&
name|timo
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|wrflags
operator|=
name|URWLOCK_WRITE_OWNER
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fflag
operator|&
name|URWLOCK_PREFER_READER
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|URWLOCK_PREFER_READER
operator|)
condition|)
name|wrflags
operator||=
name|URWLOCK_WRITE_WAITERS
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|state
operator|=
name|fuword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|int32_t
operator|*
argument_list|,
operator|&
name|rwlock
operator|->
name|rw_state
argument_list|)
argument_list|)
expr_stmt|;
comment|/* try to lock it */
while|while
condition|(
operator|!
operator|(
name|state
operator|&
name|wrflags
operator|)
condition|)
block|{
if|if
condition|(
name|__predict_false
argument_list|(
name|URWLOCK_READER_COUNT
argument_list|(
name|state
argument_list|)
operator|==
name|URWLOCK_MAX_READERS
argument_list|)
condition|)
block|{
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
name|oldstate
operator|=
name|casuword32
argument_list|(
operator|&
name|rwlock
operator|->
name|rw_state
argument_list|,
name|state
argument_list|,
name|state
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldstate
operator|==
operator|-
literal|1
condition|)
block|{
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
if|if
condition|(
name|oldstate
operator|==
name|state
condition|)
block|{
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
name|umtxq_check_susp
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|state
operator|=
name|oldstate
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
break|break;
comment|/* grab monitor lock */
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
comment|/* 		 * re-read the state, in case it changed between the try-lock above 		 * and the check below 		 */
name|state
operator|=
name|fuword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|int32_t
operator|*
argument_list|,
operator|&
name|rwlock
operator|->
name|rw_state
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set read contention bit */
while|while
condition|(
operator|(
name|state
operator|&
name|wrflags
operator|)
operator|&&
operator|!
operator|(
name|state
operator|&
name|URWLOCK_READ_WAITERS
operator|)
condition|)
block|{
name|oldstate
operator|=
name|casuword32
argument_list|(
operator|&
name|rwlock
operator|->
name|rw_state
argument_list|,
name|state
argument_list|,
name|state
operator||
name|URWLOCK_READ_WAITERS
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldstate
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|oldstate
operator|==
name|state
condition|)
goto|goto
name|sleep
goto|;
name|state
operator|=
name|oldstate
expr_stmt|;
name|error
operator|=
name|umtxq_check_susp
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* state is changed while setting flags, restart */
if|if
condition|(
operator|!
operator|(
name|state
operator|&
name|wrflags
operator|)
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|error
operator|=
name|umtxq_check_susp
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
continue|continue;
block|}
name|sleep
label|:
comment|/* contention bit is set, before sleeping, increase read waiter count */
name|blocked_readers
operator|=
name|fuword32
argument_list|(
operator|&
name|rwlock
operator|->
name|rw_blocked_readers
argument_list|)
expr_stmt|;
name|suword32
argument_list|(
operator|&
name|rwlock
operator|->
name|rw_blocked_readers
argument_list|,
name|blocked_readers
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|&
name|wrflags
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_insert
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|error
operator|=
name|umtxq_sleep
argument_list|(
name|uq
argument_list|,
literal|"urdlck"
argument_list|,
name|timeout
operator|==
name|NULL
condition|?
name|NULL
else|:
operator|&
name|timo
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|state
operator|=
name|fuword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|int32_t
operator|*
argument_list|,
operator|&
name|rwlock
operator|->
name|rw_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* decrease read waiter count, and may clear read contention bit */
name|blocked_readers
operator|=
name|fuword32
argument_list|(
operator|&
name|rwlock
operator|->
name|rw_blocked_readers
argument_list|)
expr_stmt|;
name|suword32
argument_list|(
operator|&
name|rwlock
operator|->
name|rw_blocked_readers
argument_list|,
name|blocked_readers
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocked_readers
operator|==
literal|1
condition|)
block|{
name|state
operator|=
name|fuword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|int32_t
operator|*
argument_list|,
operator|&
name|rwlock
operator|->
name|rw_state
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|oldstate
operator|=
name|casuword32
argument_list|(
operator|&
name|rwlock
operator|->
name|rw_state
argument_list|,
name|state
argument_list|,
name|state
operator|&
operator|~
name|URWLOCK_READ_WAITERS
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldstate
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|oldstate
operator|==
name|state
condition|)
break|break;
name|state
operator|=
name|oldstate
expr_stmt|;
name|error
operator|=
name|umtxq_check_susp
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_rw_wrlock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|urwlock
modifier|*
name|rwlock
parameter_list|,
name|struct
name|_umtx_time
modifier|*
name|timeout
parameter_list|)
block|{
name|struct
name|abs_timeout
name|timo
decl_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|int32_t
name|state
decl_stmt|,
name|oldstate
decl_stmt|;
name|int32_t
name|blocked_writers
decl_stmt|;
name|int32_t
name|blocked_readers
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
name|flags
operator|=
name|fuword32
argument_list|(
operator|&
name|rwlock
operator|->
name|rw_flags
argument_list|)
expr_stmt|;
name|error
operator|=
name|umtx_key_get
argument_list|(
name|rwlock
argument_list|,
name|TYPE_RWLOCK
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|timeout
operator|!=
name|NULL
condition|)
name|abs_timeout_init2
argument_list|(
operator|&
name|timo
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|blocked_readers
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|state
operator|=
name|fuword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|int32_t
operator|*
argument_list|,
operator|&
name|rwlock
operator|->
name|rw_state
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|state
operator|&
name|URWLOCK_WRITE_OWNER
operator|)
operator|&&
name|URWLOCK_READER_COUNT
argument_list|(
name|state
argument_list|)
operator|==
literal|0
condition|)
block|{
name|oldstate
operator|=
name|casuword32
argument_list|(
operator|&
name|rwlock
operator|->
name|rw_state
argument_list|,
name|state
argument_list|,
name|state
operator||
name|URWLOCK_WRITE_OWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldstate
operator|==
operator|-
literal|1
condition|)
block|{
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
if|if
condition|(
name|oldstate
operator|==
name|state
condition|)
block|{
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|state
operator|=
name|oldstate
expr_stmt|;
name|error
operator|=
name|umtxq_check_susp
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|state
operator|&
operator|(
name|URWLOCK_WRITE_OWNER
operator||
name|URWLOCK_WRITE_WAITERS
operator|)
operator|)
operator|&&
name|blocked_readers
operator|!=
literal|0
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_signal_queue
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|,
name|INT_MAX
argument_list|,
name|UMTX_SHARED_QUEUE
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* grab monitor lock */
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
comment|/* 		 * re-read the state, in case it changed between the try-lock above 		 * and the check below 		 */
name|state
operator|=
name|fuword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|int32_t
operator|*
argument_list|,
operator|&
name|rwlock
operator|->
name|rw_state
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|state
operator|&
name|URWLOCK_WRITE_OWNER
operator|)
operator|||
name|URWLOCK_READER_COUNT
argument_list|(
name|state
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|state
operator|&
name|URWLOCK_WRITE_WAITERS
operator|)
operator|==
literal|0
condition|)
block|{
name|oldstate
operator|=
name|casuword32
argument_list|(
operator|&
name|rwlock
operator|->
name|rw_state
argument_list|,
name|state
argument_list|,
name|state
operator||
name|URWLOCK_WRITE_WAITERS
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldstate
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|oldstate
operator|==
name|state
condition|)
goto|goto
name|sleep
goto|;
name|state
operator|=
name|oldstate
expr_stmt|;
name|error
operator|=
name|umtxq_check_susp
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|state
operator|&
name|URWLOCK_WRITE_OWNER
operator|)
operator|&&
name|URWLOCK_READER_COUNT
argument_list|(
name|state
argument_list|)
operator|==
literal|0
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|error
operator|=
name|umtxq_check_susp
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
continue|continue;
block|}
name|sleep
label|:
name|blocked_writers
operator|=
name|fuword32
argument_list|(
operator|&
name|rwlock
operator|->
name|rw_blocked_writers
argument_list|)
expr_stmt|;
name|suword32
argument_list|(
operator|&
name|rwlock
operator|->
name|rw_blocked_writers
argument_list|,
name|blocked_writers
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|state
operator|&
name|URWLOCK_WRITE_OWNER
operator|)
operator|||
name|URWLOCK_READER_COUNT
argument_list|(
name|state
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_insert_queue
argument_list|(
name|uq
argument_list|,
name|UMTX_EXCLUSIVE_QUEUE
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|error
operator|=
name|umtxq_sleep
argument_list|(
name|uq
argument_list|,
literal|"uwrlck"
argument_list|,
name|timeout
operator|==
name|NULL
condition|?
name|NULL
else|:
operator|&
name|timo
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_remove_queue
argument_list|(
name|uq
argument_list|,
name|UMTX_EXCLUSIVE_QUEUE
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|state
operator|=
name|fuword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|int32_t
operator|*
argument_list|,
operator|&
name|rwlock
operator|->
name|rw_state
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|blocked_writers
operator|=
name|fuword32
argument_list|(
operator|&
name|rwlock
operator|->
name|rw_blocked_writers
argument_list|)
expr_stmt|;
name|suword32
argument_list|(
operator|&
name|rwlock
operator|->
name|rw_blocked_writers
argument_list|,
name|blocked_writers
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocked_writers
operator|==
literal|1
condition|)
block|{
name|state
operator|=
name|fuword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|int32_t
operator|*
argument_list|,
operator|&
name|rwlock
operator|->
name|rw_state
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|oldstate
operator|=
name|casuword32
argument_list|(
operator|&
name|rwlock
operator|->
name|rw_state
argument_list|,
name|state
argument_list|,
name|state
operator|&
operator|~
name|URWLOCK_WRITE_WAITERS
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldstate
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|oldstate
operator|==
name|state
condition|)
break|break;
name|state
operator|=
name|oldstate
expr_stmt|;
name|error
operator|=
name|umtxq_check_susp
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* 				 * We are leaving the URWLOCK_WRITE_WAITERS 				 * behind, but this should not harm the 				 * correctness. 				 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
name|blocked_readers
operator|=
name|fuword32
argument_list|(
operator|&
name|rwlock
operator|->
name|rw_blocked_readers
argument_list|)
expr_stmt|;
block|}
else|else
name|blocked_readers
operator|=
literal|0
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
block|}
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_rw_unlock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|urwlock
modifier|*
name|rwlock
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|int32_t
name|state
decl_stmt|,
name|oldstate
decl_stmt|;
name|int
name|error
decl_stmt|,
name|q
decl_stmt|,
name|count
decl_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
name|flags
operator|=
name|fuword32
argument_list|(
operator|&
name|rwlock
operator|->
name|rw_flags
argument_list|)
expr_stmt|;
name|error
operator|=
name|umtx_key_get
argument_list|(
name|rwlock
argument_list|,
name|TYPE_RWLOCK
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|state
operator|=
name|fuword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|int32_t
operator|*
argument_list|,
operator|&
name|rwlock
operator|->
name|rw_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|&
name|URWLOCK_WRITE_OWNER
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|oldstate
operator|=
name|casuword32
argument_list|(
operator|&
name|rwlock
operator|->
name|rw_state
argument_list|,
name|state
argument_list|,
name|state
operator|&
operator|~
name|URWLOCK_WRITE_OWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldstate
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|oldstate
operator|!=
name|state
condition|)
block|{
name|state
operator|=
name|oldstate
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|oldstate
operator|&
name|URWLOCK_WRITE_OWNER
operator|)
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|umtxq_check_susp
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
else|else
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|URWLOCK_READER_COUNT
argument_list|(
name|state
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|oldstate
operator|=
name|casuword32
argument_list|(
operator|&
name|rwlock
operator|->
name|rw_state
argument_list|,
name|state
argument_list|,
name|state
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldstate
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|oldstate
operator|!=
name|state
condition|)
block|{
name|state
operator|=
name|oldstate
expr_stmt|;
if|if
condition|(
name|URWLOCK_READER_COUNT
argument_list|(
name|oldstate
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|umtxq_check_susp
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
else|else
break|break;
block|}
block|}
else|else
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|URWLOCK_PREFER_READER
operator|)
condition|)
block|{
if|if
condition|(
name|state
operator|&
name|URWLOCK_WRITE_WAITERS
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|q
operator|=
name|UMTX_EXCLUSIVE_QUEUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|&
name|URWLOCK_READ_WAITERS
condition|)
block|{
name|count
operator|=
name|INT_MAX
expr_stmt|;
name|q
operator|=
name|UMTX_SHARED_QUEUE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|state
operator|&
name|URWLOCK_READ_WAITERS
condition|)
block|{
name|count
operator|=
name|INT_MAX
expr_stmt|;
name|q
operator|=
name|UMTX_SHARED_QUEUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|state
operator|&
name|URWLOCK_WRITE_WAITERS
condition|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|q
operator|=
name|UMTX_EXCLUSIVE_QUEUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_signal_queue
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|,
name|count
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_sem_wait
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_usem
modifier|*
name|sem
parameter_list|,
name|struct
name|_umtx_time
modifier|*
name|timeout
parameter_list|)
block|{
name|struct
name|abs_timeout
name|timo
decl_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|,
name|count
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
name|flags
operator|=
name|fuword32
argument_list|(
operator|&
name|sem
operator|->
name|_flags
argument_list|)
expr_stmt|;
name|error
operator|=
name|umtx_key_get
argument_list|(
name|sem
argument_list|,
name|TYPE_SEM
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|timeout
operator|!=
name|NULL
condition|)
name|abs_timeout_init2
argument_list|(
operator|&
name|timo
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_insert
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|casuword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|sem
operator|->
name|_has_waiters
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|count
operator|=
name|fuword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|sem
operator|->
name|_count
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|error
operator|=
name|umtxq_sleep
argument_list|(
name|uq
argument_list|,
literal|"usem"
argument_list|,
name|timeout
operator|==
name|NULL
condition|?
name|NULL
else|:
operator|&
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uq
operator|->
name|uq_flags
operator|&
name|UQF_UMTXQ
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
comment|/* A relative timeout cannot be restarted. */
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|&&
name|timeout
operator|!=
name|NULL
operator|&&
operator|(
name|timeout
operator|->
name|_flags
operator|&
name|UMTX_ABSTIME
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
block|}
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Signal a userland condition variable.  */
end_comment

begin_function
specifier|static
name|int
name|do_sem_wake
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_usem
modifier|*
name|sem
parameter_list|)
block|{
name|struct
name|umtx_key
name|key
decl_stmt|;
name|int
name|error
decl_stmt|,
name|cnt
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|flags
operator|=
name|fuword32
argument_list|(
operator|&
name|sem
operator|->
name|_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|sem
argument_list|,
name|TYPE_SEM
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|umtxq_count
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
name|umtxq_signal
argument_list|(
operator|&
name|key
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Check if count is greater than 0, this means the memory is 		 * still being referenced by user code, so we can safely 		 * update _has_waiters flag. 		 */
if|if
condition|(
name|cnt
operator|==
literal|1
condition|)
block|{
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|error
operator|=
name|suword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|sem
operator|->
name|_has_waiters
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
block|}
block|}
name|umtxq_unbusy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sys__umtx_lock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_lock_args
modifier|*
name|uap
parameter_list|)
comment|/* struct umtx *umtx */
block|{
return|return
name|do_lock_umtx
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|umtx
argument_list|,
name|td
operator|->
name|td_tid
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|sys__umtx_unlock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_unlock_args
modifier|*
name|uap
parameter_list|)
comment|/* struct umtx *umtx */
block|{
return|return
name|do_unlock_umtx
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|umtx
argument_list|,
name|td
operator|->
name|td_tid
argument_list|)
return|;
block|}
end_function

begin_function
specifier|inline
name|int
name|umtx_copyin_timeout
parameter_list|(
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|addr
argument_list|,
name|tsp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|timespec
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tsp
operator|->
name|tv_sec
operator|<
literal|0
operator|||
name|tsp
operator|->
name|tv_nsec
operator|>=
literal|1000000000
operator|||
name|tsp
operator|->
name|tv_nsec
operator|<
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|umtx_copyin_umtx_time
parameter_list|(
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|struct
name|_umtx_time
modifier|*
name|tp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|size
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|timespec
argument_list|)
condition|)
block|{
name|tp
operator|->
name|_clockid
operator|=
name|CLOCK_REALTIME
expr_stmt|;
name|tp
operator|->
name|_flags
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|addr
argument_list|,
operator|&
name|tp
operator|->
name|_timeout
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|timespec
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|copyin
argument_list|(
name|addr
argument_list|,
name|tp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_umtx_time
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|tp
operator|->
name|_timeout
operator|.
name|tv_sec
operator|<
literal|0
operator|||
name|tp
operator|->
name|_timeout
operator|.
name|tv_nsec
operator|>=
literal|1000000000
operator|||
name|tp
operator|->
name|_timeout
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_lock_umtx
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timespec
modifier|*
name|ts
decl_stmt|,
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allow a null timespec (wait forever). */
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|ts
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|umtx_copyin_timeout
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ts
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
return|return
operator|(
name|do_lock_umtx
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|val
argument_list|,
name|ts
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_unlock_umtx
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|do_unlock_umtx
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_wait
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|_umtx_time
name|timeout
decl_stmt|,
modifier|*
name|tm_p
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|tm_p
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|umtx_copyin_umtx_time
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|(
name|size_t
operator|)
name|uap
operator|->
name|uaddr1
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tm_p
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
return|return
name|do_wait
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|val
argument_list|,
name|tm_p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_wait_uint
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|_umtx_time
name|timeout
decl_stmt|,
modifier|*
name|tm_p
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|tm_p
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|umtx_copyin_umtx_time
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|(
name|size_t
operator|)
name|uap
operator|->
name|uaddr1
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tm_p
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
return|return
name|do_wait
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|val
argument_list|,
name|tm_p
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_wait_uint_private
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|_umtx_time
modifier|*
name|tm_p
decl_stmt|,
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|tm_p
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|umtx_copyin_umtx_time
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|(
name|size_t
operator|)
name|uap
operator|->
name|uaddr1
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tm_p
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
return|return
name|do_wait
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|val
argument_list|,
name|tm_p
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_wake
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|kern_umtx_wake
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|val
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BATCH_SIZE
value|128
end_define

begin_function
specifier|static
name|int
name|__umtx_op_nwake_private
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|int
name|count
init|=
name|uap
operator|->
name|val
decl_stmt|;
name|void
modifier|*
name|uaddrs
index|[
name|BATCH_SIZE
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|upp
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|uap
operator|->
name|obj
decl_stmt|;
name|int
name|tocopy
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pos
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|tocopy
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|tocopy
operator|>
name|BATCH_SIZE
condition|)
name|tocopy
operator|=
name|BATCH_SIZE
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|upp
operator|+
name|pos
argument_list|,
name|uaddrs
argument_list|,
name|tocopy
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tocopy
condition|;
operator|++
name|i
control|)
name|kern_umtx_wake
argument_list|(
name|td
argument_list|,
name|uaddrs
index|[
name|i
index|]
argument_list|,
name|INT_MAX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|count
operator|-=
name|tocopy
expr_stmt|;
name|pos
operator|+=
name|tocopy
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_wake_private
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|kern_umtx_wake
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|val
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_lock_umutex
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|_umtx_time
modifier|*
name|tm_p
decl_stmt|,
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allow a null timespec (wait forever). */
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|tm_p
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|umtx_copyin_umtx_time
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|(
name|size_t
operator|)
name|uap
operator|->
name|uaddr1
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tm_p
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
return|return
name|do_lock_umutex
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|tm_p
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_trylock_umutex
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
name|do_lock_umutex
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|NULL
argument_list|,
name|_UMUTEX_TRY
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_wait_umutex
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|_umtx_time
modifier|*
name|tm_p
decl_stmt|,
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allow a null timespec (wait forever). */
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|tm_p
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|umtx_copyin_umtx_time
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|(
name|size_t
operator|)
name|uap
operator|->
name|uaddr1
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tm_p
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
return|return
name|do_lock_umutex
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|tm_p
argument_list|,
name|_UMUTEX_WAIT
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_wake_umutex
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
name|do_wake_umutex
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_unlock_umutex
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
name|do_unlock_umutex
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_set_ceiling
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
name|do_set_ceiling
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|val
argument_list|,
name|uap
operator|->
name|uaddr1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_cv_wait
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timespec
modifier|*
name|ts
decl_stmt|,
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allow a null timespec (wait forever). */
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|ts
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|umtx_copyin_timeout
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ts
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
return|return
operator|(
name|do_cv_wait
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|uaddr1
argument_list|,
name|ts
argument_list|,
name|uap
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_cv_signal
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
name|do_cv_signal
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_cv_broadcast
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
name|do_cv_broadcast
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_rw_rdlock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|_umtx_time
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allow a null timespec (wait forever). */
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|do_rw_rdlock
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|umtx_copyin_umtx_time
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|(
name|size_t
operator|)
name|uap
operator|->
name|uaddr1
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|do_rw_rdlock
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|val
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_rw_wrlock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|_umtx_time
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allow a null timespec (wait forever). */
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|do_rw_wrlock
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|umtx_copyin_umtx_time
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|(
name|size_t
operator|)
name|uap
operator|->
name|uaddr1
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|do_rw_wrlock
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_rw_unlock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
name|do_rw_unlock
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_sem_wait
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|_umtx_time
modifier|*
name|tm_p
decl_stmt|,
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allow a null timespec (wait forever). */
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|tm_p
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|umtx_copyin_umtx_time
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|(
name|size_t
operator|)
name|uap
operator|->
name|uaddr1
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tm_p
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
return|return
operator|(
name|do_sem_wait
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|tm_p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_sem_wake
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
name|do_sem_wake
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_wake2_umutex
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
name|do_wake2_umutex
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|val
argument_list|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|_umtx_op_func
function_decl|)
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|_umtx_op_func
name|op_table
index|[]
init|=
block|{
name|__umtx_op_lock_umtx
block|,
comment|/* UMTX_OP_LOCK */
name|__umtx_op_unlock_umtx
block|,
comment|/* UMTX_OP_UNLOCK */
name|__umtx_op_wait
block|,
comment|/* UMTX_OP_WAIT */
name|__umtx_op_wake
block|,
comment|/* UMTX_OP_WAKE */
name|__umtx_op_trylock_umutex
block|,
comment|/* UMTX_OP_MUTEX_TRYLOCK */
name|__umtx_op_lock_umutex
block|,
comment|/* UMTX_OP_MUTEX_LOCK */
name|__umtx_op_unlock_umutex
block|,
comment|/* UMTX_OP_MUTEX_UNLOCK */
name|__umtx_op_set_ceiling
block|,
comment|/* UMTX_OP_SET_CEILING */
name|__umtx_op_cv_wait
block|,
comment|/* UMTX_OP_CV_WAIT*/
name|__umtx_op_cv_signal
block|,
comment|/* UMTX_OP_CV_SIGNAL */
name|__umtx_op_cv_broadcast
block|,
comment|/* UMTX_OP_CV_BROADCAST */
name|__umtx_op_wait_uint
block|,
comment|/* UMTX_OP_WAIT_UINT */
name|__umtx_op_rw_rdlock
block|,
comment|/* UMTX_OP_RW_RDLOCK */
name|__umtx_op_rw_wrlock
block|,
comment|/* UMTX_OP_RW_WRLOCK */
name|__umtx_op_rw_unlock
block|,
comment|/* UMTX_OP_RW_UNLOCK */
name|__umtx_op_wait_uint_private
block|,
comment|/* UMTX_OP_WAIT_UINT_PRIVATE */
name|__umtx_op_wake_private
block|,
comment|/* UMTX_OP_WAKE_PRIVATE */
name|__umtx_op_wait_umutex
block|,
comment|/* UMTX_OP_UMUTEX_WAIT */
name|__umtx_op_wake_umutex
block|,
comment|/* UMTX_OP_UMUTEX_WAKE */
name|__umtx_op_sem_wait
block|,
comment|/* UMTX_OP_SEM_WAIT */
name|__umtx_op_sem_wake
block|,
comment|/* UMTX_OP_SEM_WAKE */
name|__umtx_op_nwake_private
block|,
comment|/* UMTX_OP_NWAKE_PRIVATE */
name|__umtx_op_wake2_umutex
comment|/* UMTX_OP_UMUTEX_WAKE2 */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|sys__umtx_op
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
if|if
condition|(
operator|(
name|unsigned
operator|)
name|uap
operator|->
name|op
operator|<
name|UMTX_OP_MAX
condition|)
return|return
call|(
modifier|*
name|op_table
index|[
name|uap
operator|->
name|op
index|]
call|)
argument_list|(
name|td
argument_list|,
name|uap
argument_list|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
end_ifdef

begin_function
name|int
name|freebsd32_umtx_lock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd32_umtx_lock_args
modifier|*
name|uap
parameter_list|)
comment|/* struct umtx *umtx */
block|{
return|return
operator|(
name|do_lock_umtx32
argument_list|(
name|td
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
name|uap
operator|->
name|umtx
argument_list|,
name|td
operator|->
name|td_tid
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|freebsd32_umtx_unlock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd32_umtx_unlock_args
modifier|*
name|uap
parameter_list|)
comment|/* struct umtx *umtx */
block|{
return|return
operator|(
name|do_unlock_umtx32
argument_list|(
name|td
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
name|uap
operator|->
name|umtx
argument_list|,
name|td
operator|->
name|td_tid
argument_list|)
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|timespec32
block|{
name|int32_t
name|tv_sec
decl_stmt|;
name|int32_t
name|tv_nsec
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|umtx_time32
block|{
name|struct
name|timespec32
name|timeout
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|uint32_t
name|clockid
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|int
name|umtx_copyin_timeout32
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|struct
name|timespec32
name|ts32
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|addr
argument_list|,
operator|&
name|ts32
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|timespec32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ts32
operator|.
name|tv_sec
operator|<
literal|0
operator|||
name|ts32
operator|.
name|tv_nsec
operator|>=
literal|1000000000
operator|||
name|ts32
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|tsp
operator|->
name|tv_sec
operator|=
name|ts32
operator|.
name|tv_sec
expr_stmt|;
name|tsp
operator|->
name|tv_nsec
operator|=
name|ts32
operator|.
name|tv_nsec
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|umtx_copyin_umtx_time32
parameter_list|(
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|struct
name|_umtx_time
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|umtx_time32
name|t32
decl_stmt|;
name|int
name|error
decl_stmt|;
name|t32
operator|.
name|clockid
operator|=
name|CLOCK_REALTIME
expr_stmt|;
name|t32
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|size
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|timespec32
argument_list|)
condition|)
name|error
operator|=
name|copyin
argument_list|(
name|addr
argument_list|,
operator|&
name|t32
operator|.
name|timeout
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|timespec32
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|copyin
argument_list|(
name|addr
argument_list|,
operator|&
name|t32
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|umtx_time32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|t32
operator|.
name|timeout
operator|.
name|tv_sec
operator|<
literal|0
operator|||
name|t32
operator|.
name|timeout
operator|.
name|tv_nsec
operator|>=
literal|1000000000
operator|||
name|t32
operator|.
name|timeout
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|tp
operator|->
name|_timeout
operator|.
name|tv_sec
operator|=
name|t32
operator|.
name|timeout
operator|.
name|tv_sec
expr_stmt|;
name|tp
operator|->
name|_timeout
operator|.
name|tv_nsec
operator|=
name|t32
operator|.
name|timeout
operator|.
name|tv_nsec
expr_stmt|;
name|tp
operator|->
name|_flags
operator|=
name|t32
operator|.
name|flags
expr_stmt|;
name|tp
operator|->
name|_clockid
operator|=
name|t32
operator|.
name|clockid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_lock_umtx_compat32
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timespec
modifier|*
name|ts
decl_stmt|,
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allow a null timespec (wait forever). */
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|ts
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|umtx_copyin_timeout32
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ts
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
return|return
operator|(
name|do_lock_umtx32
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|val
argument_list|,
name|ts
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_unlock_umtx_compat32
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|do_unlock_umtx32
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
operator|(
name|uint32_t
operator|)
name|uap
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_wait_compat32
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|_umtx_time
modifier|*
name|tm_p
decl_stmt|,
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|tm_p
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|umtx_copyin_umtx_time32
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|(
name|size_t
operator|)
name|uap
operator|->
name|uaddr1
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tm_p
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
return|return
name|do_wait
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|val
argument_list|,
name|tm_p
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_lock_umutex_compat32
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|_umtx_time
modifier|*
name|tm_p
decl_stmt|,
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allow a null timespec (wait forever). */
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|tm_p
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|umtx_copyin_umtx_time
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|(
name|size_t
operator|)
name|uap
operator|->
name|uaddr1
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tm_p
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
return|return
name|do_lock_umutex
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|tm_p
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_wait_umutex_compat32
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|_umtx_time
modifier|*
name|tm_p
decl_stmt|,
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allow a null timespec (wait forever). */
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|tm_p
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|umtx_copyin_umtx_time32
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|(
name|size_t
operator|)
name|uap
operator|->
name|uaddr1
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tm_p
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
return|return
name|do_lock_umutex
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|tm_p
argument_list|,
name|_UMUTEX_WAIT
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_cv_wait_compat32
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timespec
modifier|*
name|ts
decl_stmt|,
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allow a null timespec (wait forever). */
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|ts
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|umtx_copyin_timeout32
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ts
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
return|return
operator|(
name|do_cv_wait
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|uaddr1
argument_list|,
name|ts
argument_list|,
name|uap
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_rw_rdlock_compat32
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|_umtx_time
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allow a null timespec (wait forever). */
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|do_rw_rdlock
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|umtx_copyin_umtx_time32
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|(
name|size_t
operator|)
name|uap
operator|->
name|uaddr1
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|do_rw_rdlock
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|val
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_rw_wrlock_compat32
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|_umtx_time
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allow a null timespec (wait forever). */
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|do_rw_wrlock
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|umtx_copyin_umtx_time32
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|(
name|size_t
operator|)
name|uap
operator|->
name|uaddr1
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|do_rw_wrlock
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_wait_uint_private_compat32
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|_umtx_time
modifier|*
name|tm_p
decl_stmt|,
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|tm_p
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|umtx_copyin_umtx_time32
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|(
name|size_t
operator|)
name|uap
operator|->
name|uaddr1
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tm_p
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
return|return
name|do_wait
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|val
argument_list|,
name|tm_p
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_sem_wait_compat32
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|_umtx_time
modifier|*
name|tm_p
decl_stmt|,
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allow a null timespec (wait forever). */
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|tm_p
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|umtx_copyin_umtx_time32
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|(
name|size_t
operator|)
name|uap
operator|->
name|uaddr1
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tm_p
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
return|return
operator|(
name|do_sem_wait
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|tm_p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_nwake_private32
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|int
name|count
init|=
name|uap
operator|->
name|val
decl_stmt|;
name|uint32_t
name|uaddrs
index|[
name|BATCH_SIZE
index|]
decl_stmt|;
name|uint32_t
modifier|*
modifier|*
name|upp
init|=
operator|(
name|uint32_t
operator|*
operator|*
operator|)
name|uap
operator|->
name|obj
decl_stmt|;
name|int
name|tocopy
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pos
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|tocopy
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|tocopy
operator|>
name|BATCH_SIZE
condition|)
name|tocopy
operator|=
name|BATCH_SIZE
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|upp
operator|+
name|pos
argument_list|,
name|uaddrs
argument_list|,
name|tocopy
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tocopy
condition|;
operator|++
name|i
control|)
name|kern_umtx_wake
argument_list|(
name|td
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|uaddrs
index|[
name|i
index|]
argument_list|,
name|INT_MAX
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|count
operator|-=
name|tocopy
expr_stmt|;
name|pos
operator|+=
name|tocopy
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|_umtx_op_func
name|op_table_compat32
index|[]
init|=
block|{
name|__umtx_op_lock_umtx_compat32
block|,
comment|/* UMTX_OP_LOCK */
name|__umtx_op_unlock_umtx_compat32
block|,
comment|/* UMTX_OP_UNLOCK */
name|__umtx_op_wait_compat32
block|,
comment|/* UMTX_OP_WAIT */
name|__umtx_op_wake
block|,
comment|/* UMTX_OP_WAKE */
name|__umtx_op_trylock_umutex
block|,
comment|/* UMTX_OP_MUTEX_LOCK */
name|__umtx_op_lock_umutex_compat32
block|,
comment|/* UMTX_OP_MUTEX_TRYLOCK */
name|__umtx_op_unlock_umutex
block|,
comment|/* UMTX_OP_MUTEX_UNLOCK	*/
name|__umtx_op_set_ceiling
block|,
comment|/* UMTX_OP_SET_CEILING */
name|__umtx_op_cv_wait_compat32
block|,
comment|/* UMTX_OP_CV_WAIT*/
name|__umtx_op_cv_signal
block|,
comment|/* UMTX_OP_CV_SIGNAL */
name|__umtx_op_cv_broadcast
block|,
comment|/* UMTX_OP_CV_BROADCAST */
name|__umtx_op_wait_compat32
block|,
comment|/* UMTX_OP_WAIT_UINT */
name|__umtx_op_rw_rdlock_compat32
block|,
comment|/* UMTX_OP_RW_RDLOCK */
name|__umtx_op_rw_wrlock_compat32
block|,
comment|/* UMTX_OP_RW_WRLOCK */
name|__umtx_op_rw_unlock
block|,
comment|/* UMTX_OP_RW_UNLOCK */
name|__umtx_op_wait_uint_private_compat32
block|,
comment|/* UMTX_OP_WAIT_UINT_PRIVATE */
name|__umtx_op_wake_private
block|,
comment|/* UMTX_OP_WAKE_PRIVATE */
name|__umtx_op_wait_umutex_compat32
block|,
comment|/* UMTX_OP_UMUTEX_WAIT */
name|__umtx_op_wake_umutex
block|,
comment|/* UMTX_OP_UMUTEX_WAKE */
name|__umtx_op_sem_wait_compat32
block|,
comment|/* UMTX_OP_SEM_WAIT */
name|__umtx_op_sem_wake
block|,
comment|/* UMTX_OP_SEM_WAKE */
name|__umtx_op_nwake_private32
block|,
comment|/* UMTX_OP_NWAKE_PRIVATE */
name|__umtx_op_wake2_umutex
comment|/* UMTX_OP_UMUTEX_WAKE2 */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|freebsd32_umtx_op
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd32_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
if|if
condition|(
operator|(
name|unsigned
operator|)
name|uap
operator|->
name|op
operator|<
name|UMTX_OP_MAX
condition|)
return|return
call|(
modifier|*
name|op_table_compat32
index|[
name|uap
operator|->
name|op
index|]
call|)
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|_umtx_op_args
operator|*
operator|)
name|uap
argument_list|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|umtx_thread_init
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|td
operator|->
name|td_umtxq
operator|=
name|umtxq_alloc
argument_list|()
expr_stmt|;
name|td
operator|->
name|td_umtxq
operator|->
name|uq_thread
operator|=
name|td
expr_stmt|;
block|}
end_function

begin_function
name|void
name|umtx_thread_fini
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|umtxq_free
argument_list|(
name|td
operator|->
name|td_umtxq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * It will be called when new thread is created, e.g fork().  */
end_comment

begin_function
name|void
name|umtx_thread_alloc
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
name|uq
operator|->
name|uq_inherited_pri
operator|=
name|PRI_MAX
expr_stmt|;
name|KASSERT
argument_list|(
name|uq
operator|->
name|uq_flags
operator|==
literal|0
argument_list|,
operator|(
literal|"uq_flags != 0"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|uq
operator|->
name|uq_thread
operator|==
name|td
argument_list|,
operator|(
literal|"uq_thread != td"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|uq
operator|->
name|uq_pi_blocked
operator|==
name|NULL
argument_list|,
operator|(
literal|"uq_pi_blocked != NULL"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|uq
operator|->
name|uq_pi_contested
argument_list|)
argument_list|,
operator|(
literal|"uq_pi_contested is not empty"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * exec() hook.  */
end_comment

begin_function
specifier|static
name|void
name|umtx_exec_hook
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|proc
modifier|*
name|p
name|__unused
parameter_list|,
name|struct
name|image_params
modifier|*
name|imgp
name|__unused
parameter_list|)
block|{
name|umtx_thread_cleanup
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * thread_exit() hook.  */
end_comment

begin_function
name|void
name|umtx_thread_exit
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|umtx_thread_cleanup
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clean up umtx data.  */
end_comment

begin_function
specifier|static
name|void
name|umtx_thread_cleanup
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|struct
name|umtx_pi
modifier|*
name|pi
decl_stmt|;
if|if
condition|(
operator|(
name|uq
operator|=
name|td
operator|->
name|td_umtxq
operator|)
operator|==
name|NULL
condition|)
return|return;
name|mtx_lock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
name|uq
operator|->
name|uq_inherited_pri
operator|=
name|PRI_MAX
expr_stmt|;
while|while
condition|(
operator|(
name|pi
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|uq
operator|->
name|uq_pi_contested
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pi
operator|->
name|pi_owner
operator|=
name|NULL
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|uq
operator|->
name|uq_pi_contested
argument_list|,
name|pi
argument_list|,
name|pi_link
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|umtx_lock
argument_list|)
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|sched_lend_user_prio
argument_list|(
name|td
argument_list|,
name|PRI_MAX
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

