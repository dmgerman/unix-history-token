begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004, David Xu<davidxu@freebsd.org>  * Copyright (c) 2002, Jeffrey Roberson<jeff@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/thr.h>
end_include

begin_include
include|#
directive|include
file|<sys/umtx.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_define
define|#
directive|define
name|UMTX_PRIVATE
value|0
end_define

begin_define
define|#
directive|define
name|UMTX_SHARED
value|1
end_define

begin_define
define|#
directive|define
name|UMTX_STATIC_SHARED
end_define

begin_struct
struct|struct
name|umtx_key
block|{
name|int
name|type
decl_stmt|;
union|union
block|{
struct|struct
block|{
name|vm_object_t
name|object
decl_stmt|;
name|long
name|offset
decl_stmt|;
block|}
name|shared
struct|;
struct|struct
block|{
name|struct
name|umtx
modifier|*
name|umtx
decl_stmt|;
name|long
name|pid
decl_stmt|;
block|}
name|private
struct|;
struct|struct
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|long
name|word
decl_stmt|;
block|}
name|both
struct|;
block|}
name|info
union|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|umtx_q
block|{
name|LIST_ENTRY
argument_list|(
argument|umtx_q
argument_list|)
name|uq_next
expr_stmt|;
comment|/* Linked list for the hash. */
name|struct
name|umtx_key
name|uq_key
decl_stmt|;
comment|/* Umtx key. */
name|struct
name|thread
modifier|*
name|uq_thread
decl_stmt|;
comment|/* The thread waits on. */
name|LIST_ENTRY
argument_list|(
argument|umtx_q
argument_list|)
name|uq_rqnext
expr_stmt|;
comment|/* Linked list for requeuing. */
name|vm_offset_t
name|uq_addr
decl_stmt|;
comment|/* Umtx's virtual address. */
block|}
struct|;
end_struct

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|umtx_head
argument_list|,
name|umtx_q
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|umtxq_chain
block|{
name|struct
name|mtx
name|uc_lock
decl_stmt|;
comment|/* Lock for this chain. */
name|struct
name|umtx_head
name|uc_queue
decl_stmt|;
comment|/* List of sleep queues. */
define|#
directive|define
name|UCF_BUSY
value|0x01
define|#
directive|define
name|UCF_WANT
value|0x02
name|int
name|uc_flags
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|GOLDEN_RATIO_PRIME
value|2654404609U
end_define

begin_define
define|#
directive|define
name|UMTX_CHAINS
value|128
end_define

begin_define
define|#
directive|define
name|UMTX_SHIFTS
value|(__WORD_BIT - 7)
end_define

begin_decl_stmt
specifier|static
name|struct
name|umtxq_chain
name|umtxq_chains
index|[
name|UMTX_CHAINS
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_UMTX
argument_list|,
literal|"umtx"
argument_list|,
literal|"UMTX queue memory"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|umtxq_init_chains
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|umtxq_hash
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mtx
modifier|*
name|umtxq_mtx
parameter_list|(
name|int
name|chain
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtxq_lock
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtxq_unlock
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtxq_busy
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtxq_unbusy
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtxq_insert
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtxq_remove
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|umtxq_sleep
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|,
name|int
name|prio
parameter_list|,
specifier|const
name|char
modifier|*
name|wmesg
parameter_list|,
name|int
name|timo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|umtxq_count
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|umtxq_signal
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|,
name|int
name|nr_wakeup
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|UMTX_DYNAMIC_SHARED
end_ifdef

begin_function_decl
specifier|static
name|void
name|fork_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|p1
parameter_list|,
name|struct
name|proc
modifier|*
name|p2
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|umtx_key_match
parameter_list|(
specifier|const
name|struct
name|umtx_key
modifier|*
name|k1
parameter_list|,
specifier|const
name|struct
name|umtx_key
modifier|*
name|k2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|umtx_key_get
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umtx
modifier|*
name|umtx
parameter_list|,
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtx_key_release
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSINIT
argument_list|(
name|umtx
argument_list|,
name|SI_SUB_EVENTHANDLER
operator|+
literal|1
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|umtxq_init_chains
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|struct
name|umtx_q
modifier|*
name|umtxq_alloc
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|umtx_q
argument_list|)
argument_list|,
name|M_UMTX
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|umtxq_free
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|)
block|{
name|free
argument_list|(
name|uq
argument_list|,
name|M_UMTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|umtxq_init_chains
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UMTX_CHAINS
condition|;
operator|++
name|i
control|)
block|{
name|mtx_init
argument_list|(
operator|&
name|umtxq_chains
index|[
name|i
index|]
operator|.
name|uc_lock
argument_list|,
literal|"umtxq_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_DUPOK
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|umtxq_chains
index|[
name|i
index|]
operator|.
name|uc_queue
argument_list|)
expr_stmt|;
name|umtxq_chains
index|[
name|i
index|]
operator|.
name|uc_flags
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|UMTX_DYNAMIC_SHARED
name|EVENTHANDLER_REGISTER
argument_list|(
name|process_fork
argument_list|,
name|fork_handler
argument_list|,
literal|0
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|umtxq_hash
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
name|unsigned
name|n
init|=
operator|(
name|uintptr_t
operator|)
name|key
operator|->
name|info
operator|.
name|both
operator|.
name|ptr
operator|+
name|key
operator|->
name|info
operator|.
name|both
operator|.
name|word
decl_stmt|;
return|return
operator|(
operator|(
operator|(
name|n
operator|*
name|GOLDEN_RATIO_PRIME
operator|)
operator|>>
name|UMTX_SHIFTS
operator|)
operator|%
name|UMTX_CHAINS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|umtx_key_match
parameter_list|(
specifier|const
name|struct
name|umtx_key
modifier|*
name|k1
parameter_list|,
specifier|const
name|struct
name|umtx_key
modifier|*
name|k2
parameter_list|)
block|{
return|return
operator|(
name|k1
operator|->
name|type
operator|==
name|k2
operator|->
name|type
operator|&&
name|k1
operator|->
name|info
operator|.
name|both
operator|.
name|ptr
operator|==
name|k2
operator|->
name|info
operator|.
name|both
operator|.
name|ptr
operator|&&
name|k1
operator|->
name|info
operator|.
name|both
operator|.
name|word
operator|==
name|k2
operator|->
name|info
operator|.
name|both
operator|.
name|word
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|mtx
modifier|*
name|umtxq_mtx
parameter_list|(
name|int
name|chain
parameter_list|)
block|{
return|return
operator|(
operator|&
name|umtxq_chains
index|[
name|chain
index|]
operator|.
name|uc_lock
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|umtxq_busy
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
name|int
name|chain
init|=
name|umtxq_hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|mtx_assert
argument_list|(
name|umtxq_mtx
argument_list|(
name|chain
argument_list|)
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
while|while
condition|(
name|umtxq_chains
index|[
name|chain
index|]
operator|.
name|uc_flags
operator|&
name|UCF_BUSY
condition|)
block|{
name|umtxq_chains
index|[
name|chain
index|]
operator|.
name|uc_flags
operator||=
name|UCF_WANT
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|umtxq_chains
index|[
name|chain
index|]
argument_list|,
name|umtxq_mtx
argument_list|(
name|chain
argument_list|)
argument_list|,
name|curthread
operator|->
name|td_priority
argument_list|,
literal|"umtxq_busy"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|umtxq_chains
index|[
name|chain
index|]
operator|.
name|uc_flags
operator||=
name|UCF_BUSY
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|umtxq_unbusy
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
name|int
name|chain
init|=
name|umtxq_hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|mtx_assert
argument_list|(
name|umtxq_mtx
argument_list|(
name|chain
argument_list|)
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|umtxq_chains
index|[
name|chain
index|]
operator|.
name|uc_flags
operator|&
name|UCF_BUSY
argument_list|,
operator|(
literal|"not busy"
operator|)
argument_list|)
expr_stmt|;
name|umtxq_chains
index|[
name|chain
index|]
operator|.
name|uc_flags
operator|&=
operator|~
name|UCF_BUSY
expr_stmt|;
if|if
condition|(
name|umtxq_chains
index|[
name|chain
index|]
operator|.
name|uc_flags
operator|&
name|UCF_WANT
condition|)
block|{
name|umtxq_chains
index|[
name|chain
index|]
operator|.
name|uc_flags
operator|&=
operator|~
name|UCF_WANT
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|umtxq_chains
index|[
name|chain
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|umtxq_lock
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
name|int
name|chain
init|=
name|umtxq_hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
name|umtxq_mtx
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|umtxq_unlock
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
name|int
name|chain
init|=
name|umtxq_hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|mtx_unlock
argument_list|(
name|umtxq_mtx
argument_list|(
name|chain
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Insert a thread onto the umtx queue.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|umtxq_insert
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|)
block|{
name|struct
name|umtx_head
modifier|*
name|head
decl_stmt|;
name|int
name|chain
init|=
name|umtxq_hash
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
decl_stmt|;
name|mtx_assert
argument_list|(
name|umtxq_mtx
argument_list|(
name|chain
argument_list|)
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|head
operator|=
operator|&
name|umtxq_chains
index|[
name|chain
index|]
operator|.
name|uc_queue
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|uq
argument_list|,
name|uq_next
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|uq
operator|->
name|uq_thread
operator|->
name|td_flags
operator||=
name|TDF_UMTXQ
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove thread from the umtx queue.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|umtxq_remove
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|)
block|{
name|mtx_assert
argument_list|(
name|umtxq_mtx
argument_list|(
name|umtxq_hash
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
argument_list|)
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq
operator|->
name|uq_thread
operator|->
name|td_flags
operator|&
name|TDF_UMTXQ
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|uq
argument_list|,
name|uq_next
argument_list|)
expr_stmt|;
comment|/* turning off TDF_UMTXQ should be the last thing. */
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|uq
operator|->
name|uq_thread
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_UMTXQ
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|umtxq_count
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|struct
name|umtx_head
modifier|*
name|head
decl_stmt|;
name|int
name|chain
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|chain
operator|=
name|umtxq_hash
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
name|umtxq_mtx
argument_list|(
name|chain
argument_list|)
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|head
operator|=
operator|&
name|umtxq_chains
index|[
name|chain
index|]
operator|.
name|uc_queue
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|uq
argument_list|,
argument|head
argument_list|,
argument|uq_next
argument_list|)
block|{
if|if
condition|(
name|umtx_key_match
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|,
name|key
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|count
operator|>
literal|1
condition|)
break|break;
block|}
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|umtxq_signal
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|,
name|int
name|n_wake
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|umtx_head
modifier|*
name|head
decl_stmt|;
name|struct
name|thread
modifier|*
name|blocked
init|=
name|NULL
decl_stmt|;
name|int
name|chain
decl_stmt|,
name|ret
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|chain
operator|=
name|umtxq_hash
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
name|umtxq_mtx
argument_list|(
name|chain
argument_list|)
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|head
operator|=
operator|&
name|umtxq_chains
index|[
name|chain
index|]
operator|.
name|uc_queue
expr_stmt|;
for|for
control|(
name|uq
operator|=
name|LIST_FIRST
argument_list|(
name|head
argument_list|)
init|;
name|uq
condition|;
name|uq
operator|=
name|next
control|)
block|{
name|next
operator|=
name|LIST_NEXT
argument_list|(
name|uq
argument_list|,
name|uq_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|umtx_key_match
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|blocked
operator|=
name|uq
operator|->
name|uq_thread
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|blocked
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|ret
operator|>=
name|n_wake
condition|)
break|break;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|umtxq_sleep
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|,
name|int
name|priority
parameter_list|,
specifier|const
name|char
modifier|*
name|wmesg
parameter_list|,
name|int
name|timo
parameter_list|)
block|{
name|int
name|chain
init|=
name|umtxq_hash
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|int
name|error
init|=
name|msleep
argument_list|(
name|td
argument_list|,
name|umtxq_mtx
argument_list|(
name|chain
argument_list|)
argument_list|,
name|priority
argument_list|,
name|wmesg
argument_list|,
name|timo
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|umtx_key_get
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umtx
modifier|*
name|umtx
parameter_list|,
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|UMTX_DYNAMIC_SHARED
argument_list|)
operator|||
name|defined
argument_list|(
name|UMTX_STATIC_SHARED
argument_list|)
name|vm_map_t
name|map
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|boolean_t
name|wired
decl_stmt|;
name|map
operator|=
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
if|if
condition|(
name|vm_map_lookup
argument_list|(
operator|&
name|map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|umtx
argument_list|,
name|VM_PROT_WRITE
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|key
operator|->
name|info
operator|.
name|shared
operator|.
name|object
argument_list|,
operator|&
name|pindex
argument_list|,
operator|&
name|prot
argument_list|,
operator|&
name|wired
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
block|{
return|return
name|EFAULT
return|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|UMTX_DYNAMIC_SHARED
argument_list|)
name|key
operator|->
name|type
operator|=
name|UMTX_SHARED
expr_stmt|;
name|key
operator|->
name|info
operator|.
name|shared
operator|.
name|offset
operator|=
name|entry
operator|->
name|offset
operator|+
name|entry
operator|->
name|start
operator|-
operator|(
name|vm_offset_t
operator|)
name|umtx
expr_stmt|;
comment|/* 	 * Add object reference, if we don't do this, a buggy application 	 * deallocates the object, the object will be reused by other 	 * applications, then unlock will wake wrong thread. 	 */
name|vm_object_reference
argument_list|(
name|key
operator|->
name|info
operator|.
name|shared
operator|.
name|object
argument_list|)
expr_stmt|;
name|vm_map_lookup_done
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|UMTX_STATIC_SHARED
argument_list|)
if|if
condition|(
name|VM_INHERIT_SHARE
operator|==
name|entry
operator|->
name|inheritance
condition|)
block|{
name|key
operator|->
name|type
operator|=
name|UMTX_SHARED
expr_stmt|;
name|key
operator|->
name|info
operator|.
name|shared
operator|.
name|offset
operator|=
name|entry
operator|->
name|offset
operator|+
name|entry
operator|->
name|start
operator|-
operator|(
name|vm_offset_t
operator|)
name|umtx
expr_stmt|;
name|vm_object_reference
argument_list|(
name|key
operator|->
name|info
operator|.
name|shared
operator|.
name|object
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|key
operator|->
name|type
operator|=
name|UMTX_PRIVATE
expr_stmt|;
name|key
operator|->
name|info
operator|.
name|private
operator|.
name|umtx
operator|=
name|umtx
expr_stmt|;
name|key
operator|->
name|info
operator|.
name|private
operator|.
name|pid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
block|}
name|vm_map_lookup_done
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
else|#
directive|else
name|key
operator|->
name|type
operator|=
name|UMTX_PRIVATE
expr_stmt|;
name|key
operator|->
name|info
operator|.
name|private
operator|.
name|umtx
operator|=
name|umtx
expr_stmt|;
name|key
operator|->
name|info
operator|.
name|private
operator|.
name|pid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|umtx_key_release
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|->
name|type
operator|==
name|UMTX_SHARED
condition|)
name|vm_object_deallocate
argument_list|(
name|key
operator|->
name|info
operator|.
name|shared
operator|.
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|umtxq_queue_me
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umtx
modifier|*
name|umtx
parameter_list|,
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|td
argument_list|,
name|umtx
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|uq
operator|->
name|uq_addr
operator|=
operator|(
name|vm_offset_t
operator|)
name|umtx
expr_stmt|;
name|uq
operator|->
name|uq_thread
operator|=
name|td
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
comment|/* hmm, for condition variable, we don't need busy flag. */
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_insert
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|UMTX_DYNAMIC_SHARED
argument_list|)
end_if

begin_function
specifier|static
name|void
name|fork_handler
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|p1
parameter_list|,
name|struct
name|proc
modifier|*
name|p2
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|vm_map_t
name|map
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|boolean_t
name|wired
decl_stmt|;
name|struct
name|umtx_key
name|key
decl_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|umtx_q
argument_list|)
name|workq
expr_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|onq
decl_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|workq
argument_list|)
expr_stmt|;
comment|/* Collect threads waiting on umtxq */
name|PROC_LOCK
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|FOREACH_THREAD_IN_PROC
argument_list|(
argument|p1
argument_list|,
argument|td
argument_list|)
block|{
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_UMTXQ
condition|)
block|{
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
if|if
condition|(
name|uq
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|workq
argument_list|,
name|uq
argument_list|,
name|uq_rqnext
argument_list|)
expr_stmt|;
block|}
block|}
name|PROC_UNLOCK
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|uq
argument_list|,
argument|&workq
argument_list|,
argument|uq_rqnext
argument_list|)
block|{
name|map
operator|=
operator|&
name|p1
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
if|if
condition|(
name|vm_map_lookup
argument_list|(
operator|&
name|map
argument_list|,
name|uq
operator|->
name|uq_addr
argument_list|,
name|VM_PROT_WRITE
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|object
argument_list|,
operator|&
name|pindex
argument_list|,
operator|&
name|prot
argument_list|,
operator|&
name|wired
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
block|{
continue|continue;
block|}
name|key
operator|.
name|type
operator|=
name|UMTX_SHARED
expr_stmt|;
name|key
operator|.
name|info
operator|.
name|shared
operator|.
name|object
operator|=
name|object
expr_stmt|;
name|key
operator|.
name|info
operator|.
name|shared
operator|.
name|offset
operator|=
name|entry
operator|->
name|offset
operator|+
name|entry
operator|->
name|start
operator|-
name|uq
operator|->
name|uq_addr
expr_stmt|;
if|if
condition|(
name|umtx_key_match
argument_list|(
operator|&
name|key
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
condition|)
block|{
name|vm_map_lookup_done
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq
operator|->
name|uq_thread
operator|->
name|td_flags
operator|&
name|TDF_UMTXQ
condition|)
block|{
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|onq
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|onq
operator|=
literal|0
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|onq
condition|)
block|{
name|vm_object_deallocate
argument_list|(
name|uq
operator|->
name|uq_key
operator|.
name|info
operator|.
name|shared
operator|.
name|object
argument_list|)
expr_stmt|;
name|uq
operator|->
name|uq_key
operator|=
name|key
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_insert
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|vm_object_reference
argument_list|(
name|uq
operator|->
name|uq_key
operator|.
name|info
operator|.
name|shared
operator|.
name|object
argument_list|)
expr_stmt|;
block|}
name|vm_map_lookup_done
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|_do_lock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umtx
modifier|*
name|umtx
parameter_list|,
name|long
name|id
parameter_list|,
name|int
name|timo
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|intptr_t
name|owner
decl_stmt|;
name|intptr_t
name|old
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
comment|/* 	 * Care must be exercised when dealing with umtx structure.  It 	 * can fault on any access. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Try the uncontested case.  This should be done in userland. 		 */
name|owner
operator|=
name|casuptr
argument_list|(
operator|(
name|intptr_t
operator|*
operator|)
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
name|UMTX_UNOWNED
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* The acquire succeeded. */
if|if
condition|(
name|owner
operator|==
name|UMTX_UNOWNED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* If no one owns it but it is contested try to acquire it. */
if|if
condition|(
name|owner
operator|==
name|UMTX_CONTESTED
condition|)
block|{
name|owner
operator|=
name|casuptr
argument_list|(
operator|(
name|intptr_t
operator|*
operator|)
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
name|UMTX_CONTESTED
argument_list|,
name|id
operator||
name|UMTX_CONTESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
name|UMTX_CONTESTED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* If this failed the lock has changed, restart. */
continue|continue;
block|}
comment|/* 		 * If we caught a signal, we have retried and now 		 * exit immediately. 		 */
if|if
condition|(
name|error
operator|||
operator|(
name|error
operator|=
name|umtxq_queue_me
argument_list|(
name|td
argument_list|,
name|umtx
argument_list|,
name|uq
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * Set the contested bit so that a release in user space 		 * knows to use the system call for unlock.  If this fails 		 * either some one else has acquired the lock or it has been 		 * released. 		 */
name|old
operator|=
name|casuptr
argument_list|(
operator|(
name|intptr_t
operator|*
operator|)
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
name|owner
argument_list|,
name|owner
operator||
name|UMTX_CONTESTED
argument_list|)
expr_stmt|;
comment|/* The address was invalid. */
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
comment|/* 		 * We set the contested bit, sleep. Otherwise the lock changed 		 * and we need to retry or we lost a race to the thread 		 * unlocking the umtx. 		 */
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|owner
operator|&&
operator|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_UMTXQ
operator|)
condition|)
block|{
name|error
operator|=
name|umtxq_sleep
argument_list|(
name|td
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|,
name|td
operator|->
name|td_priority
operator||
name|PCATCH
argument_list|,
literal|"umtx"
argument_list|,
name|timo
argument_list|)
expr_stmt|;
block|}
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_lock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umtx
modifier|*
name|umtx
parameter_list|,
name|long
name|id
parameter_list|,
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|)
block|{
name|struct
name|timespec
name|ts
decl_stmt|,
name|ts2
decl_stmt|,
name|ts3
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|timeout
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|_do_lock
argument_list|(
name|td
argument_list|,
name|umtx
argument_list|,
name|id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getnanouptime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|timespecadd
argument_list|(
operator|&
name|ts
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
name|_do_lock
argument_list|(
name|td
argument_list|,
name|umtx
argument_list|,
name|id
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ETIMEDOUT
condition|)
break|break;
name|getnanouptime
argument_list|(
operator|&
name|ts2
argument_list|)
expr_stmt|;
if|if
condition|(
name|timespeccmp
argument_list|(
operator|&
name|ts2
argument_list|,
operator|&
name|ts
argument_list|,
operator|>=
argument_list|)
condition|)
block|{
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
break|break;
block|}
name|ts3
operator|=
name|ts
expr_stmt|;
name|timespecsub
argument_list|(
operator|&
name|ts3
argument_list|,
operator|&
name|ts2
argument_list|)
expr_stmt|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|ts3
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * This lets userland back off critical region if needed. 	 */
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_unlock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umtx
modifier|*
name|umtx
parameter_list|,
name|long
name|id
parameter_list|)
block|{
name|struct
name|umtx_key
name|key
decl_stmt|;
name|intptr_t
name|owner
decl_stmt|;
name|intptr_t
name|old
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* 	 * Make sure we own this mtx. 	 * 	 * XXX Need a {fu,su}ptr this is not correct on arch where 	 * sizeof(intptr_t) != sizeof(long). 	 */
if|if
condition|(
operator|(
name|owner
operator|=
name|fuword
argument_list|(
operator|&
name|umtx
operator|->
name|u_owner
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
operator|(
name|owner
operator|&
operator|~
name|UMTX_CONTESTED
operator|)
operator|!=
name|id
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* We should only ever be in here for contested locks */
if|if
condition|(
operator|(
name|owner
operator|&
name|UMTX_CONTESTED
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|td
argument_list|,
name|umtx
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|count
operator|=
name|umtxq_count
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
comment|/* 	 * When unlocking the umtx, it must be marked as unowned if 	 * there is zero or one thread only waiting for it. 	 * Otherwise, it must be marked as contested. 	 */
name|old
operator|=
name|casuptr
argument_list|(
operator|(
name|intptr_t
operator|*
operator|)
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
name|owner
argument_list|,
name|count
operator|<=
literal|1
condition|?
name|UMTX_UNOWNED
else|:
name|UMTX_CONTESTED
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_signal
argument_list|(
operator|&
name|key
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|old
operator|!=
name|owner
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_wait
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umtx
modifier|*
name|umtx
parameter_list|,
name|long
name|id
parameter_list|,
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|,
name|ts2
decl_stmt|,
name|ts3
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|long
name|tmp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|umtxq_queue_me
argument_list|(
name|td
argument_list|,
name|umtx
argument_list|,
name|uq
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tmp
operator|=
name|fuword
argument_list|(
operator|&
name|umtx
operator|->
name|u_owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|id
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|timeout
operator|==
name|NULL
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_UMTXQ
condition|)
name|error
operator|=
name|umtxq_sleep
argument_list|(
name|td
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|,
name|td
operator|->
name|td_priority
operator||
name|PCATCH
argument_list|,
literal|"ucond"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_UMTXQ
operator|)
condition|)
name|error
operator|=
literal|0
expr_stmt|;
else|else
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getnanouptime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|timespecadd
argument_list|(
operator|&
name|ts
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_UMTXQ
condition|)
block|{
name|error
operator|=
name|umtxq_sleep
argument_list|(
name|td
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|,
name|td
operator|->
name|td_priority
operator||
name|PCATCH
argument_list|,
literal|"ucond"
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_UMTXQ
operator|)
condition|)
block|{
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ETIMEDOUT
condition|)
break|break;
name|getnanouptime
argument_list|(
operator|&
name|ts2
argument_list|)
expr_stmt|;
if|if
condition|(
name|timespeccmp
argument_list|(
operator|&
name|ts2
argument_list|,
operator|&
name|ts
argument_list|,
operator|>=
argument_list|)
condition|)
block|{
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
break|break;
block|}
name|ts3
operator|=
name|ts
expr_stmt|;
name|timespecsub
argument_list|(
operator|&
name|ts3
argument_list|,
operator|&
name|ts2
argument_list|)
expr_stmt|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|ts3
argument_list|)
expr_stmt|;
block|}
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_wake
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|uaddr
parameter_list|,
name|int
name|n_wake
parameter_list|)
block|{
name|struct
name|umtx_key
name|key
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|umtx_key_get
argument_list|(
name|td
argument_list|,
name|uaddr
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|ret
operator|=
name|umtxq_signal
argument_list|(
operator|&
name|key
argument_list|,
name|n_wake
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_umtx_lock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_lock_args
modifier|*
name|uap
parameter_list|)
comment|/* struct umtx *umtx */
block|{
return|return
name|_do_lock
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|umtx
argument_list|,
name|td
operator|->
name|td_tid
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|_umtx_unlock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_unlock_args
modifier|*
name|uap
parameter_list|)
comment|/* struct umtx *umtx */
block|{
return|return
name|do_unlock
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|umtx
argument_list|,
name|td
operator|->
name|td_tid
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|_umtx_op
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timespec
name|timeout
decl_stmt|;
name|struct
name|timespec
modifier|*
name|ts
decl_stmt|;
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|op
condition|)
block|{
case|case
name|UMTX_OP_LOCK
case|:
comment|/* Allow a null timespec (wait forever). */
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|ts
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|&
name|timeout
argument_list|,
sizeof|sizeof
argument_list|(
name|timeout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|timeout
operator|.
name|tv_nsec
operator|>=
literal|1000000000
operator|||
name|timeout
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ts
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
name|error
operator|=
name|do_lock
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|umtx
argument_list|,
name|uap
operator|->
name|id
argument_list|,
name|ts
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMTX_OP_UNLOCK
case|:
name|error
operator|=
name|do_unlock
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|umtx
argument_list|,
name|uap
operator|->
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMTX_OP_WAIT
case|:
comment|/* Allow a null timespec (wait forever). */
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|ts
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|&
name|timeout
argument_list|,
sizeof|sizeof
argument_list|(
name|timeout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|timeout
operator|.
name|tv_nsec
operator|>=
literal|1000000000
operator|||
name|timeout
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ts
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
name|error
operator|=
name|do_wait
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|umtx
argument_list|,
name|uap
operator|->
name|id
argument_list|,
name|ts
argument_list|)
expr_stmt|;
break|break;
case|case
name|UMTX_OP_WAKE
case|:
name|error
operator|=
name|do_wake
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|umtx
argument_list|,
name|uap
operator|->
name|id
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

