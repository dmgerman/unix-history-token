begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004, David Xu<davidxu@freebsd.org>  * Copyright (c) 2002, Jeffrey Roberson<jeff@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/umtx.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_IA32
end_ifdef

begin_include
include|#
directive|include
file|<compat/freebsd32/freebsd32_proto.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TYPE_SIMPLE_LOCK
value|0
end_define

begin_define
define|#
directive|define
name|TYPE_SIMPLE_WAIT
value|1
end_define

begin_define
define|#
directive|define
name|TYPE_NORMAL_UMUTEX
value|2
end_define

begin_define
define|#
directive|define
name|TYPE_PI_UMUTEX
value|3
end_define

begin_define
define|#
directive|define
name|TYPE_PP_UMUTEX
value|4
end_define

begin_define
define|#
directive|define
name|TYPE_CV
value|5
end_define

begin_comment
comment|/* Key to represent a unique userland synchronous object */
end_comment

begin_struct
struct|struct
name|umtx_key
block|{
name|int
name|hash
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|shared
decl_stmt|;
union|union
block|{
struct|struct
block|{
name|vm_object_t
name|object
decl_stmt|;
name|uintptr_t
name|offset
decl_stmt|;
block|}
name|shared
struct|;
struct|struct
block|{
name|struct
name|vmspace
modifier|*
name|vs
decl_stmt|;
name|uintptr_t
name|addr
decl_stmt|;
block|}
name|private
struct|;
struct|struct
block|{
name|void
modifier|*
name|a
decl_stmt|;
name|uintptr_t
name|b
decl_stmt|;
block|}
name|both
struct|;
block|}
name|info
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Priority inheritance mutex info. */
end_comment

begin_struct
struct|struct
name|umtx_pi
block|{
comment|/* Owner thread */
name|struct
name|thread
modifier|*
name|pi_owner
decl_stmt|;
comment|/* Reference count */
name|int
name|pi_refcount
decl_stmt|;
comment|/* List entry to link umtx holding by thread */
name|TAILQ_ENTRY
argument_list|(
argument|umtx_pi
argument_list|)
name|pi_link
expr_stmt|;
comment|/* List entry in hash */
name|TAILQ_ENTRY
argument_list|(
argument|umtx_pi
argument_list|)
name|pi_hashlink
expr_stmt|;
comment|/* List for waiters */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|umtx_q
argument_list|)
name|pi_blocked
expr_stmt|;
comment|/* Identify a userland lock object */
name|struct
name|umtx_key
name|pi_key
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A userland synchronous object user. */
end_comment

begin_struct
struct|struct
name|umtx_q
block|{
comment|/* Linked list for the hash. */
name|TAILQ_ENTRY
argument_list|(
argument|umtx_q
argument_list|)
name|uq_link
expr_stmt|;
comment|/* Umtx key. */
name|struct
name|umtx_key
name|uq_key
decl_stmt|;
comment|/* Umtx flags. */
name|int
name|uq_flags
decl_stmt|;
define|#
directive|define
name|UQF_UMTXQ
value|0x0001
comment|/* The thread waits on. */
name|struct
name|thread
modifier|*
name|uq_thread
decl_stmt|;
comment|/* 	 * Blocked on PI mutex. read can use chain lock 	 * or sched_lock, write must have both chain lock and 	 * sched_lock being hold. 	 */
name|struct
name|umtx_pi
modifier|*
name|uq_pi_blocked
decl_stmt|;
comment|/* On blocked list */
name|TAILQ_ENTRY
argument_list|(
argument|umtx_q
argument_list|)
name|uq_lockq
expr_stmt|;
comment|/* Thread contending with us */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|umtx_pi
argument_list|)
name|uq_pi_contested
expr_stmt|;
comment|/* Inherited priority from PP mutex */
name|u_char
name|uq_inherited_pri
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|umtxq_head
argument_list|,
name|umtx_q
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Userland lock object's wait-queue chain */
end_comment

begin_struct
struct|struct
name|umtxq_chain
block|{
comment|/* Lock for this chain. */
name|struct
name|mtx
name|uc_lock
decl_stmt|;
comment|/* List of sleep queues. */
name|struct
name|umtxq_head
name|uc_queue
decl_stmt|;
comment|/* Busy flag */
name|char
name|uc_busy
decl_stmt|;
comment|/* Chain lock waiters */
name|int
name|uc_waiters
decl_stmt|;
comment|/* All PI in the list */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|umtx_pi
argument_list|)
name|uc_pi_list
expr_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|UMTXQ_LOCKED_ASSERT
parameter_list|(
name|uc
parameter_list|)
value|mtx_assert(&(uc)->uc_lock, MA_OWNED)
end_define

begin_comment
comment|/*  * Don't propagate time-sharing priority, there is a security reason,  * a user can simply introduce PI-mutex, let thread A lock the mutex,  * and let another thread B block on the mutex, because B is  * sleeping, its priority will be boosted, this causes A's priority to  * be boosted via priority propagating too and will never be lowered even  * if it is using 100%CPU, this is unfair to other processes.  */
end_comment

begin_define
define|#
directive|define
name|UPRI
parameter_list|(
name|td
parameter_list|)
value|(((td)->td_user_pri>= PRI_MIN_TIMESHARE&&\ 			  (td)->td_user_pri<= PRI_MAX_TIMESHARE) ?\ 			 PRI_MAX_TIMESHARE : (td)->td_user_pri)
end_define

begin_define
define|#
directive|define
name|GOLDEN_RATIO_PRIME
value|2654404609U
end_define

begin_define
define|#
directive|define
name|UMTX_CHAINS
value|128
end_define

begin_define
define|#
directive|define
name|UMTX_SHIFTS
value|(__WORD_BIT - 7)
end_define

begin_define
define|#
directive|define
name|THREAD_SHARE
value|0
end_define

begin_define
define|#
directive|define
name|PROCESS_SHARE
value|1
end_define

begin_define
define|#
directive|define
name|AUTO_SHARE
value|2
end_define

begin_define
define|#
directive|define
name|GET_SHARE
parameter_list|(
name|flags
parameter_list|)
define|\
value|(((flags)& USYNC_PROCESS_SHARED) == 0 ? THREAD_SHARE : PROCESS_SHARE)
end_define

begin_decl_stmt
specifier|static
name|uma_zone_t
name|umtx_pi_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|umtxq_chain
name|umtxq_chains
index|[
name|UMTX_CHAINS
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_UMTX
argument_list|,
literal|"umtx"
argument_list|,
literal|"UMTX queue memory"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|umtx_pi_allocated
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|umtx
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"umtx debug"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_umtx
argument_list|,
name|OID_AUTO
argument_list|,
name|umtx_pi_allocated
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|umtx_pi_allocated
argument_list|,
literal|0
argument_list|,
literal|"Allocated umtx_pi"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_kern_threads
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|umtx_dflt_spins
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_threads
argument_list|,
name|OID_AUTO
argument_list|,
name|umtx_dflt_spins
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|umtx_dflt_spins
argument_list|,
literal|0
argument_list|,
literal|"default umtx spin count"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|umtx_max_spins
init|=
literal|3000
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_threads
argument_list|,
name|OID_AUTO
argument_list|,
name|umtx_max_spins
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|umtx_max_spins
argument_list|,
literal|0
argument_list|,
literal|"max umtx spin count"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|umtxq_sysinit
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtxq_hash
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|umtxq_chain
modifier|*
name|umtxq_getchain
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtxq_lock
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtxq_unlock
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtxq_busy
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtxq_unbusy
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtxq_insert
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtxq_remove
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|umtxq_sleep
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|,
specifier|const
name|char
modifier|*
name|wmesg
parameter_list|,
name|int
name|timo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|umtxq_count
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|umtxq_signal
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|,
name|int
name|nr_wakeup
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|umtx_key_match
parameter_list|(
specifier|const
name|struct
name|umtx_key
modifier|*
name|k1
parameter_list|,
specifier|const
name|struct
name|umtx_key
modifier|*
name|k2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|umtx_key_get
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|share
parameter_list|,
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtx_key_release
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|umtx_pi
modifier|*
name|umtx_pi_alloc
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtx_pi_free
parameter_list|(
name|struct
name|umtx_pi
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_unlock_pp
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtx_thread_cleanup
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|umtx_exec_hook
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|proc
modifier|*
name|p
name|__unused
parameter_list|,
name|struct
name|image_params
modifier|*
name|imgp
name|__unused
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSINIT
argument_list|(
name|umtx
argument_list|,
name|SI_SUB_EVENTHANDLER
operator|+
literal|1
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|umtxq_sysinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|umtxq_sysinit
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|umtx_pi_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"umtx pi"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|umtx_pi
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UMTX_CHAINS
condition|;
operator|++
name|i
control|)
block|{
name|mtx_init
argument_list|(
operator|&
name|umtxq_chains
index|[
name|i
index|]
operator|.
name|uc_lock
argument_list|,
literal|"umtxql"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_DUPOK
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|umtxq_chains
index|[
name|i
index|]
operator|.
name|uc_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|umtxq_chains
index|[
name|i
index|]
operator|.
name|uc_pi_list
argument_list|)
expr_stmt|;
name|umtxq_chains
index|[
name|i
index|]
operator|.
name|uc_busy
operator|=
literal|0
expr_stmt|;
name|umtxq_chains
index|[
name|i
index|]
operator|.
name|uc_waiters
operator|=
literal|0
expr_stmt|;
block|}
name|EVENTHANDLER_REGISTER
argument_list|(
name|process_exec
argument_list|,
name|umtx_exec_hook
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|umtx_q
modifier|*
name|umtxq_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|uq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|umtx_q
argument_list|)
argument_list|,
name|M_UMTX
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|uq
operator|->
name|uq_pi_contested
argument_list|)
expr_stmt|;
name|uq
operator|->
name|uq_inherited_pri
operator|=
name|PRI_MAX
expr_stmt|;
return|return
operator|(
name|uq
operator|)
return|;
block|}
end_function

begin_function
name|void
name|umtxq_free
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|)
block|{
name|free
argument_list|(
name|uq
argument_list|,
name|M_UMTX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|umtxq_hash
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
name|unsigned
name|n
init|=
operator|(
name|uintptr_t
operator|)
name|key
operator|->
name|info
operator|.
name|both
operator|.
name|a
operator|+
name|key
operator|->
name|info
operator|.
name|both
operator|.
name|b
decl_stmt|;
name|key
operator|->
name|hash
operator|=
operator|(
operator|(
name|n
operator|*
name|GOLDEN_RATIO_PRIME
operator|)
operator|>>
name|UMTX_SHIFTS
operator|)
operator|%
name|UMTX_CHAINS
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|umtx_key_match
parameter_list|(
specifier|const
name|struct
name|umtx_key
modifier|*
name|k1
parameter_list|,
specifier|const
name|struct
name|umtx_key
modifier|*
name|k2
parameter_list|)
block|{
return|return
operator|(
name|k1
operator|->
name|type
operator|==
name|k2
operator|->
name|type
operator|&&
name|k1
operator|->
name|info
operator|.
name|both
operator|.
name|a
operator|==
name|k2
operator|->
name|info
operator|.
name|both
operator|.
name|a
operator|&&
name|k1
operator|->
name|info
operator|.
name|both
operator|.
name|b
operator|==
name|k2
operator|->
name|info
operator|.
name|both
operator|.
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|umtxq_chain
modifier|*
name|umtxq_getchain
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
return|return
operator|(
operator|&
name|umtxq_chains
index|[
name|key
operator|->
name|hash
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set chain to busy state when following operation  * may be blocked (kernel mutex can not be used).  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|umtxq_busy
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|uc
operator|->
name|uc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
while|while
condition|(
name|uc
operator|->
name|uc_busy
operator|!=
literal|0
condition|)
block|{
name|uc
operator|->
name|uc_waiters
operator|++
expr_stmt|;
name|msleep
argument_list|(
name|uc
argument_list|,
operator|&
name|uc
operator|->
name|uc_lock
argument_list|,
literal|0
argument_list|,
literal|"umtxqb"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uc
operator|->
name|uc_waiters
operator|--
expr_stmt|;
block|}
name|uc
operator|->
name|uc_busy
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unbusy a chain.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|umtxq_unbusy
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|uc
operator|->
name|uc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|uc
operator|->
name|uc_busy
operator|!=
literal|0
argument_list|,
operator|(
literal|"not busy"
operator|)
argument_list|)
expr_stmt|;
name|uc
operator|->
name|uc_busy
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|uc
operator|->
name|uc_waiters
condition|)
name|wakeup_one
argument_list|(
name|uc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lock a chain.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|umtxq_lock
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|uc
operator|->
name|uc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unlock a chain.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|umtxq_unlock
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|uc
operator|->
name|uc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Insert a thread onto the umtx queue.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|umtxq_insert
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|uc
operator|->
name|uc_queue
argument_list|,
name|uq
argument_list|,
name|uq_link
argument_list|)
expr_stmt|;
name|uq
operator|->
name|uq_flags
operator||=
name|UQF_UMTXQ
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove thread from the umtx queue.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|umtxq_remove
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq
operator|->
name|uq_flags
operator|&
name|UQF_UMTXQ
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|uc
operator|->
name|uc_queue
argument_list|,
name|uq
argument_list|,
name|uq_link
argument_list|)
expr_stmt|;
name|uq
operator|->
name|uq_flags
operator|&=
operator|~
name|UQF_UMTXQ
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Check if there are multiple waiters  */
end_comment

begin_function
specifier|static
name|int
name|umtxq_count
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|uq
argument_list|,
argument|&uc->uc_queue
argument_list|,
argument|uq_link
argument_list|)
block|{
if|if
condition|(
name|umtx_key_match
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|,
name|key
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|count
operator|>
literal|1
condition|)
break|break;
block|}
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if there are multiple PI waiters and returns first  * waiter.  */
end_comment

begin_function
specifier|static
name|int
name|umtxq_count_pi
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|,
name|struct
name|umtx_q
modifier|*
modifier|*
name|first
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
operator|*
name|first
operator|=
name|NULL
expr_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|uq
argument_list|,
argument|&uc->uc_queue
argument_list|,
argument|uq_link
argument_list|)
block|{
if|if
condition|(
name|umtx_key_match
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|,
name|key
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|count
operator|>
literal|1
condition|)
break|break;
operator|*
name|first
operator|=
name|uq
expr_stmt|;
block|}
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wake up threads waiting on an userland object.  */
end_comment

begin_function
specifier|static
name|int
name|umtxq_signal
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|,
name|int
name|n_wake
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|uq
argument_list|,
argument|&uc->uc_queue
argument_list|,
argument|uq_link
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|umtx_key_match
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|uq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|ret
operator|>=
name|n_wake
condition|)
break|break;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wake up specified thread.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|umtxq_signal_thread
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|uq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Put thread into sleep state, before sleeping, check if  * thread was removed from umtx queue.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|umtxq_sleep
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|,
specifier|const
name|char
modifier|*
name|wmesg
parameter_list|,
name|int
name|timo
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|uq
operator|->
name|uq_flags
operator|&
name|UQF_UMTXQ
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|msleep
argument_list|(
name|uq
argument_list|,
operator|&
name|uc
operator|->
name|uc_lock
argument_list|,
name|PCATCH
argument_list|,
name|wmesg
argument_list|,
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert userspace address into unique logical address.  */
end_comment

begin_function
specifier|static
name|int
name|umtx_key_get
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|share
parameter_list|,
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_pindex_t
name|pindex
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|boolean_t
name|wired
decl_stmt|;
name|key
operator|->
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|share
operator|==
name|THREAD_SHARE
condition|)
block|{
name|key
operator|->
name|shared
operator|=
literal|0
expr_stmt|;
name|key
operator|->
name|info
operator|.
name|private
operator|.
name|vs
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
expr_stmt|;
name|key
operator|->
name|info
operator|.
name|private
operator|.
name|addr
operator|=
operator|(
name|uintptr_t
operator|)
name|addr
expr_stmt|;
block|}
else|else
block|{
name|MPASS
argument_list|(
name|share
operator|==
name|PROCESS_SHARE
operator|||
name|share
operator|==
name|AUTO_SHARE
argument_list|)
expr_stmt|;
name|map
operator|=
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
if|if
condition|(
name|vm_map_lookup
argument_list|(
operator|&
name|map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|addr
argument_list|,
name|VM_PROT_WRITE
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|key
operator|->
name|info
operator|.
name|shared
operator|.
name|object
argument_list|,
operator|&
name|pindex
argument_list|,
operator|&
name|prot
argument_list|,
operator|&
name|wired
argument_list|)
operator|!=
name|KERN_SUCCESS
condition|)
block|{
return|return
name|EFAULT
return|;
block|}
if|if
condition|(
operator|(
name|share
operator|==
name|PROCESS_SHARE
operator|)
operator|||
operator|(
name|share
operator|==
name|AUTO_SHARE
operator|&&
name|VM_INHERIT_SHARE
operator|==
name|entry
operator|->
name|inheritance
operator|)
condition|)
block|{
name|key
operator|->
name|shared
operator|=
literal|1
expr_stmt|;
name|key
operator|->
name|info
operator|.
name|shared
operator|.
name|offset
operator|=
name|entry
operator|->
name|offset
operator|+
name|entry
operator|->
name|start
operator|-
operator|(
name|vm_offset_t
operator|)
name|addr
expr_stmt|;
name|vm_object_reference
argument_list|(
name|key
operator|->
name|info
operator|.
name|shared
operator|.
name|object
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|key
operator|->
name|shared
operator|=
literal|0
expr_stmt|;
name|key
operator|->
name|info
operator|.
name|private
operator|.
name|vs
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
expr_stmt|;
name|key
operator|->
name|info
operator|.
name|private
operator|.
name|addr
operator|=
operator|(
name|uintptr_t
operator|)
name|addr
expr_stmt|;
block|}
name|vm_map_lookup_done
argument_list|(
name|map
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|umtxq_hash
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release key.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|umtx_key_release
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|->
name|shared
condition|)
name|vm_object_deallocate
argument_list|(
name|key
operator|->
name|info
operator|.
name|shared
operator|.
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lock a umtx object.  */
end_comment

begin_function
specifier|static
name|int
name|_do_lock_umtx
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umtx
modifier|*
name|umtx
parameter_list|,
name|u_long
name|id
parameter_list|,
name|int
name|timo
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|u_long
name|owner
decl_stmt|;
name|u_long
name|old
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
comment|/* 	 * Care must be exercised when dealing with umtx structure. It 	 * can fault on any access. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Try the uncontested case.  This should be done in userland. 		 */
name|owner
operator|=
name|casuword
argument_list|(
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
name|UMTX_UNOWNED
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* The acquire succeeded. */
if|if
condition|(
name|owner
operator|==
name|UMTX_UNOWNED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* If no one owns it but it is contested try to acquire it. */
if|if
condition|(
name|owner
operator|==
name|UMTX_CONTESTED
condition|)
block|{
name|owner
operator|=
name|casuword
argument_list|(
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
name|UMTX_CONTESTED
argument_list|,
name|id
operator||
name|UMTX_CONTESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
name|UMTX_CONTESTED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* If this failed the lock has changed, restart. */
continue|continue;
block|}
comment|/* 		 * If we caught a signal, we have retried and now 		 * exit immediately. 		 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|umtx
argument_list|,
name|TYPE_SIMPLE_LOCK
argument_list|,
name|AUTO_SHARE
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_insert
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
comment|/* 		 * Set the contested bit so that a release in user space 		 * knows to use the system call for unlock.  If this fails 		 * either some one else has acquired the lock or it has been 		 * released. 		 */
name|old
operator|=
name|casuword
argument_list|(
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
name|owner
argument_list|,
name|owner
operator||
name|UMTX_CONTESTED
argument_list|)
expr_stmt|;
comment|/* The address was invalid. */
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
comment|/* 		 * We set the contested bit, sleep. Otherwise the lock changed 		 * and we need to retry or we lost a race to the thread 		 * unlocking the umtx. 		 */
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|owner
condition|)
name|error
operator|=
name|umtxq_sleep
argument_list|(
name|uq
argument_list|,
literal|"umtx"
argument_list|,
name|timo
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock a umtx object.  */
end_comment

begin_function
specifier|static
name|int
name|do_lock_umtx
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umtx
modifier|*
name|umtx
parameter_list|,
name|u_long
name|id
parameter_list|,
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|)
block|{
name|struct
name|timespec
name|ts
decl_stmt|,
name|ts2
decl_stmt|,
name|ts3
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|timeout
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|_do_lock_umtx
argument_list|(
name|td
argument_list|,
name|umtx
argument_list|,
name|id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Mutex locking is restarted if it is interrupted. */
if|if
condition|(
name|error
operator|==
name|EINTR
condition|)
name|error
operator|=
name|ERESTART
expr_stmt|;
block|}
else|else
block|{
name|getnanouptime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|timespecadd
argument_list|(
operator|&
name|ts
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
name|_do_lock_umtx
argument_list|(
name|td
argument_list|,
name|umtx
argument_list|,
name|id
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ETIMEDOUT
condition|)
break|break;
name|getnanouptime
argument_list|(
operator|&
name|ts2
argument_list|)
expr_stmt|;
if|if
condition|(
name|timespeccmp
argument_list|(
operator|&
name|ts2
argument_list|,
operator|&
name|ts
argument_list|,
operator|>=
argument_list|)
condition|)
block|{
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
break|break;
block|}
name|ts3
operator|=
name|ts
expr_stmt|;
name|timespecsub
argument_list|(
operator|&
name|ts3
argument_list|,
operator|&
name|ts2
argument_list|)
expr_stmt|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|ts3
argument_list|)
expr_stmt|;
block|}
comment|/* Timed-locking is not restarted. */
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock a umtx object.  */
end_comment

begin_function
specifier|static
name|int
name|do_unlock_umtx
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umtx
modifier|*
name|umtx
parameter_list|,
name|u_long
name|id
parameter_list|)
block|{
name|struct
name|umtx_key
name|key
decl_stmt|;
name|u_long
name|owner
decl_stmt|;
name|u_long
name|old
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* 	 * Make sure we own this mtx. 	 */
name|owner
operator|=
name|fuword
argument_list|(
name|__DEVOLATILE
argument_list|(
name|u_long
operator|*
argument_list|,
operator|&
name|umtx
operator|->
name|u_owner
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
operator|(
name|owner
operator|&
operator|~
name|UMTX_CONTESTED
operator|)
operator|!=
name|id
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* This should be done in userland */
if|if
condition|(
operator|(
name|owner
operator|&
name|UMTX_CONTESTED
operator|)
operator|==
literal|0
condition|)
block|{
name|old
operator|=
name|casuword
argument_list|(
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
name|owner
argument_list|,
name|UMTX_UNOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|old
operator|==
name|owner
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|owner
operator|=
name|old
expr_stmt|;
block|}
comment|/* We should only ever be in here for contested locks */
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|umtx
argument_list|,
name|TYPE_SIMPLE_LOCK
argument_list|,
name|AUTO_SHARE
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|count
operator|=
name|umtxq_count
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
comment|/* 	 * When unlocking the umtx, it must be marked as unowned if 	 * there is zero or one thread only waiting for it. 	 * Otherwise, it must be marked as contested. 	 */
name|old
operator|=
name|casuword
argument_list|(
operator|&
name|umtx
operator|->
name|u_owner
argument_list|,
name|owner
argument_list|,
name|count
operator|<=
literal|1
condition|?
name|UMTX_UNOWNED
else|:
name|UMTX_CONTESTED
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_signal
argument_list|(
operator|&
name|key
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|old
operator|!=
name|owner
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_IA32
end_ifdef

begin_comment
comment|/*  * Lock a umtx object.  */
end_comment

begin_function
specifier|static
name|int
name|_do_lock_umtx32
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|uint32_t
modifier|*
name|m
parameter_list|,
name|uint32_t
name|id
parameter_list|,
name|int
name|timo
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|uint32_t
name|owner
decl_stmt|;
name|uint32_t
name|old
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
comment|/* 	 * Care must be exercised when dealing with umtx structure. It 	 * can fault on any access. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Try the uncontested case.  This should be done in userland. 		 */
name|owner
operator|=
name|casuword32
argument_list|(
name|m
argument_list|,
name|UMUTEX_UNOWNED
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* The acquire succeeded. */
if|if
condition|(
name|owner
operator|==
name|UMUTEX_UNOWNED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* If no one owns it but it is contested try to acquire it. */
if|if
condition|(
name|owner
operator|==
name|UMUTEX_CONTESTED
condition|)
block|{
name|owner
operator|=
name|casuword32
argument_list|(
name|m
argument_list|,
name|UMUTEX_CONTESTED
argument_list|,
name|id
operator||
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
name|UMUTEX_CONTESTED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* If this failed the lock has changed, restart. */
continue|continue;
block|}
comment|/* 		 * If we caught a signal, we have retried and now 		 * exit immediately. 		 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|m
argument_list|,
name|TYPE_SIMPLE_LOCK
argument_list|,
name|AUTO_SHARE
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_insert
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
comment|/* 		 * Set the contested bit so that a release in user space 		 * knows to use the system call for unlock.  If this fails 		 * either some one else has acquired the lock or it has been 		 * released. 		 */
name|old
operator|=
name|casuword32
argument_list|(
name|m
argument_list|,
name|owner
argument_list|,
name|owner
operator||
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
comment|/* The address was invalid. */
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
comment|/* 		 * We set the contested bit, sleep. Otherwise the lock changed 		 * and we need to retry or we lost a race to the thread 		 * unlocking the umtx. 		 */
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|owner
condition|)
name|error
operator|=
name|umtxq_sleep
argument_list|(
name|uq
argument_list|,
literal|"umtx"
argument_list|,
name|timo
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock a umtx object.  */
end_comment

begin_function
specifier|static
name|int
name|do_lock_umtx32
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|m
parameter_list|,
name|uint32_t
name|id
parameter_list|,
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|)
block|{
name|struct
name|timespec
name|ts
decl_stmt|,
name|ts2
decl_stmt|,
name|ts3
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|timeout
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|_do_lock_umtx32
argument_list|(
name|td
argument_list|,
name|m
argument_list|,
name|id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Mutex locking is restarted if it is interrupted. */
if|if
condition|(
name|error
operator|==
name|EINTR
condition|)
name|error
operator|=
name|ERESTART
expr_stmt|;
block|}
else|else
block|{
name|getnanouptime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|timespecadd
argument_list|(
operator|&
name|ts
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
name|_do_lock_umtx32
argument_list|(
name|td
argument_list|,
name|m
argument_list|,
name|id
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ETIMEDOUT
condition|)
break|break;
name|getnanouptime
argument_list|(
operator|&
name|ts2
argument_list|)
expr_stmt|;
if|if
condition|(
name|timespeccmp
argument_list|(
operator|&
name|ts2
argument_list|,
operator|&
name|ts
argument_list|,
operator|>=
argument_list|)
condition|)
block|{
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
break|break;
block|}
name|ts3
operator|=
name|ts
expr_stmt|;
name|timespecsub
argument_list|(
operator|&
name|ts3
argument_list|,
operator|&
name|ts2
argument_list|)
expr_stmt|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|ts3
argument_list|)
expr_stmt|;
block|}
comment|/* Timed-locking is not restarted. */
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock a umtx object.  */
end_comment

begin_function
specifier|static
name|int
name|do_unlock_umtx32
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|uint32_t
modifier|*
name|m
parameter_list|,
name|uint32_t
name|id
parameter_list|)
block|{
name|struct
name|umtx_key
name|key
decl_stmt|;
name|uint32_t
name|owner
decl_stmt|;
name|uint32_t
name|old
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* 	 * Make sure we own this mtx. 	 */
name|owner
operator|=
name|fuword32
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|!=
name|id
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* This should be done in userland */
if|if
condition|(
operator|(
name|owner
operator|&
name|UMUTEX_CONTESTED
operator|)
operator|==
literal|0
condition|)
block|{
name|old
operator|=
name|casuword32
argument_list|(
name|m
argument_list|,
name|owner
argument_list|,
name|UMUTEX_UNOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|old
operator|==
name|owner
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|owner
operator|=
name|old
expr_stmt|;
block|}
comment|/* We should only ever be in here for contested locks */
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|m
argument_list|,
name|TYPE_SIMPLE_LOCK
argument_list|,
name|AUTO_SHARE
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|count
operator|=
name|umtxq_count
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
comment|/* 	 * When unlocking the umtx, it must be marked as unowned if 	 * there is zero or one thread only waiting for it. 	 * Otherwise, it must be marked as contested. 	 */
name|old
operator|=
name|casuword32
argument_list|(
name|m
argument_list|,
name|owner
argument_list|,
name|count
operator|<=
literal|1
condition|?
name|UMUTEX_UNOWNED
else|:
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_signal
argument_list|(
operator|&
name|key
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|old
operator|!=
name|owner
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Fetch and compare value, sleep on the address if value is not changed.  */
end_comment

begin_function
specifier|static
name|int
name|do_wait
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|u_long
name|id
parameter_list|,
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|,
name|int
name|compat32
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|,
name|ts2
decl_stmt|,
name|ts3
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|u_long
name|tmp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|addr
argument_list|,
name|TYPE_SIMPLE_WAIT
argument_list|,
name|AUTO_SHARE
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_insert
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat32
operator|==
literal|0
condition|)
name|tmp
operator|=
name|fuword
argument_list|(
name|addr
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|fuword32
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|id
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|timeout
operator|==
name|NULL
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|error
operator|=
name|umtxq_sleep
argument_list|(
name|uq
argument_list|,
literal|"uwait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getnanouptime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|timespecadd
argument_list|(
operator|&
name|ts
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
name|umtxq_sleep
argument_list|(
name|uq
argument_list|,
literal|"uwait"
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|uq
operator|->
name|uq_flags
operator|&
name|UQF_UMTXQ
operator|)
condition|)
break|break;
if|if
condition|(
name|error
operator|!=
name|ETIMEDOUT
condition|)
break|break;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|getnanouptime
argument_list|(
operator|&
name|ts2
argument_list|)
expr_stmt|;
if|if
condition|(
name|timespeccmp
argument_list|(
operator|&
name|ts2
argument_list|,
operator|&
name|ts
argument_list|,
operator|>=
argument_list|)
condition|)
block|{
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
break|break;
block|}
name|ts3
operator|=
name|ts
expr_stmt|;
name|timespecsub
argument_list|(
operator|&
name|ts3
argument_list|,
operator|&
name|ts2
argument_list|)
expr_stmt|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|ts3
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
block|}
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
block|}
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wake up threads sleeping on the specified address.  */
end_comment

begin_function
name|int
name|kern_umtx_wake
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|uaddr
parameter_list|,
name|int
name|n_wake
parameter_list|)
block|{
name|struct
name|umtx_key
name|key
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|umtx_key_get
argument_list|(
name|uaddr
argument_list|,
name|TYPE_SIMPLE_WAIT
argument_list|,
name|AUTO_SHARE
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|ret
operator|=
name|umtxq_signal
argument_list|(
operator|&
name|key
argument_list|,
name|n_wake
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock PTHREAD_PRIO_NONE protocol POSIX mutex.  */
end_comment

begin_function
specifier|static
name|int
name|_do_lock_normal
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
name|int
name|timo
parameter_list|,
name|int
name|try
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|uint32_t
name|owner
decl_stmt|,
name|old
decl_stmt|,
name|id
decl_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|int
name|spincount
decl_stmt|;
endif|#
directive|endif
name|int
name|error
init|=
literal|0
decl_stmt|;
name|id
operator|=
name|td
operator|->
name|td_tid
expr_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|smp_cpus
operator|>
literal|1
condition|)
block|{
name|spincount
operator|=
name|fuword32
argument_list|(
operator|&
name|m
operator|->
name|m_spincount
argument_list|)
expr_stmt|;
if|if
condition|(
name|spincount
operator|==
literal|0
condition|)
name|spincount
operator|=
name|umtx_dflt_spins
expr_stmt|;
if|if
condition|(
name|spincount
operator|>
name|umtx_max_spins
condition|)
name|spincount
operator|=
name|umtx_max_spins
expr_stmt|;
block|}
else|else
name|spincount
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Care must be exercised when dealing with umtx structure. It 	 * can fault on any access. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
ifdef|#
directive|ifdef
name|SMP
name|try_unowned
label|:
endif|#
directive|endif
comment|/* 		 * Try the uncontested case.  This should be done in userland. 		 */
name|owner
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|UMUTEX_UNOWNED
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* The acquire succeeded. */
if|if
condition|(
name|owner
operator|==
name|UMUTEX_UNOWNED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* If no one owns it but it is contested try to acquire it. */
if|if
condition|(
name|owner
operator|==
name|UMUTEX_CONTESTED
condition|)
block|{
ifdef|#
directive|ifdef
name|SMP
name|try_contested
label|:
endif|#
directive|endif
name|owner
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|UMUTEX_CONTESTED
argument_list|,
name|id
operator||
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
name|UMUTEX_CONTESTED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* If this failed the lock has changed, restart. */
continue|continue;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|UMUTEX_ERROR_CHECK
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|==
name|id
condition|)
return|return
operator|(
name|EDEADLK
operator|)
return|;
if|if
condition|(
name|try
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|spincount
operator|>
literal|0
operator|&&
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|!=
name|id
condition|)
block|{
name|int
name|i
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
name|struct
name|pcpu
modifier|*
name|pcpu
init|=
name|NULL
decl_stmt|;
comment|/* Look for a cpu the owner is running on */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
name|pcpu
operator|=
name|pcpu_find
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|==
name|pcpu
operator|->
name|pc_curtid
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|found
argument_list|)
condition|)
goto|goto
name|end_spin
goto|;
while|while
condition|(
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|==
name|pcpu
operator|->
name|pc_curtid
operator|&&
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|!=
name|id
condition|)
block|{
if|if
condition|(
operator|--
name|spincount
operator|<=
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|td
operator|->
name|td_flags
operator|&
operator|(
name|TDF_NEEDRESCHED
operator||
name|TDF_ASTPENDING
operator||
name|TDF_NEEDSIGCHK
operator|)
operator|)
operator|||
name|P_SHOULDSTOP
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
condition|)
break|break;
name|owner
operator|=
name|fuword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|m
operator|->
name|m_owner
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
name|UMUTEX_UNOWNED
condition|)
goto|goto
name|try_unowned
goto|;
if|if
condition|(
name|owner
operator|==
name|UMUTEX_CONTESTED
condition|)
goto|goto
name|try_contested
goto|;
name|cpu_spinwait
argument_list|()
expr_stmt|;
block|}
block|}
name|end_spin
label|:
name|spincount
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * If we caught a signal, we have retried and now 		 * exit immediately. 		 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|m
argument_list|,
name|TYPE_NORMAL_UMUTEX
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_insert
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
comment|/* 		 * Set the contested bit so that a release in user space 		 * knows to use the system call for unlock.  If this fails 		 * either some one else has acquired the lock or it has been 		 * released. 		 */
name|old
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|owner
argument_list|,
name|owner
operator||
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
comment|/* The address was invalid. */
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
comment|/* 		 * We set the contested bit, sleep. Otherwise the lock changed 		 * and we need to retry or we lost a race to the thread 		 * unlocking the umtx. 		 */
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|owner
condition|)
name|error
operator|=
name|umtxq_sleep
argument_list|(
name|uq
argument_list|,
literal|"umtxn"
argument_list|,
name|timo
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock PTHREAD_PRIO_NONE protocol POSIX mutex.  */
end_comment

begin_comment
comment|/*  * Unlock PTHREAD_PRIO_NONE protocol POSIX mutex.  */
end_comment

begin_function
specifier|static
name|int
name|do_unlock_normal
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|umtx_key
name|key
decl_stmt|;
name|uint32_t
name|owner
decl_stmt|,
name|old
decl_stmt|,
name|id
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|count
decl_stmt|;
name|id
operator|=
name|td
operator|->
name|td_tid
expr_stmt|;
comment|/* 	 * Make sure we own this mtx. 	 */
name|owner
operator|=
name|fuword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|m
operator|->
name|m_owner
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|!=
name|id
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* This should be done in userland */
if|if
condition|(
operator|(
name|owner
operator|&
name|UMUTEX_CONTESTED
operator|)
operator|==
literal|0
condition|)
block|{
name|old
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|owner
argument_list|,
name|UMUTEX_UNOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|old
operator|==
name|owner
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|owner
operator|=
name|old
expr_stmt|;
block|}
comment|/* We should only ever be in here for contested locks */
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|m
argument_list|,
name|TYPE_NORMAL_UMUTEX
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|count
operator|=
name|umtxq_count
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
comment|/* 	 * When unlocking the umtx, it must be marked as unowned if 	 * there is zero or one thread only waiting for it. 	 * Otherwise, it must be marked as contested. 	 */
name|old
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|owner
argument_list|,
name|count
operator|<=
literal|1
condition|?
name|UMUTEX_UNOWNED
else|:
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_signal
argument_list|(
operator|&
name|key
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|old
operator|!=
name|owner
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|umtx_pi
modifier|*
name|umtx_pi_alloc
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|struct
name|umtx_pi
modifier|*
name|pi
decl_stmt|;
name|pi
operator|=
name|uma_zalloc
argument_list|(
name|umtx_pi_zone
argument_list|,
name|M_ZERO
operator||
name|flags
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pi
operator|->
name|pi_blocked
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|umtx_pi_allocated
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|pi
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|umtx_pi_free
parameter_list|(
name|struct
name|umtx_pi
modifier|*
name|pi
parameter_list|)
block|{
name|uma_zfree
argument_list|(
name|umtx_pi_zone
argument_list|,
name|pi
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|umtx_pi_allocated
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Adjust the thread's position on a pi_state after its priority has been  * changed.  */
end_comment

begin_function
specifier|static
name|int
name|umtx_pi_adjust_thread
parameter_list|(
name|struct
name|umtx_pi
modifier|*
name|pi
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|,
modifier|*
name|uq1
decl_stmt|,
modifier|*
name|uq2
decl_stmt|;
name|struct
name|thread
modifier|*
name|td1
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
comment|/* 	 * Check if the thread needs to be moved on the blocked chain. 	 * It needs to be moved if either its priority is lower than 	 * the previous thread or higher than the next thread. 	 */
name|uq1
operator|=
name|TAILQ_PREV
argument_list|(
name|uq
argument_list|,
name|umtxq_head
argument_list|,
name|uq_lockq
argument_list|)
expr_stmt|;
name|uq2
operator|=
name|TAILQ_NEXT
argument_list|(
name|uq
argument_list|,
name|uq_lockq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uq1
operator|!=
name|NULL
operator|&&
name|UPRI
argument_list|(
name|td
argument_list|)
operator|<
name|UPRI
argument_list|(
name|uq1
operator|->
name|uq_thread
argument_list|)
operator|)
operator|||
operator|(
name|uq2
operator|!=
name|NULL
operator|&&
name|UPRI
argument_list|(
name|td
argument_list|)
operator|>
name|UPRI
argument_list|(
name|uq2
operator|->
name|uq_thread
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * Remove thread from blocked chain and determine where 		 * it should be moved to. 		 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pi
operator|->
name|pi_blocked
argument_list|,
name|uq
argument_list|,
name|uq_lockq
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|uq1
argument_list|,
argument|&pi->pi_blocked
argument_list|,
argument|uq_lockq
argument_list|)
block|{
name|td1
operator|=
name|uq1
operator|->
name|uq_thread
expr_stmt|;
name|MPASS
argument_list|(
name|td1
operator|->
name|td_proc
operator|->
name|p_magic
operator|==
name|P_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|UPRI
argument_list|(
name|td1
argument_list|)
operator|>
name|UPRI
argument_list|(
name|td
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|uq1
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pi
operator|->
name|pi_blocked
argument_list|,
name|uq
argument_list|,
name|uq_lockq
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_BEFORE
argument_list|(
name|uq1
argument_list|,
name|uq
argument_list|,
name|uq_lockq
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Propagate priority when a thread is blocked on POSIX  * PI mutex.  */
end_comment

begin_function
specifier|static
name|void
name|umtx_propagate_priority
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|struct
name|umtx_pi
modifier|*
name|pi
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|pri
operator|=
name|UPRI
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
name|pi
operator|=
name|uq
operator|->
name|uq_pi_blocked
expr_stmt|;
if|if
condition|(
name|pi
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
name|td
operator|=
name|pi
operator|->
name|pi_owner
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
return|return;
name|MPASS
argument_list|(
name|td
operator|->
name|td_proc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_magic
operator|==
name|P_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|UPRI
argument_list|(
name|td
argument_list|)
operator|<=
name|pri
condition|)
return|return;
name|sched_lend_user_prio
argument_list|(
name|td
argument_list|,
name|pri
argument_list|)
expr_stmt|;
comment|/* 		 * Pick up the lock that td is blocked on. 		 */
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
name|pi
operator|=
name|uq
operator|->
name|uq_pi_blocked
expr_stmt|;
comment|/* Resort td on the list if needed. */
if|if
condition|(
operator|!
name|umtx_pi_adjust_thread
argument_list|(
name|pi
argument_list|,
name|td
argument_list|)
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Unpropagate priority for a PI mutex when a thread blocked on  * it is interrupted by signal or resumed by others.  */
end_comment

begin_function
specifier|static
name|void
name|umtx_unpropagate_priority
parameter_list|(
name|struct
name|umtx_pi
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|,
modifier|*
name|uq_owner
decl_stmt|;
name|struct
name|umtx_pi
modifier|*
name|pi2
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
while|while
condition|(
name|pi
operator|!=
name|NULL
operator|&&
name|pi
operator|->
name|pi_owner
operator|!=
name|NULL
condition|)
block|{
name|pri
operator|=
name|PRI_MAX
expr_stmt|;
name|uq_owner
operator|=
name|pi
operator|->
name|pi_owner
operator|->
name|td_umtxq
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pi2
argument_list|,
argument|&uq_owner->uq_pi_contested
argument_list|,
argument|pi_link
argument_list|)
block|{
name|uq
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pi2
operator|->
name|pi_blocked
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pri
operator|>
name|UPRI
argument_list|(
name|uq
operator|->
name|uq_thread
argument_list|)
condition|)
name|pri
operator|=
name|UPRI
argument_list|(
name|uq
operator|->
name|uq_thread
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pri
operator|>
name|uq_owner
operator|->
name|uq_inherited_pri
condition|)
name|pri
operator|=
name|uq_owner
operator|->
name|uq_inherited_pri
expr_stmt|;
name|sched_unlend_user_prio
argument_list|(
name|pi
operator|->
name|pi_owner
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|pi
operator|=
name|uq_owner
operator|->
name|uq_pi_blocked
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Insert a PI mutex into owned list.  */
end_comment

begin_function
specifier|static
name|void
name|umtx_pi_setowner
parameter_list|(
name|struct
name|umtx_pi
modifier|*
name|pi
parameter_list|,
name|struct
name|thread
modifier|*
name|owner
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq_owner
decl_stmt|;
name|uq_owner
operator|=
name|owner
operator|->
name|td_umtxq
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pi_owner
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"pi_ower != NULL"
argument_list|)
expr_stmt|;
name|pi
operator|->
name|pi_owner
operator|=
name|owner
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|uq_owner
operator|->
name|uq_pi_contested
argument_list|,
name|pi
argument_list|,
name|pi_link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Claim ownership of a PI mutex.  */
end_comment

begin_function
specifier|static
name|int
name|umtx_pi_claim
parameter_list|(
name|struct
name|umtx_pi
modifier|*
name|pi
parameter_list|,
name|struct
name|thread
modifier|*
name|owner
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|,
modifier|*
name|uq_owner
decl_stmt|;
name|uq_owner
operator|=
name|owner
operator|->
name|td_umtxq
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pi_owner
operator|==
name|owner
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|pi
operator|->
name|pi_owner
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * userland may have already messed the mutex, sigh. 		 */
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|umtx_pi_setowner
argument_list|(
name|pi
argument_list|,
name|owner
argument_list|)
expr_stmt|;
name|uq
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pi
operator|->
name|pi_blocked
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq
operator|!=
name|NULL
condition|)
block|{
name|int
name|pri
decl_stmt|;
name|pri
operator|=
name|UPRI
argument_list|(
name|uq
operator|->
name|uq_thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|pri
operator|<
name|UPRI
argument_list|(
name|owner
argument_list|)
condition|)
name|sched_lend_user_prio
argument_list|(
name|owner
argument_list|,
name|pri
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Adjust a thread's order position in its blocked PI mutex,  * this may result new priority propagating process.  */
end_comment

begin_function
name|void
name|umtx_pi_adjust
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|u_char
name|oldpri
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|struct
name|umtx_pi
modifier|*
name|pi
decl_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|TD_ON_UPILOCK
argument_list|(
name|td
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Pick up the lock that td is blocked on. 	 */
name|pi
operator|=
name|uq
operator|->
name|uq_pi_blocked
expr_stmt|;
name|MPASS
argument_list|(
name|pi
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Resort the turnstile on the list. */
if|if
condition|(
operator|!
name|umtx_pi_adjust_thread
argument_list|(
name|pi
argument_list|,
name|td
argument_list|)
condition|)
return|return;
comment|/* 	 * If our priority was lowered and we are at the head of the 	 * turnstile, then propagate our new priority up the chain. 	 */
if|if
condition|(
name|uq
operator|==
name|TAILQ_FIRST
argument_list|(
operator|&
name|pi
operator|->
name|pi_blocked
argument_list|)
operator|&&
name|UPRI
argument_list|(
name|td
argument_list|)
operator|<
name|oldpri
condition|)
name|umtx_propagate_priority
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sleep on a PI mutex.  */
end_comment

begin_function
specifier|static
name|int
name|umtxq_sleep_pi
parameter_list|(
name|struct
name|umtx_q
modifier|*
name|uq
parameter_list|,
name|struct
name|umtx_pi
modifier|*
name|pi
parameter_list|,
name|uint32_t
name|owner
parameter_list|,
specifier|const
name|char
modifier|*
name|wmesg
parameter_list|,
name|int
name|timo
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|,
modifier|*
name|td1
decl_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq1
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|td
operator|=
name|uq
operator|->
name|uq_thread
expr_stmt|;
name|KASSERT
argument_list|(
name|td
operator|==
name|curthread
argument_list|,
operator|(
literal|"inconsistent uq_thread"
operator|)
argument_list|)
expr_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|umtxq_insert
argument_list|(
name|uq
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pi_owner
operator|==
name|NULL
condition|)
block|{
comment|/* XXX 		 * Current, We only support process private PI-mutex, 		 * non-contended PI-mutexes are locked in userland. 		 * Process shared PI-mutex should always be initialized 		 * by kernel and be registered in kernel, locking should 		 * always be done by kernel to avoid security problems. 		 * For process private PI-mutex, we can find owner 		 * thread and boost its priority safely. 		 */
name|PROC_LOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
name|td1
operator|=
name|thread_find
argument_list|(
name|curproc
argument_list|,
name|owner
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|td1
operator|!=
name|NULL
operator|&&
name|pi
operator|->
name|pi_owner
operator|==
name|NULL
condition|)
block|{
name|uq1
operator|=
name|td1
operator|->
name|td_umtxq
expr_stmt|;
name|umtx_pi_setowner
argument_list|(
name|pi
argument_list|,
name|td1
argument_list|)
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|uq1
argument_list|,
argument|&pi->pi_blocked
argument_list|,
argument|uq_lockq
argument_list|)
block|{
name|pri
operator|=
name|UPRI
argument_list|(
name|uq1
operator|->
name|uq_thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|pri
operator|>
name|UPRI
argument_list|(
name|td
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|uq1
operator|!=
name|NULL
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|uq1
argument_list|,
name|uq
argument_list|,
name|uq_lockq
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pi
operator|->
name|pi_blocked
argument_list|,
name|uq
argument_list|,
name|uq_lockq
argument_list|)
expr_stmt|;
name|uq
operator|->
name|uq_pi_blocked
operator|=
name|pi
expr_stmt|;
name|td
operator|->
name|td_flags
operator||=
name|TDF_UPIBLOCKED
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|umtx_propagate_priority
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq
operator|->
name|uq_flags
operator|&
name|UQF_UMTXQ
condition|)
block|{
name|error
operator|=
name|msleep
argument_list|(
name|uq
argument_list|,
operator|&
name|uc
operator|->
name|uc_lock
argument_list|,
name|PCATCH
argument_list|,
name|wmesg
argument_list|,
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
if|if
condition|(
name|uq
operator|->
name|uq_flags
operator|&
name|UQF_UMTXQ
condition|)
block|{
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
block|}
block|}
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|uq
operator|->
name|uq_pi_blocked
operator|=
name|NULL
expr_stmt|;
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_UPIBLOCKED
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pi
operator|->
name|pi_blocked
argument_list|,
name|uq
argument_list|,
name|uq_lockq
argument_list|)
expr_stmt|;
name|umtx_unpropagate_priority
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add reference count for a PI mutex.  */
end_comment

begin_function
specifier|static
name|void
name|umtx_pi_ref
parameter_list|(
name|struct
name|umtx_pi
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
operator|&
name|pi
operator|->
name|pi_key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|pi
operator|->
name|pi_refcount
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Decrease reference count for a PI mutex, if the counter  * is decreased to zero, its memory space is freed.  */
end_comment

begin_function
specifier|static
name|void
name|umtx_pi_unref
parameter_list|(
name|struct
name|umtx_pi
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|int
name|free
init|=
literal|0
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
operator|&
name|pi
operator|->
name|pi_key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pi
operator|->
name|pi_refcount
operator|>
literal|0
argument_list|,
operator|(
literal|"invalid reference count"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|pi
operator|->
name|pi_refcount
operator|==
literal|0
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pi_owner
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pi
operator|->
name|pi_owner
operator|->
name|td_umtxq
operator|->
name|uq_pi_contested
argument_list|,
name|pi
argument_list|,
name|pi_link
argument_list|)
expr_stmt|;
name|pi
operator|->
name|pi_owner
operator|=
name|NULL
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|pi
operator|->
name|pi_blocked
argument_list|)
argument_list|,
operator|(
literal|"blocked queue not empty"
operator|)
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|uc
operator|->
name|uc_pi_list
argument_list|,
name|pi
argument_list|,
name|pi_hashlink
argument_list|)
expr_stmt|;
name|free
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|free
condition|)
name|umtx_pi_free
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find a PI mutex in hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|umtx_pi
modifier|*
name|umtx_pi_lookup
parameter_list|(
name|struct
name|umtx_key
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|struct
name|umtx_pi
modifier|*
name|pi
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pi
argument_list|,
argument|&uc->uc_pi_list
argument_list|,
argument|pi_hashlink
argument_list|)
block|{
if|if
condition|(
name|umtx_key_match
argument_list|(
operator|&
name|pi
operator|->
name|pi_key
argument_list|,
name|key
argument_list|)
condition|)
block|{
return|return
operator|(
name|pi
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert a PI mutex into hash table.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|umtx_pi_insert
parameter_list|(
name|struct
name|umtx_pi
modifier|*
name|pi
parameter_list|)
block|{
name|struct
name|umtxq_chain
modifier|*
name|uc
decl_stmt|;
name|uc
operator|=
name|umtxq_getchain
argument_list|(
operator|&
name|pi
operator|->
name|pi_key
argument_list|)
expr_stmt|;
name|UMTXQ_LOCKED_ASSERT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|uc
operator|->
name|uc_pi_list
argument_list|,
name|pi
argument_list|,
name|pi_hashlink
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lock a PI mutex.  */
end_comment

begin_function
specifier|static
name|int
name|_do_lock_pi
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
name|int
name|timo
parameter_list|,
name|int
name|try
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|struct
name|umtx_pi
modifier|*
name|pi
decl_stmt|,
modifier|*
name|new_pi
decl_stmt|;
name|uint32_t
name|id
decl_stmt|,
name|owner
decl_stmt|,
name|old
decl_stmt|;
name|int
name|error
decl_stmt|;
name|id
operator|=
name|td
operator|->
name|td_tid
expr_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|m
argument_list|,
name|TYPE_PI_UMUTEX
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|pi
operator|=
name|umtx_pi_lookup
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|==
name|NULL
condition|)
block|{
name|new_pi
operator|=
name|umtx_pi_alloc
argument_list|(
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_pi
operator|==
name|NULL
condition|)
block|{
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|new_pi
operator|=
name|umtx_pi_alloc
argument_list|(
name|M_WAITOK
argument_list|)
expr_stmt|;
name|new_pi
operator|->
name|pi_key
operator|=
name|uq
operator|->
name|uq_key
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|pi
operator|=
name|umtx_pi_lookup
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|!=
name|NULL
condition|)
block|{
name|umtx_pi_free
argument_list|(
name|new_pi
argument_list|)
expr_stmt|;
name|new_pi
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|new_pi
operator|!=
name|NULL
condition|)
block|{
name|new_pi
operator|->
name|pi_key
operator|=
name|uq
operator|->
name|uq_key
expr_stmt|;
name|umtx_pi_insert
argument_list|(
name|new_pi
argument_list|)
expr_stmt|;
name|pi
operator|=
name|new_pi
expr_stmt|;
block|}
block|}
name|umtx_pi_ref
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
comment|/* 	 * Care must be exercised when dealing with umtx structure.  It 	 * can fault on any access. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Try the uncontested case.  This should be done in userland. 		 */
name|owner
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|UMUTEX_UNOWNED
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* The acquire succeeded. */
if|if
condition|(
name|owner
operator|==
name|UMUTEX_UNOWNED
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
comment|/* If no one owns it but it is contested try to acquire it. */
if|if
condition|(
name|owner
operator|==
name|UMUTEX_CONTESTED
condition|)
block|{
name|owner
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|UMUTEX_CONTESTED
argument_list|,
name|id
operator||
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
name|UMUTEX_CONTESTED
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|error
operator|=
name|umtx_pi_claim
argument_list|(
name|pi
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
comment|/* If this failed the lock has changed, restart. */
continue|continue;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|UMUTEX_ERROR_CHECK
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|==
name|id
condition|)
block|{
name|error
operator|=
name|EDEADLK
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|try
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
comment|/* 		 * If we caught a signal, we have retried and now 		 * exit immediately. 		 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
comment|/* 		 * Set the contested bit so that a release in user space 		 * knows to use the system call for unlock.  If this fails 		 * either some one else has acquired the lock or it has been 		 * released. 		 */
name|old
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|owner
argument_list|,
name|owner
operator||
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
comment|/* The address was invalid. */
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
comment|/* 		 * We set the contested bit, sleep. Otherwise the lock changed 		 * and we need to retry or we lost a race to the thread 		 * unlocking the umtx. 		 */
if|if
condition|(
name|old
operator|==
name|owner
condition|)
name|error
operator|=
name|umtxq_sleep_pi
argument_list|(
name|uq
argument_list|,
name|pi
argument_list|,
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
argument_list|,
literal|"umtxpi"
argument_list|,
name|timo
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
block|}
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_pi_unref
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock a PI mutex.  */
end_comment

begin_function
specifier|static
name|int
name|do_unlock_pi
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|umtx_key
name|key
decl_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq_first
decl_stmt|,
modifier|*
name|uq_first2
decl_stmt|,
modifier|*
name|uq_me
decl_stmt|;
name|struct
name|umtx_pi
modifier|*
name|pi
decl_stmt|,
modifier|*
name|pi2
decl_stmt|;
name|uint32_t
name|owner
decl_stmt|,
name|old
decl_stmt|,
name|id
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|id
operator|=
name|td
operator|->
name|td_tid
expr_stmt|;
comment|/* 	 * Make sure we own this mtx. 	 */
name|owner
operator|=
name|fuword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|m
operator|->
name|m_owner
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|!=
name|id
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* This should be done in userland */
if|if
condition|(
operator|(
name|owner
operator|&
name|UMUTEX_CONTESTED
operator|)
operator|==
literal|0
condition|)
block|{
name|old
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|owner
argument_list|,
name|UMUTEX_UNOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|old
operator|==
name|owner
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|owner
operator|=
name|old
expr_stmt|;
block|}
comment|/* We should only ever be in here for contested locks */
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|m
argument_list|,
name|TYPE_PI_UMUTEX
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|count
operator|=
name|umtxq_count_pi
argument_list|(
operator|&
name|key
argument_list|,
operator|&
name|uq_first
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq_first
operator|!=
name|NULL
condition|)
block|{
name|pi
operator|=
name|uq_first
operator|->
name|uq_pi_blocked
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|pi_owner
operator|!=
name|curthread
condition|)
block|{
name|umtxq_unbusy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
comment|/* userland messed the mutex */
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|uq_me
operator|=
name|curthread
operator|->
name|td_umtxq
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|pi
operator|->
name|pi_owner
operator|=
name|NULL
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|uq_me
operator|->
name|uq_pi_contested
argument_list|,
name|pi
argument_list|,
name|pi_link
argument_list|)
expr_stmt|;
name|uq_first
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pi
operator|->
name|pi_blocked
argument_list|)
expr_stmt|;
name|pri
operator|=
name|PRI_MAX
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pi2
argument_list|,
argument|&uq_me->uq_pi_contested
argument_list|,
argument|pi_link
argument_list|)
block|{
name|uq_first2
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pi2
operator|->
name|pi_blocked
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq_first2
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pri
operator|>
name|UPRI
argument_list|(
name|uq_first2
operator|->
name|uq_thread
argument_list|)
condition|)
name|pri
operator|=
name|UPRI
argument_list|(
name|uq_first2
operator|->
name|uq_thread
argument_list|)
expr_stmt|;
block|}
block|}
name|sched_unlend_user_prio
argument_list|(
name|curthread
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
comment|/* 	 * When unlocking the umtx, it must be marked as unowned if 	 * there is zero or one thread only waiting for it. 	 * Otherwise, it must be marked as contested. 	 */
name|old
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|owner
argument_list|,
name|count
operator|<=
literal|1
condition|?
name|UMUTEX_UNOWNED
else|:
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq_first
operator|!=
name|NULL
condition|)
name|umtxq_signal_thread
argument_list|(
name|uq_first
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|old
operator|!=
name|owner
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock a PP mutex.  */
end_comment

begin_function
specifier|static
name|int
name|_do_lock_pp
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
name|int
name|timo
parameter_list|,
name|int
name|try
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|,
modifier|*
name|uq2
decl_stmt|;
name|struct
name|umtx_pi
modifier|*
name|pi
decl_stmt|;
name|uint32_t
name|ceiling
decl_stmt|;
name|uint32_t
name|owner
decl_stmt|,
name|id
decl_stmt|;
name|int
name|error
decl_stmt|,
name|pri
decl_stmt|,
name|old_inherited_pri
decl_stmt|,
name|su
decl_stmt|;
name|id
operator|=
name|td
operator|->
name|td_tid
expr_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|m
argument_list|,
name|TYPE_PP_UMUTEX
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|su
operator|=
operator|(
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_SCHED_RTPRIO
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|old_inherited_pri
operator|=
name|uq
operator|->
name|uq_inherited_pri
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|ceiling
operator|=
name|RTP_PRIO_MAX
operator|-
name|fuword32
argument_list|(
operator|&
name|m
operator|->
name|m_ceilings
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ceiling
operator|>
name|RTP_PRIO_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|UPRI
argument_list|(
name|td
argument_list|)
operator|<
name|PRI_MIN_REALTIME
operator|+
name|ceiling
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|su
operator|&&
name|PRI_MIN_REALTIME
operator|+
name|ceiling
operator|<
name|uq
operator|->
name|uq_inherited_pri
condition|)
block|{
name|uq
operator|->
name|uq_inherited_pri
operator|=
name|PRI_MIN_REALTIME
operator|+
name|ceiling
expr_stmt|;
if|if
condition|(
name|uq
operator|->
name|uq_inherited_pri
operator|<
name|UPRI
argument_list|(
name|td
argument_list|)
condition|)
name|sched_lend_user_prio
argument_list|(
name|td
argument_list|,
name|uq
operator|->
name|uq_inherited_pri
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|owner
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|UMUTEX_CONTESTED
argument_list|,
name|id
operator||
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
name|UMUTEX_CONTESTED
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|UMUTEX_ERROR_CHECK
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|==
name|id
condition|)
block|{
name|error
operator|=
name|EDEADLK
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|try
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
comment|/* 		 * If we caught a signal, we have retried and now 		 * exit immediately. 		 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_insert
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|error
operator|=
name|umtxq_sleep
argument_list|(
name|uq
argument_list|,
literal|"umtxpp"
argument_list|,
name|timo
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|uq
operator|->
name|uq_inherited_pri
operator|=
name|old_inherited_pri
expr_stmt|;
name|pri
operator|=
name|PRI_MAX
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pi
argument_list|,
argument|&uq->uq_pi_contested
argument_list|,
argument|pi_link
argument_list|)
block|{
name|uq2
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pi
operator|->
name|pi_blocked
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq2
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pri
operator|>
name|UPRI
argument_list|(
name|uq2
operator|->
name|uq_thread
argument_list|)
condition|)
name|pri
operator|=
name|UPRI
argument_list|(
name|uq2
operator|->
name|uq_thread
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pri
operator|>
name|uq
operator|->
name|uq_inherited_pri
condition|)
name|pri
operator|=
name|uq
operator|->
name|uq_inherited_pri
expr_stmt|;
name|sched_unlend_user_prio
argument_list|(
name|td
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|uq
operator|->
name|uq_inherited_pri
operator|=
name|old_inherited_pri
expr_stmt|;
name|pri
operator|=
name|PRI_MAX
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pi
argument_list|,
argument|&uq->uq_pi_contested
argument_list|,
argument|pi_link
argument_list|)
block|{
name|uq2
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pi
operator|->
name|pi_blocked
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq2
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pri
operator|>
name|UPRI
argument_list|(
name|uq2
operator|->
name|uq_thread
argument_list|)
condition|)
name|pri
operator|=
name|UPRI
argument_list|(
name|uq2
operator|->
name|uq_thread
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pri
operator|>
name|uq
operator|->
name|uq_inherited_pri
condition|)
name|pri
operator|=
name|uq
operator|->
name|uq_inherited_pri
expr_stmt|;
name|sched_unlend_user_prio
argument_list|(
name|td
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock a PP mutex.  */
end_comment

begin_function
specifier|static
name|int
name|do_unlock_pp
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|umtx_key
name|key
decl_stmt|;
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|,
modifier|*
name|uq2
decl_stmt|;
name|struct
name|umtx_pi
modifier|*
name|pi
decl_stmt|;
name|uint32_t
name|owner
decl_stmt|,
name|id
decl_stmt|;
name|uint32_t
name|rceiling
decl_stmt|;
name|int
name|error
decl_stmt|,
name|pri
decl_stmt|,
name|new_inherited_pri
decl_stmt|,
name|su
decl_stmt|;
name|id
operator|=
name|td
operator|->
name|td_tid
expr_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
name|su
operator|=
operator|(
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_SCHED_RTPRIO
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* 	 * Make sure we own this mtx. 	 */
name|owner
operator|=
name|fuword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|m
operator|->
name|m_owner
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|!=
name|id
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
operator|&
name|m
operator|->
name|m_ceilings
index|[
literal|1
index|]
argument_list|,
operator|&
name|rceiling
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|rceiling
operator|==
operator|-
literal|1
condition|)
name|new_inherited_pri
operator|=
name|PRI_MAX
expr_stmt|;
else|else
block|{
name|rceiling
operator|=
name|RTP_PRIO_MAX
operator|-
name|rceiling
expr_stmt|;
if|if
condition|(
name|rceiling
operator|>
name|RTP_PRIO_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|new_inherited_pri
operator|=
name|PRI_MIN_REALTIME
operator|+
name|rceiling
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|m
argument_list|,
name|TYPE_PP_UMUTEX
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
comment|/* 	 * For priority protected mutex, always set unlocked state 	 * to UMUTEX_CONTESTED, so that userland always enters kernel 	 * to lock the mutex, it is necessary because thread priority 	 * has to be adjusted for such mutex. 	 */
name|error
operator|=
name|suword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|m
operator|->
name|m_owner
argument_list|)
argument_list|,
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|umtxq_signal
argument_list|(
operator|&
name|key
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
name|error
operator|=
name|EFAULT
expr_stmt|;
else|else
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|su
operator|!=
literal|0
condition|)
name|uq
operator|->
name|uq_inherited_pri
operator|=
name|new_inherited_pri
expr_stmt|;
name|pri
operator|=
name|PRI_MAX
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pi
argument_list|,
argument|&uq->uq_pi_contested
argument_list|,
argument|pi_link
argument_list|)
block|{
name|uq2
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pi
operator|->
name|pi_blocked
argument_list|)
expr_stmt|;
if|if
condition|(
name|uq2
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pri
operator|>
name|UPRI
argument_list|(
name|uq2
operator|->
name|uq_thread
argument_list|)
condition|)
name|pri
operator|=
name|UPRI
argument_list|(
name|uq2
operator|->
name|uq_thread
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pri
operator|>
name|uq
operator|->
name|uq_inherited_pri
condition|)
name|pri
operator|=
name|uq
operator|->
name|uq_inherited_pri
expr_stmt|;
name|sched_unlend_user_prio
argument_list|(
name|td
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
name|umtx_key_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_set_ceiling
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|,
name|uint32_t
name|ceiling
parameter_list|,
name|uint32_t
modifier|*
name|old_ceiling
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|uint32_t
name|save_ceiling
decl_stmt|;
name|uint32_t
name|owner
decl_stmt|,
name|id
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|int
name|error
decl_stmt|;
name|flags
operator|=
name|fuword32
argument_list|(
operator|&
name|m
operator|->
name|m_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|UMUTEX_PRIO_PROTECT
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ceiling
operator|>
name|RTP_PRIO_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|id
operator|=
name|td
operator|->
name|td_tid
expr_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|m
argument_list|,
name|TYPE_PP_UMUTEX
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|save_ceiling
operator|=
name|fuword32
argument_list|(
operator|&
name|m
operator|->
name|m_ceilings
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|owner
operator|=
name|casuword32
argument_list|(
operator|&
name|m
operator|->
name|m_owner
argument_list|,
name|UMUTEX_CONTESTED
argument_list|,
name|id
operator||
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|==
name|UMUTEX_CONTESTED
condition|)
block|{
name|suword32
argument_list|(
operator|&
name|m
operator|->
name|m_ceilings
index|[
literal|0
index|]
argument_list|,
name|ceiling
argument_list|)
expr_stmt|;
name|suword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|m
operator|->
name|m_owner
argument_list|)
argument_list|,
name|UMUTEX_CONTESTED
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* The address was invalid. */
if|if
condition|(
name|owner
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|owner
operator|&
operator|~
name|UMUTEX_CONTESTED
operator|)
operator|==
name|id
condition|)
block|{
name|suword32
argument_list|(
operator|&
name|m
operator|->
name|m_ceilings
index|[
literal|0
index|]
argument_list|,
name|ceiling
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* 		 * If we caught a signal, we have retried and now 		 * exit immediately. 		 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
comment|/* 		 * We set the contested bit, sleep. Otherwise the lock changed 		 * and we need to retry or we lost a race to the thread 		 * unlocking the umtx. 		 */
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_insert
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|error
operator|=
name|umtxq_sleep
argument_list|(
name|uq
argument_list|,
literal|"umtxpp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
block|}
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|umtxq_signal
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|,
name|INT_MAX
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|old_ceiling
operator|!=
name|NULL
condition|)
name|suword32
argument_list|(
name|old_ceiling
argument_list|,
name|save_ceiling
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_do_lock_umutex
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|timo
parameter_list|,
name|int
name|try
parameter_list|)
block|{
switch|switch
condition|(
name|flags
operator|&
operator|(
name|UMUTEX_PRIO_INHERIT
operator||
name|UMUTEX_PRIO_PROTECT
operator|)
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
name|_do_lock_normal
argument_list|(
name|td
argument_list|,
name|m
argument_list|,
name|flags
argument_list|,
name|timo
argument_list|,
name|try
argument_list|)
operator|)
return|;
case|case
name|UMUTEX_PRIO_INHERIT
case|:
return|return
operator|(
name|_do_lock_pi
argument_list|(
name|td
argument_list|,
name|m
argument_list|,
name|flags
argument_list|,
name|timo
argument_list|,
name|try
argument_list|)
operator|)
return|;
case|case
name|UMUTEX_PRIO_PROTECT
case|:
return|return
operator|(
name|_do_lock_pp
argument_list|(
name|td
argument_list|,
name|m
argument_list|,
name|flags
argument_list|,
name|timo
argument_list|,
name|try
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock a userland POSIX mutex.  */
end_comment

begin_function
specifier|static
name|int
name|do_lock_umutex
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|,
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|,
name|int
name|try
parameter_list|)
block|{
name|struct
name|timespec
name|ts
decl_stmt|,
name|ts2
decl_stmt|,
name|ts3
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|int
name|error
decl_stmt|;
name|flags
operator|=
name|fuword32
argument_list|(
operator|&
name|m
operator|->
name|m_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
name|timeout
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|_do_lock_umutex
argument_list|(
name|td
argument_list|,
name|m
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|,
name|try
argument_list|)
expr_stmt|;
comment|/* Mutex locking is restarted if it is interrupted. */
if|if
condition|(
name|error
operator|==
name|EINTR
condition|)
name|error
operator|=
name|ERESTART
expr_stmt|;
block|}
else|else
block|{
name|getnanouptime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|timespecadd
argument_list|(
operator|&
name|ts
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
name|_do_lock_umutex
argument_list|(
name|td
argument_list|,
name|m
argument_list|,
name|flags
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|,
name|try
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ETIMEDOUT
condition|)
break|break;
name|getnanouptime
argument_list|(
operator|&
name|ts2
argument_list|)
expr_stmt|;
if|if
condition|(
name|timespeccmp
argument_list|(
operator|&
name|ts2
argument_list|,
operator|&
name|ts
argument_list|,
operator|>=
argument_list|)
condition|)
block|{
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
break|break;
block|}
name|ts3
operator|=
name|ts
expr_stmt|;
name|timespecsub
argument_list|(
operator|&
name|ts3
argument_list|,
operator|&
name|ts2
argument_list|)
expr_stmt|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|ts3
argument_list|)
expr_stmt|;
block|}
comment|/* Timed-locking is not restarted. */
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock a userland POSIX mutex.  */
end_comment

begin_function
specifier|static
name|int
name|do_unlock_umutex
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|)
block|{
name|uint32_t
name|flags
decl_stmt|;
name|flags
operator|=
name|fuword32
argument_list|(
operator|&
name|m
operator|->
name|m_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
switch|switch
condition|(
name|flags
operator|&
operator|(
name|UMUTEX_PRIO_INHERIT
operator||
name|UMUTEX_PRIO_PROTECT
operator|)
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
name|do_unlock_normal
argument_list|(
name|td
argument_list|,
name|m
argument_list|,
name|flags
argument_list|)
operator|)
return|;
case|case
name|UMUTEX_PRIO_INHERIT
case|:
return|return
operator|(
name|do_unlock_pi
argument_list|(
name|td
argument_list|,
name|m
argument_list|,
name|flags
argument_list|)
operator|)
return|;
case|case
name|UMUTEX_PRIO_PROTECT
case|:
return|return
operator|(
name|do_unlock_pp
argument_list|(
name|td
argument_list|,
name|m
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_cv_wait
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|ucond
modifier|*
name|cv
parameter_list|,
name|struct
name|umutex
modifier|*
name|m
parameter_list|,
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|,
name|u_long
name|wflags
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timespec
name|cts
decl_stmt|,
name|ets
decl_stmt|,
name|tts
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
name|flags
operator|=
name|fuword32
argument_list|(
operator|&
name|cv
operator|->
name|c_flags
argument_list|)
expr_stmt|;
name|error
operator|=
name|umtx_key_get
argument_list|(
name|cv
argument_list|,
name|TYPE_CV
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_insert
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
comment|/* 	 * The magic thing is we should set c_has_waiters to 1 before 	 * releasing user mutex. 	 */
name|suword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|cv
operator|->
name|c_has_waiters
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|error
operator|=
name|do_unlock_umutex
argument_list|(
name|td
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|wflags
operator|&
name|UMTX_CHECK_UNPARKING
operator|)
operator|&&
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_WAKEUP
operator|)
condition|)
block|{
name|td
operator|->
name|td_pflags
operator|&=
operator|~
name|TDP_WAKEUP
expr_stmt|;
name|error
operator|=
name|EINTR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|timeout
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|umtxq_sleep
argument_list|(
name|uq
argument_list|,
literal|"ucond"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|getnanouptime
argument_list|(
operator|&
name|ets
argument_list|)
expr_stmt|;
name|timespecadd
argument_list|(
operator|&
name|ets
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
name|umtxq_sleep
argument_list|(
name|uq
argument_list|,
literal|"ucond"
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ETIMEDOUT
condition|)
break|break;
name|getnanouptime
argument_list|(
operator|&
name|cts
argument_list|)
expr_stmt|;
if|if
condition|(
name|timespeccmp
argument_list|(
operator|&
name|cts
argument_list|,
operator|&
name|ets
argument_list|,
operator|>=
argument_list|)
condition|)
block|{
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
break|break;
block|}
name|tts
operator|=
name|ets
expr_stmt|;
name|timespecsub
argument_list|(
operator|&
name|tts
argument_list|,
operator|&
name|cts
argument_list|)
expr_stmt|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|tts
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|uq
operator|->
name|uq_flags
operator|&
name|UQF_UMTXQ
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If we concurrently got do_cv_signal()d 			 * and we got an error or UNIX signals or a timeout, 			 * then, perform another umtxq_signal to avoid 			 * consuming the wakeup. This may cause supurious 			 * wakeup for another thread which was just queued, 			 * but SUSV3 explicitly allows supurious wakeup to 			 * occur, and indeed a kernel based implementation 			 * can not avoid it. 			 */
if|if
condition|(
operator|!
name|umtxq_signal
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|,
literal|1
argument_list|)
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
block|}
name|umtxq_remove
argument_list|(
name|uq
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|uq
operator|->
name|uq_key
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Signal a userland condition variable.  */
end_comment

begin_function
specifier|static
name|int
name|do_cv_signal
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|ucond
modifier|*
name|cv
parameter_list|)
block|{
name|struct
name|umtx_key
name|key
decl_stmt|;
name|int
name|error
decl_stmt|,
name|cnt
decl_stmt|,
name|nwake
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|flags
operator|=
name|fuword32
argument_list|(
operator|&
name|cv
operator|->
name|c_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|cv
argument_list|,
name|TYPE_CV
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|umtxq_count
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|nwake
operator|=
name|umtxq_signal
argument_list|(
operator|&
name|key
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<=
name|nwake
condition|)
block|{
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|error
operator|=
name|suword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|cv
operator|->
name|c_has_waiters
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
block|}
name|umtxq_unbusy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_cv_broadcast
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|ucond
modifier|*
name|cv
parameter_list|)
block|{
name|struct
name|umtx_key
name|key
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|flags
operator|=
name|fuword32
argument_list|(
operator|&
name|cv
operator|->
name|c_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|umtx_key_get
argument_list|(
name|cv
argument_list|,
name|TYPE_CV
argument_list|,
name|GET_SHARE
argument_list|(
name|flags
argument_list|)
argument_list|,
operator|&
name|key
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_busy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_signal
argument_list|(
operator|&
name|key
argument_list|,
name|INT_MAX
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|error
operator|=
name|suword32
argument_list|(
name|__DEVOLATILE
argument_list|(
name|uint32_t
operator|*
argument_list|,
operator|&
name|cv
operator|->
name|c_has_waiters
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|umtxq_lock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unbusy
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtxq_unlock
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|umtx_key_release
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_umtx_lock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_lock_args
modifier|*
name|uap
parameter_list|)
comment|/* struct umtx *umtx */
block|{
return|return
name|_do_lock_umtx
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|umtx
argument_list|,
name|td
operator|->
name|td_tid
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|_umtx_unlock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_unlock_args
modifier|*
name|uap
parameter_list|)
comment|/* struct umtx *umtx */
block|{
return|return
name|do_unlock_umtx
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|umtx
argument_list|,
name|td
operator|->
name|td_tid
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_lock_umtx
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timespec
modifier|*
name|ts
decl_stmt|,
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allow a null timespec (wait forever). */
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|ts
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|&
name|timeout
argument_list|,
sizeof|sizeof
argument_list|(
name|timeout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|timeout
operator|.
name|tv_nsec
operator|>=
literal|1000000000
operator|||
name|timeout
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ts
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
return|return
operator|(
name|do_lock_umtx
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|val
argument_list|,
name|ts
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_unlock_umtx
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|do_unlock_umtx
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_wait
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timespec
modifier|*
name|ts
decl_stmt|,
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|ts
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|&
name|timeout
argument_list|,
sizeof|sizeof
argument_list|(
name|timeout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|timeout
operator|.
name|tv_nsec
operator|>=
literal|1000000000
operator|||
name|timeout
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ts
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
return|return
name|do_wait
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|val
argument_list|,
name|ts
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_wake
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|kern_umtx_wake
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_lock_umutex
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timespec
modifier|*
name|ts
decl_stmt|,
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allow a null timespec (wait forever). */
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|ts
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|&
name|timeout
argument_list|,
sizeof|sizeof
argument_list|(
name|timeout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|timeout
operator|.
name|tv_nsec
operator|>=
literal|1000000000
operator|||
name|timeout
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ts
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
return|return
name|do_lock_umutex
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|ts
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_trylock_umutex
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
name|do_lock_umutex
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_unlock_umutex
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
name|do_unlock_umutex
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_set_ceiling
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
name|do_set_ceiling
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|val
argument_list|,
name|uap
operator|->
name|uaddr1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_cv_wait
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timespec
modifier|*
name|ts
decl_stmt|,
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allow a null timespec (wait forever). */
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|ts
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|&
name|timeout
argument_list|,
sizeof|sizeof
argument_list|(
name|timeout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|timeout
operator|.
name|tv_nsec
operator|>=
literal|1000000000
operator|||
name|timeout
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ts
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
return|return
operator|(
name|do_cv_wait
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|uaddr1
argument_list|,
name|ts
argument_list|,
name|uap
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_cv_signal
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
name|do_cv_signal
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_cv_broadcast
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
name|do_cv_broadcast
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|_umtx_op_func
function_decl|)
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|_umtx_op_func
name|op_table
index|[]
init|=
block|{
name|__umtx_op_lock_umtx
block|,
comment|/* UMTX_OP_LOCK */
name|__umtx_op_unlock_umtx
block|,
comment|/* UMTX_OP_UNLOCK */
name|__umtx_op_wait
block|,
comment|/* UMTX_OP_WAIT */
name|__umtx_op_wake
block|,
comment|/* UMTX_OP_WAKE */
name|__umtx_op_trylock_umutex
block|,
comment|/* UMTX_OP_MUTEX_TRYLOCK */
name|__umtx_op_lock_umutex
block|,
comment|/* UMTX_OP_MUTEX_LOCK */
name|__umtx_op_unlock_umutex
block|,
comment|/* UMTX_OP_MUTEX_UNLOCK */
name|__umtx_op_set_ceiling
block|,
comment|/* UMTX_OP_SET_CEILING */
name|__umtx_op_cv_wait
block|,
comment|/* UMTX_OP_CV_WAIT*/
name|__umtx_op_cv_signal
block|,
comment|/* UMTX_OP_CV_SIGNAL */
name|__umtx_op_cv_broadcast
comment|/* UMTX_OP_CV_BROADCAST */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|_umtx_op
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
if|if
condition|(
operator|(
name|unsigned
operator|)
name|uap
operator|->
name|op
operator|<
name|UMTX_OP_MAX
condition|)
return|return
call|(
modifier|*
name|op_table
index|[
name|uap
operator|->
name|op
index|]
call|)
argument_list|(
name|td
argument_list|,
name|uap
argument_list|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_IA32
end_ifdef

begin_function
name|int
name|freebsd32_umtx_lock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd32_umtx_lock_args
modifier|*
name|uap
parameter_list|)
comment|/* struct umtx *umtx */
block|{
return|return
operator|(
name|do_lock_umtx32
argument_list|(
name|td
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
name|uap
operator|->
name|umtx
argument_list|,
name|td
operator|->
name|td_tid
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|freebsd32_umtx_unlock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd32_umtx_unlock_args
modifier|*
name|uap
parameter_list|)
comment|/* struct umtx *umtx */
block|{
return|return
operator|(
name|do_unlock_umtx32
argument_list|(
name|td
argument_list|,
operator|(
name|uint32_t
operator|*
operator|)
name|uap
operator|->
name|umtx
argument_list|,
name|td
operator|->
name|td_tid
argument_list|)
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|timespec32
block|{
name|u_int32_t
name|tv_sec
decl_stmt|;
name|u_int32_t
name|tv_nsec
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|int
name|copyin_timeout32
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|)
block|{
name|struct
name|timespec32
name|ts32
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|addr
argument_list|,
operator|&
name|ts32
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|timespec32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|tsp
operator|->
name|tv_sec
operator|=
name|ts32
operator|.
name|tv_sec
expr_stmt|;
name|tsp
operator|->
name|tv_nsec
operator|=
name|ts32
operator|.
name|tv_nsec
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_lock_umtx_compat32
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timespec
modifier|*
name|ts
decl_stmt|,
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allow a null timespec (wait forever). */
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|ts
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|copyin_timeout32
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|timeout
operator|.
name|tv_nsec
operator|>=
literal|1000000000
operator|||
name|timeout
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ts
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
return|return
operator|(
name|do_lock_umtx32
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|val
argument_list|,
name|ts
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_unlock_umtx_compat32
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|do_unlock_umtx32
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
operator|(
name|uint32_t
operator|)
name|uap
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_wait_compat32
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timespec
modifier|*
name|ts
decl_stmt|,
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|ts
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|copyin_timeout32
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|timeout
operator|.
name|tv_nsec
operator|>=
literal|1000000000
operator|||
name|timeout
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ts
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
return|return
name|do_wait
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|val
argument_list|,
name|ts
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_lock_umutex_compat32
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timespec
modifier|*
name|ts
decl_stmt|,
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allow a null timespec (wait forever). */
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|ts
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|copyin_timeout32
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|timeout
operator|.
name|tv_nsec
operator|>=
literal|1000000000
operator|||
name|timeout
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ts
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
return|return
name|do_lock_umutex
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|ts
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__umtx_op_cv_wait_compat32
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timespec
modifier|*
name|ts
decl_stmt|,
name|timeout
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Allow a null timespec (wait forever). */
if|if
condition|(
name|uap
operator|->
name|uaddr2
operator|==
name|NULL
condition|)
name|ts
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|copyin_timeout32
argument_list|(
name|uap
operator|->
name|uaddr2
argument_list|,
operator|&
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|timeout
operator|.
name|tv_nsec
operator|>=
literal|1000000000
operator|||
name|timeout
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ts
operator|=
operator|&
name|timeout
expr_stmt|;
block|}
return|return
operator|(
name|do_cv_wait
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|obj
argument_list|,
name|uap
operator|->
name|uaddr1
argument_list|,
name|ts
argument_list|,
name|uap
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|_umtx_op_func
name|op_table_compat32
index|[]
init|=
block|{
name|__umtx_op_lock_umtx_compat32
block|,
comment|/* UMTX_OP_LOCK */
name|__umtx_op_unlock_umtx_compat32
block|,
comment|/* UMTX_OP_UNLOCK */
name|__umtx_op_wait_compat32
block|,
comment|/* UMTX_OP_WAIT */
name|__umtx_op_wake
block|,
comment|/* UMTX_OP_WAKE */
name|__umtx_op_trylock_umutex
block|,
comment|/* UMTX_OP_MUTEX_LOCK */
name|__umtx_op_lock_umutex_compat32
block|,
comment|/* UMTX_OP_MUTEX_TRYLOCK */
name|__umtx_op_unlock_umutex
block|,
comment|/* UMTX_OP_MUTEX_UNLOCK	*/
name|__umtx_op_set_ceiling
block|,
comment|/* UMTX_OP_SET_CEILING */
name|__umtx_op_cv_wait_compat32
block|,
comment|/* UMTX_OP_CV_WAIT*/
name|__umtx_op_cv_signal
block|,
comment|/* UMTX_OP_CV_SIGNAL */
name|__umtx_op_cv_broadcast
comment|/* UMTX_OP_CV_BROADCAST */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|freebsd32_umtx_op
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd32_umtx_op_args
modifier|*
name|uap
parameter_list|)
block|{
if|if
condition|(
operator|(
name|unsigned
operator|)
name|uap
operator|->
name|op
operator|<
name|UMTX_OP_MAX
condition|)
return|return
call|(
modifier|*
name|op_table_compat32
index|[
name|uap
operator|->
name|op
index|]
call|)
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|_umtx_op_args
operator|*
operator|)
name|uap
argument_list|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|umtx_thread_init
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|td
operator|->
name|td_umtxq
operator|=
name|umtxq_alloc
argument_list|()
expr_stmt|;
name|td
operator|->
name|td_umtxq
operator|->
name|uq_thread
operator|=
name|td
expr_stmt|;
block|}
end_function

begin_function
name|void
name|umtx_thread_fini
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|umtxq_free
argument_list|(
name|td
operator|->
name|td_umtxq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * It will be called when new thread is created, e.g fork().  */
end_comment

begin_function
name|void
name|umtx_thread_alloc
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|uq
operator|=
name|td
operator|->
name|td_umtxq
expr_stmt|;
name|uq
operator|->
name|uq_inherited_pri
operator|=
name|PRI_MAX
expr_stmt|;
name|KASSERT
argument_list|(
name|uq
operator|->
name|uq_flags
operator|==
literal|0
argument_list|,
operator|(
literal|"uq_flags != 0"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|uq
operator|->
name|uq_thread
operator|==
name|td
argument_list|,
operator|(
literal|"uq_thread != td"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|uq
operator|->
name|uq_pi_blocked
operator|==
name|NULL
argument_list|,
operator|(
literal|"uq_pi_blocked != NULL"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|uq
operator|->
name|uq_pi_contested
argument_list|)
argument_list|,
operator|(
literal|"uq_pi_contested is not empty"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * exec() hook.  */
end_comment

begin_function
specifier|static
name|void
name|umtx_exec_hook
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|proc
modifier|*
name|p
name|__unused
parameter_list|,
name|struct
name|image_params
modifier|*
name|imgp
name|__unused
parameter_list|)
block|{
name|umtx_thread_cleanup
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * thread_exit() hook.  */
end_comment

begin_function
name|void
name|umtx_thread_exit
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|umtx_thread_cleanup
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * clean up umtx data.  */
end_comment

begin_function
specifier|static
name|void
name|umtx_thread_cleanup
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|umtx_q
modifier|*
name|uq
decl_stmt|;
name|struct
name|umtx_pi
modifier|*
name|pi
decl_stmt|;
if|if
condition|(
operator|(
name|uq
operator|=
name|td
operator|->
name|td_umtxq
operator|)
operator|==
name|NULL
condition|)
return|return;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|uq
operator|->
name|uq_inherited_pri
operator|=
name|PRI_MAX
expr_stmt|;
while|while
condition|(
operator|(
name|pi
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|uq
operator|->
name|uq_pi_contested
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pi
operator|->
name|pi_owner
operator|=
name|NULL
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|uq
operator|->
name|uq_pi_contested
argument_list|,
name|pi
argument_list|,
name|pi_link
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_UBORROWING
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

