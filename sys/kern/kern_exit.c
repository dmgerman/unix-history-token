begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1989, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  * (c) UNIX System Laboratories, Inc.  * All or some portions of this file are derived from material licensed  * to the University of California by American Telephone and Telegraph  * Co. or Unix System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)kern_exit.c	8.7 (Berkeley) 2/12/94  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_kdtrace.h"
end_include

begin_include
include|#
directive|include
file|"opt_ktrace.h"
end_include

begin_include
include|#
directive|include
file|"opt_procdesc.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/capability.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/procdesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/pioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/racct.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/acct.h>
end_include

begin_comment
comment|/* for acct_process() function prototype */
end_comment

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sdt.h>
end_include

begin_include
include|#
directive|include
file|<sys/shm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sem.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<security/audit/audit.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
end_ifdef

begin_include
include|#
directive|include
file|<sys/dtrace_bsd.h>
end_include

begin_decl_stmt
name|dtrace_execexit_func_t
name|dtrace_fasttrap_exit
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SDT_PROVIDER_DECLARE
argument_list|(
name|proc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SDT_PROBE_DEFINE1
argument_list|(
name|proc
argument_list|,
name|kernel
argument_list|, ,
name|exit
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Hook for NFS teardown procedure. */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|nlminfo_release_p
function_decl|)
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|struct
name|proc
modifier|*
name|proc_realparent
parameter_list|(
name|struct
name|proc
modifier|*
name|child
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|,
modifier|*
name|parent
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|proctree_lock
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|child
operator|->
name|p_treeflag
operator|&
name|P_TREE_ORPHANED
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|child
operator|->
name|p_pptr
operator|->
name|p_pid
operator|==
name|child
operator|->
name|p_oppid
condition|?
name|child
operator|->
name|p_pptr
else|:
name|initproc
operator|)
return|;
block|}
for|for
control|(
name|p
operator|=
name|child
init|;
operator|(
name|p
operator|->
name|p_treeflag
operator|&
name|P_TREE_FIRST_ORPHAN
operator|)
operator|==
literal|0
condition|;
control|)
block|{
comment|/* Cannot use LIST_PREV(), since the list head is not known. */
name|p
operator|=
name|__containerof
argument_list|(
name|p
operator|->
name|p_orphan
operator|.
name|le_prev
argument_list|,
expr|struct
name|proc
argument_list|,
name|p_orphan
operator|.
name|le_next
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|p
operator|->
name|p_treeflag
operator|&
name|P_TREE_ORPHANED
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"missing P_ORPHAN %p"
operator|,
name|p
operator|)
argument_list|)
expr_stmt|;
block|}
name|parent
operator|=
name|__containerof
argument_list|(
name|p
operator|->
name|p_orphan
operator|.
name|le_prev
argument_list|,
expr|struct
name|proc
argument_list|,
name|p_orphans
operator|.
name|lh_first
argument_list|)
expr_stmt|;
return|return
operator|(
name|parent
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clear_orphan
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p1
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|proctree_lock
argument_list|,
name|SA_XLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|p_treeflag
operator|&
name|P_TREE_ORPHANED
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|p
operator|->
name|p_treeflag
operator|&
name|P_TREE_FIRST_ORPHAN
operator|)
operator|!=
literal|0
condition|)
block|{
name|p1
operator|=
name|LIST_NEXT
argument_list|(
name|p
argument_list|,
name|p_orphan
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|!=
name|NULL
condition|)
name|p1
operator|->
name|p_treeflag
operator||=
name|P_TREE_FIRST_ORPHAN
expr_stmt|;
name|p
operator|->
name|p_treeflag
operator|&=
operator|~
name|P_TREE_FIRST_ORPHAN
expr_stmt|;
block|}
name|LIST_REMOVE
argument_list|(
name|p
argument_list|,
name|p_orphan
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_treeflag
operator|&=
operator|~
name|P_TREE_ORPHANED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * exit -- death of process.  */
end_comment

begin_function
name|void
name|sys_sys_exit
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|sys_exit_args
modifier|*
name|uap
parameter_list|)
block|{
name|exit1
argument_list|(
name|td
argument_list|,
name|W_EXITCODE
argument_list|(
name|uap
operator|->
name|rval
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Exit: deallocate address space and other resources, change proc state to  * zombie, and unlink proc from allproc and parent's lists.  Save exit status  * and rusage for wait().  Check for child processes and orphan them.  */
end_comment

begin_function
name|void
name|exit1
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|rv
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|,
modifier|*
name|nq
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|struct
name|vnode
modifier|*
name|ttyvp
init|=
name|NULL
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
comment|/* 	 * XXX in case we're rebooting we just let init die in order to 	 * work around an unsolved stack overflow seen very late during 	 * shutdown on sparc64 when the gmirror worker process exists. 	 */
if|if
condition|(
name|p
operator|==
name|initproc
operator|&&
name|rebooting
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"init died (signal %d, exit %d)\n"
argument_list|,
name|WTERMSIG
argument_list|(
name|rv
argument_list|)
argument_list|,
name|WEXITSTATUS
argument_list|(
name|rv
argument_list|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Going nowhere without my init!"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * MUST abort all other threads before proceeding past here. 	 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_HADTHREADS
condition|)
block|{
comment|/* 		 * First check if some other thread got here before us. 		 * If so, act appropriately: exit or suspend. 		 */
name|thread_suspend_check
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Kill off the other threads. This requires 		 * some co-operation from other parts of the kernel 		 * so it may not be instantaneous.  With this state set 		 * any thread entering the kernel from userspace will 		 * thread_exit() in trap().  Any thread attempting to 		 * sleep will return immediately with EINTR or EWOULDBLOCK 		 * which will hopefully force them to back out to userland 		 * freeing resources as they go.  Any thread attempting 		 * to return to userland will thread_exit() from userret(). 		 * thread_exit() will unsuspend us when the last of the 		 * other threads exits. 		 * If there is already a thread singler after resumption, 		 * calling thread_single will fail; in that case, we just 		 * re-check all suspension request, the thread should 		 * either be suspended there or exit. 		 */
if|if
condition|(
operator|!
name|thread_single
argument_list|(
name|SINGLE_EXIT
argument_list|)
condition|)
break|break;
comment|/* 		 * All other activity in this process is now stopped. 		 * Threading support has been turned off. 		 */
block|}
name|KASSERT
argument_list|(
name|p
operator|->
name|p_numthreads
operator|==
literal|1
argument_list|,
operator|(
literal|"exit1: proc %p exiting with %d threads"
operator|,
name|p
operator|,
name|p
operator|->
name|p_numthreads
operator|)
argument_list|)
expr_stmt|;
name|racct_sub
argument_list|(
name|p
argument_list|,
name|RACCT_NTHR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Wakeup anyone in procfs' PIOCWAIT.  They should have a hold 	 * on our vmspace, so we should block below until they have 	 * released their reference to us.  Note that if they have 	 * requested S_EXIT stops we will block here until they ack 	 * via PIOCCONT. 	 */
name|_STOPEVENT
argument_list|(
name|p
argument_list|,
name|S_EXIT
argument_list|,
name|rv
argument_list|)
expr_stmt|;
comment|/* 	 * Ignore any pending request to stop due to a stop signal. 	 * Once P_WEXIT is set, future requests will be ignored as 	 * well. 	 */
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_STOPPED_SIG
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|P_SHOULDSTOP
argument_list|(
name|p
argument_list|)
argument_list|,
operator|(
literal|"exiting process is stopped"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Note that we are exiting and do another wakeup of anyone in 	 * PIOCWAIT in case they aren't listening for S_EXIT stops or 	 * decided to wait again after we told them we are exiting. 	 */
name|p
operator|->
name|p_flag
operator||=
name|P_WEXIT
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|p
operator|->
name|p_stype
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for any processes that have a hold on our vmspace to 	 * release their reference. 	 */
while|while
condition|(
name|p
operator|->
name|p_lock
operator|>
literal|0
condition|)
name|msleep
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|,
operator|&
name|p
operator|->
name|p_mtx
argument_list|,
name|PWAIT
argument_list|,
literal|"exithold"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_xstat
operator|=
name|rv
expr_stmt|;
comment|/* Let event handler change exit status */
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Drain the limit callout while we don't have the proc locked */
name|callout_drain
argument_list|(
operator|&
name|p
operator|->
name|p_limco
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUDIT
comment|/* 	 * The Sun BSM exit token contains two components: an exit status as 	 * passed to exit(), and a return value to indicate what sort of exit 	 * it was.  The exit status is WEXITSTATUS(rv), but it's not clear 	 * what the return value is. 	 */
name|AUDIT_ARG_EXIT
argument_list|(
name|WEXITSTATUS
argument_list|(
name|rv
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AUDIT_SYSCALL_EXIT
argument_list|(
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Are we a task leader? */
if|if
condition|(
name|p
operator|==
name|p
operator|->
name|p_leader
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|ppeers_lock
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|p_peers
expr_stmt|;
while|while
condition|(
name|q
operator|!=
name|NULL
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|kern_psignal
argument_list|(
name|q
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|q
operator|->
name|p_peers
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|->
name|p_peers
operator|!=
name|NULL
condition|)
name|msleep
argument_list|(
name|p
argument_list|,
operator|&
name|ppeers_lock
argument_list|,
name|PWAIT
argument_list|,
literal|"exit1"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ppeers_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check if any loadable modules need anything done at process exit. 	 * E.g. SYSV IPC stuff 	 * XXX what if one of these generates an error? 	 */
name|EVENTHANDLER_INVOKE
argument_list|(
name|process_exit
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * If parent is waiting for us to exit or exec, 	 * P_PPWAIT is set; we will wakeup the parent below. 	 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|rv
operator|=
name|p
operator|->
name|p_xstat
expr_stmt|;
comment|/* Event handler could change exit status */
name|stopprofclock
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator|&=
operator|~
operator|(
name|P_TRACED
operator||
name|P_PPWAIT
operator||
name|P_PPTRACE
operator|)
expr_stmt|;
comment|/* 	 * Stop the real interval timer.  If the handler is currently 	 * executing, prevent it from rearming itself and let it finish. 	 */
if|if
condition|(
name|timevalisset
argument_list|(
operator|&
name|p
operator|->
name|p_realtimer
operator|.
name|it_value
argument_list|)
operator|&&
name|callout_stop
argument_list|(
operator|&
name|p
operator|->
name|p_itcallout
argument_list|)
operator|==
literal|0
condition|)
block|{
name|timevalclear
argument_list|(
operator|&
name|p
operator|->
name|p_realtimer
operator|.
name|it_interval
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|p
operator|->
name|p_itcallout
argument_list|,
operator|&
name|p
operator|->
name|p_mtx
argument_list|,
name|PWAIT
argument_list|,
literal|"ritwait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|timevalisset
argument_list|(
operator|&
name|p
operator|->
name|p_realtimer
operator|.
name|it_value
argument_list|)
argument_list|,
operator|(
literal|"realtime timer is still armed"
operator|)
argument_list|)
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Reset any sigio structures pointing to us as a result of 	 * F_SETOWN with our pid. 	 */
name|funsetownlst
argument_list|(
operator|&
name|p
operator|->
name|p_sigiolst
argument_list|)
expr_stmt|;
comment|/* 	 * If this process has an nlminfo data area (for lockd), release it 	 */
if|if
condition|(
name|nlminfo_release_p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|p_nlminfo
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|nlminfo_release_p
call|)
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Close open files and release open-file table. 	 * This may block! 	 */
name|fdescfree
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* 	 * If this thread tickled GEOM, we need to wait for the giggling to 	 * stop before we return to userland 	 */
if|if
condition|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_GEOM
condition|)
name|g_waitidle
argument_list|()
expr_stmt|;
comment|/* 	 * Remove ourself from our leader's peer list and wake our leader. 	 */
name|mtx_lock
argument_list|(
operator|&
name|ppeers_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_leader
operator|->
name|p_peers
condition|)
block|{
name|q
operator|=
name|p
operator|->
name|p_leader
expr_stmt|;
while|while
condition|(
name|q
operator|->
name|p_peers
operator|!=
name|p
condition|)
name|q
operator|=
name|q
operator|->
name|p_peers
expr_stmt|;
name|q
operator|->
name|p_peers
operator|=
name|p
operator|->
name|p_peers
expr_stmt|;
name|wakeup
argument_list|(
name|p
operator|->
name|p_leader
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ppeers_lock
argument_list|)
expr_stmt|;
name|vmspace_exit
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|SESS_LEADER
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|struct
name|session
modifier|*
name|sp
init|=
name|p
operator|->
name|p_session
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
comment|/* 		 * s_ttyp is not zero'd; we use this to indicate that 		 * the session once had a controlling terminal. (for 		 * logging and informational purposes) 		 */
name|SESS_LOCK
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|ttyvp
operator|=
name|sp
operator|->
name|s_ttyvp
expr_stmt|;
name|tp
operator|=
name|sp
operator|->
name|s_ttyp
expr_stmt|;
name|sp
operator|->
name|s_ttyvp
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|s_ttydp
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|s_leader
operator|=
name|NULL
expr_stmt|;
name|SESS_UNLOCK
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 		 * Signal foreground pgrp and revoke access to 		 * controlling terminal if it has not been revoked 		 * already. 		 * 		 * Because the TTY may have been revoked in the mean 		 * time and could already have a new session associated 		 * with it, make sure we don't send a SIGHUP to a 		 * foreground process group that does not belong to this 		 * session. 		 */
if|if
condition|(
name|tp
operator|!=
name|NULL
condition|)
block|{
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_session
operator|==
name|sp
condition|)
name|tty_signal_pgrp
argument_list|(
name|tp
argument_list|,
name|SIGHUP
argument_list|)
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ttyvp
operator|!=
name|NULL
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_lock
argument_list|(
name|ttyvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VOP_REVOKE
argument_list|(
name|ttyvp
argument_list|,
name|REVOKEALL
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|ttyvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sx_xlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
block|}
block|}
name|fixjobc
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|p_pgrp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|acct_process
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* Release the TTY now we've unlocked everything. */
if|if
condition|(
name|ttyvp
operator|!=
name|NULL
condition|)
name|vrele
argument_list|(
name|ttyvp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
name|ktrprocexit
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Release reference to text vnode 	 */
if|if
condition|(
name|p
operator|->
name|p_textvp
operator|!=
name|NULL
condition|)
block|{
name|vrele
argument_list|(
name|p
operator|->
name|p_textvp
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_textvp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Release our limits structure. 	 */
name|lim_free
argument_list|(
name|p
operator|->
name|p_limit
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_limit
operator|=
name|NULL
expr_stmt|;
name|tidhash_remove
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* 	 * Remove proc from allproc queue and pidhash chain. 	 * Place onto zombproc.  Unlink from parent's child list. 	 */
name|sx_xlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|p
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|zombproc
argument_list|,
name|p
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|p
argument_list|,
name|p_hash
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Call machine-dependent code to release any 	 * machine-dependent resources other than the address space. 	 * The address space is released by "vmspace_exitfree(p)" in 	 * vm_waitproc(). 	 */
name|cpu_exit
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|WITNESS_WARN
argument_list|(
name|WARN_PANIC
argument_list|,
name|NULL
argument_list|,
literal|"process (pid %d) exiting"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
comment|/* 	 * Reparent all of our children to init. 	 */
name|sx_xlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|q
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|p
operator|->
name|p_children
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
comment|/* only need this if any child is S_ZOMB */
name|wakeup
argument_list|(
name|initproc
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|nq
control|)
block|{
name|nq
operator|=
name|LIST_NEXT
argument_list|(
name|q
argument_list|,
name|p_sibling
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|proc_reparent
argument_list|(
name|q
argument_list|,
name|initproc
argument_list|)
expr_stmt|;
name|q
operator|->
name|p_sigparent
operator|=
name|SIGCHLD
expr_stmt|;
comment|/* 		 * Traced processes are killed 		 * since their existence means someone is screwing up. 		 */
if|if
condition|(
name|q
operator|->
name|p_flag
operator|&
name|P_TRACED
condition|)
block|{
name|struct
name|thread
modifier|*
name|temp
decl_stmt|;
comment|/* 			 * Since q was found on our children list, the 			 * proc_reparent() call moved q to the orphan 			 * list due to present P_TRACED flag. Clear 			 * orphan link for q now while q is locked. 			 */
name|clear_orphan
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|p_flag
operator|&=
operator|~
operator|(
name|P_TRACED
operator||
name|P_STOPPED_TRACE
operator|)
expr_stmt|;
name|FOREACH_THREAD_IN_PROC
argument_list|(
argument|q
argument_list|,
argument|temp
argument_list|)
name|temp
operator|->
name|td_dbgflags
operator|&=
operator|~
name|TDB_SUSPEND
expr_stmt|;
name|kern_psignal
argument_list|(
name|q
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Also get rid of our orphans. 	 */
while|while
condition|(
operator|(
name|q
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|p
operator|->
name|p_orphans
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|clear_orphan
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* Save exit status. */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_xthread
operator|=
name|td
expr_stmt|;
comment|/* Tell the prison that we are gone. */
name|prison_proc_free
argument_list|(
name|p
operator|->
name|p_ucred
operator|->
name|cr_prison
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
comment|/* 	 * Tell the DTrace fasttrap provider about the exit if it 	 * has declared an interest. 	 */
if|if
condition|(
name|dtrace_fasttrap_exit
condition|)
name|dtrace_fasttrap_exit
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Notify interested parties of our demise. 	 */
name|KNOTE_LOCKED
argument_list|(
operator|&
name|p
operator|->
name|p_klist
argument_list|,
name|NOTE_EXIT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
name|int
name|reason
init|=
name|CLD_EXITED
decl_stmt|;
if|if
condition|(
name|WCOREDUMP
argument_list|(
name|rv
argument_list|)
condition|)
name|reason
operator|=
name|CLD_DUMPED
expr_stmt|;
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|rv
argument_list|)
condition|)
name|reason
operator|=
name|CLD_KILLED
expr_stmt|;
name|SDT_PROBE
argument_list|(
name|proc
argument_list|,
name|kernel
argument_list|, ,
name|exit
argument_list|,
name|reason
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Just delete all entries in the p_klist. At this point we won't 	 * report any more events, and there are nasty race conditions that 	 * can beat us if we don't. 	 */
name|knlist_clear
argument_list|(
operator|&
name|p
operator|->
name|p_klist
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a process with a descriptor, we may not need to deliver 	 * a signal to the parent.  proctree_lock is held over 	 * procdesc_exit() to serialize concurrent calls to close() and 	 * exit(). 	 */
ifdef|#
directive|ifdef
name|PROCDESC
if|if
condition|(
name|p
operator|->
name|p_procdesc
operator|==
name|NULL
operator|||
name|procdesc_exit
argument_list|(
name|p
argument_list|)
condition|)
block|{
endif|#
directive|endif
comment|/* 		 * Notify parent that we're gone.  If parent has the 		 * PS_NOCLDWAIT flag set, or if the handler is set to SIG_IGN, 		 * notify process 1 instead (and hope it will handle this 		 * situation). 		 */
name|PROC_LOCK
argument_list|(
name|p
operator|->
name|p_pptr
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|p
operator|->
name|p_pptr
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_pptr
operator|->
name|p_sigacts
operator|->
name|ps_flag
operator|&
operator|(
name|PS_NOCLDWAIT
operator||
name|PS_CLDSIGIGN
operator|)
condition|)
block|{
name|struct
name|proc
modifier|*
name|pp
decl_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|p
operator|->
name|p_pptr
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
name|pp
operator|=
name|p
operator|->
name|p_pptr
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|proc_reparent
argument_list|(
name|p
argument_list|,
name|initproc
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_sigparent
operator|=
name|SIGCHLD
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
operator|->
name|p_pptr
argument_list|)
expr_stmt|;
comment|/* 			 * Notify parent, so in case he was wait(2)ing or 			 * executing waitpid(2) with our pid, he will 			 * continue. 			 */
name|wakeup
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|p
operator|->
name|p_pptr
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_pptr
operator|==
name|initproc
condition|)
name|kern_psignal
argument_list|(
name|p
operator|->
name|p_pptr
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|p_sigparent
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_sigparent
operator|==
name|SIGCHLD
condition|)
name|childproc_exited
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
comment|/* LINUX thread */
name|kern_psignal
argument_list|(
name|p
operator|->
name|p_pptr
argument_list|,
name|p
operator|->
name|p_sigparent
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PROCDESC
block|}
else|else
name|PROC_LOCK
argument_list|(
name|p
operator|->
name|p_pptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
comment|/* 	 * The state PRS_ZOMBIE prevents other proesses from sending 	 * signal to the process, to avoid memory leak, we free memory 	 * for signal queue at the time when the state is set. 	 */
name|sigqueue_flush
argument_list|(
operator|&
name|p
operator|->
name|p_sigqueue
argument_list|)
expr_stmt|;
name|sigqueue_flush
argument_list|(
operator|&
name|td
operator|->
name|td_sigqueue
argument_list|)
expr_stmt|;
comment|/* 	 * We have to wait until after acquiring all locks before 	 * changing p_state.  We need to avoid all possible context 	 * switches (including ones from blocking on a mutex) while 	 * marked as a zombie.  We also have to set the zombie state 	 * before we release the parent process' proc lock to avoid 	 * a lost wakeup.  So, we first call wakeup, then we grab the 	 * sched lock, update the state, and release the parent process' 	 * proc lock. 	 */
name|wakeup
argument_list|(
name|p
operator|->
name|p_pptr
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|p
operator|->
name|p_pwait
argument_list|)
expr_stmt|;
name|sched_exit
argument_list|(
name|p
operator|->
name|p_pptr
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|PROC_SLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_state
operator|=
name|PRS_ZOMBIE
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
operator|->
name|p_pptr
argument_list|)
expr_stmt|;
comment|/* 	 * Hopefully no one will try to deliver a signal to the process this 	 * late in the game. 	 */
name|knlist_destroy
argument_list|(
operator|&
name|p
operator|->
name|p_klist
argument_list|)
expr_stmt|;
comment|/* 	 * Save our children's rusage information in our exit rusage. 	 */
name|ruadd
argument_list|(
operator|&
name|p
operator|->
name|p_ru
argument_list|,
operator|&
name|p
operator|->
name|p_rux
argument_list|,
operator|&
name|p
operator|->
name|p_stats
operator|->
name|p_cru
argument_list|,
operator|&
name|p
operator|->
name|p_crux
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the scheduler takes this thread out of its tables etc. 	 * This will also release this thread's reference to the ucred. 	 * Other thread parts to release include pcb bits and such. 	 */
name|thread_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|abort2_args
block|{
name|char
modifier|*
name|why
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|void
modifier|*
modifier|*
name|args
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sys_abort2
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|abort2_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|void
modifier|*
name|uargs
index|[
literal|16
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|sig
decl_stmt|;
comment|/* 	 * Do it right now so we can log either proper call of abort2(), or 	 * note, that invalid argument was passed. 512 is big enough to 	 * handle 16 arguments' descriptions with additional comments. 	 */
name|sb
operator|=
name|sbuf_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|512
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|sbuf_clear
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s(pid %d uid %d) aborted: "
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_ucred
operator|->
name|cr_uid
argument_list|)
expr_stmt|;
comment|/* 	 * Since we can't return from abort2(), send SIGKILL in cases, where 	 * abort2() was called improperly 	 */
name|sig
operator|=
name|SIGKILL
expr_stmt|;
comment|/* Prevent from DoSes from user-space. */
if|if
condition|(
name|uap
operator|->
name|nargs
operator|<
literal|0
operator|||
name|uap
operator|->
name|nargs
operator|>
literal|16
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|uap
operator|->
name|nargs
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|uap
operator|->
name|args
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|args
argument_list|,
name|uargs
argument_list|,
name|uap
operator|->
name|nargs
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Limit size of 'reason' string to 128. Will fit even when 	 * maximal number of arguments was chosen to be logged. 	 */
if|if
condition|(
name|uap
operator|->
name|why
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|sbuf_copyin
argument_list|(
name|sb
argument_list|,
name|uap
operator|->
name|why
argument_list|,
literal|128
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"(null)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uap
operator|->
name|nargs
operator|>
literal|0
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uap
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s%p"
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|""
else|:
literal|", "
argument_list|,
name|uargs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Final stage: arguments were proper, string has been 	 * successfully copied from userspace, and copying pointers 	 * from user-space succeed. 	 */
name|sig
operator|=
name|SIGABRT
expr_stmt|;
name|out
label|:
if|if
condition|(
name|sig
operator|==
name|SIGKILL
condition|)
block|{
name|sbuf_trim
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" (Reason text inaccessible)"
argument_list|)
expr_stmt|;
block|}
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s"
argument_list|,
name|sbuf_data
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|exit1
argument_list|(
name|td
argument_list|,
name|W_EXITCODE
argument_list|(
literal|0
argument_list|,
name|sig
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_43
end_ifdef

begin_comment
comment|/*  * The dirty work is handled by kern_wait().  */
end_comment

begin_function
name|int
name|owait
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|owait_args
modifier|*
name|uap
name|__unused
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|status
decl_stmt|;
name|error
operator|=
name|kern_wait
argument_list|(
name|td
argument_list|,
name|WAIT_ANY
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
name|status
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPAT_43 */
end_comment

begin_comment
comment|/*  * The dirty work is handled by kern_wait().  */
end_comment

begin_function
name|int
name|sys_wait4
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|wait4_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|rusage
name|ru
decl_stmt|,
modifier|*
name|rup
decl_stmt|;
name|int
name|error
decl_stmt|,
name|status
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|rusage
operator|!=
name|NULL
condition|)
name|rup
operator|=
operator|&
name|ru
expr_stmt|;
else|else
name|rup
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|kern_wait
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|pid
argument_list|,
operator|&
name|status
argument_list|,
name|uap
operator|->
name|options
argument_list|,
name|rup
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|status
operator|!=
name|NULL
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|status
argument_list|,
name|uap
operator|->
name|status
argument_list|,
sizeof|sizeof
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|rusage
operator|!=
name|NULL
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|ru
argument_list|,
name|uap
operator|->
name|rusage
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rusage
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sys_wait6
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|wait6_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|__wrusage
name|wru
decl_stmt|,
modifier|*
name|wrup
decl_stmt|;
name|siginfo_t
name|si
decl_stmt|,
modifier|*
name|sip
decl_stmt|;
name|idtype_t
name|idtype
decl_stmt|;
name|id_t
name|id
decl_stmt|;
name|int
name|error
decl_stmt|,
name|status
decl_stmt|;
name|idtype
operator|=
name|uap
operator|->
name|idtype
expr_stmt|;
name|id
operator|=
name|uap
operator|->
name|id
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|wrusage
operator|!=
name|NULL
condition|)
name|wrup
operator|=
operator|&
name|wru
expr_stmt|;
else|else
name|wrup
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|info
operator|!=
name|NULL
condition|)
block|{
name|sip
operator|=
operator|&
name|si
expr_stmt|;
name|bzero
argument_list|(
name|sip
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sip
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|sip
operator|=
name|NULL
expr_stmt|;
comment|/* 	 *  We expect all callers of wait6() to know about WEXITED and 	 *  WTRAPPED. 	 */
name|error
operator|=
name|kern_wait6
argument_list|(
name|td
argument_list|,
name|idtype
argument_list|,
name|id
argument_list|,
operator|&
name|status
argument_list|,
name|uap
operator|->
name|options
argument_list|,
name|wrup
argument_list|,
name|sip
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|status
operator|!=
name|NULL
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|status
argument_list|,
name|uap
operator|->
name|status
argument_list|,
sizeof|sizeof
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|wrusage
operator|!=
name|NULL
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|wru
argument_list|,
name|uap
operator|->
name|wrusage
argument_list|,
sizeof|sizeof
argument_list|(
name|wru
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|info
operator|!=
name|NULL
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|si
argument_list|,
name|uap
operator|->
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reap the remains of a zombie process and optionally return status and  * rusage.  Asserts and will release both the proctree_lock and the process  * lock as part of its work.  */
end_comment

begin_function
name|void
name|proc_reap
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|int
modifier|*
name|status
parameter_list|,
name|int
name|options
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|q
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|proctree_lock
argument_list|,
name|SA_XLOCKED
argument_list|)
expr_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|PROC_SLOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|p
operator|->
name|p_state
operator|==
name|PRS_ZOMBIE
argument_list|,
operator|(
literal|"proc_reap: !PRS_ZOMBIE"
operator|)
argument_list|)
expr_stmt|;
name|q
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_SUNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
if|if
condition|(
name|status
condition|)
operator|*
name|status
operator|=
name|p
operator|->
name|p_xstat
expr_stmt|;
comment|/* convert to int */
if|if
condition|(
name|options
operator|&
name|WNOWAIT
condition|)
block|{
comment|/* 		 *  Only poll, returning the status.  Caller does not wish to 		 * release the proc struct just yet. 		 */
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|sigqueue_take
argument_list|(
name|p
operator|->
name|p_ksi
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * If we got the child via a ptrace 'attach', we need to give it back 	 * to the old parent. 	 */
if|if
condition|(
name|p
operator|->
name|p_oppid
operator|!=
literal|0
condition|)
block|{
name|t
operator|=
name|proc_realparent
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|proc_reparent
argument_list|(
name|p
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_oppid
operator|=
literal|0
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pksignal
argument_list|(
name|t
argument_list|,
name|SIGCHLD
argument_list|,
name|p
operator|->
name|p_ksi
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|p
operator|->
name|p_pwait
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Remove other references to this process to ensure we have an 	 * exclusive reference. 	 */
name|sx_xlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|p
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
comment|/* off zombproc */
name|sx_xunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|p
argument_list|,
name|p_sibling
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|clear_orphan
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|leavepgrp
argument_list|(
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROCDESC
if|if
condition|(
name|p
operator|->
name|p_procdesc
operator|!=
name|NULL
condition|)
name|procdesc_reap
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
comment|/* 	 * As a side effect of this lock, we know that all other writes to 	 * this proc are visible now, so no more locking is needed for p. 	 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_xstat
operator|=
literal|0
expr_stmt|;
comment|/* XXX: why? */
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|ruadd
argument_list|(
operator|&
name|q
operator|->
name|p_stats
operator|->
name|p_cru
argument_list|,
operator|&
name|q
operator|->
name|p_crux
argument_list|,
operator|&
name|p
operator|->
name|p_ru
argument_list|,
operator|&
name|p
operator|->
name|p_rux
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* 	 * Decrement the count of procs running with this uid. 	 */
operator|(
name|void
operator|)
name|chgproccnt
argument_list|(
name|p
operator|->
name|p_ucred
operator|->
name|cr_ruidinfo
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Destroy resource accounting information associated with the process. 	 */
ifdef|#
directive|ifdef
name|RACCT
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|racct_sub
argument_list|(
name|p
argument_list|,
name|RACCT_NPROC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|racct_proc_exit
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Free credentials, arguments, and sigacts. 	 */
name|crfree
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_ucred
operator|=
name|NULL
expr_stmt|;
name|pargs_drop
argument_list|(
name|p
operator|->
name|p_args
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_args
operator|=
name|NULL
expr_stmt|;
name|sigacts_free
argument_list|(
name|p
operator|->
name|p_sigacts
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_sigacts
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Do any thread-system specific cleanups. 	 */
name|thread_wait
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Give vm and machine-dependent layer a chance to free anything that 	 * cpu_exit couldn't release while still running in process context. 	 */
name|vm_waitproc
argument_list|(
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_proc_destroy
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|FIRST_THREAD_IN_PROC
argument_list|(
name|p
argument_list|)
argument_list|,
operator|(
literal|"proc_reap: no residual thread!"
operator|)
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|proc_zone
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|nprocs
operator|--
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|proc_to_reap
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|idtype_t
name|idtype
parameter_list|,
name|id_t
name|id
parameter_list|,
name|int
modifier|*
name|status
parameter_list|,
name|int
name|options
parameter_list|,
name|struct
name|__wrusage
modifier|*
name|wrusage
parameter_list|,
name|siginfo_t
modifier|*
name|siginfo
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|q
decl_stmt|;
name|struct
name|rusage
modifier|*
name|rup
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|proctree_lock
argument_list|,
name|SA_XLOCKED
argument_list|)
expr_stmt|;
name|q
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|idtype
condition|)
block|{
case|case
name|P_ALL
case|:
break|break;
case|case
name|P_PID
case|:
if|if
condition|(
name|p
operator|->
name|p_pid
operator|!=
operator|(
name|pid_t
operator|)
name|id
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|P_PGID
case|:
if|if
condition|(
name|p
operator|->
name|p_pgid
operator|!=
operator|(
name|pid_t
operator|)
name|id
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|P_SID
case|:
if|if
condition|(
name|p
operator|->
name|p_session
operator|->
name|s_sid
operator|!=
operator|(
name|pid_t
operator|)
name|id
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|P_UID
case|:
if|if
condition|(
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
operator|(
name|uid_t
operator|)
name|id
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|P_GID
case|:
if|if
condition|(
name|p
operator|->
name|p_ucred
operator|->
name|cr_gid
operator|!=
operator|(
name|gid_t
operator|)
name|id
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|P_JAILID
case|:
if|if
condition|(
name|p
operator|->
name|p_ucred
operator|->
name|cr_prison
operator|->
name|pr_id
operator|!=
operator|(
name|int
operator|)
name|id
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
comment|/* 	 * It seems that the thread structures get zeroed out 	 * at process exit.  This makes it impossible to 	 * support P_SETID, P_CID or P_CPUID. 	 */
default|default:
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|p_canwait
argument_list|(
name|td
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|options
operator|&
name|WEXITED
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|p
operator|->
name|p_state
operator|==
name|PRS_ZOMBIE
operator|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * This special case handles a kthread spawned by linux_clone 	 * (see linux_misc.c).  The linux_wait4 and linux_waitpid 	 * functions need to be able to distinguish between waiting 	 * on a process and waiting on a thread.  It is a thread if 	 * p_sigparent is not SIGCHLD, and the WLINUXCLONE option 	 * signifies we want to wait for threads and not processes. 	 */
if|if
condition|(
operator|(
name|p
operator|->
name|p_sigparent
operator|!=
name|SIGCHLD
operator|)
operator|^
operator|(
operator|(
name|options
operator|&
name|WLINUXCLONE
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|PROC_SLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|siginfo
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
name|siginfo
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|siginfo
argument_list|)
argument_list|)
expr_stmt|;
name|siginfo
operator|->
name|si_errno
operator|=
literal|0
expr_stmt|;
comment|/* 		 * SUSv4 requires that the si_signo value is always 		 * SIGCHLD. Obey it despite the rfork(2) interface 		 * allows to request other signal for child exit 		 * notification. 		 */
name|siginfo
operator|->
name|si_signo
operator|=
name|SIGCHLD
expr_stmt|;
comment|/* 		 *  This is still a rough estimate.  We will fix the 		 *  cases TRAPPED, STOPPED, and CONTINUED later. 		 */
if|if
condition|(
name|WCOREDUMP
argument_list|(
name|p
operator|->
name|p_xstat
argument_list|)
condition|)
block|{
name|siginfo
operator|->
name|si_code
operator|=
name|CLD_DUMPED
expr_stmt|;
name|siginfo
operator|->
name|si_status
operator|=
name|WTERMSIG
argument_list|(
name|p
operator|->
name|p_xstat
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|p
operator|->
name|p_xstat
argument_list|)
condition|)
block|{
name|siginfo
operator|->
name|si_code
operator|=
name|CLD_KILLED
expr_stmt|;
name|siginfo
operator|->
name|si_status
operator|=
name|WTERMSIG
argument_list|(
name|p
operator|->
name|p_xstat
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|siginfo
operator|->
name|si_code
operator|=
name|CLD_EXITED
expr_stmt|;
name|siginfo
operator|->
name|si_status
operator|=
name|WEXITSTATUS
argument_list|(
name|p
operator|->
name|p_xstat
argument_list|)
expr_stmt|;
block|}
name|siginfo
operator|->
name|si_pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|siginfo
operator|->
name|si_uid
operator|=
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
expr_stmt|;
comment|/* 		 * The si_addr field would be useful additional 		 * detail, but apparently the PC value may be lost 		 * when we reach this point.  bzero() above sets 		 * siginfo->si_addr to NULL. 		 */
block|}
comment|/* 	 * There should be no reason to limit resources usage info to 	 * exited processes only.  A snapshot about any resources used 	 * by a stopped process may be exactly what is needed. 	 */
if|if
condition|(
name|wrusage
operator|!=
name|NULL
condition|)
block|{
name|rup
operator|=
operator|&
name|wrusage
operator|->
name|wru_self
expr_stmt|;
operator|*
name|rup
operator|=
name|p
operator|->
name|p_ru
expr_stmt|;
name|calcru
argument_list|(
name|p
argument_list|,
operator|&
name|rup
operator|->
name|ru_utime
argument_list|,
operator|&
name|rup
operator|->
name|ru_stime
argument_list|)
expr_stmt|;
name|rup
operator|=
operator|&
name|wrusage
operator|->
name|wru_children
expr_stmt|;
operator|*
name|rup
operator|=
name|p
operator|->
name|p_stats
operator|->
name|p_cru
expr_stmt|;
name|calccru
argument_list|(
name|p
argument_list|,
operator|&
name|rup
operator|->
name|ru_utime
argument_list|,
operator|&
name|rup
operator|->
name|ru_stime
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|p_state
operator|==
name|PRS_ZOMBIE
condition|)
block|{
name|proc_reap
argument_list|(
name|td
argument_list|,
name|p
argument_list|,
name|status
argument_list|,
name|options
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|PROC_SUNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kern_wait
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|int
modifier|*
name|status
parameter_list|,
name|int
name|options
parameter_list|,
name|struct
name|rusage
modifier|*
name|rusage
parameter_list|)
block|{
name|struct
name|__wrusage
name|wru
decl_stmt|,
modifier|*
name|wrup
decl_stmt|;
name|idtype_t
name|idtype
decl_stmt|;
name|id_t
name|id
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* 	 * Translate the special pid values into the (idtype, pid) 	 * pair for kern_wait6.  The WAIT_MYPGRP case is handled by 	 * kern_wait6() on its own. 	 */
if|if
condition|(
name|pid
operator|==
name|WAIT_ANY
condition|)
block|{
name|idtype
operator|=
name|P_ALL
expr_stmt|;
name|id
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|idtype
operator|=
name|P_PGID
expr_stmt|;
name|id
operator|=
operator|(
name|id_t
operator|)
operator|-
name|pid
expr_stmt|;
block|}
else|else
block|{
name|idtype
operator|=
name|P_PID
expr_stmt|;
name|id
operator|=
operator|(
name|id_t
operator|)
name|pid
expr_stmt|;
block|}
if|if
condition|(
name|rusage
operator|!=
name|NULL
condition|)
name|wrup
operator|=
operator|&
name|wru
expr_stmt|;
else|else
name|wrup
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * For backward compatibility we implicitly add flags WEXITED 	 * and WTRAPPED here. 	 */
name|options
operator||=
name|WEXITED
operator||
name|WTRAPPED
expr_stmt|;
name|ret
operator|=
name|kern_wait6
argument_list|(
name|td
argument_list|,
name|idtype
argument_list|,
name|id
argument_list|,
name|status
argument_list|,
name|options
argument_list|,
name|wrup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rusage
operator|!=
name|NULL
condition|)
operator|*
name|rusage
operator|=
name|wru
operator|.
name|wru_self
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kern_wait6
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|idtype_t
name|idtype
parameter_list|,
name|id_t
name|id
parameter_list|,
name|int
modifier|*
name|status
parameter_list|,
name|int
name|options
parameter_list|,
name|struct
name|__wrusage
modifier|*
name|wrusage
parameter_list|,
name|siginfo_t
modifier|*
name|siginfo
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nfound
decl_stmt|,
name|ret
decl_stmt|;
name|AUDIT_ARG_VALUE
argument_list|(
operator|(
name|int
operator|)
name|idtype
argument_list|)
expr_stmt|;
comment|/* XXX - This is likely wrong! */
name|AUDIT_ARG_PID
argument_list|(
operator|(
name|pid_t
operator|)
name|id
argument_list|)
expr_stmt|;
comment|/* XXX - This may be wrong! */
name|AUDIT_ARG_VALUE
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|q
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
if|if
condition|(
operator|(
name|pid_t
operator|)
name|id
operator|==
name|WAIT_MYPGRP
operator|&&
operator|(
name|idtype
operator|==
name|P_PID
operator|||
name|idtype
operator|==
name|P_PGID
operator|)
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|id
operator|=
operator|(
name|id_t
operator|)
name|q
operator|->
name|p_pgid
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|idtype
operator|=
name|P_PGID
expr_stmt|;
block|}
comment|/* If we don't know the option, just return. */
if|if
condition|(
operator|(
name|options
operator|&
operator|~
operator|(
name|WUNTRACED
operator||
name|WNOHANG
operator||
name|WCONTINUED
operator||
name|WNOWAIT
operator||
name|WEXITED
operator||
name|WTRAPPED
operator||
name|WLINUXCLONE
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|options
operator|&
operator|(
name|WEXITED
operator||
name|WUNTRACED
operator||
name|WCONTINUED
operator||
name|WTRAPPED
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We will be unable to find any matching processes, 		 * because there are no known events to look for. 		 * Prefer to return error instead of blocking 		 * indefinitely. 		 */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|loop
label|:
if|if
condition|(
name|q
operator|->
name|p_flag
operator|&
name|P_STATCHILD
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|p_flag
operator|&=
operator|~
name|P_STATCHILD
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|nfound
operator|=
literal|0
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&q->p_children
argument_list|,
argument|p_sibling
argument_list|)
block|{
name|ret
operator|=
name|proc_to_reap
argument_list|(
name|td
argument_list|,
name|p
argument_list|,
name|idtype
argument_list|,
name|id
argument_list|,
name|status
argument_list|,
name|options
argument_list|,
name|wrusage
argument_list|,
name|siginfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
name|nfound
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PROC_SLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|WTRAPPED
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_TRACED
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|->
name|p_flag
operator|&
operator|(
name|P_STOPPED_TRACE
operator||
name|P_STOPPED_SIG
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|->
name|p_suspcount
operator|==
name|p
operator|->
name|p_numthreads
operator|)
operator|&&
operator|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_WAITED
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|PROC_SUNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|WNOWAIT
operator|)
operator|==
literal|0
condition|)
name|p
operator|->
name|p_flag
operator||=
name|P_WAITED
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|NULL
condition|)
operator|*
name|status
operator|=
name|W_STOPCODE
argument_list|(
name|p
operator|->
name|p_xstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|siginfo
operator|!=
name|NULL
condition|)
block|{
name|siginfo
operator|->
name|si_status
operator|=
name|p
operator|->
name|p_xstat
expr_stmt|;
name|siginfo
operator|->
name|si_code
operator|=
name|CLD_TRAPPED
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|options
operator|&
name|WNOWAIT
operator|)
operator|==
literal|0
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|sigqueue_take
argument_list|(
name|p
operator|->
name|p_ksi
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|options
operator|&
name|WUNTRACED
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_STOPPED_SIG
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|->
name|p_suspcount
operator|==
name|p
operator|->
name|p_numthreads
operator|)
operator|&&
operator|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_WAITED
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|PROC_SUNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|WNOWAIT
operator|)
operator|==
literal|0
condition|)
name|p
operator|->
name|p_flag
operator||=
name|P_WAITED
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|NULL
condition|)
operator|*
name|status
operator|=
name|W_STOPCODE
argument_list|(
name|p
operator|->
name|p_xstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|siginfo
operator|!=
name|NULL
condition|)
block|{
name|siginfo
operator|->
name|si_status
operator|=
name|p
operator|->
name|p_xstat
expr_stmt|;
name|siginfo
operator|->
name|si_code
operator|=
name|CLD_STOPPED
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|options
operator|&
name|WNOWAIT
operator|)
operator|==
literal|0
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|sigqueue_take
argument_list|(
name|p
operator|->
name|p_ksi
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|PROC_SUNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|WCONTINUED
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_CONTINUED
operator|)
operator|!=
literal|0
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
if|if
condition|(
operator|(
name|options
operator|&
name|WNOWAIT
operator|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_CONTINUED
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|sigqueue_take
argument_list|(
name|p
operator|->
name|p_ksi
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|NULL
condition|)
operator|*
name|status
operator|=
name|SIGCONT
expr_stmt|;
if|if
condition|(
name|siginfo
operator|!=
name|NULL
condition|)
block|{
name|siginfo
operator|->
name|si_status
operator|=
name|SIGCONT
expr_stmt|;
name|siginfo
operator|->
name|si_code
operator|=
name|CLD_CONTINUED
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Look in the orphans list too, to allow the parent to 	 * collect it's child exit status even if child is being 	 * debugged. 	 * 	 * Debugger detaches from the parent upon successful 	 * switch-over from parent to child.  At this point due to 	 * re-parenting the parent loses the child to debugger and a 	 * wait4(2) call would report that it has no children to wait 	 * for.  By maintaining a list of orphans we allow the parent 	 * to successfully wait until the child becomes a zombie. 	 */
name|LIST_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&q->p_orphans
argument_list|,
argument|p_orphan
argument_list|)
block|{
name|ret
operator|=
name|proc_to_reap
argument_list|(
name|td
argument_list|,
name|p
argument_list|,
name|idtype
argument_list|,
name|id
argument_list|,
name|status
argument_list|,
name|options
argument_list|,
name|wrusage
argument_list|,
name|siginfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
name|nfound
operator|++
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|nfound
operator|==
literal|0
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ECHILD
operator|)
return|;
block|}
if|if
condition|(
name|options
operator|&
name|WNOHANG
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|p_flag
operator|&
name|P_STATCHILD
condition|)
block|{
name|q
operator|->
name|p_flag
operator|&=
operator|~
name|P_STATCHILD
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|error
operator|=
name|msleep
argument_list|(
name|q
argument_list|,
operator|&
name|q
operator|->
name|p_mtx
argument_list|,
name|PWAIT
operator||
name|PCATCH
argument_list|,
literal|"wait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
goto|goto
name|loop
goto|;
block|}
end_function

begin_comment
comment|/*  * Make process 'parent' the new parent of process 'child'.  * Must be called with an exclusive hold of proctree lock.  */
end_comment

begin_function
name|void
name|proc_reparent
parameter_list|(
name|struct
name|proc
modifier|*
name|child
parameter_list|,
name|struct
name|proc
modifier|*
name|parent
parameter_list|)
block|{
name|sx_assert
argument_list|(
operator|&
name|proctree_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|child
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|p_pptr
operator|==
name|parent
condition|)
return|return;
name|PROC_LOCK
argument_list|(
name|child
operator|->
name|p_pptr
argument_list|)
expr_stmt|;
name|sigqueue_take
argument_list|(
name|child
operator|->
name|p_ksi
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|child
operator|->
name|p_pptr
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|child
argument_list|,
name|p_sibling
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|parent
operator|->
name|p_children
argument_list|,
name|child
argument_list|,
name|p_sibling
argument_list|)
expr_stmt|;
name|clear_orphan
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|p_flag
operator|&
name|P_TRACED
condition|)
block|{
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|child
operator|->
name|p_pptr
operator|->
name|p_orphans
argument_list|)
condition|)
block|{
name|child
operator|->
name|p_treeflag
operator||=
name|P_TREE_FIRST_ORPHAN
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|child
operator|->
name|p_pptr
operator|->
name|p_orphans
argument_list|,
name|child
argument_list|,
name|p_orphan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LIST_INSERT_AFTER
argument_list|(
name|LIST_FIRST
argument_list|(
operator|&
name|child
operator|->
name|p_pptr
operator|->
name|p_orphans
argument_list|)
argument_list|,
name|child
argument_list|,
name|p_orphan
argument_list|)
expr_stmt|;
block|}
name|child
operator|->
name|p_treeflag
operator||=
name|P_TREE_ORPHANED
expr_stmt|;
block|}
name|child
operator|->
name|p_pptr
operator|=
name|parent
expr_stmt|;
block|}
end_function

end_unit

