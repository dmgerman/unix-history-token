begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1989, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  * (c) UNIX System Laboratories, Inc.  * All or some portions of this file are derived from material licensed  * to the University of California by American Telephone and Telegraph  * Co. or Unix System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)kern_exit.c	8.7 (Berkeley) 2/12/94  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_ktrace.h"
end_include

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/pioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/acct.h>
end_include

begin_comment
comment|/* for acct_process() function prototype */
end_comment

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/shm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sem.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<security/audit/audit.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_comment
comment|/* Required to be non-static for SysVR4 emulator */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_ZOMBIE
argument_list|,
literal|"zombie"
argument_list|,
literal|"zombie proc status"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Hook for NFS teardown procedure. */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|nlminfo_release_p
function_decl|)
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * exit -- death of process.  */
end_comment

begin_function
name|void
name|sys_exit
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|sys_exit_args
modifier|*
name|uap
parameter_list|)
block|{
name|exit1
argument_list|(
name|td
argument_list|,
name|W_EXITCODE
argument_list|(
name|uap
operator|->
name|rval
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Exit: deallocate address space and other resources, change proc state to  * zombie, and unlink proc from allproc and parent's lists.  Save exit status  * and rusage for wait().  Check for child processes and orphan them.  */
end_comment

begin_function
name|void
name|exit1
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|rv
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|,
modifier|*
name|nq
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|ttyvp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vtmp
decl_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
name|struct
name|vnode
modifier|*
name|tracevp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|tracecred
decl_stmt|;
endif|#
directive|endif
name|struct
name|plimit
modifier|*
name|plim
decl_stmt|;
name|int
name|locked
decl_stmt|;
comment|/* 	 * Drop Giant if caller has it.  Eventually we should warn about 	 * being called with Giant held. 	 */
while|while
condition|(
name|mtx_owned
argument_list|(
operator|&
name|Giant
argument_list|)
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|initproc
condition|)
block|{
name|printf
argument_list|(
literal|"init died (signal %d, exit %d)\n"
argument_list|,
name|WTERMSIG
argument_list|(
name|rv
argument_list|)
argument_list|,
name|WEXITSTATUS
argument_list|(
name|rv
argument_list|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Going nowhere without my init!"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * MUST abort all other threads before proceeding past here. 	 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_HADTHREADS
condition|)
block|{
name|retry
label|:
comment|/* 		 * First check if some other thread got here before us.. 		 * if so, act apropriatly, (exit or suspend); 		 */
name|thread_suspend_check
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Kill off the other threads. This requires 		 * some co-operation from other parts of the kernel 		 * so it may not be instantaneous.  With this state set 		 * any thread entering the kernel from userspace will 		 * thread_exit() in trap().  Any thread attempting to 		 * sleep will return immediately with EINTR or EWOULDBLOCK 		 * which will hopefully force them to back out to userland 		 * freeing resources as they go.  Any thread attempting 		 * to return to userland will thread_exit() from userret(). 		 * thread_exit() will unsuspend us when the last of the 		 * other threads exits. 		 * If there is already a thread singler after resumption, 		 * calling thread_single will fail; in that case, we just 		 * re-check all suspension request, the thread should 		 * either be suspended there or exit. 		 */
if|if
condition|(
name|thread_single
argument_list|(
name|SINGLE_EXIT
argument_list|)
condition|)
goto|goto
name|retry
goto|;
comment|/* 		 * All other activity in this process is now stopped. 		 * Threading support has been turned off. 		 */
block|}
comment|/* 	 * Wakeup anyone in procfs' PIOCWAIT.  They should have a hold 	 * on our vmspace, so we should block below until they have 	 * released their reference to us.  Note that if they have 	 * requested S_EXIT stops we will block here until they ack 	 * via PIOCCONT. 	 */
name|_STOPEVENT
argument_list|(
name|p
argument_list|,
name|S_EXIT
argument_list|,
name|rv
argument_list|)
expr_stmt|;
comment|/* 	 * Note that we are exiting and do another wakeup of anyone in 	 * PIOCWAIT in case they aren't listening for S_EXIT stops or 	 * decided to wait again after we told them we are exiting. 	 */
name|p
operator|->
name|p_flag
operator||=
name|P_WEXIT
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|p
operator|->
name|p_stype
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for any processes that have a hold on our vmspace to 	 * release their reference. 	 */
while|while
condition|(
name|p
operator|->
name|p_lock
operator|>
literal|0
condition|)
name|msleep
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|,
operator|&
name|p
operator|->
name|p_mtx
argument_list|,
name|PWAIT
argument_list|,
literal|"exithold"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AUDIT
comment|/* 	 * The Sun BSM exit token contains two components: an exit status as 	 * passed to exit(), and a return value to indicate what sort of exit 	 * it was.  The exit status is WEXITSTATUS(rv), but it's not clear 	 * what the return value is. 	 */
name|AUDIT_ARG
argument_list|(
name|exit
argument_list|,
name|WEXITSTATUS
argument_list|(
name|rv
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AUDIT_SYSCALL_EXIT
argument_list|(
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Are we a task leader? */
if|if
condition|(
name|p
operator|==
name|p
operator|->
name|p_leader
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|ppeers_lock
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|->
name|p_peers
expr_stmt|;
while|while
condition|(
name|q
operator|!=
name|NULL
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|q
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|=
name|q
operator|->
name|p_peers
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|->
name|p_peers
operator|!=
name|NULL
condition|)
name|msleep
argument_list|(
name|p
argument_list|,
operator|&
name|ppeers_lock
argument_list|,
name|PWAIT
argument_list|,
literal|"exit1"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ppeers_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check if any loadable modules need anything done at process exit. 	 * E.g. SYSV IPC stuff 	 * XXX what if one of these generates an error? 	 */
name|EVENTHANDLER_INVOKE
argument_list|(
name|process_exit
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|p
operator|->
name|p_ru
argument_list|,
expr|struct
name|rusage
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rusage
argument_list|)
argument_list|,
name|M_ZOMBIE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * If parent is waiting for us to exit or exec, 	 * P_PPWAIT is set; we will wakeup the parent below. 	 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|stopprofclock
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator|&=
operator|~
operator|(
name|P_TRACED
operator||
name|P_PPWAIT
operator|)
expr_stmt|;
comment|/* 	 * Stop the real interval timer.  If the handler is currently 	 * executing, prevent it from rearming itself and let it finish. 	 */
if|if
condition|(
name|timevalisset
argument_list|(
operator|&
name|p
operator|->
name|p_realtimer
operator|.
name|it_value
argument_list|)
operator|&&
name|callout_stop
argument_list|(
operator|&
name|p
operator|->
name|p_itcallout
argument_list|)
operator|==
literal|0
condition|)
block|{
name|timevalclear
argument_list|(
operator|&
name|p
operator|->
name|p_realtimer
operator|.
name|it_interval
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|p
operator|->
name|p_itcallout
argument_list|,
operator|&
name|p
operator|->
name|p_mtx
argument_list|,
name|PWAIT
argument_list|,
literal|"ritwait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|timevalisset
argument_list|(
operator|&
name|p
operator|->
name|p_realtimer
operator|.
name|it_value
argument_list|)
argument_list|,
operator|(
literal|"realtime timer is still armed"
operator|)
argument_list|)
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Reset any sigio structures pointing to us as a result of 	 * F_SETOWN with our pid. 	 */
name|funsetownlst
argument_list|(
operator|&
name|p
operator|->
name|p_sigiolst
argument_list|)
expr_stmt|;
comment|/* 	 * If this process has an nlminfo data area (for lockd), release it 	 */
if|if
condition|(
name|nlminfo_release_p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|p_nlminfo
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|nlminfo_release_p
call|)
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Close open files and release open-file table. 	 * This may block! 	 */
name|fdfree
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* 	 * If this thread tickled GEOM, we need to wait for the giggling to 	 * stop before we return to userland 	 */
if|if
condition|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_GEOM
condition|)
name|g_waitidle
argument_list|()
expr_stmt|;
comment|/* 	 * Remove ourself from our leader's peer list and wake our leader. 	 */
name|mtx_lock
argument_list|(
operator|&
name|ppeers_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_leader
operator|->
name|p_peers
condition|)
block|{
name|q
operator|=
name|p
operator|->
name|p_leader
expr_stmt|;
while|while
condition|(
name|q
operator|->
name|p_peers
operator|!=
name|p
condition|)
name|q
operator|=
name|q
operator|->
name|p_peers
expr_stmt|;
name|q
operator|->
name|p_peers
operator|=
name|p
operator|->
name|p_peers
expr_stmt|;
name|wakeup
argument_list|(
name|p
operator|->
name|p_leader
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ppeers_lock
argument_list|)
expr_stmt|;
name|vmspace_exit
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/* XXX TTY */
name|sx_xlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|SESS_LEADER
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|struct
name|session
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|p
operator|->
name|p_session
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_ttyvp
condition|)
block|{
comment|/* 			 * Controlling process. 			 * Signal foreground pgrp, 			 * drain controlling terminal 			 * and revoke access to controlling terminal. 			 */
if|if
condition|(
name|sp
operator|->
name|s_ttyp
operator|&&
operator|(
name|sp
operator|->
name|s_ttyp
operator|->
name|t_session
operator|==
name|sp
operator|)
condition|)
block|{
name|tp
operator|=
name|sp
operator|->
name|s_ttyp
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|s_ttyp
operator|->
name|t_pgrp
condition|)
block|{
name|PGRP_LOCK
argument_list|(
name|sp
operator|->
name|s_ttyp
operator|->
name|t_pgrp
argument_list|)
expr_stmt|;
name|pgsignal
argument_list|(
name|sp
operator|->
name|s_ttyp
operator|->
name|t_pgrp
argument_list|,
name|SIGHUP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PGRP_UNLOCK
argument_list|(
name|sp
operator|->
name|s_ttyp
operator|->
name|t_pgrp
argument_list|)
expr_stmt|;
block|}
comment|/* XXX tp should be locked. */
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ttywait
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
comment|/* 				 * The tty could have been revoked 				 * if we blocked. 				 */
if|if
condition|(
name|sp
operator|->
name|s_ttyvp
condition|)
block|{
name|ttyvp
operator|=
name|sp
operator|->
name|s_ttyvp
expr_stmt|;
name|SESS_LOCK
argument_list|(
name|p
operator|->
name|p_session
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_ttyvp
operator|=
name|NULL
expr_stmt|;
name|SESS_UNLOCK
argument_list|(
name|p
operator|->
name|p_session
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|VOP_LOCK
argument_list|(
name|ttyvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VOP_REVOKE
argument_list|(
name|ttyvp
argument_list|,
name|REVOKEALL
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ttyvp
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sp
operator|->
name|s_ttyvp
condition|)
block|{
name|ttyvp
operator|=
name|sp
operator|->
name|s_ttyvp
expr_stmt|;
name|SESS_LOCK
argument_list|(
name|p
operator|->
name|p_session
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_ttyvp
operator|=
name|NULL
expr_stmt|;
name|SESS_UNLOCK
argument_list|(
name|p
operator|->
name|p_session
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|ttyvp
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * s_ttyp is not zero'd; we use this to indicate 			 * that the session once had a controlling terminal. 			 * (for logging and informational purposes) 			 */
block|}
name|SESS_LOCK
argument_list|(
name|p
operator|->
name|p_session
argument_list|)
expr_stmt|;
name|sp
operator|->
name|s_leader
operator|=
name|NULL
expr_stmt|;
name|SESS_UNLOCK
argument_list|(
name|p
operator|->
name|p_session
argument_list|)
expr_stmt|;
block|}
name|fixjobc
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|p_pgrp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|acct_process
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
comment|/* 	 * Drain any pending records on the thread and release the trace 	 * file.  It might be better if drain-and-clear were atomic. 	 */
name|ktrprocexit
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ktrace_mtx
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_traceflag
operator|=
literal|0
expr_stmt|;
comment|/* don't trace the vrele() */
name|tracevp
operator|=
name|p
operator|->
name|p_tracevp
expr_stmt|;
name|p
operator|->
name|p_tracevp
operator|=
name|NULL
expr_stmt|;
name|tracecred
operator|=
name|p
operator|->
name|p_tracecred
expr_stmt|;
name|p
operator|->
name|p_tracecred
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ktrace_mtx
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracevp
operator|!=
name|NULL
condition|)
block|{
name|locked
operator|=
name|VFS_LOCK_GIANT
argument_list|(
name|tracevp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|tracevp
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|locked
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tracecred
operator|!=
name|NULL
condition|)
name|crfree
argument_list|(
name|tracecred
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Release reference to text vnode 	 */
if|if
condition|(
operator|(
name|vtmp
operator|=
name|p
operator|->
name|p_textvp
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|->
name|p_textvp
operator|=
name|NULL
expr_stmt|;
name|locked
operator|=
name|VFS_LOCK_GIANT
argument_list|(
name|vtmp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|vtmp
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|locked
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Release our limits structure. 	 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|plim
operator|=
name|p
operator|->
name|p_limit
expr_stmt|;
name|p
operator|->
name|p_limit
operator|=
name|NULL
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|lim_free
argument_list|(
name|plim
argument_list|)
expr_stmt|;
comment|/* 	 * Remove proc from allproc queue and pidhash chain. 	 * Place onto zombproc.  Unlink from parent's child list. 	 */
name|sx_xlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|p
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|zombproc
argument_list|,
name|p
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|p
argument_list|,
name|p_hash
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Reparent all of our children to init. 	 */
name|sx_xlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|q
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|p
operator|->
name|p_children
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|NULL
condition|)
comment|/* only need this if any child is S_ZOMB */
name|wakeup
argument_list|(
name|initproc
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|nq
control|)
block|{
name|nq
operator|=
name|LIST_NEXT
argument_list|(
name|q
argument_list|,
name|p_sibling
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|proc_reparent
argument_list|(
name|q
argument_list|,
name|initproc
argument_list|)
expr_stmt|;
name|q
operator|->
name|p_sigparent
operator|=
name|SIGCHLD
expr_stmt|;
comment|/* 		 * Traced processes are killed 		 * since their existence means someone is screwing up. 		 */
if|if
condition|(
name|q
operator|->
name|p_flag
operator|&
name|P_TRACED
condition|)
block|{
name|q
operator|->
name|p_flag
operator|&=
operator|~
operator|(
name|P_TRACED
operator||
name|P_STOPPED_TRACE
operator|)
expr_stmt|;
name|psignal
argument_list|(
name|q
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Save exit status and finalize rusage info except for times, 	 * adding in child rusage info later when our time is locked. 	 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_xstat
operator|=
name|rv
expr_stmt|;
name|p
operator|->
name|p_xthread
operator|=
name|td
expr_stmt|;
name|p
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_nvcsw
operator|++
expr_stmt|;
operator|*
name|p
operator|->
name|p_ru
operator|=
name|p
operator|->
name|p_stats
operator|->
name|p_ru
expr_stmt|;
comment|/* 	 * Notify interested parties of our demise. 	 */
name|KNOTE_LOCKED
argument_list|(
operator|&
name|p
operator|->
name|p_klist
argument_list|,
name|NOTE_EXIT
argument_list|)
expr_stmt|;
comment|/* 	 * Just delete all entries in the p_klist. At this point we won't 	 * report any more events, and there are nasty race conditions that 	 * can beat us if we don't. 	 */
name|knlist_clear
argument_list|(
operator|&
name|p
operator|->
name|p_klist
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Notify parent that we're gone.  If parent has the PS_NOCLDWAIT 	 * flag set, or if the handler is set to SIG_IGN, notify process 	 * 1 instead (and hope it will handle this situation). 	 */
name|PROC_LOCK
argument_list|(
name|p
operator|->
name|p_pptr
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|p
operator|->
name|p_pptr
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_pptr
operator|->
name|p_sigacts
operator|->
name|ps_flag
operator|&
operator|(
name|PS_NOCLDWAIT
operator||
name|PS_CLDSIGIGN
operator|)
condition|)
block|{
name|struct
name|proc
modifier|*
name|pp
decl_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|p
operator|->
name|p_pptr
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
name|pp
operator|=
name|p
operator|->
name|p_pptr
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|proc_reparent
argument_list|(
name|p
argument_list|,
name|initproc
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_sigparent
operator|=
name|SIGCHLD
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
operator|->
name|p_pptr
argument_list|)
expr_stmt|;
comment|/* 		 * If this was the last child of our parent, notify 		 * parent, so in case he was wait(2)ing, he will 		 * continue. 		 */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|pp
operator|->
name|p_children
argument_list|)
condition|)
name|wakeup
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|p
operator|->
name|p_pptr
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_pptr
operator|==
name|initproc
condition|)
name|psignal
argument_list|(
name|p
operator|->
name|p_pptr
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|p_sigparent
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_sigparent
operator|==
name|SIGCHLD
condition|)
name|childproc_exited
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
comment|/* LINUX thread */
name|psignal
argument_list|(
name|p
operator|->
name|p_pptr
argument_list|,
name|p
operator|->
name|p_sigparent
argument_list|)
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
operator|->
name|p_pptr
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * Finally, call machine-dependent code to release the remaining 	 * resources including address space. 	 * The address space is released by "vmspace_exitfree(p)" in 	 * vm_waitproc(). 	 */
name|cpu_exit
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|WITNESS_WARN
argument_list|(
name|WARN_PANIC
argument_list|,
operator|&
name|proctree_lock
operator|.
name|lock_object
argument_list|,
literal|"process (pid %d) exiting"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
operator|->
name|p_pptr
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
comment|/* 	 * The state PRS_ZOMBIE prevents other proesses from sending 	 * signal to the process, to avoid memory leak, we free memory 	 * for signal queue at the time when the state is set. 	 */
name|sigqueue_flush
argument_list|(
operator|&
name|p
operator|->
name|p_sigqueue
argument_list|)
expr_stmt|;
name|sigqueue_flush
argument_list|(
operator|&
name|td
operator|->
name|td_sigqueue
argument_list|)
expr_stmt|;
comment|/* 	 * We have to wait until after acquiring all locks before 	 * changing p_state.  We need to avoid all possible context 	 * switches (including ones from blocking on a mutex) while 	 * marked as a zombie.  We also have to set the zombie state 	 * before we release the parent process' proc lock to avoid 	 * a lost wakeup.  So, we first call wakeup, then we grab the 	 * sched lock, update the state, and release the parent process' 	 * proc lock. 	 */
name|wakeup
argument_list|(
name|p
operator|->
name|p_pptr
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_state
operator|=
name|PRS_ZOMBIE
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
operator|->
name|p_pptr
argument_list|)
expr_stmt|;
name|sched_exit
argument_list|(
name|p
operator|->
name|p_pptr
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* 	 * Hopefully no one will try to deliver a signal to the process this 	 * late in the game. 	 */
name|knlist_destroy
argument_list|(
operator|&
name|p
operator|->
name|p_klist
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the scheduler takes this thread out of its tables etc. 	 * This will also release this thread's reference to the ucred. 	 * Other thread parts to release include pcb bits and such. 	 */
name|thread_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|abort2_args
block|{
name|char
modifier|*
name|why
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|void
modifier|*
modifier|*
name|args
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|abort2
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|abort2_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|void
modifier|*
name|uargs
index|[
literal|16
index|]
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|sig
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* satisfy compiler */
comment|/* 	 * Do it right now so we can log either proper call of abort2(), or 	 * note, that invalid argument was passed. 512 is big enough to 	 * handle 16 arguments' descriptions with additional comments. 	 */
name|sb
operator|=
name|sbuf_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|512
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|sbuf_clear
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s(pid %d uid %d) aborted: "
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_ucred
operator|->
name|cr_uid
argument_list|)
expr_stmt|;
comment|/*  	 * Since we can't return from abort2(), send SIGKILL in cases, where 	 * abort2() was called improperly 	 */
name|sig
operator|=
name|SIGKILL
expr_stmt|;
comment|/* Prevent from DoSes from user-space. */
if|if
condition|(
name|uap
operator|->
name|nargs
operator|<
literal|0
operator|||
name|uap
operator|->
name|nargs
operator|>
literal|16
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|uap
operator|->
name|args
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|args
argument_list|,
name|uargs
argument_list|,
name|uap
operator|->
name|nargs
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Limit size of 'reason' string to 128. Will fit even when 	 * maximal number of arguments was chosen to be logged. 	 */
if|if
condition|(
name|uap
operator|->
name|why
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|sbuf_copyin
argument_list|(
name|sb
argument_list|,
name|uap
operator|->
name|why
argument_list|,
literal|128
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"(null)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uap
operator|->
name|nargs
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uap
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s%p"
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|""
else|:
literal|", "
argument_list|,
name|uargs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Final stage: arguments were proper, string has been 	 * successfully copied from userspace, and copying pointers 	 * from user-space succeed. 	 */
name|sig
operator|=
name|SIGABRT
expr_stmt|;
name|out
label|:
if|if
condition|(
name|sig
operator|==
name|SIGKILL
condition|)
block|{
name|sbuf_trim
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|" (Reason text inaccessible)"
argument_list|)
expr_stmt|;
block|}
name|sbuf_cat
argument_list|(
name|sb
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s"
argument_list|,
name|sbuf_data
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|exit1
argument_list|(
name|td
argument_list|,
name|W_EXITCODE
argument_list|(
literal|0
argument_list|,
name|sig
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_43
end_ifdef

begin_comment
comment|/*  * The dirty work is handled by kern_wait().  */
end_comment

begin_function
name|int
name|owait
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|owait_args
modifier|*
name|uap
name|__unused
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|status
decl_stmt|;
name|error
operator|=
name|kern_wait
argument_list|(
name|td
argument_list|,
name|WAIT_ANY
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
name|status
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPAT_43 */
end_comment

begin_comment
comment|/*  * The dirty work is handled by kern_wait().  */
end_comment

begin_function
name|int
name|wait4
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|wait_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|rusage
name|ru
decl_stmt|,
modifier|*
name|rup
decl_stmt|;
name|int
name|error
decl_stmt|,
name|status
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|rusage
operator|!=
name|NULL
condition|)
name|rup
operator|=
operator|&
name|ru
expr_stmt|;
else|else
name|rup
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|kern_wait
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|pid
argument_list|,
operator|&
name|status
argument_list|,
name|uap
operator|->
name|options
argument_list|,
name|rup
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|status
operator|!=
name|NULL
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|status
argument_list|,
name|uap
operator|->
name|status
argument_list|,
sizeof|sizeof
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|rusage
operator|!=
name|NULL
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|ru
argument_list|,
name|uap
operator|->
name|rusage
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rusage
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kern_wait
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|pid_t
name|pid
parameter_list|,
name|int
modifier|*
name|status
parameter_list|,
name|int
name|options
parameter_list|,
name|struct
name|rusage
modifier|*
name|rusage
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|error
decl_stmt|,
name|nfound
decl_stmt|;
name|AUDIT_ARG
argument_list|(
name|pid
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|q
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|pid
operator|=
operator|-
name|q
operator|->
name|p_pgid
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|options
operator|&
operator|~
operator|(
name|WUNTRACED
operator||
name|WNOHANG
operator||
name|WCONTINUED
operator||
name|WLINUXCLONE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|loop
label|:
if|if
condition|(
name|q
operator|->
name|p_flag
operator|&
name|P_STATCHILD
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|p_flag
operator|&=
operator|~
name|P_STATCHILD
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|nfound
operator|=
literal|0
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&q->p_children
argument_list|,
argument|p_sibling
argument_list|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|!=
name|WAIT_ANY
operator|&&
name|p
operator|->
name|p_pid
operator|!=
name|pid
operator|&&
name|p
operator|->
name|p_pgid
operator|!=
operator|-
name|pid
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|p_canwait
argument_list|(
name|td
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * This special case handles a kthread spawned by linux_clone 		 * (see linux_misc.c).  The linux_wait4 and linux_waitpid 		 * functions need to be able to distinguish between waiting 		 * on a process and waiting on a thread.  It is a thread if 		 * p_sigparent is not SIGCHLD, and the WLINUXCLONE option 		 * signifies we want to wait for threads and not processes. 		 */
if|if
condition|(
operator|(
name|p
operator|->
name|p_sigparent
operator|!=
name|SIGCHLD
operator|)
operator|^
operator|(
operator|(
name|options
operator|&
name|WLINUXCLONE
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nfound
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_state
operator|==
name|PRS_ZOMBIE
condition|)
block|{
comment|/* 			 * It is possible that the last thread of this 			 * process is still running on another CPU 			 * in thread_exit() after having dropped the process 			 * lock via PROC_UNLOCK() but before it has completed 			 * cpu_throw().  In that case, the other thread must 			 * still hold sched_lock, so simply by acquiring 			 * sched_lock once we will wait long enough for the 			 * thread to exit in that case. 			 */
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
if|if
condition|(
name|status
condition|)
operator|*
name|status
operator|=
name|p
operator|->
name|p_xstat
expr_stmt|;
comment|/* convert to int */
if|if
condition|(
name|rusage
condition|)
block|{
operator|*
name|rusage
operator|=
operator|*
name|p
operator|->
name|p_ru
expr_stmt|;
name|calcru
argument_list|(
name|p
argument_list|,
operator|&
name|rusage
operator|->
name|ru_utime
argument_list|,
operator|&
name|rusage
operator|->
name|ru_stime
argument_list|)
expr_stmt|;
block|}
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|sigqueue_take
argument_list|(
name|p
operator|->
name|p_ksi
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* 			 * If we got the child via a ptrace 'attach', 			 * we need to give it back to the old parent. 			 */
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_oppid
operator|&&
operator|(
name|t
operator|=
name|pfind
argument_list|(
name|p
operator|->
name|p_oppid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_oppid
operator|=
literal|0
expr_stmt|;
name|proc_reparent
argument_list|(
name|p
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|tdsignal
argument_list|(
name|t
argument_list|,
name|NULL
argument_list|,
name|SIGCHLD
argument_list|,
name|p
operator|->
name|p_ksi
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 			 * Remove other references to this process to ensure 			 * we have an exclusive reference. 			 */
name|sx_xlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|p
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
comment|/* off zombproc */
name|sx_xunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|p
argument_list|,
name|p_sibling
argument_list|)
expr_stmt|;
name|leavepgrp
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
comment|/* 			 * As a side effect of this lock, we know that 			 * all other writes to this proc are visible now, so 			 * no more locking is needed for p. 			 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_xstat
operator|=
literal|0
expr_stmt|;
comment|/* XXX: why? */
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|ruadd
argument_list|(
operator|&
name|q
operator|->
name|p_stats
operator|->
name|p_cru
argument_list|,
operator|&
name|q
operator|->
name|p_crux
argument_list|,
name|p
operator|->
name|p_ru
argument_list|,
operator|&
name|p
operator|->
name|p_rux
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|p
operator|->
name|p_ru
argument_list|,
name|M_ZOMBIE
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_ru
operator|=
name|NULL
expr_stmt|;
comment|/* 			 * Decrement the count of procs running with this uid. 			 */
operator|(
name|void
operator|)
name|chgproccnt
argument_list|(
name|p
operator|->
name|p_ucred
operator|->
name|cr_ruidinfo
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * Free credentials, arguments, and sigacts. 			 */
name|crfree
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_ucred
operator|=
name|NULL
expr_stmt|;
name|pargs_drop
argument_list|(
name|p
operator|->
name|p_args
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_args
operator|=
name|NULL
expr_stmt|;
name|sigacts_free
argument_list|(
name|p
operator|->
name|p_sigacts
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_sigacts
operator|=
name|NULL
expr_stmt|;
comment|/* 			 * Do any thread-system specific cleanups. 			 */
name|thread_wait
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 			 * Give vm and machine-dependent layer a chance 			 * to free anything that cpu_exit couldn't 			 * release while still running in process context. 			 */
name|vm_waitproc
argument_list|(
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_destroy_proc
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|AUDIT
name|audit_proc_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|FIRST_THREAD_IN_PROC
argument_list|(
name|p
argument_list|)
argument_list|,
operator|(
literal|"kern_wait: no residual thread!"
operator|)
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|proc_zone
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|nprocs
operator|--
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_STOPPED_SIG
operator|)
operator|&&
operator|(
name|p
operator|->
name|p_suspcount
operator|==
name|p
operator|->
name|p_numthreads
operator|)
operator|&&
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_WAITED
operator|)
operator|==
literal|0
operator|&&
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_TRACED
operator|||
name|options
operator|&
name|WUNTRACED
operator|)
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|P_WAITED
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
if|if
condition|(
name|status
condition|)
operator|*
name|status
operator|=
name|W_STOPCODE
argument_list|(
name|p
operator|->
name|p_xstat
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|sigqueue_take
argument_list|(
name|p
operator|->
name|p_ksi
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|WCONTINUED
operator|&&
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_CONTINUED
operator|)
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_CONTINUED
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|sigqueue_take
argument_list|(
name|p
operator|->
name|p_ksi
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
operator|*
name|status
operator|=
name|SIGCONT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nfound
operator|==
literal|0
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ECHILD
operator|)
return|;
block|}
if|if
condition|(
name|options
operator|&
name|WNOHANG
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|p_flag
operator|&
name|P_STATCHILD
condition|)
block|{
name|q
operator|->
name|p_flag
operator|&=
operator|~
name|P_STATCHILD
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|error
operator|=
name|msleep
argument_list|(
name|q
argument_list|,
operator|&
name|q
operator|->
name|p_mtx
argument_list|,
name|PWAIT
operator||
name|PCATCH
argument_list|,
literal|"wait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
goto|goto
name|loop
goto|;
block|}
end_function

begin_comment
comment|/*  * Make process 'parent' the new parent of process 'child'.  * Must be called with an exclusive hold of proctree lock.  */
end_comment

begin_function
name|void
name|proc_reparent
parameter_list|(
name|struct
name|proc
modifier|*
name|child
parameter_list|,
name|struct
name|proc
modifier|*
name|parent
parameter_list|)
block|{
name|sx_assert
argument_list|(
operator|&
name|proctree_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|child
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|p_pptr
operator|==
name|parent
condition|)
return|return;
name|PROC_LOCK
argument_list|(
name|child
operator|->
name|p_pptr
argument_list|)
expr_stmt|;
name|sigqueue_take
argument_list|(
name|child
operator|->
name|p_ksi
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|child
operator|->
name|p_pptr
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|child
argument_list|,
name|p_sibling
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|parent
operator|->
name|p_children
argument_list|,
name|child
argument_list|,
name|p_sibling
argument_list|)
expr_stmt|;
name|child
operator|->
name|p_pptr
operator|=
name|parent
expr_stmt|;
block|}
end_function

end_unit

