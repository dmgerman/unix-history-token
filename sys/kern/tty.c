begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Ed Schouten<ed@FreeBSD.org>  * All rights reserved.  *  * Portions of this software were developed under sponsorship from Snow  * B.V., the Netherlands.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_capsicum.h"
end_include

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/capsicum.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_43TTY
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl_compat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPAT_43TTY */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/serial.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/ttycom.h>
end_include

begin_define
define|#
directive|define
name|TTYDEFCHARS
end_define

begin_include
include|#
directive|include
file|<sys/ttydefaults.h>
end_include

begin_undef
undef|#
directive|undef
name|TTYDEFCHARS
end_undef

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_TTY
argument_list|,
literal|"tty"
argument_list|,
literal|"tty device"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|tty_rel_free
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|tty
argument_list|)
name|tty_list
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|tty_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|sx
name|tty_list_sx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SX_SYSINIT
argument_list|(
name|tty_list
argument_list|,
operator|&
name|tty_list_sx
argument_list|,
literal|"tty list"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|tty_list_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Character device of /dev/console. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdev
modifier|*
name|dev_console
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|dev_console_filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Flags that are supported and stored by this implementation.  */
end_comment

begin_define
define|#
directive|define
name|TTYSUP_IFLAG
value|(IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK|ISTRIP|\ 			INLCR|IGNCR|ICRNL|IXON|IXOFF|IXANY|IMAXBEL)
end_define

begin_define
define|#
directive|define
name|TTYSUP_OFLAG
value|(OPOST|ONLCR|TAB3|ONOEOT|OCRNL|ONOCR|ONLRET)
end_define

begin_define
define|#
directive|define
name|TTYSUP_LFLAG
value|(ECHOKE|ECHOE|ECHOK|ECHO|ECHONL|ECHOPRT|\ 			ECHOCTL|ISIG|ICANON|ALTWERASE|IEXTEN|TOSTOP|\ 			FLUSHO|NOKERNINFO|NOFLSH)
end_define

begin_define
define|#
directive|define
name|TTYSUP_CFLAG
value|(CIGNORE|CSIZE|CSTOPB|CREAD|PARENB|PARODD|\ 			HUPCL|CLOCAL|CCTS_OFLOW|CRTS_IFLOW|CDTR_IFLOW|\ 			CDSR_OFLOW|CCAR_OFLOW)
end_define

begin_define
define|#
directive|define
name|TTY_CALLOUT
parameter_list|(
name|tp
parameter_list|,
name|d
parameter_list|)
value|(dev2unit(d)& TTYUNIT_CALLOUT)
end_define

begin_decl_stmt
specifier|static
name|int
name|tty_drainwait
init|=
literal|5
operator|*
literal|60
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|tty_drainwait
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|tty_drainwait
argument_list|,
literal|0
argument_list|,
literal|"Default output drain timeout in seconds"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Set TTY buffer sizes.  */
end_comment

begin_define
define|#
directive|define
name|TTYBUF_MAX
value|65536
end_define

begin_comment
comment|/*  * Allocate buffer space if necessary, and set low watermarks, based on speed.  * Note that the ttyxxxq_setsize() functions may drop and then reacquire the tty  * lock during memory allocation.  They will return ENXIO if the tty disappears  * while unlocked.  */
end_comment

begin_function
specifier|static
name|int
name|tty_watermarks
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|size_t
name|bs
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Provide an input buffer for 2 seconds of data. */
if|if
condition|(
name|tp
operator|->
name|t_termios
operator|.
name|c_cflag
operator|&
name|CREAD
condition|)
name|bs
operator|=
name|MIN
argument_list|(
name|tp
operator|->
name|t_termios
operator|.
name|c_ispeed
operator|/
literal|5
argument_list|,
name|TTYBUF_MAX
argument_list|)
expr_stmt|;
name|error
operator|=
name|ttyinq_setsize
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|,
name|tp
argument_list|,
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Set low watermark at 10% (when 90% is available). */
name|tp
operator|->
name|t_inlow
operator|=
operator|(
name|ttyinq_getallocatedsize
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|)
operator|*
literal|9
operator|)
operator|/
literal|10
expr_stmt|;
comment|/* Provide an output buffer for 2 seconds of data. */
name|bs
operator|=
name|MIN
argument_list|(
name|tp
operator|->
name|t_termios
operator|.
name|c_ospeed
operator|/
literal|5
argument_list|,
name|TTYBUF_MAX
argument_list|)
expr_stmt|;
name|error
operator|=
name|ttyoutq_setsize
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|tp
argument_list|,
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Set low watermark at 10% (when 90% is available). */
name|tp
operator|->
name|t_outlow
operator|=
operator|(
name|ttyoutq_getallocatedsize
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
operator|*
literal|9
operator|)
operator|/
literal|10
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tty_drain
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|leaving
parameter_list|)
block|{
name|sbintime_t
name|timeout_at
decl_stmt|;
name|size_t
name|bytes
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|ttyhook_hashook
argument_list|(
name|tp
argument_list|,
name|getc_inject
argument_list|)
condition|)
comment|/* buffer is inaccessible */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * For close(), use the recent historic timeout of "1 second without 	 * making progress".  For tcdrain(), use t_drainwait as the timeout, 	 * with zero meaning "no timeout" which gives POSIX behavior. 	 */
if|if
condition|(
name|leaving
condition|)
name|timeout_at
operator|=
name|getsbinuptime
argument_list|()
operator|+
name|SBT_1S
expr_stmt|;
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_drainwait
operator|!=
literal|0
condition|)
name|timeout_at
operator|=
name|getsbinuptime
argument_list|()
operator|+
name|SBT_1S
operator|*
name|tp
operator|->
name|t_drainwait
expr_stmt|;
else|else
name|timeout_at
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Poll the output buffer and the hardware for completion, at 10 Hz. 	 * Polling is required for devices which are not able to signal an 	 * interrupt when the transmitter becomes idle (most USB serial devs). 	 * The unusual structure of this loop ensures we check for busy one more 	 * time after tty_timedwait() returns EWOULDBLOCK, so that success has 	 * higher priority than timeout if the IO completed in the last 100mS. 	 */
name|error
operator|=
literal|0
expr_stmt|;
name|bytes
operator|=
name|ttyoutq_bytesused
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ttyoutq_bytesused
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|ttydevsw_busy
argument_list|(
name|tp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ttydevsw_outwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|error
operator|=
name|tty_timedwait
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_outwait
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|EWOULDBLOCK
condition|)
return|return
operator|(
name|error
operator|)
return|;
elseif|else
if|if
condition|(
name|timeout_at
operator|==
literal|0
operator|||
name|getsbinuptime
argument_list|()
operator|<
name|timeout_at
condition|)
name|error
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|leaving
operator|&&
name|ttyoutq_bytesused
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
operator|<
name|bytes
condition|)
block|{
comment|/* In close, making progress, grant an extra second. */
name|error
operator|=
literal|0
expr_stmt|;
name|timeout_at
operator|+=
name|SBT_1S
expr_stmt|;
name|bytes
operator|=
name|ttyoutq_bytesused
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Though ttydev_enter() and ttydev_leave() seem to be related, they  * don't have to be used together. ttydev_enter() is used by the cdev  * operations to prevent an actual operation from being processed when  * the TTY has been abandoned. ttydev_leave() is used by ttydev_open()  * and ttydev_close() to determine whether per-TTY data should be  * deallocated.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|ttydev_enter
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_gone
argument_list|(
name|tp
argument_list|)
operator|||
operator|!
name|tty_opened
argument_list|(
name|tp
argument_list|)
condition|)
block|{
comment|/* Device is already gone. */
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ttydev_leave
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_opened
argument_list|(
name|tp
argument_list|)
operator|||
name|tp
operator|->
name|t_flags
operator|&
name|TF_OPENCLOSE
condition|)
block|{
comment|/* Device is still opened somewhere. */
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return;
block|}
name|tp
operator|->
name|t_flags
operator||=
name|TF_OPENCLOSE
expr_stmt|;
comment|/* Stop asynchronous I/O. */
name|funsetown
argument_list|(
operator|&
name|tp
operator|->
name|t_sigio
argument_list|)
expr_stmt|;
comment|/* Remove console TTY. */
if|if
condition|(
name|constty
operator|==
name|tp
condition|)
name|constty_clear
argument_list|()
expr_stmt|;
comment|/* Drain any output. */
if|if
condition|(
operator|!
name|tty_gone
argument_list|(
name|tp
argument_list|)
condition|)
name|tty_drain
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ttydisc_close
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* Free i/o queues now since they might be large. */
name|ttyinq_free
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_inlow
operator|=
literal|0
expr_stmt|;
name|ttyoutq_free
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_outlow
operator|=
literal|0
expr_stmt|;
name|knlist_clear
argument_list|(
operator|&
name|tp
operator|->
name|t_inpoll
operator|.
name|si_note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|knlist_clear
argument_list|(
operator|&
name|tp
operator|->
name|t_outpoll
operator|.
name|si_note
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tty_gone
argument_list|(
name|tp
argument_list|)
condition|)
name|ttydevsw_close
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_OPENCLOSE
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tp
operator|->
name|t_dcdwait
argument_list|)
expr_stmt|;
name|tty_rel_free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Operations that are exposed through the character device in /dev.  */
end_comment

begin_function
specifier|static
name|int
name|ttydev_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
name|__unused
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|tp
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_gone
argument_list|(
name|tp
argument_list|)
condition|)
block|{
comment|/* Device is already gone. */
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Block when other processes are currently opening or closing 	 * the TTY. 	 */
while|while
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_OPENCLOSE
condition|)
block|{
name|error
operator|=
name|tty_wait
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_dcdwait
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|tp
operator|->
name|t_flags
operator||=
name|TF_OPENCLOSE
expr_stmt|;
comment|/* 	 * Make sure the "tty" and "cua" device cannot be opened at the 	 * same time.  The console is a "tty" device. 	 */
if|if
condition|(
name|TTY_CALLOUT
argument_list|(
name|tp
argument_list|,
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|TF_OPENED_CONS
operator||
name|TF_OPENED_IN
operator|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_OPENED_OUT
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_EXCLUDE
operator|&&
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_TTY_EXCLUSIVE
argument_list|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|!
name|tty_opened
argument_list|(
name|tp
argument_list|)
condition|)
block|{
comment|/* Set proper termios flags. */
if|if
condition|(
name|TTY_CALLOUT
argument_list|(
name|tp
argument_list|,
name|dev
argument_list|)
condition|)
name|tp
operator|->
name|t_termios
operator|=
name|tp
operator|->
name|t_termios_init_out
expr_stmt|;
else|else
name|tp
operator|->
name|t_termios
operator|=
name|tp
operator|->
name|t_termios_init_in
expr_stmt|;
name|ttydevsw_param
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
comment|/* Prevent modem control on callout devices and /dev/console. */
if|if
condition|(
name|TTY_CALLOUT
argument_list|(
name|tp
argument_list|,
name|dev
argument_list|)
operator|||
name|dev
operator|==
name|dev_console
condition|)
name|tp
operator|->
name|t_termios
operator|.
name|c_cflag
operator||=
name|CLOCAL
expr_stmt|;
name|ttydevsw_modem
argument_list|(
name|tp
argument_list|,
name|SER_DTR
operator||
name|SER_RTS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|ttydevsw_open
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|ttydisc_open
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|error
operator|=
name|tty_watermarks
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* Wait for Carrier Detect. */
if|if
condition|(
operator|(
name|oflags
operator|&
name|O_NONBLOCK
operator|)
operator|==
literal|0
operator|&&
operator|(
name|tp
operator|->
name|t_termios
operator|.
name|c_cflag
operator|&
name|CLOCAL
operator|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|ttydevsw_modem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|&
name|SER_DCD
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|tty_wait
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_dcdwait
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|dev
operator|==
name|dev_console
condition|)
name|tp
operator|->
name|t_flags
operator||=
name|TF_OPENED_CONS
expr_stmt|;
elseif|else
if|if
condition|(
name|TTY_CALLOUT
argument_list|(
name|tp
argument_list|,
name|dev
argument_list|)
condition|)
name|tp
operator|->
name|t_flags
operator||=
name|TF_OPENED_OUT
expr_stmt|;
else|else
name|tp
operator|->
name|t_flags
operator||=
name|TF_OPENED_IN
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|TF_OPENED_CONS
operator||
name|TF_OPENED_IN
operator|)
operator|)
operator|==
literal|0
operator|||
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_OPENED_OUT
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|done
label|:
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_OPENCLOSE
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tp
operator|->
name|t_dcdwait
argument_list|)
expr_stmt|;
name|ttydev_leave
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttydev_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
name|__unused
parameter_list|,
name|struct
name|thread
modifier|*
name|td
name|__unused
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* 	 * Don't actually close the device if it is being used as the 	 * console. 	 */
name|MPASS
argument_list|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
operator|(
name|TF_OPENED_CONS
operator||
name|TF_OPENED_IN
operator|)
operator|)
operator|==
literal|0
operator|||
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_OPENED_OUT
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|dev_console
condition|)
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_OPENED_CONS
expr_stmt|;
else|else
name|tp
operator|->
name|t_flags
operator|&=
operator|~
operator|(
name|TF_OPENED_IN
operator||
name|TF_OPENED_OUT
operator|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_OPENED
condition|)
block|{
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* If revoking, flush output now to avoid draining it later. */
if|if
condition|(
name|fflag
operator|&
name|FREVOKE
condition|)
name|tty_flush
argument_list|(
name|tp
argument_list|,
name|FWRITE
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_EXCLUDE
expr_stmt|;
comment|/* Properly wake up threads that are stuck - revoke(). */
name|tp
operator|->
name|t_revokecnt
operator|++
expr_stmt|;
name|tty_wakeup
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tp
operator|->
name|t_bgwait
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tp
operator|->
name|t_dcdwait
argument_list|)
expr_stmt|;
name|ttydev_leave
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|tty_is_ctty
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|p_session
operator|==
name|tp
operator|->
name|t_session
operator|&&
name|p
operator|->
name|p_flag
operator|&
name|P_CONTROLT
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tty_wait_background
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|sig
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|pgrp
modifier|*
name|pg
decl_stmt|;
name|ksiginfo_t
name|ksi
decl_stmt|;
name|int
name|error
decl_stmt|;
name|MPASS
argument_list|(
name|sig
operator|==
name|SIGTTIN
operator|||
name|sig
operator|==
name|SIGTTOU
argument_list|)
expr_stmt|;
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 		 * The process should only sleep, when: 		 * - This terminal is the controlling terminal 		 * - Its process group is not the foreground process 		 *   group 		 * - The parent process isn't waiting for the child to 		 *   exit 		 * - the signal to send to the process isn't masked 		 */
if|if
condition|(
operator|!
name|tty_is_ctty
argument_list|(
name|tp
argument_list|,
name|p
argument_list|)
operator|||
name|p
operator|->
name|p_pgrp
operator|==
name|tp
operator|->
name|t_pgrp
condition|)
block|{
comment|/* Allow the action to happen. */
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|SIGISMEMBER
argument_list|(
name|p
operator|->
name|p_sigacts
operator|->
name|ps_sigignore
argument_list|,
name|sig
argument_list|)
operator|||
name|SIGISMEMBER
argument_list|(
name|td
operator|->
name|td_sigmask
argument_list|,
name|sig
argument_list|)
condition|)
block|{
comment|/* Only allow them in write()/ioctl(). */
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|sig
operator|==
name|SIGTTOU
condition|?
literal|0
else|:
name|EIO
operator|)
return|;
block|}
name|pg
operator|=
name|p
operator|->
name|p_pgrp
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_PPWAIT
operator|||
name|pg
operator|->
name|pg_jobc
operator|==
literal|0
condition|)
block|{
comment|/* Don't allow the action to happen. */
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 		 * Send the signal and sleep until we're the new 		 * foreground process group. 		 */
if|if
condition|(
name|sig
operator|!=
literal|0
condition|)
block|{
name|ksiginfo_init
argument_list|(
operator|&
name|ksi
argument_list|)
expr_stmt|;
name|ksi
operator|.
name|ksi_code
operator|=
name|SI_KERNEL
expr_stmt|;
name|ksi
operator|.
name|ksi_signo
operator|=
name|sig
expr_stmt|;
name|sig
operator|=
literal|0
expr_stmt|;
block|}
name|PGRP_LOCK
argument_list|(
name|pg
argument_list|)
expr_stmt|;
name|pgsignal
argument_list|(
name|pg
argument_list|,
name|ksi
operator|.
name|ksi_signo
argument_list|,
literal|1
argument_list|,
operator|&
name|ksi
argument_list|)
expr_stmt|;
name|PGRP_UNLOCK
argument_list|(
name|pg
argument_list|)
expr_stmt|;
name|error
operator|=
name|tty_wait
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_bgwait
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ttydev_read
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ttydev_enter
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|error
operator|=
name|ttydisc_read
argument_list|(
name|tp
argument_list|,
name|uio
argument_list|,
name|ioflag
argument_list|)
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* 	 * The read() call should not throw an error when the device is 	 * being destroyed. Silently convert it to an EOF. 	 */
name|done
label|:
if|if
condition|(
name|error
operator|==
name|ENXIO
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttydev_write
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ttydev_enter
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|tp
operator|->
name|t_termios
operator|.
name|c_lflag
operator|&
name|TOSTOP
condition|)
block|{
name|error
operator|=
name|tty_wait_background
argument_list|(
name|tp
argument_list|,
name|curthread
argument_list|,
name|SIGTTOU
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|ioflag
operator|&
name|IO_NDELAY
operator|&&
name|tp
operator|->
name|t_flags
operator|&
name|TF_BUSY_OUT
condition|)
block|{
comment|/* Allow non-blocking writes to bypass serialization. */
name|error
operator|=
name|ttydisc_write
argument_list|(
name|tp
argument_list|,
name|uio
argument_list|,
name|ioflag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Serialize write() calls. */
while|while
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_BUSY_OUT
condition|)
block|{
name|error
operator|=
name|tty_wait
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_outserwait
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
block|}
name|tp
operator|->
name|t_flags
operator||=
name|TF_BUSY_OUT
expr_stmt|;
name|error
operator|=
name|ttydisc_write
argument_list|(
name|tp
argument_list|,
name|uio
argument_list|,
name|ioflag
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_BUSY_OUT
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|tp
operator|->
name|t_outserwait
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttydev_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ttydev_enter
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCCBRK
case|:
case|case
name|TIOCCONS
case|:
case|case
name|TIOCDRAIN
case|:
case|case
name|TIOCEXCL
case|:
case|case
name|TIOCFLUSH
case|:
case|case
name|TIOCNXCL
case|:
case|case
name|TIOCSBRK
case|:
case|case
name|TIOCSCTTY
case|:
case|case
name|TIOCSETA
case|:
case|case
name|TIOCSETAF
case|:
case|case
name|TIOCSETAW
case|:
case|case
name|TIOCSPGRP
case|:
case|case
name|TIOCSTART
case|:
case|case
name|TIOCSTAT
case|:
case|case
name|TIOCSTI
case|:
case|case
name|TIOCSTOP
case|:
case|case
name|TIOCSWINSZ
case|:
if|#
directive|if
literal|0
block|case TIOCSDRAINWAIT: 	case TIOCSETD:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COMPAT_43TTY
case|case
name|TIOCLBIC
case|:
case|case
name|TIOCLBIS
case|:
case|case
name|TIOCLSET
case|:
case|case
name|TIOCSETC
case|:
case|case
name|OTIOCSETD
case|:
case|case
name|TIOCSETN
case|:
case|case
name|TIOCSETP
case|:
case|case
name|TIOCSLTC
case|:
endif|#
directive|endif
comment|/* COMPAT_43TTY */
comment|/* 		 * If the ioctl() causes the TTY to be modified, let it 		 * wait in the background. 		 */
name|error
operator|=
name|tty_wait_background
argument_list|(
name|tp
argument_list|,
name|curthread
argument_list|,
name|SIGTTOU
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|cmd
operator|==
name|TIOCSETA
operator|||
name|cmd
operator|==
name|TIOCSETAW
operator|||
name|cmd
operator|==
name|TIOCSETAF
condition|)
block|{
name|struct
name|termios
modifier|*
name|old
init|=
operator|&
name|tp
operator|->
name|t_termios
decl_stmt|;
name|struct
name|termios
modifier|*
name|new
init|=
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|termios
modifier|*
name|lock
init|=
name|TTY_CALLOUT
argument_list|(
name|tp
argument_list|,
name|dev
argument_list|)
condition|?
operator|&
name|tp
operator|->
name|t_termios_lock_out
else|:
operator|&
name|tp
operator|->
name|t_termios_lock_in
decl_stmt|;
name|int
name|cc
decl_stmt|;
comment|/* 		 * Lock state devices.  Just overwrite the values of the 		 * commands that are currently in use. 		 */
name|new
operator|->
name|c_iflag
operator|=
operator|(
name|old
operator|->
name|c_iflag
operator|&
name|lock
operator|->
name|c_iflag
operator|)
operator||
operator|(
name|new
operator|->
name|c_iflag
operator|&
operator|~
name|lock
operator|->
name|c_iflag
operator|)
expr_stmt|;
name|new
operator|->
name|c_oflag
operator|=
operator|(
name|old
operator|->
name|c_oflag
operator|&
name|lock
operator|->
name|c_oflag
operator|)
operator||
operator|(
name|new
operator|->
name|c_oflag
operator|&
operator|~
name|lock
operator|->
name|c_oflag
operator|)
expr_stmt|;
name|new
operator|->
name|c_cflag
operator|=
operator|(
name|old
operator|->
name|c_cflag
operator|&
name|lock
operator|->
name|c_cflag
operator|)
operator||
operator|(
name|new
operator|->
name|c_cflag
operator|&
operator|~
name|lock
operator|->
name|c_cflag
operator|)
expr_stmt|;
name|new
operator|->
name|c_lflag
operator|=
operator|(
name|old
operator|->
name|c_lflag
operator|&
name|lock
operator|->
name|c_lflag
operator|)
operator||
operator|(
name|new
operator|->
name|c_lflag
operator|&
operator|~
name|lock
operator|->
name|c_lflag
operator|)
expr_stmt|;
for|for
control|(
name|cc
operator|=
literal|0
init|;
name|cc
operator|<
name|NCCS
condition|;
operator|++
name|cc
control|)
if|if
condition|(
name|lock
operator|->
name|c_cc
index|[
name|cc
index|]
condition|)
name|new
operator|->
name|c_cc
index|[
name|cc
index|]
operator|=
name|old
operator|->
name|c_cc
index|[
name|cc
index|]
expr_stmt|;
if|if
condition|(
name|lock
operator|->
name|c_ispeed
condition|)
name|new
operator|->
name|c_ispeed
operator|=
name|old
operator|->
name|c_ispeed
expr_stmt|;
if|if
condition|(
name|lock
operator|->
name|c_ospeed
condition|)
name|new
operator|->
name|c_ospeed
operator|=
name|old
operator|->
name|c_ospeed
expr_stmt|;
block|}
name|error
operator|=
name|tty_ioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|fflag
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|done
label|:
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttydev_poll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|int
name|error
decl_stmt|,
name|revents
init|=
literal|0
decl_stmt|;
name|error
operator|=
name|ttydev_enter
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
operator|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
operator|)
operator||
name|POLLHUP
operator|)
return|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
comment|/* See if we can read something. */
if|if
condition|(
name|ttydisc_read_poll
argument_list|(
name|tp
argument_list|)
operator|>
literal|0
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_ZOMBIE
condition|)
block|{
comment|/* Hangup flag on zombie state. */
name|revents
operator||=
name|POLLHUP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
condition|)
block|{
comment|/* See if we can write something. */
if|if
condition|(
name|ttydisc_write_poll
argument_list|(
name|tp
argument_list|)
operator|>
literal|0
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|revents
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|tp
operator|->
name|t_inpoll
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
condition|)
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|tp
operator|->
name|t_outpoll
argument_list|)
expr_stmt|;
block|}
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttydev_mmap
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_paddr_t
modifier|*
name|paddr
parameter_list|,
name|int
name|nprot
parameter_list|,
name|vm_memattr_t
modifier|*
name|memattr
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Handle mmap() through the driver. */
name|error
operator|=
name|ttydev_enter
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|error
operator|=
name|ttydevsw_mmap
argument_list|(
name|tp
argument_list|,
name|offset
argument_list|,
name|paddr
argument_list|,
name|nprot
argument_list|,
name|memattr
argument_list|)
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * kqueue support.  */
end_comment

begin_function
specifier|static
name|void
name|tty_kqops_read_detach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|kn
operator|->
name|kn_hook
decl_stmt|;
name|knlist_remove
argument_list|(
operator|&
name|tp
operator|->
name|t_inpoll
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tty_kqops_read_event
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
name|__unused
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|kn
operator|->
name|kn_hook
decl_stmt|;
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_gone
argument_list|(
name|tp
argument_list|)
operator|||
name|tp
operator|->
name|t_flags
operator|&
name|TF_ZOMBIE
condition|)
block|{
name|kn
operator|->
name|kn_flags
operator||=
name|EV_EOF
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|kn
operator|->
name|kn_data
operator|=
name|ttydisc_read_poll
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|kn
operator|->
name|kn_data
operator|>
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|tty_kqops_write_detach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|kn
operator|->
name|kn_hook
decl_stmt|;
name|knlist_remove
argument_list|(
operator|&
name|tp
operator|->
name|t_outpoll
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tty_kqops_write_event
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
name|__unused
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|kn
operator|->
name|kn_hook
decl_stmt|;
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_gone
argument_list|(
name|tp
argument_list|)
condition|)
block|{
name|kn
operator|->
name|kn_flags
operator||=
name|EV_EOF
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|kn
operator|->
name|kn_data
operator|=
name|ttydisc_write_poll
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|kn
operator|->
name|kn_data
operator|>
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|tty_kqops_read
init|=
block|{
operator|.
name|f_isfd
operator|=
literal|1
block|,
operator|.
name|f_detach
operator|=
name|tty_kqops_read_detach
block|,
operator|.
name|f_event
operator|=
name|tty_kqops_read_event
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|tty_kqops_write
init|=
block|{
operator|.
name|f_isfd
operator|=
literal|1
block|,
operator|.
name|f_detach
operator|=
name|tty_kqops_write_detach
block|,
operator|.
name|f_event
operator|=
name|tty_kqops_write_event
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ttydev_kqfilter
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|ttydev_enter
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|kn
operator|->
name|kn_filter
condition|)
block|{
case|case
name|EVFILT_READ
case|:
name|kn
operator|->
name|kn_hook
operator|=
name|tp
expr_stmt|;
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|tty_kqops_read
expr_stmt|;
name|knlist_add
argument_list|(
operator|&
name|tp
operator|->
name|t_inpoll
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|EVFILT_WRITE
case|:
name|kn
operator|->
name|kn_hook
operator|=
name|tp
expr_stmt|;
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|tty_kqops_write
expr_stmt|;
name|knlist_add
argument_list|(
operator|&
name|tp
operator|->
name|t_outpoll
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ttydev_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|ttydev_open
block|,
operator|.
name|d_close
operator|=
name|ttydev_close
block|,
operator|.
name|d_read
operator|=
name|ttydev_read
block|,
operator|.
name|d_write
operator|=
name|ttydev_write
block|,
operator|.
name|d_ioctl
operator|=
name|ttydev_ioctl
block|,
operator|.
name|d_kqfilter
operator|=
name|ttydev_kqfilter
block|,
operator|.
name|d_poll
operator|=
name|ttydev_poll
block|,
operator|.
name|d_mmap
operator|=
name|ttydev_mmap
block|,
operator|.
name|d_name
operator|=
literal|"ttydev"
block|,
operator|.
name|d_flags
operator|=
name|D_TTY
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Init/lock-state devices  */
end_comment

begin_function
specifier|static
name|int
name|ttyil_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|oflags
name|__unused
parameter_list|,
name|int
name|devtype
name|__unused
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|tp
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_gone
argument_list|(
name|tp
argument_list|)
condition|)
name|error
operator|=
name|ENODEV
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttyil_close
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
name|__unused
parameter_list|,
name|int
name|flag
name|__unused
parameter_list|,
name|int
name|mode
name|__unused
parameter_list|,
name|struct
name|thread
modifier|*
name|td
name|__unused
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttyil_rdwr
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
name|__unused
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
name|__unused
parameter_list|,
name|int
name|ioflag
name|__unused
parameter_list|)
block|{
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttyil_ioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_gone
argument_list|(
name|tp
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENODEV
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|error
operator|=
name|ttydevsw_cioctl
argument_list|(
name|tp
argument_list|,
name|dev2unit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOIOCTL
condition|)
goto|goto
name|done
goto|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TIOCGETA
case|:
comment|/* Obtain terminal flags through tcgetattr(). */
operator|*
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
operator|=
operator|*
operator|(
expr|struct
name|termios
operator|*
operator|)
name|dev
operator|->
name|si_drv2
expr_stmt|;
break|break;
case|case
name|TIOCSETA
case|:
comment|/* Set terminal flags through tcsetattr(). */
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_TTY_SETA
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
operator|*
operator|(
expr|struct
name|termios
operator|*
operator|)
name|dev
operator|->
name|si_drv2
operator|=
operator|*
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
expr_stmt|;
break|break;
case|case
name|TIOCGETD
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|TTYDISC
expr_stmt|;
break|break;
case|case
name|TIOCGWINSZ
case|:
name|bzero
argument_list|(
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|winsize
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
block|}
name|done
label|:
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ttyil_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|ttyil_open
block|,
operator|.
name|d_close
operator|=
name|ttyil_close
block|,
operator|.
name|d_read
operator|=
name|ttyil_rdwr
block|,
operator|.
name|d_write
operator|=
name|ttyil_rdwr
block|,
operator|.
name|d_ioctl
operator|=
name|ttyil_ioctl
block|,
operator|.
name|d_name
operator|=
literal|"ttyil"
block|,
operator|.
name|d_flags
operator|=
name|D_TTY
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|tty_init_termios
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|termios
modifier|*
name|t
init|=
operator|&
name|tp
operator|->
name|t_termios_init_in
decl_stmt|;
name|t
operator|->
name|c_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|t
operator|->
name|c_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|t
operator|->
name|c_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|t
operator|->
name|c_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|t
operator|->
name|c_ispeed
operator|=
name|TTYDEF_SPEED
expr_stmt|;
name|t
operator|->
name|c_ospeed
operator|=
name|TTYDEF_SPEED
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|t
operator|->
name|c_cc
argument_list|,
name|ttydefchars
argument_list|,
sizeof|sizeof
name|ttydefchars
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_termios_init_out
operator|=
operator|*
name|t
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tty_init_console
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|speed_t
name|s
parameter_list|)
block|{
name|struct
name|termios
modifier|*
name|ti
init|=
operator|&
name|tp
operator|->
name|t_termios_init_in
decl_stmt|;
name|struct
name|termios
modifier|*
name|to
init|=
operator|&
name|tp
operator|->
name|t_termios_init_out
decl_stmt|;
if|if
condition|(
name|s
operator|!=
literal|0
condition|)
block|{
name|ti
operator|->
name|c_ispeed
operator|=
name|ti
operator|->
name|c_ospeed
operator|=
name|s
expr_stmt|;
name|to
operator|->
name|c_ispeed
operator|=
name|to
operator|->
name|c_ospeed
operator|=
name|s
expr_stmt|;
block|}
name|ti
operator|->
name|c_cflag
operator||=
name|CLOCAL
expr_stmt|;
name|to
operator|->
name|c_cflag
operator||=
name|CLOCAL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Standard device routine implementations, mostly meant for  * pseudo-terminal device drivers. When a driver creates a new terminal  * device class, missing routines are patched.  */
end_comment

begin_function
specifier|static
name|int
name|ttydevsw_defopen
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
name|__unused
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ttydevsw_defclose
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
name|__unused
parameter_list|)
block|{  }
end_function

begin_function
specifier|static
name|void
name|ttydevsw_defoutwakeup
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
name|__unused
parameter_list|)
block|{
name|panic
argument_list|(
literal|"Terminal device has output, while not implemented"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ttydevsw_definwakeup
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
name|__unused
parameter_list|)
block|{  }
end_function

begin_function
specifier|static
name|int
name|ttydevsw_defioctl
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
name|__unused
parameter_list|,
name|u_long
name|cmd
name|__unused
parameter_list|,
name|caddr_t
name|data
name|__unused
parameter_list|,
name|struct
name|thread
modifier|*
name|td
name|__unused
parameter_list|)
block|{
return|return
operator|(
name|ENOIOCTL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttydevsw_defcioctl
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
name|__unused
parameter_list|,
name|int
name|unit
name|__unused
parameter_list|,
name|u_long
name|cmd
name|__unused
parameter_list|,
name|caddr_t
name|data
name|__unused
parameter_list|,
name|struct
name|thread
modifier|*
name|td
name|__unused
parameter_list|)
block|{
return|return
operator|(
name|ENOIOCTL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttydevsw_defparam
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
name|__unused
parameter_list|,
name|struct
name|termios
modifier|*
name|t
parameter_list|)
block|{
comment|/* 	 * Allow the baud rate to be adjusted for pseudo-devices, but at 	 * least restrict it to 115200 to prevent excessive buffer 	 * usage.  Also disallow 0, to prevent foot shooting. 	 */
if|if
condition|(
name|t
operator|->
name|c_ispeed
operator|<
name|B50
condition|)
name|t
operator|->
name|c_ispeed
operator|=
name|B50
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|c_ispeed
operator|>
name|B115200
condition|)
name|t
operator|->
name|c_ispeed
operator|=
name|B115200
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|c_ospeed
operator|<
name|B50
condition|)
name|t
operator|->
name|c_ospeed
operator|=
name|B50
expr_stmt|;
elseif|else
if|if
condition|(
name|t
operator|->
name|c_ospeed
operator|>
name|B115200
condition|)
name|t
operator|->
name|c_ospeed
operator|=
name|B115200
expr_stmt|;
name|t
operator|->
name|c_cflag
operator||=
name|CREAD
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttydevsw_defmodem
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
name|__unused
parameter_list|,
name|int
name|sigon
name|__unused
parameter_list|,
name|int
name|sigoff
name|__unused
parameter_list|)
block|{
comment|/* Simulate a carrier to make the TTY layer happy. */
return|return
operator|(
name|SER_DCD
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttydevsw_defmmap
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
name|__unused
parameter_list|,
name|vm_ooffset_t
name|offset
name|__unused
parameter_list|,
name|vm_paddr_t
modifier|*
name|paddr
name|__unused
parameter_list|,
name|int
name|nprot
name|__unused
parameter_list|,
name|vm_memattr_t
modifier|*
name|memattr
name|__unused
parameter_list|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ttydevsw_defpktnotify
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
name|__unused
parameter_list|,
name|char
name|event
name|__unused
parameter_list|)
block|{  }
end_function

begin_function
specifier|static
name|void
name|ttydevsw_deffree
parameter_list|(
name|void
modifier|*
name|softc
name|__unused
parameter_list|)
block|{
name|panic
argument_list|(
literal|"Terminal device freed without a free-handler"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|ttydevsw_defbusy
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
name|__unused
parameter_list|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * TTY allocation and deallocation. TTY devices can be deallocated when  * the driver doesn't use it anymore, when the TTY isn't a session's  * controlling TTY and when the device node isn't opened through devfs.  */
end_comment

begin_function
name|struct
name|tty
modifier|*
name|tty_alloc
parameter_list|(
name|struct
name|ttydevsw
modifier|*
name|tsw
parameter_list|,
name|void
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
name|tty_alloc_mutex
argument_list|(
name|tsw
argument_list|,
name|sc
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|tty
modifier|*
name|tty_alloc_mutex
parameter_list|(
name|struct
name|ttydevsw
modifier|*
name|tsw
parameter_list|,
name|void
modifier|*
name|sc
parameter_list|,
name|struct
name|mtx
modifier|*
name|mutex
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
comment|/* Make sure the driver defines all routines. */
define|#
directive|define
name|PATCH_FUNC
parameter_list|(
name|x
parameter_list|)
value|do {				\ 	if (tsw->tsw_ ## x == NULL)			\ 		tsw->tsw_ ## x = ttydevsw_def ## x;	\ } while (0)
name|PATCH_FUNC
argument_list|(
name|open
argument_list|)
expr_stmt|;
name|PATCH_FUNC
argument_list|(
name|close
argument_list|)
expr_stmt|;
name|PATCH_FUNC
argument_list|(
name|outwakeup
argument_list|)
expr_stmt|;
name|PATCH_FUNC
argument_list|(
name|inwakeup
argument_list|)
expr_stmt|;
name|PATCH_FUNC
argument_list|(
name|ioctl
argument_list|)
expr_stmt|;
name|PATCH_FUNC
argument_list|(
name|cioctl
argument_list|)
expr_stmt|;
name|PATCH_FUNC
argument_list|(
name|param
argument_list|)
expr_stmt|;
name|PATCH_FUNC
argument_list|(
name|modem
argument_list|)
expr_stmt|;
name|PATCH_FUNC
argument_list|(
name|mmap
argument_list|)
expr_stmt|;
name|PATCH_FUNC
argument_list|(
name|pktnotify
argument_list|)
expr_stmt|;
name|PATCH_FUNC
argument_list|(
name|free
argument_list|)
expr_stmt|;
name|PATCH_FUNC
argument_list|(
name|busy
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|PATCH_FUNC
name|tp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tty
argument_list|)
argument_list|,
name|M_TTY
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_devsw
operator|=
name|tsw
expr_stmt|;
name|tp
operator|->
name|t_devswsoftc
operator|=
name|sc
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|=
name|tsw
operator|->
name|tsw_flags
expr_stmt|;
name|tp
operator|->
name|t_drainwait
operator|=
name|tty_drainwait
expr_stmt|;
name|tty_init_termios
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|tp
operator|->
name|t_inwait
argument_list|,
literal|"ttyin"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|tp
operator|->
name|t_outwait
argument_list|,
literal|"ttyout"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|tp
operator|->
name|t_outserwait
argument_list|,
literal|"ttyosr"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|tp
operator|->
name|t_bgwait
argument_list|,
literal|"ttybg"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|tp
operator|->
name|t_dcdwait
argument_list|,
literal|"ttydcd"
argument_list|)
expr_stmt|;
comment|/* Allow drivers to use a custom mutex to lock the TTY. */
if|if
condition|(
name|mutex
operator|!=
name|NULL
condition|)
block|{
name|tp
operator|->
name|t_mtx
operator|=
name|mutex
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|->
name|t_mtx
operator|=
operator|&
name|tp
operator|->
name|t_mtxobj
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|tp
operator|->
name|t_mtxobj
argument_list|,
literal|"ttymtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
name|knlist_init_mtx
argument_list|(
operator|&
name|tp
operator|->
name|t_inpoll
operator|.
name|si_note
argument_list|,
name|tp
operator|->
name|t_mtx
argument_list|)
expr_stmt|;
name|knlist_init_mtx
argument_list|(
operator|&
name|tp
operator|->
name|t_outpoll
operator|.
name|si_note
argument_list|,
name|tp
operator|->
name|t_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tty_dealloc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
init|=
name|arg
decl_stmt|;
comment|/* 	 * ttyydev_leave() usually frees the i/o queues earlier, but it is 	 * not always called between queue allocation and here.  The queues 	 * may be allocated by ioctls on a pty control device without the 	 * corresponding pty slave device ever being open, or after it is 	 * closed. 	 */
name|ttyinq_free
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|)
expr_stmt|;
name|ttyoutq_free
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|seldrain
argument_list|(
operator|&
name|tp
operator|->
name|t_inpoll
argument_list|)
expr_stmt|;
name|seldrain
argument_list|(
operator|&
name|tp
operator|->
name|t_outpoll
argument_list|)
expr_stmt|;
name|knlist_destroy
argument_list|(
operator|&
name|tp
operator|->
name|t_inpoll
operator|.
name|si_note
argument_list|)
expr_stmt|;
name|knlist_destroy
argument_list|(
operator|&
name|tp
operator|->
name|t_outpoll
operator|.
name|si_note
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|tp
operator|->
name|t_inwait
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|tp
operator|->
name|t_outwait
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|tp
operator|->
name|t_bgwait
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|tp
operator|->
name|t_dcdwait
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|tp
operator|->
name|t_outserwait
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_mtx
operator|==
operator|&
name|tp
operator|->
name|t_mtxobj
condition|)
name|mtx_destroy
argument_list|(
operator|&
name|tp
operator|->
name|t_mtxobj
argument_list|)
expr_stmt|;
name|ttydevsw_free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|,
name|M_TTY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tty_rel_free
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
define|#
directive|define
name|TF_ACTIVITY
value|(TF_GONE|TF_OPENED|TF_HOOK|TF_OPENCLOSE)
if|if
condition|(
name|tp
operator|->
name|t_sessioncnt
operator|!=
literal|0
operator|||
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_ACTIVITY
operator|)
operator|!=
name|TF_GONE
condition|)
block|{
comment|/* TTY is still in use. */
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* TTY can be deallocated. */
name|dev
operator|=
name|tp
operator|->
name|t_dev
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|NULL
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|!=
name|NULL
condition|)
block|{
name|sx_xlock
argument_list|(
operator|&
name|tty_list_sx
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|tty_list
argument_list|,
name|tp
argument_list|,
name|t_list
argument_list|)
expr_stmt|;
name|tty_list_count
operator|--
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|tty_list_sx
argument_list|)
expr_stmt|;
name|destroy_dev_sched_cb
argument_list|(
name|dev
argument_list|,
name|tty_dealloc
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|tty_rel_pgrp
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|pgrp
modifier|*
name|pg
parameter_list|)
block|{
name|MPASS
argument_list|(
name|tp
operator|->
name|t_sessioncnt
operator|>
literal|0
argument_list|)
expr_stmt|;
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_pgrp
operator|==
name|pg
condition|)
name|tp
operator|->
name|t_pgrp
operator|=
name|NULL
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tty_rel_sess
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|session
modifier|*
name|sess
parameter_list|)
block|{
name|MPASS
argument_list|(
name|tp
operator|->
name|t_sessioncnt
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* Current session has left. */
if|if
condition|(
name|tp
operator|->
name|t_session
operator|==
name|sess
condition|)
block|{
name|tp
operator|->
name|t_session
operator|=
name|NULL
expr_stmt|;
name|MPASS
argument_list|(
name|tp
operator|->
name|t_pgrp
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|t_sessioncnt
operator|--
expr_stmt|;
name|tty_rel_free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tty_rel_gone
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|MPASS
argument_list|(
operator|!
name|tty_gone
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Simulate carrier removal. */
name|ttydisc_modem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Wake up all blocked threads. */
name|tty_wakeup
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tp
operator|->
name|t_bgwait
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tp
operator|->
name|t_dcdwait
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|TF_GONE
expr_stmt|;
name|tty_rel_free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Exposing information about current TTY's through sysctl  */
end_comment

begin_function
specifier|static
name|void
name|tty_to_xtty
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|xtty
modifier|*
name|xt
parameter_list|)
block|{
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|xt
operator|->
name|xt_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|xtty
argument_list|)
expr_stmt|;
name|xt
operator|->
name|xt_insize
operator|=
name|ttyinq_getsize
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|)
expr_stmt|;
name|xt
operator|->
name|xt_incc
operator|=
name|ttyinq_bytescanonicalized
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|)
expr_stmt|;
name|xt
operator|->
name|xt_inlc
operator|=
name|ttyinq_bytesline
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|)
expr_stmt|;
name|xt
operator|->
name|xt_inlow
operator|=
name|tp
operator|->
name|t_inlow
expr_stmt|;
name|xt
operator|->
name|xt_outsize
operator|=
name|ttyoutq_getsize
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|xt
operator|->
name|xt_outcc
operator|=
name|ttyoutq_bytesused
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|xt
operator|->
name|xt_outlow
operator|=
name|tp
operator|->
name|t_outlow
expr_stmt|;
name|xt
operator|->
name|xt_column
operator|=
name|tp
operator|->
name|t_column
expr_stmt|;
name|xt
operator|->
name|xt_pgid
operator|=
name|tp
operator|->
name|t_pgrp
condition|?
name|tp
operator|->
name|t_pgrp
operator|->
name|pg_id
else|:
literal|0
expr_stmt|;
name|xt
operator|->
name|xt_sid
operator|=
name|tp
operator|->
name|t_session
condition|?
name|tp
operator|->
name|t_session
operator|->
name|s_sid
else|:
literal|0
expr_stmt|;
name|xt
operator|->
name|xt_flags
operator|=
name|tp
operator|->
name|t_flags
expr_stmt|;
name|xt
operator|->
name|xt_dev
operator|=
name|tp
operator|->
name|t_dev
condition|?
name|dev2udev
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
else|:
operator|(
name|uint32_t
operator|)
name|NODEV
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_kern_ttys
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|unsigned
name|long
name|lsize
decl_stmt|;
name|struct
name|xtty
modifier|*
name|xtlist
decl_stmt|,
modifier|*
name|xt
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sx_slock
argument_list|(
operator|&
name|tty_list_sx
argument_list|)
expr_stmt|;
name|lsize
operator|=
name|tty_list_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|xtty
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsize
operator|==
literal|0
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|tty_list_sx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|xtlist
operator|=
name|xt
operator|=
name|malloc
argument_list|(
name|lsize
argument_list|,
name|M_TTY
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&tty_list
argument_list|,
argument|t_list
argument_list|)
block|{
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tty_to_xtty
argument_list|(
name|tp
argument_list|,
name|xt
argument_list|)
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|xt
operator|++
expr_stmt|;
block|}
name|sx_sunlock
argument_list|(
operator|&
name|tty_list_sx
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|xtlist
argument_list|,
name|lsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xtlist
argument_list|,
name|M_TTY
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|ttys
argument_list|,
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_kern_ttys
argument_list|,
literal|"S,xtty"
argument_list|,
literal|"List of TTYs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Device node creation. Device has been set up, now we can expose it to  * the user.  */
end_comment

begin_function
name|int
name|tty_makedevf
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|struct
name|make_dev_args
name|args
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|,
modifier|*
name|init
decl_stmt|,
modifier|*
name|lock
decl_stmt|,
modifier|*
name|cua
decl_stmt|,
modifier|*
name|cinit
decl_stmt|,
modifier|*
name|clock
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
init|=
literal|"tty"
decl_stmt|;
name|char
name|name
index|[
name|SPECNAMELEN
operator|-
literal|3
index|]
decl_stmt|;
comment|/* for "tty" and "cua". */
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Remove "tty" prefix from devices like PTY's. */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_NOPREFIX
condition|)
name|prefix
operator|=
literal|""
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnrprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
literal|32
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|cred
operator|==
name|NULL
condition|)
block|{
comment|/* System device. */
name|uid
operator|=
name|UID_ROOT
expr_stmt|;
name|gid
operator|=
name|GID_WHEEL
expr_stmt|;
name|mode
operator|=
name|S_IRUSR
operator||
name|S_IWUSR
expr_stmt|;
block|}
else|else
block|{
comment|/* User device. */
name|uid
operator|=
name|cred
operator|->
name|cr_ruid
expr_stmt|;
name|gid
operator|=
name|GID_TTY
expr_stmt|;
name|mode
operator|=
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IWGRP
expr_stmt|;
block|}
name|flags
operator|=
name|flags
operator|&
name|TTYMK_CLONING
condition|?
name|MAKEDEV_REF
else|:
literal|0
expr_stmt|;
name|flags
operator||=
name|MAKEDEV_CHECKNAME
expr_stmt|;
comment|/* Master call-in device. */
name|make_dev_args_init
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
name|args
operator|.
name|mda_flags
operator|=
name|flags
expr_stmt|;
name|args
operator|.
name|mda_devsw
operator|=
operator|&
name|ttydev_cdevsw
expr_stmt|;
name|args
operator|.
name|mda_cr
operator|=
name|cred
expr_stmt|;
name|args
operator|.
name|mda_uid
operator|=
name|uid
expr_stmt|;
name|args
operator|.
name|mda_gid
operator|=
name|gid
expr_stmt|;
name|args
operator|.
name|mda_mode
operator|=
name|mode
expr_stmt|;
name|args
operator|.
name|mda_si_drv1
operator|=
name|tp
expr_stmt|;
name|error
operator|=
name|make_dev_s
argument_list|(
operator|&
name|args
argument_list|,
operator|&
name|dev
argument_list|,
literal|"%s%s"
argument_list|,
name|prefix
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
name|init
operator|=
name|lock
operator|=
name|cua
operator|=
name|cinit
operator|=
name|clock
operator|=
name|NULL
expr_stmt|;
comment|/* Slave call-in devices. */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_INITLOCK
condition|)
block|{
name|args
operator|.
name|mda_devsw
operator|=
operator|&
name|ttyil_cdevsw
expr_stmt|;
name|args
operator|.
name|mda_unit
operator|=
name|TTYUNIT_INIT
expr_stmt|;
name|args
operator|.
name|mda_si_drv1
operator|=
name|tp
expr_stmt|;
name|args
operator|.
name|mda_si_drv2
operator|=
operator|&
name|tp
operator|->
name|t_termios_init_in
expr_stmt|;
name|error
operator|=
name|make_dev_s
argument_list|(
operator|&
name|args
argument_list|,
operator|&
name|init
argument_list|,
literal|"%s%s.init"
argument_list|,
name|prefix
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|dev_depends
argument_list|(
name|dev
argument_list|,
name|init
argument_list|)
expr_stmt|;
name|args
operator|.
name|mda_unit
operator|=
name|TTYUNIT_LOCK
expr_stmt|;
name|args
operator|.
name|mda_si_drv2
operator|=
operator|&
name|tp
operator|->
name|t_termios_lock_in
expr_stmt|;
name|error
operator|=
name|make_dev_s
argument_list|(
operator|&
name|args
argument_list|,
operator|&
name|lock
argument_list|,
literal|"%s%s.lock"
argument_list|,
name|prefix
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|dev_depends
argument_list|(
name|dev
argument_list|,
name|lock
argument_list|)
expr_stmt|;
block|}
comment|/* Call-out devices. */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_CALLOUT
condition|)
block|{
name|make_dev_args_init
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
name|args
operator|.
name|mda_flags
operator|=
name|flags
expr_stmt|;
name|args
operator|.
name|mda_devsw
operator|=
operator|&
name|ttydev_cdevsw
expr_stmt|;
name|args
operator|.
name|mda_cr
operator|=
name|cred
expr_stmt|;
name|args
operator|.
name|mda_uid
operator|=
name|UID_UUCP
expr_stmt|;
name|args
operator|.
name|mda_gid
operator|=
name|GID_DIALER
expr_stmt|;
name|args
operator|.
name|mda_mode
operator|=
literal|0660
expr_stmt|;
name|args
operator|.
name|mda_unit
operator|=
name|TTYUNIT_CALLOUT
expr_stmt|;
name|args
operator|.
name|mda_si_drv1
operator|=
name|tp
expr_stmt|;
name|error
operator|=
name|make_dev_s
argument_list|(
operator|&
name|args
argument_list|,
operator|&
name|cua
argument_list|,
literal|"cua%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|dev_depends
argument_list|(
name|dev
argument_list|,
name|cua
argument_list|)
expr_stmt|;
comment|/* Slave call-out devices. */
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_INITLOCK
condition|)
block|{
name|args
operator|.
name|mda_devsw
operator|=
operator|&
name|ttyil_cdevsw
expr_stmt|;
name|args
operator|.
name|mda_unit
operator|=
name|TTYUNIT_CALLOUT
operator||
name|TTYUNIT_INIT
expr_stmt|;
name|args
operator|.
name|mda_si_drv2
operator|=
operator|&
name|tp
operator|->
name|t_termios_init_out
expr_stmt|;
name|error
operator|=
name|make_dev_s
argument_list|(
operator|&
name|args
argument_list|,
operator|&
name|cinit
argument_list|,
literal|"cua%s.init"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|dev_depends
argument_list|(
name|dev
argument_list|,
name|cinit
argument_list|)
expr_stmt|;
name|args
operator|.
name|mda_unit
operator|=
name|TTYUNIT_CALLOUT
operator||
name|TTYUNIT_LOCK
expr_stmt|;
name|args
operator|.
name|mda_si_drv2
operator|=
operator|&
name|tp
operator|->
name|t_termios_lock_out
expr_stmt|;
name|error
operator|=
name|make_dev_s
argument_list|(
operator|&
name|args
argument_list|,
operator|&
name|clock
argument_list|,
literal|"cua%s.lock"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|dev_depends
argument_list|(
name|dev
argument_list|,
name|clock
argument_list|)
expr_stmt|;
block|}
block|}
name|sx_xlock
argument_list|(
operator|&
name|tty_list_sx
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|tty_list
argument_list|,
name|tp
argument_list|,
name|t_list
argument_list|)
expr_stmt|;
name|tty_list_count
operator|++
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|tty_list_sx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|destroy_dev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|init
condition|)
name|destroy_dev
argument_list|(
name|init
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
condition|)
name|destroy_dev
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cinit
condition|)
name|destroy_dev
argument_list|(
name|cinit
argument_list|)
expr_stmt|;
if|if
condition|(
name|clock
condition|)
name|destroy_dev
argument_list|(
name|clock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Signalling processes.  */
end_comment

begin_function
name|void
name|tty_signal_sessleader
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|sig
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|sig
operator|>=
literal|1
operator|&&
name|sig
operator|<
name|NSIG
argument_list|)
expr_stmt|;
comment|/* Make signals start output again. */
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_STOPPED
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_session
operator|!=
name|NULL
operator|&&
name|tp
operator|->
name|t_session
operator|->
name|s_leader
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|tp
operator|->
name|t_session
operator|->
name|s_leader
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|kern_psignal
argument_list|(
name|p
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|tty_signal_pgrp
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|sig
parameter_list|)
block|{
name|ksiginfo_t
name|ksi
decl_stmt|;
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|sig
operator|>=
literal|1
operator|&&
name|sig
operator|<
name|NSIG
argument_list|)
expr_stmt|;
comment|/* Make signals start output again. */
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_STOPPED
expr_stmt|;
if|if
condition|(
name|sig
operator|==
name|SIGINFO
operator|&&
operator|!
operator|(
name|tp
operator|->
name|t_termios
operator|.
name|c_lflag
operator|&
name|NOKERNINFO
operator|)
condition|)
name|tty_info
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_pgrp
operator|!=
name|NULL
condition|)
block|{
name|ksiginfo_init
argument_list|(
operator|&
name|ksi
argument_list|)
expr_stmt|;
name|ksi
operator|.
name|ksi_signo
operator|=
name|sig
expr_stmt|;
name|ksi
operator|.
name|ksi_code
operator|=
name|SI_KERNEL
expr_stmt|;
name|PGRP_LOCK
argument_list|(
name|tp
operator|->
name|t_pgrp
argument_list|)
expr_stmt|;
name|pgsignal
argument_list|(
name|tp
operator|->
name|t_pgrp
argument_list|,
name|sig
argument_list|,
literal|1
argument_list|,
operator|&
name|ksi
argument_list|)
expr_stmt|;
name|PGRP_UNLOCK
argument_list|(
name|tp
operator|->
name|t_pgrp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|tty_wakeup
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_ASYNC
operator|&&
name|tp
operator|->
name|t_sigio
operator|!=
name|NULL
condition|)
name|pgsigio
argument_list|(
operator|&
name|tp
operator|->
name|t_sigio
argument_list|,
name|SIGIO
argument_list|,
operator|(
name|tp
operator|->
name|t_session
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FWRITE
condition|)
block|{
name|cv_broadcast
argument_list|(
operator|&
name|tp
operator|->
name|t_outwait
argument_list|)
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_outpoll
argument_list|)
expr_stmt|;
name|KNOTE_LOCKED
argument_list|(
operator|&
name|tp
operator|->
name|t_outpoll
operator|.
name|si_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|FREAD
condition|)
block|{
name|cv_broadcast
argument_list|(
operator|&
name|tp
operator|->
name|t_inwait
argument_list|)
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|tp
operator|->
name|t_inpoll
argument_list|)
expr_stmt|;
name|KNOTE_LOCKED
argument_list|(
operator|&
name|tp
operator|->
name|t_inpoll
operator|.
name|si_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|tty_wait
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|cv
modifier|*
name|cv
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|revokecnt
init|=
name|tp
operator|->
name|t_revokecnt
decl_stmt|;
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
operator||
name|MA_NOTRECURSED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|!
name|tty_gone
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|cv_wait_sig
argument_list|(
name|cv
argument_list|,
name|tp
operator|->
name|t_mtx
argument_list|)
expr_stmt|;
comment|/* Bail out when the device slipped away. */
if|if
condition|(
name|tty_gone
argument_list|(
name|tp
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Restart the system call when we may have been revoked. */
if|if
condition|(
name|tp
operator|->
name|t_revokecnt
operator|!=
name|revokecnt
condition|)
return|return
operator|(
name|ERESTART
operator|)
return|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tty_timedwait
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|cv
modifier|*
name|cv
parameter_list|,
name|int
name|hz
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|revokecnt
init|=
name|tp
operator|->
name|t_revokecnt
decl_stmt|;
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
operator||
name|MA_NOTRECURSED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|!
name|tty_gone
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|cv_timedwait_sig
argument_list|(
name|cv
argument_list|,
name|tp
operator|->
name|t_mtx
argument_list|,
name|hz
argument_list|)
expr_stmt|;
comment|/* Bail out when the device slipped away. */
if|if
condition|(
name|tty_gone
argument_list|(
name|tp
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Restart the system call when we may have been revoked. */
if|if
condition|(
name|tp
operator|->
name|t_revokecnt
operator|!=
name|revokecnt
condition|)
return|return
operator|(
name|ERESTART
operator|)
return|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tty_flush
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|FWRITE
condition|)
block|{
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_HIWAT_OUT
expr_stmt|;
name|ttyoutq_flush
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|tty_wakeup
argument_list|(
name|tp
argument_list|,
name|FWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tty_gone
argument_list|(
name|tp
argument_list|)
condition|)
block|{
name|ttydevsw_outwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|ttydevsw_pktnotify
argument_list|(
name|tp
argument_list|,
name|TIOCPKT_FLUSHWRITE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|FREAD
condition|)
block|{
name|tty_hiwat_in_unblock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|ttyinq_flush
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|)
expr_stmt|;
name|tty_wakeup
argument_list|(
name|tp
argument_list|,
name|FREAD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tty_gone
argument_list|(
name|tp
argument_list|)
condition|)
block|{
name|ttydevsw_inwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|ttydevsw_pktnotify
argument_list|(
name|tp
argument_list|,
name|TIOCPKT_FLUSHREAD
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|tty_set_winsize
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
specifier|const
name|struct
name|winsize
modifier|*
name|wsz
parameter_list|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|tp
operator|->
name|t_winsize
argument_list|,
name|wsz
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wsz
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|tp
operator|->
name|t_winsize
operator|=
operator|*
name|wsz
expr_stmt|;
name|tty_signal_pgrp
argument_list|(
name|tp
argument_list|,
name|SIGWINCH
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tty_generic_ioctl
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* 	 * Modem commands. 	 * The SER_* and TIOCM_* flags are the same, but one bit 	 * shifted. I don't know why. 	 */
case|case
name|TIOCSDTR
case|:
name|ttydevsw_modem
argument_list|(
name|tp
argument_list|,
name|SER_DTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCCDTR
case|:
name|ttydevsw_modem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
name|SER_DTR
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCMSET
case|:
block|{
name|int
name|bits
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
decl_stmt|;
name|ttydevsw_modem
argument_list|(
name|tp
argument_list|,
operator|(
name|bits
operator|&
operator|(
name|TIOCM_DTR
operator||
name|TIOCM_RTS
operator|)
operator|)
operator|>>
literal|1
argument_list|,
operator|(
operator|(
operator|~
name|bits
operator|)
operator|&
operator|(
name|TIOCM_DTR
operator||
name|TIOCM_RTS
operator|)
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|TIOCMBIS
case|:
block|{
name|int
name|bits
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
decl_stmt|;
name|ttydevsw_modem
argument_list|(
name|tp
argument_list|,
operator|(
name|bits
operator|&
operator|(
name|TIOCM_DTR
operator||
name|TIOCM_RTS
operator|)
operator|)
operator|>>
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|TIOCMBIC
case|:
block|{
name|int
name|bits
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
decl_stmt|;
name|ttydevsw_modem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
operator|(
name|bits
operator|&
operator|(
name|TIOCM_DTR
operator||
name|TIOCM_RTS
operator|)
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|TIOCMGET
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|TIOCM_LE
operator|+
operator|(
name|ttydevsw_modem
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<<
literal|1
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FIOASYNC
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|tp
operator|->
name|t_flags
operator||=
name|TF_ASYNC
expr_stmt|;
else|else
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_ASYNC
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FIONBIO
case|:
comment|/* This device supports non-blocking operation. */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FIONREAD
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|ttyinq_bytescanonicalized
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FIONWRITE
case|:
case|case
name|TIOCOUTQ
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|ttyoutq_bytesused
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FIOSETOWN
case|:
if|if
condition|(
name|tp
operator|->
name|t_session
operator|!=
name|NULL
operator|&&
operator|!
name|tty_is_ctty
argument_list|(
name|tp
argument_list|,
name|td
operator|->
name|td_proc
argument_list|)
condition|)
comment|/* Not allowed to set ownership. */
return|return
operator|(
name|ENOTTY
operator|)
return|;
comment|/* Temporarily unlock the TTY to set ownership. */
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|error
operator|=
name|fsetown
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
operator|&
name|tp
operator|->
name|t_sigio
argument_list|)
expr_stmt|;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
case|case
name|FIOGETOWN
case|:
if|if
condition|(
name|tp
operator|->
name|t_session
operator|!=
name|NULL
operator|&&
operator|!
name|tty_is_ctty
argument_list|(
name|tp
argument_list|,
name|td
operator|->
name|td_proc
argument_list|)
condition|)
comment|/* Not allowed to set ownership. */
return|return
operator|(
name|ENOTTY
operator|)
return|;
comment|/* Get ownership. */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|fgetown
argument_list|(
operator|&
name|tp
operator|->
name|t_sigio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGETA
case|:
comment|/* Obtain terminal flags through tcgetattr(). */
operator|*
operator|(
expr|struct
name|termios
operator|*
operator|)
name|data
operator|=
name|tp
operator|->
name|t_termios
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCSETA
case|:
case|case
name|TIOCSETAW
case|:
case|case
name|TIOCSETAF
case|:
block|{
name|struct
name|termios
modifier|*
name|t
init|=
name|data
decl_stmt|;
comment|/* 		 * Who makes up these funny rules? According to POSIX, 		 * input baud rate is set equal to the output baud rate 		 * when zero. 		 */
if|if
condition|(
name|t
operator|->
name|c_ispeed
operator|==
literal|0
condition|)
name|t
operator|->
name|c_ispeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
comment|/* Discard any unsupported bits. */
name|t
operator|->
name|c_iflag
operator|&=
name|TTYSUP_IFLAG
expr_stmt|;
name|t
operator|->
name|c_oflag
operator|&=
name|TTYSUP_OFLAG
expr_stmt|;
name|t
operator|->
name|c_lflag
operator|&=
name|TTYSUP_LFLAG
expr_stmt|;
name|t
operator|->
name|c_cflag
operator|&=
name|TTYSUP_CFLAG
expr_stmt|;
comment|/* Set terminal flags through tcsetattr(). */
if|if
condition|(
name|cmd
operator|==
name|TIOCSETAW
operator|||
name|cmd
operator|==
name|TIOCSETAF
condition|)
block|{
name|error
operator|=
name|tty_drain
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|cmd
operator|==
name|TIOCSETAF
condition|)
name|tty_flush
argument_list|(
name|tp
argument_list|,
name|FREAD
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Only call param() when the flags really change. 		 */
if|if
condition|(
operator|(
name|t
operator|->
name|c_cflag
operator|&
name|CIGNORE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|tp
operator|->
name|t_termios
operator|.
name|c_cflag
operator|!=
name|t
operator|->
name|c_cflag
operator|||
operator|(
operator|(
name|tp
operator|->
name|t_termios
operator|.
name|c_iflag
operator|^
name|t
operator|->
name|c_iflag
operator|)
operator|&
operator|(
name|IXON
operator||
name|IXOFF
operator||
name|IXANY
operator|)
operator|)
operator|||
name|tp
operator|->
name|t_termios
operator|.
name|c_ispeed
operator|!=
name|t
operator|->
name|c_ispeed
operator|||
name|tp
operator|->
name|t_termios
operator|.
name|c_ospeed
operator|!=
name|t
operator|->
name|c_ospeed
operator|)
condition|)
block|{
name|error
operator|=
name|ttydevsw_param
argument_list|(
name|tp
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* XXX: CLOCAL? */
name|tp
operator|->
name|t_termios
operator|.
name|c_cflag
operator|=
name|t
operator|->
name|c_cflag
operator|&
operator|~
name|CIGNORE
expr_stmt|;
name|tp
operator|->
name|t_termios
operator|.
name|c_ispeed
operator|=
name|t
operator|->
name|c_ispeed
expr_stmt|;
name|tp
operator|->
name|t_termios
operator|.
name|c_ospeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
comment|/* Baud rate has changed - update watermarks. */
name|error
operator|=
name|tty_watermarks
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Copy new non-device driver parameters. */
name|tp
operator|->
name|t_termios
operator|.
name|c_iflag
operator|=
name|t
operator|->
name|c_iflag
expr_stmt|;
name|tp
operator|->
name|t_termios
operator|.
name|c_oflag
operator|=
name|t
operator|->
name|c_oflag
expr_stmt|;
name|tp
operator|->
name|t_termios
operator|.
name|c_lflag
operator|=
name|t
operator|->
name|c_lflag
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|tp
operator|->
name|t_termios
operator|.
name|c_cc
argument_list|,
name|t
operator|->
name|c_cc
argument_list|,
sizeof|sizeof
name|t
operator|->
name|c_cc
argument_list|)
expr_stmt|;
name|ttydisc_optimize
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|->
name|c_lflag
operator|&
name|ICANON
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * When in non-canonical mode, wake up all 			 * readers. Canonicalize any partial input. VMIN 			 * and VTIME could also be adjusted. 			 */
name|ttyinq_canonicalize
argument_list|(
operator|&
name|tp
operator|->
name|t_inq
argument_list|)
expr_stmt|;
name|tty_wakeup
argument_list|(
name|tp
argument_list|,
name|FREAD
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * For packet mode: notify the PTY consumer that VSTOP 		 * and VSTART may have been changed. 		 */
if|if
condition|(
name|tp
operator|->
name|t_termios
operator|.
name|c_iflag
operator|&
name|IXON
operator|&&
name|tp
operator|->
name|t_termios
operator|.
name|c_cc
index|[
name|VSTOP
index|]
operator|==
name|CTRL
argument_list|(
literal|'S'
argument_list|)
operator|&&
name|tp
operator|->
name|t_termios
operator|.
name|c_cc
index|[
name|VSTART
index|]
operator|==
name|CTRL
argument_list|(
literal|'Q'
argument_list|)
condition|)
name|ttydevsw_pktnotify
argument_list|(
name|tp
argument_list|,
name|TIOCPKT_DOSTOP
argument_list|)
expr_stmt|;
else|else
name|ttydevsw_pktnotify
argument_list|(
name|tp
argument_list|,
name|TIOCPKT_NOSTOP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|TIOCGETD
case|:
comment|/* For compatibility - we only support TTYDISC. */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|TTYDISC
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGPGRP
case|:
if|if
condition|(
operator|!
name|tty_is_ctty
argument_list|(
name|tp
argument_list|,
name|td
operator|->
name|td_proc
argument_list|)
condition|)
return|return
operator|(
name|ENOTTY
operator|)
return|;
if|if
condition|(
name|tp
operator|->
name|t_pgrp
operator|!=
name|NULL
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|tp
operator|->
name|t_pgrp
operator|->
name|pg_id
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|NO_PID
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGSID
case|:
if|if
condition|(
operator|!
name|tty_is_ctty
argument_list|(
name|tp
argument_list|,
name|td
operator|->
name|td_proc
argument_list|)
condition|)
return|return
operator|(
name|ENOTTY
operator|)
return|;
name|MPASS
argument_list|(
name|tp
operator|->
name|t_session
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|tp
operator|->
name|t_session
operator|->
name|s_sid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCSCTTY
case|:
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
comment|/* XXX: This looks awful. */
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SESS_LEADER
argument_list|(
name|p
argument_list|)
condition|)
block|{
comment|/* Only the session leader may do this. */
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_session
operator|!=
name|NULL
operator|&&
name|tp
operator|->
name|t_session
operator|==
name|p
operator|->
name|p_session
condition|)
block|{
comment|/* This is already our controlling TTY. */
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|->
name|p_session
operator|->
name|s_ttyp
operator|!=
name|NULL
operator|||
operator|(
name|tp
operator|->
name|t_session
operator|!=
name|NULL
operator|&&
name|tp
operator|->
name|t_session
operator|->
name|s_ttyvp
operator|!=
name|NULL
operator|&&
name|tp
operator|->
name|t_session
operator|->
name|s_ttyvp
operator|->
name|v_type
operator|!=
name|VBAD
operator|)
condition|)
block|{
comment|/* 			 * There is already a relation between a TTY and 			 * a session, or the caller is not the session 			 * leader. 			 * 			 * Allow the TTY to be stolen when the vnode is 			 * invalid, but the reference to the TTY is 			 * still active.  This allows immediate reuse of 			 * TTYs of which the session leader has been 			 * killed or the TTY revoked. 			 */
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
comment|/* Connect the session to the TTY. */
name|tp
operator|->
name|t_session
operator|=
name|p
operator|->
name|p_session
expr_stmt|;
name|tp
operator|->
name|t_session
operator|->
name|s_ttyp
operator|=
name|tp
expr_stmt|;
name|tp
operator|->
name|t_sessioncnt
operator|++
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
comment|/* Assign foreground process group. */
name|tp
operator|->
name|t_pgrp
operator|=
name|p
operator|->
name|p_pgrp
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|P_CONTROLT
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|TIOCSPGRP
case|:
block|{
name|struct
name|pgrp
modifier|*
name|pg
decl_stmt|;
comment|/* 		 * XXX: Temporarily unlock the TTY to locate the process 		 * group. This code would be lot nicer if we would ever 		 * decompose proctree_lock. 		 */
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|pg
operator|=
name|pgfind
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|pg
operator|!=
name|NULL
condition|)
name|PGRP_UNLOCK
argument_list|(
name|pg
argument_list|)
expr_stmt|;
if|if
condition|(
name|pg
operator|==
name|NULL
operator|||
name|pg
operator|->
name|pg_session
operator|!=
name|td
operator|->
name|td_proc
operator|->
name|p_session
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* 		 * Determine if this TTY is the controlling TTY after 		 * relocking the TTY. 		 */
if|if
condition|(
operator|!
name|tty_is_ctty
argument_list|(
name|tp
argument_list|,
name|td
operator|->
name|td_proc
argument_list|)
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
name|tp
operator|->
name|t_pgrp
operator|=
name|pg
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
comment|/* Wake up the background process groups. */
name|cv_broadcast
argument_list|(
operator|&
name|tp
operator|->
name|t_bgwait
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|TIOCFLUSH
case|:
block|{
name|int
name|flags
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|flags
operator|==
literal|0
condition|)
name|flags
operator|=
operator|(
name|FREAD
operator||
name|FWRITE
operator|)
expr_stmt|;
else|else
name|flags
operator|&=
operator|(
name|FREAD
operator||
name|FWRITE
operator|)
expr_stmt|;
name|tty_flush
argument_list|(
name|tp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|TIOCDRAIN
case|:
comment|/* Drain TTY output. */
return|return
name|tty_drain
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|TIOCGDRAINWAIT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|tp
operator|->
name|t_drainwait
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCSDRAINWAIT
case|:
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_TTY_DRAINWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|tp
operator|->
name|t_drainwait
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
case|case
name|TIOCCONS
case|:
comment|/* Set terminal as console TTY. */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_TTY_CONSOLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 			 * XXX: constty should really need to be locked! 			 * XXX: allow disconnected constty's to be stolen! 			 */
if|if
condition|(
name|constty
operator|==
name|tp
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|constty
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|constty_set
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|constty
operator|==
name|tp
condition|)
block|{
name|constty_clear
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCGWINSZ
case|:
comment|/* Obtain window size. */
operator|*
operator|(
expr|struct
name|winsize
operator|*
operator|)
name|data
operator|=
name|tp
operator|->
name|t_winsize
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCSWINSZ
case|:
comment|/* Set window size. */
name|tty_set_winsize
argument_list|(
name|tp
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCEXCL
case|:
name|tp
operator|->
name|t_flags
operator||=
name|TF_EXCLUDE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCNXCL
case|:
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_EXCLUDE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCSTOP
case|:
name|tp
operator|->
name|t_flags
operator||=
name|TF_STOPPED
expr_stmt|;
name|ttydevsw_pktnotify
argument_list|(
name|tp
argument_list|,
name|TIOCPKT_STOP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCSTART
case|:
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_STOPPED
expr_stmt|;
name|ttydevsw_outwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|ttydevsw_pktnotify
argument_list|(
name|tp
argument_list|,
name|TIOCPKT_START
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCSTAT
case|:
name|tty_info
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TIOCSTI
case|:
if|if
condition|(
operator|(
name|fflag
operator|&
name|FREAD
operator|)
operator|==
literal|0
operator|&&
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_TTY_STI
argument_list|)
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
operator|!
name|tty_is_ctty
argument_list|(
name|tp
argument_list|,
name|td
operator|->
name|td_proc
argument_list|)
operator|&&
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_TTY_STI
argument_list|)
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
name|ttydisc_rint
argument_list|(
name|tp
argument_list|,
operator|*
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ttydisc_rint_done
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|COMPAT_43TTY
return|return
name|tty_ioctl_compat
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|fflag
argument_list|,
name|td
argument_list|)
return|;
else|#
directive|else
comment|/* !COMPAT_43TTY */
return|return
operator|(
name|ENOIOCTL
operator|)
return|;
endif|#
directive|endif
comment|/* COMPAT_43TTY */
block|}
end_function

begin_function
name|int
name|tty_ioctl
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|tty_gone
argument_list|(
name|tp
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|error
operator|=
name|ttydevsw_ioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
name|error
operator|=
name|tty_generic_ioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|fflag
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|dev_t
name|tty_udev
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_dev
condition|)
return|return
operator|(
name|dev2udev
argument_list|(
name|tp
operator|->
name|t_dev
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|NODEV
operator|)
return|;
block|}
end_function

begin_function
name|int
name|tty_checkoutq
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
comment|/* 256 bytes should be enough to print a log message. */
return|return
operator|(
name|ttyoutq_bytesleft
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
operator|>=
literal|256
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tty_hiwat_in_block
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_HIWAT_IN
operator|)
operator|==
literal|0
operator|&&
name|tp
operator|->
name|t_termios
operator|.
name|c_iflag
operator|&
name|IXOFF
operator|&&
name|tp
operator|->
name|t_termios
operator|.
name|c_cc
index|[
name|VSTOP
index|]
operator|!=
name|_POSIX_VDISABLE
condition|)
block|{
comment|/* 		 * Input flow control. Only enter the high watermark when we 		 * can successfully store the VSTOP character. 		 */
if|if
condition|(
name|ttyoutq_write_nofrag
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
operator|.
name|c_cc
index|[
name|VSTOP
index|]
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|tp
operator|->
name|t_flags
operator||=
name|TF_HIWAT_IN
expr_stmt|;
block|}
else|else
block|{
comment|/* No input flow control. */
name|tp
operator|->
name|t_flags
operator||=
name|TF_HIWAT_IN
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|tty_hiwat_in_unblock
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_HIWAT_IN
operator|&&
name|tp
operator|->
name|t_termios
operator|.
name|c_iflag
operator|&
name|IXOFF
operator|&&
name|tp
operator|->
name|t_termios
operator|.
name|c_cc
index|[
name|VSTART
index|]
operator|!=
name|_POSIX_VDISABLE
condition|)
block|{
comment|/* 		 * Input flow control. Only leave the high watermark when we 		 * can successfully store the VSTART character. 		 */
if|if
condition|(
name|ttyoutq_write_nofrag
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
operator|.
name|c_cc
index|[
name|VSTART
index|]
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_HIWAT_IN
expr_stmt|;
block|}
else|else
block|{
comment|/* No input flow control. */
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_HIWAT_IN
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tty_gone
argument_list|(
name|tp
argument_list|)
condition|)
name|ttydevsw_inwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * TTY hooks interface.  */
end_comment

begin_function
specifier|static
name|int
name|ttyhook_defrint
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|char
name|c
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|ttyhook_rint_bypass
argument_list|(
name|tp
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ttyhook_register
parameter_list|(
name|struct
name|tty
modifier|*
modifier|*
name|rtp
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|ttyhook
modifier|*
name|th
parameter_list|,
name|void
modifier|*
name|softc
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|struct
name|cdevsw
modifier|*
name|cdp
decl_stmt|;
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|cap_rights_t
name|rights
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ref
decl_stmt|;
comment|/* Validate the file descriptor. */
name|fdp
operator|=
name|p
operator|->
name|p_fd
expr_stmt|;
name|error
operator|=
name|fget_unlocked
argument_list|(
name|fdp
argument_list|,
name|fd
argument_list|,
name|cap_rights_init
argument_list|(
operator|&
name|rights
argument_list|,
name|CAP_TTYHOOK
argument_list|)
argument_list|,
operator|&
name|fp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|fp
operator|->
name|f_ops
operator|==
operator|&
name|badfileops
condition|)
block|{
name|error
operator|=
name|EBADF
expr_stmt|;
goto|goto
name|done1
goto|;
block|}
comment|/* 	 * Make sure the vnode is bound to a character device. 	 * Unlocked check for the vnode type is ok there, because we 	 * only shall prevent calling devvn_refthread on the file that 	 * never has been opened over a character device. 	 */
if|if
condition|(
name|fp
operator|->
name|f_type
operator|!=
name|DTYPE_VNODE
operator|||
name|fp
operator|->
name|f_vnode
operator|->
name|v_type
operator|!=
name|VCHR
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done1
goto|;
block|}
comment|/* Make sure it is a TTY. */
name|cdp
operator|=
name|devvn_refthread
argument_list|(
name|fp
operator|->
name|f_vnode
argument_list|,
operator|&
name|dev
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done1
goto|;
block|}
if|if
condition|(
name|dev
operator|!=
name|fp
operator|->
name|f_data
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
name|cdp
operator|!=
operator|&
name|ttydev_cdevsw
condition|)
block|{
name|error
operator|=
name|ENOTTY
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|tp
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
comment|/* Try to attach the hook to the TTY. */
name|error
operator|=
name|EBUSY
expr_stmt|;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|tp
operator|->
name|t_hook
operator|==
name|NULL
operator|)
operator|==
operator|(
operator|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_HOOK
operator|)
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_HOOK
condition|)
goto|goto
name|done3
goto|;
name|tp
operator|->
name|t_flags
operator||=
name|TF_HOOK
expr_stmt|;
name|tp
operator|->
name|t_hook
operator|=
name|th
expr_stmt|;
name|tp
operator|->
name|t_hooksoftc
operator|=
name|softc
expr_stmt|;
operator|*
name|rtp
operator|=
name|tp
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Maybe we can switch into bypass mode now. */
name|ttydisc_optimize
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* Silently convert rint() calls to rint_bypass() when possible. */
if|if
condition|(
operator|!
name|ttyhook_hashook
argument_list|(
name|tp
argument_list|,
name|rint
argument_list|)
operator|&&
name|ttyhook_hashook
argument_list|(
name|tp
argument_list|,
name|rint_bypass
argument_list|)
condition|)
name|th
operator|->
name|th_rint
operator|=
name|ttyhook_defrint
expr_stmt|;
name|done3
label|:
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|done2
label|:
name|dev_relthread
argument_list|(
name|dev
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|done1
label|:
name|fdrop
argument_list|(
name|fp
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ttyhook_unregister
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|tty_lock_assert
argument_list|(
name|tp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|tp
operator|->
name|t_flags
operator|&
name|TF_HOOK
argument_list|)
expr_stmt|;
comment|/* Disconnect the hook. */
name|tp
operator|->
name|t_flags
operator|&=
operator|~
name|TF_HOOK
expr_stmt|;
name|tp
operator|->
name|t_hook
operator|=
name|NULL
expr_stmt|;
comment|/* Maybe we need to leave bypass mode. */
name|ttydisc_optimize
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* Maybe deallocate the TTY as well. */
name|tty_rel_free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * /dev/console handling.  */
end_comment

begin_function
specifier|static
name|int
name|ttyconsdev_open
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
comment|/* System has no console device. */
if|if
condition|(
name|dev_console_filename
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Look up corresponding TTY by device name. */
name|sx_slock
argument_list|(
operator|&
name|tty_list_sx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&tty_list
argument_list|,
argument|t_list
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dev_console_filename
argument_list|,
name|tty_devname
argument_list|(
name|tp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dev_console
operator|->
name|si_drv1
operator|=
name|tp
expr_stmt|;
break|break;
block|}
block|}
name|sx_sunlock
argument_list|(
operator|&
name|tty_list_sx
argument_list|)
expr_stmt|;
comment|/* System console has no TTY associated. */
if|if
condition|(
name|dev_console
operator|->
name|si_drv1
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
name|ttydev_open
argument_list|(
name|dev
argument_list|,
name|oflags
argument_list|,
name|devtype
argument_list|,
name|td
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttyconsdev_write
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|log_console
argument_list|(
name|uio
argument_list|)
expr_stmt|;
return|return
operator|(
name|ttydev_write
argument_list|(
name|dev
argument_list|,
name|uio
argument_list|,
name|ioflag
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * /dev/console is a little different than normal TTY's.  When opened,  * it determines which TTY to use.  When data gets written to it, it  * will be logged in the kernel message buffer.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|ttyconsdev_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|ttyconsdev_open
block|,
operator|.
name|d_close
operator|=
name|ttydev_close
block|,
operator|.
name|d_read
operator|=
name|ttydev_read
block|,
operator|.
name|d_write
operator|=
name|ttyconsdev_write
block|,
operator|.
name|d_ioctl
operator|=
name|ttydev_ioctl
block|,
operator|.
name|d_kqfilter
operator|=
name|ttydev_kqfilter
block|,
operator|.
name|d_poll
operator|=
name|ttydev_poll
block|,
operator|.
name|d_mmap
operator|=
name|ttydev_mmap
block|,
operator|.
name|d_name
operator|=
literal|"ttyconsdev"
block|,
operator|.
name|d_flags
operator|=
name|D_TTY
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ttyconsdev_init
parameter_list|(
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|dev_console
operator|=
name|make_dev_credf
argument_list|(
name|MAKEDEV_ETERNAL
argument_list|,
operator|&
name|ttyconsdev_cdevsw
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"console"
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|tty
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|ttyconsdev_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|ttyconsdev_select
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|dev_console_filename
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Debugging routines.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_sym.h>
end_include

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|int
name|flag
decl_stmt|;
name|char
name|val
decl_stmt|;
block|}
name|ttystates
index|[]
init|=
block|{
if|#
directive|if
literal|0
block|{ TF_NOPREFIX,		'N' },
endif|#
directive|endif
block|{
name|TF_INITLOCK
block|,
literal|'I'
block|}
block|,
block|{
name|TF_CALLOUT
block|,
literal|'C'
block|}
block|,
comment|/* Keep these together -> 'Oi' and 'Oo'. */
block|{
name|TF_OPENED
block|,
literal|'O'
block|}
block|,
block|{
name|TF_OPENED_IN
block|,
literal|'i'
block|}
block|,
block|{
name|TF_OPENED_OUT
block|,
literal|'o'
block|}
block|,
block|{
name|TF_OPENED_CONS
block|,
literal|'c'
block|}
block|,
block|{
name|TF_GONE
block|,
literal|'G'
block|}
block|,
block|{
name|TF_OPENCLOSE
block|,
literal|'B'
block|}
block|,
block|{
name|TF_ASYNC
block|,
literal|'Y'
block|}
block|,
block|{
name|TF_LITERAL
block|,
literal|'L'
block|}
block|,
comment|/* Keep these together -> 'Hi' and 'Ho'. */
block|{
name|TF_HIWAT
block|,
literal|'H'
block|}
block|,
block|{
name|TF_HIWAT_IN
block|,
literal|'i'
block|}
block|,
block|{
name|TF_HIWAT_OUT
block|,
literal|'o'
block|}
block|,
block|{
name|TF_STOPPED
block|,
literal|'S'
block|}
block|,
block|{
name|TF_EXCLUDE
block|,
literal|'X'
block|}
block|,
block|{
name|TF_BYPASS
block|,
literal|'l'
block|}
block|,
block|{
name|TF_ZOMBIE
block|,
literal|'Z'
block|}
block|,
block|{
name|TF_HOOK
block|,
literal|'s'
block|}
block|,
comment|/* Keep these together -> 'bi' and 'bo'. */
block|{
name|TF_BUSY
block|,
literal|'b'
block|}
block|,
block|{
name|TF_BUSY_IN
block|,
literal|'i'
block|}
block|,
block|{
name|TF_BUSY_OUT
block|,
literal|'o'
block|}
block|,
block|{
literal|0
block|,
literal|'\0'
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|TTY_FLAG_BITS
define|\
value|"\20\1NOPREFIX\2INITLOCK\3CALLOUT\4OPENED_IN" \ 	"\5OPENED_OUT\6OPENED_CONS\7GONE\10OPENCLOSE" \ 	"\11ASYNC\12LITERAL\13HIWAT_IN\14HIWAT_OUT" \ 	"\15STOPPED\16EXCLUDE\17BYPASS\20ZOMBIE" \ 	"\21HOOK\22BUSY_IN\23BUSY_OUT"
end_define

begin_define
define|#
directive|define
name|DB_PRINTSYM
parameter_list|(
name|name
parameter_list|,
name|addr
parameter_list|)
define|\
value|db_printf("%s  " #name ": ", sep); \ 	db_printsym((db_addr_t) addr, DB_STGY_ANY); \ 	db_printf("\n");
end_define

begin_function
specifier|static
name|void
name|_db_show_devsw
parameter_list|(
specifier|const
name|char
modifier|*
name|sep
parameter_list|,
specifier|const
name|struct
name|ttydevsw
modifier|*
name|tsw
parameter_list|)
block|{
name|db_printf
argument_list|(
literal|"%sdevsw: "
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|db_printsym
argument_list|(
operator|(
name|db_addr_t
operator|)
name|tsw
argument_list|,
name|DB_STGY_ANY
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|" (%p)\n"
argument_list|,
name|tsw
argument_list|)
expr_stmt|;
name|DB_PRINTSYM
argument_list|(
name|open
argument_list|,
name|tsw
operator|->
name|tsw_open
argument_list|)
expr_stmt|;
name|DB_PRINTSYM
argument_list|(
name|close
argument_list|,
name|tsw
operator|->
name|tsw_close
argument_list|)
expr_stmt|;
name|DB_PRINTSYM
argument_list|(
name|outwakeup
argument_list|,
name|tsw
operator|->
name|tsw_outwakeup
argument_list|)
expr_stmt|;
name|DB_PRINTSYM
argument_list|(
name|inwakeup
argument_list|,
name|tsw
operator|->
name|tsw_inwakeup
argument_list|)
expr_stmt|;
name|DB_PRINTSYM
argument_list|(
name|ioctl
argument_list|,
name|tsw
operator|->
name|tsw_ioctl
argument_list|)
expr_stmt|;
name|DB_PRINTSYM
argument_list|(
name|param
argument_list|,
name|tsw
operator|->
name|tsw_param
argument_list|)
expr_stmt|;
name|DB_PRINTSYM
argument_list|(
name|modem
argument_list|,
name|tsw
operator|->
name|tsw_modem
argument_list|)
expr_stmt|;
name|DB_PRINTSYM
argument_list|(
name|mmap
argument_list|,
name|tsw
operator|->
name|tsw_mmap
argument_list|)
expr_stmt|;
name|DB_PRINTSYM
argument_list|(
name|pktnotify
argument_list|,
name|tsw
operator|->
name|tsw_pktnotify
argument_list|)
expr_stmt|;
name|DB_PRINTSYM
argument_list|(
name|free
argument_list|,
name|tsw
operator|->
name|tsw_free
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_db_show_hooks
parameter_list|(
specifier|const
name|char
modifier|*
name|sep
parameter_list|,
specifier|const
name|struct
name|ttyhook
modifier|*
name|th
parameter_list|)
block|{
name|db_printf
argument_list|(
literal|"%shook: "
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|db_printsym
argument_list|(
operator|(
name|db_addr_t
operator|)
name|th
argument_list|,
name|DB_STGY_ANY
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|" (%p)\n"
argument_list|,
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|th
operator|==
name|NULL
condition|)
return|return;
name|DB_PRINTSYM
argument_list|(
name|rint
argument_list|,
name|th
operator|->
name|th_rint
argument_list|)
expr_stmt|;
name|DB_PRINTSYM
argument_list|(
name|rint_bypass
argument_list|,
name|th
operator|->
name|th_rint_bypass
argument_list|)
expr_stmt|;
name|DB_PRINTSYM
argument_list|(
name|rint_done
argument_list|,
name|th
operator|->
name|th_rint_done
argument_list|)
expr_stmt|;
name|DB_PRINTSYM
argument_list|(
name|rint_poll
argument_list|,
name|th
operator|->
name|th_rint_poll
argument_list|)
expr_stmt|;
name|DB_PRINTSYM
argument_list|(
name|getc_inject
argument_list|,
name|th
operator|->
name|th_getc_inject
argument_list|)
expr_stmt|;
name|DB_PRINTSYM
argument_list|(
name|getc_capture
argument_list|,
name|th
operator|->
name|th_getc_capture
argument_list|)
expr_stmt|;
name|DB_PRINTSYM
argument_list|(
name|getc_poll
argument_list|,
name|th
operator|->
name|th_getc_poll
argument_list|)
expr_stmt|;
name|DB_PRINTSYM
argument_list|(
name|close
argument_list|,
name|th
operator|->
name|th_close
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_db_show_termios
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|struct
name|termios
modifier|*
name|t
parameter_list|)
block|{
name|db_printf
argument_list|(
literal|"%s: iflag 0x%x oflag 0x%x cflag 0x%x "
literal|"lflag 0x%x ispeed %u ospeed %u\n"
argument_list|,
name|name
argument_list|,
name|t
operator|->
name|c_iflag
argument_list|,
name|t
operator|->
name|c_oflag
argument_list|,
name|t
operator|->
name|c_cflag
argument_list|,
name|t
operator|->
name|c_lflag
argument_list|,
name|t
operator|->
name|c_ispeed
argument_list|,
name|t
operator|->
name|c_ospeed
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* DDB command to show TTY statistics. */
end_comment

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|tty
argument_list|,
argument|db_show_tty
argument_list|)
end_macro

begin_block
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
operator|!
name|have_addr
condition|)
block|{
name|db_printf
argument_list|(
literal|"usage: show tty<addr>\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|tp
operator|=
operator|(
expr|struct
name|tty
operator|*
operator|)
name|addr
expr_stmt|;
name|db_printf
argument_list|(
literal|"%p: %s\n"
argument_list|,
name|tp
argument_list|,
name|tty_devname
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\tmtx: %p\n"
argument_list|,
name|tp
operator|->
name|t_mtx
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\tflags: 0x%b\n"
argument_list|,
name|tp
operator|->
name|t_flags
argument_list|,
name|TTY_FLAG_BITS
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\trevokecnt: %u\n"
argument_list|,
name|tp
operator|->
name|t_revokecnt
argument_list|)
expr_stmt|;
comment|/* Buffering mechanisms. */
name|db_printf
argument_list|(
literal|"\tinq: %p begin %u linestart %u reprint %u end %u "
literal|"nblocks %u quota %u\n"
argument_list|,
operator|&
name|tp
operator|->
name|t_inq
argument_list|,
name|tp
operator|->
name|t_inq
operator|.
name|ti_begin
argument_list|,
name|tp
operator|->
name|t_inq
operator|.
name|ti_linestart
argument_list|,
name|tp
operator|->
name|t_inq
operator|.
name|ti_reprint
argument_list|,
name|tp
operator|->
name|t_inq
operator|.
name|ti_end
argument_list|,
name|tp
operator|->
name|t_inq
operator|.
name|ti_nblocks
argument_list|,
name|tp
operator|->
name|t_inq
operator|.
name|ti_quota
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\toutq: %p begin %u end %u nblocks %u quota %u\n"
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|tp
operator|->
name|t_outq
operator|.
name|to_begin
argument_list|,
name|tp
operator|->
name|t_outq
operator|.
name|to_end
argument_list|,
name|tp
operator|->
name|t_outq
operator|.
name|to_nblocks
argument_list|,
name|tp
operator|->
name|t_outq
operator|.
name|to_quota
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\tinlow: %zu\n"
argument_list|,
name|tp
operator|->
name|t_inlow
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\toutlow: %zu\n"
argument_list|,
name|tp
operator|->
name|t_outlow
argument_list|)
expr_stmt|;
name|_db_show_termios
argument_list|(
literal|"\ttermios"
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\twinsize: row %u col %u xpixel %u ypixel %u\n"
argument_list|,
name|tp
operator|->
name|t_winsize
operator|.
name|ws_row
argument_list|,
name|tp
operator|->
name|t_winsize
operator|.
name|ws_col
argument_list|,
name|tp
operator|->
name|t_winsize
operator|.
name|ws_xpixel
argument_list|,
name|tp
operator|->
name|t_winsize
operator|.
name|ws_ypixel
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\tcolumn: %u\n"
argument_list|,
name|tp
operator|->
name|t_column
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\twritepos: %u\n"
argument_list|,
name|tp
operator|->
name|t_writepos
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\tcompatflags: 0x%x\n"
argument_list|,
name|tp
operator|->
name|t_compatflags
argument_list|)
expr_stmt|;
comment|/* Init/lock-state devices. */
name|_db_show_termios
argument_list|(
literal|"\ttermios_init_in"
argument_list|,
operator|&
name|tp
operator|->
name|t_termios_init_in
argument_list|)
expr_stmt|;
name|_db_show_termios
argument_list|(
literal|"\ttermios_init_out"
argument_list|,
operator|&
name|tp
operator|->
name|t_termios_init_out
argument_list|)
expr_stmt|;
name|_db_show_termios
argument_list|(
literal|"\ttermios_lock_in"
argument_list|,
operator|&
name|tp
operator|->
name|t_termios_lock_in
argument_list|)
expr_stmt|;
name|_db_show_termios
argument_list|(
literal|"\ttermios_lock_out"
argument_list|,
operator|&
name|tp
operator|->
name|t_termios_lock_out
argument_list|)
expr_stmt|;
comment|/* Hooks */
name|_db_show_devsw
argument_list|(
literal|"\t"
argument_list|,
name|tp
operator|->
name|t_devsw
argument_list|)
expr_stmt|;
name|_db_show_hooks
argument_list|(
literal|"\t"
argument_list|,
name|tp
operator|->
name|t_hook
argument_list|)
expr_stmt|;
comment|/* Process info. */
name|db_printf
argument_list|(
literal|"\tpgrp: %p gid %d jobc %d\n"
argument_list|,
name|tp
operator|->
name|t_pgrp
argument_list|,
name|tp
operator|->
name|t_pgrp
condition|?
name|tp
operator|->
name|t_pgrp
operator|->
name|pg_id
else|:
literal|0
argument_list|,
name|tp
operator|->
name|t_pgrp
condition|?
name|tp
operator|->
name|t_pgrp
operator|->
name|pg_jobc
else|:
literal|0
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\tsession: %p"
argument_list|,
name|tp
operator|->
name|t_session
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_session
operator|!=
name|NULL
condition|)
name|db_printf
argument_list|(
literal|" count %u leader %p tty %p sid %d login %s"
argument_list|,
name|tp
operator|->
name|t_session
operator|->
name|s_count
argument_list|,
name|tp
operator|->
name|t_session
operator|->
name|s_leader
argument_list|,
name|tp
operator|->
name|t_session
operator|->
name|s_ttyp
argument_list|,
name|tp
operator|->
name|t_session
operator|->
name|s_sid
argument_list|,
name|tp
operator|->
name|t_session
operator|->
name|s_login
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\tsessioncnt: %u\n"
argument_list|,
name|tp
operator|->
name|t_sessioncnt
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\tdevswsoftc: %p\n"
argument_list|,
name|tp
operator|->
name|t_devswsoftc
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\thooksoftc: %p\n"
argument_list|,
name|tp
operator|->
name|t_hooksoftc
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\tdev: %p\n"
argument_list|,
name|tp
operator|->
name|t_dev
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* DDB command to list TTYs. */
end_comment

begin_macro
name|DB_SHOW_ALL_COMMAND
argument_list|(
argument|ttys
argument_list|,
argument|db_show_all_ttys
argument_list|)
end_macro

begin_block
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|size_t
name|isiz
decl_stmt|,
name|osiz
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Make the output look like `pstat -t'. */
name|db_printf
argument_list|(
literal|"PTR        "
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__LP64__
argument_list|)
name|db_printf
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|db_printf
argument_list|(
literal|"      LINE   INQ  CAN  LIN  LOW  OUTQ  USE  LOW   "
literal|"COL  SESS  PGID STATE\n"
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&tty_list
argument_list|,
argument|t_list
argument_list|)
block|{
name|isiz
operator|=
name|tp
operator|->
name|t_inq
operator|.
name|ti_nblocks
operator|*
name|TTYINQ_DATASIZE
expr_stmt|;
name|osiz
operator|=
name|tp
operator|->
name|t_outq
operator|.
name|to_nblocks
operator|*
name|TTYOUTQ_DATASIZE
expr_stmt|;
name|db_printf
argument_list|(
literal|"%p %10s %5zu %4u %4u %4zu %5zu %4u %4zu %5u %5d "
literal|"%5d "
argument_list|,
name|tp
argument_list|,
name|tty_devname
argument_list|(
name|tp
argument_list|)
argument_list|,
name|isiz
argument_list|,
name|tp
operator|->
name|t_inq
operator|.
name|ti_linestart
operator|-
name|tp
operator|->
name|t_inq
operator|.
name|ti_begin
argument_list|,
name|tp
operator|->
name|t_inq
operator|.
name|ti_end
operator|-
name|tp
operator|->
name|t_inq
operator|.
name|ti_linestart
argument_list|,
name|isiz
operator|-
name|tp
operator|->
name|t_inlow
argument_list|,
name|osiz
argument_list|,
name|tp
operator|->
name|t_outq
operator|.
name|to_end
operator|-
name|tp
operator|->
name|t_outq
operator|.
name|to_begin
argument_list|,
name|osiz
operator|-
name|tp
operator|->
name|t_outlow
argument_list|,
name|MIN
argument_list|(
name|tp
operator|->
name|t_column
argument_list|,
literal|99999
argument_list|)
argument_list|,
name|tp
operator|->
name|t_session
condition|?
name|tp
operator|->
name|t_session
operator|->
name|s_sid
else|:
literal|0
argument_list|,
name|tp
operator|->
name|t_pgrp
condition|?
name|tp
operator|->
name|t_pgrp
operator|->
name|pg_id
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* Flag bits. */
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|ttystates
index|[
name|i
index|]
operator|.
name|flag
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tp
operator|->
name|t_flags
operator|&
name|ttystates
index|[
name|i
index|]
operator|.
name|flag
condition|)
block|{
name|db_printf
argument_list|(
literal|"%c"
argument_list|,
name|ttystates
index|[
name|i
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|db_printf
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

end_unit

