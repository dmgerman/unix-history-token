begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013-2015 Gleb Smirnoff<glebius@FreeBSD.org>  * Copyright (c) 1998, David Greenman. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/capsicum.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sf_buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<security/audit/audit.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_comment
comment|/*  * Structure describing a single sendfile(2) I/O, which may consist of  * several underlying pager I/Os.  *  * The syscall context allocates the structure and initializes 'nios'  * to 1.  As sendfile_swapin() runs through pages and starts asynchronous  * paging operations, it increments 'nios'.  *  * Every I/O completion calls sendfile_iodone(), which decrements the 'nios',  * and the syscall also calls sendfile_iodone() after allocating all mbufs,  * linking them and sending to socket.  Whoever reaches zero 'nios' is  * responsible to * call pru_ready on the socket, to notify it of readyness  * of the data.  */
end_comment

begin_struct
struct|struct
name|sf_io
block|{
specifier|volatile
name|u_int
name|nios
decl_stmt|;
name|u_int
name|error
decl_stmt|;
name|int
name|npages
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|vm_page_t
name|pa
index|[]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Structure used to track requests with SF_SYNC flag.  */
end_comment

begin_struct
struct|struct
name|sendfile_sync
block|{
name|struct
name|mtx
name|mtx
decl_stmt|;
name|struct
name|cv
name|cv
decl_stmt|;
name|unsigned
name|count
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|counter_u64_t
name|sfstat
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|sfstat
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sfstat_init
parameter_list|(
specifier|const
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|COUNTER_ARRAY_ALLOC
argument_list|(
name|sfstat
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sfstat
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|sfstat
argument_list|,
name|SI_SUB_MBUF
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|sfstat_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sfstat_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|sfstat
name|s
decl_stmt|;
name|COUNTER_ARRAY_COPY
argument_list|(
name|sfstat
argument_list|,
operator|&
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|newptr
condition|)
name|COUNTER_ARRAY_ZERO
argument_list|(
name|sfstat
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|sfstat
argument_list|,
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sfstat_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"sendfile statistics"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Detach mapped page and release resources back to the system.  Called  * by mbuf(9) code when last reference to a page is freed.  */
end_comment

begin_function
name|void
name|sf_ext_free
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|struct
name|sf_buf
modifier|*
name|sf
init|=
name|arg1
decl_stmt|;
name|struct
name|sendfile_sync
modifier|*
name|sfs
init|=
name|arg2
decl_stmt|;
name|vm_page_t
name|pg
init|=
name|sf_buf_page
argument_list|(
name|sf
argument_list|)
decl_stmt|;
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|pg
argument_list|)
expr_stmt|;
comment|/* 	 * Check for the object going away on us. This can 	 * happen since we don't hold a reference to it. 	 * If so, we're responsible for freeing the page. 	 */
if|if
condition|(
name|vm_page_unwire
argument_list|(
name|pg
argument_list|,
name|PQ_INACTIVE
argument_list|)
operator|&&
name|pg
operator|->
name|object
operator|==
name|NULL
condition|)
name|vm_page_free
argument_list|(
name|pg
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|pg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfs
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sfs
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sfs
operator|->
name|count
operator|>
literal|0
argument_list|,
operator|(
literal|"Sendfile sync botchup count == 0"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|sfs
operator|->
name|count
operator|==
literal|0
condition|)
name|cv_signal
argument_list|(
operator|&
name|sfs
operator|->
name|cv
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sfs
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Same as above, but forces the page to be detached from the object  * and go into free pool.  */
end_comment

begin_function
name|void
name|sf_ext_free_nocache
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|struct
name|sf_buf
modifier|*
name|sf
init|=
name|arg1
decl_stmt|;
name|struct
name|sendfile_sync
modifier|*
name|sfs
init|=
name|arg2
decl_stmt|;
name|vm_page_t
name|pg
init|=
name|sf_buf_page
argument_list|(
name|sf
argument_list|)
decl_stmt|;
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|pg
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm_page_unwire
argument_list|(
name|pg
argument_list|,
name|PQ_NONE
argument_list|)
condition|)
block|{
name|vm_object_t
name|obj
decl_stmt|;
comment|/* Try to free the page, but only if it is cheap to. */
if|if
condition|(
operator|(
name|obj
operator|=
name|pg
operator|->
name|object
operator|)
operator|==
name|NULL
condition|)
name|vm_page_free
argument_list|(
name|pg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|vm_page_xbusied
argument_list|(
name|pg
argument_list|)
operator|&&
name|VM_OBJECT_TRYWLOCK
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|vm_page_free
argument_list|(
name|pg
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
else|else
name|vm_page_deactivate
argument_list|(
name|pg
argument_list|)
expr_stmt|;
block|}
name|vm_page_unlock
argument_list|(
name|pg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfs
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sfs
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sfs
operator|->
name|count
operator|>
literal|0
argument_list|,
operator|(
literal|"Sendfile sync botchup count == 0"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|sfs
operator|->
name|count
operator|==
literal|0
condition|)
name|cv_signal
argument_list|(
operator|&
name|sfs
operator|->
name|cv
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sfs
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Helper function to calculate how much data to put into page i of n.  * Only first and last pages are special.  */
end_comment

begin_function
specifier|static
specifier|inline
name|off_t
name|xfsize
parameter_list|(
name|int
name|i
parameter_list|,
name|int
name|n
parameter_list|,
name|off_t
name|off
parameter_list|,
name|off_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|omin
argument_list|(
name|PAGE_SIZE
operator|-
operator|(
name|off
operator|&
name|PAGE_MASK
operator|)
argument_list|,
name|len
argument_list|)
operator|)
return|;
if|if
condition|(
name|i
operator|==
name|n
operator|-
literal|1
operator|&&
operator|(
operator|(
name|off
operator|+
name|len
operator|)
operator|&
name|PAGE_MASK
operator|)
operator|>
literal|0
condition|)
return|return
operator|(
operator|(
name|off
operator|+
name|len
operator|)
operator|&
name|PAGE_MASK
operator|)
return|;
return|return
operator|(
name|PAGE_SIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Helper function to get offset within object for i page.  */
end_comment

begin_function
specifier|static
specifier|inline
name|vm_ooffset_t
name|vmoff
parameter_list|(
name|int
name|i
parameter_list|,
name|off_t
name|off
parameter_list|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|vm_ooffset_t
operator|)
name|off
operator|)
return|;
return|return
operator|(
name|trunc_page
argument_list|(
name|off
operator|+
name|i
operator|*
name|PAGE_SIZE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Helper function used when allocation of a page or sf_buf failed.  * Pretend as if we don't have enough space, subtract xfsize() of  * all pages that failed.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|fixspace
parameter_list|(
name|int
name|old
parameter_list|,
name|int
name|new
parameter_list|,
name|off_t
name|off
parameter_list|,
name|int
modifier|*
name|space
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|old
operator|>
name|new
argument_list|,
operator|(
literal|"%s: old %d new %d"
operator|,
name|__func__
operator|,
name|old
operator|,
name|new
operator|)
argument_list|)
expr_stmt|;
comment|/* Subtract last one. */
operator|*
name|space
operator|-=
name|xfsize
argument_list|(
name|old
operator|-
literal|1
argument_list|,
name|old
argument_list|,
name|off
argument_list|,
operator|*
name|space
argument_list|)
expr_stmt|;
name|old
operator|--
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|old
condition|)
comment|/* There was only one page. */
return|return;
comment|/* Subtract first one. */
if|if
condition|(
name|new
operator|==
literal|0
condition|)
block|{
operator|*
name|space
operator|-=
name|xfsize
argument_list|(
literal|0
argument_list|,
name|old
argument_list|,
name|off
argument_list|,
operator|*
name|space
argument_list|)
expr_stmt|;
name|new
operator|++
expr_stmt|;
block|}
comment|/* Rest of pages are full sized. */
operator|*
name|space
operator|-=
operator|(
name|old
operator|-
name|new
operator|)
operator|*
name|PAGE_SIZE
expr_stmt|;
name|KASSERT
argument_list|(
operator|*
name|space
operator|>=
literal|0
argument_list|,
operator|(
literal|"%s: space went backwards"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * I/O completion callback.  */
end_comment

begin_function
specifier|static
name|void
name|sendfile_iodone
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|vm_page_t
modifier|*
name|pg
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|sf_io
modifier|*
name|sfio
init|=
name|arg
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|sfio
operator|->
name|so
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pg
index|[
name|i
index|]
operator|!=
name|bogus_page
condition|)
name|vm_page_xunbusy
argument_list|(
name|pg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|sfio
operator|->
name|error
operator|=
name|error
expr_stmt|;
if|if
condition|(
operator|!
name|refcount_release
argument_list|(
operator|&
name|sfio
operator|->
name|nios
argument_list|)
condition|)
return|return;
if|if
condition|(
name|sfio
operator|->
name|error
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* 		 * I/O operation failed.  The state of data in the socket 		 * is now inconsistent, and all what we can do is to tear 		 * it down. Protocol abort method would tear down protocol 		 * state, free all ready mbufs and detach not ready ones. 		 * We will free the mbufs corresponding to this I/O manually. 		 * 		 * The socket would be marked with EIO and made available 		 * for read, so that application receives EIO on next 		 * syscall and eventually closes the socket. 		 */
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_abort
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
name|EIO
expr_stmt|;
name|m
operator|=
name|sfio
operator|->
name|m
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sfio
operator|->
name|npages
condition|;
name|i
operator|++
control|)
name|m
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CURVNET_SET
argument_list|(
name|so
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_ready
argument_list|)
argument_list|(
name|so
argument_list|,
name|sfio
operator|->
name|m
argument_list|,
name|sfio
operator|->
name|npages
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sorele
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sfio
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Iterate through pages vector and request paging for non-valid pages.  */
end_comment

begin_function
specifier|static
name|int
name|sendfile_swapin
parameter_list|(
name|vm_object_t
name|obj
parameter_list|,
name|struct
name|sf_io
modifier|*
name|sfio
parameter_list|,
name|off_t
name|off
parameter_list|,
name|off_t
name|len
parameter_list|,
name|int
name|npages
parameter_list|,
name|int
name|rhpages
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|vm_page_t
modifier|*
name|pa
init|=
name|sfio
operator|->
name|pa
decl_stmt|;
name|int
name|grabbed
decl_stmt|,
name|nios
decl_stmt|;
name|nios
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
operator|(
name|flags
operator|&
name|SF_NODISKIO
operator|)
condition|?
name|VM_ALLOC_NOWAIT
else|:
literal|0
expr_stmt|;
comment|/* 	 * First grab all the pages and wire them.  Note that we grab 	 * only required pages.  Readahead pages are dealt with later. 	 */
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|grabbed
operator|=
name|vm_page_grab_pages
argument_list|(
name|obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|off
argument_list|)
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_WIRED
operator||
name|flags
argument_list|,
name|pa
argument_list|,
name|npages
argument_list|)
expr_stmt|;
if|if
condition|(
name|grabbed
operator|<
name|npages
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
name|grabbed
init|;
name|i
operator|<
name|npages
condition|;
name|i
operator|++
control|)
name|pa
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|npages
operator|=
name|grabbed
expr_stmt|;
name|rhpages
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|npages
condition|;
control|)
block|{
name|int
name|j
decl_stmt|,
name|a
decl_stmt|,
name|count
decl_stmt|,
name|rv
decl_stmt|;
comment|/* Skip valid pages. */
if|if
condition|(
name|vm_page_is_valid
argument_list|(
name|pa
index|[
name|i
index|]
argument_list|,
name|vmoff
argument_list|(
name|i
argument_list|,
name|off
argument_list|)
operator|&
name|PAGE_MASK
argument_list|,
name|xfsize
argument_list|(
name|i
argument_list|,
name|npages
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
argument_list|)
condition|)
block|{
name|vm_page_xunbusy
argument_list|(
name|pa
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|SFSTAT_INC
argument_list|(
name|sf_pages_valid
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Next page is invalid.  Check if it belongs to pager.  It 		 * may not be there, which is a regular situation for shmem 		 * pager.  For vnode pager this happens only in case of 		 * a sparse file. 		 * 		 * Important feature of vm_pager_has_page() is the hint 		 * stored in 'a', about how many pages we can pagein after 		 * this page in a single I/O. 		 */
if|if
condition|(
operator|!
name|vm_pager_has_page
argument_list|(
name|obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|vmoff
argument_list|(
name|i
argument_list|,
name|off
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|a
argument_list|)
condition|)
block|{
name|pmap_zero_page
argument_list|(
name|pa
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pa
index|[
name|i
index|]
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|MPASS
argument_list|(
name|pa
index|[
name|i
index|]
operator|->
name|dirty
operator|==
literal|0
argument_list|)
expr_stmt|;
name|vm_page_xunbusy
argument_list|(
name|pa
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * We want to pagein as many pages as possible, limited only 		 * by the 'a' hint and actual request. 		 */
name|count
operator|=
name|min
argument_list|(
name|a
operator|+
literal|1
argument_list|,
name|npages
operator|-
name|i
argument_list|)
expr_stmt|;
comment|/* 		 * We should not pagein into a valid page, thus we first trim 		 * any valid pages off the end of request, and substitute 		 * to bogus_page those, that are in the middle. 		 */
for|for
control|(
name|j
operator|=
name|i
operator|+
name|count
operator|-
literal|1
init|;
name|j
operator|>
name|i
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|vm_page_is_valid
argument_list|(
name|pa
index|[
name|j
index|]
argument_list|,
name|vmoff
argument_list|(
name|j
argument_list|,
name|off
argument_list|)
operator|&
name|PAGE_MASK
argument_list|,
name|xfsize
argument_list|(
name|j
argument_list|,
name|npages
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
argument_list|)
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|rhpages
operator|=
literal|0
expr_stmt|;
block|}
else|else
break|break;
block|}
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|i
operator|+
name|count
operator|-
literal|1
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|vm_page_is_valid
argument_list|(
name|pa
index|[
name|j
index|]
argument_list|,
name|vmoff
argument_list|(
name|j
argument_list|,
name|off
argument_list|)
operator|&
name|PAGE_MASK
argument_list|,
name|xfsize
argument_list|(
name|j
argument_list|,
name|npages
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
argument_list|)
condition|)
block|{
name|vm_page_xunbusy
argument_list|(
name|pa
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|SFSTAT_INC
argument_list|(
name|sf_pages_valid
argument_list|)
expr_stmt|;
name|SFSTAT_INC
argument_list|(
name|sf_pages_bogus
argument_list|)
expr_stmt|;
name|pa
index|[
name|j
index|]
operator|=
name|bogus_page
expr_stmt|;
block|}
name|refcount_acquire
argument_list|(
operator|&
name|sfio
operator|->
name|nios
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_pager_get_pages_async
argument_list|(
name|obj
argument_list|,
name|pa
operator|+
name|i
argument_list|,
name|count
argument_list|,
name|NULL
argument_list|,
name|i
operator|+
name|count
operator|==
name|npages
condition|?
operator|&
name|rhpages
else|:
name|NULL
argument_list|,
operator|&
name|sendfile_iodone
argument_list|,
name|sfio
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rv
operator|==
name|VM_PAGER_OK
argument_list|,
operator|(
literal|"%s: pager fail obj %p page %p"
operator|,
name|__func__
operator|,
name|obj
operator|,
name|pa
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
name|SFSTAT_INC
argument_list|(
name|sf_iocnt
argument_list|)
expr_stmt|;
name|SFSTAT_ADD
argument_list|(
name|sf_pages_read
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
name|count
operator|==
name|npages
condition|)
name|SFSTAT_ADD
argument_list|(
name|sf_rhpages_read
argument_list|,
name|rhpages
argument_list|)
expr_stmt|;
comment|/* 		 * Restore the valid page pointers.  They are already 		 * unbusied, but still wired. 		 */
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|i
operator|+
name|count
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|pa
index|[
name|j
index|]
operator|==
name|bogus_page
condition|)
block|{
name|pa
index|[
name|j
index|]
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|vmoff
argument_list|(
name|j
argument_list|,
name|off
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pa
index|[
name|j
index|]
argument_list|,
operator|(
literal|"%s: page %p[%d] disappeared"
operator|,
name|__func__
operator|,
name|pa
operator|,
name|j
operator|)
argument_list|)
expr_stmt|;
block|}
name|i
operator|+=
name|count
expr_stmt|;
name|nios
operator|++
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|nios
operator|==
literal|0
operator|&&
name|npages
operator|!=
literal|0
condition|)
name|SFSTAT_INC
argument_list|(
name|sf_noiocnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|nios
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sendfile_getobj
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|vm_object_t
modifier|*
name|obj_res
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vp_res
parameter_list|,
name|struct
name|shmfd
modifier|*
modifier|*
name|shmfd_res
parameter_list|,
name|off_t
modifier|*
name|obj_size
parameter_list|,
name|int
modifier|*
name|bsize
parameter_list|)
block|{
name|struct
name|vattr
name|va
decl_stmt|;
name|vm_object_t
name|obj
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|shmfd
modifier|*
name|shmfd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vp
operator|=
operator|*
name|vp_res
operator|=
name|NULL
expr_stmt|;
name|obj
operator|=
name|NULL
expr_stmt|;
name|shmfd
operator|=
operator|*
name|shmfd_res
operator|=
name|NULL
expr_stmt|;
operator|*
name|bsize
operator|=
literal|0
expr_stmt|;
comment|/* 	 * The file descriptor must be a regular file and have a 	 * backing VM object. 	 */
if|if
condition|(
name|fp
operator|->
name|f_type
operator|==
name|DTYPE_VNODE
condition|)
block|{
name|vp
operator|=
name|fp
operator|->
name|f_vnode
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_SHARED
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|*
name|bsize
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
expr_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|va
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
operator|*
name|obj_size
operator|=
name|va
operator|.
name|va_size
expr_stmt|;
name|obj
operator|=
name|vp
operator|->
name|v_object
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|fp
operator|->
name|f_type
operator|==
name|DTYPE_SHM
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
name|shmfd
operator|=
name|fp
operator|->
name|f_data
expr_stmt|;
name|obj
operator|=
name|shmfd
operator|->
name|shm_object
expr_stmt|;
operator|*
name|obj_size
operator|=
name|shmfd
operator|->
name|shm_size
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|obj
operator|->
name|flags
operator|&
name|OBJ_DEAD
operator|)
operator|!=
literal|0
condition|)
block|{
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBADF
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Temporarily increase the backing VM object's reference 	 * count so that a forced reclamation of its vnode does not 	 * immediately destroy it. 	 */
name|vm_object_reference_locked
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
operator|*
name|obj_res
operator|=
name|obj
expr_stmt|;
operator|*
name|vp_res
operator|=
name|vp
expr_stmt|;
operator|*
name|shmfd_res
operator|=
name|shmfd
expr_stmt|;
name|out
label|:
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sendfile_getsock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|s
parameter_list|,
name|struct
name|file
modifier|*
modifier|*
name|sock_fp
parameter_list|,
name|struct
name|socket
modifier|*
modifier|*
name|so
parameter_list|)
block|{
name|cap_rights_t
name|rights
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|sock_fp
operator|=
name|NULL
expr_stmt|;
operator|*
name|so
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * The socket must be a stream socket and connected. 	 */
name|error
operator|=
name|getsock_cap
argument_list|(
name|td
argument_list|,
name|s
argument_list|,
name|cap_rights_init
argument_list|(
operator|&
name|rights
argument_list|,
name|CAP_SEND
argument_list|)
argument_list|,
name|sock_fp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|so
operator|=
operator|(
operator|*
name|sock_fp
operator|)
operator|->
name|f_data
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|so
operator|)
operator|->
name|so_type
operator|!=
name|SOCK_STREAM
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
operator|(
operator|*
name|so
operator|)
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOTCONN
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vn_sendfile
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|int
name|sockfd
parameter_list|,
name|struct
name|uio
modifier|*
name|hdr_uio
parameter_list|,
name|struct
name|uio
modifier|*
name|trl_uio
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|size_t
name|nbytes
parameter_list|,
name|off_t
modifier|*
name|sent
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|file
modifier|*
name|sock_fp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vm_object
modifier|*
name|obj
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mh
decl_stmt|,
modifier|*
name|mhtail
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|struct
name|shmfd
modifier|*
name|shmfd
decl_stmt|;
name|struct
name|sendfile_sync
modifier|*
name|sfs
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
name|off_t
name|off
decl_stmt|,
name|sbytes
decl_stmt|,
name|rem
decl_stmt|,
name|obj_size
decl_stmt|;
name|int
name|error
decl_stmt|,
name|softerr
decl_stmt|,
name|bsize
decl_stmt|,
name|hdrlen
decl_stmt|;
name|obj
operator|=
name|NULL
expr_stmt|;
name|so
operator|=
name|NULL
expr_stmt|;
name|m
operator|=
name|mh
operator|=
name|NULL
expr_stmt|;
name|sfs
operator|=
name|NULL
expr_stmt|;
name|hdrlen
operator|=
name|sbytes
operator|=
literal|0
expr_stmt|;
name|softerr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sendfile_getobj
argument_list|(
name|td
argument_list|,
name|fp
argument_list|,
operator|&
name|obj
argument_list|,
operator|&
name|vp
argument_list|,
operator|&
name|shmfd
argument_list|,
operator|&
name|obj_size
argument_list|,
operator|&
name|bsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|sendfile_getsock
argument_list|(
name|td
argument_list|,
name|sockfd
argument_list|,
operator|&
name|sock_fp
argument_list|,
operator|&
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_socket_check_send
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
endif|#
directive|endif
name|SFSTAT_INC
argument_list|(
name|sf_syscalls
argument_list|)
expr_stmt|;
name|SFSTAT_ADD
argument_list|(
name|sf_rhpages_requested
argument_list|,
name|SF_READAHEAD
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SF_SYNC
condition|)
block|{
name|sfs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|sfs
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sfs
operator|->
name|mtx
argument_list|,
literal|"sendfile"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|sfs
operator|->
name|cv
argument_list|,
literal|"sendfile"
argument_list|)
expr_stmt|;
block|}
name|rem
operator|=
name|nbytes
condition|?
name|omin
argument_list|(
name|nbytes
argument_list|,
name|obj_size
operator|-
name|offset
argument_list|)
else|:
name|obj_size
operator|-
name|offset
expr_stmt|;
comment|/* 	 * Protect against multiple writers to the socket. 	 * 	 * XXXRW: Historically this has assumed non-interruptibility, so now 	 * we implement that, but possibly shouldn't. 	 */
operator|(
name|void
operator|)
name|sblock
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
name|SBL_WAIT
operator||
name|SBL_NOINTR
argument_list|)
expr_stmt|;
comment|/* 	 * Loop through the pages of the file, starting with the requested 	 * offset. Get a file page (do I/O if necessary), map the file page 	 * into an sf_buf, attach an mbuf header to the sf_buf, and queue 	 * it on the socket. 	 * This is done in two loops.  The inner loop turns as many pages 	 * as it can, up to available socket buffer space, without blocking 	 * into mbufs to have it bulk delivered into the socket send buffer. 	 * The outer loop checks the state and available space of the socket 	 * and takes care of the overall progress. 	 */
for|for
control|(
name|off
operator|=
name|offset
init|;
name|rem
operator|>
literal|0
condition|;
control|)
block|{
name|struct
name|sf_io
modifier|*
name|sfio
decl_stmt|;
name|vm_page_t
modifier|*
name|pa
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mtail
decl_stmt|;
name|int
name|nios
decl_stmt|,
name|space
decl_stmt|,
name|npages
decl_stmt|,
name|rhpages
decl_stmt|;
name|mtail
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Check the socket state for ongoing connection, 		 * no errors and space in socket buffer. 		 * If space is low allow for the remainder of the 		 * file to be processed if it fits the socket buffer. 		 * Otherwise block in waiting for sufficient space 		 * to proceed, or if the socket is nonblocking, return 		 * to userland with EAGAIN while reporting how far 		 * we've come. 		 * We wait until the socket buffer has significant free 		 * space to do bulk sends.  This makes good use of file 		 * system read ahead and allows packet segmentation 		 * offloading hardware to take over lots of work.  If 		 * we were not careful here we would send off only one 		 * sfbuf at a time. 		 */
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_lowat
operator|<
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|/
literal|2
condition|)
name|so
operator|->
name|so_snd
operator|.
name|sb_lowat
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|/
literal|2
expr_stmt|;
name|retry_space
label|:
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_state
operator|&
name|SBS_CANTSENDMORE
condition|)
block|{
name|error
operator|=
name|EPIPE
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
elseif|else
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|space
operator|=
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|<
name|rem
operator|&&
operator|(
name|space
operator|<=
literal|0
operator|||
name|space
operator|<
name|so
operator|->
name|so_snd
operator|.
name|sb_lowat
operator|)
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 			 * sbwait drops the lock while sleeping. 			 * When we loop back to retry_space the 			 * state may have changed and we retest 			 * for it. 			 */
name|error
operator|=
name|sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
comment|/* 			 * An error from sbwait usually indicates that we've 			 * been interrupted by a signal. If we've sent anything 			 * then return bytes sent, otherwise return the error. 			 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
goto|goto
name|retry_space
goto|;
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
comment|/* 		 * At the beginning of the first loop check if any headers 		 * are specified and copy them into mbufs.  Reduce space in 		 * the socket buffer by the size of the header mbuf chain. 		 * Clear hdr_uio here and hdrlen at the end of the first loop. 		 */
if|if
condition|(
name|hdr_uio
operator|!=
name|NULL
operator|&&
name|hdr_uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|hdr_uio
operator|->
name|uio_td
operator|=
name|td
expr_stmt|;
name|hdr_uio
operator|->
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|mh
operator|=
name|m_uiotombuf
argument_list|(
name|hdr_uio
argument_list|,
name|M_WAITOK
argument_list|,
name|space
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hdrlen
operator|=
name|m_length
argument_list|(
name|mh
argument_list|,
operator|&
name|mhtail
argument_list|)
expr_stmt|;
name|space
operator|-=
name|hdrlen
expr_stmt|;
comment|/* 			 * If header consumed all the socket buffer space, 			 * don't waste CPU cycles and jump to the end. 			 */
if|if
condition|(
name|space
operator|==
literal|0
condition|)
block|{
name|sfio
operator|=
name|NULL
expr_stmt|;
name|nios
operator|=
literal|0
expr_stmt|;
goto|goto
name|prepend_header
goto|;
block|}
name|hdr_uio
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_SHARED
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|va
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|off
operator|>=
name|va
operator|.
name|va_size
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|va
operator|.
name|va_size
operator|!=
name|obj_size
condition|)
block|{
name|obj_size
operator|=
name|va
operator|.
name|va_size
expr_stmt|;
name|rem
operator|=
name|nbytes
condition|?
name|omin
argument_list|(
name|nbytes
operator|+
name|offset
argument_list|,
name|obj_size
argument_list|)
else|:
name|obj_size
expr_stmt|;
name|rem
operator|-=
name|off
expr_stmt|;
block|}
block|}
if|if
condition|(
name|space
operator|>
name|rem
condition|)
name|space
operator|=
name|rem
expr_stmt|;
name|npages
operator|=
name|howmany
argument_list|(
name|space
operator|+
operator|(
name|off
operator|&
name|PAGE_MASK
operator|)
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* 		 * Calculate maximum allowed number of pages for readahead 		 * at this iteration.  If SF_USER_READAHEAD was set, we don't 		 * do any heuristics and use exactly the value supplied by 		 * application.  Otherwise, we allow readahead up to "rem". 		 * If application wants more, let it be, but there is no 		 * reason to go above MAXPHYS.  Also check against "obj_size", 		 * since vm_pager_has_page() can hint beyond EOF. 		 */
if|if
condition|(
name|flags
operator|&
name|SF_USER_READAHEAD
condition|)
block|{
name|rhpages
operator|=
name|SF_READAHEAD
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rhpages
operator|=
name|howmany
argument_list|(
name|rem
operator|+
operator|(
name|off
operator|&
name|PAGE_MASK
operator|)
argument_list|,
name|PAGE_SIZE
argument_list|)
operator|-
name|npages
expr_stmt|;
name|rhpages
operator|+=
name|SF_READAHEAD
argument_list|(
name|flags
argument_list|)
expr_stmt|;
block|}
name|rhpages
operator|=
name|min
argument_list|(
name|howmany
argument_list|(
name|MAXPHYS
argument_list|,
name|PAGE_SIZE
argument_list|)
argument_list|,
name|rhpages
argument_list|)
expr_stmt|;
name|rhpages
operator|=
name|min
argument_list|(
name|howmany
argument_list|(
name|obj_size
operator|-
name|trunc_page
argument_list|(
name|off
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|)
operator|-
name|npages
argument_list|,
name|rhpages
argument_list|)
expr_stmt|;
name|sfio
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sf_io
argument_list|)
operator|+
name|npages
operator|*
sizeof|sizeof
argument_list|(
name|vm_page_t
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|refcount_init
argument_list|(
operator|&
name|sfio
operator|->
name|nios
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sfio
operator|->
name|so
operator|=
name|so
expr_stmt|;
name|sfio
operator|->
name|error
operator|=
literal|0
expr_stmt|;
name|nios
operator|=
name|sendfile_swapin
argument_list|(
name|obj
argument_list|,
name|sfio
argument_list|,
name|off
argument_list|,
name|space
argument_list|,
name|npages
argument_list|,
name|rhpages
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 		 * Loop and construct maximum sized mbuf chain to be bulk 		 * dumped into socket buffer. 		 */
name|pa
operator|=
name|sfio
operator|->
name|pa
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|npages
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
comment|/* 			 * If a page wasn't grabbed successfully, then 			 * trim the array. Can happen only with SF_NODISKIO. 			 */
if|if
condition|(
name|pa
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|SFSTAT_INC
argument_list|(
name|sf_busy
argument_list|)
expr_stmt|;
name|fixspace
argument_list|(
name|npages
argument_list|,
name|i
argument_list|,
name|off
argument_list|,
operator|&
name|space
argument_list|)
expr_stmt|;
name|npages
operator|=
name|i
expr_stmt|;
name|softerr
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
comment|/* 			 * Get a sendfile buf.  When allocating the 			 * first buffer for mbuf chain, we usually 			 * wait as long as necessary, but this wait 			 * can be interrupted.  For consequent 			 * buffers, do not sleep, since several 			 * threads might exhaust the buffers and then 			 * deadlock. 			 */
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|pa
index|[
name|i
index|]
argument_list|,
name|m
operator|!=
name|NULL
condition|?
name|SFB_NOWAIT
else|:
name|SFB_CATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf
operator|==
name|NULL
condition|)
block|{
name|SFSTAT_INC
argument_list|(
name|sf_allocfail
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
name|i
init|;
name|j
operator|<
name|npages
condition|;
name|j
operator|++
control|)
block|{
name|vm_page_lock
argument_list|(
name|pa
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|pa
index|[
name|j
index|]
argument_list|,
name|PQ_INACTIVE
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|pa
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|softerr
operator|=
name|ENOBUFS
expr_stmt|;
name|fixspace
argument_list|(
name|npages
argument_list|,
name|i
argument_list|,
name|off
argument_list|,
operator|&
name|space
argument_list|)
expr_stmt|;
name|npages
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|m0
operator|=
name|m_get
argument_list|(
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_ext
operator|.
name|ext_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_ext
operator|.
name|ext_size
operator|=
name|PAGE_SIZE
expr_stmt|;
name|m0
operator|->
name|m_ext
operator|.
name|ext_arg1
operator|=
name|sf
expr_stmt|;
name|m0
operator|->
name|m_ext
operator|.
name|ext_arg2
operator|=
name|sfs
expr_stmt|;
comment|/* 			 * SF_NOCACHE sets the page as being freed upon send. 			 * However, we ignore it for the last page in 'space', 			 * if the page is truncated, and we got more data to 			 * send (rem> space), or if we have readahead 			 * configured (rhpages> 0). 			 */
if|if
condition|(
operator|(
name|flags
operator|&
name|SF_NOCACHE
operator|)
operator|==
literal|0
operator|||
operator|(
name|i
operator|==
name|npages
operator|-
literal|1
operator|&&
operator|(
operator|(
name|off
operator|+
name|space
operator|)
operator|&
name|PAGE_MASK
operator|)
operator|&&
operator|(
name|rem
operator|>
name|space
operator|||
name|rhpages
operator|>
literal|0
operator|)
operator|)
condition|)
name|m0
operator|->
name|m_ext
operator|.
name|ext_type
operator|=
name|EXT_SFBUF
expr_stmt|;
else|else
name|m0
operator|->
name|m_ext
operator|.
name|ext_type
operator|=
name|EXT_SFBUF_NOCACHE
expr_stmt|;
name|m0
operator|->
name|m_ext
operator|.
name|ext_flags
operator|=
name|EXT_FLAG_EMBREF
expr_stmt|;
name|m0
operator|->
name|m_ext
operator|.
name|ext_count
operator|=
literal|1
expr_stmt|;
name|m0
operator|->
name|m_flags
operator||=
operator|(
name|M_EXT
operator||
name|M_RDONLY
operator|)
expr_stmt|;
if|if
condition|(
name|nios
condition|)
name|m0
operator|->
name|m_flags
operator||=
name|M_NOTREADY
expr_stmt|;
name|m0
operator|->
name|m_data
operator|=
operator|(
name|char
operator|*
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
operator|+
operator|(
name|vmoff
argument_list|(
name|i
argument_list|,
name|off
argument_list|)
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
name|m0
operator|->
name|m_len
operator|=
name|xfsize
argument_list|(
name|i
argument_list|,
name|npages
argument_list|,
name|off
argument_list|,
name|space
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|sfio
operator|->
name|m
operator|=
name|m0
expr_stmt|;
comment|/* Append to mbuf chain. */
if|if
condition|(
name|mtail
operator|!=
name|NULL
condition|)
name|mtail
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
else|else
name|m
operator|=
name|m0
expr_stmt|;
name|mtail
operator|=
name|m0
expr_stmt|;
if|if
condition|(
name|sfs
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sfs
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|sfs
operator|->
name|count
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sfs
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Keep track of bytes processed. */
name|off
operator|+=
name|space
expr_stmt|;
name|rem
operator|-=
name|space
expr_stmt|;
comment|/* Prepend header, if any. */
if|if
condition|(
name|hdrlen
condition|)
block|{
name|prepend_header
label|:
name|mhtail
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|mh
expr_stmt|;
name|mh
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|softerr
argument_list|,
operator|(
literal|"%s: m NULL, no error"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|softerr
expr_stmt|;
name|free
argument_list|(
name|sfio
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Add the buffer chain to the socket buffer. */
name|KASSERT
argument_list|(
name|m_length
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
operator|==
name|space
operator|+
name|hdrlen
argument_list|,
operator|(
literal|"%s: mlen %u space %d hdrlen %d"
operator|,
name|__func__
operator|,
name|m_length
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
operator|,
name|space
operator|,
name|hdrlen
operator|)
argument_list|)
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|so
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
if|if
condition|(
name|nios
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If sendfile_swapin() didn't initiate any I/Os, 			 * which happens if all data is cached in VM, then 			 * we can send data right now without the 			 * PRUS_NOTREADY flag. 			 */
name|free
argument_list|(
name|sfio
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_send
call|)
argument_list|(
name|so
argument_list|,
literal|0
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sfio
operator|->
name|npages
operator|=
name|npages
expr_stmt|;
name|soref
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_send
call|)
argument_list|(
name|so
argument_list|,
name|PRUS_NOTREADY
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|sendfile_iodone
argument_list|(
name|sfio
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
comment|/* pru_send always consumes */
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|sbytes
operator|+=
name|space
operator|+
name|hdrlen
expr_stmt|;
if|if
condition|(
name|hdrlen
condition|)
name|hdrlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|softerr
condition|)
block|{
name|error
operator|=
name|softerr
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* 	 * Send trailers. Wimp out and use writev(2). 	 */
if|if
condition|(
name|trl_uio
operator|!=
name|NULL
condition|)
block|{
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|error
operator|=
name|kern_writev
argument_list|(
name|td
argument_list|,
name|sockfd
argument_list|,
name|trl_uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|sbytes
operator|+=
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|done
label|:
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* 	 * If there was no error we have to clear td->td_retval[0] 	 * because it may have been set by writev. 	 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sent
operator|!=
name|NULL
condition|)
block|{
operator|(
operator|*
name|sent
operator|)
operator|=
name|sbytes
expr_stmt|;
block|}
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
name|vm_object_deallocate
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
condition|)
name|fdrop
argument_list|(
name|sock_fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|mh
condition|)
name|m_freem
argument_list|(
name|mh
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfs
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sfs
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfs
operator|->
name|count
operator|!=
literal|0
condition|)
name|cv_wait
argument_list|(
operator|&
name|sfs
operator|->
name|cv
argument_list|,
operator|&
name|sfs
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sfs
operator|->
name|count
operator|==
literal|0
argument_list|,
operator|(
literal|"sendfile sync still busy"
operator|)
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|sfs
operator|->
name|cv
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sfs
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sfs
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sendfile
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|sendfile_args
modifier|*
name|uap
parameter_list|,
name|int
name|compat
parameter_list|)
block|{
name|struct
name|sf_hdtr
name|hdtr
decl_stmt|;
name|struct
name|uio
modifier|*
name|hdr_uio
decl_stmt|,
modifier|*
name|trl_uio
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|cap_rights_t
name|rights
decl_stmt|;
name|off_t
name|sbytes
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * File offset must be positive.  If it goes beyond EOF 	 * we send only the header/trailer and no payload data. 	 */
if|if
condition|(
name|uap
operator|->
name|offset
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sbytes
operator|=
literal|0
expr_stmt|;
name|hdr_uio
operator|=
name|trl_uio
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|hdtr
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|hdtr
argument_list|,
operator|&
name|hdtr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdtr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|hdtr
operator|.
name|headers
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|copyinuio
argument_list|(
name|hdtr
operator|.
name|headers
argument_list|,
name|hdtr
operator|.
name|hdr_cnt
argument_list|,
operator|&
name|hdr_uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD4
comment|/* 			 * In FreeBSD< 5.0 the nbytes to send also included 			 * the header.  If compat is specified subtract the 			 * header size from nbytes. 			 */
if|if
condition|(
name|compat
condition|)
block|{
if|if
condition|(
name|uap
operator|->
name|nbytes
operator|>
name|hdr_uio
operator|->
name|uio_resid
condition|)
name|uap
operator|->
name|nbytes
operator|-=
name|hdr_uio
operator|->
name|uio_resid
expr_stmt|;
else|else
name|uap
operator|->
name|nbytes
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|hdtr
operator|.
name|trailers
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|copyinuio
argument_list|(
name|hdtr
operator|.
name|trailers
argument_list|,
name|hdtr
operator|.
name|trl_cnt
argument_list|,
operator|&
name|trl_uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
block|}
name|AUDIT_ARG_FD
argument_list|(
name|uap
operator|->
name|fd
argument_list|)
expr_stmt|;
comment|/* 	 * sendfile(2) can start at any offset within a file so we require 	 * CAP_READ+CAP_SEEK = CAP_PREAD. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|fget_read
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
name|cap_rights_init
argument_list|(
operator|&
name|rights
argument_list|,
name|CAP_PREAD
argument_list|)
argument_list|,
operator|&
name|fp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|fo_sendfile
argument_list|(
name|fp
argument_list|,
name|uap
operator|->
name|s
argument_list|,
name|hdr_uio
argument_list|,
name|trl_uio
argument_list|,
name|uap
operator|->
name|offset
argument_list|,
name|uap
operator|->
name|nbytes
argument_list|,
operator|&
name|sbytes
argument_list|,
name|uap
operator|->
name|flags
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|sbytes
operator|!=
name|NULL
condition|)
name|copyout
argument_list|(
operator|&
name|sbytes
argument_list|,
name|uap
operator|->
name|sbytes
argument_list|,
sizeof|sizeof
argument_list|(
name|off_t
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|hdr_uio
argument_list|,
name|M_IOV
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|trl_uio
argument_list|,
name|M_IOV
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * sendfile(2)  *   * int sendfile(int fd, int s, off_t offset, size_t nbytes,  *       struct sf_hdtr *hdtr, off_t *sbytes, int flags)  *   * Send a file specified by 'fd' and starting at 'offset' to a socket  * specified by 's'. Send only 'nbytes' of the file or until EOF if nbytes ==  * 0.  Optionally add a header and/or trailer to the socket output.  If  * specified, write the total number of bytes sent into *sbytes.  */
end_comment

begin_function
name|int
name|sys_sendfile
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|sendfile_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|sendfile
argument_list|(
name|td
argument_list|,
name|uap
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD4
end_ifdef

begin_function
name|int
name|freebsd4_sendfile
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd4_sendfile_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|sendfile_args
name|args
decl_stmt|;
name|args
operator|.
name|fd
operator|=
name|uap
operator|->
name|fd
expr_stmt|;
name|args
operator|.
name|s
operator|=
name|uap
operator|->
name|s
expr_stmt|;
name|args
operator|.
name|offset
operator|=
name|uap
operator|->
name|offset
expr_stmt|;
name|args
operator|.
name|nbytes
operator|=
name|uap
operator|->
name|nbytes
expr_stmt|;
name|args
operator|.
name|hdtr
operator|=
name|uap
operator|->
name|hdtr
expr_stmt|;
name|args
operator|.
name|sbytes
operator|=
name|uap
operator|->
name|sbytes
expr_stmt|;
name|args
operator|.
name|flags
operator|=
name|uap
operator|->
name|flags
expr_stmt|;
return|return
operator|(
name|sendfile
argument_list|(
name|td
argument_list|,
operator|&
name|args
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPAT_FREEBSD4 */
end_comment

end_unit

