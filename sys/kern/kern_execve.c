begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989, 1990, 1991, 1992 William F. Jolitz, TeleMuse  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This software is a component of "386BSD" developed by   *	William F. Jolitz, TeleMuse.  * 4. Neither the name of the developer nor the name "386BSD"  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS A COMPONENT OF 386BSD DEVELOPED BY WILLIAM F. JOLITZ   * AND IS INTENDED FOR RESEARCH AND EDUCATIONAL PURPOSES ONLY. THIS   * SOFTWARE SHOULD NOT BE CONSIDERED TO BE A COMMERCIAL PRODUCT.   * THE DEVELOPER URGES THAT USERS WHO REQUIRE A COMMERCIAL PRODUCT   * NOT MAKE USE OF THIS WORK.  *  * FOR USERS WHO WISH TO UNDERSTAND THE 386BSD SYSTEM DEVELOPED  * BY WILLIAM F. JOLITZ, WE RECOMMEND THE USER STUDY WRITTEN   * REFERENCES SUCH AS THE  "PORTING UNIX TO THE 386" SERIES   * (BEGINNING JANUARY 1991 "DR. DOBBS JOURNAL", USA AND BEGINNING   * JUNE 1991 "UNIX MAGAZIN", GERMANY) BY WILLIAM F. JOLITZ AND   * LYNNE GREER JOLITZ, AS WELL AS OTHER BOOKS ON UNIX AND THE   * ON-LINE 386BSD USER MANUAL BEFORE USE. A BOOK DISCUSSING THE INTERNALS   * OF 386BSD ENTITLED "386BSD FROM THE INSIDE OUT" WILL BE AVAILABLE LATE 1992.  *  * THIS SOFTWARE IS PROVIDED BY THE DEVELOPER ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE DEVELOPER BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * This procedure implements a minimal program execution facility for  * 386BSD. It interfaces to the BSD kernel as the execve system call.  * Significant limitations and lack of compatiblity with POSIX are  * present with this version, to make its basic operation more clear.  *  * PATCHES MAGIC                LEVEL   PATCH THAT GOT US HERE  * --------------------         -----   ----------------------  * CURRENT PATCH LEVEL:         6       00165  * --------------------         -----   ----------------------  *  * 05 Aug 92	Paul Kranenburg		Fixed #! as a magic number  * 29 Jul 92	Mark Tinguely		Fixed execute permission enforcement  * 15 Aug 92    Terry Lambert           Fixed CMOS RAM size bug  * 12 Dec 92	Julians Elischer	Place argc into user address space  *					correctly  * 10 Apr 93	Yoval Yarom		Fix for busy text on executables  * 20 Apr 93	markie			Stop execution of a file open for write  *		Rodney W. Grimes	Fix date on Yoval Yarom's patch  * 01 Jun 93	Chris Demetriou		Completed markie's patch for VTEXT busy  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"signalvar.h"
end_include

begin_include
include|#
directive|include
file|"resourcevar.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"mount.h"
end_include

begin_include
include|#
directive|include
file|"namei.h"
end_include

begin_include
include|#
directive|include
file|"vnode.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"exec.h"
end_include

begin_include
include|#
directive|include
file|"stat.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"mman.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm_param.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm_map.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm_kern.h"
end_include

begin_include
include|#
directive|include
file|"machine/reg.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|dostacklimits
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|copyinoutstr
value|copyinstr
end_define

begin_comment
comment|/*  * execve() system call.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|execve
argument_list|(
argument|p
argument_list|,
argument|uap
argument_list|,
argument|retval
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_struct
specifier|register
struct|struct
name|args
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
modifier|*
name|argp
decl_stmt|;
name|char
modifier|*
modifier|*
name|envp
decl_stmt|;
block|}
modifier|*
name|uap
struct|;
end_struct

begin_decl_stmt
name|int
modifier|*
name|retval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nameidata
modifier|*
name|ndp
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|char
modifier|*
modifier|*
name|argbuf
decl_stmt|,
modifier|*
modifier|*
name|argbufp
decl_stmt|,
modifier|*
name|stringbuf
decl_stmt|,
modifier|*
name|stringbufp
decl_stmt|;
name|char
modifier|*
modifier|*
name|vectp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|int
name|needsenv
decl_stmt|,
name|limitonargs
decl_stmt|,
name|stringlen
decl_stmt|,
name|addr
decl_stmt|,
name|size
decl_stmt|,
name|len
decl_stmt|,
name|rv
decl_stmt|,
name|amt
decl_stmt|,
name|argc
decl_stmt|,
name|tsize
decl_stmt|,
name|dsize
decl_stmt|,
name|bsize
decl_stmt|,
name|cnt
decl_stmt|,
name|foff
decl_stmt|;
name|struct
name|vattr
name|attr
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vs
decl_stmt|;
name|caddr_t
name|newframe
decl_stmt|;
name|char
name|shellname
index|[
name|MAXINTERP
index|]
decl_stmt|;
comment|/* 05 Aug 92*/
union|union
block|{
name|char
name|ex_shell
index|[
name|MAXINTERP
index|]
decl_stmt|;
comment|/* #! and interpreter name */
name|struct
name|exec
name|ex_hdr
decl_stmt|;
block|}
name|exdata
union|;
name|int
name|indir
init|=
literal|0
decl_stmt|;
comment|/* 	 * Step 1. Lookup filename to see if we have something to execute. 	 */
name|ndp
operator|=
operator|&
name|nd
expr_stmt|;
name|ndp
operator|->
name|ni_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|ndp
operator|->
name|ni_dirp
operator|=
name|uap
operator|->
name|fname
expr_stmt|;
name|again
label|:
comment|/* 05 Aug 92*/
name|ndp
operator|->
name|ni_nameiop
operator|=
name|LOOKUP
operator||
name|LOCKLEAF
operator||
name|FOLLOW
operator||
name|SAVENAME
expr_stmt|;
comment|/* is it there? */
if|if
condition|(
name|rv
operator|=
name|namei
argument_list|(
name|ndp
argument_list|,
name|p
argument_list|)
condition|)
return|return
operator|(
name|rv
operator|)
return|;
if|if
condition|(
name|ndp
operator|->
name|ni_vp
operator|->
name|v_writecount
condition|)
block|{
comment|/* don't exec if file is busy */
name|rv
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|exec_fail
goto|;
block|}
comment|/* does it have any attributes? */
name|rv
operator|=
name|VOP_GETATTR
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|,
operator|&
name|attr
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
goto|goto
name|exec_fail
goto|;
if|if
condition|(
name|ndp
operator|->
name|ni_vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_NOEXEC
condition|)
block|{
comment|/* no exec on fs ?*/
name|rv
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|exec_fail
goto|;
block|}
comment|/* is it executable, and a regular file? */
if|if
condition|(
operator|(
name|ndp
operator|->
name|ni_vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_NOEXEC
operator|)
operator|||
comment|/* 29 Jul 92*/
operator|(
name|VOP_ACCESS
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|,
name|VEXEC
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|attr
operator|.
name|va_mode
operator|&
literal|0111
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|attr
operator|.
name|va_type
operator|!=
name|VREG
operator|)
condition|)
block|{
name|rv
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|exec_fail
goto|;
block|}
comment|/* 	 * Step 2. Does the file contain a format we can 	 * understand and execute 	 * 	 * XXX 05 Aug 92 	 * Read in first few bytes of file for segment sizes, magic number: 	 *      ZMAGIC = demand paged RO text 	 * Also an ASCII line beginning with #! is 	 * the file name of a ``shell'' and arguments may be prepended 	 * to the argument list if given here. 	 */
name|exdata
operator|.
name|ex_shell
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* for zero length files */
name|rv
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|ndp
operator|->
name|ni_vp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|exdata
argument_list|,
sizeof|sizeof
argument_list|(
name|exdata
argument_list|)
argument_list|,
literal|0
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|amt
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* big enough to hold a header? */
if|if
condition|(
name|rv
condition|)
goto|goto
name|exec_fail
goto|;
if|if
condition|(
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_text
operator|!=
literal|0
operator|&&
operator|(
name|ndp
operator|->
name|ni_vp
operator|->
name|v_flag
operator|&
name|VTEXT
operator|)
operator|==
literal|0
operator|&&
name|ndp
operator|->
name|ni_vp
operator|->
name|v_writecount
operator|!=
literal|0
condition|)
block|{
name|rv
operator|=
name|ETXTBSY
expr_stmt|;
goto|goto
name|exec_fail
goto|;
block|}
comment|/* ... that we recognize? */
name|rv
operator|=
name|ENOEXEC
expr_stmt|;
if|if
condition|(
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_magic
operator|!=
name|ZMAGIC
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|exdata
operator|.
name|ex_shell
index|[
literal|0
index|]
operator|!=
literal|'#'
operator|||
name|exdata
operator|.
name|ex_shell
index|[
literal|1
index|]
operator|!=
literal|'!'
operator|||
name|indir
condition|)
block|{
name|rv
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|exec_fail
goto|;
block|}
for|for
control|(
name|cp
operator|=
operator|&
name|exdata
operator|.
name|ex_shell
index|[
literal|2
index|]
init|;
condition|;
operator|++
name|cp
control|)
block|{
if|if
condition|(
name|cp
operator|>=
operator|&
name|exdata
operator|.
name|ex_shell
index|[
name|MAXINTERP
index|]
condition|)
block|{
name|rv
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|exec_fail
goto|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\t'
condition|)
operator|*
name|cp
operator|=
literal|' '
expr_stmt|;
block|}
name|cp
operator|=
operator|&
name|exdata
operator|.
name|ex_shell
index|[
literal|2
index|]
expr_stmt|;
comment|/* get shell interpreter name */
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
condition|)
name|cp
operator|++
expr_stmt|;
name|sp
operator|=
name|shellname
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|*
name|cp
operator|!=
literal|' '
condition|)
operator|*
name|sp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
operator|*
name|sp
operator|=
literal|'\0'
expr_stmt|;
name|indir
operator|=
literal|1
expr_stmt|;
comment|/* indicate this is a script file */
name|vput
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ndp
operator|->
name|ni_pnbuf
argument_list|,
name|M_NAMEI
argument_list|)
expr_stmt|;
name|ndp
operator|->
name|ni_dirp
operator|=
name|shellname
expr_stmt|;
comment|/* find shell interpreter */
name|ndp
operator|->
name|ni_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* sanity check  "ain't not such thing as a sanity clause" -groucho */
name|rv
operator|=
name|ENOMEM
expr_stmt|;
if|if
condition|(
comment|/*exdata.ex_hdr.a_text == 0 || */
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_text
operator|>
name|MAXTSIZ
operator|||
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_text
operator|%
name|NBPG
operator|||
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_text
operator|>
name|attr
operator|.
name|va_size
condition|)
goto|goto
name|exec_fail
goto|;
if|if
condition|(
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_data
operator|==
literal|0
operator|||
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_data
operator|>
name|DFLDSIZ
operator|||
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_data
operator|>
name|attr
operator|.
name|va_size
operator|||
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_data
operator|+
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_text
operator|>
name|attr
operator|.
name|va_size
condition|)
goto|goto
name|exec_fail
goto|;
if|if
condition|(
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_bss
operator|>
name|MAXDSIZ
condition|)
goto|goto
name|exec_fail
goto|;
if|if
condition|(
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_text
operator|+
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_data
operator|+
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_bss
operator|>
name|MAXTSIZ
operator|+
name|MAXDSIZ
condition|)
goto|goto
name|exec_fail
goto|;
if|if
condition|(
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_data
operator|+
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_bss
operator|>
name|p
operator|->
name|p_rlimit
index|[
name|RLIMIT_DATA
index|]
operator|.
name|rlim_cur
condition|)
goto|goto
name|exec_fail
goto|;
if|if
condition|(
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_entry
operator|>
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_text
operator|+
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_data
condition|)
goto|goto
name|exec_fail
goto|;
comment|/* 	 * Step 3.  File and header are valid. Now, dig out the strings 	 * out of the old process image. 	 */
comment|/* 	 * We implement a single-pass algorithm that builds a new stack 	 * frame within the address space of the "old" process image, 	 * avoiding the second pass entirely. Thus, the new frame is 	 * in position to be run. This consumes much virtual address space, 	 * and two pages more of 'real' memory, such are the costs. 	 * [Also, note the cache wipe that's avoided!] 	 */
comment|/* create anonymous memory region for new stack */
name|vs
operator|=
name|p
operator|->
name|p_vmspace
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|vs
operator|->
name|vm_maxsaddr
operator|+
name|MAXSSIZ
operator|<
name|USRSTACK
condition|)
name|newframe
operator|=
operator|(
name|caddr_t
operator|)
name|USRSTACK
operator|-
name|MAXSSIZ
expr_stmt|;
else|else
name|vs
operator|->
name|vm_maxsaddr
operator|=
name|newframe
operator|=
operator|(
name|caddr_t
operator|)
name|USRSTACK
operator|-
literal|2
operator|*
name|MAXSSIZ
expr_stmt|;
comment|/* don't do stack limit checking on traps temporarily XXX*/
name|dostacklimits
operator|=
literal|0
expr_stmt|;
name|rv
operator|=
name|vm_allocate
argument_list|(
operator|&
name|vs
operator|->
name|vm_map
argument_list|,
operator|&
name|newframe
argument_list|,
name|MAXSSIZ
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
goto|goto
name|exec_fail
goto|;
comment|/* allocate string buffer and arg buffer */
name|argbuf
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|newframe
operator|+
name|MAXSSIZ
operator|-
literal|3
operator|*
name|ARG_MAX
operator|)
expr_stmt|;
name|stringbuf
operator|=
name|stringbufp
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|argbuf
operator|)
operator|+
literal|2
operator|*
name|ARG_MAX
expr_stmt|;
name|argbufp
operator|=
name|argbuf
expr_stmt|;
comment|/* first, do args */
name|vectp
operator|=
name|uap
operator|->
name|argp
expr_stmt|;
name|needsenv
operator|=
literal|1
expr_stmt|;
name|limitonargs
operator|=
name|ARG_MAX
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
comment|/* first, do (shell name if any then) args */
if|if
condition|(
name|indir
condition|)
block|{
name|ep
operator|=
name|shellname
expr_stmt|;
name|twice
label|:
if|if
condition|(
name|ep
condition|)
block|{
comment|/* did we outgrow initial argbuf, if so, die */
if|if
condition|(
name|argbufp
operator|>=
operator|(
name|char
operator|*
operator|*
operator|)
name|stringbuf
condition|)
block|{
name|rv
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|exec_dealloc
goto|;
block|}
if|if
condition|(
name|rv
operator|=
name|copyoutstr
argument_list|(
name|ep
argument_list|,
name|stringbufp
argument_list|,
operator|(
name|u_int
operator|)
name|limitonargs
argument_list|,
operator|(
name|u_int
operator|*
operator|)
operator|&
name|stringlen
argument_list|)
condition|)
block|{
if|if
condition|(
name|rv
operator|==
name|ENAMETOOLONG
condition|)
name|rv
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|exec_dealloc
goto|;
block|}
name|suword
argument_list|(
name|argbufp
operator|++
argument_list|,
operator|(
name|int
operator|)
name|stringbufp
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|stringbufp
operator|+=
name|stringlen
expr_stmt|;
name|limitonargs
operator|-=
name|stringlen
expr_stmt|;
block|}
if|if
condition|(
name|indir
condition|)
block|{
name|indir
operator|=
literal|0
expr_stmt|;
comment|/* orginal executable is 1st argument with scripts */
name|ep
operator|=
name|uap
operator|->
name|fname
expr_stmt|;
goto|goto
name|twice
goto|;
block|}
comment|/* terminate in case no more args to script */
name|suword
argument_list|(
name|argbufp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vectp
operator|=
name|uap
operator|->
name|argp
condition|)
name|vectp
operator|++
expr_stmt|;
comment|/* manually doing the first 						   argument with scripts */
block|}
name|do_env_as_well
label|:
if|if
condition|(
name|vectp
operator|==
literal|0
condition|)
goto|goto
name|dont_bother
goto|;
comment|/* for each envp, copy in string */
do|do
block|{
comment|/* did we outgrow initial argbuf, if so, die */
if|if
condition|(
name|argbufp
operator|==
operator|(
name|char
operator|*
operator|*
operator|)
name|stringbuf
condition|)
block|{
name|rv
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|exec_dealloc
goto|;
block|}
comment|/* get an string pointer */
name|ep
operator|=
operator|(
name|char
operator|*
operator|)
name|fuword
argument_list|(
name|vectp
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
operator|(
name|char
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|rv
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|exec_dealloc
goto|;
block|}
comment|/* if not a null pointer, copy string */
if|if
condition|(
name|ep
condition|)
block|{
if|if
condition|(
name|rv
operator|=
name|copyinoutstr
argument_list|(
name|ep
argument_list|,
name|stringbufp
argument_list|,
operator|(
name|u_int
operator|)
name|limitonargs
argument_list|,
operator|(
name|u_int
operator|*
operator|)
operator|&
name|stringlen
argument_list|)
condition|)
block|{
if|if
condition|(
name|rv
operator|==
name|ENAMETOOLONG
condition|)
name|rv
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|exec_dealloc
goto|;
block|}
name|suword
argument_list|(
name|argbufp
operator|++
argument_list|,
operator|(
name|int
operator|)
name|stringbufp
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|stringbufp
operator|+=
name|stringlen
expr_stmt|;
name|limitonargs
operator|-=
name|stringlen
expr_stmt|;
block|}
else|else
block|{
name|suword
argument_list|(
name|argbufp
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|limitonargs
operator|>
literal|0
condition|)
do|;
name|dont_bother
label|:
if|if
condition|(
name|limitonargs
operator|<=
literal|0
condition|)
block|{
name|rv
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|exec_dealloc
goto|;
block|}
comment|/* have we done the environment yet ? */
if|if
condition|(
name|needsenv
condition|)
block|{
comment|/* remember the arg count for later */
name|argc
operator|=
name|cnt
expr_stmt|;
name|vectp
operator|=
name|uap
operator|->
name|envp
expr_stmt|;
name|needsenv
operator|=
literal|0
expr_stmt|;
goto|goto
name|do_env_as_well
goto|;
block|}
comment|/* At this point, one could optionally implement a 	 * second pass to condense the strings, arguement vectors, 	 * and stack to fit the fewest pages. 	 * 	 * One might selectively do this when copying was cheaper 	 * than leaving allocated two more pages per process. 	 */
comment|/* stuff arg count on top of "new" stack */
comment|/* argbuf[-1] = (char *)argc;*/
name|suword
argument_list|(
name|argbuf
operator|-
literal|1
argument_list|,
name|argc
argument_list|)
expr_stmt|;
comment|/* 	 * Step 4. Build the new processes image. 	 * 	 * At this point, we are committed -- destroy old executable! 	 */
comment|/* blow away all address space, except the stack */
name|rv
operator|=
name|vm_deallocate
argument_list|(
operator|&
name|vs
operator|->
name|vm_map
argument_list|,
literal|0
argument_list|,
name|USRSTACK
operator|-
literal|2
operator|*
name|MAXSSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
goto|goto
name|exec_abort
goto|;
comment|/* destroy "old" stack */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|newframe
operator|<
name|USRSTACK
operator|-
name|MAXSSIZ
condition|)
block|{
name|rv
operator|=
name|vm_deallocate
argument_list|(
operator|&
name|vs
operator|->
name|vm_map
argument_list|,
name|USRSTACK
operator|-
name|MAXSSIZ
argument_list|,
name|MAXSSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
goto|goto
name|exec_abort
goto|;
block|}
else|else
block|{
name|rv
operator|=
name|vm_deallocate
argument_list|(
operator|&
name|vs
operator|->
name|vm_map
argument_list|,
name|USRSTACK
operator|-
literal|2
operator|*
name|MAXSSIZ
argument_list|,
name|MAXSSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
goto|goto
name|exec_abort
goto|;
block|}
comment|/* build a new address space */
name|addr
operator|=
literal|0
expr_stmt|;
comment|/* screwball mode -- special case of 413 to save space for floppy */
if|if
condition|(
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_text
operator|==
literal|0
condition|)
block|{
name|foff
operator|=
name|tsize
operator|=
literal|0
expr_stmt|;
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_data
operator|+=
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_text
expr_stmt|;
block|}
else|else
block|{
name|tsize
operator|=
name|roundup
argument_list|(
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_text
argument_list|,
name|NBPG
argument_list|)
expr_stmt|;
name|foff
operator|=
name|NBPG
expr_stmt|;
block|}
comment|/* treat text and data in terms of integral page size */
name|dsize
operator|=
name|roundup
argument_list|(
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_data
argument_list|,
name|NBPG
argument_list|)
expr_stmt|;
name|bsize
operator|=
name|roundup
argument_list|(
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_bss
operator|+
name|dsize
argument_list|,
name|NBPG
argument_list|)
expr_stmt|;
name|bsize
operator|-=
name|dsize
expr_stmt|;
comment|/* map text& data in file, as being "paged in" on demand */
name|rv
operator|=
name|vm_mmap
argument_list|(
operator|&
name|vs
operator|->
name|vm_map
argument_list|,
operator|&
name|addr
argument_list|,
name|tsize
operator|+
name|dsize
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|MAP_FILE
operator||
name|MAP_COPY
operator||
name|MAP_FIXED
argument_list|,
operator|(
name|caddr_t
operator|)
name|ndp
operator|->
name|ni_vp
argument_list|,
name|foff
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
goto|goto
name|exec_abort
goto|;
comment|/* mark pages r/w data, r/o text */
if|if
condition|(
name|tsize
condition|)
block|{
name|addr
operator|=
literal|0
expr_stmt|;
name|rv
operator|=
name|vm_protect
argument_list|(
operator|&
name|vs
operator|->
name|vm_map
argument_list|,
name|addr
argument_list|,
name|tsize
argument_list|,
name|FALSE
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
goto|goto
name|exec_abort
goto|;
block|}
comment|/* create anonymous memory region for bss */
name|addr
operator|=
name|dsize
operator|+
name|tsize
expr_stmt|;
name|rv
operator|=
name|vm_allocate
argument_list|(
operator|&
name|vs
operator|->
name|vm_map
argument_list|,
operator|&
name|addr
argument_list|,
name|bsize
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
goto|goto
name|exec_abort
goto|;
comment|/* 	 * Step 5. Prepare process for execution. 	 */
comment|/* touchup process information -- vm system is unfinished! */
name|vs
operator|->
name|vm_tsize
operator|=
name|tsize
operator|/
name|NBPG
expr_stmt|;
comment|/* text size (pages) XXX */
name|vs
operator|->
name|vm_dsize
operator|=
operator|(
name|dsize
operator|+
name|bsize
operator|)
operator|/
name|NBPG
expr_stmt|;
comment|/* data size (pages) XXX */
name|vs
operator|->
name|vm_taddr
operator|=
literal|0
expr_stmt|;
comment|/* user virtual address of text XXX */
name|vs
operator|->
name|vm_daddr
operator|=
operator|(
name|caddr_t
operator|)
name|tsize
expr_stmt|;
comment|/* user virtual address of data XXX */
name|vs
operator|->
name|vm_maxsaddr
operator|=
name|newframe
expr_stmt|;
comment|/* user VA at max stack growth XXX */
name|vs
operator|->
name|vm_ssize
operator|=
operator|(
operator|(
name|unsigned
operator|)
name|vs
operator|->
name|vm_maxsaddr
operator|+
name|MAXSSIZ
operator|-
operator|(
name|unsigned
operator|)
name|argbuf
operator|)
operator|/
name|NBPG
operator|+
literal|1
expr_stmt|;
comment|/* stack size (pages) */
name|dostacklimits
operator|=
literal|1
expr_stmt|;
comment|/* allow stack limits to be enforced XXX */
comment|/* close files on exec, fixup signals */
name|fdcloseexec
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|execsigs
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* name this process - nameiexec(p, ndp) */
name|len
operator|=
name|MIN
argument_list|(
name|ndp
operator|->
name|ni_namelen
argument_list|,
name|MAXCOMLEN
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ndp
operator|->
name|ni_ptr
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_comm
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* mark as executable, wakeup any process that was vforked and tell 	 * it that it now has it's own resources back */
name|p
operator|->
name|p_flag
operator||=
name|SEXEC
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_pptr
operator|&&
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SPPWAIT
operator|)
condition|)
block|{
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|SPPWAIT
expr_stmt|;
name|wakeup
argument_list|(
name|p
operator|->
name|p_pptr
argument_list|)
expr_stmt|;
block|}
comment|/* implement set userid/groupid */
if|if
condition|(
operator|(
name|attr
operator|.
name|va_mode
operator|&
name|VSUID
operator|)
operator|&&
operator|(
name|p
operator|->
name|p_flag
operator|&
name|STRC
operator|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|p_ucred
operator|=
name|crcopy
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_cred
operator|->
name|p_svuid
operator|=
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|=
name|attr
operator|.
name|va_uid
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|attr
operator|.
name|va_mode
operator|&
name|VSGID
operator|)
operator|&&
operator|(
name|p
operator|->
name|p_flag
operator|&
name|STRC
operator|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|p_ucred
operator|=
name|crcopy
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_cred
operator|->
name|p_svgid
operator|=
name|p
operator|->
name|p_ucred
operator|->
name|cr_groups
index|[
literal|0
index|]
operator|=
name|attr
operator|.
name|va_gid
expr_stmt|;
block|}
comment|/* setup initial register state */
name|p
operator|->
name|p_regs
index|[
name|SP
index|]
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|argbuf
operator|-
literal|1
argument_list|)
expr_stmt|;
name|setregs
argument_list|(
name|p
argument_list|,
name|exdata
operator|.
name|ex_hdr
operator|.
name|a_entry
argument_list|)
expr_stmt|;
name|ndp
operator|->
name|ni_vp
operator|->
name|v_flag
operator||=
name|VTEXT
expr_stmt|;
comment|/* mark vnode pure text */
name|vput
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ndp
operator|->
name|ni_pnbuf
argument_list|,
name|M_NAMEI
argument_list|)
expr_stmt|;
comment|/* if tracing process, pass control back to debugger so breakpoints 	   can be set before the program "runs" */
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|STRC
condition|)
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGTRAP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|exec_dealloc
label|:
comment|/* remove interim "new" stack frame we were building */
name|vm_deallocate
argument_list|(
operator|&
name|vs
operator|->
name|vm_map
argument_list|,
name|newframe
argument_list|,
name|MAXSSIZ
argument_list|)
expr_stmt|;
name|exec_fail
label|:
name|dostacklimits
operator|=
literal|1
expr_stmt|;
name|vput
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ndp
operator|->
name|ni_pnbuf
argument_list|,
name|M_NAMEI
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
name|exec_abort
label|:
comment|/* sorry, no more process anymore. exit gracefully */
name|vm_deallocate
argument_list|(
operator|&
name|vs
operator|->
name|vm_map
argument_list|,
name|newframe
argument_list|,
name|MAXSSIZ
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ndp
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ndp
operator|->
name|ni_pnbuf
argument_list|,
name|M_NAMEI
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|p
argument_list|,
name|W_EXITCODE
argument_list|(
literal|0
argument_list|,
name|SIGABRT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

end_unit

