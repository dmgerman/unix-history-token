begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992 Terrence R. Lambert.  * Copyright (c) 1994 Christopher G. Demetriou  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Terrence R. Lambert.  * 4. The name Terrence R. Lambert may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED BY TERRENCE R. LAMBERT ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE TERRENCE R. LAMBERT BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * XXX it's not really safe to unload *any* of the types which are  * currently loadable; e.g. you could unload a syscall which was being  * blocked in, etc.  In the long term, a solution should be come up  * with, but "not right now." -- cgd  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact.h>
end_include

begin_include
include|#
directive|include
file|<sys/lkm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_define
define|#
directive|define
name|PAGESIZE
value|1024
end_define

begin_comment
comment|/* kmem_alloc() allocation quantum */
end_comment

begin_define
define|#
directive|define
name|LKM_ALLOC
value|0x01
end_define

begin_define
define|#
directive|define
name|LKM_WANT
value|0x02
end_define

begin_define
define|#
directive|define
name|LKMS_IDLE
value|0x00
end_define

begin_define
define|#
directive|define
name|LKMS_RESERVED
value|0x01
end_define

begin_define
define|#
directive|define
name|LKMS_LOADING
value|0x02
end_define

begin_define
define|#
directive|define
name|LKMS_LOADED
value|0x04
end_define

begin_define
define|#
directive|define
name|LKMS_UNLOADING
value|0x08
end_define

begin_decl_stmt
specifier|static
name|int
name|lkm_v
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lkm_state
init|=
name|LKMS_IDLE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|modname
index|[
name|MAXLKMNAME
index|]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MAXLKMS
end_ifndef

begin_define
define|#
directive|define
name|MAXLKMS
value|20
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|lkm_table
name|lkmods
index|[
name|MAXLKMS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of loaded modules */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|lkm_table
modifier|*
name|curp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global for in-progress ops */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|lkmcopen
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|devtype
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|devtype
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* bad minor # */
comment|/* 	 * Use of the loadable kernel module device must be exclusive; we 	 * may try to remove this restriction later, but it's really no 	 * hardship. 	 */
while|while
condition|(
name|lkm_v
operator|&
name|LKM_ALLOC
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|FNONBLOCK
condition|)
comment|/* don't hang */
return|return
operator|(
name|EBUSY
operator|)
return|;
name|lkm_v
operator||=
name|LKM_WANT
expr_stmt|;
comment|/* 		 * Sleep pending unlock; we use tsleep() to allow 		 * an alarm out of the open. 		 */
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lkm_v
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"lkmopn"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* leave LKM_WANT set -- no problem */
block|}
name|lkm_v
operator||=
name|LKM_ALLOC
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* pseudo-device open */
block|}
end_function

begin_comment
comment|/*  * Unreserve the memory associated with the current loaded module; done on  * a coerced close of the lkm device (close on premature exit of modload)  * or explicitly by modload as a result of a link failure.  */
end_comment

begin_function
specifier|static
name|void
name|lkmunreserve
parameter_list|()
block|{
if|if
condition|(
name|lkm_state
operator|==
name|LKMS_IDLE
condition|)
return|return;
comment|/* 	 * Actually unreserve the memory 	 */
if|if
condition|(
name|curp
operator|&&
name|curp
operator|->
name|area
condition|)
block|{
name|kmem_free
argument_list|(
name|kmem_map
argument_list|,
name|curp
operator|->
name|area
argument_list|,
name|curp
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/**/
name|curp
operator|->
name|area
operator|=
literal|0
expr_stmt|;
name|curp
operator|->
name|private
operator|.
name|lkm_any
operator|=
name|NULL
expr_stmt|;
block|}
name|lkm_state
operator|=
name|LKMS_IDLE
expr_stmt|;
block|}
end_function

begin_function
name|int
name|lkmcclose
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|(
name|lkm_v
operator|&
name|LKM_ALLOC
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"LKM: close before open!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
comment|/* do this before waking the herd... */
if|if
condition|(
name|curp
operator|&&
operator|!
name|curp
operator|->
name|used
condition|)
block|{
comment|/* 		 * If we close before setting used, we have aborted 		 * by way of error or by way of close-on-exit from 		 * a premature exit of "modload". 		 */
name|lkmunreserve
argument_list|()
expr_stmt|;
comment|/* coerce state to LKM_IDLE */
block|}
name|lkm_v
operator|&=
operator|~
name|LKM_ALLOC
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lkm_v
argument_list|)
expr_stmt|;
comment|/* thundering herd "problem" here */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* pseudo-device closed */
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|lkmcioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|lmc_resrv
modifier|*
name|resrvp
decl_stmt|;
name|struct
name|lmc_loadbuf
modifier|*
name|loadbufp
decl_stmt|;
name|struct
name|lmc_unload
modifier|*
name|unloadp
decl_stmt|;
name|struct
name|lmc_stat
modifier|*
name|statp
decl_stmt|;
name|char
name|istr
index|[
name|MAXLKMNAME
index|]
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|LMRESERV
case|:
comment|/* reserve pages for a module */
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
comment|/* only allow this if writing */
return|return
name|EPERM
return|;
name|resrvp
operator|=
operator|(
expr|struct
name|lmc_resrv
operator|*
operator|)
name|data
expr_stmt|;
comment|/* 		 * Find a free slot. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXLKMS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|lkmods
index|[
name|i
index|]
operator|.
name|used
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|MAXLKMS
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
comment|/* no slots available */
break|break;
block|}
name|curp
operator|=
operator|&
name|lkmods
index|[
name|i
index|]
expr_stmt|;
name|curp
operator|->
name|id
operator|=
name|i
expr_stmt|;
comment|/* self reference slot offset */
name|resrvp
operator|->
name|slot
operator|=
name|i
expr_stmt|;
comment|/* return slot */
comment|/* 		 * Get memory for module 		 */
name|curp
operator|->
name|size
operator|=
name|resrvp
operator|->
name|size
expr_stmt|;
comment|/* XXX RIXME: Save the module name for sanity checking. */
name|strcpy
argument_list|(
name|modname
argument_list|,
name|resrvp
operator|->
name|name
argument_list|)
expr_stmt|;
name|curp
operator|->
name|area
operator|=
name|kmem_alloc
argument_list|(
name|kmem_map
argument_list|,
name|curp
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/**/
name|curp
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* load offset */
name|resrvp
operator|->
name|addr
operator|=
name|curp
operator|->
name|area
expr_stmt|;
comment|/* ret kernel addr */
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"LKM: LMRESERV (actual   = 0x%08x)\n"
argument_list|,
name|curp
operator|->
name|area
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"LKM: LMRESERV (adjusted = 0x%08x)\n"
argument_list|,
name|trunc_page
argument_list|(
name|curp
operator|->
name|area
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|lkm_state
operator|=
name|LKMS_RESERVED
expr_stmt|;
break|break;
case|case
name|LMLOADBUF
case|:
comment|/* Copy in; stateful, follows LMRESERV */
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
comment|/* only allow this if writing */
return|return
name|EPERM
return|;
name|loadbufp
operator|=
operator|(
expr|struct
name|lmc_loadbuf
operator|*
operator|)
name|data
expr_stmt|;
name|i
operator|=
name|loadbufp
operator|->
name|cnt
expr_stmt|;
if|if
condition|(
operator|(
name|lkm_state
operator|!=
name|LKMS_RESERVED
operator|&&
name|lkm_state
operator|!=
name|LKMS_LOADING
operator|)
operator|||
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|MODIOBUF
operator|||
name|i
operator|>
name|curp
operator|->
name|size
operator|-
name|curp
operator|->
name|offset
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
comment|/* copy in buffer full of data */
name|err
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|loadbufp
operator|->
name|data
argument_list|,
operator|(
name|caddr_t
operator|)
name|curp
operator|->
name|area
operator|+
name|curp
operator|->
name|offset
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
if|if
condition|(
operator|(
name|curp
operator|->
name|offset
operator|+
name|i
operator|)
operator|<
name|curp
operator|->
name|size
condition|)
block|{
name|lkm_state
operator|=
name|LKMS_LOADING
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"LKM: LMLOADBUF (loading @ %d of %d, i = %d)\n"
argument_list|,
name|curp
operator|->
name|offset
argument_list|,
name|curp
operator|->
name|size
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
else|else
block|{
name|lkm_state
operator|=
name|LKMS_LOADED
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"LKM: LMLOADBUF (loaded)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
name|curp
operator|->
name|offset
operator|+=
name|i
expr_stmt|;
break|break;
case|case
name|LMUNRESRV
case|:
comment|/* discard reserved pages for a module */
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
comment|/* only allow this if writing */
return|return
name|EPERM
return|;
name|lkmunreserve
argument_list|()
expr_stmt|;
comment|/* coerce state to LKM_IDLE */
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"LKM: LMUNRESERV\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
break|break;
case|case
name|LMREADY
case|:
comment|/* module loaded: call entry */
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
comment|/* only allow this if writing */
return|return
name|EPERM
return|;
switch|switch
condition|(
name|lkm_state
condition|)
block|{
case|case
name|LKMS_LOADED
case|:
break|break;
case|case
name|LKMS_LOADING
case|:
comment|/* The remainder must be bss, so we clear it */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|curp
operator|->
name|area
operator|+
name|curp
operator|->
name|offset
argument_list|,
name|curp
operator|->
name|size
operator|-
name|curp
operator|->
name|offset
argument_list|)
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"lkm_state is %02x\n"
argument_list|,
name|lkm_state
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
name|ENXIO
return|;
block|}
comment|/* 		 * Check that this isn't a duplicate module (broken 		 * modules are too stupid to check this for 		 * themselves). We must do this *BEFORE* we call 		 * the entry point of the module, since we might 		 * be able to unload the module aftwewards without 		 * panicking the system. This defeats the purpose of 		 * the lkmexists() checking that takes place for 		 * properly designed modules, but I can't find a better 		 * way to do it, so... 		 * XXX FIXME: Name matching can easily be defeated if 		 * the user renames the module. :( 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXLKMS
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|lkmods
index|[
name|j
index|]
operator|.
name|used
operator|||
operator|&
name|lkmods
index|[
name|j
index|]
operator|==
name|curp
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|modname
argument_list|,
name|lkmods
index|[
name|j
index|]
operator|.
name|private
operator|.
name|lkm_any
operator|->
name|lkm_name
argument_list|)
condition|)
block|{
name|lkm_state
operator|=
name|LKMS_UNLOADING
expr_stmt|;
name|lkmunreserve
argument_list|()
expr_stmt|;
name|curp
operator|->
name|used
operator|=
literal|0
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
block|}
name|curp
operator|->
name|entry
operator|=
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|(
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
operator|(
name|data
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* call entry(load)... (assigns "private" portion) */
name|err
operator|=
operator|(
operator|*
operator|(
name|curp
operator|->
name|entry
operator|)
operator|)
operator|(
name|curp
operator|,
name|LKM_E_LOAD
operator|,
name|LKM_VERSION
operator|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* 			 * Module may refuse loading or may have a 			 * version mismatch... 			 */
name|lkm_state
operator|=
name|LKMS_UNLOADING
expr_stmt|;
comment|/* for lkmunreserve */
name|lkmunreserve
argument_list|()
expr_stmt|;
comment|/* free memory */
name|curp
operator|->
name|used
operator|=
literal|0
expr_stmt|;
comment|/* free slot */
break|break;
block|}
comment|/* 		 * XXX FIXME: Somebody has apparently decided that we can 		 * load modules that don't play by the rules, which means 		 * they have no proper startup and shutdown routines, 		 * and consequently they have no 'private' sections. 		 * This is bad ju-ju: no private section means no lkm_name, 		 * and no lkm_name means modstat will panic us. To 		 * protect ourselves, we have to dummy up an lkm_any 		 * structure by ourselves. 		 */
if|if
condition|(
name|curp
operator|->
name|private
operator|.
name|lkm_any
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
comment|/* chastise the module programmer for being a dolt */
name|printf
argument_list|(
literal|"warning: module #%d has no 'private' data!\n"
argument_list|,
name|curp
operator|->
name|id
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We lose some memory here, but we can't unload 			   this module anyway, so what the hell. */
name|curp
operator|->
name|private
operator|.
name|lkm_any
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lkm_any
argument_list|)
argument_list|,
name|M_IOCTLOPS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* This is all thoroughly bogus, 			   but it's better than a panic. */
name|curp
operator|->
name|private
operator|.
name|lkm_any
operator|->
name|lkm_offset
operator|=
literal|0
expr_stmt|;
name|curp
operator|->
name|private
operator|.
name|lkm_any
operator|->
name|lkm_ver
operator|=
name|LKM_VERSION
expr_stmt|;
name|curp
operator|->
name|private
operator|.
name|lkm_any
operator|->
name|lkm_type
operator|=
name|LM_UNKNOWN
expr_stmt|;
name|curp
operator|->
name|private
operator|.
name|lkm_any
operator|->
name|lkm_name
operator|=
name|malloc
argument_list|(
name|MAXLKMNAME
argument_list|,
name|M_IOCTLOPS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|curp
operator|->
name|private
operator|.
name|lkm_any
operator|->
name|lkm_name
argument_list|,
name|modname
argument_list|)
expr_stmt|;
block|}
name|curp
operator|->
name|used
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"LKM: LMREADY\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|lkm_state
operator|=
name|LKMS_IDLE
expr_stmt|;
break|break;
case|case
name|LMUNLOAD
case|:
comment|/* unload a module */
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
condition|)
comment|/* only allow this if writing */
return|return
name|EPERM
return|;
name|unloadp
operator|=
operator|(
expr|struct
name|lmc_unload
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|unloadp
operator|->
name|id
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* unload by name */
comment|/* 			 * Copy name and lookup id from all loaded 			 * modules.  May fail. 			 */
name|err
operator|=
name|copyinstr
argument_list|(
name|unloadp
operator|->
name|name
argument_list|,
name|istr
argument_list|,
name|MAXLKMNAME
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
comment|/* 			 * look up id... 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXLKMS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|lkmods
index|[
name|i
index|]
operator|.
name|used
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|istr
argument_list|,
name|lkmods
index|[
name|i
index|]
operator|.
name|private
operator|.
name|lkm_any
operator|->
name|lkm_name
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* 		 * Range check the value; on failure, return EINVAL 		 */
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|MAXLKMS
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|curp
operator|=
operator|&
name|lkmods
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|curp
operator|->
name|used
condition|)
block|{
name|err
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
comment|/* 		 * XXX FIXME: Remember those modules without the 'private' 		 * sections? Don't even *think* about unloading them. 		 */
if|if
condition|(
name|curp
operator|->
name|private
operator|.
name|lkm_any
operator|->
name|lkm_type
operator|==
name|LM_UNKNOWN
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
comment|/* abuse the module programmer again. */
name|printf
argument_list|(
literal|"warning: module #%d can't be unloaded!\n"
argument_list|,
name|curp
operator|->
name|id
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|err
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* call entry(unload) */
if|if
condition|(
operator|(
operator|*
operator|(
name|curp
operator|->
name|entry
operator|)
operator|)
operator|(
name|curp
operator|,
name|LKM_E_UNLOAD
operator|,
name|LKM_VERSION
operator|)
condition|)
block|{
name|err
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
block|}
name|lkm_state
operator|=
name|LKMS_UNLOADING
expr_stmt|;
comment|/* non-idle for lkmunreserve */
name|lkmunreserve
argument_list|()
expr_stmt|;
comment|/* free memory */
name|curp
operator|->
name|used
operator|=
literal|0
expr_stmt|;
comment|/* free slot */
break|break;
case|case
name|LMSTAT
case|:
comment|/* stat a module by id/name */
comment|/* allow readers and writers to stat */
name|statp
operator|=
operator|(
expr|struct
name|lmc_stat
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|statp
operator|->
name|id
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* stat by name */
comment|/* 			 * Copy name and lookup id from all loaded 			 * modules. 			 */
name|copystr
argument_list|(
name|statp
operator|->
name|name
argument_list|,
name|istr
argument_list|,
name|MAXLKMNAME
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * look up id... 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXLKMS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|lkmods
index|[
name|i
index|]
operator|.
name|used
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|istr
argument_list|,
name|lkmods
index|[
name|i
index|]
operator|.
name|private
operator|.
name|lkm_any
operator|->
name|lkm_name
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|MAXLKMS
condition|)
block|{
comment|/* Not found */
name|err
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * Range check the value; on failure, return EINVAL 		 */
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|MAXLKMS
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|curp
operator|=
operator|&
name|lkmods
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|curp
operator|->
name|used
condition|)
block|{
comment|/* Not found */
name|err
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
comment|/* 		 * Copy out stat information for this module... 		 */
name|statp
operator|->
name|id
operator|=
name|curp
operator|->
name|id
expr_stmt|;
name|statp
operator|->
name|offset
operator|=
name|curp
operator|->
name|private
operator|.
name|lkm_any
operator|->
name|lkm_offset
expr_stmt|;
name|statp
operator|->
name|type
operator|=
name|curp
operator|->
name|private
operator|.
name|lkm_any
operator|->
name|lkm_type
expr_stmt|;
name|statp
operator|->
name|area
operator|=
name|curp
operator|->
name|area
expr_stmt|;
name|statp
operator|->
name|size
operator|=
name|curp
operator|->
name|size
operator|/
name|PAGESIZE
expr_stmt|;
name|statp
operator|->
name|private
operator|=
operator|(
name|unsigned
name|long
operator|)
name|curp
operator|->
name|private
operator|.
name|lkm_any
expr_stmt|;
name|statp
operator|->
name|ver
operator|=
name|curp
operator|->
name|private
operator|.
name|lkm_any
operator|->
name|lkm_ver
expr_stmt|;
name|copystr
argument_list|(
name|curp
operator|->
name|private
operator|.
name|lkm_any
operator|->
name|lkm_name
argument_list|,
name|statp
operator|->
name|name
argument_list|,
name|MAXLKMNAME
operator|-
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* bad ioctl()... */
name|err
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Acts like "nosys" but can be identified in sysent for dynamic call  * number assignment for a limited number of calls.  *  * Place holder for system call slots reserved for loadable modules.  */
end_comment

begin_function
name|int
name|lkmnosys
parameter_list|()
block|{
return|return
operator|(
name|nosys
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Acts like "enodev", but can be identified in cdevsw and bdevsw for  * dynamic driver major number assignment for a limited number of  * drivers.  *  * Place holder for device switch slots reserved for loadable modules.  */
end_comment

begin_function
name|int
name|lkmenodev
parameter_list|()
block|{
return|return
operator|(
name|enodev
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lkmexists
parameter_list|(
name|lkmtp
parameter_list|)
name|struct
name|lkm_table
modifier|*
name|lkmtp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * see if name exists... 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXLKMS
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * An unused module and the one we are testing are not 		 * considered. 		 */
if|if
condition|(
operator|!
name|lkmods
index|[
name|i
index|]
operator|.
name|used
operator|||
operator|&
name|lkmods
index|[
name|i
index|]
operator|==
name|lkmtp
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|lkmtp
operator|->
name|private
operator|.
name|lkm_any
operator|->
name|lkm_name
argument_list|,
name|lkmods
index|[
name|i
index|]
operator|.
name|private
operator|.
name|lkm_any
operator|->
name|lkm_name
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* already loaded... */
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* module not loaded... */
block|}
end_function

begin_comment
comment|/*  * For the loadable system call described by the structure pointed to  * by lkmtp, load/unload/stat it depending on the cmd requested.  */
end_comment

begin_function
specifier|static
name|int
name|_lkm_syscall
parameter_list|(
name|lkmtp
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|lkm_table
modifier|*
name|lkmtp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
block|{
name|struct
name|lkm_syscall
modifier|*
name|args
init|=
name|lkmtp
operator|->
name|private
operator|.
name|lkm_syscall
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|LKM_E_LOAD
case|:
comment|/* don't load twice! */
if|if
condition|(
name|lkmexists
argument_list|(
name|lkmtp
argument_list|)
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
if|if
condition|(
operator|(
name|i
operator|=
name|args
operator|->
name|lkm_offset
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* auto */
comment|/* 			 * Search the table looking for a slot... 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|aout_sysvec
operator|.
name|sv_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|aout_sysvec
operator|.
name|sv_table
index|[
name|i
index|]
operator|.
name|sy_call
operator|==
name|lkmnosys
condition|)
break|break;
comment|/* found it! */
comment|/* out of allocable slots? */
if|if
condition|(
name|i
operator|==
name|aout_sysvec
operator|.
name|sv_size
condition|)
block|{
name|err
operator|=
name|ENFILE
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* assign */
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|aout_sysvec
operator|.
name|sv_size
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
comment|/* save old */
name|bcopy
argument_list|(
operator|&
name|aout_sysvec
operator|.
name|sv_table
index|[
name|i
index|]
argument_list|,
operator|&
operator|(
name|args
operator|->
name|lkm_oldent
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sysent
argument_list|)
argument_list|)
expr_stmt|;
comment|/* replace with new */
name|bcopy
argument_list|(
name|args
operator|->
name|lkm_sysent
argument_list|,
operator|&
name|aout_sysvec
operator|.
name|sv_table
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sysent
argument_list|)
argument_list|)
expr_stmt|;
comment|/* done! */
name|args
operator|->
name|lkm_offset
operator|=
name|i
expr_stmt|;
comment|/* slot in sysent[] */
break|break;
case|case
name|LKM_E_UNLOAD
case|:
comment|/* current slot... */
name|i
operator|=
name|args
operator|->
name|lkm_offset
expr_stmt|;
comment|/* replace current slot contents with old contents */
name|bcopy
argument_list|(
operator|&
operator|(
name|args
operator|->
name|lkm_oldent
operator|)
argument_list|,
operator|&
name|aout_sysvec
operator|.
name|sv_table
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sysent
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LKM_E_STAT
case|:
comment|/* no special handling... */
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For the loadable virtual file system described by the structure pointed  * to by lkmtp, load/unload/stat it depending on the cmd requested.  */
end_comment

begin_function
specifier|static
name|int
name|_lkm_vfs
parameter_list|(
name|lkmtp
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|lkm_table
modifier|*
name|lkmtp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
block|{
name|struct
name|lkm_vfs
modifier|*
name|args
init|=
name|lkmtp
operator|->
name|private
operator|.
name|lkm_vfs
decl_stmt|;
name|struct
name|vfsconf
modifier|*
name|vfc
init|=
name|args
operator|->
name|lkm_vfsconf
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|LKM_E_LOAD
case|:
comment|/* don't load twice! */
if|if
condition|(
name|lkmexists
argument_list|(
name|lkmtp
argument_list|)
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MOUNT_MAXTYPE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|vfc
operator|->
name|vfc_name
argument_list|,
name|vfsconf
index|[
name|i
index|]
operator|->
name|vfc_name
argument_list|)
condition|)
block|{
return|return
name|EEXIST
return|;
block|}
block|}
name|i
operator|=
name|args
operator|->
name|lkm_offset
operator|=
name|vfc
operator|->
name|vfc_index
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|MOUNT_MAXTYPE
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|vfsconf
index|[
name|i
index|]
operator|==
operator|&
name|void_vfsconf
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
name|args
operator|->
name|lkm_offset
operator|=
name|vfc
operator|->
name|vfc_index
operator|=
name|i
expr_stmt|;
name|vfsconf
index|[
name|i
index|]
operator|=
name|vfc
expr_stmt|;
name|vfssw
index|[
name|i
index|]
operator|=
name|vfc
operator|->
name|vfc_vfsops
expr_stmt|;
comment|/* like in vfs_op_init */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|args
operator|->
name|lkm_vnodeops
operator|->
name|ls_items
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|vnodeopv_desc
modifier|*
name|opv
init|=
operator|(
expr|struct
name|vnodeopv_desc
operator|*
operator|)
name|args
operator|->
name|lkm_vnodeops
operator|->
name|ls_items
index|[
name|i
index|]
decl_stmt|;
operator|*
operator|(
name|opv
operator|->
name|opv_desc_vector_p
operator|)
operator|=
name|NULL
expr_stmt|;
block|}
name|vfs_opv_init
argument_list|(
operator|(
expr|struct
name|vnodeopv_desc
operator|*
operator|*
operator|)
name|args
operator|->
name|lkm_vnodeops
operator|->
name|ls_items
argument_list|)
expr_stmt|;
comment|/* 		 * Call init function for this VFS... 		 */
operator|(
operator|*
operator|(
name|vfssw
index|[
name|vfc
operator|->
name|vfc_index
index|]
operator|->
name|vfs_init
operator|)
operator|)
operator|(
operator|)
expr_stmt|;
comment|/* done! */
break|break;
case|case
name|LKM_E_UNLOAD
case|:
comment|/* current slot... */
name|i
operator|=
name|args
operator|->
name|lkm_offset
expr_stmt|;
if|if
condition|(
name|vfsconf
index|[
name|i
index|]
operator|->
name|vfc_refcount
condition|)
block|{
return|return
name|EBUSY
return|;
block|}
comment|/* replace current slot contents with old contents */
name|vfssw
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|vfsops
operator|*
operator|)
literal|0
expr_stmt|;
name|vfsconf
index|[
name|i
index|]
operator|=
operator|&
name|void_vfsconf
expr_stmt|;
break|break;
case|case
name|LKM_E_STAT
case|:
comment|/* no special handling... */
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For the loadable device driver described by the structure pointed to  * by lkmtp, load/unload/stat it depending on the cmd requested.  */
end_comment

begin_function
specifier|static
name|int
name|_lkm_dev
parameter_list|(
name|lkmtp
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|lkm_table
modifier|*
name|lkmtp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
block|{
name|struct
name|lkm_dev
modifier|*
name|args
init|=
name|lkmtp
operator|->
name|private
operator|.
name|lkm_dev
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|LKM_E_LOAD
case|:
comment|/* don't load twice! */
if|if
condition|(
name|lkmexists
argument_list|(
name|lkmtp
argument_list|)
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
switch|switch
condition|(
name|args
operator|->
name|lkm_devtype
condition|)
block|{
case|case
name|LM_DT_BLOCK
case|:
if|if
condition|(
operator|(
name|i
operator|=
name|args
operator|->
name|lkm_offset
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* auto */
comment|/* 				 * Search the table looking for a slot... 				 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nblkdev
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|bdevsw
index|[
name|i
index|]
operator|.
name|d_open
operator|==
name|lkmenodev
condition|)
break|break;
comment|/* found it! */
comment|/* out of allocable slots? */
if|if
condition|(
name|i
operator|==
name|nblkdev
condition|)
block|{
name|err
operator|=
name|ENFILE
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* assign */
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|nblkdev
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
comment|/* save old */
name|bcopy
argument_list|(
operator|&
name|bdevsw
index|[
name|i
index|]
argument_list|,
operator|&
operator|(
name|args
operator|->
name|lkm_olddev
operator|.
name|bdev
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bdevsw
argument_list|)
argument_list|)
expr_stmt|;
comment|/* replace with new */
name|bcopy
argument_list|(
name|args
operator|->
name|lkm_dev
operator|.
name|bdev
argument_list|,
operator|&
name|bdevsw
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bdevsw
argument_list|)
argument_list|)
expr_stmt|;
comment|/* done! */
name|args
operator|->
name|lkm_offset
operator|=
name|i
expr_stmt|;
comment|/* slot in bdevsw[] */
break|break;
case|case
name|LM_DT_CHAR
case|:
if|if
condition|(
operator|(
name|i
operator|=
name|args
operator|->
name|lkm_offset
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* auto */
comment|/* 				 * Search the table looking for a slot... 				 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchrdev
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cdevsw
index|[
name|i
index|]
operator|.
name|d_open
operator|==
name|lkmenodev
condition|)
break|break;
comment|/* found it! */
comment|/* out of allocable slots? */
if|if
condition|(
name|i
operator|==
name|nchrdev
condition|)
block|{
name|err
operator|=
name|ENFILE
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* assign */
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|nchrdev
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
comment|/* save old */
name|bcopy
argument_list|(
operator|&
name|cdevsw
index|[
name|i
index|]
argument_list|,
operator|&
operator|(
name|args
operator|->
name|lkm_olddev
operator|.
name|cdev
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cdevsw
argument_list|)
argument_list|)
expr_stmt|;
comment|/* replace with new */
name|bcopy
argument_list|(
name|args
operator|->
name|lkm_dev
operator|.
name|cdev
argument_list|,
operator|&
name|cdevsw
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cdevsw
argument_list|)
argument_list|)
expr_stmt|;
comment|/* done! */
name|args
operator|->
name|lkm_offset
operator|=
name|i
expr_stmt|;
comment|/* slot in cdevsw[] */
break|break;
default|default:
name|err
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|LKM_E_UNLOAD
case|:
comment|/* current slot... */
name|i
operator|=
name|args
operator|->
name|lkm_offset
expr_stmt|;
switch|switch
condition|(
name|args
operator|->
name|lkm_devtype
condition|)
block|{
case|case
name|LM_DT_BLOCK
case|:
comment|/* replace current slot contents with old contents */
name|bcopy
argument_list|(
operator|&
operator|(
name|args
operator|->
name|lkm_olddev
operator|.
name|bdev
operator|)
argument_list|,
operator|&
name|bdevsw
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bdevsw
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LM_DT_CHAR
case|:
comment|/* replace current slot contents with old contents */
name|bcopy
argument_list|(
operator|&
operator|(
name|args
operator|->
name|lkm_olddev
operator|.
name|cdev
operator|)
argument_list|,
operator|&
name|cdevsw
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cdevsw
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|LKM_E_STAT
case|:
comment|/* no special handling... */
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|STREAMS
end_ifdef

begin_comment
comment|/*  * For the loadable streams module described by the structure pointed to  * by lkmtp, load/unload/stat it depending on the cmd requested.  */
end_comment

begin_function
specifier|static
name|int
name|_lkm_strmod
parameter_list|(
name|lkmtp
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|lkm_table
modifier|*
name|lkmtp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
block|{
name|struct
name|lkm_strmod
modifier|*
name|args
init|=
name|lkmtp
operator|->
name|private
operator|.
name|lkm_strmod
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|LKM_E_LOAD
case|:
comment|/* don't load twice! */
if|if
condition|(
name|lkmexists
argument_list|(
name|lkmtp
argument_list|)
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
break|break;
case|case
name|LKM_E_UNLOAD
case|:
break|break;
case|case
name|LKM_E_STAT
case|:
comment|/* no special handling... */
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STREAMS */
end_comment

begin_comment
comment|/*  * For the loadable execution class described by the structure pointed to  * by lkmtp, load/unload/stat it depending on the cmd requested.  */
end_comment

begin_function
specifier|static
name|int
name|_lkm_exec
parameter_list|(
name|lkmtp
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|lkm_table
modifier|*
name|lkmtp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
block|{
name|struct
name|lkm_exec
modifier|*
name|args
init|=
name|lkmtp
operator|->
name|private
operator|.
name|lkm_exec
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|execsw
modifier|*
modifier|*
name|execsw
init|=
operator|(
specifier|const
expr|struct
name|execsw
operator|*
operator|*
operator|)
operator|&
name|execsw_set
operator|.
name|ls_items
index|[
literal|0
index|]
decl_stmt|;
if|#
directive|if
literal|1
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|LKM_E_LOAD
case|:
comment|/* don't load twice! */
if|if
condition|(
name|lkmexists
argument_list|(
name|lkmtp
argument_list|)
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
if|if
condition|(
operator|(
name|i
operator|=
name|args
operator|->
name|lkm_offset
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* auto */
comment|/* 			 * Search the table looking for a slot... 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|execsw
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|execsw
index|[
name|i
index|]
operator|->
name|ex_imgact
operator|==
name|NULL
condition|)
break|break;
comment|/* found it! */
comment|/* out of allocable slots? */
if|if
condition|(
name|execsw
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENFILE
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* assign */
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* save old */
name|bcopy
argument_list|(
operator|&
name|execsw
index|[
name|i
index|]
argument_list|,
operator|&
operator|(
name|args
operator|->
name|lkm_oldexec
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|execsw
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* replace with new */
name|bcopy
argument_list|(
operator|&
operator|(
name|args
operator|->
name|lkm_exec
operator|)
argument_list|,
operator|&
name|execsw
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|execsw
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* done! */
name|args
operator|->
name|lkm_offset
operator|=
name|i
expr_stmt|;
comment|/* slot in execsw[] */
break|break;
case|case
name|LKM_E_UNLOAD
case|:
comment|/* current slot... */
name|i
operator|=
name|args
operator|->
name|lkm_offset
expr_stmt|;
comment|/* replace current slot contents with old contents */
name|bcopy
argument_list|(
operator|&
operator|(
name|args
operator|->
name|lkm_oldexec
operator|)
argument_list|,
operator|&
name|execsw
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|execsw
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LKM_E_STAT
case|:
comment|/* no special handling... */
break|break;
block|}
else|#
directive|else
name|err
operator|=
name|EINVAL
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|execsw
name|lkm_exec_dummy
init|=
block|{
name|NULL
block|,
literal|"lkm"
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TEXT_SET
argument_list|(
name|execsw_set
argument_list|,
name|lkm_exec_dummy
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TEXT_SET
argument_list|(
name|execsw_set
argument_list|,
name|lkm_exec_dummy
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TEXT_SET
argument_list|(
name|execsw_set
argument_list|,
name|lkm_exec_dummy
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TEXT_SET
argument_list|(
name|execsw_set
argument_list|,
name|lkm_exec_dummy
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This code handles the per-module type "wiring-in" of loadable modules  * into existing kernel tables.  For "LM_MISC" modules, wiring and unwiring  * is assumed to be done in their entry routines internal to the module  * itself.  */
end_comment

begin_function
name|int
name|lkmdispatch
parameter_list|(
name|lkmtp
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|lkm_table
modifier|*
name|lkmtp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* default = success */
switch|switch
condition|(
name|lkmtp
operator|->
name|private
operator|.
name|lkm_any
operator|->
name|lkm_type
condition|)
block|{
case|case
name|LM_SYSCALL
case|:
name|err
operator|=
name|_lkm_syscall
argument_list|(
name|lkmtp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|LM_VFS
case|:
name|err
operator|=
name|_lkm_vfs
argument_list|(
name|lkmtp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|LM_DEV
case|:
name|err
operator|=
name|_lkm_dev
argument_list|(
name|lkmtp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|STREAMS
case|case
name|LM_STRMOD
case|:
block|{
name|struct
name|lkm_strmod
modifier|*
name|args
init|=
name|lkmtp
operator|->
name|private
operator|.
name|lkm_strmod
decl_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* STREAMS */
case|case
name|LM_EXEC
case|:
name|err
operator|=
name|_lkm_exec
argument_list|(
name|lkmtp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|LM_MISC
case|:
comment|/* ignore content -- no "misc-specific" procedure */
if|if
condition|(
name|lkmexists
argument_list|(
name|lkmtp
argument_list|)
condition|)
name|err
operator|=
name|EEXIST
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|ENXIO
expr_stmt|;
comment|/* unknown type */
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

