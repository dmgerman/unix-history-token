begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992 Terrence R. Lambert.  * Copyright (c) 1994 Christopher G. Demetriou  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Terrence R. Lambert.  * 4. The name Terrence R. Lambert may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED BY TERRENCE R. LAMBERT ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE TERRENCE R. LAMBERT BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: kern_lkm.c,v 1.44 1997/10/28 15:58:15 bde Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/lkm.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEVFS*/
end_comment

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_define
define|#
directive|define
name|PAGESIZE
value|1024
end_define

begin_comment
comment|/* kmem_alloc() allocation quantum */
end_comment

begin_define
define|#
directive|define
name|LKM_ALLOC
value|0x01
end_define

begin_define
define|#
directive|define
name|LKM_WANT
value|0x02
end_define

begin_define
define|#
directive|define
name|LKMS_IDLE
value|0x00
end_define

begin_define
define|#
directive|define
name|LKMS_RESERVED
value|0x01
end_define

begin_define
define|#
directive|define
name|LKMS_LOADING
value|0x02
end_define

begin_define
define|#
directive|define
name|LKMS_LOADED
value|0x04
end_define

begin_define
define|#
directive|define
name|LKMS_UNLOADING
value|0x08
end_define

begin_decl_stmt
specifier|static
name|int
name|lkm_v
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lkm_state
init|=
name|LKMS_IDLE
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MAXLKMS
end_ifndef

begin_define
define|#
directive|define
name|MAXLKMS
value|20
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|lkm_table
name|lkmods
index|[
name|MAXLKMS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table of loaded modules */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|lkm_table
modifier|*
name|curp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global for in-progress ops */
end_comment

begin_decl_stmt
specifier|static
name|int
name|_lkm_dev
name|__P
argument_list|(
operator|(
expr|struct
name|lkm_table
operator|*
name|lkmtp
operator|,
name|int
name|cmd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_lkm_exec
name|__P
argument_list|(
operator|(
expr|struct
name|lkm_table
operator|*
name|lkmtp
operator|,
name|int
name|cmd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_lkm_vfs
name|__P
argument_list|(
operator|(
expr|struct
name|lkm_table
operator|*
name|lkmtp
operator|,
name|int
name|cmd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_lkm_syscall
name|__P
argument_list|(
operator|(
expr|struct
name|lkm_table
operator|*
name|lkmtp
operator|,
name|int
name|cmd
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|lkmunreserve
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|lkmcopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|lkmcclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|lkmcioctl
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|32
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|lkmc_cdevsw
init|=
block|{
name|lkmcopen
block|,
name|lkmcclose
block|,
name|noread
block|,
name|nowrite
block|,
comment|/*32*/
name|lkmcioctl
block|,
name|nostop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
name|seltrue
block|,
name|nommap
block|,
name|NULL
block|,
literal|"lkm"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|lkmcopen
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|devtype
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|devtype
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* bad minor # */
comment|/* 	 * Use of the loadable kernel module device must be exclusive; we 	 * may try to remove this restriction later, but it's really no 	 * hardship. 	 */
while|while
condition|(
name|lkm_v
operator|&
name|LKM_ALLOC
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|FNONBLOCK
condition|)
comment|/* don't hang */
return|return
operator|(
name|EBUSY
operator|)
return|;
name|lkm_v
operator||=
name|LKM_WANT
expr_stmt|;
comment|/* 		 * Sleep pending unlock; we use tsleep() to allow 		 * an alarm out of the open. 		 */
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lkm_v
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"lkmopn"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* leave LKM_WANT set -- no problem */
block|}
name|lkm_v
operator||=
name|LKM_ALLOC
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* pseudo-device open */
block|}
end_function

begin_comment
comment|/*  * Unreserve the memory associated with the current loaded module; done on  * a coerced close of the lkm device (close on premature exit of modload)  * or explicitly by modload as a result of a link failure.  */
end_comment

begin_function
specifier|static
name|void
name|lkmunreserve
parameter_list|()
block|{
if|if
condition|(
name|lkm_state
operator|==
name|LKMS_IDLE
condition|)
return|return;
comment|/* 	 * Actually unreserve the memory 	 */
if|if
condition|(
name|curp
operator|&&
name|curp
operator|->
name|area
condition|)
block|{
name|kmem_free
argument_list|(
name|kernel_map
argument_list|,
name|curp
operator|->
name|area
argument_list|,
name|curp
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/**/
name|curp
operator|->
name|area
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|curp
operator|->
name|private
operator|.
name|lkm_any
operator|!=
name|NULL
condition|)
name|curp
operator|->
name|private
operator|.
name|lkm_any
operator|=
name|NULL
expr_stmt|;
block|}
name|lkm_state
operator|=
name|LKMS_IDLE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lkmcclose
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|mode
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
operator|!
operator|(
name|lkm_v
operator|&
name|LKM_ALLOC
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"LKM: close before open!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
comment|/* do this before waking the herd... */
if|if
condition|(
name|curp
operator|&&
operator|!
name|curp
operator|->
name|used
condition|)
block|{
comment|/* 		 * If we close before setting used, we have aborted 		 * by way of error or by way of close-on-exit from 		 * a premature exit of "modload". 		 */
name|lkmunreserve
argument_list|()
expr_stmt|;
comment|/* coerce state to LKM_IDLE */
block|}
name|lkm_v
operator|&=
operator|~
name|LKM_ALLOC
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|lkm_v
argument_list|)
expr_stmt|;
comment|/* thundering herd "problem" here */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* pseudo-device closed */
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|lkmcioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|lmc_resrv
modifier|*
name|resrvp
decl_stmt|;
name|struct
name|lmc_loadbuf
modifier|*
name|loadbufp
decl_stmt|;
name|struct
name|lmc_unload
modifier|*
name|unloadp
decl_stmt|;
name|struct
name|lmc_stat
modifier|*
name|statp
decl_stmt|;
name|char
name|istr
index|[
name|MAXLKMNAME
index|]
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|LMRESERV
case|:
comment|/* reserve pages for a module */
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
operator|||
name|securelevel
operator|>
literal|0
condition|)
comment|/* only allow this if writing and insecure */
return|return
name|EPERM
return|;
name|resrvp
operator|=
operator|(
expr|struct
name|lmc_resrv
operator|*
operator|)
name|data
expr_stmt|;
comment|/* 		 * Find a free slot. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXLKMS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|lkmods
index|[
name|i
index|]
operator|.
name|used
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|MAXLKMS
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
comment|/* no slots available */
break|break;
block|}
name|curp
operator|=
operator|&
name|lkmods
index|[
name|i
index|]
expr_stmt|;
name|curp
operator|->
name|id
operator|=
name|i
expr_stmt|;
comment|/* self reference slot offset */
name|resrvp
operator|->
name|slot
operator|=
name|i
expr_stmt|;
comment|/* return slot */
comment|/* 		 * Get memory for module 		 */
name|curp
operator|->
name|size
operator|=
name|resrvp
operator|->
name|size
expr_stmt|;
name|curp
operator|->
name|area
operator|=
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|curp
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/**/
name|curp
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* load offset */
name|resrvp
operator|->
name|addr
operator|=
name|curp
operator|->
name|area
expr_stmt|;
comment|/* ret kernel addr */
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"LKM: LMRESERV (actual   = 0x%08x)\n"
argument_list|,
name|curp
operator|->
name|area
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"LKM: LMRESERV (adjusted = 0x%08x)\n"
argument_list|,
name|trunc_page
argument_list|(
name|curp
operator|->
name|area
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|lkm_state
operator|=
name|LKMS_RESERVED
expr_stmt|;
break|break;
case|case
name|LMLOADBUF
case|:
comment|/* Copy in; stateful, follows LMRESERV */
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
operator|||
name|securelevel
operator|>
literal|0
condition|)
comment|/* only allow this if writing and insecure */
return|return
name|EPERM
return|;
name|loadbufp
operator|=
operator|(
expr|struct
name|lmc_loadbuf
operator|*
operator|)
name|data
expr_stmt|;
name|i
operator|=
name|loadbufp
operator|->
name|cnt
expr_stmt|;
if|if
condition|(
operator|(
name|lkm_state
operator|!=
name|LKMS_RESERVED
operator|&&
name|lkm_state
operator|!=
name|LKMS_LOADING
operator|)
operator|||
name|i
operator|<
literal|0
operator|||
name|i
operator|>
name|MODIOBUF
operator|||
name|i
operator|>
name|curp
operator|->
name|size
operator|-
name|curp
operator|->
name|offset
condition|)
block|{
name|err
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
comment|/* copy in buffer full of data */
name|err
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|loadbufp
operator|->
name|data
argument_list|,
operator|(
name|caddr_t
operator|)
name|curp
operator|->
name|area
operator|+
name|curp
operator|->
name|offset
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
if|if
condition|(
operator|(
name|curp
operator|->
name|offset
operator|+
name|i
operator|)
operator|<
name|curp
operator|->
name|size
condition|)
block|{
name|lkm_state
operator|=
name|LKMS_LOADING
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"LKM: LMLOADBUF (loading @ %d of %d, i = %d)\n"
argument_list|,
name|curp
operator|->
name|offset
argument_list|,
name|curp
operator|->
name|size
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
else|else
block|{
name|lkm_state
operator|=
name|LKMS_LOADED
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"LKM: LMLOADBUF (loaded)\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
block|}
name|curp
operator|->
name|offset
operator|+=
name|i
expr_stmt|;
break|break;
case|case
name|LMUNRESRV
case|:
comment|/* discard reserved pages for a module */
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
operator|||
name|securelevel
operator|>
literal|0
condition|)
comment|/* only allow this if writing and insecure */
return|return
name|EPERM
return|;
name|lkmunreserve
argument_list|()
expr_stmt|;
comment|/* coerce state to LKM_IDLE */
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"LKM: LMUNRESERV\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
break|break;
case|case
name|LMREADY
case|:
comment|/* module loaded: call entry */
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
operator|||
name|securelevel
operator|>
literal|0
condition|)
comment|/* only allow this if writing or insecure */
return|return
name|EPERM
return|;
switch|switch
condition|(
name|lkm_state
condition|)
block|{
case|case
name|LKMS_LOADED
case|:
break|break;
case|case
name|LKMS_LOADING
case|:
comment|/* The remainder must be bss, so we clear it */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|curp
operator|->
name|area
operator|+
name|curp
operator|->
name|offset
argument_list|,
name|curp
operator|->
name|size
operator|-
name|curp
operator|->
name|offset
argument_list|)
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"lkm_state is %02x\n"
argument_list|,
name|lkm_state
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
return|return
name|ENXIO
return|;
block|}
comment|/* XXX gack */
name|curp
operator|->
name|entry
operator|=
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|__P
argument_list|(
operator|(
expr|struct
name|lkm_table
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
operator|)
operator|(
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|)
expr_stmt|;
comment|/* call entry(load)... (assigns "private" portion) */
name|err
operator|=
operator|(
operator|*
operator|(
name|curp
operator|->
name|entry
operator|)
operator|)
operator|(
name|curp
operator|,
name|LKM_E_LOAD
operator|,
name|LKM_VERSION
operator|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* 			 * Module may refuse loading or may have a 			 * version mismatch... 			 */
name|lkm_state
operator|=
name|LKMS_UNLOADING
expr_stmt|;
comment|/* for lkmunreserve */
name|lkmunreserve
argument_list|()
expr_stmt|;
comment|/* free memory */
name|curp
operator|->
name|used
operator|=
literal|0
expr_stmt|;
comment|/* free slot */
break|break;
block|}
comment|/* 		 * It's possible for a user to load a module that doesn't 		 * initialize itself correctly. (You can even get away with 		 * using it for a while.) Unfortunately, we are faced with 		 * the following problems: 		 * - we can't tell a good module from a bad one until 		 *   after we've run its entry function (if the private 		 *   section is uninitalized after we return from the 		 *   entry, then something's fishy) 		 * - now that we've called the entry function, we can't 		 *   forcibly unload the module without risking a crash 		 * - since we don't know what the module's entry function 		 *   did, we can't easily clean up the mess it may have 		 *   made, so we can't know just how unstable the system 		 *   may be 		 * So, being stuck between a rock and a hard place, we 		 * have no choice but to do this... 		 */
if|if
condition|(
name|curp
operator|->
name|private
operator|.
name|lkm_any
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"loadable module initialization failed"
argument_list|)
expr_stmt|;
name|curp
operator|->
name|used
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"LKM: LMREADY\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
name|lkm_state
operator|=
name|LKMS_IDLE
expr_stmt|;
break|break;
case|case
name|LMUNLOAD
case|:
comment|/* unload a module */
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|==
literal|0
operator|||
name|securelevel
operator|>
literal|0
condition|)
comment|/* only allow this if writing and insecure */
return|return
name|EPERM
return|;
name|unloadp
operator|=
operator|(
expr|struct
name|lmc_unload
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|unloadp
operator|->
name|id
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* unload by name */
comment|/* 			 * Copy name and lookup id from all loaded 			 * modules.  May fail. 			 */
name|err
operator|=
name|copyinstr
argument_list|(
name|unloadp
operator|->
name|name
argument_list|,
name|istr
argument_list|,
name|MAXLKMNAME
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
comment|/* 			 * look up id... 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXLKMS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|lkmods
index|[
name|i
index|]
operator|.
name|used
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|istr
argument_list|,
name|lkmods
index|[
name|i
index|]
operator|.
name|private
operator|.
name|lkm_any
operator|->
name|lkm_name
argument_list|)
condition|)
break|break;
block|}
block|}
comment|/* 		 * Range check the value; on failure, return EINVAL 		 */
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|MAXLKMS
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|curp
operator|=
operator|&
name|lkmods
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|curp
operator|->
name|used
condition|)
block|{
name|err
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
comment|/* call entry(unload) */
if|if
condition|(
operator|(
operator|*
operator|(
name|curp
operator|->
name|entry
operator|)
operator|)
operator|(
name|curp
operator|,
name|LKM_E_UNLOAD
operator|,
name|LKM_VERSION
operator|)
condition|)
block|{
name|err
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
name|lkm_state
operator|=
name|LKMS_UNLOADING
expr_stmt|;
comment|/* non-idle for lkmunreserve */
name|lkmunreserve
argument_list|()
expr_stmt|;
comment|/* free memory */
name|curp
operator|->
name|used
operator|=
literal|0
expr_stmt|;
comment|/* free slot */
break|break;
case|case
name|LMSTAT
case|:
comment|/* stat a module by id/name */
comment|/* allow readers and writers to stat */
name|statp
operator|=
operator|(
expr|struct
name|lmc_stat
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|statp
operator|->
name|id
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* stat by name */
comment|/* 			 * Copy name and lookup id from all loaded 			 * modules. 			 */
name|copystr
argument_list|(
name|statp
operator|->
name|name
argument_list|,
name|istr
argument_list|,
name|MAXLKMNAME
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * look up id... 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXLKMS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|lkmods
index|[
name|i
index|]
operator|.
name|used
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|istr
argument_list|,
name|lkmods
index|[
name|i
index|]
operator|.
name|private
operator|.
name|lkm_any
operator|->
name|lkm_name
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|MAXLKMS
condition|)
block|{
comment|/* Not found */
name|err
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * Range check the value; on failure, return EINVAL 		 */
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|MAXLKMS
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|curp
operator|=
operator|&
name|lkmods
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|curp
operator|->
name|used
condition|)
block|{
comment|/* Not found */
name|err
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
comment|/* 		 * Copy out stat information for this module... 		 */
name|statp
operator|->
name|id
operator|=
name|curp
operator|->
name|id
expr_stmt|;
name|statp
operator|->
name|offset
operator|=
name|curp
operator|->
name|private
operator|.
name|lkm_any
operator|->
name|lkm_offset
expr_stmt|;
name|statp
operator|->
name|type
operator|=
name|curp
operator|->
name|private
operator|.
name|lkm_any
operator|->
name|lkm_type
expr_stmt|;
name|statp
operator|->
name|area
operator|=
name|curp
operator|->
name|area
expr_stmt|;
name|statp
operator|->
name|size
operator|=
name|curp
operator|->
name|size
operator|/
name|PAGESIZE
expr_stmt|;
name|statp
operator|->
name|private
operator|=
operator|(
name|unsigned
name|long
operator|)
name|curp
operator|->
name|private
operator|.
name|lkm_any
expr_stmt|;
name|statp
operator|->
name|ver
operator|=
name|curp
operator|->
name|private
operator|.
name|lkm_any
operator|->
name|lkm_ver
expr_stmt|;
name|copystr
argument_list|(
name|curp
operator|->
name|private
operator|.
name|lkm_any
operator|->
name|lkm_name
argument_list|,
name|statp
operator|->
name|name
argument_list|,
name|MAXLKMNAME
operator|-
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* bad ioctl()... */
name|err
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Acts like "nosys" but can be identified in sysent for dynamic call  * number assignment for a limited number of calls.  *  * Place holder for system call slots reserved for loadable modules.  */
end_comment

begin_function
name|int
name|lkmnosys
parameter_list|(
name|p
parameter_list|,
name|args
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|nosys_args
modifier|*
name|args
decl_stmt|;
block|{
return|return
operator|(
name|nosys
argument_list|(
name|p
argument_list|,
name|args
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lkmexists
parameter_list|(
name|lkmtp
parameter_list|)
name|struct
name|lkm_table
modifier|*
name|lkmtp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * see if name exists... 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXLKMS
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * An unused module and the one we are testing are not 		 * considered. 		 */
if|if
condition|(
operator|!
name|lkmods
index|[
name|i
index|]
operator|.
name|used
operator|||
operator|&
name|lkmods
index|[
name|i
index|]
operator|==
name|lkmtp
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|lkmtp
operator|->
name|private
operator|.
name|lkm_any
operator|->
name|lkm_name
argument_list|,
name|lkmods
index|[
name|i
index|]
operator|.
name|private
operator|.
name|lkm_any
operator|->
name|lkm_name
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* already loaded... */
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* module not loaded... */
block|}
end_function

begin_comment
comment|/*  * For the loadable system call described by the structure pointed to  * by lkmtp, load/unload/stat it depending on the cmd requested.  */
end_comment

begin_function
specifier|static
name|int
name|_lkm_syscall
parameter_list|(
name|lkmtp
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|lkm_table
modifier|*
name|lkmtp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
block|{
name|struct
name|lkm_syscall
modifier|*
name|args
init|=
name|lkmtp
operator|->
name|private
operator|.
name|lkm_syscall
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|LKM_E_LOAD
case|:
comment|/* don't load twice! */
if|if
condition|(
name|lkmexists
argument_list|(
name|lkmtp
argument_list|)
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
if|if
condition|(
operator|(
name|i
operator|=
name|args
operator|->
name|lkm_offset
operator|)
operator|==
name|LKM_ANON
condition|)
block|{
comment|/* auto */
comment|/* 			 * Search the table looking for a slot... 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|aout_sysvec
operator|.
name|sv_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|aout_sysvec
operator|.
name|sv_table
index|[
name|i
index|]
operator|.
name|sy_call
operator|==
operator|(
name|sy_call_t
operator|*
operator|)
name|lkmnosys
condition|)
break|break;
comment|/* found it! */
comment|/* out of allocable slots? */
if|if
condition|(
name|i
operator|==
name|aout_sysvec
operator|.
name|sv_size
condition|)
block|{
name|err
operator|=
name|ENFILE
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* assign */
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|aout_sysvec
operator|.
name|sv_size
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
comment|/* save old */
name|bcopy
argument_list|(
operator|&
name|aout_sysvec
operator|.
name|sv_table
index|[
name|i
index|]
argument_list|,
operator|&
operator|(
name|args
operator|->
name|lkm_oldent
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sysent
argument_list|)
argument_list|)
expr_stmt|;
comment|/* replace with new */
name|bcopy
argument_list|(
name|args
operator|->
name|lkm_sysent
argument_list|,
operator|&
name|aout_sysvec
operator|.
name|sv_table
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sysent
argument_list|)
argument_list|)
expr_stmt|;
comment|/* done! */
name|args
operator|->
name|lkm_offset
operator|=
name|i
expr_stmt|;
comment|/* slot in sysent[] */
break|break;
case|case
name|LKM_E_UNLOAD
case|:
comment|/* current slot... */
name|i
operator|=
name|args
operator|->
name|lkm_offset
expr_stmt|;
comment|/* replace current slot contents with old contents */
name|bcopy
argument_list|(
operator|&
operator|(
name|args
operator|->
name|lkm_oldent
operator|)
argument_list|,
operator|&
name|aout_sysvec
operator|.
name|sv_table
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sysent
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LKM_E_STAT
case|:
comment|/* no special handling... */
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For the loadable virtual file system described by the structure pointed  * to by lkmtp, load/unload/stat it depending on the cmd requested.  */
end_comment

begin_function
specifier|static
name|int
name|_lkm_vfs
parameter_list|(
name|lkmtp
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|lkm_table
modifier|*
name|lkmtp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
block|{
name|struct
name|lkm_vfs
modifier|*
name|args
init|=
name|lkmtp
operator|->
name|private
operator|.
name|lkm_vfs
decl_stmt|;
name|struct
name|vfsconf
modifier|*
name|vfc
init|=
name|args
operator|->
name|lkm_vfsconf
decl_stmt|;
name|struct
name|vfsconf
modifier|*
name|vfsp
decl_stmt|,
modifier|*
name|prev_vfsp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|maxtypenum
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|LKM_E_LOAD
case|:
comment|/* don't load twice! */
if|if
condition|(
name|lkmexists
argument_list|(
name|lkmtp
argument_list|)
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
for|for
control|(
name|vfsp
operator|=
name|vfsconf
init|;
name|vfsp
operator|->
name|vfc_next
condition|;
name|vfsp
operator|=
name|vfsp
operator|->
name|vfc_next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|vfc
operator|->
name|vfc_name
argument_list|,
name|vfsp
operator|->
name|vfc_name
argument_list|)
condition|)
block|{
return|return
name|EEXIST
return|;
block|}
block|}
name|i
operator|=
name|args
operator|->
name|lkm_offset
operator|=
name|vfc
operator|->
name|vfc_typenum
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|i
operator|=
name|maxvfsconf
expr_stmt|;
block|}
name|args
operator|->
name|lkm_offset
operator|=
name|vfc
operator|->
name|vfc_typenum
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|maxvfsconf
operator|<=
name|i
condition|)
name|maxvfsconf
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|vfsp
operator|->
name|vfc_next
operator|=
name|vfc
expr_stmt|;
name|vfc
operator|->
name|vfc_next
operator|=
name|NULL
expr_stmt|;
comment|/* like in vfs_op_init */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|args
operator|->
name|lkm_vnodeops
operator|->
name|ls_items
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|vnodeopv_desc
modifier|*
name|opv
init|=
name|args
operator|->
name|lkm_vnodeops
operator|->
name|ls_items
index|[
name|i
index|]
decl_stmt|;
operator|*
operator|(
name|opv
operator|->
name|opv_desc_vector_p
operator|)
operator|=
name|NULL
expr_stmt|;
block|}
name|vfs_opv_init
argument_list|(
operator|(
expr|struct
name|vnodeopv_desc
operator|*
operator|*
operator|)
name|args
operator|->
name|lkm_vnodeops
operator|->
name|ls_items
argument_list|)
expr_stmt|;
comment|/* 		 * Call init function for this VFS... 		 */
operator|(
operator|*
operator|(
name|vfc
operator|->
name|vfc_vfsops
operator|->
name|vfs_init
operator|)
operator|)
operator|(
name|vfc
operator|)
expr_stmt|;
comment|/* done! */
break|break;
case|case
name|LKM_E_UNLOAD
case|:
comment|/* current slot... */
name|i
operator|=
name|args
operator|->
name|lkm_offset
expr_stmt|;
name|prev_vfsp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|vfsp
operator|=
name|vfsconf
init|;
name|vfsp
condition|;
name|prev_vfsp
operator|=
name|vfsp
operator|,
name|vfsp
operator|=
name|vfsp
operator|->
name|vfc_next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|vfc
operator|->
name|vfc_name
argument_list|,
name|vfsp
operator|->
name|vfc_name
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|vfsp
operator|==
name|NULL
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|vfsp
operator|->
name|vfc_refcount
condition|)
block|{
return|return
name|EBUSY
return|;
block|}
name|prev_vfsp
operator|->
name|vfc_next
operator|=
name|vfsp
operator|->
name|vfc_next
expr_stmt|;
comment|/* 		 * Maintain maxvfsconf. 		 */
name|maxtypenum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|vfsp
operator|=
name|vfsconf
init|;
name|vfsp
operator|!=
name|NULL
condition|;
name|vfsp
operator|=
name|vfsp
operator|->
name|vfc_next
control|)
if|if
condition|(
name|maxtypenum
operator|<
name|vfsp
operator|->
name|vfc_typenum
condition|)
name|maxtypenum
operator|=
name|vfsp
operator|->
name|vfc_typenum
expr_stmt|;
name|maxvfsconf
operator|=
name|maxtypenum
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|LKM_E_STAT
case|:
comment|/* no special handling... */
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For the loadable device driver described by the structure pointed to  * by lkmtp, load/unload/stat it depending on the cmd requested.  */
end_comment

begin_function
specifier|static
name|int
name|_lkm_dev
parameter_list|(
name|lkmtp
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|lkm_table
modifier|*
name|lkmtp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
block|{
name|struct
name|lkm_dev
modifier|*
name|args
init|=
name|lkmtp
operator|->
name|private
operator|.
name|lkm_dev
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dev_t
name|descrip
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|LKM_E_LOAD
case|:
comment|/* don't load twice! */
if|if
condition|(
name|lkmexists
argument_list|(
name|lkmtp
argument_list|)
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
switch|switch
condition|(
name|args
operator|->
name|lkm_devtype
condition|)
block|{
case|case
name|LM_DT_BLOCK
case|:
if|if
condition|(
operator|(
name|i
operator|=
name|args
operator|->
name|lkm_offset
operator|)
operator|==
name|LKM_ANON
condition|)
name|descrip
operator|=
operator|(
name|dev_t
operator|)
operator|-
literal|1
expr_stmt|;
else|else
name|descrip
operator|=
name|makedev
argument_list|(
name|args
operator|->
name|lkm_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|=
name|bdevsw_add
argument_list|(
operator|&
name|descrip
argument_list|,
name|args
operator|->
name|lkm_dev
operator|.
name|bdev
argument_list|,
operator|&
operator|(
name|args
operator|->
name|lkm_olddev
operator|.
name|bdev
operator|)
argument_list|)
condition|)
block|{
break|break;
block|}
name|args
operator|->
name|lkm_offset
operator|=
name|major
argument_list|(
name|descrip
argument_list|)
expr_stmt|;
break|break;
case|case
name|LM_DT_CHAR
case|:
if|if
condition|(
operator|(
name|i
operator|=
name|args
operator|->
name|lkm_offset
operator|)
operator|==
name|LKM_ANON
condition|)
name|descrip
operator|=
operator|(
name|dev_t
operator|)
operator|-
literal|1
expr_stmt|;
else|else
name|descrip
operator|=
name|makedev
argument_list|(
name|args
operator|->
name|lkm_offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|=
name|cdevsw_add
argument_list|(
operator|&
name|descrip
argument_list|,
name|args
operator|->
name|lkm_dev
operator|.
name|cdev
argument_list|,
operator|&
operator|(
name|args
operator|->
name|lkm_olddev
operator|.
name|cdev
operator|)
argument_list|)
condition|)
block|{
break|break;
block|}
name|args
operator|->
name|lkm_offset
operator|=
name|major
argument_list|(
name|descrip
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|LKM_E_UNLOAD
case|:
comment|/* current slot... */
name|i
operator|=
name|args
operator|->
name|lkm_offset
expr_stmt|;
name|descrip
operator|=
name|makedev
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|args
operator|->
name|lkm_devtype
condition|)
block|{
case|case
name|LM_DT_BLOCK
case|:
comment|/* replace current slot contents with old contents */
name|bdevsw_add
argument_list|(
operator|&
name|descrip
argument_list|,
name|args
operator|->
name|lkm_olddev
operator|.
name|bdev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|LM_DT_CHAR
case|:
comment|/* replace current slot contents with old contents */
name|cdevsw_add
argument_list|(
operator|&
name|descrip
argument_list|,
name|args
operator|->
name|lkm_olddev
operator|.
name|cdev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|ENODEV
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|LKM_E_STAT
case|:
comment|/* no special handling... */
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|STREAMS
end_ifdef

begin_comment
comment|/*  * For the loadable streams module described by the structure pointed to  * by lkmtp, load/unload/stat it depending on the cmd requested.  */
end_comment

begin_function
specifier|static
name|int
name|_lkm_strmod
parameter_list|(
name|lkmtp
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|lkm_table
modifier|*
name|lkmtp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
block|{
name|struct
name|lkm_strmod
modifier|*
name|args
init|=
name|lkmtp
operator|->
name|private
operator|.
name|lkm_strmod
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|LKM_E_LOAD
case|:
comment|/* don't load twice! */
if|if
condition|(
name|lkmexists
argument_list|(
name|lkmtp
argument_list|)
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
break|break;
case|case
name|LKM_E_UNLOAD
case|:
break|break;
case|case
name|LKM_E_STAT
case|:
comment|/* no special handling... */
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STREAMS */
end_comment

begin_comment
comment|/*  * For the loadable execution class described by the structure pointed to  * by lkmtp, load/unload/stat it depending on the cmd requested.  */
end_comment

begin_function
specifier|static
name|int
name|_lkm_exec
parameter_list|(
name|lkmtp
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|lkm_table
modifier|*
name|lkmtp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
block|{
name|struct
name|lkm_exec
modifier|*
name|args
init|=
name|lkmtp
operator|->
name|private
operator|.
name|lkm_exec
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|execsw
modifier|*
modifier|*
name|execsw
init|=
operator|(
specifier|const
expr|struct
name|execsw
operator|*
operator|*
operator|)
operator|&
name|execsw_set
operator|.
name|ls_items
index|[
literal|0
index|]
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|LKM_E_LOAD
case|:
comment|/* don't load twice! */
if|if
condition|(
name|lkmexists
argument_list|(
name|lkmtp
argument_list|)
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
if|if
condition|(
operator|(
name|i
operator|=
name|args
operator|->
name|lkm_offset
operator|)
operator|==
name|LKM_ANON
condition|)
block|{
comment|/* auto */
comment|/* 			 * Search the table looking for a slot... 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|execsw
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|execsw
index|[
name|i
index|]
operator|->
name|ex_imgact
operator|==
name|NULL
condition|)
break|break;
comment|/* found it! */
comment|/* out of allocable slots? */
if|if
condition|(
name|execsw
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|ENFILE
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* assign */
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* save old */
name|bcopy
argument_list|(
operator|&
name|execsw
index|[
name|i
index|]
argument_list|,
operator|&
operator|(
name|args
operator|->
name|lkm_oldexec
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|execsw
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* replace with new */
name|bcopy
argument_list|(
operator|&
operator|(
name|args
operator|->
name|lkm_exec
operator|)
argument_list|,
operator|&
name|execsw
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|execsw
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* done! */
name|args
operator|->
name|lkm_offset
operator|=
name|i
expr_stmt|;
comment|/* slot in execsw[] */
break|break;
case|case
name|LKM_E_UNLOAD
case|:
comment|/* current slot... */
name|i
operator|=
name|args
operator|->
name|lkm_offset
expr_stmt|;
comment|/* replace current slot contents with old contents */
name|bcopy
argument_list|(
operator|&
operator|(
name|args
operator|->
name|lkm_oldexec
operator|)
argument_list|,
operator|&
name|execsw
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|execsw
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LKM_E_STAT
case|:
comment|/* no special handling... */
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/* XXX: This is bogus.  we should find a better method RSN! */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|execsw
name|lkm_exec_dummy1
init|=
block|{
name|NULL
block|,
literal|"lkm"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|execsw
name|lkm_exec_dummy2
init|=
block|{
name|NULL
block|,
literal|"lkm"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|execsw
name|lkm_exec_dummy3
init|=
block|{
name|NULL
block|,
literal|"lkm"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|execsw
name|lkm_exec_dummy4
init|=
block|{
name|NULL
block|,
literal|"lkm"
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TEXT_SET
argument_list|(
name|execsw_set
argument_list|,
name|lkm_exec_dummy1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TEXT_SET
argument_list|(
name|execsw_set
argument_list|,
name|lkm_exec_dummy2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TEXT_SET
argument_list|(
name|execsw_set
argument_list|,
name|lkm_exec_dummy3
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TEXT_SET
argument_list|(
name|execsw_set
argument_list|,
name|lkm_exec_dummy4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This code handles the per-module type "wiring-in" of loadable modules  * into existing kernel tables.  For "LM_MISC" modules, wiring and unwiring  * is assumed to be done in their entry routines internal to the module  * itself.  */
end_comment

begin_function
name|int
name|lkmdispatch
parameter_list|(
name|lkmtp
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|lkm_table
modifier|*
name|lkmtp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* default = success */
switch|switch
condition|(
name|lkmtp
operator|->
name|private
operator|.
name|lkm_any
operator|->
name|lkm_type
condition|)
block|{
case|case
name|LM_SYSCALL
case|:
name|err
operator|=
name|_lkm_syscall
argument_list|(
name|lkmtp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|LM_VFS
case|:
name|err
operator|=
name|_lkm_vfs
argument_list|(
name|lkmtp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|LM_DEV
case|:
name|err
operator|=
name|_lkm_dev
argument_list|(
name|lkmtp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|STREAMS
case|case
name|LM_STRMOD
case|:
block|{
name|struct
name|lkm_strmod
modifier|*
name|args
init|=
name|lkmtp
operator|->
name|private
operator|.
name|lkm_strmod
decl_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* STREAMS */
case|case
name|LM_EXEC
case|:
name|err
operator|=
name|_lkm_exec
argument_list|(
name|lkmtp
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|LM_MISC
case|:
comment|/* ignore content -- no "misc-specific" procedure */
if|if
condition|(
name|lkmexists
argument_list|(
name|lkmtp
argument_list|)
condition|)
name|err
operator|=
name|EEXIST
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|ENXIO
expr_stmt|;
comment|/* unknown type */
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lkm_nullcmd
parameter_list|(
name|lkmtp
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|lkm_table
modifier|*
name|lkmtp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|lkm_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_decl_stmt
specifier|static
name|void
modifier|*
name|lkmc_devfs_token
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|lkm_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|lkm_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|lkmc_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|lkm_devsw_installed
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|lkmc_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|lkmc_cdevsw
argument_list|,
literal|0
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0644
argument_list|,
literal|"lkm"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|lkmdev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|lkm_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

end_unit

