begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005-2006, David Xu<yfxu@corp.netease.com>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_hwpmc_hooks.h"
end_include

begin_include
include|#
directive|include
file|"opt_sched.h"
end_include

begin_define
define|#
directive|define
name|kse
value|td_sched
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/turnstile.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HWPMC_HOOKS
end_ifdef

begin_include
include|#
directive|include
file|<sys/pmckern.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_comment
comment|/* get process's nice value, skip value 20 which is not supported */
end_comment

begin_define
define|#
directive|define
name|PROC_NICE
parameter_list|(
name|p
parameter_list|)
value|MIN((p)->p_nice, 19)
end_define

begin_comment
comment|/* convert nice to kernel thread priority */
end_comment

begin_define
define|#
directive|define
name|NICE_TO_PRI
parameter_list|(
name|nice
parameter_list|)
value|(PUSER + 20 + (nice))
end_define

begin_comment
comment|/* get process's static priority */
end_comment

begin_define
define|#
directive|define
name|PROC_PRI
parameter_list|(
name|p
parameter_list|)
value|NICE_TO_PRI(PROC_NICE(p))
end_define

begin_comment
comment|/* convert kernel thread priority to user priority */
end_comment

begin_define
define|#
directive|define
name|USER_PRI
parameter_list|(
name|pri
parameter_list|)
value|MIN((pri) - PUSER, 39)
end_define

begin_comment
comment|/* convert nice value to user priority */
end_comment

begin_define
define|#
directive|define
name|PROC_USER_PRI
parameter_list|(
name|p
parameter_list|)
value|(PROC_NICE(p) + 20)
end_define

begin_comment
comment|/* maximum user priority, highest prio + 1 */
end_comment

begin_define
define|#
directive|define
name|MAX_USER_PRI
value|40
end_define

begin_comment
comment|/* maximum kernel priority its nice is 19 */
end_comment

begin_define
define|#
directive|define
name|PUSER_MAX
value|(PUSER + 39)
end_define

begin_comment
comment|/* ticks and nanosecond converters */
end_comment

begin_define
define|#
directive|define
name|NS_TO_HZ
parameter_list|(
name|n
parameter_list|)
value|((n) / (1000000000 / hz))
end_define

begin_define
define|#
directive|define
name|HZ_TO_NS
parameter_list|(
name|h
parameter_list|)
value|((h) * (1000000000 / hz))
end_define

begin_comment
comment|/* ticks and microsecond converters */
end_comment

begin_define
define|#
directive|define
name|MS_TO_HZ
parameter_list|(
name|m
parameter_list|)
value|((m) / (1000000 / hz))
end_define

begin_define
define|#
directive|define
name|PRI_SCORE_RATIO
value|25
end_define

begin_define
define|#
directive|define
name|MAX_SCORE
value|(MAX_USER_PRI * PRI_SCORE_RATIO / 100)
end_define

begin_define
define|#
directive|define
name|MAX_SLEEP_TIME
value|(def_timeslice * MAX_SCORE)
end_define

begin_define
define|#
directive|define
name|NS_MAX_SLEEP_TIME
value|(HZ_TO_NS(MAX_SLEEP_TIME))
end_define

begin_define
define|#
directive|define
name|STARVATION_TIME
value|(MAX_SLEEP_TIME)
end_define

begin_define
define|#
directive|define
name|CURRENT_SCORE
parameter_list|(
name|kg
parameter_list|)
define|\
value|(MAX_SCORE * NS_TO_HZ((kg)->kg_slptime) / MAX_SLEEP_TIME)
end_define

begin_define
define|#
directive|define
name|SCALE_USER_PRI
parameter_list|(
name|x
parameter_list|,
name|upri
parameter_list|)
define|\
value|MAX(x * (upri + 1) / (MAX_USER_PRI/2), min_timeslice)
end_define

begin_comment
comment|/*  * For a thread whose nice is zero, the score is used to determine  * if it is an interactive thread.  */
end_comment

begin_define
define|#
directive|define
name|INTERACTIVE_BASE_SCORE
value|(MAX_SCORE * 20)/100
end_define

begin_comment
comment|/*  * Calculate a score which a thread must have to prove itself is  * an interactive thread.  */
end_comment

begin_define
define|#
directive|define
name|INTERACTIVE_SCORE
parameter_list|(
name|ke
parameter_list|)
define|\
value|(PROC_NICE((ke)->ke_proc) * MAX_SCORE / 40 + INTERACTIVE_BASE_SCORE)
end_define

begin_comment
comment|/* Test if a thread is an interactive thread */
end_comment

begin_define
define|#
directive|define
name|THREAD_IS_INTERACTIVE
parameter_list|(
name|ke
parameter_list|)
define|\
value|((ke)->ke_ksegrp->kg_user_pri<=	\ 	PROC_PRI((ke)->ke_proc) - INTERACTIVE_SCORE(ke))
end_define

begin_comment
comment|/*  * Calculate how long a thread must sleep to prove itself is an  * interactive sleep.  */
end_comment

begin_define
define|#
directive|define
name|INTERACTIVE_SLEEP_TIME
parameter_list|(
name|ke
parameter_list|)
define|\
value|(HZ_TO_NS(MAX_SLEEP_TIME *		\ 	(MAX_SCORE / 2 + INTERACTIVE_SCORE((ke)) + 1) / MAX_SCORE - 1))
end_define

begin_define
define|#
directive|define
name|CHILD_WEIGHT
value|90
end_define

begin_define
define|#
directive|define
name|PARENT_WEIGHT
value|90
end_define

begin_define
define|#
directive|define
name|EXIT_WEIGHT
value|3
end_define

begin_define
define|#
directive|define
name|SCHED_LOAD_SCALE
value|128UL
end_define

begin_define
define|#
directive|define
name|IDLE
value|0
end_define

begin_define
define|#
directive|define
name|IDLE_IDLE
value|1
end_define

begin_define
define|#
directive|define
name|NOT_IDLE
value|2
end_define

begin_define
define|#
directive|define
name|KQB_LEN
value|(8)
end_define

begin_comment
comment|/* Number of priority status words. */
end_comment

begin_define
define|#
directive|define
name|KQB_L2BPW
value|(5)
end_define

begin_comment
comment|/* Log2(sizeof(rqb_word_t) * NBBY)). */
end_comment

begin_define
define|#
directive|define
name|KQB_BPW
value|(1<<KQB_L2BPW)
end_define

begin_comment
comment|/* Bits in an rqb_word_t. */
end_comment

begin_define
define|#
directive|define
name|KQB_BIT
parameter_list|(
name|pri
parameter_list|)
value|(1<< ((pri)& (KQB_BPW - 1)))
end_define

begin_define
define|#
directive|define
name|KQB_WORD
parameter_list|(
name|pri
parameter_list|)
value|((pri)>> KQB_L2BPW)
end_define

begin_define
define|#
directive|define
name|KQB_FFS
parameter_list|(
name|word
parameter_list|)
value|(ffs(word) - 1)
end_define

begin_define
define|#
directive|define
name|KQ_NQS
value|256
end_define

begin_comment
comment|/*  * Type of run queue status word.  */
end_comment

begin_typedef
typedef|typedef
name|u_int32_t
name|kqb_word_t
typedef|;
end_typedef

begin_comment
comment|/*  * Head of run queues.  */
end_comment

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|krqhead
argument_list|,
name|kse
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Bit array which maintains the status of a run queue.  When a queue is  * non-empty the bit corresponding to the queue number will be set.  */
end_comment

begin_struct
struct|struct
name|krqbits
block|{
name|kqb_word_t
name|rqb_bits
index|[
name|KQB_LEN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Run queue structure. Contains an array of run queues on which processes  * are placed, and a structure to maintain the status of each queue.  */
end_comment

begin_struct
struct|struct
name|krunq
block|{
name|struct
name|krqbits
name|rq_status
decl_stmt|;
name|struct
name|krqhead
name|rq_queues
index|[
name|KQ_NQS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The following datastructures are allocated within their parent structure  * but are scheduler specific.  */
end_comment

begin_comment
comment|/*  * The schedulable entity that can be given a context to run.  A process may  * have several of these.  */
end_comment

begin_struct
struct|struct
name|kse
block|{
name|TAILQ_ENTRY
argument_list|(
argument|kse
argument_list|)
name|ke_procq
expr_stmt|;
comment|/* (j/z) Run queue. */
name|int
name|ke_flags
decl_stmt|;
comment|/* (j) KEF_* flags. */
name|struct
name|thread
modifier|*
name|ke_thread
decl_stmt|;
comment|/* (*) Active associated thread. */
name|fixpt_t
name|ke_pctcpu
decl_stmt|;
comment|/* (j) %cpu during p_swtime. */
name|u_char
name|ke_rqindex
decl_stmt|;
comment|/* (j) Run queue index. */
enum|enum
block|{
name|KES_THREAD
init|=
literal|0x0
block|,
comment|/* slaved to thread state */
name|KES_ONRUNQ
block|}
name|ke_state
enum|;
comment|/* (j) thread sched specific status. */
name|int
name|ke_slice
decl_stmt|;
name|struct
name|krunq
modifier|*
name|ke_runq
decl_stmt|;
name|int
name|ke_cpu
decl_stmt|;
comment|/* CPU that we have affinity for. */
name|int
name|ke_activated
decl_stmt|;
name|uint64_t
name|ke_timestamp
decl_stmt|;
name|uint64_t
name|ke_lastran
decl_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|int
name|ke_tocpu
decl_stmt|;
endif|#
directive|endif
comment|/* The following variables are only used for pctcpu calculation */
name|int
name|ke_ltick
decl_stmt|;
comment|/* Last tick that we were running on */
name|int
name|ke_ftick
decl_stmt|;
comment|/* First tick that we were running on */
name|int
name|ke_ticks
decl_stmt|;
comment|/* Tick count */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|td_kse
value|td_sched
end_define

begin_define
define|#
directive|define
name|ke_proc
value|ke_thread->td_proc
end_define

begin_define
define|#
directive|define
name|ke_ksegrp
value|ke_thread->td_ksegrp
end_define

begin_comment
comment|/* flags kept in ke_flags */
end_comment

begin_define
define|#
directive|define
name|KEF_ASSIGNED
value|0x0001
end_define

begin_comment
comment|/* Thread is being migrated. */
end_comment

begin_define
define|#
directive|define
name|KEF_BOUND
value|0x0002
end_define

begin_comment
comment|/* Thread can not migrate. */
end_comment

begin_define
define|#
directive|define
name|KEF_XFERABLE
value|0x0004
end_define

begin_comment
comment|/* Thread was added as transferable. */
end_comment

begin_define
define|#
directive|define
name|KEF_HOLD
value|0x0008
end_define

begin_comment
comment|/* Thread is temporarily bound. */
end_comment

begin_define
define|#
directive|define
name|KEF_REMOVED
value|0x0010
end_define

begin_comment
comment|/* Thread was removed while ASSIGNED */
end_comment

begin_define
define|#
directive|define
name|KEF_INTERNAL
value|0x0020
end_define

begin_comment
comment|/* Thread added due to migration. */
end_comment

begin_define
define|#
directive|define
name|KEF_PREEMPTED
value|0x0040
end_define

begin_comment
comment|/* Thread was preempted. */
end_comment

begin_define
define|#
directive|define
name|KEF_MIGRATING
value|0x0080
end_define

begin_comment
comment|/* Thread is migrating. */
end_comment

begin_define
define|#
directive|define
name|KEF_SLEEP
value|0x0100
end_define

begin_comment
comment|/* Thread did sleep. */
end_comment

begin_define
define|#
directive|define
name|KEF_DIDRUN
value|0x2000
end_define

begin_comment
comment|/* Thread actually ran. */
end_comment

begin_define
define|#
directive|define
name|KEF_EXIT
value|0x4000
end_define

begin_comment
comment|/* Thread is being killed. */
end_comment

begin_define
define|#
directive|define
name|KEF_NEXTRQ
value|0x8000
end_define

begin_comment
comment|/* Thread should be in next queue. */
end_comment

begin_define
define|#
directive|define
name|KEF_FIRST_SLICE
value|0x10000
end_define

begin_comment
comment|/* Thread has first time slice left. */
end_comment

begin_struct
struct|struct
name|kg_sched
block|{
name|struct
name|thread
modifier|*
name|skg_last_assigned
decl_stmt|;
comment|/* (j) Last thread assigned to */
comment|/* the system scheduler */
name|u_long
name|skg_slptime
decl_stmt|;
comment|/* (j) Number of ticks we vol. slept */
name|u_long
name|skg_runtime
decl_stmt|;
comment|/* (j) Temp total run time. */
name|int
name|skg_avail_opennings
decl_stmt|;
comment|/* (j) Num unfilled slots in group.*/
name|int
name|skg_concurrency
decl_stmt|;
comment|/* (j) Num threads requested in group.*/
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|kg_last_assigned
value|kg_sched->skg_last_assigned
end_define

begin_define
define|#
directive|define
name|kg_avail_opennings
value|kg_sched->skg_avail_opennings
end_define

begin_define
define|#
directive|define
name|kg_concurrency
value|kg_sched->skg_concurrency
end_define

begin_define
define|#
directive|define
name|kg_slptime
value|kg_sched->skg_slptime
end_define

begin_define
define|#
directive|define
name|kg_runtime
value|kg_sched->skg_runtime
end_define

begin_define
define|#
directive|define
name|SLOT_RELEASE
parameter_list|(
name|kg
parameter_list|)
value|(kg)->kg_avail_opennings++
end_define

begin_define
define|#
directive|define
name|SLOT_USE
parameter_list|(
name|kg
parameter_list|)
value|(kg)->kg_avail_opennings--
end_define

begin_comment
comment|/*  * Cpu percentage computation macros and defines.  *  * SCHED_CPU_TIME:	Number of seconds to average the cpu usage across.  * SCHED_CPU_TICKS:	Number of hz ticks to average the cpu usage across.  */
end_comment

begin_define
define|#
directive|define
name|SCHED_CPU_TIME
value|10
end_define

begin_define
define|#
directive|define
name|SCHED_CPU_TICKS
value|(hz * SCHED_CPU_TIME)
end_define

begin_comment
comment|/*  * kseq - per processor runqs and statistics.  */
end_comment

begin_struct
struct|struct
name|kseq
block|{
name|struct
name|krunq
name|ksq_idle
decl_stmt|;
comment|/* Queue of IDLE threads. */
name|struct
name|krunq
name|ksq_timeshare
index|[
literal|2
index|]
decl_stmt|;
comment|/* Run queues for !IDLE. */
name|struct
name|krunq
modifier|*
name|ksq_next
decl_stmt|;
comment|/* Next timeshare queue. */
name|struct
name|krunq
modifier|*
name|ksq_curr
decl_stmt|;
comment|/* Current queue. */
name|int
name|ksq_load_timeshare
decl_stmt|;
comment|/* Load for timeshare. */
name|int
name|ksq_load_idle
decl_stmt|;
name|int
name|ksq_load
decl_stmt|;
comment|/* Aggregate load. */
name|int
name|ksq_sysload
decl_stmt|;
comment|/* For loadavg, !P_NOLOAD */
name|uint64_t
name|ksq_expired_timestamp
decl_stmt|;
name|uint64_t
name|ksq_last_timestamp
decl_stmt|;
name|signed
name|char
name|ksq_best_expired_nice
decl_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|int
name|ksq_transferable
decl_stmt|;
name|LIST_ENTRY
argument_list|(
argument|kseq
argument_list|)
name|ksq_siblings
expr_stmt|;
comment|/* Next in kseq group. */
name|struct
name|kseq_group
modifier|*
name|ksq_group
decl_stmt|;
comment|/* Our processor group. */
name|struct
name|thread
modifier|*
name|ksq_migrated
decl_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|kse
argument_list|)
name|ksq_migrateq
expr_stmt|;
name|int
name|ksq_avgload
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_comment
comment|/*  * kseq groups are groups of processors which can cheaply share threads. When  * one processor in the group goes idle it will check the runqs of the other  * processors in its group prior to halting and waiting for an interrupt.  * These groups are suitable for SMT (Symetric Multi-Threading) and not NUMA.  * In a NUMA environment we'd want an idle bitmap per group and a two tiered  * load balancer.  */
end_comment

begin_struct
struct|struct
name|kseq_group
block|{
name|int
name|ksg_cpus
decl_stmt|;
comment|/* Count of CPUs in this kseq group. */
name|cpumask_t
name|ksg_cpumask
decl_stmt|;
comment|/* Mask of cpus in this group. */
name|cpumask_t
name|ksg_idlemask
decl_stmt|;
comment|/* Idle cpus in this group. */
name|cpumask_t
name|ksg_mask
decl_stmt|;
comment|/* Bit mask for first cpu. */
name|int
name|ksg_transferable
decl_stmt|;
comment|/* Transferable load of this group. */
name|LIST_HEAD
argument_list|(
argument_list|,
argument|kseq
argument_list|)
name|ksg_members
expr_stmt|;
comment|/* Linked list of all members. */
name|int
name|ksg_balance_tick
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|kse
name|kse0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kg_sched
name|kg_sched0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|min_timeslice
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|def_timeslice
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|granularity
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|realstathz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * One kse queue per processor.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_decl_stmt
specifier|static
name|cpumask_t
name|kseq_idle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ksg_maxid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kseq
name|kseq_cpu
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kseq_group
name|kseq_groups
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|balance_tick
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|balance_interval
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|balance_interval_max
init|=
literal|32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|balance_interval_min
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|balance_busy_factor
init|=
literal|32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|imbalance_pct
init|=
literal|25
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|imbalance_pct2
init|=
literal|50
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ignore_topology
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KSEQ_SELF
parameter_list|()
value|(&kseq_cpu[PCPU_GET(cpuid)])
end_define

begin_define
define|#
directive|define
name|KSEQ_CPU
parameter_list|(
name|x
parameter_list|)
value|(&kseq_cpu[(x)])
end_define

begin_define
define|#
directive|define
name|KSEQ_ID
parameter_list|(
name|x
parameter_list|)
value|((x) - kseq_cpu)
end_define

begin_define
define|#
directive|define
name|KSEQ_GROUP
parameter_list|(
name|x
parameter_list|)
value|(&kseq_groups[(x)])
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !SMP */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|kseq
name|kseq_cpu
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KSEQ_SELF
parameter_list|()
value|(&kseq_cpu)
end_define

begin_define
define|#
directive|define
name|KSEQ_CPU
parameter_list|(
name|x
parameter_list|)
value|(&kseq_cpu)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* decay 95% of `p_pctcpu' in 60 seconds; see CCPU_SHIFT before changing */
end_comment

begin_decl_stmt
specifier|static
name|fixpt_t
name|ccpu
init|=
literal|0.95122942450071400909
operator|*
name|FSCALE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* exp(-1/20) */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|ccpu
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ccpu
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|sched_setup
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSINIT
argument_list|(
name|sched_setup
argument_list|,
name|SI_SUB_RUN_QUEUE
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|sched_setup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|sched_initticks
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_macro
name|SYSINIT
argument_list|(
argument|sched_initticks
argument_list|,
argument|SI_SUB_CLOCKS
argument_list|,
argument|SI_ORDER_THIRD
argument_list|,
argument|sched_initticks
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|sched
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Scheduler"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_STRING
argument_list|(
name|_kern_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|"core"
argument_list|,
literal|0
argument_list|,
literal|"Scheduler name"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|imbalance_pct
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|imbalance_pct
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|imbalance_pct2
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|imbalance_pct2
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|balance_interval_min
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|balance_interval_min
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|balance_interval_max
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|balance_interval_max
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|slot_fill
parameter_list|(
name|struct
name|ksegrp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|krunq_add
parameter_list|(
name|struct
name|krunq
modifier|*
parameter_list|,
name|struct
name|kse
modifier|*
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|kse
modifier|*
name|krunq_choose
parameter_list|(
name|struct
name|krunq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|krunq_clrbit
parameter_list|(
name|struct
name|krunq
modifier|*
name|rq
parameter_list|,
name|int
name|pri
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|krunq_findbit
parameter_list|(
name|struct
name|krunq
modifier|*
name|rq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|krunq_init
parameter_list|(
name|struct
name|krunq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|krunq_remove
parameter_list|(
name|struct
name|krunq
modifier|*
parameter_list|,
name|struct
name|kse
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function_decl
specifier|static
name|struct
name|kse
modifier|*
name|krunq_steal
parameter_list|(
name|struct
name|krunq
modifier|*
name|rq
parameter_list|,
name|int
name|my_cpu
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|kse
modifier|*
name|kseq_choose
parameter_list|(
name|struct
name|kseq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kseq_load_add
parameter_list|(
name|struct
name|kseq
modifier|*
parameter_list|,
name|struct
name|kse
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kseq_load_rem
parameter_list|(
name|struct
name|kseq
modifier|*
parameter_list|,
name|struct
name|kse
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kseq_runq_add
parameter_list|(
name|struct
name|kseq
modifier|*
parameter_list|,
name|struct
name|kse
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kseq_runq_rem
parameter_list|(
name|struct
name|kseq
modifier|*
parameter_list|,
name|struct
name|kse
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kseq_setup
parameter_list|(
name|struct
name|kseq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sched_is_timeshare
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|kse
modifier|*
name|sched_choose
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sched_calc_pri
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sched_starving
parameter_list|(
name|struct
name|kseq
modifier|*
parameter_list|,
name|uint64_t
parameter_list|,
name|struct
name|kse
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sched_pctcpu_update
parameter_list|(
name|struct
name|kse
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sched_thread_priority
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|u_char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|sched_timestamp
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sched_recalc_pri
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|,
name|uint64_t
name|now
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sched_timeslice
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sched_update_runtime
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|,
name|uint64_t
name|now
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sched_commit_runtime
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function_decl
specifier|static
name|void
name|sched_balance_tick
parameter_list|(
name|int
name|my_cpu
parameter_list|,
name|int
name|idle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sched_balance_idle
parameter_list|(
name|int
name|my_cpu
parameter_list|,
name|int
name|idle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sched_balance
parameter_list|(
name|int
name|my_cpu
parameter_list|,
name|int
name|idle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|kseq_group
modifier|*
name|sched_find_busiest_group
parameter_list|(
name|int
name|my_cpu
parameter_list|,
name|int
name|idle
parameter_list|,
name|int
modifier|*
name|imbalance
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|kseq
modifier|*
name|sched_find_busiest_queue
parameter_list|(
name|struct
name|kseq_group
modifier|*
name|ksg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sched_find_idlest_cpu
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|,
name|int
name|cpu
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sched_pull_threads
parameter_list|(
name|struct
name|kseq
modifier|*
name|high
parameter_list|,
name|struct
name|kseq
modifier|*
name|myksq
parameter_list|,
name|int
name|max_move
parameter_list|,
name|int
name|idle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sched_pull_one
parameter_list|(
name|struct
name|kseq
modifier|*
name|from
parameter_list|,
name|struct
name|kseq
modifier|*
name|myksq
parameter_list|,
name|int
name|idle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|kse
modifier|*
name|sched_steal
parameter_list|(
name|struct
name|kseq
modifier|*
parameter_list|,
name|int
name|my_cpu
parameter_list|,
name|int
name|stealidle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sched_idled
parameter_list|(
name|struct
name|kseq
modifier|*
parameter_list|,
name|int
name|idle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sched_find_idle_cpu
parameter_list|(
name|int
name|defcpu
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|migrated_setup
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|migrated
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSINIT
argument_list|(
name|migrated_setup
argument_list|,
name|SI_SUB_KTHREAD_IDLE
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|migrated_setup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMP */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|kse_pinned
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
if|if
condition|(
name|ke
operator|->
name|ke_thread
operator|->
name|td_pinned
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ke
operator|->
name|ke_flags
operator|&
name|KEF_BOUND
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function
specifier|static
specifier|inline
name|int
name|kse_can_migrate
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
if|if
condition|(
name|kse_pinned
argument_list|(
name|ke
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Initialize a run structure.  */
end_comment

begin_function
specifier|static
name|void
name|krunq_init
parameter_list|(
name|struct
name|krunq
modifier|*
name|rq
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
name|rq
argument_list|,
sizeof|sizeof
expr|*
name|rq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KQ_NQS
condition|;
name|i
operator|++
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|rq
operator|->
name|rq_queues
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear the status bit of the queue corresponding to priority level pri,  * indicating that it is empty.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|krunq_clrbit
parameter_list|(
name|struct
name|krunq
modifier|*
name|rq
parameter_list|,
name|int
name|pri
parameter_list|)
block|{
name|struct
name|krqbits
modifier|*
name|rqb
decl_stmt|;
name|rqb
operator|=
operator|&
name|rq
operator|->
name|rq_status
expr_stmt|;
name|rqb
operator|->
name|rqb_bits
index|[
name|KQB_WORD
argument_list|(
name|pri
argument_list|)
index|]
operator|&=
operator|~
name|KQB_BIT
argument_list|(
name|pri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the index of the first non-empty run queue.  This is done by  * scanning the status bits, a set bit indicates a non-empty queue.  */
end_comment

begin_function
specifier|static
name|int
name|krunq_findbit
parameter_list|(
name|struct
name|krunq
modifier|*
name|rq
parameter_list|)
block|{
name|struct
name|krqbits
modifier|*
name|rqb
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rqb
operator|=
operator|&
name|rq
operator|->
name|rq_status
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KQB_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rqb
operator|->
name|rqb_bits
index|[
name|i
index|]
condition|)
block|{
name|pri
operator|=
name|KQB_FFS
argument_list|(
name|rqb
operator|->
name|rqb_bits
index|[
name|i
index|]
argument_list|)
operator|+
operator|(
name|i
operator|<<
name|KQB_L2BPW
operator|)
expr_stmt|;
return|return
operator|(
name|pri
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the status bit of the queue corresponding to priority level pri,  * indicating that it is non-empty.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|krunq_setbit
parameter_list|(
name|struct
name|krunq
modifier|*
name|rq
parameter_list|,
name|int
name|pri
parameter_list|)
block|{
name|struct
name|krqbits
modifier|*
name|rqb
decl_stmt|;
name|rqb
operator|=
operator|&
name|rq
operator|->
name|rq_status
expr_stmt|;
name|rqb
operator|->
name|rqb_bits
index|[
name|KQB_WORD
argument_list|(
name|pri
argument_list|)
index|]
operator||=
name|KQB_BIT
argument_list|(
name|pri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add the KSE to the queue specified by its priority, and set the  * corresponding status bit.  */
end_comment

begin_function
specifier|static
name|void
name|krunq_add
parameter_list|(
name|struct
name|krunq
modifier|*
name|rq
parameter_list|,
name|struct
name|kse
modifier|*
name|ke
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|krqhead
modifier|*
name|rqh
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|pri
operator|=
name|ke
operator|->
name|ke_thread
operator|->
name|td_priority
expr_stmt|;
name|ke
operator|->
name|ke_rqindex
operator|=
name|pri
expr_stmt|;
name|krunq_setbit
argument_list|(
name|rq
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|rqh
operator|=
operator|&
name|rq
operator|->
name|rq_queues
index|[
name|pri
index|]
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SRQ_PREEMPTED
condition|)
name|TAILQ_INSERT_HEAD
argument_list|(
name|rqh
argument_list|,
name|ke
argument_list|,
name|ke_procq
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
name|rqh
argument_list|,
name|ke
argument_list|,
name|ke_procq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the highest priority process on the run queue.  */
end_comment

begin_function
specifier|static
name|struct
name|kse
modifier|*
name|krunq_choose
parameter_list|(
name|struct
name|krunq
modifier|*
name|rq
parameter_list|)
block|{
name|struct
name|krqhead
modifier|*
name|rqh
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pri
operator|=
name|krunq_findbit
argument_list|(
name|rq
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|rqh
operator|=
operator|&
name|rq
operator|->
name|rq_queues
index|[
name|pri
index|]
expr_stmt|;
name|ke
operator|=
name|TAILQ_FIRST
argument_list|(
name|rqh
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ke
operator|!=
name|NULL
argument_list|,
operator|(
literal|"runq_choose: no proc on busy queue"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ke
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove the KSE from the queue specified by its priority, and clear the  * corresponding status bit if the queue becomes empty.  * Caller must set ke->ke_state afterwards.  */
end_comment

begin_function
specifier|static
name|void
name|krunq_remove
parameter_list|(
name|struct
name|krunq
modifier|*
name|rq
parameter_list|,
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
name|struct
name|krqhead
modifier|*
name|rqh
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|KASSERT
argument_list|(
name|ke
operator|->
name|ke_proc
operator|->
name|p_sflag
operator|&
name|PS_INMEM
argument_list|,
operator|(
literal|"runq_remove: process swapped out"
operator|)
argument_list|)
expr_stmt|;
name|pri
operator|=
name|ke
operator|->
name|ke_rqindex
expr_stmt|;
name|rqh
operator|=
operator|&
name|rq
operator|->
name|rq_queues
index|[
name|pri
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|ke
operator|!=
name|NULL
argument_list|,
operator|(
literal|"krunq_remove: no proc on busy queue"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|rqh
argument_list|,
name|ke
argument_list|,
name|ke_procq
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
name|rqh
argument_list|)
condition|)
name|krunq_clrbit
argument_list|(
name|rq
argument_list|,
name|pri
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function
specifier|static
name|struct
name|kse
modifier|*
name|krunq_steal
parameter_list|(
name|struct
name|krunq
modifier|*
name|rq
parameter_list|,
name|int
name|my_cpu
parameter_list|)
block|{
name|struct
name|krqhead
modifier|*
name|rqh
decl_stmt|;
name|struct
name|krqbits
modifier|*
name|rqb
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|kqb_word_t
name|word
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bit
decl_stmt|;
operator|(
name|void
operator|)
name|my_cpu
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|rqb
operator|=
operator|&
name|rq
operator|->
name|rq_status
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KQB_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|word
operator|=
name|rqb
operator|->
name|rqb_bits
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|)
continue|continue;
do|do
block|{
name|bit
operator|=
name|KQB_FFS
argument_list|(
name|word
argument_list|)
expr_stmt|;
name|rqh
operator|=
operator|&
name|rq
operator|->
name|rq_queues
index|[
name|bit
operator|+
operator|(
name|i
operator|<<
name|KQB_L2BPW
operator|)
index|]
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ke
argument_list|,
argument|rqh
argument_list|,
argument|ke_procq
argument_list|)
block|{
if|if
condition|(
name|kse_can_migrate
argument_list|(
name|ke
argument_list|)
condition|)
return|return
operator|(
name|ke
operator|)
return|;
block|}
name|word
operator|&=
operator|~
operator|(
operator|(
name|kqb_word_t
operator|)
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|word
operator|!=
literal|0
condition|)
do|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|void
name|kseq_runq_add
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|,
name|struct
name|kse
modifier|*
name|ke
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|kse_pinned
argument_list|(
name|ke
argument_list|)
operator|==
literal|0
condition|)
block|{
name|kseq
operator|->
name|ksq_transferable
operator|++
expr_stmt|;
name|kseq
operator|->
name|ksq_group
operator|->
name|ksg_transferable
operator|++
expr_stmt|;
name|ke
operator|->
name|ke_flags
operator||=
name|KEF_XFERABLE
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ke
operator|->
name|ke_flags
operator|&
name|KEF_PREEMPTED
condition|)
name|flags
operator||=
name|SRQ_PREEMPTED
expr_stmt|;
name|krunq_add
argument_list|(
name|ke
operator|->
name|ke_runq
argument_list|,
name|ke
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|kseq_runq_rem
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|,
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|ke
operator|->
name|ke_flags
operator|&
name|KEF_XFERABLE
condition|)
block|{
name|kseq
operator|->
name|ksq_transferable
operator|--
expr_stmt|;
name|kseq
operator|->
name|ksq_group
operator|->
name|ksg_transferable
operator|--
expr_stmt|;
name|ke
operator|->
name|ke_flags
operator|&=
operator|~
name|KEF_XFERABLE
expr_stmt|;
block|}
endif|#
directive|endif
name|krunq_remove
argument_list|(
name|ke
operator|->
name|ke_runq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_runq
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kseq_load_add
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|,
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
name|int
name|class
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|__predict_false
argument_list|(
name|ke
operator|->
name|ke_thread
operator|==
name|kseq
operator|->
name|ksq_migrated
argument_list|)
condition|)
return|return;
endif|#
directive|endif
name|class
operator|=
name|PRI_BASE
argument_list|(
name|ke
operator|->
name|ke_ksegrp
operator|->
name|kg_pri_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|PRI_TIMESHARE
condition|)
name|kseq
operator|->
name|ksq_load_timeshare
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|class
operator|==
name|PRI_IDLE
condition|)
name|kseq
operator|->
name|ksq_load_idle
operator|++
expr_stmt|;
name|kseq
operator|->
name|ksq_load
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ke
operator|->
name|ke_proc
operator|->
name|p_flag
operator|&
name|P_NOLOAD
operator|)
operator|==
literal|0
condition|)
name|kseq
operator|->
name|ksq_sysload
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kseq_load_rem
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|,
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
name|int
name|class
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|__predict_false
argument_list|(
name|ke
operator|->
name|ke_thread
operator|==
name|kseq
operator|->
name|ksq_migrated
argument_list|)
condition|)
return|return;
endif|#
directive|endif
name|class
operator|=
name|PRI_BASE
argument_list|(
name|ke
operator|->
name|ke_ksegrp
operator|->
name|kg_pri_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|PRI_TIMESHARE
condition|)
name|kseq
operator|->
name|ksq_load_timeshare
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|class
operator|==
name|PRI_IDLE
condition|)
name|kseq
operator|->
name|ksq_load_idle
operator|--
expr_stmt|;
name|kseq
operator|->
name|ksq_load
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|ke
operator|->
name|ke_proc
operator|->
name|p_flag
operator|&
name|P_NOLOAD
operator|)
operator|==
literal|0
condition|)
name|kseq
operator|->
name|ksq_sysload
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Pick the highest priority task we have and return it.  */
end_comment

begin_function
specifier|static
name|struct
name|kse
modifier|*
name|kseq_choose
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|)
block|{
name|struct
name|krunq
modifier|*
name|swap
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ke
operator|=
name|krunq_choose
argument_list|(
name|kseq
operator|->
name|ksq_curr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ke
operator|)
return|;
name|kseq
operator|->
name|ksq_best_expired_nice
operator|=
literal|21
expr_stmt|;
name|kseq
operator|->
name|ksq_expired_timestamp
operator|=
literal|0
expr_stmt|;
name|swap
operator|=
name|kseq
operator|->
name|ksq_curr
expr_stmt|;
name|kseq
operator|->
name|ksq_curr
operator|=
name|kseq
operator|->
name|ksq_next
expr_stmt|;
name|kseq
operator|->
name|ksq_next
operator|=
name|swap
expr_stmt|;
name|ke
operator|=
name|krunq_choose
argument_list|(
name|kseq
operator|->
name|ksq_curr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ke
operator|)
return|;
return|return
name|krunq_choose
argument_list|(
operator|&
name|kseq
operator|->
name|ksq_idle
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|sched_timestamp
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|now
init|=
name|cputick2usec
argument_list|(
name|cpu_ticks
argument_list|()
argument_list|)
operator|*
literal|1000
decl_stmt|;
return|return
operator|(
name|now
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|sched_timeslice
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|ke
operator|->
name|ke_proc
decl_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_proc
operator|->
name|p_nice
operator|<
literal|0
condition|)
return|return
name|SCALE_USER_PRI
argument_list|(
name|def_timeslice
operator|*
literal|4
argument_list|,
name|PROC_USER_PRI
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
else|else
return|return
name|SCALE_USER_PRI
argument_list|(
name|def_timeslice
argument_list|,
name|PROC_USER_PRI
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|sched_is_timeshare
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|)
block|{
comment|/* 	 * XXX P_KTHREAD should be checked, but unfortunately, the 	 * readonly flag resides in a volatile member p_flag, reading 	 * it could cause lots of cache line sharing and invalidating. 	 */
return|return
operator|(
name|kg
operator|->
name|kg_pri_class
operator|==
name|PRI_TIMESHARE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sched_calc_pri
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|)
block|{
name|int
name|score
decl_stmt|,
name|pri
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|sched_is_timeshare
argument_list|(
name|kg
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|kg
operator|->
name|kg_user_pri
operator|)
return|;
name|score
operator|=
name|CURRENT_SCORE
argument_list|(
name|kg
argument_list|)
operator|-
name|MAX_SCORE
operator|/
literal|2
expr_stmt|;
name|pri
operator|=
name|PROC_PRI
argument_list|(
name|kg
operator|->
name|kg_proc
argument_list|)
operator|-
name|score
expr_stmt|;
if|if
condition|(
name|pri
operator|<
name|PUSER
condition|)
name|pri
operator|=
name|PUSER
expr_stmt|;
if|if
condition|(
name|pri
operator|>
name|PUSER_MAX
condition|)
name|pri
operator|=
name|PUSER_MAX
expr_stmt|;
return|return
operator|(
name|pri
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sched_recalc_pri
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|,
name|uint64_t
name|now
parameter_list|)
block|{
name|uint64_t
name|delta
decl_stmt|;
name|unsigned
name|int
name|sleep_time
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|kg
operator|=
name|ke
operator|->
name|ke_ksegrp
expr_stmt|;
name|delta
operator|=
name|now
operator|-
name|ke
operator|->
name|ke_timestamp
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|sched_is_timeshare
argument_list|(
name|kg
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|kg
operator|->
name|kg_user_pri
operator|)
return|;
if|if
condition|(
name|delta
operator|>
name|NS_MAX_SLEEP_TIME
condition|)
name|sleep_time
operator|=
name|NS_MAX_SLEEP_TIME
expr_stmt|;
else|else
name|sleep_time
operator|=
operator|(
name|unsigned
name|int
operator|)
name|delta
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|sleep_time
operator|==
literal|0
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|ke
operator|->
name|ke_activated
operator|!=
operator|-
literal|1
operator|&&
name|sleep_time
operator|>
name|INTERACTIVE_SLEEP_TIME
argument_list|(
name|ke
argument_list|)
condition|)
block|{
name|kg
operator|->
name|kg_slptime
operator|=
name|HZ_TO_NS
argument_list|(
name|MAX_SLEEP_TIME
operator|-
name|def_timeslice
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sleep_time
operator|*=
operator|(
name|MAX_SCORE
operator|-
name|CURRENT_SCORE
argument_list|(
name|kg
argument_list|)
operator|)
condition|?
else|:
literal|1
expr_stmt|;
comment|/* 		 * If thread is waking from uninterruptible sleep, it is 		 * unlikely an interactive sleep, limit its sleep time to 		 * prevent it from being an interactive thread. 		 */
if|if
condition|(
name|ke
operator|->
name|ke_activated
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|kg
operator|->
name|kg_slptime
operator|>=
name|INTERACTIVE_SLEEP_TIME
argument_list|(
name|ke
argument_list|)
condition|)
name|sleep_time
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|kg
operator|->
name|kg_slptime
operator|+
name|sleep_time
operator|>=
name|INTERACTIVE_SLEEP_TIME
argument_list|(
name|ke
argument_list|)
condition|)
block|{
name|kg
operator|->
name|kg_slptime
operator|=
name|INTERACTIVE_SLEEP_TIME
argument_list|(
name|ke
argument_list|)
expr_stmt|;
name|sleep_time
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 		 * Thread gets priority boost here.                  */
name|kg
operator|->
name|kg_slptime
operator|+=
name|sleep_time
expr_stmt|;
comment|/* Sleep time should never be larger than maximum */
if|if
condition|(
name|kg
operator|->
name|kg_slptime
operator|>
name|NS_MAX_SLEEP_TIME
condition|)
name|kg
operator|->
name|kg_slptime
operator|=
name|NS_MAX_SLEEP_TIME
expr_stmt|;
block|}
name|out
label|:
return|return
operator|(
name|sched_calc_pri
argument_list|(
name|kg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sched_update_runtime
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|,
name|uint64_t
name|now
parameter_list|)
block|{
name|uint64_t
name|runtime
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
init|=
name|ke
operator|->
name|ke_ksegrp
decl_stmt|;
if|if
condition|(
name|sched_is_timeshare
argument_list|(
name|kg
argument_list|)
condition|)
block|{
if|if
condition|(
call|(
name|int64_t
call|)
argument_list|(
name|now
operator|-
name|ke
operator|->
name|ke_timestamp
argument_list|)
operator|<
name|NS_MAX_SLEEP_TIME
condition|)
block|{
name|runtime
operator|=
name|now
operator|-
name|ke
operator|->
name|ke_timestamp
expr_stmt|;
if|if
condition|(
call|(
name|int64_t
call|)
argument_list|(
name|now
operator|-
name|ke
operator|->
name|ke_timestamp
argument_list|)
operator|<
literal|0
condition|)
name|runtime
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|runtime
operator|=
name|NS_MAX_SLEEP_TIME
expr_stmt|;
block|}
name|runtime
operator|/=
operator|(
name|CURRENT_SCORE
argument_list|(
name|kg
argument_list|)
condition|?
else|:
literal|1
operator|)
expr_stmt|;
name|kg
operator|->
name|kg_runtime
operator|+=
name|runtime
expr_stmt|;
name|ke
operator|->
name|ke_timestamp
operator|=
name|now
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sched_commit_runtime
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
name|struct
name|ksegrp
modifier|*
name|kg
init|=
name|ke
operator|->
name|ke_ksegrp
decl_stmt|;
if|if
condition|(
name|kg
operator|->
name|kg_runtime
operator|>
name|kg
operator|->
name|kg_slptime
condition|)
name|kg
operator|->
name|kg_slptime
operator|=
literal|0
expr_stmt|;
else|else
name|kg
operator|->
name|kg_slptime
operator|-=
name|kg
operator|->
name|kg_runtime
expr_stmt|;
name|kg
operator|->
name|kg_runtime
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_comment
comment|/* staged balancing operations between CPUs */
end_comment

begin_define
define|#
directive|define
name|CPU_OFFSET
parameter_list|(
name|cpu
parameter_list|)
value|(hz * cpu / MAXCPU)
end_define

begin_function
specifier|static
name|void
name|sched_balance_tick
parameter_list|(
name|int
name|my_cpu
parameter_list|,
name|int
name|idle
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
init|=
name|KSEQ_CPU
argument_list|(
name|my_cpu
argument_list|)
decl_stmt|;
name|unsigned
name|t
init|=
name|ticks
operator|+
name|CPU_OFFSET
argument_list|(
name|my_cpu
argument_list|)
decl_stmt|;
name|int
name|old_load
decl_stmt|,
name|cur_load
decl_stmt|;
name|int
name|interval
decl_stmt|;
name|old_load
operator|=
name|kseq
operator|->
name|ksq_avgload
expr_stmt|;
name|cur_load
operator|=
name|kseq
operator|->
name|ksq_load
operator|*
name|SCHED_LOAD_SCALE
expr_stmt|;
if|if
condition|(
name|cur_load
operator|>
name|old_load
condition|)
name|old_load
operator|++
expr_stmt|;
name|kseq
operator|->
name|ksq_avgload
operator|=
operator|(
name|old_load
operator|+
name|cur_load
operator|)
operator|/
literal|2
expr_stmt|;
name|interval
operator|=
name|balance_interval
expr_stmt|;
if|if
condition|(
name|idle
operator|==
name|NOT_IDLE
condition|)
name|interval
operator|*=
name|balance_busy_factor
expr_stmt|;
name|interval
operator|=
name|MS_TO_HZ
argument_list|(
name|interval
argument_list|)
expr_stmt|;
if|if
condition|(
name|interval
operator|==
literal|0
condition|)
name|interval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|t
operator|-
name|balance_tick
operator|>=
name|interval
condition|)
block|{
name|sched_balance
argument_list|(
name|my_cpu
argument_list|,
name|idle
argument_list|)
expr_stmt|;
name|balance_tick
operator|+=
name|interval
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sched_balance
parameter_list|(
name|int
name|my_cpu
parameter_list|,
name|int
name|idle
parameter_list|)
block|{
name|struct
name|kseq_group
modifier|*
name|high_group
decl_stmt|;
name|struct
name|kseq
modifier|*
name|high_queue
decl_stmt|;
name|int
name|imbalance
decl_stmt|,
name|pulled
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|high_group
operator|=
name|sched_find_busiest_group
argument_list|(
name|my_cpu
argument_list|,
name|idle
argument_list|,
operator|&
name|imbalance
argument_list|)
expr_stmt|;
if|if
condition|(
name|high_group
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|high_queue
operator|=
name|sched_find_busiest_queue
argument_list|(
name|high_group
argument_list|)
expr_stmt|;
if|if
condition|(
name|high_queue
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|pulled
operator|=
name|sched_pull_threads
argument_list|(
name|high_queue
argument_list|,
name|KSEQ_CPU
argument_list|(
name|my_cpu
argument_list|)
argument_list|,
name|imbalance
argument_list|,
name|idle
argument_list|)
expr_stmt|;
if|if
condition|(
name|pulled
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|balance_interval
operator|<
name|balance_interval_max
condition|)
name|balance_interval
operator|++
expr_stmt|;
block|}
else|else
block|{
name|balance_interval
operator|=
name|balance_interval_min
expr_stmt|;
block|}
return|return
operator|(
name|pulled
operator|)
return|;
name|out
label|:
if|if
condition|(
name|balance_interval
operator|<
name|balance_interval_max
condition|)
name|balance_interval
operator|*=
literal|2
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sched_balance_idle
parameter_list|(
name|int
name|my_cpu
parameter_list|,
name|int
name|idle
parameter_list|)
block|{
name|struct
name|kseq_group
modifier|*
name|high_group
decl_stmt|;
name|struct
name|kseq
modifier|*
name|high_queue
decl_stmt|;
name|int
name|imbalance
decl_stmt|,
name|pulled
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|high_group
operator|=
name|sched_find_busiest_group
argument_list|(
name|my_cpu
argument_list|,
name|idle
argument_list|,
operator|&
name|imbalance
argument_list|)
expr_stmt|;
if|if
condition|(
name|high_group
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|high_queue
operator|=
name|sched_find_busiest_queue
argument_list|(
name|high_group
argument_list|)
expr_stmt|;
if|if
condition|(
name|high_queue
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|pulled
operator|=
name|sched_pull_threads
argument_list|(
name|high_queue
argument_list|,
name|KSEQ_CPU
argument_list|(
name|my_cpu
argument_list|)
argument_list|,
name|imbalance
argument_list|,
name|idle
argument_list|)
expr_stmt|;
return|return
operator|(
name|pulled
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|kseq_source_load
parameter_list|(
name|struct
name|kseq
modifier|*
name|ksq
parameter_list|)
block|{
name|int
name|load
init|=
name|ksq
operator|->
name|ksq_load
operator|*
name|SCHED_LOAD_SCALE
decl_stmt|;
return|return
operator|(
name|MIN
argument_list|(
name|ksq
operator|->
name|ksq_avgload
argument_list|,
name|load
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|kseq_dest_load
parameter_list|(
name|struct
name|kseq
modifier|*
name|ksq
parameter_list|)
block|{
name|int
name|load
init|=
name|ksq
operator|->
name|ksq_load
operator|*
name|SCHED_LOAD_SCALE
decl_stmt|;
return|return
operator|(
name|MAX
argument_list|(
name|ksq
operator|->
name|ksq_avgload
argument_list|,
name|load
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|kseq_group
modifier|*
name|sched_find_busiest_group
parameter_list|(
name|int
name|my_cpu
parameter_list|,
name|int
name|idle
parameter_list|,
name|int
modifier|*
name|imbalance
parameter_list|)
block|{
specifier|static
name|unsigned
name|stage_cpu
decl_stmt|;
name|struct
name|kseq_group
modifier|*
name|high
decl_stmt|;
name|struct
name|kseq_group
modifier|*
name|ksg
decl_stmt|;
name|struct
name|kseq
modifier|*
name|my_ksq
decl_stmt|,
modifier|*
name|ksq
decl_stmt|;
name|int
name|my_load
decl_stmt|,
name|high_load
decl_stmt|,
name|avg_load
decl_stmt|,
name|total_load
decl_stmt|,
name|load
decl_stmt|;
name|int
name|diff
decl_stmt|,
name|cnt
decl_stmt|,
name|i
decl_stmt|;
operator|*
name|imbalance
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|smp_started
operator|==
literal|0
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|my_ksq
operator|=
name|KSEQ_CPU
argument_list|(
name|my_cpu
argument_list|)
expr_stmt|;
name|high
operator|=
name|NULL
expr_stmt|;
name|high_load
operator|=
name|total_load
operator|=
name|my_load
operator|=
literal|0
expr_stmt|;
name|i
operator|=
operator|(
name|stage_cpu
operator|++
operator|)
operator|%
operator|(
name|ksg_maxid
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<=
name|ksg_maxid
condition|;
name|cnt
operator|++
control|)
block|{
name|ksg
operator|=
name|KSEQ_GROUP
argument_list|(
name|i
argument_list|)
expr_stmt|;
comment|/* 		 * Find the CPU with the highest load that has some 		 * threads to transfer. 		 */
name|load
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ksq
argument_list|,
argument|&ksg->ksg_members
argument_list|,
argument|ksq_siblings
argument_list|)
block|{
if|if
condition|(
name|ksg
operator|==
name|my_ksq
operator|->
name|ksq_group
condition|)
name|load
operator|+=
name|kseq_dest_load
argument_list|(
name|ksq
argument_list|)
expr_stmt|;
else|else
name|load
operator|+=
name|kseq_source_load
argument_list|(
name|ksq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ksg
operator|==
name|my_ksq
operator|->
name|ksq_group
condition|)
block|{
name|my_load
operator|=
name|load
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|load
operator|>
name|high_load
operator|&&
name|ksg
operator|->
name|ksg_transferable
condition|)
block|{
name|high
operator|=
name|ksg
expr_stmt|;
name|high_load
operator|=
name|load
expr_stmt|;
block|}
name|total_load
operator|+=
name|load
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|>
name|ksg_maxid
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|avg_load
operator|=
name|total_load
operator|/
operator|(
name|ksg_maxid
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|high
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|my_load
operator|>=
name|avg_load
operator|||
operator|(
name|high_load
operator|-
name|my_load
operator|)
operator|*
literal|100
operator|<
name|imbalance_pct
operator|*
name|my_load
condition|)
block|{
if|if
condition|(
name|idle
operator|==
name|IDLE_IDLE
operator|||
operator|(
name|idle
operator|==
name|IDLE
operator|&&
name|high_load
operator|>
name|SCHED_LOAD_SCALE
operator|)
condition|)
block|{
operator|*
name|imbalance
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|high
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* 	 * Pick a minimum imbalance value, avoid raising our load 	 * higher than average and pushing busiest load under average. 	 */
name|diff
operator|=
name|MIN
argument_list|(
name|high_load
operator|-
name|avg_load
argument_list|,
name|avg_load
operator|-
name|my_load
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|<
name|SCHED_LOAD_SCALE
condition|)
block|{
if|if
condition|(
name|high_load
operator|-
name|my_load
operator|>=
name|SCHED_LOAD_SCALE
operator|*
literal|2
condition|)
block|{
operator|*
name|imbalance
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|high
operator|)
return|;
block|}
block|}
operator|*
name|imbalance
operator|=
name|diff
operator|/
name|SCHED_LOAD_SCALE
expr_stmt|;
return|return
operator|(
name|high
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|kseq
modifier|*
name|sched_find_busiest_queue
parameter_list|(
name|struct
name|kseq_group
modifier|*
name|ksg
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|,
modifier|*
name|high
init|=
name|NULL
decl_stmt|;
name|int
name|load
decl_stmt|,
name|high_load
init|=
literal|0
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|kseq
argument_list|,
argument|&ksg->ksg_members
argument_list|,
argument|ksq_siblings
argument_list|)
block|{
name|load
operator|=
name|kseq_source_load
argument_list|(
name|kseq
argument_list|)
expr_stmt|;
if|if
condition|(
name|load
operator|>
name|high_load
condition|)
block|{
name|high_load
operator|=
name|load
expr_stmt|;
name|high
operator|=
name|kseq
expr_stmt|;
block|}
block|}
return|return
operator|(
name|high
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sched_pull_threads
parameter_list|(
name|struct
name|kseq
modifier|*
name|high
parameter_list|,
name|struct
name|kseq
modifier|*
name|myksq
parameter_list|,
name|int
name|max_pull
parameter_list|,
name|int
name|idle
parameter_list|)
block|{
name|int
name|pulled
decl_stmt|,
name|i
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|pulled
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_pull
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sched_pull_one
argument_list|(
name|high
argument_list|,
name|myksq
argument_list|,
name|idle
argument_list|)
condition|)
name|pulled
operator|++
expr_stmt|;
else|else
break|break;
block|}
return|return
operator|(
name|pulled
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sched_pull_one
parameter_list|(
name|struct
name|kseq
modifier|*
name|from
parameter_list|,
name|struct
name|kseq
modifier|*
name|myksq
parameter_list|,
name|int
name|idle
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|struct
name|krunq
modifier|*
name|destq
decl_stmt|;
name|int
name|class
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|kseq
operator|=
name|from
expr_stmt|;
name|ke
operator|=
name|sched_steal
argument_list|(
name|kseq
argument_list|,
name|KSEQ_ID
argument_list|(
name|myksq
argument_list|)
argument_list|,
name|idle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|==
name|NULL
condition|)
block|{
comment|/* doing balance in same group */
if|if
condition|(
name|from
operator|->
name|ksq_group
operator|==
name|myksq
operator|->
name|ksq_group
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|struct
name|kseq_group
modifier|*
name|ksg
decl_stmt|;
name|ksg
operator|=
name|kseq
operator|->
name|ksq_group
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|kseq
argument_list|,
argument|&ksg->ksg_members
argument_list|,
argument|ksq_siblings
argument_list|)
block|{
if|if
condition|(
name|kseq
operator|==
name|from
operator|||
name|kseq
operator|==
name|myksq
operator|||
name|kseq
operator|->
name|ksq_transferable
operator|==
literal|0
condition|)
continue|continue;
name|ke
operator|=
name|sched_steal
argument_list|(
name|kseq
argument_list|,
name|KSEQ_ID
argument_list|(
name|myksq
argument_list|)
argument_list|,
name|idle
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ke
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ke
operator|->
name|ke_timestamp
operator|=
name|ke
operator|->
name|ke_timestamp
operator|+
name|myksq
operator|->
name|ksq_last_timestamp
operator|-
name|kseq
operator|->
name|ksq_last_timestamp
expr_stmt|;
name|ke
operator|->
name|ke_lastran
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_runq
operator|==
name|from
operator|->
name|ksq_curr
condition|)
name|destq
operator|=
name|myksq
operator|->
name|ksq_curr
expr_stmt|;
elseif|else
if|if
condition|(
name|ke
operator|->
name|ke_runq
operator|==
name|from
operator|->
name|ksq_next
condition|)
name|destq
operator|=
name|myksq
operator|->
name|ksq_next
expr_stmt|;
else|else
name|destq
operator|=
operator|&
name|myksq
operator|->
name|ksq_idle
expr_stmt|;
name|kseq_runq_rem
argument_list|(
name|kseq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|kseq_load_rem
argument_list|(
name|kseq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_cpu
operator|=
name|KSEQ_ID
argument_list|(
name|myksq
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_runq
operator|=
name|destq
expr_stmt|;
name|ke
operator|->
name|ke_state
operator|=
name|KES_ONRUNQ
expr_stmt|;
name|kseq_runq_add
argument_list|(
name|myksq
argument_list|,
name|ke
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kseq_load_add
argument_list|(
name|myksq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|class
operator|=
name|PRI_BASE
argument_list|(
name|ke
operator|->
name|ke_ksegrp
operator|->
name|kg_pri_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|!=
name|PRI_IDLE
condition|)
block|{
if|if
condition|(
name|kseq_idle
operator|&
name|myksq
operator|->
name|ksq_group
operator|->
name|ksg_mask
condition|)
name|kseq_idle
operator|&=
operator|~
name|myksq
operator|->
name|ksq_group
operator|->
name|ksg_mask
expr_stmt|;
if|if
condition|(
name|myksq
operator|->
name|ksq_group
operator|->
name|ksg_idlemask
operator|&
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
condition|)
name|myksq
operator|->
name|ksq_group
operator|->
name|ksg_idlemask
operator|&=
operator|~
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ke
operator|->
name|ke_thread
operator|->
name|td_priority
operator|<
name|curthread
operator|->
name|td_priority
condition|)
name|curthread
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|kse
modifier|*
name|sched_steal
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|,
name|int
name|my_cpu
parameter_list|,
name|int
name|idle
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
comment|/* 	 * Steal from expired queue first to try to get a non-interactive 	 * task that may not have run for a while. 	 */
if|if
condition|(
operator|(
name|ke
operator|=
name|krunq_steal
argument_list|(
name|kseq
operator|->
name|ksq_next
argument_list|,
name|my_cpu
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ke
operator|)
return|;
if|if
condition|(
operator|(
name|ke
operator|=
name|krunq_steal
argument_list|(
name|kseq
operator|->
name|ksq_curr
argument_list|,
name|my_cpu
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ke
operator|)
return|;
if|if
condition|(
name|idle
operator|==
name|IDLE_IDLE
condition|)
return|return
operator|(
name|krunq_steal
argument_list|(
operator|&
name|kseq
operator|->
name|ksq_idle
argument_list|,
name|my_cpu
argument_list|)
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sched_idled
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|,
name|int
name|idle
parameter_list|)
block|{
name|struct
name|kseq_group
modifier|*
name|ksg
decl_stmt|;
name|struct
name|kseq
modifier|*
name|steal
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ksg
operator|=
name|kseq
operator|->
name|ksq_group
expr_stmt|;
comment|/* 	 * If we're in a cpu group, try and steal kses from another cpu in 	 * the group before idling. 	 */
if|if
condition|(
name|ksg
operator|->
name|ksg_cpus
operator|>
literal|1
operator|&&
name|ksg
operator|->
name|ksg_transferable
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|steal
argument_list|,
argument|&ksg->ksg_members
argument_list|,
argument|ksq_siblings
argument_list|)
block|{
if|if
condition|(
name|steal
operator|==
name|kseq
operator|||
name|steal
operator|->
name|ksq_transferable
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sched_pull_one
argument_list|(
name|steal
argument_list|,
name|kseq
argument_list|,
name|idle
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|sched_balance_idle
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
name|idle
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * We only set the idled bit when all of the cpus in the group are 	 * idle.  Otherwise we could get into a situation where a KSE bounces 	 * back and forth between two idle cores on seperate physical CPUs. 	 */
name|ksg
operator|->
name|ksg_idlemask
operator||=
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
expr_stmt|;
if|if
condition|(
name|ksg
operator|->
name|ksg_idlemask
operator|!=
name|ksg
operator|->
name|ksg_cpumask
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|kseq_idle
operator||=
name|ksg
operator|->
name|ksg_mask
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sched_find_idle_cpu
parameter_list|(
name|int
name|defcpu
parameter_list|)
block|{
name|struct
name|pcpu
modifier|*
name|pcpu
decl_stmt|;
name|struct
name|kseq_group
modifier|*
name|ksg
decl_stmt|;
name|struct
name|kseq
modifier|*
name|ksq
decl_stmt|;
name|int
name|cpu
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ksq
operator|=
name|KSEQ_CPU
argument_list|(
name|defcpu
argument_list|)
expr_stmt|;
name|ksg
operator|=
name|ksq
operator|->
name|ksq_group
expr_stmt|;
name|pcpu
operator|=
name|pcpu_find
argument_list|(
name|defcpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|ksg
operator|->
name|ksg_idlemask
operator|&
name|pcpu
operator|->
name|pc_cpumask
condition|)
return|return
operator|(
name|defcpu
operator|)
return|;
comment|/* Try to find a fully idled cpu. */
if|if
condition|(
name|kseq_idle
condition|)
block|{
name|cpu
operator|=
name|ffs
argument_list|(
name|kseq_idle
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpu
condition|)
goto|goto
name|migrate
goto|;
block|}
comment|/* 	 * If another cpu in this group has idled, assign a thread over 	 * to them after checking to see if there are idled groups. 	 */
if|if
condition|(
name|ksg
operator|->
name|ksg_idlemask
condition|)
block|{
name|cpu
operator|=
name|ffs
argument_list|(
name|ksg
operator|->
name|ksg_idlemask
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpu
condition|)
goto|goto
name|migrate
goto|;
block|}
return|return
operator|(
name|defcpu
operator|)
return|;
name|migrate
label|:
comment|/* 	 * Now that we've found an idle CPU, migrate the thread. 	 */
name|cpu
operator|--
expr_stmt|;
return|return
operator|(
name|cpu
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sched_find_idlest_cpu
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|,
name|int
name|cpu
parameter_list|)
block|{
specifier|static
name|unsigned
name|stage_cpu
decl_stmt|;
name|struct
name|kseq_group
modifier|*
name|ksg
decl_stmt|;
name|struct
name|kseq
modifier|*
name|ksq
decl_stmt|;
name|int
name|load
decl_stmt|,
name|min_load
init|=
name|INT_MAX
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
name|int
name|idlest
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cnt
decl_stmt|;
operator|(
name|void
operator|)
name|ke
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|smp_started
operator|==
literal|0
argument_list|)
condition|)
return|return
operator|(
name|cpu
operator|)
return|;
name|first
operator|=
literal|1
expr_stmt|;
name|i
operator|=
operator|(
name|stage_cpu
operator|++
operator|)
operator|%
operator|(
name|ksg_maxid
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<=
name|ksg_maxid
condition|;
name|cnt
operator|++
control|)
block|{
name|ksg
operator|=
name|KSEQ_GROUP
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ksq
argument_list|,
argument|&ksg->ksg_members
argument_list|,
argument|ksq_siblings
argument_list|)
block|{
name|load
operator|=
name|kseq_source_load
argument_list|(
name|ksq
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|||
name|load
operator|<
name|min_load
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
name|load
operator|=
name|min_load
expr_stmt|;
name|idlest
operator|=
name|KSEQ_ID
argument_list|(
name|ksq
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|++
name|i
operator|>
name|ksg_maxid
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|idlest
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|migrated_setup
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
name|kseq
operator|=
operator|&
name|kseq_cpu
index|[
name|i
index|]
expr_stmt|;
name|error
operator|=
name|kthread_create
argument_list|(
name|migrated
argument_list|,
name|kseq
argument_list|,
operator|&
name|p
argument_list|,
name|RFSTOPPED
argument_list|,
literal|0
argument_list|,
literal|"migrated%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"can not create migration thread"
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|P_NOLOAD
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|td
operator|=
name|FIRST_THREAD_IN_PROC
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_kse
operator|->
name|ke_flags
operator||=
name|KEF_BOUND
expr_stmt|;
name|td
operator|->
name|td_kse
operator|->
name|ke_cpu
operator|=
name|i
expr_stmt|;
name|kseq
operator|->
name|ksq_migrated
operator|=
name|td
expr_stmt|;
name|sched_class
argument_list|(
name|td
operator|->
name|td_ksegrp
argument_list|,
name|PRI_ITHD
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_kse
operator|->
name|ke_runq
operator|=
name|kseq
operator|->
name|ksq_curr
expr_stmt|;
name|sched_prio
argument_list|(
name|td
argument_list|,
name|PRI_MIN
argument_list|)
expr_stmt|;
name|SLOT_USE
argument_list|(
name|td
operator|->
name|td_ksegrp
argument_list|)
expr_stmt|;
name|kseq_runq_add
argument_list|(
name|kseq
argument_list|,
name|td
operator|->
name|td_kse
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_kse
operator|->
name|ke_state
operator|=
name|KES_ONRUNQ
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|migrated
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|kseq
modifier|*
name|kseq
init|=
name|KSEQ_SELF
argument_list|()
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
name|ke
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|kseq
operator|->
name|ksq_migrateq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kseq
operator|->
name|ksq_migrateq
argument_list|,
name|ke
argument_list|,
name|ke_procq
argument_list|)
expr_stmt|;
name|kseq_load_rem
argument_list|(
name|kseq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_flags
operator|&=
operator|~
name|KEF_MIGRATING
expr_stmt|;
name|ke
operator|->
name|ke_cpu
operator|=
name|ke
operator|->
name|ke_tocpu
expr_stmt|;
name|setrunqueue
argument_list|(
name|ke
operator|->
name|ke_thread
argument_list|,
name|SRQ_BORING
argument_list|)
expr_stmt|;
block|}
name|TD_SET_IWAIT
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|mi_switch
argument_list|(
name|SW_VOL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
specifier|inline
name|void
name|sched_balance_tick
parameter_list|(
name|int
name|my_cpu
parameter_list|,
name|int
name|idle
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SMP */
end_comment

begin_function
specifier|static
name|void
name|kseq_setup
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|)
block|{
name|krunq_init
argument_list|(
operator|&
name|kseq
operator|->
name|ksq_timeshare
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|krunq_init
argument_list|(
operator|&
name|kseq
operator|->
name|ksq_timeshare
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|krunq_init
argument_list|(
operator|&
name|kseq
operator|->
name|ksq_idle
argument_list|)
expr_stmt|;
name|kseq
operator|->
name|ksq_curr
operator|=
operator|&
name|kseq
operator|->
name|ksq_timeshare
index|[
literal|0
index|]
expr_stmt|;
name|kseq
operator|->
name|ksq_next
operator|=
operator|&
name|kseq
operator|->
name|ksq_timeshare
index|[
literal|1
index|]
expr_stmt|;
name|kseq
operator|->
name|ksq_best_expired_nice
operator|=
literal|21
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|TAILQ_INIT
argument_list|(
operator|&
name|kseq
operator|->
name|ksq_migrateq
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|sched_setup
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SMP
name|int
name|i
decl_stmt|;
name|int
name|t
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * To avoid divide-by-zero, we set realstathz a dummy value 	 * in case which sched_clock() called before sched_initticks(). 	 */
name|realstathz
operator|=
name|hz
expr_stmt|;
name|min_timeslice
operator|=
name|MAX
argument_list|(
literal|5
operator|*
name|hz
operator|/
literal|1000
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|def_timeslice
operator|=
name|MAX
argument_list|(
literal|100
operator|*
name|hz
operator|/
literal|1000
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|granularity
operator|=
name|MAX
argument_list|(
literal|10
operator|*
name|hz
operator|/
literal|1000
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|t
operator|=
name|ticks
expr_stmt|;
name|balance_tick
operator|=
name|t
expr_stmt|;
comment|/* 	 * Initialize the kseqs. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|kseq
modifier|*
name|ksq
decl_stmt|;
name|ksq
operator|=
operator|&
name|kseq_cpu
index|[
name|i
index|]
expr_stmt|;
name|kseq_setup
argument_list|(
operator|&
name|kseq_cpu
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|smp_topology
operator|==
name|NULL
operator|||
name|ignore_topology
condition|)
block|{
name|struct
name|kseq_group
modifier|*
name|ksg
decl_stmt|;
name|struct
name|kseq
modifier|*
name|ksq
decl_stmt|;
name|int
name|cpus
decl_stmt|;
for|for
control|(
name|cpus
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
name|ksq
operator|=
operator|&
name|kseq_cpu
index|[
name|i
index|]
expr_stmt|;
name|ksg
operator|=
operator|&
name|kseq_groups
index|[
name|cpus
index|]
expr_stmt|;
comment|/* 			 * Setup a kseq group with one member. 			 */
name|ksq
operator|->
name|ksq_group
operator|=
name|ksg
expr_stmt|;
name|ksg
operator|->
name|ksg_cpus
operator|=
literal|1
expr_stmt|;
name|ksg
operator|->
name|ksg_idlemask
operator|=
literal|0
expr_stmt|;
name|ksg
operator|->
name|ksg_cpumask
operator|=
name|ksg
operator|->
name|ksg_mask
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
name|ksg
operator|->
name|ksg_balance_tick
operator|=
name|t
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ksg
operator|->
name|ksg_members
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ksg
operator|->
name|ksg_members
argument_list|,
name|ksq
argument_list|,
name|ksq_siblings
argument_list|)
expr_stmt|;
name|cpus
operator|++
expr_stmt|;
block|}
name|ksg_maxid
operator|=
name|cpus
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|struct
name|kseq_group
modifier|*
name|ksg
decl_stmt|;
name|struct
name|cpu_group
modifier|*
name|cg
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|smp_topology
operator|->
name|ct_count
condition|;
name|i
operator|++
control|)
block|{
name|cg
operator|=
operator|&
name|smp_topology
operator|->
name|ct_group
index|[
name|i
index|]
expr_stmt|;
name|ksg
operator|=
operator|&
name|kseq_groups
index|[
name|i
index|]
expr_stmt|;
comment|/* 			 * Initialize the group. 			 */
name|ksg
operator|->
name|ksg_idlemask
operator|=
literal|0
expr_stmt|;
name|ksg
operator|->
name|ksg_cpus
operator|=
name|cg
operator|->
name|cg_count
expr_stmt|;
name|ksg
operator|->
name|ksg_cpumask
operator|=
name|cg
operator|->
name|cg_mask
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ksg
operator|->
name|ksg_members
argument_list|)
expr_stmt|;
comment|/* 			 * Find all of the group members and add them. 			 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXCPU
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cg
operator|->
name|cg_mask
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ksg
operator|->
name|ksg_mask
operator|==
literal|0
condition|)
name|ksg
operator|->
name|ksg_mask
operator|=
literal|1
operator|<<
name|j
expr_stmt|;
name|kseq_cpu
index|[
name|j
index|]
operator|.
name|ksq_group
operator|=
name|ksg
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ksg
operator|->
name|ksg_members
argument_list|,
operator|&
name|kseq_cpu
index|[
name|j
index|]
argument_list|,
name|ksq_siblings
argument_list|)
expr_stmt|;
block|}
block|}
name|ksg
operator|->
name|ksg_balance_tick
operator|=
name|t
expr_stmt|;
block|}
name|ksg_maxid
operator|=
name|smp_topology
operator|->
name|ct_count
operator|-
literal|1
expr_stmt|;
block|}
else|#
directive|else
name|kseq_setup
argument_list|(
name|KSEQ_SELF
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|kseq_load_add
argument_list|(
name|KSEQ_SELF
argument_list|()
argument_list|,
operator|&
name|kse0
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|sched_initticks
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|realstathz
operator|=
name|stathz
condition|?
name|stathz
else|:
name|hz
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Very early in the boot some setup of scheduler-specific  * parts of proc0 and of soem scheduler resources needs to be done.  * Called from:  *  proc0_init()  */
end_comment

begin_function
name|void
name|schedinit
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Set up the scheduler specific parts of proc0. 	 */
name|proc0
operator|.
name|p_sched
operator|=
name|NULL
expr_stmt|;
comment|/* XXX */
name|ksegrp0
operator|.
name|kg_sched
operator|=
operator|&
name|kg_sched0
expr_stmt|;
name|thread0
operator|.
name|td_sched
operator|=
operator|&
name|kse0
expr_stmt|;
name|kse0
operator|.
name|ke_thread
operator|=
operator|&
name|thread0
expr_stmt|;
name|kse0
operator|.
name|ke_state
operator|=
name|KES_THREAD
expr_stmt|;
name|kse0
operator|.
name|ke_slice
operator|=
literal|100
expr_stmt|;
name|kg_sched0
operator|.
name|skg_concurrency
operator|=
literal|1
expr_stmt|;
name|kg_sched0
operator|.
name|skg_avail_opennings
operator|=
literal|0
expr_stmt|;
comment|/* we are already running */
block|}
end_function

begin_comment
comment|/*  * This is only somewhat accurate since given many processes of the same  * priority they will switch when their slices run out, which will be  * at most SCHED_SLICE_MAX.  */
end_comment

begin_function
name|int
name|sched_rr_interval
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|def_timeslice
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sched_pctcpu_update
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
comment|/* 	 * Adjust counters and watermark for pctcpu calc. 	 */
if|if
condition|(
name|ke
operator|->
name|ke_ltick
operator|>
name|ticks
operator|-
name|SCHED_CPU_TICKS
condition|)
block|{
comment|/* 		 * Shift the tick count out so that the divide doesn't 		 * round away our results. 		 */
name|ke
operator|->
name|ke_ticks
operator|<<=
literal|10
expr_stmt|;
name|ke
operator|->
name|ke_ticks
operator|=
operator|(
name|ke
operator|->
name|ke_ticks
operator|/
operator|(
name|ticks
operator|-
name|ke
operator|->
name|ke_ftick
operator|)
operator|)
operator|*
name|SCHED_CPU_TICKS
expr_stmt|;
name|ke
operator|->
name|ke_ticks
operator|>>=
literal|10
expr_stmt|;
block|}
else|else
name|ke
operator|->
name|ke_ticks
operator|=
literal|0
expr_stmt|;
name|ke
operator|->
name|ke_ltick
operator|=
name|ticks
expr_stmt|;
name|ke
operator|->
name|ke_ftick
operator|=
name|ke
operator|->
name|ke_ltick
operator|-
name|SCHED_CPU_TICKS
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_thread_priority
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|u_char
name|prio
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|td
operator|->
name|td_priority
operator|==
name|prio
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TD_ON_RUNQ
argument_list|(
name|td
argument_list|)
condition|)
block|{
comment|/* 		 * If the priority has been elevated due to priority 		 * propagation, we may have to move ourselves to a new 		 * queue.  We still call adjustrunqueue below in case kse 		 * needs to fix things up. 		 */
if|if
condition|(
name|prio
operator|<
name|td
operator|->
name|td_priority
operator|&&
name|ke
operator|->
name|ke_runq
operator|!=
name|NULL
operator|&&
name|ke
operator|->
name|ke_runq
operator|!=
name|KSEQ_CPU
argument_list|(
name|ke
operator|->
name|ke_cpu
argument_list|)
operator|->
name|ksq_curr
condition|)
block|{
name|krunq_remove
argument_list|(
name|ke
operator|->
name|ke_runq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_runq
operator|=
name|KSEQ_CPU
argument_list|(
name|ke
operator|->
name|ke_cpu
argument_list|)
operator|->
name|ksq_curr
expr_stmt|;
name|krunq_add
argument_list|(
name|ke
operator|->
name|ke_runq
argument_list|,
name|ke
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Hold this kse on this cpu so that sched_prio() doesn't 		 * cause excessive migration.  We only want migration to 		 * happen as the result of a wakeup. 		 */
name|ke
operator|->
name|ke_flags
operator||=
name|KEF_HOLD
expr_stmt|;
name|adjustrunqueue
argument_list|(
name|td
argument_list|,
name|prio
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_flags
operator|&=
operator|~
name|KEF_HOLD
expr_stmt|;
block|}
else|else
name|td
operator|->
name|td_priority
operator|=
name|prio
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update a thread's priority when it is lent another thread's  * priority.  */
end_comment

begin_function
name|void
name|sched_lend_prio
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|u_char
name|prio
parameter_list|)
block|{
name|td
operator|->
name|td_flags
operator||=
name|TDF_BORROWING
expr_stmt|;
name|sched_thread_priority
argument_list|(
name|td
argument_list|,
name|prio
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restore a thread's priority when priority propagation is  * over.  The prio argument is the minimum priority the thread  * needs to have to satisfy other possible priority lending  * requests.  If the thread's regular priority is less  * important than prio, the thread will keep a priority boost  * of prio.  */
end_comment

begin_function
name|void
name|sched_unlend_prio
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|u_char
name|prio
parameter_list|)
block|{
name|u_char
name|base_pri
decl_stmt|;
if|if
condition|(
name|td
operator|->
name|td_base_pri
operator|>=
name|PRI_MIN_TIMESHARE
operator|&&
name|td
operator|->
name|td_base_pri
operator|<=
name|PRI_MAX_TIMESHARE
condition|)
name|base_pri
operator|=
name|td
operator|->
name|td_ksegrp
operator|->
name|kg_user_pri
expr_stmt|;
else|else
name|base_pri
operator|=
name|td
operator|->
name|td_base_pri
expr_stmt|;
if|if
condition|(
name|prio
operator|>=
name|base_pri
condition|)
block|{
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_BORROWING
expr_stmt|;
name|sched_thread_priority
argument_list|(
name|td
argument_list|,
name|base_pri
argument_list|)
expr_stmt|;
block|}
else|else
name|sched_lend_prio
argument_list|(
name|td
argument_list|,
name|prio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_prio
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|u_char
name|prio
parameter_list|)
block|{
name|u_char
name|oldprio
decl_stmt|;
comment|/* First, update the base priority. */
name|td
operator|->
name|td_base_pri
operator|=
name|prio
expr_stmt|;
comment|/* 	 * If the thread is borrowing another thread's priority, don't 	 * ever lower the priority. 	 */
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_BORROWING
operator|&&
name|td
operator|->
name|td_priority
operator|<
name|prio
condition|)
return|return;
comment|/* Change the real priority. */
name|oldprio
operator|=
name|td
operator|->
name|td_priority
expr_stmt|;
name|sched_thread_priority
argument_list|(
name|td
argument_list|,
name|prio
argument_list|)
expr_stmt|;
comment|/* 	 * If the thread is on a turnstile, then let the turnstile update 	 * its state. 	 */
if|if
condition|(
name|TD_ON_LOCK
argument_list|(
name|td
argument_list|)
operator|&&
name|oldprio
operator|!=
name|prio
condition|)
name|turnstile_adjust
argument_list|(
name|td
argument_list|,
name|oldprio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_switch
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|thread
modifier|*
name|newtd
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|ksq
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|uint64_t
name|now
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|now
operator|=
name|sched_timestamp
argument_list|()
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
name|ksq
operator|=
name|KSEQ_SELF
argument_list|()
expr_stmt|;
name|td
operator|->
name|td_lastcpu
operator|=
name|td
operator|->
name|td_oncpu
expr_stmt|;
name|td
operator|->
name|td_oncpu
operator|=
name|NOCPU
expr_stmt|;
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_NEEDRESCHED
expr_stmt|;
name|td
operator|->
name|td_owepreempt
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If the KSE has been assigned it may be in the process of switching 	 * to the new cpu.  This is the case in sched_bind(). 	 */
if|if
condition|(
name|__predict_false
argument_list|(
name|td
operator|==
name|PCPU_GET
argument_list|(
name|idlethread
argument_list|)
argument_list|)
condition|)
block|{
name|TD_SET_CAN_RUN
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|ke
operator|->
name|ke_flags
operator|&
name|KEF_MIGRATING
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|SLOT_RELEASE
argument_list|(
name|td
operator|->
name|td_ksegrp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We are ending our run so make our slot available again */
name|SLOT_RELEASE
argument_list|(
name|td
operator|->
name|td_ksegrp
argument_list|)
expr_stmt|;
name|kseq_load_rem
argument_list|(
name|ksq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
if|if
condition|(
name|TD_IS_RUNNING
argument_list|(
name|td
argument_list|)
condition|)
block|{
comment|/* 			 * Don't allow the thread to migrate 			 * from a preemption. 			 */
name|ke
operator|->
name|ke_flags
operator||=
name|KEF_HOLD
expr_stmt|;
name|setrunqueue
argument_list|(
name|td
argument_list|,
operator|(
name|flags
operator|&
name|SW_PREEMPT
operator|)
condition|?
name|SRQ_OURSELF
operator||
name|SRQ_YIELDING
operator||
name|SRQ_PREEMPTED
else|:
name|SRQ_OURSELF
operator||
name|SRQ_YIELDING
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_flags
operator|&=
operator|~
name|KEF_HOLD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator|&
name|P_HADTHREADS
operator|)
operator|&&
operator|(
name|newtd
operator|==
name|NULL
operator|||
name|newtd
operator|->
name|td_ksegrp
operator|!=
name|td
operator|->
name|td_ksegrp
operator|)
condition|)
comment|/* 			 * We will not be on the run queue. 			 * So we must be sleeping or similar. 			 * Don't use the slot if we will need it  			 * for newtd. 			 */
name|slot_fill
argument_list|(
name|td
operator|->
name|td_ksegrp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newtd
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If we bring in a thread account for it as if it had been 		 * added to the run queue and then chosen. 		 */
name|newtd
operator|->
name|td_kse
operator|->
name|ke_flags
operator||=
name|KEF_DIDRUN
expr_stmt|;
name|TD_SET_RUNNING
argument_list|(
name|newtd
argument_list|)
expr_stmt|;
name|kseq_load_add
argument_list|(
name|KSEQ_SELF
argument_list|()
argument_list|,
name|newtd
operator|->
name|td_kse
argument_list|)
expr_stmt|;
comment|/* 		 * XXX When we preempt, we've already consumed a slot because 		 * we got here through sched_add().  However, newtd can come 		 * from thread_switchout() which can't SLOT_USE() because 		 * the SLOT code is scheduler dependent.  We must use the 		 * slot here otherwise. 		 */
if|if
condition|(
operator|(
name|flags
operator|&
name|SW_PREEMPT
operator|)
operator|==
literal|0
condition|)
name|SLOT_USE
argument_list|(
name|newtd
operator|->
name|td_ksegrp
argument_list|)
expr_stmt|;
name|newtd
operator|->
name|td_kse
operator|->
name|ke_timestamp
operator|=
name|now
expr_stmt|;
block|}
else|else
name|newtd
operator|=
name|choosethread
argument_list|()
expr_stmt|;
if|if
condition|(
name|td
operator|!=
name|newtd
condition|)
block|{
name|sched_update_runtime
argument_list|(
name|ke
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_lastran
operator|=
name|now
expr_stmt|;
ifdef|#
directive|ifdef
name|HWPMC_HOOKS
if|if
condition|(
name|PMC_PROC_IS_USING_PMCS
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
condition|)
name|PMC_SWITCH_CONTEXT
argument_list|(
name|td
argument_list|,
name|PMC_FN_CSW_OUT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cpu_switch
argument_list|(
name|td
argument_list|,
name|newtd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HWPMC_HOOKS
if|if
condition|(
name|PMC_PROC_IS_USING_PMCS
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
condition|)
name|PMC_SWITCH_CONTEXT
argument_list|(
name|td
argument_list|,
name|PMC_FN_CSW_IN
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|sched_lock
operator|.
name|mtx_lock
operator|=
operator|(
name|uintptr_t
operator|)
name|td
expr_stmt|;
name|td
operator|->
name|td_oncpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_nice
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|int
name|nice
parameter_list|)
block|{
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_nice
operator|=
name|nice
expr_stmt|;
name|FOREACH_KSEGRP_IN_PROC
argument_list|(
argument|p
argument_list|,
argument|kg
argument_list|)
block|{
if|if
condition|(
name|kg
operator|->
name|kg_pri_class
operator|==
name|PRI_TIMESHARE
condition|)
block|{
name|kg
operator|->
name|kg_user_pri
operator|=
name|sched_calc_pri
argument_list|(
name|kg
argument_list|)
expr_stmt|;
name|FOREACH_THREAD_IN_GROUP
argument_list|(
argument|kg
argument_list|,
argument|td
argument_list|)
name|td
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|sched_sleep
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_SINTR
condition|)
name|ke
operator|->
name|ke_activated
operator|=
literal|0
expr_stmt|;
else|else
name|ke
operator|->
name|ke_activated
operator|=
operator|-
literal|1
expr_stmt|;
name|ke
operator|->
name|ke_flags
operator||=
name|KEF_SLEEP
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_wakeup
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|,
modifier|*
name|mykseq
decl_stmt|;
name|uint64_t
name|now
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
name|kseq
operator|=
name|KSEQ_CPU
argument_list|(
name|ke
operator|->
name|ke_cpu
argument_list|)
expr_stmt|;
name|mykseq
operator|=
name|KSEQ_SELF
argument_list|()
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_flags
operator|&
name|KEF_SLEEP
condition|)
block|{
name|ke
operator|->
name|ke_flags
operator|&=
operator|~
name|KEF_SLEEP
expr_stmt|;
if|if
condition|(
name|sched_is_timeshare
argument_list|(
name|kg
argument_list|)
condition|)
block|{
name|now
operator|=
name|sched_timestamp
argument_list|()
expr_stmt|;
name|sched_commit_runtime
argument_list|(
name|ke
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|kseq
operator|!=
name|mykseq
condition|)
name|now
operator|=
name|now
operator|-
name|mykseq
operator|->
name|ksq_last_timestamp
operator|+
name|kseq
operator|->
name|ksq_last_timestamp
expr_stmt|;
endif|#
directive|endif
name|kg
operator|->
name|kg_user_pri
operator|=
name|sched_recalc_pri
argument_list|(
name|ke
argument_list|,
name|now
argument_list|)
expr_stmt|;
block|}
block|}
name|ke
operator|->
name|ke_flags
operator|&=
operator|~
name|KEF_NEXTRQ
expr_stmt|;
name|setrunqueue
argument_list|(
name|td
argument_list|,
name|SRQ_BORING
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Penalize the parent for creating a new child and initialize the child's  * priority.  */
end_comment

begin_function
name|void
name|sched_fork
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|thread
modifier|*
name|childtd
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sched_fork_ksegrp
argument_list|(
name|td
argument_list|,
name|childtd
operator|->
name|td_ksegrp
argument_list|)
expr_stmt|;
name|sched_fork_thread
argument_list|(
name|td
argument_list|,
name|childtd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_fork_ksegrp
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|ksegrp
modifier|*
name|child
parameter_list|)
block|{
name|struct
name|ksegrp
modifier|*
name|kg
init|=
name|td
operator|->
name|td_ksegrp
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|child
operator|->
name|kg_slptime
operator|=
name|kg
operator|->
name|kg_slptime
operator|*
name|CHILD_WEIGHT
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|kg_pri_class
operator|==
name|PRI_TIMESHARE
condition|)
name|child
operator|->
name|kg_user_pri
operator|=
name|sched_calc_pri
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|kg
operator|->
name|kg_slptime
operator|=
name|kg
operator|->
name|kg_slptime
operator|*
name|PARENT_WEIGHT
operator|/
literal|100
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_fork_thread
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|thread
modifier|*
name|child
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke2
decl_stmt|;
name|sched_newthread
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|ke2
operator|=
name|child
operator|->
name|td_kse
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|ke2
operator|->
name|ke_cpu
operator|=
name|sched_find_idlest_cpu
argument_list|(
name|ke
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ke2
operator|->
name|ke_cpu
operator|=
name|ke
operator|->
name|ke_cpu
expr_stmt|;
endif|#
directive|endif
name|ke2
operator|->
name|ke_slice
operator|=
operator|(
name|ke
operator|->
name|ke_slice
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|ke2
operator|->
name|ke_flags
operator||=
name|KEF_FIRST_SLICE
expr_stmt|;
name|ke2
operator|->
name|ke_activated
operator|=
literal|0
expr_stmt|;
name|ke2
operator|->
name|ke_timestamp
operator|=
name|sched_timestamp
argument_list|()
expr_stmt|;
name|ke
operator|->
name|ke_slice
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_slice
operator|==
literal|0
condition|)
block|{
name|ke
operator|->
name|ke_slice
operator|=
literal|1
expr_stmt|;
name|sched_tick
argument_list|()
expr_stmt|;
block|}
comment|/* Grab our parents cpu estimation information. */
name|ke2
operator|->
name|ke_ticks
operator|=
name|ke
operator|->
name|ke_ticks
expr_stmt|;
name|ke2
operator|->
name|ke_ltick
operator|=
name|ke
operator|->
name|ke_ltick
expr_stmt|;
name|ke2
operator|->
name|ke_ftick
operator|=
name|ke
operator|->
name|ke_ftick
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_class
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|,
name|int
name|class
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|nclass
decl_stmt|;
name|int
name|oclass
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|kg
operator|->
name|kg_pri_class
operator|==
name|class
condition|)
return|return;
name|nclass
operator|=
name|PRI_BASE
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|oclass
operator|=
name|PRI_BASE
argument_list|(
name|kg
operator|->
name|kg_pri_class
argument_list|)
expr_stmt|;
name|FOREACH_THREAD_IN_GROUP
argument_list|(
argument|kg
argument_list|,
argument|td
argument_list|)
block|{
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
comment|/* New thread does not have runq assigned */
if|if
condition|(
name|ke
operator|->
name|ke_runq
operator|==
name|NULL
condition|)
continue|continue;
name|kseq
operator|=
name|KSEQ_CPU
argument_list|(
name|ke
operator|->
name|ke_cpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|oclass
operator|==
name|PRI_TIMESHARE
condition|)
name|kseq
operator|->
name|ksq_load_timeshare
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|oclass
operator|==
name|PRI_IDLE
condition|)
name|kseq
operator|->
name|ksq_load_idle
operator|--
expr_stmt|;
if|if
condition|(
name|nclass
operator|==
name|PRI_TIMESHARE
condition|)
name|kseq
operator|->
name|ksq_load_timeshare
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|nclass
operator|==
name|PRI_IDLE
condition|)
name|kseq
operator|->
name|ksq_load_idle
operator|++
expr_stmt|;
block|}
name|kg
operator|->
name|kg_pri_class
operator|=
name|class
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return some of the child's priority and interactivity to the parent.  */
end_comment

begin_function
name|void
name|sched_exit
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|thread
modifier|*
name|childtd
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sched_exit_thread
argument_list|(
name|FIRST_THREAD_IN_PROC
argument_list|(
name|p
argument_list|)
argument_list|,
name|childtd
argument_list|)
expr_stmt|;
name|sched_exit_ksegrp
argument_list|(
name|FIRST_KSEGRP_IN_PROC
argument_list|(
name|p
argument_list|)
argument_list|,
name|childtd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_exit_ksegrp
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|parentkg
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
if|if
condition|(
name|td
operator|->
name|td_ksegrp
operator|->
name|kg_slptime
operator|<
name|parentkg
operator|->
name|kg_slptime
condition|)
block|{
name|parentkg
operator|->
name|kg_slptime
operator|=
name|parentkg
operator|->
name|kg_slptime
operator|/
operator|(
name|EXIT_WEIGHT
operator|)
operator|*
operator|(
name|EXIT_WEIGHT
operator|-
literal|1
operator|)
operator|+
name|td
operator|->
name|td_ksegrp
operator|->
name|kg_slptime
operator|/
name|EXIT_WEIGHT
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sched_exit_thread
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|thread
modifier|*
name|childtd
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|childke
init|=
name|childtd
operator|->
name|td_kse
decl_stmt|;
name|struct
name|kse
modifier|*
name|parentke
init|=
name|td
operator|->
name|td_kse
decl_stmt|;
name|kseq_load_rem
argument_list|(
name|KSEQ_CPU
argument_list|(
name|childke
operator|->
name|ke_cpu
argument_list|)
argument_list|,
name|childke
argument_list|)
expr_stmt|;
name|sched_update_runtime
argument_list|(
name|childke
argument_list|,
name|sched_timestamp
argument_list|()
argument_list|)
expr_stmt|;
name|sched_commit_runtime
argument_list|(
name|childke
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|childke
operator|->
name|ke_flags
operator|&
name|KEF_FIRST_SLICE
operator|)
operator|&&
name|td
operator|->
name|td_proc
operator|==
name|childtd
operator|->
name|td_proc
operator|->
name|p_pptr
condition|)
block|{
name|parentke
operator|->
name|ke_slice
operator|+=
name|childke
operator|->
name|ke_slice
expr_stmt|;
if|if
condition|(
name|parentke
operator|->
name|ke_slice
operator|>
name|sched_timeslice
argument_list|(
name|parentke
argument_list|)
condition|)
name|parentke
operator|->
name|ke_slice
operator|=
name|sched_timeslice
argument_list|(
name|parentke
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sched_starving
parameter_list|(
name|struct
name|kseq
modifier|*
name|ksq
parameter_list|,
name|uint64_t
name|now
parameter_list|,
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
name|uint64_t
name|delta
decl_stmt|;
if|if
condition|(
name|PROC_NICE
argument_list|(
name|ke
operator|->
name|ke_proc
argument_list|)
operator|>
name|ksq
operator|->
name|ksq_best_expired_nice
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ksq
operator|->
name|ksq_expired_timestamp
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|delta
operator|=
name|now
operator|-
name|ksq
operator|->
name|ksq_expired_timestamp
expr_stmt|;
if|if
condition|(
name|delta
operator|>
name|STARVATION_TIME
operator|*
operator|(
name|ksq
operator|->
name|ksq_load
operator|-
name|ksq
operator|->
name|ksq_load_idle
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * An interactive thread has smaller time slice granularity,  * a cpu hog can have larger granularity.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|sched_timeslice_split
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
name|int
name|score
decl_stmt|,
name|g
decl_stmt|;
name|score
operator|=
call|(
name|int
call|)
argument_list|(
name|MAX_SCORE
operator|-
name|CURRENT_SCORE
argument_list|(
name|ke
operator|->
name|ke_ksegrp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|score
operator|==
literal|0
condition|)
name|score
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|g
operator|=
name|granularity
operator|*
operator|(
operator|(
literal|1
operator|<<
name|score
operator|)
operator|-
literal|1
operator|)
operator|*
name|smp_cpus
expr_stmt|;
else|#
directive|else
name|g
operator|=
name|granularity
operator|*
operator|(
operator|(
literal|1
operator|<<
name|score
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ke
operator|->
name|ke_slice
operator|>=
name|g
operator|&&
name|ke
operator|->
name|ke_slice
operator|%
name|g
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sched_tick
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|uint64_t
name|now
decl_stmt|;
name|int
name|cpuid
decl_stmt|;
name|int
name|class
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|kg
operator|=
name|ke
operator|->
name|ke_ksegrp
expr_stmt|;
name|p
operator|=
name|ke
operator|->
name|ke_proc
expr_stmt|;
name|class
operator|=
name|PRI_BASE
argument_list|(
name|kg
operator|->
name|kg_pri_class
argument_list|)
expr_stmt|;
name|now
operator|=
name|sched_timestamp
argument_list|()
expr_stmt|;
name|cpuid
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|kseq
operator|=
name|KSEQ_CPU
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|kseq
operator|->
name|ksq_last_timestamp
operator|=
name|now
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|PRI_IDLE
condition|)
block|{
name|int
name|idle_td
init|=
operator|(
name|curthread
operator|==
name|PCPU_GET
argument_list|(
name|idlethread
argument_list|)
operator|)
decl_stmt|;
comment|/* 		 * Processes of equal idle priority are run round-robin. 		 */
if|if
condition|(
operator|!
name|idle_td
operator|&&
operator|--
name|ke
operator|->
name|ke_slice
operator|<=
literal|0
condition|)
block|{
name|ke
operator|->
name|ke_slice
operator|=
name|def_timeslice
expr_stmt|;
name|td
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
block|}
name|sched_balance_tick
argument_list|(
name|cpuid
argument_list|,
name|idle_td
condition|?
name|IDLE_IDLE
else|:
name|IDLE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ke
operator|->
name|ke_flags
operator|&
name|KEF_NEXTRQ
condition|)
block|{
comment|/* The thread was already scheduled off. */
name|curthread
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|class
operator|==
name|PRI_REALTIME
condition|)
block|{
comment|/* 		 * Realtime scheduling, do round robin for RR class, FIFO 		 * is not affected. 		 */
if|if
condition|(
name|PRI_NEED_RR
argument_list|(
name|kg
operator|->
name|kg_pri_class
argument_list|)
operator|&&
operator|--
name|ke
operator|->
name|ke_slice
operator|<=
literal|0
condition|)
block|{
name|ke
operator|->
name|ke_slice
operator|=
name|def_timeslice
expr_stmt|;
name|curthread
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Current, we skip kernel thread, though it may be classified as 	 * TIMESHARE. 	 */
if|if
condition|(
name|class
operator|!=
name|PRI_TIMESHARE
operator|||
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_KTHREAD
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|--
name|ke
operator|->
name|ke_slice
operator|<=
literal|0
condition|)
block|{
name|curthread
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
name|sched_update_runtime
argument_list|(
name|ke
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|sched_commit_runtime
argument_list|(
name|ke
argument_list|)
expr_stmt|;
name|kg
operator|->
name|kg_user_pri
operator|=
name|sched_calc_pri
argument_list|(
name|kg
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_slice
operator|=
name|sched_timeslice
argument_list|(
name|ke
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_flags
operator|&=
operator|~
name|KEF_FIRST_SLICE
expr_stmt|;
if|if
condition|(
operator|!
name|kseq
operator|->
name|ksq_expired_timestamp
condition|)
name|kseq
operator|->
name|ksq_expired_timestamp
operator|=
name|now
expr_stmt|;
if|if
condition|(
operator|!
name|THREAD_IS_INTERACTIVE
argument_list|(
name|ke
argument_list|)
operator|||
name|sched_starving
argument_list|(
name|kseq
argument_list|,
name|now
argument_list|,
name|ke
argument_list|)
condition|)
block|{
comment|/* The thead becomes cpu hog, schedule it off. */
name|ke
operator|->
name|ke_flags
operator||=
name|KEF_NEXTRQ
expr_stmt|;
if|if
condition|(
name|PROC_NICE
argument_list|(
name|p
argument_list|)
operator|<
name|kseq
operator|->
name|ksq_best_expired_nice
condition|)
name|kseq
operator|->
name|ksq_best_expired_nice
operator|=
name|PROC_NICE
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Don't allow an interactive thread which has long timeslice 		 * to monopolize CPU, split the long timeslice into small 		 * chunks. This essentially does round-robin between 		 * interactive threads. 		 */
if|if
condition|(
name|THREAD_IS_INTERACTIVE
argument_list|(
name|ke
argument_list|)
operator|&&
name|sched_timeslice_split
argument_list|(
name|ke
argument_list|)
condition|)
name|curthread
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
block|}
name|out
label|:
name|sched_balance_tick
argument_list|(
name|cpuid
argument_list|,
name|NOT_IDLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_clock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|kg
operator|=
name|ke
operator|->
name|ke_ksegrp
expr_stmt|;
comment|/* Adjust ticks for pctcpu */
name|ke
operator|->
name|ke_ticks
operator|++
expr_stmt|;
name|ke
operator|->
name|ke_ltick
operator|=
name|ticks
expr_stmt|;
comment|/* Go up to one second beyond our max and then trim back down */
if|if
condition|(
name|ke
operator|->
name|ke_ftick
operator|+
name|SCHED_CPU_TICKS
operator|+
name|hz
operator|<
name|ke
operator|->
name|ke_ltick
condition|)
name|sched_pctcpu_update
argument_list|(
name|ke
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sched_runnable
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|kseq
operator|=
name|KSEQ_SELF
argument_list|()
expr_stmt|;
if|if
condition|(
name|krunq_findbit
argument_list|(
name|kseq
operator|->
name|ksq_curr
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|krunq_findbit
argument_list|(
name|kseq
operator|->
name|ksq_next
argument_list|)
operator|!=
operator|-
literal|1
operator|||
name|krunq_findbit
argument_list|(
operator|&
name|kseq
operator|->
name|ksq_idle
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sched_userret
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_BORROWING
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"thread with borrowed priority returning to userland"
operator|)
argument_list|)
expr_stmt|;
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_priority
operator|!=
name|kg
operator|->
name|kg_user_pri
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_priority
operator|=
name|kg
operator|->
name|kg_user_pri
expr_stmt|;
name|td
operator|->
name|td_base_pri
operator|=
name|kg
operator|->
name|kg_user_pri
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|kse
modifier|*
name|sched_choose
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|kseq
operator|=
name|KSEQ_SELF
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|restart
label|:
endif|#
directive|endif
name|ke
operator|=
name|kseq_choose
argument_list|(
name|kseq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
condition|)
block|{
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|ke
operator|->
name|ke_ksegrp
operator|->
name|kg_pri_class
operator|==
name|PRI_IDLE
condition|)
if|if
condition|(
name|sched_idled
argument_list|(
name|kseq
argument_list|,
name|IDLE
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|restart
goto|;
endif|#
directive|endif
name|kseq_runq_rem
argument_list|(
name|kseq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_state
operator|=
name|KES_THREAD
expr_stmt|;
name|ke
operator|->
name|ke_flags
operator|&=
operator|~
name|KEF_PREEMPTED
expr_stmt|;
name|ke
operator|->
name|ke_timestamp
operator|=
name|sched_timestamp
argument_list|()
expr_stmt|;
return|return
operator|(
name|ke
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|sched_idled
argument_list|(
name|kseq
argument_list|,
name|IDLE_IDLE
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|restart
goto|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sched_add
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|ksq
decl_stmt|,
modifier|*
name|my_ksq
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|int
name|preemptive
decl_stmt|;
name|int
name|canmigrate
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
name|my_cpu
decl_stmt|;
name|int
name|nextrq
decl_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|struct
name|thread
modifier|*
name|td2
decl_stmt|;
name|struct
name|pcpu
modifier|*
name|pcpu
decl_stmt|;
name|int
name|cpu
decl_stmt|,
name|new_cpu
decl_stmt|;
name|int
name|load
decl_stmt|,
name|my_load
decl_stmt|;
endif|#
directive|endif
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
name|KASSERT
argument_list|(
name|ke
operator|->
name|ke_state
operator|!=
name|KES_ONRUNQ
argument_list|,
operator|(
literal|"sched_add: kse %p (%s) already in run queue"
operator|,
name|ke
operator|,
name|ke
operator|->
name|ke_proc
operator|->
name|p_comm
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ke
operator|->
name|ke_proc
operator|->
name|p_sflag
operator|&
name|PS_INMEM
argument_list|,
operator|(
literal|"sched_add: process swapped out"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ke
operator|->
name|ke_runq
operator|==
name|NULL
argument_list|,
operator|(
literal|"sched_add: KSE %p is still assigned to a run queue"
operator|,
name|ke
operator|)
argument_list|)
expr_stmt|;
name|canmigrate
operator|=
literal|1
expr_stmt|;
name|preemptive
operator|=
operator|!
operator|(
name|flags
operator|&
name|SRQ_YIELDING
operator|)
expr_stmt|;
name|class
operator|=
name|PRI_BASE
argument_list|(
name|kg
operator|->
name|kg_pri_class
argument_list|)
expr_stmt|;
name|my_cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|my_ksq
operator|=
name|KSEQ_CPU
argument_list|(
name|my_cpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SRQ_PREEMPTED
condition|)
name|ke
operator|->
name|ke_flags
operator||=
name|KEF_PREEMPTED
expr_stmt|;
if|if
condition|(
operator|(
name|ke
operator|->
name|ke_flags
operator|&
name|KEF_INTERNAL
operator|)
operator|==
literal|0
condition|)
name|SLOT_USE
argument_list|(
name|td
operator|->
name|td_ksegrp
argument_list|)
expr_stmt|;
name|nextrq
operator|=
operator|(
name|ke
operator|->
name|ke_flags
operator|&
name|KEF_NEXTRQ
operator|)
expr_stmt|;
name|ke
operator|->
name|ke_flags
operator|&=
operator|~
operator|(
name|KEF_NEXTRQ
operator||
name|KEF_INTERNAL
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|cpu
operator|=
name|ke
operator|->
name|ke_cpu
expr_stmt|;
name|canmigrate
operator|=
name|kse_can_migrate
argument_list|(
name|ke
argument_list|)
expr_stmt|;
comment|/* 	 * Don't migrate running threads here.  Force the long term balancer 	 * to do it. 	 */
if|if
condition|(
name|ke
operator|->
name|ke_flags
operator|&
name|KEF_HOLD
condition|)
block|{
name|ke
operator|->
name|ke_flags
operator|&=
operator|~
name|KEF_HOLD
expr_stmt|;
name|canmigrate
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If this thread is pinned or bound, notify the target cpu. 	 */
if|if
condition|(
operator|!
name|canmigrate
condition|)
goto|goto
name|activate_it
goto|;
if|if
condition|(
name|class
operator|==
name|PRI_ITHD
condition|)
block|{
name|ke
operator|->
name|ke_cpu
operator|=
name|my_cpu
expr_stmt|;
goto|goto
name|activate_it
goto|;
block|}
if|if
condition|(
name|ke
operator|->
name|ke_cpu
operator|==
name|my_cpu
condition|)
goto|goto
name|activate_it
goto|;
if|if
condition|(
name|my_ksq
operator|->
name|ksq_group
operator|->
name|ksg_idlemask
operator|&
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
condition|)
block|{
name|ke
operator|->
name|ke_cpu
operator|=
name|my_cpu
expr_stmt|;
goto|goto
name|activate_it
goto|;
block|}
name|new_cpu
operator|=
name|my_cpu
expr_stmt|;
name|load
operator|=
name|kseq_source_load
argument_list|(
name|KSEQ_CPU
argument_list|(
name|cpu
argument_list|)
argument_list|)
expr_stmt|;
name|my_load
operator|=
name|kseq_dest_load
argument_list|(
name|my_ksq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|my_load
operator|-
name|load
operator|)
operator|*
literal|100
operator|<
name|my_load
operator|*
name|imbalance_pct2
condition|)
goto|goto
name|try_idle_cpu
goto|;
name|new_cpu
operator|=
name|cpu
expr_stmt|;
name|try_idle_cpu
label|:
name|new_cpu
operator|=
name|sched_find_idle_cpu
argument_list|(
name|new_cpu
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_cpu
operator|=
name|new_cpu
expr_stmt|;
name|activate_it
label|:
if|if
condition|(
name|ke
operator|->
name|ke_cpu
operator|!=
name|cpu
condition|)
name|ke
operator|->
name|ke_lastran
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|ksq
operator|=
name|KSEQ_CPU
argument_list|(
name|ke
operator|->
name|ke_cpu
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|PRI_ITHD
case|:
case|case
name|PRI_REALTIME
case|:
name|ke
operator|->
name|ke_runq
operator|=
name|ksq
operator|->
name|ksq_curr
expr_stmt|;
break|break;
case|case
name|PRI_TIMESHARE
case|:
if|if
condition|(
operator|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_BORROWING
operator|)
operator|==
literal|0
operator|&&
name|nextrq
condition|)
name|ke
operator|->
name|ke_runq
operator|=
name|ksq
operator|->
name|ksq_next
expr_stmt|;
else|else
name|ke
operator|->
name|ke_runq
operator|=
name|ksq
operator|->
name|ksq_curr
expr_stmt|;
break|break;
case|case
name|PRI_IDLE
case|:
comment|/* 		 * This is for priority prop. 		 */
if|if
condition|(
name|td
operator|->
name|td_priority
operator|<
name|PRI_MIN_IDLE
condition|)
name|ke
operator|->
name|ke_runq
operator|=
name|ksq
operator|->
name|ksq_curr
expr_stmt|;
else|else
name|ke
operator|->
name|ke_runq
operator|=
operator|&
name|ksq
operator|->
name|ksq_idle
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unknown pri class."
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ke
operator|->
name|ke_runq
operator|==
name|my_ksq
operator|->
name|ksq_curr
operator|&&
name|td
operator|->
name|td_priority
operator|<
name|curthread
operator|->
name|td_priority
condition|)
block|{
name|curthread
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
name|ke
operator|->
name|ke_runq
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|preemptive
operator|&&
name|maybe_preempt
argument_list|(
name|td
argument_list|)
condition|)
return|return;
name|ke
operator|->
name|ke_runq
operator|=
name|my_ksq
operator|->
name|ksq_curr
expr_stmt|;
if|if
condition|(
name|curthread
operator|->
name|td_ksegrp
operator|->
name|kg_pri_class
operator|==
name|PRI_IDLE
condition|)
name|td
operator|->
name|td_owepreempt
operator|=
literal|1
expr_stmt|;
block|}
name|ke
operator|->
name|ke_state
operator|=
name|KES_ONRUNQ
expr_stmt|;
name|kseq_runq_add
argument_list|(
name|ksq
argument_list|,
name|ke
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|kseq_load_add
argument_list|(
name|ksq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|pcpu
operator|=
name|pcpu_find
argument_list|(
name|ke
operator|->
name|ke_cpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|!=
name|PRI_IDLE
condition|)
block|{
if|if
condition|(
name|kseq_idle
operator|&
name|ksq
operator|->
name|ksq_group
operator|->
name|ksg_mask
condition|)
name|kseq_idle
operator|&=
operator|~
name|ksq
operator|->
name|ksq_group
operator|->
name|ksg_mask
expr_stmt|;
if|if
condition|(
name|ksq
operator|->
name|ksq_group
operator|->
name|ksg_idlemask
operator|&
name|pcpu
operator|->
name|pc_cpumask
condition|)
name|ksq
operator|->
name|ksq_group
operator|->
name|ksg_idlemask
operator|&=
operator|~
name|pcpu
operator|->
name|pc_cpumask
expr_stmt|;
block|}
if|if
condition|(
name|ke
operator|->
name|ke_cpu
operator|!=
name|my_cpu
condition|)
block|{
name|td2
operator|=
name|pcpu
operator|->
name|pc_curthread
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|td2
operator|==
name|pcpu
operator|->
name|pc_idlethread
argument_list|)
condition|)
block|{
name|td2
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
name|ipi_selected
argument_list|(
name|pcpu
operator|->
name|pc_cpumask
argument_list|,
name|IPI_AST
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|td
operator|->
name|td_priority
operator|<
name|td2
operator|->
name|td_priority
condition|)
block|{
if|if
condition|(
name|class
operator|==
name|PRI_ITHD
operator|||
name|class
operator|==
name|PRI_REALTIME
operator|||
name|td2
operator|->
name|td_ksegrp
operator|->
name|kg_pri_class
operator|==
name|PRI_IDLE
condition|)
name|ipi_selected
argument_list|(
name|pcpu
operator|->
name|pc_cpumask
argument_list|,
name|IPI_PREEMPT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|td2
operator|->
name|td_flags
operator|&
name|TDF_NEEDRESCHED
operator|)
operator|==
literal|0
condition|)
block|{
name|td2
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
name|ipi_selected
argument_list|(
name|pcpu
operator|->
name|pc_cpumask
argument_list|,
name|IPI_AST
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|sched_rem
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|ke
operator|->
name|ke_flags
operator|&=
operator|~
name|KEF_PREEMPTED
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ke
operator|->
name|ke_state
operator|==
name|KES_ONRUNQ
operator|)
argument_list|,
operator|(
literal|"sched_rem: KSE not on run queue"
operator|)
argument_list|)
expr_stmt|;
name|kseq
operator|=
name|KSEQ_CPU
argument_list|(
name|ke
operator|->
name|ke_cpu
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|ke
operator|->
name|ke_flags
operator|&
name|KEF_MIGRATING
condition|)
block|{
name|ke
operator|->
name|ke_flags
operator|&=
operator|~
name|KEF_MIGRATING
expr_stmt|;
name|kseq_load_rem
argument_list|(
name|kseq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kseq
operator|->
name|ksq_migrateq
argument_list|,
name|ke
argument_list|,
name|ke_procq
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_cpu
operator|=
name|ke
operator|->
name|ke_tocpu
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|KASSERT
argument_list|(
operator|(
name|ke
operator|->
name|ke_state
operator|==
name|KES_ONRUNQ
operator|)
argument_list|,
operator|(
literal|"sched_rem: KSE not on run queue"
operator|)
argument_list|)
expr_stmt|;
name|SLOT_RELEASE
argument_list|(
name|td
operator|->
name|td_ksegrp
argument_list|)
expr_stmt|;
name|kseq_runq_rem
argument_list|(
name|kseq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|kseq_load_rem
argument_list|(
name|kseq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
block|}
name|ke
operator|->
name|ke_state
operator|=
name|KES_THREAD
expr_stmt|;
block|}
end_function

begin_function
name|fixpt_t
name|sched_pctcpu
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|fixpt_t
name|pctcpu
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|pctcpu
operator|=
literal|0
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
if|if
condition|(
name|ke
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_ticks
condition|)
block|{
name|int
name|rtick
decl_stmt|;
comment|/* 		 * Don't update more frequently than twice a second.  Allowing 		 * this causes the cpu usage to decay away too quickly due to 		 * rounding errors. 		 */
if|if
condition|(
name|ke
operator|->
name|ke_ftick
operator|+
name|SCHED_CPU_TICKS
operator|<
name|ke
operator|->
name|ke_ltick
operator|||
name|ke
operator|->
name|ke_ltick
operator|<
operator|(
name|ticks
operator|-
operator|(
name|hz
operator|/
literal|2
operator|)
operator|)
condition|)
name|sched_pctcpu_update
argument_list|(
name|ke
argument_list|)
expr_stmt|;
comment|/* How many rtick per second ? */
name|rtick
operator|=
name|MIN
argument_list|(
name|ke
operator|->
name|ke_ticks
operator|/
name|SCHED_CPU_TIME
argument_list|,
name|SCHED_CPU_TICKS
argument_list|)
expr_stmt|;
name|pctcpu
operator|=
operator|(
name|FSCALE
operator|*
operator|(
operator|(
name|FSCALE
operator|*
name|rtick
operator|)
operator|/
name|realstathz
operator|)
operator|)
operator|>>
name|FSHIFT
expr_stmt|;
block|}
name|ke
operator|->
name|ke_proc
operator|->
name|p_swtime
operator|=
name|ke
operator|->
name|ke_ltick
operator|-
name|ke
operator|->
name|ke_ftick
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|pctcpu
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sched_bind
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|cpu
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|ke
operator|->
name|ke_flags
operator||=
name|KEF_BOUND
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
operator|==
name|cpu
condition|)
return|return;
name|kseq
operator|=
name|KSEQ_SELF
argument_list|()
expr_stmt|;
name|ke
operator|->
name|ke_flags
operator||=
name|KEF_MIGRATING
expr_stmt|;
name|ke
operator|->
name|ke_tocpu
operator|=
name|cpu
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|kseq
operator|->
name|ksq_migrateq
argument_list|,
name|ke
argument_list|,
name|ke_procq
argument_list|)
expr_stmt|;
if|if
condition|(
name|kseq
operator|->
name|ksq_migrated
condition|)
block|{
if|if
condition|(
name|TD_AWAITING_INTR
argument_list|(
name|kseq
operator|->
name|ksq_migrated
argument_list|)
condition|)
block|{
name|TD_CLR_IWAIT
argument_list|(
name|kseq
operator|->
name|ksq_migrated
argument_list|)
expr_stmt|;
name|setrunqueue
argument_list|(
name|kseq
operator|->
name|ksq_migrated
argument_list|,
name|SRQ_YIELDING
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* When we return from mi_switch we'll be on the correct cpu. */
name|mi_switch
argument_list|(
name|SW_VOL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|kseq
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|sched_unbind
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_kse
operator|->
name|ke_flags
operator|&=
operator|~
name|KEF_BOUND
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sched_is_bound
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
return|return
operator|(
name|td
operator|->
name|td_kse
operator|->
name|ke_flags
operator|&
name|KEF_BOUND
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sched_load
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SMP
name|int
name|total
decl_stmt|;
name|int
name|i
decl_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
name|total
operator|+=
name|KSEQ_CPU
argument_list|(
name|i
argument_list|)
operator|->
name|ksq_sysload
expr_stmt|;
return|return
operator|(
name|total
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|KSEQ_SELF
argument_list|()
operator|->
name|ksq_sysload
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|sched_sizeof_ksegrp
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ksegrp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|kg_sched
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sched_sizeof_proc
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sched_sizeof_thread
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|td_sched
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|KERN_SWITCH_INCLUDE
value|1
end_define

begin_include
include|#
directive|include
file|"kern/kern_switch.c"
end_include

end_unit

