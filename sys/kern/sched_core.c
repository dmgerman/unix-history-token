begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005-2006, David Xu<yfxu@corp.netease.com>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_hwpmc_hooks.h"
end_include

begin_include
include|#
directive|include
file|"opt_sched.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/turnstile.h>
end_include

begin_include
include|#
directive|include
file|<sys/umtx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HWPMC_HOOKS
end_ifdef

begin_include
include|#
directive|include
file|<sys/pmckern.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_comment
comment|/* get process's nice value, skip value 20 which is not supported */
end_comment

begin_define
define|#
directive|define
name|PROC_NICE
parameter_list|(
name|p
parameter_list|)
value|MIN((p)->p_nice, 19)
end_define

begin_comment
comment|/* convert nice to kernel thread priority */
end_comment

begin_define
define|#
directive|define
name|NICE_TO_PRI
parameter_list|(
name|nice
parameter_list|)
value|(PUSER + 20 + (nice))
end_define

begin_comment
comment|/* get process's static priority */
end_comment

begin_define
define|#
directive|define
name|PROC_PRI
parameter_list|(
name|p
parameter_list|)
value|NICE_TO_PRI(PROC_NICE(p))
end_define

begin_comment
comment|/* convert kernel thread priority to user priority */
end_comment

begin_define
define|#
directive|define
name|USER_PRI
parameter_list|(
name|pri
parameter_list|)
value|MIN((pri) - PUSER, 39)
end_define

begin_comment
comment|/* convert nice value to user priority */
end_comment

begin_define
define|#
directive|define
name|PROC_USER_PRI
parameter_list|(
name|p
parameter_list|)
value|(PROC_NICE(p) + 20)
end_define

begin_comment
comment|/* maximum user priority, highest prio + 1 */
end_comment

begin_define
define|#
directive|define
name|MAX_USER_PRI
value|40
end_define

begin_comment
comment|/* maximum kernel priority its nice is 19 */
end_comment

begin_define
define|#
directive|define
name|PUSER_MAX
value|(PUSER + 39)
end_define

begin_comment
comment|/* ticks and nanosecond converters */
end_comment

begin_define
define|#
directive|define
name|NS_TO_HZ
parameter_list|(
name|n
parameter_list|)
value|((n) / (1000000000 / hz))
end_define

begin_define
define|#
directive|define
name|HZ_TO_NS
parameter_list|(
name|h
parameter_list|)
value|((h) * (1000000000 / hz))
end_define

begin_comment
comment|/* ticks and microsecond converters */
end_comment

begin_define
define|#
directive|define
name|MS_TO_HZ
parameter_list|(
name|m
parameter_list|)
value|((m) / (1000000 / hz))
end_define

begin_define
define|#
directive|define
name|PRI_SCORE_RATIO
value|25
end_define

begin_define
define|#
directive|define
name|MAX_SCORE
value|(MAX_USER_PRI * PRI_SCORE_RATIO / 100)
end_define

begin_define
define|#
directive|define
name|MAX_SLEEP_TIME
value|(def_timeslice * MAX_SCORE)
end_define

begin_define
define|#
directive|define
name|NS_MAX_SLEEP_TIME
value|(HZ_TO_NS(MAX_SLEEP_TIME))
end_define

begin_define
define|#
directive|define
name|STARVATION_TIME
value|(MAX_SLEEP_TIME)
end_define

begin_define
define|#
directive|define
name|CURRENT_SCORE
parameter_list|(
name|ts
parameter_list|)
define|\
value|(MAX_SCORE * NS_TO_HZ((ts)->ts_slptime) / MAX_SLEEP_TIME)
end_define

begin_define
define|#
directive|define
name|SCALE_USER_PRI
parameter_list|(
name|x
parameter_list|,
name|upri
parameter_list|)
define|\
value|MAX(x * (upri + 1) / (MAX_USER_PRI/2), min_timeslice)
end_define

begin_comment
comment|/*  * For a thread whose nice is zero, the score is used to determine  * if it is an interactive thread.  */
end_comment

begin_define
define|#
directive|define
name|INTERACTIVE_BASE_SCORE
value|(MAX_SCORE * 20)/100
end_define

begin_comment
comment|/*  * Calculate a score which a thread must have to prove itself is  * an interactive thread.  */
end_comment

begin_define
define|#
directive|define
name|INTERACTIVE_SCORE
parameter_list|(
name|ts
parameter_list|)
define|\
value|(PROC_NICE((ts)->ts_proc) * MAX_SCORE / 40 + INTERACTIVE_BASE_SCORE)
end_define

begin_comment
comment|/* Test if a thread is an interactive thread */
end_comment

begin_define
define|#
directive|define
name|THREAD_IS_INTERACTIVE
parameter_list|(
name|ts
parameter_list|)
define|\
value|((ts)->ts_thread->td_user_pri<=	\ 	PROC_PRI((ts)->ts_proc) - INTERACTIVE_SCORE(ts))
end_define

begin_comment
comment|/*  * Calculate how long a thread must sleep to prove itself is an  * interactive sleep.  */
end_comment

begin_define
define|#
directive|define
name|INTERACTIVE_SLEEP_TIME
parameter_list|(
name|ts
parameter_list|)
define|\
value|(HZ_TO_NS(MAX_SLEEP_TIME *		\ 	(MAX_SCORE / 2 + INTERACTIVE_SCORE((ts)) + 1) / MAX_SCORE - 1))
end_define

begin_define
define|#
directive|define
name|CHILD_WEIGHT
value|90
end_define

begin_define
define|#
directive|define
name|PARENT_WEIGHT
value|90
end_define

begin_define
define|#
directive|define
name|EXIT_WEIGHT
value|3
end_define

begin_define
define|#
directive|define
name|SCHED_LOAD_SCALE
value|128UL
end_define

begin_define
define|#
directive|define
name|IDLE
value|0
end_define

begin_define
define|#
directive|define
name|IDLE_IDLE
value|1
end_define

begin_define
define|#
directive|define
name|NOT_IDLE
value|2
end_define

begin_define
define|#
directive|define
name|KQB_LEN
value|(8)
end_define

begin_comment
comment|/* Number of priority status words. */
end_comment

begin_define
define|#
directive|define
name|KQB_L2BPW
value|(5)
end_define

begin_comment
comment|/* Log2(sizeof(rqb_word_t) * NBBY)). */
end_comment

begin_define
define|#
directive|define
name|KQB_BPW
value|(1<<KQB_L2BPW)
end_define

begin_comment
comment|/* Bits in an rqb_word_t. */
end_comment

begin_define
define|#
directive|define
name|KQB_BIT
parameter_list|(
name|pri
parameter_list|)
value|(1<< ((pri)& (KQB_BPW - 1)))
end_define

begin_define
define|#
directive|define
name|KQB_WORD
parameter_list|(
name|pri
parameter_list|)
value|((pri)>> KQB_L2BPW)
end_define

begin_define
define|#
directive|define
name|KQB_FFS
parameter_list|(
name|word
parameter_list|)
value|(ffs(word) - 1)
end_define

begin_define
define|#
directive|define
name|KQ_NQS
value|256
end_define

begin_comment
comment|/*  * Type of run queue status word.  */
end_comment

begin_typedef
typedef|typedef
name|u_int32_t
name|kqb_word_t
typedef|;
end_typedef

begin_comment
comment|/*  * Head of run queues.  */
end_comment

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|krqhead
argument_list|,
name|td_sched
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Bit array which maintains the status of a run queue.  When a queue is  * non-empty the bit corresponding to the queue number will be set.  */
end_comment

begin_struct
struct|struct
name|krqbits
block|{
name|kqb_word_t
name|rqb_bits
index|[
name|KQB_LEN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Run queue structure. Contains an array of run queues on which processes  * are placed, and a structure to maintain the status of each queue.  */
end_comment

begin_struct
struct|struct
name|krunq
block|{
name|struct
name|krqbits
name|rq_status
decl_stmt|;
name|struct
name|krqhead
name|rq_queues
index|[
name|KQ_NQS
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The following datastructures are allocated within their parent structure  * but are scheduler specific.  */
end_comment

begin_comment
comment|/*  * The schedulable entity that can be given a context to run.  A process may  * have several of these.  */
end_comment

begin_struct
struct|struct
name|td_sched
block|{
name|struct
name|thread
modifier|*
name|ts_thread
decl_stmt|;
comment|/* (*) Active associated thread. */
name|TAILQ_ENTRY
argument_list|(
argument|td_sched
argument_list|)
name|ts_procq
expr_stmt|;
comment|/* (j/z) Run queue. */
name|int
name|ts_flags
decl_stmt|;
comment|/* (j) TSF_* flags. */
name|fixpt_t
name|ts_pctcpu
decl_stmt|;
comment|/* (j) %cpu during p_swtime. */
name|u_char
name|ts_rqindex
decl_stmt|;
comment|/* (j) Run queue index. */
enum|enum
block|{
name|TSS_THREAD
init|=
literal|0x0
block|,
comment|/* slaved to thread state */
name|TSS_ONRUNQ
block|}
name|ts_state
enum|;
comment|/* (j) thread sched specific status. */
name|int
name|ts_slice
decl_stmt|;
comment|/* Time slice in ticks */
name|struct
name|kseq
modifier|*
name|ts_kseq
decl_stmt|;
comment|/* Kseq the thread belongs to */
name|struct
name|krunq
modifier|*
name|ts_runq
decl_stmt|;
comment|/* Assiociated runqueue */
ifdef|#
directive|ifdef
name|SMP
name|int
name|ts_cpu
decl_stmt|;
comment|/* CPU that we have affinity for. */
name|int
name|ts_wakeup_cpu
decl_stmt|;
comment|/* CPU that has activated us. */
endif|#
directive|endif
name|int
name|ts_activated
decl_stmt|;
comment|/* How is the thread activated. */
name|uint64_t
name|ts_timestamp
decl_stmt|;
comment|/* Last timestamp dependent on state.*/
name|unsigned
name|ts_lastran
decl_stmt|;
comment|/* Last timestamp the thread ran. */
comment|/* The following variables are only used for pctcpu calculation */
name|int
name|ts_ltick
decl_stmt|;
comment|/* Last tick that we were running on */
name|int
name|ts_ftick
decl_stmt|;
comment|/* First tick that we were running on */
name|int
name|ts_ticks
decl_stmt|;
comment|/* Tick count */
name|u_long
name|ts_slptime
decl_stmt|;
comment|/* (j) Number of ticks we vol. slept */
name|u_long
name|ts_runtime
decl_stmt|;
comment|/* (j) Temp total run time. */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|td_sched
value|td_sched
end_define

begin_define
define|#
directive|define
name|ts_proc
value|ts_thread->td_proc
end_define

begin_comment
comment|/* flags kept in ts_flags */
end_comment

begin_define
define|#
directive|define
name|TSF_BOUND
value|0x0001
end_define

begin_comment
comment|/* Thread can not migrate. */
end_comment

begin_define
define|#
directive|define
name|TSF_PREEMPTED
value|0x0002
end_define

begin_comment
comment|/* Thread was preempted. */
end_comment

begin_define
define|#
directive|define
name|TSF_MIGRATING
value|0x0004
end_define

begin_comment
comment|/* Thread is migrating. */
end_comment

begin_define
define|#
directive|define
name|TSF_SLEEP
value|0x0008
end_define

begin_comment
comment|/* Thread did sleep. */
end_comment

begin_define
define|#
directive|define
name|TSF_DIDRUN
value|0x0010
end_define

begin_comment
comment|/* Thread actually ran. */
end_comment

begin_define
define|#
directive|define
name|TSF_EXIT
value|0x0020
end_define

begin_comment
comment|/* Thread is being killed. */
end_comment

begin_define
define|#
directive|define
name|TSF_NEXTRQ
value|0x0400
end_define

begin_comment
comment|/* Thread should be in next queue. */
end_comment

begin_define
define|#
directive|define
name|TSF_FIRST_SLICE
value|0x0800
end_define

begin_comment
comment|/* Thread has first time slice left. */
end_comment

begin_comment
comment|/*  * Cpu percentage computation macros and defines.  *  * SCHED_CPU_TIME:	Number of seconds to average the cpu usage across.  * SCHED_CPU_TICKS:	Number of hz ticks to average the cpu usage across.  */
end_comment

begin_define
define|#
directive|define
name|SCHED_CPU_TIME
value|10
end_define

begin_define
define|#
directive|define
name|SCHED_CPU_TICKS
value|(hz * SCHED_CPU_TIME)
end_define

begin_comment
comment|/*  * kseq - per processor runqs and statistics.  */
end_comment

begin_struct
struct|struct
name|kseq
block|{
name|struct
name|krunq
modifier|*
name|ksq_curr
decl_stmt|;
comment|/* Current queue. */
name|struct
name|krunq
modifier|*
name|ksq_next
decl_stmt|;
comment|/* Next timeshare queue. */
name|struct
name|krunq
name|ksq_timeshare
index|[
literal|2
index|]
decl_stmt|;
comment|/* Run queues for !IDLE. */
name|struct
name|krunq
name|ksq_idle
decl_stmt|;
comment|/* Queue of IDLE threads. */
name|int
name|ksq_load
decl_stmt|;
name|uint64_t
name|ksq_last_timestamp
decl_stmt|;
comment|/* Per-cpu last clock tick */
name|unsigned
name|ksq_expired_tick
decl_stmt|;
comment|/* First expired tick */
name|signed
name|char
name|ksq_expired_nice
decl_stmt|;
comment|/* Lowest nice in nextq */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|td_sched
name|kse0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|min_timeslice
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|def_timeslice
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|granularity
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|realstathz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sched_tdcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kseq
name|kseq_global
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * One td_sched queue per processor.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|kseq
name|kseq_cpu
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KSEQ_SELF
parameter_list|()
value|(&kseq_cpu[PCPU_GET(cpuid)])
end_define

begin_define
define|#
directive|define
name|KSEQ_CPU
parameter_list|(
name|x
parameter_list|)
value|(&kseq_cpu[(x)])
end_define

begin_define
define|#
directive|define
name|KSEQ_ID
parameter_list|(
name|x
parameter_list|)
value|((x) - kseq_cpu)
end_define

begin_decl_stmt
specifier|static
name|cpumask_t
name|cpu_sibling
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !SMP */
end_comment

begin_define
define|#
directive|define
name|KSEQ_SELF
parameter_list|()
value|(&kseq_global)
end_define

begin_define
define|#
directive|define
name|KSEQ_CPU
parameter_list|(
name|x
parameter_list|)
value|(&kseq_global)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* decay 95% of `p_pctcpu' in 60 seconds; see CCPU_SHIFT before changing */
end_comment

begin_decl_stmt
specifier|static
name|fixpt_t
name|ccpu
init|=
literal|0.95122942450071400909
operator|*
name|FSCALE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* exp(-1/20) */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|ccpu
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ccpu
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|sched_setup
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSINIT
argument_list|(
name|sched_setup
argument_list|,
name|SI_SUB_RUN_QUEUE
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|sched_setup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|sched_initticks
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_macro
name|SYSINIT
argument_list|(
argument|sched_initticks
argument_list|,
argument|SI_SUB_CLOCKS
argument_list|,
argument|SI_ORDER_THIRD
argument_list|,
argument|sched_initticks
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|sched
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Scheduler"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_STRING
argument_list|(
name|_kern_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|"CORE"
argument_list|,
literal|0
argument_list|,
literal|"Scheduler name"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_comment
comment|/* Enable forwarding of wakeups to all other cpus */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|ipiwakeup
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Kernel SMP"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|runq_fuzz
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|runq_fuzz
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|runq_fuzz
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|forward_wakeup_enabled
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_sched_ipiwakeup
argument_list|,
name|OID_AUTO
argument_list|,
name|enabled
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|forward_wakeup_enabled
argument_list|,
literal|0
argument_list|,
literal|"Forwarding of wakeup to idle CPUs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|forward_wakeups_requested
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_sched_ipiwakeup
argument_list|,
name|OID_AUTO
argument_list|,
name|requested
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|forward_wakeups_requested
argument_list|,
literal|0
argument_list|,
literal|"Requests for Forwarding of wakeup to idle CPUs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|forward_wakeups_delivered
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_sched_ipiwakeup
argument_list|,
name|OID_AUTO
argument_list|,
name|delivered
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|forward_wakeups_delivered
argument_list|,
literal|0
argument_list|,
literal|"Completed Forwarding of wakeup to idle CPUs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|forward_wakeup_use_mask
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_sched_ipiwakeup
argument_list|,
name|OID_AUTO
argument_list|,
name|usemask
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|forward_wakeup_use_mask
argument_list|,
literal|0
argument_list|,
literal|"Use the mask of idle cpus"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|forward_wakeup_use_loop
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_sched_ipiwakeup
argument_list|,
name|OID_AUTO
argument_list|,
name|useloop
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|forward_wakeup_use_loop
argument_list|,
literal|0
argument_list|,
literal|"Use a loop to find idle cpus"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|forward_wakeup_use_single
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_sched_ipiwakeup
argument_list|,
name|OID_AUTO
argument_list|,
name|onecpu
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|forward_wakeup_use_single
argument_list|,
literal|0
argument_list|,
literal|"Only signal one idle cpu"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|forward_wakeup_use_htt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_sched_ipiwakeup
argument_list|,
name|OID_AUTO
argument_list|,
name|htt2
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|forward_wakeup_use_htt
argument_list|,
literal|0
argument_list|,
literal|"account for htt"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|krunq_add
parameter_list|(
name|struct
name|krunq
modifier|*
parameter_list|,
name|struct
name|td_sched
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|td_sched
modifier|*
name|krunq_choose
parameter_list|(
name|struct
name|krunq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|krunq_clrbit
parameter_list|(
name|struct
name|krunq
modifier|*
name|rq
parameter_list|,
name|int
name|pri
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|krunq_findbit
parameter_list|(
name|struct
name|krunq
modifier|*
name|rq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|krunq_init
parameter_list|(
name|struct
name|krunq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|krunq_remove
parameter_list|(
name|struct
name|krunq
modifier|*
parameter_list|,
name|struct
name|td_sched
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|td_sched
modifier|*
name|kseq_choose
parameter_list|(
name|struct
name|kseq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kseq_load_add
parameter_list|(
name|struct
name|kseq
modifier|*
parameter_list|,
name|struct
name|td_sched
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kseq_load_rem
parameter_list|(
name|struct
name|kseq
modifier|*
parameter_list|,
name|struct
name|td_sched
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kseq_runq_add
parameter_list|(
name|struct
name|kseq
modifier|*
parameter_list|,
name|struct
name|td_sched
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kseq_runq_rem
parameter_list|(
name|struct
name|kseq
modifier|*
parameter_list|,
name|struct
name|td_sched
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kseq_setup
parameter_list|(
name|struct
name|kseq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sched_is_timeshare
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|td_sched
modifier|*
name|sched_choose
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sched_calc_pri
parameter_list|(
name|struct
name|td_sched
modifier|*
name|ts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sched_starving
parameter_list|(
name|struct
name|kseq
modifier|*
parameter_list|,
name|unsigned
parameter_list|,
name|struct
name|td_sched
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sched_pctcpu_update
parameter_list|(
name|struct
name|td_sched
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sched_thread_priority
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|u_char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|sched_timestamp
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sched_recalc_pri
parameter_list|(
name|struct
name|td_sched
modifier|*
name|ts
parameter_list|,
name|uint64_t
name|now
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sched_timeslice
parameter_list|(
name|struct
name|td_sched
modifier|*
name|ts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sched_update_runtime
parameter_list|(
name|struct
name|td_sched
modifier|*
name|ts
parameter_list|,
name|uint64_t
name|now
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sched_commit_runtime
parameter_list|(
name|struct
name|td_sched
modifier|*
name|ts
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Initialize a run structure.  */
end_comment

begin_function
specifier|static
name|void
name|krunq_init
parameter_list|(
name|struct
name|krunq
modifier|*
name|rq
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
name|rq
argument_list|,
sizeof|sizeof
expr|*
name|rq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KQ_NQS
condition|;
name|i
operator|++
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|rq
operator|->
name|rq_queues
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear the status bit of the queue corresponding to priority level pri,  * indicating that it is empty.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|krunq_clrbit
parameter_list|(
name|struct
name|krunq
modifier|*
name|rq
parameter_list|,
name|int
name|pri
parameter_list|)
block|{
name|struct
name|krqbits
modifier|*
name|rqb
decl_stmt|;
name|rqb
operator|=
operator|&
name|rq
operator|->
name|rq_status
expr_stmt|;
name|rqb
operator|->
name|rqb_bits
index|[
name|KQB_WORD
argument_list|(
name|pri
argument_list|)
index|]
operator|&=
operator|~
name|KQB_BIT
argument_list|(
name|pri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the index of the first non-empty run queue.  This is done by  * scanning the status bits, a set bit indicates a non-empty queue.  */
end_comment

begin_function
specifier|static
name|int
name|krunq_findbit
parameter_list|(
name|struct
name|krunq
modifier|*
name|rq
parameter_list|)
block|{
name|struct
name|krqbits
modifier|*
name|rqb
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rqb
operator|=
operator|&
name|rq
operator|->
name|rq_status
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KQB_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rqb
operator|->
name|rqb_bits
index|[
name|i
index|]
condition|)
block|{
name|pri
operator|=
name|KQB_FFS
argument_list|(
name|rqb
operator|->
name|rqb_bits
index|[
name|i
index|]
argument_list|)
operator|+
operator|(
name|i
operator|<<
name|KQB_L2BPW
operator|)
expr_stmt|;
return|return
operator|(
name|pri
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|krunq_check
parameter_list|(
name|struct
name|krunq
modifier|*
name|rq
parameter_list|)
block|{
name|struct
name|krqbits
modifier|*
name|rqb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rqb
operator|=
operator|&
name|rq
operator|->
name|rq_status
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KQB_LEN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|rqb
operator|->
name|rqb_bits
index|[
name|i
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the status bit of the queue corresponding to priority level pri,  * indicating that it is non-empty.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|krunq_setbit
parameter_list|(
name|struct
name|krunq
modifier|*
name|rq
parameter_list|,
name|int
name|pri
parameter_list|)
block|{
name|struct
name|krqbits
modifier|*
name|rqb
decl_stmt|;
name|rqb
operator|=
operator|&
name|rq
operator|->
name|rq_status
expr_stmt|;
name|rqb
operator|->
name|rqb_bits
index|[
name|KQB_WORD
argument_list|(
name|pri
argument_list|)
index|]
operator||=
name|KQB_BIT
argument_list|(
name|pri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add the KSE to the queue specified by its priority, and set the  * corresponding status bit.  */
end_comment

begin_function
specifier|static
name|void
name|krunq_add
parameter_list|(
name|struct
name|krunq
modifier|*
name|rq
parameter_list|,
name|struct
name|td_sched
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|krqhead
modifier|*
name|rqh
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|pri
operator|=
name|ts
operator|->
name|ts_thread
operator|->
name|td_priority
expr_stmt|;
name|ts
operator|->
name|ts_rqindex
operator|=
name|pri
expr_stmt|;
name|krunq_setbit
argument_list|(
name|rq
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|rqh
operator|=
operator|&
name|rq
operator|->
name|rq_queues
index|[
name|pri
index|]
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_flags
operator|&
name|TSF_PREEMPTED
condition|)
name|TAILQ_INSERT_HEAD
argument_list|(
name|rqh
argument_list|,
name|ts
argument_list|,
name|ts_procq
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
name|rqh
argument_list|,
name|ts
argument_list|,
name|ts_procq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the highest priority process on the run queue.  */
end_comment

begin_function
specifier|static
name|struct
name|td_sched
modifier|*
name|krunq_choose
parameter_list|(
name|struct
name|krunq
modifier|*
name|rq
parameter_list|)
block|{
name|struct
name|krqhead
modifier|*
name|rqh
decl_stmt|;
name|struct
name|td_sched
modifier|*
name|ts
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pri
operator|=
name|krunq_findbit
argument_list|(
name|rq
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|rqh
operator|=
operator|&
name|rq
operator|->
name|rq_queues
index|[
name|pri
index|]
expr_stmt|;
name|ts
operator|=
name|TAILQ_FIRST
argument_list|(
name|rqh
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ts
operator|!=
name|NULL
argument_list|,
operator|(
literal|"krunq_choose: no thread on busy queue"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|pri
operator|<=
name|PRI_MAX_ITHD
operator|||
name|runq_fuzz
operator|<=
literal|0
condition|)
return|return
operator|(
name|ts
operator|)
return|;
comment|/* 		 * In the first couple of entries, check if 		 * there is one for our CPU as a preference. 		 */
name|struct
name|td_sched
modifier|*
name|ts2
init|=
name|ts
decl_stmt|;
specifier|const
name|int
name|mycpu
init|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
decl_stmt|;
specifier|const
name|int
name|mymask
init|=
literal|1
operator|<<
name|mycpu
decl_stmt|;
name|int
name|count
init|=
name|runq_fuzz
decl_stmt|;
while|while
condition|(
name|count
operator|--
operator|&&
name|ts2
condition|)
block|{
specifier|const
name|int
name|cpu
init|=
name|ts2
operator|->
name|ts_wakeup_cpu
decl_stmt|;
if|if
condition|(
name|cpu_sibling
index|[
name|cpu
index|]
operator|&
name|mymask
condition|)
block|{
name|ts
operator|=
name|ts2
expr_stmt|;
break|break;
block|}
name|ts2
operator|=
name|TAILQ_NEXT
argument_list|(
name|ts2
argument_list|,
name|ts_procq
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|ts
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove the KSE from the queue specified by its priority, and clear the  * corresponding status bit if the queue becomes empty.  * Caller must set ts->ts_state afterwards.  */
end_comment

begin_function
specifier|static
name|void
name|krunq_remove
parameter_list|(
name|struct
name|krunq
modifier|*
name|rq
parameter_list|,
name|struct
name|td_sched
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|krqhead
modifier|*
name|rqh
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|KASSERT
argument_list|(
name|ts
operator|->
name|ts_proc
operator|->
name|p_sflag
operator|&
name|PS_INMEM
argument_list|,
operator|(
literal|"runq_remove: process swapped out"
operator|)
argument_list|)
expr_stmt|;
name|pri
operator|=
name|ts
operator|->
name|ts_rqindex
expr_stmt|;
name|rqh
operator|=
operator|&
name|rq
operator|->
name|rq_queues
index|[
name|pri
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|ts
operator|!=
name|NULL
argument_list|,
operator|(
literal|"krunq_remove: no proc on busy queue"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|rqh
argument_list|,
name|ts
argument_list|,
name|ts_procq
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
name|rqh
argument_list|)
condition|)
name|krunq_clrbit
argument_list|(
name|rq
argument_list|,
name|pri
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|kseq_runq_add
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|,
name|struct
name|td_sched
modifier|*
name|ts
parameter_list|)
block|{
name|krunq_add
argument_list|(
name|ts
operator|->
name|ts_runq
argument_list|,
name|ts
argument_list|)
expr_stmt|;
name|ts
operator|->
name|ts_kseq
operator|=
name|kseq
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|kseq_runq_rem
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|,
name|struct
name|td_sched
modifier|*
name|ts
parameter_list|)
block|{
name|krunq_remove
argument_list|(
name|ts
operator|->
name|ts_runq
argument_list|,
name|ts
argument_list|)
expr_stmt|;
name|ts
operator|->
name|ts_kseq
operator|=
name|NULL
expr_stmt|;
name|ts
operator|->
name|ts_runq
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|kseq_load_add
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|,
name|struct
name|td_sched
modifier|*
name|ts
parameter_list|)
block|{
name|kseq
operator|->
name|ksq_load
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ts
operator|->
name|ts_proc
operator|->
name|p_flag
operator|&
name|P_NOLOAD
operator|)
operator|==
literal|0
condition|)
name|sched_tdcnt
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|kseq_load_rem
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|,
name|struct
name|td_sched
modifier|*
name|ts
parameter_list|)
block|{
name|kseq
operator|->
name|ksq_load
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|ts
operator|->
name|ts_proc
operator|->
name|p_flag
operator|&
name|P_NOLOAD
operator|)
operator|==
literal|0
condition|)
name|sched_tdcnt
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Pick the highest priority task we have and return it.  */
end_comment

begin_function
specifier|static
name|struct
name|td_sched
modifier|*
name|kseq_choose
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|)
block|{
name|struct
name|krunq
modifier|*
name|swap
decl_stmt|;
name|struct
name|td_sched
modifier|*
name|ts
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ts
operator|=
name|krunq_choose
argument_list|(
name|kseq
operator|->
name|ksq_curr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ts
operator|)
return|;
name|kseq
operator|->
name|ksq_expired_nice
operator|=
name|PRIO_MAX
operator|+
literal|1
expr_stmt|;
name|kseq
operator|->
name|ksq_expired_tick
operator|=
literal|0
expr_stmt|;
name|swap
operator|=
name|kseq
operator|->
name|ksq_curr
expr_stmt|;
name|kseq
operator|->
name|ksq_curr
operator|=
name|kseq
operator|->
name|ksq_next
expr_stmt|;
name|kseq
operator|->
name|ksq_next
operator|=
name|swap
expr_stmt|;
name|ts
operator|=
name|krunq_choose
argument_list|(
name|kseq
operator|->
name|ksq_curr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ts
operator|)
return|;
return|return
name|krunq_choose
argument_list|(
operator|&
name|kseq
operator|->
name|ksq_idle
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|sched_timestamp
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|now
init|=
name|cputick2usec
argument_list|(
name|cpu_ticks
argument_list|()
argument_list|)
operator|*
literal|1000
decl_stmt|;
return|return
operator|(
name|now
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|sched_timeslice
parameter_list|(
name|struct
name|td_sched
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|ts
operator|->
name|ts_proc
decl_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_proc
operator|->
name|p_nice
operator|<
literal|0
condition|)
return|return
name|SCALE_USER_PRI
argument_list|(
name|def_timeslice
operator|*
literal|4
argument_list|,
name|PROC_USER_PRI
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
else|else
return|return
name|SCALE_USER_PRI
argument_list|(
name|def_timeslice
argument_list|,
name|PROC_USER_PRI
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|sched_is_timeshare
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
name|td
operator|->
name|td_pri_class
operator|==
name|PRI_TIMESHARE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sched_calc_pri
parameter_list|(
name|struct
name|td_sched
modifier|*
name|ts
parameter_list|)
block|{
name|int
name|score
decl_stmt|,
name|pri
decl_stmt|;
if|if
condition|(
name|sched_is_timeshare
argument_list|(
name|ts
operator|->
name|ts_thread
argument_list|)
condition|)
block|{
name|score
operator|=
name|CURRENT_SCORE
argument_list|(
name|ts
argument_list|)
operator|-
name|MAX_SCORE
operator|/
literal|2
expr_stmt|;
name|pri
operator|=
name|PROC_PRI
argument_list|(
name|ts
operator|->
name|ts_proc
argument_list|)
operator|-
name|score
expr_stmt|;
if|if
condition|(
name|pri
operator|<
name|PUSER
condition|)
name|pri
operator|=
name|PUSER
expr_stmt|;
elseif|else
if|if
condition|(
name|pri
operator|>
name|PUSER_MAX
condition|)
name|pri
operator|=
name|PUSER_MAX
expr_stmt|;
return|return
operator|(
name|pri
operator|)
return|;
block|}
return|return
operator|(
name|ts
operator|->
name|ts_thread
operator|->
name|td_base_user_pri
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sched_recalc_pri
parameter_list|(
name|struct
name|td_sched
modifier|*
name|ts
parameter_list|,
name|uint64_t
name|now
parameter_list|)
block|{
name|uint64_t
name|delta
decl_stmt|;
name|unsigned
name|int
name|sleep_time
decl_stmt|;
name|delta
operator|=
name|now
operator|-
name|ts
operator|->
name|ts_timestamp
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|sched_is_timeshare
argument_list|(
name|ts
operator|->
name|ts_thread
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|ts
operator|->
name|ts_thread
operator|->
name|td_base_user_pri
operator|)
return|;
if|if
condition|(
name|delta
operator|>
name|NS_MAX_SLEEP_TIME
condition|)
name|sleep_time
operator|=
name|NS_MAX_SLEEP_TIME
expr_stmt|;
else|else
name|sleep_time
operator|=
operator|(
name|unsigned
name|int
operator|)
name|delta
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|sleep_time
operator|==
literal|0
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|ts
operator|->
name|ts_activated
operator|!=
operator|-
literal|1
operator|&&
name|sleep_time
operator|>
name|INTERACTIVE_SLEEP_TIME
argument_list|(
name|ts
argument_list|)
condition|)
block|{
name|ts
operator|->
name|ts_slptime
operator|=
name|HZ_TO_NS
argument_list|(
name|MAX_SLEEP_TIME
operator|-
name|def_timeslice
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sleep_time
operator|*=
operator|(
name|MAX_SCORE
operator|-
name|CURRENT_SCORE
argument_list|(
name|ts
argument_list|)
operator|)
condition|?
else|:
literal|1
expr_stmt|;
comment|/* 		 * If thread is waking from uninterruptible sleep, it is 		 * unlikely an interactive sleep, limit its sleep time to 		 * prevent it from being an interactive thread. 		 */
if|if
condition|(
name|ts
operator|->
name|ts_activated
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ts
operator|->
name|ts_slptime
operator|>=
name|INTERACTIVE_SLEEP_TIME
argument_list|(
name|ts
argument_list|)
condition|)
name|sleep_time
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|ts
operator|->
name|ts_slptime
operator|+
name|sleep_time
operator|>=
name|INTERACTIVE_SLEEP_TIME
argument_list|(
name|ts
argument_list|)
condition|)
block|{
name|ts
operator|->
name|ts_slptime
operator|=
name|INTERACTIVE_SLEEP_TIME
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|sleep_time
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 		 * Thread gets priority boost here.                  */
name|ts
operator|->
name|ts_slptime
operator|+=
name|sleep_time
expr_stmt|;
comment|/* Sleep time should never be larger than maximum */
if|if
condition|(
name|ts
operator|->
name|ts_slptime
operator|>
name|NS_MAX_SLEEP_TIME
condition|)
name|ts
operator|->
name|ts_slptime
operator|=
name|NS_MAX_SLEEP_TIME
expr_stmt|;
block|}
name|out
label|:
return|return
operator|(
name|sched_calc_pri
argument_list|(
name|ts
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sched_update_runtime
parameter_list|(
name|struct
name|td_sched
modifier|*
name|ts
parameter_list|,
name|uint64_t
name|now
parameter_list|)
block|{
name|uint64_t
name|runtime
decl_stmt|;
if|if
condition|(
name|sched_is_timeshare
argument_list|(
name|ts
operator|->
name|ts_thread
argument_list|)
condition|)
block|{
if|if
condition|(
call|(
name|int64_t
call|)
argument_list|(
name|now
operator|-
name|ts
operator|->
name|ts_timestamp
argument_list|)
operator|<
name|NS_MAX_SLEEP_TIME
condition|)
block|{
name|runtime
operator|=
name|now
operator|-
name|ts
operator|->
name|ts_timestamp
expr_stmt|;
if|if
condition|(
call|(
name|int64_t
call|)
argument_list|(
name|now
operator|-
name|ts
operator|->
name|ts_timestamp
argument_list|)
operator|<
literal|0
condition|)
name|runtime
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|runtime
operator|=
name|NS_MAX_SLEEP_TIME
expr_stmt|;
block|}
name|runtime
operator|/=
operator|(
name|CURRENT_SCORE
argument_list|(
name|ts
argument_list|)
condition|?
else|:
literal|1
operator|)
expr_stmt|;
name|ts
operator|->
name|ts_runtime
operator|+=
name|runtime
expr_stmt|;
name|ts
operator|->
name|ts_timestamp
operator|=
name|now
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sched_commit_runtime
parameter_list|(
name|struct
name|td_sched
modifier|*
name|ts
parameter_list|)
block|{
if|if
condition|(
name|ts
operator|->
name|ts_runtime
operator|>
name|ts
operator|->
name|ts_slptime
condition|)
name|ts
operator|->
name|ts_slptime
operator|=
literal|0
expr_stmt|;
else|else
name|ts
operator|->
name|ts_slptime
operator|-=
name|ts
operator|->
name|ts_runtime
expr_stmt|;
name|ts
operator|->
name|ts_runtime
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kseq_setup
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|)
block|{
name|krunq_init
argument_list|(
operator|&
name|kseq
operator|->
name|ksq_timeshare
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|krunq_init
argument_list|(
operator|&
name|kseq
operator|->
name|ksq_timeshare
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|krunq_init
argument_list|(
operator|&
name|kseq
operator|->
name|ksq_idle
argument_list|)
expr_stmt|;
name|kseq
operator|->
name|ksq_curr
operator|=
operator|&
name|kseq
operator|->
name|ksq_timeshare
index|[
literal|0
index|]
expr_stmt|;
name|kseq
operator|->
name|ksq_next
operator|=
operator|&
name|kseq
operator|->
name|ksq_timeshare
index|[
literal|1
index|]
expr_stmt|;
name|kseq
operator|->
name|ksq_expired_nice
operator|=
name|PRIO_MAX
operator|+
literal|1
expr_stmt|;
name|kseq
operator|->
name|ksq_expired_tick
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sched_setup
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SMP
name|int
name|i
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * To avoid divide-by-zero, we set realstathz a dummy value 	 * in case which sched_clock() called before sched_initticks(). 	 */
name|realstathz
operator|=
name|hz
expr_stmt|;
name|min_timeslice
operator|=
name|MAX
argument_list|(
literal|5
operator|*
name|hz
operator|/
literal|1000
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|def_timeslice
operator|=
name|MAX
argument_list|(
literal|100
operator|*
name|hz
operator|/
literal|1000
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|granularity
operator|=
name|MAX
argument_list|(
literal|10
operator|*
name|hz
operator|/
literal|1000
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kseq_setup
argument_list|(
operator|&
name|kseq_global
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|runq_fuzz
operator|=
name|MIN
argument_list|(
name|mp_ncpus
operator|*
literal|2
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the kseqs. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|kseq
modifier|*
name|ksq
decl_stmt|;
name|ksq
operator|=
operator|&
name|kseq_cpu
index|[
name|i
index|]
expr_stmt|;
name|kseq_setup
argument_list|(
operator|&
name|kseq_cpu
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|cpu_sibling
index|[
name|i
index|]
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
if|if
condition|(
name|smp_topology
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|cpumask_t
name|visited
decl_stmt|;
name|struct
name|cpu_group
modifier|*
name|cg
decl_stmt|;
name|visited
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|smp_topology
operator|->
name|ct_count
condition|;
name|i
operator|++
control|)
block|{
name|cg
operator|=
operator|&
name|smp_topology
operator|->
name|ct_group
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|cg
operator|->
name|cg_mask
operator|&
name|visited
condition|)
name|panic
argument_list|(
literal|"duplicated cpumask in ct_group."
argument_list|)
expr_stmt|;
if|if
condition|(
name|cg
operator|->
name|cg_mask
operator|==
literal|0
condition|)
continue|continue;
name|visited
operator||=
name|cg
operator|->
name|cg_mask
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXCPU
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|cg
operator|->
name|cg_mask
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
operator|)
operator|!=
literal|0
condition|)
name|cpu_sibling
index|[
name|j
index|]
operator||=
name|cg
operator|->
name|cg_mask
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|kseq_load_add
argument_list|(
name|KSEQ_SELF
argument_list|()
argument_list|,
operator|&
name|kse0
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|sched_initticks
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|realstathz
operator|=
name|stathz
condition|?
name|stathz
else|:
name|hz
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Very early in the boot some setup of scheduler-specific  * parts of proc0 and of soem scheduler resources needs to be done.  * Called from:  *  proc0_init()  */
end_comment

begin_function
name|void
name|schedinit
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Set up the scheduler specific parts of proc0. 	 */
name|proc0
operator|.
name|p_sched
operator|=
name|NULL
expr_stmt|;
comment|/* XXX */
name|thread0
operator|.
name|td_sched
operator|=
operator|&
name|kse0
expr_stmt|;
name|kse0
operator|.
name|ts_thread
operator|=
operator|&
name|thread0
expr_stmt|;
name|kse0
operator|.
name|ts_state
operator|=
name|TSS_THREAD
expr_stmt|;
name|kse0
operator|.
name|ts_slice
operator|=
literal|100
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is only somewhat accurate since given many processes of the same  * priority they will switch when their slices run out, which will be  * at most SCHED_SLICE_MAX.  */
end_comment

begin_function
name|int
name|sched_rr_interval
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|def_timeslice
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sched_pctcpu_update
parameter_list|(
name|struct
name|td_sched
modifier|*
name|ts
parameter_list|)
block|{
comment|/* 	 * Adjust counters and watermark for pctcpu calc. 	 */
if|if
condition|(
name|ts
operator|->
name|ts_ltick
operator|>
name|ticks
operator|-
name|SCHED_CPU_TICKS
condition|)
block|{
comment|/* 		 * Shift the tick count out so that the divide doesn't 		 * round away our results. 		 */
name|ts
operator|->
name|ts_ticks
operator|<<=
literal|10
expr_stmt|;
name|ts
operator|->
name|ts_ticks
operator|=
operator|(
name|ts
operator|->
name|ts_ticks
operator|/
operator|(
name|ticks
operator|-
name|ts
operator|->
name|ts_ftick
operator|)
operator|)
operator|*
name|SCHED_CPU_TICKS
expr_stmt|;
name|ts
operator|->
name|ts_ticks
operator|>>=
literal|10
expr_stmt|;
block|}
else|else
name|ts
operator|->
name|ts_ticks
operator|=
literal|0
expr_stmt|;
name|ts
operator|->
name|ts_ltick
operator|=
name|ticks
expr_stmt|;
name|ts
operator|->
name|ts_ftick
operator|=
name|ts
operator|->
name|ts_ltick
operator|-
name|SCHED_CPU_TICKS
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sched_thread_priority
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|u_char
name|prio
parameter_list|)
block|{
name|struct
name|td_sched
modifier|*
name|ts
decl_stmt|;
name|ts
operator|=
name|td
operator|->
name|td_sched
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|td
operator|->
name|td_priority
operator|==
name|prio
argument_list|)
condition|)
return|return;
if|if
condition|(
name|TD_ON_RUNQ
argument_list|(
name|td
argument_list|)
condition|)
block|{
comment|/* 		 * If the priority has been elevated due to priority 		 * propagation, we may have to move ourselves to a new 		 * queue.  We still call adjustrunqueue below in case td_sched 		 * needs to fix things up. 		 */
if|if
condition|(
name|prio
operator|<
name|td
operator|->
name|td_priority
operator|&&
name|ts
operator|->
name|ts_runq
operator|!=
name|NULL
operator|&&
name|ts
operator|->
name|ts_runq
operator|!=
name|ts
operator|->
name|ts_kseq
operator|->
name|ksq_curr
condition|)
block|{
name|krunq_remove
argument_list|(
name|ts
operator|->
name|ts_runq
argument_list|,
name|ts
argument_list|)
expr_stmt|;
name|ts
operator|->
name|ts_runq
operator|=
name|ts
operator|->
name|ts_kseq
operator|->
name|ksq_curr
expr_stmt|;
name|krunq_add
argument_list|(
name|ts
operator|->
name|ts_runq
argument_list|,
name|ts
argument_list|)
expr_stmt|;
block|}
name|adjustrunqueue
argument_list|(
name|td
argument_list|,
name|prio
argument_list|)
expr_stmt|;
block|}
else|else
name|td
operator|->
name|td_priority
operator|=
name|prio
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update a thread's priority when it is lent another thread's  * priority.  */
end_comment

begin_function
name|void
name|sched_lend_prio
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|u_char
name|prio
parameter_list|)
block|{
name|td
operator|->
name|td_flags
operator||=
name|TDF_BORROWING
expr_stmt|;
name|sched_thread_priority
argument_list|(
name|td
argument_list|,
name|prio
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restore a thread's priority when priority propagation is  * over.  The prio argument is the minimum priority the thread  * needs to have to satisfy other possible priority lending  * requests.  If the thread's regular priority is less  * important than prio, the thread will keep a priority boost  * of prio.  */
end_comment

begin_function
name|void
name|sched_unlend_prio
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|u_char
name|prio
parameter_list|)
block|{
name|u_char
name|base_pri
decl_stmt|;
if|if
condition|(
name|td
operator|->
name|td_base_pri
operator|>=
name|PRI_MIN_TIMESHARE
operator|&&
name|td
operator|->
name|td_base_pri
operator|<=
name|PRI_MAX_TIMESHARE
condition|)
name|base_pri
operator|=
name|td
operator|->
name|td_user_pri
expr_stmt|;
else|else
name|base_pri
operator|=
name|td
operator|->
name|td_base_pri
expr_stmt|;
if|if
condition|(
name|prio
operator|>=
name|base_pri
condition|)
block|{
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_BORROWING
expr_stmt|;
name|sched_thread_priority
argument_list|(
name|td
argument_list|,
name|base_pri
argument_list|)
expr_stmt|;
block|}
else|else
name|sched_lend_prio
argument_list|(
name|td
argument_list|,
name|prio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_prio
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|u_char
name|prio
parameter_list|)
block|{
name|u_char
name|oldprio
decl_stmt|;
if|if
condition|(
name|td
operator|->
name|td_pri_class
operator|==
name|PRI_TIMESHARE
condition|)
name|prio
operator|=
name|MIN
argument_list|(
name|prio
argument_list|,
name|PUSER_MAX
argument_list|)
expr_stmt|;
comment|/* First, update the base priority. */
name|td
operator|->
name|td_base_pri
operator|=
name|prio
expr_stmt|;
comment|/* 	 * If the thread is borrowing another thread's priority, don't 	 * ever lower the priority. 	 */
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_BORROWING
operator|&&
name|td
operator|->
name|td_priority
operator|<
name|prio
condition|)
return|return;
comment|/* Change the real priority. */
name|oldprio
operator|=
name|td
operator|->
name|td_priority
expr_stmt|;
name|sched_thread_priority
argument_list|(
name|td
argument_list|,
name|prio
argument_list|)
expr_stmt|;
comment|/* 	 * If the thread is on a turnstile, then let the turnstile update 	 * its state. 	 */
if|if
condition|(
name|TD_ON_LOCK
argument_list|(
name|td
argument_list|)
operator|&&
name|oldprio
operator|!=
name|prio
condition|)
name|turnstile_adjust
argument_list|(
name|td
argument_list|,
name|oldprio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_user_prio
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|u_char
name|prio
parameter_list|)
block|{
name|u_char
name|oldprio
decl_stmt|;
name|td
operator|->
name|td_base_user_pri
operator|=
name|prio
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_UBORROWING
operator|&&
name|td
operator|->
name|td_user_pri
operator|<=
name|prio
condition|)
return|return;
name|oldprio
operator|=
name|td
operator|->
name|td_user_pri
expr_stmt|;
name|td
operator|->
name|td_user_pri
operator|=
name|prio
expr_stmt|;
if|if
condition|(
name|TD_ON_UPILOCK
argument_list|(
name|td
argument_list|)
operator|&&
name|oldprio
operator|!=
name|prio
condition|)
name|umtx_pi_adjust
argument_list|(
name|td
argument_list|,
name|oldprio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_lend_user_prio
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|u_char
name|prio
parameter_list|)
block|{
name|u_char
name|oldprio
decl_stmt|;
name|td
operator|->
name|td_flags
operator||=
name|TDF_UBORROWING
expr_stmt|;
name|oldprio
operator|=
name|td
operator|->
name|td_user_pri
expr_stmt|;
name|td
operator|->
name|td_user_pri
operator|=
name|prio
expr_stmt|;
if|if
condition|(
name|TD_ON_UPILOCK
argument_list|(
name|td
argument_list|)
operator|&&
name|oldprio
operator|!=
name|prio
condition|)
name|umtx_pi_adjust
argument_list|(
name|td
argument_list|,
name|oldprio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_unlend_user_prio
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|u_char
name|prio
parameter_list|)
block|{
name|u_char
name|base_pri
decl_stmt|;
name|base_pri
operator|=
name|td
operator|->
name|td_base_user_pri
expr_stmt|;
if|if
condition|(
name|prio
operator|>=
name|base_pri
condition|)
block|{
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_UBORROWING
expr_stmt|;
name|sched_user_prio
argument_list|(
name|td
argument_list|,
name|base_pri
argument_list|)
expr_stmt|;
block|}
else|else
name|sched_lend_user_prio
argument_list|(
name|td
argument_list|,
name|prio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_switch
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|thread
modifier|*
name|newtd
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|ksq
decl_stmt|;
name|struct
name|td_sched
modifier|*
name|ts
decl_stmt|;
name|uint64_t
name|now
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|now
operator|=
name|sched_timestamp
argument_list|()
expr_stmt|;
name|ts
operator|=
name|td
operator|->
name|td_sched
expr_stmt|;
name|ksq
operator|=
name|KSEQ_SELF
argument_list|()
expr_stmt|;
name|td
operator|->
name|td_lastcpu
operator|=
name|td
operator|->
name|td_oncpu
expr_stmt|;
name|td
operator|->
name|td_oncpu
operator|=
name|NOCPU
expr_stmt|;
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_NEEDRESCHED
expr_stmt|;
name|td
operator|->
name|td_owepreempt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|PCPU_GET
argument_list|(
name|idlethread
argument_list|)
condition|)
block|{
name|TD_SET_CAN_RUN
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sched_update_runtime
argument_list|(
name|ts
argument_list|,
name|now
argument_list|)
expr_stmt|;
comment|/* We are ending our run so make our slot available again */
name|kseq_load_rem
argument_list|(
name|ksq
argument_list|,
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|TD_IS_RUNNING
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|setrunqueue
argument_list|(
name|td
argument_list|,
operator|(
name|flags
operator|&
name|SW_PREEMPT
operator|)
condition|?
name|SRQ_OURSELF
operator||
name|SRQ_YIELDING
operator||
name|SRQ_PREEMPTED
else|:
name|SRQ_OURSELF
operator||
name|SRQ_YIELDING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ts
operator|->
name|ts_flags
operator|&=
operator|~
name|TSF_NEXTRQ
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newtd
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If we bring in a thread account for it as if it had been 		 * added to the run queue and then chosen. 		 */
name|newtd
operator|->
name|td_sched
operator|->
name|ts_flags
operator||=
name|TSF_DIDRUN
expr_stmt|;
name|newtd
operator|->
name|td_sched
operator|->
name|ts_timestamp
operator|=
name|now
expr_stmt|;
name|TD_SET_RUNNING
argument_list|(
name|newtd
argument_list|)
expr_stmt|;
name|kseq_load_add
argument_list|(
name|ksq
argument_list|,
name|newtd
operator|->
name|td_sched
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newtd
operator|=
name|choosethread
argument_list|()
expr_stmt|;
comment|/* sched_choose sets ts_timestamp, just reuse it */
block|}
if|if
condition|(
name|td
operator|!=
name|newtd
condition|)
block|{
name|ts
operator|->
name|ts_lastran
operator|=
name|tick
expr_stmt|;
ifdef|#
directive|ifdef
name|HWPMC_HOOKS
if|if
condition|(
name|PMC_PROC_IS_USING_PMCS
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
condition|)
name|PMC_SWITCH_CONTEXT
argument_list|(
name|td
argument_list|,
name|PMC_FN_CSW_OUT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cpu_switch
argument_list|(
name|td
argument_list|,
name|newtd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HWPMC_HOOKS
if|if
condition|(
name|PMC_PROC_IS_USING_PMCS
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
condition|)
name|PMC_SWITCH_CONTEXT
argument_list|(
name|td
argument_list|,
name|PMC_FN_CSW_IN
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|sched_lock
operator|.
name|mtx_lock
operator|=
operator|(
name|uintptr_t
operator|)
name|td
expr_stmt|;
name|td
operator|->
name|td_oncpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_nice
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|int
name|nice
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_nice
operator|=
name|nice
expr_stmt|;
name|FOREACH_THREAD_IN_PROC
argument_list|(
argument|p
argument_list|,
argument|td
argument_list|)
block|{
if|if
condition|(
name|td
operator|->
name|td_pri_class
operator|==
name|PRI_TIMESHARE
condition|)
block|{
name|sched_user_prio
argument_list|(
name|td
argument_list|,
name|sched_calc_pri
argument_list|(
name|td
operator|->
name|td_sched
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|sched_sleep
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|td_sched
modifier|*
name|ts
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ts
operator|=
name|td
operator|->
name|td_sched
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_SINTR
condition|)
name|ts
operator|->
name|ts_activated
operator|=
literal|0
expr_stmt|;
else|else
name|ts
operator|->
name|ts_activated
operator|=
operator|-
literal|1
expr_stmt|;
name|ts
operator|->
name|ts_flags
operator||=
name|TSF_SLEEP
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_wakeup
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|td_sched
modifier|*
name|ts
decl_stmt|;
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|,
modifier|*
name|mykseq
decl_stmt|;
name|uint64_t
name|now
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ts
operator|=
name|td
operator|->
name|td_sched
expr_stmt|;
name|mykseq
operator|=
name|KSEQ_SELF
argument_list|()
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_flags
operator|&
name|TSF_SLEEP
condition|)
block|{
name|ts
operator|->
name|ts_flags
operator|&=
operator|~
name|TSF_SLEEP
expr_stmt|;
if|if
condition|(
name|sched_is_timeshare
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|sched_commit_runtime
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|now
operator|=
name|sched_timestamp
argument_list|()
expr_stmt|;
name|kseq
operator|=
name|KSEQ_CPU
argument_list|(
name|td
operator|->
name|td_lastcpu
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|kseq
operator|!=
name|mykseq
condition|)
name|now
operator|=
name|now
operator|-
name|mykseq
operator|->
name|ksq_last_timestamp
operator|+
name|kseq
operator|->
name|ksq_last_timestamp
expr_stmt|;
endif|#
directive|endif
name|sched_user_prio
argument_list|(
name|td
argument_list|,
name|sched_recalc_pri
argument_list|(
name|ts
argument_list|,
name|now
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|setrunqueue
argument_list|(
name|td
argument_list|,
name|SRQ_BORING
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Penalize the parent for creating a new child and initialize the child's  * priority.  */
end_comment

begin_function
name|void
name|sched_fork
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|thread
modifier|*
name|childtd
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sched_fork_thread
argument_list|(
name|td
argument_list|,
name|childtd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_fork_thread
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|thread
modifier|*
name|child
parameter_list|)
block|{
name|struct
name|td_sched
modifier|*
name|ts
decl_stmt|;
name|struct
name|td_sched
modifier|*
name|ts2
decl_stmt|;
name|sched_newthread
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|ts
operator|=
name|td
operator|->
name|td_sched
expr_stmt|;
name|ts2
operator|=
name|child
operator|->
name|td_sched
expr_stmt|;
name|ts2
operator|->
name|ts_slptime
operator|=
name|ts2
operator|->
name|ts_slptime
operator|*
name|CHILD_WEIGHT
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|td_pri_class
operator|==
name|PRI_TIMESHARE
condition|)
name|sched_user_prio
argument_list|(
name|child
argument_list|,
name|sched_calc_pri
argument_list|(
name|ts2
argument_list|)
argument_list|)
expr_stmt|;
name|ts
operator|->
name|ts_slptime
operator|=
name|ts
operator|->
name|ts_slptime
operator|*
name|PARENT_WEIGHT
operator|/
literal|100
expr_stmt|;
name|ts2
operator|->
name|ts_slice
operator|=
operator|(
name|ts
operator|->
name|ts_slice
operator|+
literal|1
operator|)
operator|>>
literal|1
expr_stmt|;
name|ts2
operator|->
name|ts_flags
operator||=
name|TSF_FIRST_SLICE
operator||
operator|(
name|ts
operator|->
name|ts_flags
operator|&
name|TSF_NEXTRQ
operator|)
expr_stmt|;
name|ts2
operator|->
name|ts_activated
operator|=
literal|0
expr_stmt|;
name|ts
operator|->
name|ts_slice
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_slice
operator|==
literal|0
condition|)
block|{
name|ts
operator|->
name|ts_slice
operator|=
literal|1
expr_stmt|;
name|sched_tick
argument_list|()
expr_stmt|;
block|}
comment|/* Grab our parents cpu estimation information. */
name|ts2
operator|->
name|ts_ticks
operator|=
name|ts
operator|->
name|ts_ticks
expr_stmt|;
name|ts2
operator|->
name|ts_ltick
operator|=
name|ts
operator|->
name|ts_ltick
expr_stmt|;
name|ts2
operator|->
name|ts_ftick
operator|=
name|ts
operator|->
name|ts_ftick
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_class
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|class
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_pri_class
operator|=
name|class
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return some of the child's priority and interactivity to the parent.  */
end_comment

begin_function
name|void
name|sched_exit
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|thread
modifier|*
name|childtd
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sched_exit_thread
argument_list|(
name|FIRST_THREAD_IN_PROC
argument_list|(
name|p
argument_list|)
argument_list|,
name|childtd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_exit_thread
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|thread
modifier|*
name|childtd
parameter_list|)
block|{
name|struct
name|td_sched
modifier|*
name|childke
init|=
name|childtd
operator|->
name|td_sched
decl_stmt|;
name|struct
name|td_sched
modifier|*
name|parentke
init|=
name|td
operator|->
name|td_sched
decl_stmt|;
if|if
condition|(
name|childke
operator|->
name|ts_slptime
operator|<
name|parentke
operator|->
name|ts_slptime
condition|)
block|{
name|parentke
operator|->
name|ts_slptime
operator|=
name|parentke
operator|->
name|ts_slptime
operator|/
operator|(
name|EXIT_WEIGHT
operator|)
operator|*
operator|(
name|EXIT_WEIGHT
operator|-
literal|1
operator|)
operator|+
name|parentke
operator|->
name|ts_slptime
operator|/
name|EXIT_WEIGHT
expr_stmt|;
block|}
name|kseq_load_rem
argument_list|(
name|KSEQ_SELF
argument_list|()
argument_list|,
name|childke
argument_list|)
expr_stmt|;
name|sched_update_runtime
argument_list|(
name|childke
argument_list|,
name|sched_timestamp
argument_list|()
argument_list|)
expr_stmt|;
name|sched_commit_runtime
argument_list|(
name|childke
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|childke
operator|->
name|ts_flags
operator|&
name|TSF_FIRST_SLICE
operator|)
operator|&&
name|td
operator|->
name|td_proc
operator|==
name|childtd
operator|->
name|td_proc
operator|->
name|p_pptr
condition|)
block|{
name|parentke
operator|->
name|ts_slice
operator|+=
name|childke
operator|->
name|ts_slice
expr_stmt|;
if|if
condition|(
name|parentke
operator|->
name|ts_slice
operator|>
name|sched_timeslice
argument_list|(
name|parentke
argument_list|)
condition|)
name|parentke
operator|->
name|ts_slice
operator|=
name|sched_timeslice
argument_list|(
name|parentke
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sched_starving
parameter_list|(
name|struct
name|kseq
modifier|*
name|ksq
parameter_list|,
name|unsigned
name|now
parameter_list|,
name|struct
name|td_sched
modifier|*
name|ts
parameter_list|)
block|{
name|uint64_t
name|delta
decl_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_proc
operator|->
name|p_nice
operator|>
name|ksq
operator|->
name|ksq_expired_nice
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ksq
operator|->
name|ksq_expired_tick
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|delta
operator|=
name|HZ_TO_NS
argument_list|(
operator|(
name|uint64_t
operator|)
name|now
operator|-
name|ksq
operator|->
name|ksq_expired_tick
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|>
name|STARVATION_TIME
operator|*
name|ksq
operator|->
name|ksq_load
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * An interactive thread has smaller time slice granularity,  * a cpu hog can have larger granularity.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|sched_timeslice_split
parameter_list|(
name|struct
name|td_sched
modifier|*
name|ts
parameter_list|)
block|{
name|int
name|score
decl_stmt|,
name|g
decl_stmt|;
name|score
operator|=
call|(
name|int
call|)
argument_list|(
name|MAX_SCORE
operator|-
name|CURRENT_SCORE
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|score
operator|==
literal|0
condition|)
name|score
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|g
operator|=
name|granularity
operator|*
operator|(
operator|(
literal|1
operator|<<
name|score
operator|)
operator|-
literal|1
operator|)
operator|*
name|smp_cpus
expr_stmt|;
else|#
directive|else
name|g
operator|=
name|granularity
operator|*
operator|(
operator|(
literal|1
operator|<<
name|score
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ts
operator|->
name|ts_slice
operator|>=
name|g
operator|&&
name|ts
operator|->
name|ts_slice
operator|%
name|g
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sched_tick
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|td_sched
modifier|*
name|ts
decl_stmt|;
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|uint64_t
name|now
decl_stmt|;
name|int
name|cpuid
decl_stmt|;
name|int
name|class
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|ts
operator|=
name|td
operator|->
name|td_sched
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|class
operator|=
name|PRI_BASE
argument_list|(
name|td
operator|->
name|td_pri_class
argument_list|)
expr_stmt|;
name|now
operator|=
name|sched_timestamp
argument_list|()
expr_stmt|;
name|cpuid
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|kseq
operator|=
name|KSEQ_CPU
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|kseq
operator|->
name|ksq_last_timestamp
operator|=
name|now
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|PRI_IDLE
condition|)
block|{
comment|/* 		 * Processes of equal idle priority are run round-robin. 		 */
if|if
condition|(
name|td
operator|!=
name|PCPU_GET
argument_list|(
name|idlethread
argument_list|)
operator|&&
operator|--
name|ts
operator|->
name|ts_slice
operator|<=
literal|0
condition|)
block|{
name|ts
operator|->
name|ts_slice
operator|=
name|def_timeslice
expr_stmt|;
name|td
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|class
operator|==
name|PRI_REALTIME
condition|)
block|{
comment|/* 		 * Realtime scheduling, do round robin for RR class, FIFO 		 * is not affected. 		 */
if|if
condition|(
name|PRI_NEED_RR
argument_list|(
name|td
operator|->
name|td_pri_class
argument_list|)
operator|&&
operator|--
name|ts
operator|->
name|ts_slice
operator|<=
literal|0
condition|)
block|{
name|ts
operator|->
name|ts_slice
operator|=
name|def_timeslice
expr_stmt|;
name|td
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * We skip kernel thread, though it may be classified as TIMESHARE. 	 */
if|if
condition|(
name|class
operator|!=
name|PRI_TIMESHARE
operator|||
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_KTHREAD
operator|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
operator|--
name|ts
operator|->
name|ts_slice
operator|<=
literal|0
condition|)
block|{
name|td
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
name|sched_update_runtime
argument_list|(
name|ts
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|sched_commit_runtime
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|sched_user_prio
argument_list|(
name|td
argument_list|,
name|sched_calc_pri
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
name|ts
operator|->
name|ts_slice
operator|=
name|sched_timeslice
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|ts
operator|->
name|ts_flags
operator|&=
operator|~
name|TSF_FIRST_SLICE
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_flags
operator|&
name|TSF_BOUND
operator|||
name|td
operator|->
name|td_pinned
condition|)
block|{
if|if
condition|(
name|kseq
operator|->
name|ksq_expired_tick
operator|==
literal|0
condition|)
name|kseq
operator|->
name|ksq_expired_tick
operator|=
name|tick
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|kseq_global
operator|.
name|ksq_expired_tick
operator|==
literal|0
condition|)
name|kseq_global
operator|.
name|ksq_expired_tick
operator|=
name|tick
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|THREAD_IS_INTERACTIVE
argument_list|(
name|ts
argument_list|)
operator|||
name|sched_starving
argument_list|(
name|kseq
argument_list|,
name|tick
argument_list|,
name|ts
argument_list|)
operator|||
name|sched_starving
argument_list|(
operator|&
name|kseq_global
argument_list|,
name|tick
argument_list|,
name|ts
argument_list|)
condition|)
block|{
comment|/* The thead becomes cpu hog, schedule it off. */
name|ts
operator|->
name|ts_flags
operator||=
name|TSF_NEXTRQ
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_flags
operator|&
name|TSF_BOUND
operator|||
name|td
operator|->
name|td_pinned
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_nice
operator|<
name|kseq
operator|->
name|ksq_expired_nice
condition|)
name|kseq
operator|->
name|ksq_expired_nice
operator|=
name|p
operator|->
name|p_nice
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p
operator|->
name|p_nice
operator|<
name|kseq_global
operator|.
name|ksq_expired_nice
condition|)
name|kseq_global
operator|.
name|ksq_expired_nice
operator|=
name|p
operator|->
name|p_nice
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * Don't allow an interactive thread which has long timeslice 		 * to monopolize CPU, split the long timeslice into small 		 * chunks. This essentially does round-robin between 		 * interactive threads. 		 */
if|if
condition|(
name|THREAD_IS_INTERACTIVE
argument_list|(
name|ts
argument_list|)
operator|&&
name|sched_timeslice_split
argument_list|(
name|ts
argument_list|)
condition|)
name|td
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sched_clock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|td_sched
modifier|*
name|ts
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ts
operator|=
name|td
operator|->
name|td_sched
expr_stmt|;
comment|/* Adjust ticks for pctcpu */
name|ts
operator|->
name|ts_ticks
operator|++
expr_stmt|;
name|ts
operator|->
name|ts_ltick
operator|=
name|ticks
expr_stmt|;
comment|/* Go up to one second beyond our max and then trim back down */
if|if
condition|(
name|ts
operator|->
name|ts_ftick
operator|+
name|SCHED_CPU_TICKS
operator|+
name|hz
operator|<
name|ts
operator|->
name|ts_ltick
condition|)
name|sched_pctcpu_update
argument_list|(
name|ts
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|kseq_runnable
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|)
block|{
return|return
operator|(
name|krunq_check
argument_list|(
name|kseq
operator|->
name|ksq_curr
argument_list|)
operator|||
name|krunq_check
argument_list|(
name|kseq
operator|->
name|ksq_next
argument_list|)
operator|||
name|krunq_check
argument_list|(
operator|&
name|kseq
operator|->
name|ksq_idle
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sched_runnable
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SMP
return|return
operator|(
name|kseq_runnable
argument_list|(
operator|&
name|kseq_global
argument_list|)
operator|||
name|kseq_runnable
argument_list|(
name|KSEQ_SELF
argument_list|()
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|kseq_runnable
argument_list|(
operator|&
name|kseq_global
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|sched_userret
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_BORROWING
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"thread with borrowed priority returning to userland"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_priority
operator|!=
name|td
operator|->
name|td_user_pri
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_priority
operator|=
name|td
operator|->
name|td_user_pri
expr_stmt|;
name|td
operator|->
name|td_base_pri
operator|=
name|td
operator|->
name|td_user_pri
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|td_sched
modifier|*
name|sched_choose
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|td_sched
modifier|*
name|ts
decl_stmt|;
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|struct
name|td_sched
modifier|*
name|kecpu
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|kseq
operator|=
operator|&
name|kseq_global
expr_stmt|;
name|ts
operator|=
name|kseq_choose
argument_list|(
operator|&
name|kseq_global
argument_list|)
expr_stmt|;
name|kecpu
operator|=
name|kseq_choose
argument_list|(
name|KSEQ_SELF
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|==
name|NULL
operator|||
operator|(
name|kecpu
operator|!=
name|NULL
operator|&&
name|kecpu
operator|->
name|ts_thread
operator|->
name|td_priority
operator|<
name|ts
operator|->
name|ts_thread
operator|->
name|td_priority
operator|)
condition|)
block|{
name|ts
operator|=
name|kecpu
expr_stmt|;
name|kseq
operator|=
name|KSEQ_SELF
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
name|kseq
operator|=
operator|&
name|kseq_global
expr_stmt|;
name|ts
operator|=
name|kseq_choose
argument_list|(
name|kseq
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ts
operator|!=
name|NULL
condition|)
block|{
name|kseq_runq_rem
argument_list|(
name|kseq
argument_list|,
name|ts
argument_list|)
expr_stmt|;
name|ts
operator|->
name|ts_state
operator|=
name|TSS_THREAD
expr_stmt|;
name|ts
operator|->
name|ts_flags
operator|&=
operator|~
name|TSF_PREEMPTED
expr_stmt|;
name|ts
operator|->
name|ts_timestamp
operator|=
name|sched_timestamp
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ts
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function
specifier|static
name|int
name|forward_wakeup
parameter_list|(
name|int
name|cpunum
parameter_list|,
name|cpumask_t
name|me
parameter_list|)
block|{
name|cpumask_t
name|map
decl_stmt|,
name|dontuse
decl_stmt|;
name|cpumask_t
name|map2
decl_stmt|;
name|struct
name|pcpu
modifier|*
name|pc
decl_stmt|;
name|cpumask_t
name|id
decl_stmt|,
name|map3
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|CTR0
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"forward_wakeup()"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|forward_wakeup_enabled
operator|)
operator|||
operator|(
name|forward_wakeup_use_mask
operator|==
literal|0
operator|&&
name|forward_wakeup_use_loop
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|smp_started
operator|||
name|cold
operator|||
name|panicstr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|forward_wakeups_requested
operator|++
expr_stmt|;
comment|/* 	 * check the idle mask we received against what we calculated before 	 * in the old version. 	 */
comment|/*  	 * don't bother if we should be doing it ourself.. 	 */
if|if
condition|(
operator|(
name|me
operator|&
name|idle_cpus_mask
operator|)
operator|&&
operator|(
name|cpunum
operator|==
name|NOCPU
operator|||
name|me
operator|==
operator|(
literal|1
operator|<<
name|cpunum
operator|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dontuse
operator|=
name|me
operator||
name|stopped_cpus
operator||
name|hlt_cpus_mask
expr_stmt|;
name|map3
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|forward_wakeup_use_loop
condition|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|pc
argument_list|,
argument|&cpuhead
argument_list|,
argument|pc_allcpu
argument_list|)
block|{
name|id
operator|=
name|pc
operator|->
name|pc_cpumask
expr_stmt|;
if|if
condition|(
operator|(
name|id
operator|&
name|dontuse
operator|)
operator|==
literal|0
operator|&&
name|pc
operator|->
name|pc_curthread
operator|==
name|pc
operator|->
name|pc_idlethread
condition|)
block|{
name|map3
operator||=
name|id
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|forward_wakeup_use_mask
condition|)
block|{
name|map
operator|=
literal|0
expr_stmt|;
name|map
operator|=
name|idle_cpus_mask
operator|&
operator|~
name|dontuse
expr_stmt|;
comment|/* If they are both on, compare and use loop if different */
if|if
condition|(
name|forward_wakeup_use_loop
condition|)
block|{
if|if
condition|(
name|map
operator|!=
name|map3
condition|)
block|{
name|printf
argument_list|(
literal|"map (%02X) != map3 (%02X)\n"
argument_list|,
name|map
argument_list|,
name|map3
argument_list|)
expr_stmt|;
name|map
operator|=
name|map3
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|map
operator|=
name|map3
expr_stmt|;
block|}
comment|/* If we only allow a specific CPU, then mask off all the others */
if|if
condition|(
name|cpunum
operator|!=
name|NOCPU
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|cpunum
operator|<=
name|mp_maxcpus
operator|)
argument_list|,
operator|(
literal|"forward_wakeup: bad cpunum."
operator|)
argument_list|)
expr_stmt|;
name|map
operator|&=
operator|(
literal|1
operator|<<
name|cpunum
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Try choose an idle die. */
if|if
condition|(
name|forward_wakeup_use_htt
condition|)
block|{
name|map2
operator|=
operator|(
name|map
operator|&
operator|(
name|map
operator|>>
literal|1
operator|)
operator|)
operator|&
literal|0x5555
expr_stmt|;
if|if
condition|(
name|map2
condition|)
block|{
name|map
operator|=
name|map2
expr_stmt|;
block|}
block|}
comment|/* set only one bit */
if|if
condition|(
name|forward_wakeup_use_single
condition|)
block|{
name|map
operator|=
name|map
operator|&
operator|(
operator|(
operator|~
name|map
operator|)
operator|+
literal|1
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|map
condition|)
block|{
name|forward_wakeups_delivered
operator|++
expr_stmt|;
name|ipi_selected
argument_list|(
name|map
argument_list|,
name|IPI_AST
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|sched_add
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|ksq
decl_stmt|;
name|struct
name|td_sched
modifier|*
name|ts
decl_stmt|;
name|struct
name|thread
modifier|*
name|mytd
decl_stmt|;
name|int
name|class
decl_stmt|;
name|int
name|nextrq
decl_stmt|;
name|int
name|need_resched
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|int
name|cpu
decl_stmt|;
name|int
name|mycpu
decl_stmt|;
name|int
name|pinned
decl_stmt|;
name|struct
name|kseq
modifier|*
name|myksq
decl_stmt|;
endif|#
directive|endif
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mytd
operator|=
name|curthread
expr_stmt|;
name|ts
operator|=
name|td
operator|->
name|td_sched
expr_stmt|;
name|KASSERT
argument_list|(
name|ts
operator|->
name|ts_state
operator|!=
name|TSS_ONRUNQ
argument_list|,
operator|(
literal|"sched_add: td_sched %p (%s) already in run queue"
operator|,
name|ts
operator|,
name|ts
operator|->
name|ts_proc
operator|->
name|p_comm
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ts
operator|->
name|ts_proc
operator|->
name|p_sflag
operator|&
name|PS_INMEM
argument_list|,
operator|(
literal|"sched_add: process swapped out"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ts
operator|->
name|ts_runq
operator|==
name|NULL
argument_list|,
operator|(
literal|"sched_add: KSE %p is still assigned to a run queue"
operator|,
name|ts
operator|)
argument_list|)
expr_stmt|;
name|class
operator|=
name|PRI_BASE
argument_list|(
name|td
operator|->
name|td_pri_class
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|mycpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|myksq
operator|=
name|KSEQ_CPU
argument_list|(
name|mycpu
argument_list|)
expr_stmt|;
name|ts
operator|->
name|ts_wakeup_cpu
operator|=
name|mycpu
expr_stmt|;
endif|#
directive|endif
name|nextrq
operator|=
operator|(
name|ts
operator|->
name|ts_flags
operator|&
name|TSF_NEXTRQ
operator|)
expr_stmt|;
name|ts
operator|->
name|ts_flags
operator|&=
operator|~
name|TSF_NEXTRQ
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SRQ_PREEMPTED
condition|)
name|ts
operator|->
name|ts_flags
operator||=
name|TSF_PREEMPTED
expr_stmt|;
name|ksq
operator|=
operator|&
name|kseq_global
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|td
operator|->
name|td_pinned
operator|!=
literal|0
condition|)
block|{
name|cpu
operator|=
name|td
operator|->
name|td_lastcpu
expr_stmt|;
name|ksq
operator|=
name|KSEQ_CPU
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
name|pinned
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ts
operator|)
operator|->
name|ts_flags
operator|&
name|TSF_BOUND
condition|)
block|{
name|cpu
operator|=
name|ts
operator|->
name|ts_cpu
expr_stmt|;
name|ksq
operator|=
name|KSEQ_CPU
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
name|pinned
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pinned
operator|=
literal|0
expr_stmt|;
name|cpu
operator|=
name|NOCPU
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|PRI_ITHD
case|:
case|case
name|PRI_REALTIME
case|:
name|ts
operator|->
name|ts_runq
operator|=
name|ksq
operator|->
name|ksq_curr
expr_stmt|;
break|break;
case|case
name|PRI_TIMESHARE
case|:
if|if
condition|(
operator|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_BORROWING
operator|)
operator|==
literal|0
operator|&&
name|nextrq
condition|)
name|ts
operator|->
name|ts_runq
operator|=
name|ksq
operator|->
name|ksq_next
expr_stmt|;
else|else
name|ts
operator|->
name|ts_runq
operator|=
name|ksq
operator|->
name|ksq_curr
expr_stmt|;
break|break;
case|case
name|PRI_IDLE
case|:
comment|/* 		 * This is for priority prop. 		 */
if|if
condition|(
name|td
operator|->
name|td_priority
operator|<
name|PRI_MIN_IDLE
condition|)
name|ts
operator|->
name|ts_runq
operator|=
name|ksq
operator|->
name|ksq_curr
expr_stmt|;
else|else
name|ts
operator|->
name|ts_runq
operator|=
operator|&
name|ksq
operator|->
name|ksq_idle
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unknown pri class."
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
operator|(
name|ts
operator|->
name|ts_runq
operator|==
name|kseq_global
operator|.
name|ksq_curr
operator|||
name|ts
operator|->
name|ts_runq
operator|==
name|myksq
operator|->
name|ksq_curr
operator|)
operator|&&
name|td
operator|->
name|td_priority
operator|<
name|mytd
operator|->
name|td_priority
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|ts
operator|->
name|ts_runq
operator|==
name|kseq_global
operator|.
name|ksq_curr
operator|&&
name|td
operator|->
name|td_priority
operator|<
name|mytd
operator|->
name|td_priority
condition|)
block|{
endif|#
directive|endif
name|struct
name|krunq
modifier|*
name|rq
decl_stmt|;
name|rq
operator|=
name|ts
operator|->
name|ts_runq
expr_stmt|;
name|ts
operator|->
name|ts_runq
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SRQ_YIELDING
operator|)
operator|==
literal|0
operator|&&
name|maybe_preempt
argument_list|(
name|td
argument_list|)
condition|)
return|return;
name|ts
operator|->
name|ts_runq
operator|=
name|rq
expr_stmt|;
name|need_resched
operator|=
name|TDF_NEEDRESCHED
expr_stmt|;
block|}
name|ts
operator|->
name|ts_state
operator|=
name|TSS_ONRUNQ
expr_stmt|;
name|kseq_runq_add
argument_list|(
name|ksq
argument_list|,
name|ts
argument_list|)
expr_stmt|;
name|kseq_load_add
argument_list|(
name|ksq
argument_list|,
name|ts
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|pinned
condition|)
block|{
if|if
condition|(
name|cpu
operator|!=
name|mycpu
condition|)
block|{
name|struct
name|thread
modifier|*
name|running
init|=
name|pcpu_find
argument_list|(
name|cpu
argument_list|)
operator|->
name|pc_curthread
decl_stmt|;
if|if
condition|(
name|ksq
operator|->
name|ksq_curr
operator|==
name|ts
operator|->
name|ts_runq
operator|&&
name|running
operator|->
name|td_priority
operator|<
name|td
operator|->
name|td_priority
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|td_priority
operator|<=
name|PRI_MAX_ITHD
condition|)
name|ipi_selected
argument_list|(
literal|1
operator|<<
name|cpu
argument_list|,
name|IPI_PREEMPT
argument_list|)
expr_stmt|;
else|else
block|{
name|running
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
name|ipi_selected
argument_list|(
literal|1
operator|<<
name|cpu
argument_list|,
name|IPI_AST
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|curthread
operator|->
name|td_flags
operator||=
name|need_resched
expr_stmt|;
block|}
else|else
block|{
name|cpumask_t
name|me
init|=
literal|1
operator|<<
name|mycpu
decl_stmt|;
name|cpumask_t
name|idle
init|=
name|idle_cpus_mask
operator|&
name|me
decl_stmt|;
name|int
name|forwarded
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|idle
operator|&&
operator|(
operator|(
name|flags
operator|&
name|SRQ_INTR
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|idle_cpus_mask
operator|&
operator|~
operator|(
name|hlt_cpus_mask
operator||
name|me
operator|)
operator|)
condition|)
name|forwarded
operator|=
name|forward_wakeup
argument_list|(
name|cpu
argument_list|,
name|me
argument_list|)
expr_stmt|;
if|if
condition|(
name|forwarded
operator|==
literal|0
condition|)
name|curthread
operator|->
name|td_flags
operator||=
name|need_resched
expr_stmt|;
block|}
else|#
directive|else
name|mytd
operator|->
name|td_flags
operator||=
name|need_resched
expr_stmt|;
endif|#
directive|endif
block|}
name|void
name|sched_rem
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|struct
name|td_sched
modifier|*
name|ts
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ts
operator|=
name|td
operator|->
name|td_sched
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ts
operator|->
name|ts_state
operator|==
name|TSS_ONRUNQ
operator|)
argument_list|,
operator|(
literal|"sched_rem: KSE not on run queue"
operator|)
argument_list|)
expr_stmt|;
name|kseq
operator|=
name|ts
operator|->
name|ts_kseq
expr_stmt|;
name|kseq_runq_rem
argument_list|(
name|kseq
argument_list|,
name|ts
argument_list|)
expr_stmt|;
name|kseq_load_rem
argument_list|(
name|kseq
argument_list|,
name|ts
argument_list|)
expr_stmt|;
name|ts
operator|->
name|ts_state
operator|=
name|TSS_THREAD
expr_stmt|;
block|}
name|fixpt_t
name|sched_pctcpu
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|fixpt_t
name|pctcpu
decl_stmt|;
name|struct
name|td_sched
modifier|*
name|ts
decl_stmt|;
name|pctcpu
operator|=
literal|0
expr_stmt|;
name|ts
operator|=
name|td
operator|->
name|td_sched
expr_stmt|;
if|if
condition|(
name|ts
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_ticks
condition|)
block|{
name|int
name|rtick
decl_stmt|;
comment|/* 		 * Don't update more frequently than twice a second.  Allowing 		 * this causes the cpu usage to decay away too quickly due to 		 * rounding errors. 		 */
if|if
condition|(
name|ts
operator|->
name|ts_ftick
operator|+
name|SCHED_CPU_TICKS
operator|<
name|ts
operator|->
name|ts_ltick
operator|||
name|ts
operator|->
name|ts_ltick
operator|<
operator|(
name|ticks
operator|-
operator|(
name|hz
operator|/
literal|2
operator|)
operator|)
condition|)
name|sched_pctcpu_update
argument_list|(
name|ts
argument_list|)
expr_stmt|;
comment|/* How many rtick per second ? */
name|rtick
operator|=
name|MIN
argument_list|(
name|ts
operator|->
name|ts_ticks
operator|/
name|SCHED_CPU_TIME
argument_list|,
name|SCHED_CPU_TICKS
argument_list|)
expr_stmt|;
name|pctcpu
operator|=
operator|(
name|FSCALE
operator|*
operator|(
operator|(
name|FSCALE
operator|*
name|rtick
operator|)
operator|/
name|realstathz
operator|)
operator|)
operator|>>
name|FSHIFT
expr_stmt|;
block|}
name|ts
operator|->
name|ts_proc
operator|->
name|p_swtime
operator|=
name|ts
operator|->
name|ts_ltick
operator|-
name|ts
operator|->
name|ts_ftick
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|pctcpu
operator|)
return|;
block|}
name|void
name|sched_bind
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|cpu
parameter_list|)
block|{
name|struct
name|td_sched
modifier|*
name|ts
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ts
operator|=
name|td
operator|->
name|td_sched
expr_stmt|;
name|ts
operator|->
name|ts_flags
operator||=
name|TSF_BOUND
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|ts
operator|->
name|ts_cpu
operator|=
name|cpu
expr_stmt|;
if|if
condition|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
operator|==
name|cpu
condition|)
return|return;
name|mi_switch
argument_list|(
name|SW_VOL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|void
name|sched_unbind
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_sched
operator|->
name|ts_flags
operator|&=
operator|~
name|TSF_BOUND
expr_stmt|;
block|}
name|int
name|sched_is_bound
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
return|return
operator|(
name|td
operator|->
name|td_sched
operator|->
name|ts_flags
operator|&
name|TSF_BOUND
operator|)
return|;
block|}
name|int
name|sched_load
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|sched_tdcnt
operator|)
return|;
block|}
name|void
name|sched_relinquish
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sched_is_timeshare
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|sched_prio
argument_list|(
name|td
argument_list|,
name|PRI_MAX_TIMESHARE
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_sched
operator|->
name|ts_flags
operator||=
name|TSF_NEXTRQ
expr_stmt|;
block|}
name|mi_switch
argument_list|(
name|SW_VOL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
name|int
name|sched_sizeof_proc
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
operator|)
return|;
block|}
name|int
name|sched_sizeof_thread
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|td_sched
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|KERN_SWITCH_INCLUDE
value|1
end_define

begin_include
include|#
directive|include
file|"kern/kern_switch.c"
end_include

end_unit

