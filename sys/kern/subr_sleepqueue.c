begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004 John Baldwin<jhb@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Implementation of sleep queues used to hold queue of threads blocked on  * a wait channel.  Sleep queues different from turnstiles in that wait  * channels are not owned by anyone, so there is no priority propagation.  * Sleep queues can also provide a timeout and can also be interrupted by  * signals.  That said, there are several similarities between the turnstile  * and sleep queue implementations.  (Note: turnstiles were implemented  * first.)  For example, both use a hash table of the same size where each  * bucket is referred to as a "chain" that contains both a spin lock and  * a linked list of queues.  An individual queue is located by using a hash  * to pick a chain, locking the chain, and then walking the chain searching  * for the queue.  This means that a wait channel object does not need to  * embed it's queue head just as locks do not embed their turnstile queue  * head.  Threads also carry around a sleep queue that they lend to the  * wait channel when blocking.  Just as in turnstiles, the queue includes  * a free list of the sleep queues of other threads blocked on the same  * wait channel in the case of multiple waiters.  *  * Some additional functionality provided by sleep queues include the  * ability to set a timeout.  The timeout is managed using a per-thread  * callout that resumes a thread if it is asleep.  A thread may also  * catch signals while it is asleep (aka an interruptible sleep).  The  * signal code uses sleepq_abort() to interrupt a sleeping thread.  Finally,  * sleep queues also provide some extra assertions.  One is not allowed to  * mix the sleep/wakeup and cv APIs for a given wait channel.  Also, one  * must consistently use the same lock to synchronize with a wait channel,  * though this check is currently only a warning for sleep/wakeup due to  * pre-existing abuse of that API.  The same lock must also be held when  * awakening threads, though that is currently only enforced for condition  * variables.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_sleepqueue_profiling.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sleepqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Constants for the hash table of sleep queue chains.  These constants are  * the same ones that 4BSD (and possibly earlier versions of BSD) used.  * Basically, we ignore the lower 8 bits of the address since most wait  * channel pointers are aligned and only look at the next 7 bits for the  * hash.  SC_TABLESIZE must be a power of two for SC_MASK to work properly.  */
end_comment

begin_define
define|#
directive|define
name|SC_TABLESIZE
value|128
end_define

begin_comment
comment|/* Must be power of 2. */
end_comment

begin_define
define|#
directive|define
name|SC_MASK
value|(SC_TABLESIZE - 1)
end_define

begin_define
define|#
directive|define
name|SC_SHIFT
value|8
end_define

begin_define
define|#
directive|define
name|SC_HASH
parameter_list|(
name|wc
parameter_list|)
value|(((uintptr_t)(wc)>> SC_SHIFT)& SC_MASK)
end_define

begin_define
define|#
directive|define
name|SC_LOOKUP
parameter_list|(
name|wc
parameter_list|)
value|&sleepq_chains[SC_HASH(wc)]
end_define

begin_define
define|#
directive|define
name|NR_SLEEPQS
value|2
end_define

begin_comment
comment|/*  * There two different lists of sleep queues.  Both lists are connected  * via the sq_hash entries.  The first list is the sleep queue chain list  * that a sleep queue is on when it is attached to a wait channel.  The  * second list is the free list hung off of a sleep queue that is attached  * to a wait channel.  *  * Each sleep queue also contains the wait channel it is attached to, the  * list of threads blocked on that wait channel, flags specific to the  * wait channel, and the lock used to synchronize with a wait channel.  * The flags are used to catch mismatches between the various consumers  * of the sleep queue API (e.g. sleep/wakeup and condition variables).  * The lock pointer is only used when invariants are enabled for various  * debugging checks.  *  * Locking key:  *  c - sleep queue chain lock  */
end_comment

begin_struct
struct|struct
name|sleepqueue
block|{
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|thread
argument_list|)
name|sq_blocked
index|[
name|NR_SLEEPQS
index|]
expr_stmt|;
comment|/* (c) Blocked threads. */
name|LIST_ENTRY
argument_list|(
argument|sleepqueue
argument_list|)
name|sq_hash
expr_stmt|;
comment|/* (c) Chain and free list. */
name|LIST_HEAD
argument_list|(
argument_list|,
argument|sleepqueue
argument_list|)
name|sq_free
expr_stmt|;
comment|/* (c) Free queues. */
name|void
modifier|*
name|sq_wchan
decl_stmt|;
comment|/* (c) Wait channel. */
ifdef|#
directive|ifdef
name|INVARIANTS
name|int
name|sq_type
decl_stmt|;
comment|/* (c) Queue type. */
name|struct
name|lock_object
modifier|*
name|sq_lock
decl_stmt|;
comment|/* (c) Associated lock. */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sleepqueue_chain
block|{
name|LIST_HEAD
argument_list|(
argument_list|,
argument|sleepqueue
argument_list|)
name|sc_queues
expr_stmt|;
comment|/* List of sleep queues. */
name|struct
name|mtx
name|sc_lock
decl_stmt|;
comment|/* Spin lock for this chain. */
ifdef|#
directive|ifdef
name|SLEEPQUEUE_PROFILING
name|u_int
name|sc_depth
decl_stmt|;
comment|/* Length of sc_queues. */
name|u_int
name|sc_max_depth
decl_stmt|;
comment|/* Max length of sc_queues. */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|SLEEPQUEUE_PROFILING
end_ifdef

begin_decl_stmt
name|u_int
name|sleepq_max_depth
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|sleepq
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"sleepq profiling"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_debug_sleepq
argument_list|,
name|OID_AUTO
argument_list|,
name|chains
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"sleepq chain stats"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_debug_sleepq
argument_list|,
name|OID_AUTO
argument_list|,
name|max_depth
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sleepq_max_depth
argument_list|,
literal|0
argument_list|,
literal|"maxmimum depth achieved of a single chain"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|sleepqueue_chain
name|sleepq_chains
index|[
name|SC_TABLESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_SLEEPQUEUE
argument_list|,
literal|"sleepqueue"
argument_list|,
literal|"sleep queues"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Prototypes for non-exported routines.  */
end_comment

begin_function_decl
specifier|static
name|int
name|sleepq_catch_signals
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sleepq_check_signals
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sleepq_check_timeout
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sleepq_switch
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sleepq_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sleepq_resume_thread
parameter_list|(
name|struct
name|sleepqueue
modifier|*
name|sq
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|pri
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Early initialization of sleep queues that is called from the sleepinit()  * SYSINIT.  */
end_comment

begin_function
name|void
name|init_sleepqueues
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SLEEPQUEUE_PROFILING
name|struct
name|sysctl_oid
modifier|*
name|chain_oid
decl_stmt|;
name|char
name|chain_name
index|[
literal|10
index|]
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SC_TABLESIZE
condition|;
name|i
operator|++
control|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|sleepq_chains
index|[
name|i
index|]
operator|.
name|sc_queues
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sleepq_chains
index|[
name|i
index|]
operator|.
name|sc_lock
argument_list|,
literal|"sleepq chain"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SLEEPQUEUE_PROFILING
name|snprintf
argument_list|(
name|chain_name
argument_list|,
sizeof|sizeof
argument_list|(
name|chain_name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|chain_oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|NULL
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_debug_sleepq_chains
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|chain_name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"sleepq chain stats"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|NULL
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|chain_oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"depth"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sleepq_chains
index|[
name|i
index|]
operator|.
name|sc_depth
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|NULL
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|chain_oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"max_depth"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sleepq_chains
index|[
name|i
index|]
operator|.
name|sc_max_depth
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|thread0
operator|.
name|td_sleepqueue
operator|=
name|sleepq_alloc
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Malloc and initialize a new sleep queue for a new thread.  */
end_comment

begin_function
name|struct
name|sleepqueue
modifier|*
name|sleepq_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sleepqueue
modifier|*
name|sq
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sleepqueue
argument_list|)
argument_list|,
name|M_SLEEPQUEUE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_SLEEPQS
condition|;
name|i
operator|++
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|sq
operator|->
name|sq_blocked
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sq
operator|->
name|sq_free
argument_list|)
expr_stmt|;
return|return
operator|(
name|sq
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a sleep queue when a thread is destroyed.  */
end_comment

begin_function
name|void
name|sleepq_free
parameter_list|(
name|struct
name|sleepqueue
modifier|*
name|sq
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|MPASS
argument_list|(
name|sq
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_SLEEPQS
condition|;
name|i
operator|++
control|)
name|MPASS
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sq
operator|->
name|sq_blocked
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sq
argument_list|,
name|M_SLEEPQUEUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lock the sleep queue chain associated with the specified wait channel.  */
end_comment

begin_function
name|void
name|sleepq_lock
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|)
block|{
name|struct
name|sleepqueue_chain
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|SC_LOOKUP
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look up the sleep queue associated with a given wait channel in the hash  * table locking the associated sleep queue chain.  If no queue is found in  * the table, NULL is returned.  */
end_comment

begin_function
name|struct
name|sleepqueue
modifier|*
name|sleepq_lookup
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|)
block|{
name|struct
name|sleepqueue_chain
modifier|*
name|sc
decl_stmt|;
name|struct
name|sleepqueue
modifier|*
name|sq
decl_stmt|;
name|KASSERT
argument_list|(
name|wchan
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: invalid NULL wait channel"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|SC_LOOKUP
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sq
argument_list|,
argument|&sc->sc_queues
argument_list|,
argument|sq_hash
argument_list|)
if|if
condition|(
name|sq
operator|->
name|sq_wchan
operator|==
name|wchan
condition|)
return|return
operator|(
name|sq
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock the sleep queue chain associated with a given wait channel.  */
end_comment

begin_function
name|void
name|sleepq_release
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|)
block|{
name|struct
name|sleepqueue_chain
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|SC_LOOKUP
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Places the current thread on the sleep queue for the specified wait  * channel.  If INVARIANTS is enabled, then it associates the passed in  * lock with the sleepq to make sure it is held when that sleep queue is  * woken up.  */
end_comment

begin_function
name|void
name|sleepq_add
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|,
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|,
specifier|const
name|char
modifier|*
name|wmesg
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|queue
parameter_list|)
block|{
name|struct
name|sleepqueue_chain
modifier|*
name|sc
decl_stmt|;
name|struct
name|sleepqueue
modifier|*
name|sq
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|sc
operator|=
name|SC_LOOKUP
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|td
operator|->
name|td_sleepqueue
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|wchan
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|queue
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|queue
operator|<
name|NR_SLEEPQS
operator|)
argument_list|)
expr_stmt|;
comment|/* If this thread is not allowed to sleep, die a horrible death. */
name|KASSERT
argument_list|(
operator|!
operator|(
name|td
operator|->
name|td_pflags
operator|&
name|TDP_NOSLEEPING
operator|)
argument_list|,
operator|(
literal|"Trying sleep, but thread marked as sleeping prohibited"
operator|)
argument_list|)
expr_stmt|;
comment|/* Look up the sleep queue associated with the wait channel 'wchan'. */
name|sq
operator|=
name|sleepq_lookup
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
comment|/* 	 * If the wait channel does not already have a sleep queue, use 	 * this thread's sleep queue.  Otherwise, insert the current thread 	 * into the sleep queue already in use by this wait channel. 	 */
if|if
condition|(
name|sq
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_SLEEPQS
condition|;
name|i
operator|++
control|)
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sq
operator|->
name|sq_blocked
index|[
name|i
index|]
argument_list|)
argument_list|,
operator|(
literal|"thread's sleep queue %d is not empty"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|sq
operator|->
name|sq_free
argument_list|)
argument_list|,
operator|(
literal|"thread's sleep queue has a non-empty free list"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sq
operator|->
name|sq_wchan
operator|==
name|NULL
argument_list|,
operator|(
literal|"stale sq_wchan pointer"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SLEEPQUEUE_PROFILING
name|sc
operator|->
name|sc_depth
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_depth
operator|>
name|sc
operator|->
name|sc_max_depth
condition|)
block|{
name|sc
operator|->
name|sc_max_depth
operator|=
name|sc
operator|->
name|sc_depth
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_max_depth
operator|>
name|sleepq_max_depth
condition|)
name|sleepq_max_depth
operator|=
name|sc
operator|->
name|sc_max_depth
expr_stmt|;
block|}
endif|#
directive|endif
name|sq
operator|=
name|td
operator|->
name|td_sleepqueue
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_queues
argument_list|,
name|sq
argument_list|,
name|sq_hash
argument_list|)
expr_stmt|;
name|sq
operator|->
name|sq_wchan
operator|=
name|wchan
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|sq
operator|->
name|sq_lock
operator|=
name|lock
expr_stmt|;
name|sq
operator|->
name|sq_type
operator|=
name|flags
operator|&
name|SLEEPQ_TYPE
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|MPASS
argument_list|(
name|wchan
operator|==
name|sq
operator|->
name|sq_wchan
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|lock
operator|==
name|sq
operator|->
name|sq_lock
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|flags
operator|&
name|SLEEPQ_TYPE
operator|)
operator|==
name|sq
operator|->
name|sq_type
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sq
operator|->
name|sq_free
argument_list|,
name|td
operator|->
name|td_sleepqueue
argument_list|,
name|sq_hash
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sq
operator|->
name|sq_blocked
index|[
name|queue
index|]
argument_list|,
name|td
argument_list|,
name|td_slpq
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_sleepqueue
operator|=
name|NULL
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_sqqueue
operator|=
name|queue
expr_stmt|;
name|td
operator|->
name|td_wchan
operator|=
name|wchan
expr_stmt|;
name|td
operator|->
name|td_wmesg
operator|=
name|wmesg
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SLEEPQ_INTERRUPTIBLE
condition|)
block|{
name|td
operator|->
name|td_flags
operator||=
name|TDF_SINTR
expr_stmt|;
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_SLEEPABORT
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sets a timeout that will remove the current thread from the specified  * sleep queue after timo ticks if the thread has not already been awakened.  */
end_comment

begin_function
name|void
name|sleepq_set_timeout
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|,
name|int
name|timo
parameter_list|)
block|{
name|struct
name|sleepqueue_chain
modifier|*
name|sc
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|sc
operator|=
name|SC_LOOKUP
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|td
operator|->
name|td_sleepqueue
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|wchan
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|td
operator|->
name|td_slpcallout
argument_list|,
name|timo
argument_list|,
name|sleepq_timeout
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Marks the pending sleep of the current thread as interruptible and  * makes an initial check for pending signals before putting a thread  * to sleep. Return with sleep queue and scheduler lock held.  */
end_comment

begin_function
specifier|static
name|int
name|sleepq_catch_signals
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|)
block|{
name|struct
name|sleepqueue_chain
modifier|*
name|sc
decl_stmt|;
name|struct
name|sleepqueue
modifier|*
name|sq
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|sigacts
modifier|*
name|ps
decl_stmt|;
name|int
name|sig
decl_stmt|,
name|ret
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|curproc
expr_stmt|;
name|sc
operator|=
name|SC_LOOKUP
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|wchan
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"sleepq catching signals: thread %p (pid %ld, %s)"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|td
argument_list|,
operator|(
name|long
operator|)
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_SINTR
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
comment|/* See if there are any pending signals for this thread. */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ps
operator|=
name|p
operator|->
name|p_sigacts
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ps
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
name|sig
operator|=
name|cursig
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|==
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ps
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|thread_suspend_check
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ret
operator|==
literal|0
operator|||
name|ret
operator|==
name|EINTR
operator|||
name|ret
operator|==
name|ERESTART
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SIGISMEMBER
argument_list|(
name|ps
operator|->
name|ps_sigintr
argument_list|,
name|sig
argument_list|)
condition|)
name|ret
operator|=
name|EINTR
expr_stmt|;
else|else
name|ret
operator|=
name|ERESTART
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ps
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Lock sched_lock before unlocking proc lock, 		 * without this, we could lose a race. 		 */
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_INTERRUPT
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* KSE threads tried unblocking us. */
name|ret
operator|=
name|td
operator|->
name|td_intrval
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ret
operator|==
name|EINTR
operator|||
name|ret
operator|==
name|ERESTART
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * There were pending signals and this thread is still 	 * on the sleep queue, remove it from the sleep queue. 	 */
name|sq
operator|=
name|sleepq_lookup
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
condition|)
name|sleepq_resume_thread
argument_list|(
name|sq
argument_list|,
name|td
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Switches to another thread if we are still asleep on a sleep queue and  * drop the lock on the sleep queue chain.  Returns with sched_lock held.  */
end_comment

begin_function
specifier|static
name|void
name|sleepq_switch
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|)
block|{
name|struct
name|sleepqueue_chain
modifier|*
name|sc
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|sc
operator|=
name|SC_LOOKUP
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/*  	 * If we have a sleep queue, then we've already been woken up, so 	 * just return. 	 */
if|if
condition|(
name|td
operator|->
name|td_sleepqueue
operator|!=
name|NULL
condition|)
block|{
name|MPASS
argument_list|(
operator|!
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Otherwise, actually go to sleep. 	 */
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|sched_sleep
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|TD_SET_SLEEPING
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|mi_switch
argument_list|(
name|SW_VOL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TD_IS_RUNNING
argument_list|(
name|td
argument_list|)
argument_list|,
operator|(
literal|"running but not TDS_RUNNING"
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"sleepq resume: thread %p (pid %ld, %s)"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|td
argument_list|,
operator|(
name|long
operator|)
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see if we timed out.  */
end_comment

begin_function
specifier|static
name|int
name|sleepq_check_timeout
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
comment|/* 	 * If TDF_TIMEOUT is set, we timed out. 	 */
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_TIMEOUT
condition|)
block|{
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_TIMEOUT
expr_stmt|;
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
block|}
comment|/* 	 * If TDF_TIMOFAIL is set, the timeout ran after we had 	 * already been woken up. 	 */
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_TIMOFAIL
condition|)
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_TIMOFAIL
expr_stmt|;
comment|/* 	 * If callout_stop() fails, then the timeout is running on 	 * another CPU, so synchronize with it to avoid having it 	 * accidentally wake up a subsequent sleep. 	 */
elseif|else
if|if
condition|(
name|callout_stop
argument_list|(
operator|&
name|td
operator|->
name|td_slpcallout
argument_list|)
operator|==
literal|0
condition|)
block|{
name|td
operator|->
name|td_flags
operator||=
name|TDF_TIMEOUT
expr_stmt|;
name|TD_SET_SLEEPING
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|mi_switch
argument_list|(
name|SW_INVOL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if we were awoken by a signal.  */
end_comment

begin_function
specifier|static
name|int
name|sleepq_check_signals
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
comment|/* We are no longer in an interruptible sleep. */
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_SINTR
condition|)
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_SINTR
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_SLEEPABORT
condition|)
block|{
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_SLEEPABORT
expr_stmt|;
return|return
operator|(
name|td
operator|->
name|td_intrval
operator|)
return|;
block|}
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_INTERRUPT
condition|)
return|return
operator|(
name|td
operator|->
name|td_intrval
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Block the current thread until it is awakened from its sleep queue.  */
end_comment

begin_function
name|void
name|sleepq_wait
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|)
block|{
name|MPASS
argument_list|(
operator|!
operator|(
name|curthread
operator|->
name|td_flags
operator|&
name|TDF_SINTR
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|sleepq_switch
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Block the current thread until it is awakened from its sleep queue  * or it is interrupted by a signal.  */
end_comment

begin_function
name|int
name|sleepq_wait_sig
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|)
block|{
name|int
name|rcatch
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|rcatch
operator|=
name|sleepq_catch_signals
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcatch
operator|==
literal|0
condition|)
name|sleepq_switch
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
else|else
name|sleepq_release
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|rval
operator|=
name|sleepq_check_signals
argument_list|()
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcatch
condition|)
return|return
operator|(
name|rcatch
operator|)
return|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Block the current thread until it is awakened from its sleep queue  * or it times out while waiting.  */
end_comment

begin_function
name|int
name|sleepq_timedwait
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|)
block|{
name|int
name|rval
decl_stmt|;
name|MPASS
argument_list|(
operator|!
operator|(
name|curthread
operator|->
name|td_flags
operator|&
name|TDF_SINTR
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|sleepq_switch
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|rval
operator|=
name|sleepq_check_timeout
argument_list|()
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Block the current thread until it is awakened from its sleep queue,  * it is interrupted by a signal, or it times out waiting to be awakened.  */
end_comment

begin_function
name|int
name|sleepq_timedwait_sig
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|)
block|{
name|int
name|rcatch
decl_stmt|,
name|rvalt
decl_stmt|,
name|rvals
decl_stmt|;
name|rcatch
operator|=
name|sleepq_catch_signals
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcatch
operator|==
literal|0
condition|)
name|sleepq_switch
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
else|else
name|sleepq_release
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|rvalt
operator|=
name|sleepq_check_timeout
argument_list|()
expr_stmt|;
name|rvals
operator|=
name|sleepq_check_signals
argument_list|()
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcatch
condition|)
return|return
operator|(
name|rcatch
operator|)
return|;
if|if
condition|(
name|rvals
condition|)
return|return
operator|(
name|rvals
operator|)
return|;
return|return
operator|(
name|rvalt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Removes a thread from a sleep queue and makes it  * runnable.  */
end_comment

begin_function
specifier|static
name|void
name|sleepq_resume_thread
parameter_list|(
name|struct
name|sleepqueue
modifier|*
name|sq
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|pri
parameter_list|)
block|{
name|struct
name|sleepqueue_chain
modifier|*
name|sc
decl_stmt|;
name|MPASS
argument_list|(
name|td
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|sq
operator|->
name|sq_wchan
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|td
operator|->
name|td_wchan
operator|==
name|sq
operator|->
name|sq_wchan
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|td
operator|->
name|td_sqqueue
operator|<
name|NR_SLEEPQS
operator|&&
name|td
operator|->
name|td_sqqueue
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|=
name|SC_LOOKUP
argument_list|(
name|sq
operator|->
name|sq_wchan
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Remove the thread from the queue. */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sq
operator|->
name|sq_blocked
index|[
name|td
operator|->
name|td_sqqueue
index|]
argument_list|,
name|td
argument_list|,
name|td_slpq
argument_list|)
expr_stmt|;
comment|/* 	 * Get a sleep queue for this thread.  If this is the last waiter, 	 * use the queue itself and take it out of the chain, otherwise, 	 * remove a queue from the free list. 	 */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|sq
operator|->
name|sq_free
argument_list|)
condition|)
block|{
name|td
operator|->
name|td_sleepqueue
operator|=
name|sq
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|sq
operator|->
name|sq_wchan
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SLEEPQUEUE_PROFILING
name|sc
operator|->
name|sc_depth
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|td
operator|->
name|td_sleepqueue
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sq
operator|->
name|sq_free
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|td
operator|->
name|td_sleepqueue
argument_list|,
name|sq_hash
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_wmesg
operator|=
name|NULL
expr_stmt|;
name|td
operator|->
name|td_wchan
operator|=
name|NULL
expr_stmt|;
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_SINTR
expr_stmt|;
comment|/* 	 * Note that thread td might not be sleeping if it is running 	 * sleepq_catch_signals() on another CPU or is blocked on 	 * its proc lock to check signals.  It doesn't hurt to clear 	 * the sleeping flag if it isn't set though, so we just always 	 * do it.  However, we can't assert that it is set. 	 */
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"sleepq_wakeup: thread %p (pid %ld, %s)"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|td
argument_list|,
operator|(
name|long
operator|)
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|TD_CLR_SLEEPING
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* Adjust priority if requested. */
name|MPASS
argument_list|(
name|pri
operator|==
operator|-
literal|1
operator|||
operator|(
name|pri
operator|>=
name|PRI_MIN
operator|&&
name|pri
operator|<=
name|PRI_MAX
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pri
operator|!=
operator|-
literal|1
operator|&&
name|td
operator|->
name|td_priority
operator|>
name|pri
condition|)
name|sched_prio
argument_list|(
name|td
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|setrunnable
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the highest priority thread sleeping on a wait channel and resume it.  */
end_comment

begin_function
name|void
name|sleepq_signal
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|pri
parameter_list|,
name|int
name|queue
parameter_list|)
block|{
name|struct
name|sleepqueue
modifier|*
name|sq
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|,
modifier|*
name|besttd
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_PROC
argument_list|,
literal|"sleepq_signal(%p, %d)"
argument_list|,
name|wchan
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|wchan
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: invalid NULL wait channel"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|queue
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|queue
operator|<
name|NR_SLEEPQS
operator|)
argument_list|)
expr_stmt|;
name|sq
operator|=
name|sleepq_lookup
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq
operator|==
name|NULL
condition|)
block|{
name|sleepq_release
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|sq
operator|->
name|sq_type
operator|==
operator|(
name|flags
operator|&
name|SLEEPQ_TYPE
operator|)
argument_list|,
operator|(
literal|"%s: mismatch between sleep/wakeup and cv_*"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Find the highest priority thread on the queue.  If there is a 	 * tie, use the thread that first appears in the queue as it has 	 * been sleeping the longest since threads are always added to 	 * the tail of sleep queues. 	 */
name|besttd
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|td
argument_list|,
argument|&sq->sq_blocked[queue]
argument_list|,
argument|td_slpq
argument_list|)
block|{
if|if
condition|(
name|besttd
operator|==
name|NULL
operator|||
name|td
operator|->
name|td_priority
operator|<
name|besttd
operator|->
name|td_priority
condition|)
name|besttd
operator|=
name|td
expr_stmt|;
block|}
name|MPASS
argument_list|(
name|besttd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|sleepq_resume_thread
argument_list|(
name|sq
argument_list|,
name|besttd
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|sleepq_release
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Resume all threads sleeping on a specified wait channel.  */
end_comment

begin_function
name|void
name|sleepq_broadcast
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|pri
parameter_list|,
name|int
name|queue
parameter_list|)
block|{
name|struct
name|sleepqueue
modifier|*
name|sq
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_PROC
argument_list|,
literal|"sleepq_broadcast(%p, %d)"
argument_list|,
name|wchan
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|wchan
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: invalid NULL wait channel"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|(
name|queue
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|queue
operator|<
name|NR_SLEEPQS
operator|)
argument_list|)
expr_stmt|;
name|sq
operator|=
name|sleepq_lookup
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq
operator|==
name|NULL
condition|)
block|{
name|sleepq_release
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|sq
operator|->
name|sq_type
operator|==
operator|(
name|flags
operator|&
name|SLEEPQ_TYPE
operator|)
argument_list|,
operator|(
literal|"%s: mismatch between sleep/wakeup and cv_*"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Resume all blocked threads on the sleep queue. */
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sq
operator|->
name|sq_blocked
index|[
name|queue
index|]
argument_list|)
condition|)
name|sleepq_resume_thread
argument_list|(
name|sq
argument_list|,
name|TAILQ_FIRST
argument_list|(
operator|&
name|sq
operator|->
name|sq_blocked
index|[
name|queue
index|]
argument_list|)
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|sleepq_release
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Time sleeping threads out.  When the timeout expires, the thread is  * removed from the sleep queue and made runnable if it is still asleep.  */
end_comment

begin_function
specifier|static
name|void
name|sleepq_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sleepqueue
modifier|*
name|sq
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|void
modifier|*
name|wchan
decl_stmt|;
name|td
operator|=
name|arg
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"sleepq_timeout: thread %p (pid %ld, %s)"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|td
argument_list|,
operator|(
name|long
operator|)
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
comment|/* 	 * First, see if the thread is asleep and get the wait channel if 	 * it is. 	 */
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|wchan
operator|=
name|td
operator|->
name|td_wchan
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|sleepq_lock
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|sq
operator|=
name|sleepq_lookup
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wchan
operator|=
name|NULL
expr_stmt|;
name|sq
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * At this point, if the thread is still on the sleep queue, 	 * we have that sleep queue locked as it cannot migrate sleep 	 * queues while we dropped sched_lock.  If it had resumed and 	 * was on another CPU while the lock was dropped, it would have 	 * seen that TDF_TIMEOUT and TDF_TIMOFAIL are clear and the 	 * call to callout_stop() to stop this routine would have failed 	 * meaning that it would have already set TDF_TIMEOUT to 	 * synchronize with this function. 	 */
if|if
condition|(
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|MPASS
argument_list|(
name|td
operator|->
name|td_wchan
operator|==
name|wchan
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|sq
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_flags
operator||=
name|TDF_TIMEOUT
expr_stmt|;
name|sleepq_resume_thread
argument_list|(
name|sq
argument_list|,
name|td
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|sleepq_release
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|wchan
operator|!=
name|NULL
condition|)
name|sleepq_release
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
comment|/* 	 * Now check for the edge cases.  First, if TDF_TIMEOUT is set, 	 * then the other thread has already yielded to us, so clear 	 * the flag and resume it.  If TDF_TIMEOUT is not set, then the 	 * we know that the other thread is not on a sleep queue, but it 	 * hasn't resumed execution yet.  In that case, set TDF_TIMOFAIL 	 * to let it know that the timeout has already run and doesn't 	 * need to be canceled. 	 */
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_TIMEOUT
condition|)
block|{
name|MPASS
argument_list|(
name|TD_IS_SLEEPING
argument_list|(
name|td
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_TIMEOUT
expr_stmt|;
name|TD_CLR_SLEEPING
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|setrunnable
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
else|else
name|td
operator|->
name|td_flags
operator||=
name|TDF_TIMOFAIL
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Resumes a specific thread from the sleep queue associated with a specific  * wait channel if it is on that queue.  */
end_comment

begin_function
name|void
name|sleepq_remove
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|wchan
parameter_list|)
block|{
name|struct
name|sleepqueue
modifier|*
name|sq
decl_stmt|;
comment|/* 	 * Look up the sleep queue for this wait channel, then re-check 	 * that the thread is asleep on that channel, if it is not, then 	 * bail. 	 */
name|MPASS
argument_list|(
name|wchan
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sleepq_lock
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|sq
operator|=
name|sleepq_lookup
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
operator|||
name|td
operator|->
name|td_wchan
operator|!=
name|wchan
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|sleepq_release
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
return|return;
block|}
name|MPASS
argument_list|(
name|sq
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Thread is asleep on sleep queue sq, so wake it up. */
name|sleepq_resume_thread
argument_list|(
name|sq
argument_list|,
name|td
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sleepq_release
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Abort a thread as if an interrupt had occurred.  Only abort  * interruptible waits (unfortunately it isn't safe to abort others).  *  * XXX: What in the world does the comment below mean?  * Also, whatever the signal code does...  */
end_comment

begin_function
name|void
name|sleepq_abort
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|intrval
parameter_list|)
block|{
name|void
modifier|*
name|wchan
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_SINTR
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|intrval
operator|==
name|EINTR
operator|||
name|intrval
operator|==
name|ERESTART
argument_list|)
expr_stmt|;
comment|/* 	 * If the TDF_TIMEOUT flag is set, just leave. A 	 * timeout is scheduled anyhow. 	 */
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_TIMEOUT
condition|)
return|return;
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"sleepq_abort: thread %p (pid %ld, %s)"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|td
argument_list|,
operator|(
name|long
operator|)
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|wchan
operator|=
name|td
operator|->
name|td_wchan
expr_stmt|;
if|if
condition|(
name|wchan
operator|!=
name|NULL
condition|)
block|{
name|td
operator|->
name|td_intrval
operator|=
name|intrval
expr_stmt|;
name|td
operator|->
name|td_flags
operator||=
name|TDF_SLEEPABORT
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|sleepq_remove
argument_list|(
name|td
argument_list|,
name|wchan
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|sleepq
argument_list|,
argument|db_show_sleepqueue
argument_list|)
end_macro

begin_block
block|{
name|struct
name|sleepqueue_chain
modifier|*
name|sc
decl_stmt|;
name|struct
name|sleepqueue
modifier|*
name|sq
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|lock_object
modifier|*
name|lock
decl_stmt|;
endif|#
directive|endif
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|void
modifier|*
name|wchan
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|have_addr
condition|)
return|return;
comment|/* 	 * First, see if there is an active sleep queue for the wait channel 	 * indicated by the address. 	 */
name|wchan
operator|=
operator|(
name|void
operator|*
operator|)
name|addr
expr_stmt|;
name|sc
operator|=
name|SC_LOOKUP
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sq
argument_list|,
argument|&sc->sc_queues
argument_list|,
argument|sq_hash
argument_list|)
if|if
condition|(
name|sq
operator|->
name|sq_wchan
operator|==
name|wchan
condition|)
goto|goto
name|found
goto|;
comment|/* 	 * Second, see if there is an active sleep queue at the address 	 * indicated. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SC_TABLESIZE
condition|;
name|i
operator|++
control|)
name|LIST_FOREACH
argument_list|(
argument|sq
argument_list|,
argument|&sleepq_chains[i].sc_queues
argument_list|,
argument|sq_hash
argument_list|)
block|{
if|if
condition|(
name|sq
operator|==
operator|(
expr|struct
name|sleepqueue
operator|*
operator|)
name|addr
condition|)
goto|goto
name|found
goto|;
block|}
name|db_printf
argument_list|(
literal|"Unable to locate a sleep queue via %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
return|return;
name|found
label|:
name|db_printf
argument_list|(
literal|"Wait channel: %p\n"
argument_list|,
name|sq
operator|->
name|sq_wchan
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|db_printf
argument_list|(
literal|"Queue type: %d\n"
argument_list|,
name|sq
operator|->
name|sq_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq
operator|->
name|sq_lock
condition|)
block|{
name|lock
operator|=
name|sq
operator|->
name|sq_lock
expr_stmt|;
name|db_printf
argument_list|(
literal|"Associated Interlock: %p - (%s) %s\n"
argument_list|,
name|lock
argument_list|,
name|LOCK_CLASS
argument_list|(
name|lock
argument_list|)
operator|->
name|lc_name
argument_list|,
name|lock
operator|->
name|lo_name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|db_printf
argument_list|(
literal|"Blocked threads:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_SLEEPQS
condition|;
name|i
operator|++
control|)
block|{
name|db_printf
argument_list|(
literal|"\nQueue[%d]:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sq
operator|->
name|sq_blocked
index|[
name|i
index|]
argument_list|)
condition|)
name|db_printf
argument_list|(
literal|"\tempty\n"
argument_list|)
expr_stmt|;
else|else
name|TAILQ_FOREACH
argument_list|(
argument|td
argument_list|,
argument|&sq->sq_blocked[
literal|0
argument|]
argument_list|,
argument|td_slpq
argument_list|)
block|{
name|db_printf
argument_list|(
literal|"\t%p (tid %d, pid %d, \"%s\")\n"
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_tid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_name
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|?
name|td
operator|->
name|td_name
else|:
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/* Alias 'show sleepqueue' to 'show sleepq'. */
end_comment

begin_expr_stmt
name|DB_SET
argument_list|(
name|sleepqueue
argument_list|,
name|db_show_sleepqueue
argument_list|,
name|db_show_cmd_set
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

