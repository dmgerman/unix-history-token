begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004 John Baldwin<jhb@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Implementation of sleep queues used to hold queue of threads blocked on  * a wait channel.  Sleep queues different from turnstiles in that wait  * channels are not owned by anyone, so there is no priority propagation.  * Sleep queues can also provide a timeout and can also be interrupted by  * signals.  That said, there are several similarities between the turnstile  * and sleep queue implementations.  (Note: turnstiles were implemented  * first.)  For example, both use a hash table of the same size where each  * bucket is referred to as a "chain" that contains both a spin lock and  * a linked list of queues.  An individual queue is located by using a hash  * to pick a chain, locking the chain, and then walking the chain searching  * for the queue.  This means that a wait channel object does not need to  * embed it's queue head just as locks do not embed their turnstile queue  * head.  Threads also carry around a sleep queue that they lend to the  * wait channel when blocking.  Just as in turnstiles, the queue includes  * a free list of the sleep queues of other threads blocked on the same  * wait channel in the case of multiple waiters.  *  * Some additional functionality provided by sleep queues include the  * ability to set a timeout.  The timeout is managed using a per-thread  * callout that resumes a thread if it is asleep.  A thread may also  * catch signals while it is asleep (aka an interruptible sleep).  The  * signal code uses sleepq_abort() to interrupt a sleeping thread.  Finally,  * sleep queues also provide some extra assertions.  One is not allowed to  * mix the sleep/wakeup and cv APIs for a given wait channel.  Also, one  * must consistently use the same lock to synchronize with a wait channel,  * though this check is currently only a warning for sleep/wakeup due to  * pre-existing abuse of that API.  The same lock must also be held when  * awakening threads, though that is currently only enforced for condition  * variables.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sleepqueue.h>
end_include

begin_comment
comment|/*  * Constants for the hash table of sleep queue chains.  These constants are  * the same ones that 4BSD (and possibly earlier versions of BSD) used.  * Basically, we ignore the lower 8 bits of the address since most wait  * channel pointers are aligned and only look at the next 7 bits for the  * hash.  SC_TABLESIZE must be a power of two for SC_MASK to work properly.  */
end_comment

begin_define
define|#
directive|define
name|SC_TABLESIZE
value|128
end_define

begin_comment
comment|/* Must be power of 2. */
end_comment

begin_define
define|#
directive|define
name|SC_MASK
value|(SC_TABLESIZE - 1)
end_define

begin_define
define|#
directive|define
name|SC_SHIFT
value|8
end_define

begin_define
define|#
directive|define
name|SC_HASH
parameter_list|(
name|wc
parameter_list|)
value|(((uintptr_t)(wc)>> SC_SHIFT)& SC_MASK)
end_define

begin_define
define|#
directive|define
name|SC_LOOKUP
parameter_list|(
name|wc
parameter_list|)
value|&sleepq_chains[SC_HASH(wc)]
end_define

begin_comment
comment|/*  * There two different lists of sleep queues.  Both lists are connected  * via the sq_hash entries.  The first list is the sleep queue chain list  * that a sleep queue is on when it is attached to a wait channel.  The  * second list is the free list hung off of a sleep queue that is attached  * to a wait channel.  *  * Each sleep queue also contains the wait channel it is attached to, the  * list of threads blocked on that wait channel, flags specific to the  * wait channel, and the lock used to synchronize with a wait channel.  * The flags are used to catch mismatches between the various consumers  * of the sleep queue API (e.g. sleep/wakeup and condition variables).  * The lock pointer is only used when invariants are enabled for various  * debugging checks.  *  * Locking key:  *  c - sleep queue chain lock  */
end_comment

begin_struct
struct|struct
name|sleepqueue
block|{
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|thread
argument_list|)
name|sq_blocked
expr_stmt|;
comment|/* (c) Blocked threads. */
name|LIST_ENTRY
argument_list|(
argument|sleepqueue
argument_list|)
name|sq_hash
expr_stmt|;
comment|/* (c) Chain and free list. */
name|LIST_HEAD
argument_list|(
argument_list|,
argument|sleepqueue
argument_list|)
name|sq_free
expr_stmt|;
comment|/* (c) Free queues. */
name|void
modifier|*
name|sq_wchan
decl_stmt|;
comment|/* (c) Wait channel. */
name|int
name|sq_flags
decl_stmt|;
comment|/* (c) Flags. */
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|mtx
modifier|*
name|sq_lock
decl_stmt|;
comment|/* (c) Associated lock. */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|sleepqueue_chain
block|{
name|LIST_HEAD
argument_list|(
argument_list|,
argument|sleepqueue
argument_list|)
name|sc_queues
expr_stmt|;
comment|/* List of sleep queues. */
name|struct
name|mtx
name|sc_lock
decl_stmt|;
comment|/* Spin lock for this chain. */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|sleepqueue_chain
name|sleepq_chains
index|[
name|SC_TABLESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_SLEEPQUEUE
argument_list|,
literal|"sleep queues"
argument_list|,
literal|"sleep queues"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Prototypes for non-exported routines.  */
end_comment

begin_function_decl
specifier|static
name|int
name|sleepq_check_timeout
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sleepq_switch
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sleepq_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sleepq_wakeup_thread
parameter_list|(
name|struct
name|sleepqueue
modifier|*
name|sq
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|pri
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Early initialization of sleep queues that is called from the sleepinit()  * SYSINIT.  */
end_comment

begin_function
name|void
name|init_sleepqueues
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SC_TABLESIZE
condition|;
name|i
operator|++
control|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|sleepq_chains
index|[
name|i
index|]
operator|.
name|sc_queues
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sleepq_chains
index|[
name|i
index|]
operator|.
name|sc_lock
argument_list|,
literal|"sleepq chain"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
block|}
name|thread0
operator|.
name|td_sleepqueue
operator|=
name|sleepq_alloc
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Malloc and initialize a new sleep queue for a new thread.  */
end_comment

begin_function
name|struct
name|sleepqueue
modifier|*
name|sleepq_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sleepqueue
modifier|*
name|sq
decl_stmt|;
name|sq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sleepqueue
argument_list|)
argument_list|,
name|M_SLEEPQUEUE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sq
operator|->
name|sq_blocked
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sq
operator|->
name|sq_free
argument_list|)
expr_stmt|;
return|return
operator|(
name|sq
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a sleep queue when a thread is destroyed.  */
end_comment

begin_function
name|void
name|sleepq_free
parameter_list|(
name|struct
name|sleepqueue
modifier|*
name|sq
parameter_list|)
block|{
name|MPASS
argument_list|(
name|sq
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sq
operator|->
name|sq_blocked
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sq
argument_list|,
name|M_SLEEPQUEUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look up the sleep queue associated with a given wait channel in the hash  * table locking the associated sleep queue chain.  Return holdind the sleep  * queue chain lock.  If no queue is found in the table, NULL is returned.  */
end_comment

begin_function
name|struct
name|sleepqueue
modifier|*
name|sleepq_lookup
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|)
block|{
name|struct
name|sleepqueue_chain
modifier|*
name|sc
decl_stmt|;
name|struct
name|sleepqueue
modifier|*
name|sq
decl_stmt|;
name|KASSERT
argument_list|(
name|wchan
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: invalid NULL wait channel"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|SC_LOOKUP
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sq
argument_list|,
argument|&sc->sc_queues
argument_list|,
argument|sq_hash
argument_list|)
if|if
condition|(
name|sq
operator|->
name|sq_wchan
operator|==
name|wchan
condition|)
return|return
operator|(
name|sq
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock the sleep queue chain associated with a given wait channel.  */
end_comment

begin_function
name|void
name|sleepq_release
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|)
block|{
name|struct
name|sleepqueue_chain
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|SC_LOOKUP
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Places the current thread on the sleepqueue for the specified wait  * channel.  If INVARIANTS is enabled, then it associates the passed in  * lock with the sleepq to make sure it is held when that sleep queue is  * woken up.  */
end_comment

begin_function
name|void
name|sleepq_add
parameter_list|(
name|struct
name|sleepqueue
modifier|*
name|sq
parameter_list|,
name|void
modifier|*
name|wchan
parameter_list|,
name|struct
name|mtx
modifier|*
name|lock
parameter_list|,
specifier|const
name|char
modifier|*
name|wmesg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|sleepqueue_chain
modifier|*
name|sc
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|,
modifier|*
name|td1
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|sc
operator|=
name|SC_LOOKUP
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|td
operator|->
name|td_sleepqueue
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|wchan
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If the passed in sleep queue is NULL, use this thread's queue. */
if|if
condition|(
name|sq
operator|==
name|NULL
condition|)
block|{
name|sq
operator|=
name|td
operator|->
name|td_sleepqueue
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_queues
argument_list|,
name|sq
argument_list|,
name|sq_hash
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sq
operator|->
name|sq_blocked
argument_list|)
argument_list|,
operator|(
literal|"thread's sleep queue has a non-empty queue"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|sq
operator|->
name|sq_free
argument_list|)
argument_list|,
operator|(
literal|"thread's sleep queue has a non-empty free list"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sq
operator|->
name|sq_wchan
operator|==
name|NULL
argument_list|,
operator|(
literal|"stale sq_wchan pointer"
operator|)
argument_list|)
expr_stmt|;
name|sq
operator|->
name|sq_wchan
operator|=
name|wchan
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|sq
operator|->
name|sq_lock
operator|=
name|lock
expr_stmt|;
endif|#
directive|endif
name|sq
operator|->
name|sq_flags
operator|=
name|flags
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sq
operator|->
name|sq_blocked
argument_list|,
name|td
argument_list|,
name|td_slpq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MPASS
argument_list|(
name|wchan
operator|==
name|sq
operator|->
name|sq_wchan
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|lock
operator|==
name|sq
operator|->
name|sq_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|td1
argument_list|,
argument|&sq->sq_blocked
argument_list|,
argument|td_slpq
argument_list|)
if|if
condition|(
name|td1
operator|->
name|td_priority
operator|>
name|td
operator|->
name|td_priority
condition|)
break|break;
if|if
condition|(
name|td1
operator|!=
name|NULL
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|td1
argument_list|,
name|td
argument_list|,
name|td_slpq
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sq
operator|->
name|sq_blocked
argument_list|,
name|td
argument_list|,
name|td_slpq
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sq
operator|->
name|sq_free
argument_list|,
name|td
operator|->
name|td_sleepqueue
argument_list|,
name|sq_hash
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_sleepqueue
operator|=
name|NULL
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_wchan
operator|=
name|wchan
expr_stmt|;
name|td
operator|->
name|td_wmesg
operator|=
name|wmesg
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sets a timeout that will remove the current thread from the specified  * sleep queue after timo ticks if the thread has not already been awakened.  */
end_comment

begin_function
name|void
name|sleepq_set_timeout
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|,
name|int
name|timo
parameter_list|)
block|{
name|struct
name|sleepqueue_chain
modifier|*
name|sc
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|sc
operator|=
name|SC_LOOKUP
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|td
operator|->
name|td_sleepqueue
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|wchan
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|td
operator|->
name|td_slpcallout
argument_list|,
name|timo
argument_list|,
name|sleepq_timeout
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Marks the pending sleep of the current thread as interruptible and  * makes an initial check for pending signals before putting a thread  * to sleep.  */
end_comment

begin_function
name|int
name|sleepq_catch_signals
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|)
block|{
name|struct
name|sleepqueue_chain
modifier|*
name|sc
decl_stmt|;
name|struct
name|sleepqueue
modifier|*
name|sq
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|sig
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|sc
operator|=
name|SC_LOOKUP
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|td
operator|->
name|td_sleepqueue
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|wchan
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"sleepq catching signals: thread %p (pid %d, %s)"
argument_list|,
name|td
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
comment|/* Mark thread as being in an interruptible sleep. */
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_flags
operator||=
name|TDF_SINTR
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|sleepq_release
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
comment|/* See if there are any pending signals for this thread. */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|p
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
name|sig
operator|=
name|cursig
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|p
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|==
literal|0
operator|&&
name|thread_suspend_check
argument_list|(
literal|1
argument_list|)
condition|)
name|sig
operator|=
name|SIGSTOP
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * If there were pending signals and this thread is still on 	 * the sleep queue, remove it from the sleep queue. 	 */
name|sq
operator|=
name|sleepq_lookup
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
operator|&&
name|sig
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|sleepq_wakeup_thread
argument_list|(
name|sq
argument_list|,
name|td
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|sig
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Switches to another thread if we are still asleep on a sleep queue and  * drop the lock on the sleepqueue chain.  Returns with sched_lock held.  */
end_comment

begin_function
specifier|static
name|void
name|sleepq_switch
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|)
block|{
name|struct
name|sleepqueue_chain
modifier|*
name|sc
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|sc
operator|=
name|SC_LOOKUP
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/*  	 * If we have a sleep queue, then we've already been woken up, so 	 * just return. 	 */
if|if
condition|(
name|td
operator|->
name|td_sleepqueue
operator|!=
name|NULL
condition|)
block|{
name|MPASS
argument_list|(
operator|!
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Otherwise, actually go to sleep. 	 */
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|)
expr_stmt|;
name|sched_sleep
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|TD_SET_SLEEPING
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|mi_switch
argument_list|(
name|SW_VOL
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TD_IS_RUNNING
argument_list|(
name|td
argument_list|)
argument_list|,
operator|(
literal|"running but not TDS_RUNNING"
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"sleepq resume: thread %p (pid %d, %s)"
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see if we timed out.  */
end_comment

begin_function
specifier|static
name|int
name|sleepq_check_timeout
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
comment|/* 	 * If TDF_TIMEOUT is set, we timed out. 	 */
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_TIMEOUT
condition|)
block|{
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_TIMEOUT
expr_stmt|;
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
block|}
comment|/* 	 * If TDF_TIMOFAIL is set, the timeout ran after we had 	 * already been woken up. 	 */
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_TIMOFAIL
condition|)
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_TIMOFAIL
expr_stmt|;
comment|/* 	 * If callout_stop() fails, then the timeout is running on 	 * another CPU, so synchronize with it to avoid having it 	 * accidentally wake up a subsequent sleep. 	 */
elseif|else
if|if
condition|(
name|callout_stop
argument_list|(
operator|&
name|td
operator|->
name|td_slpcallout
argument_list|)
operator|==
literal|0
condition|)
block|{
name|td
operator|->
name|td_flags
operator||=
name|TDF_TIMEOUT
expr_stmt|;
name|TD_SET_SLEEPING
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|mi_switch
argument_list|(
name|SW_INVOL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if we were awoken by a signal.  */
end_comment

begin_function
specifier|static
name|int
name|sleepq_check_signals
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
comment|/* We are no longer in an interruptible sleep. */
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_SINTR
expr_stmt|;
comment|/* If we were interrupted, return td_intrval. */
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_INTERRUPT
condition|)
return|return
operator|(
name|td
operator|->
name|td_intrval
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If we were in an interruptible sleep and we weren't interrupted and  * didn't timeout, check to see if there are any pending signals and  * which return value we should use if so.  The return value from an  * earlier call to sleepq_catch_signals() should be passed in as the  * argument.  */
end_comment

begin_function
name|int
name|sleepq_calc_signal_retval
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|p
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
comment|/* XXX: Should we always be calling cursig()? */
if|if
condition|(
name|sig
operator|==
literal|0
condition|)
name|sig
operator|=
name|cursig
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|SIGISMEMBER
argument_list|(
name|p
operator|->
name|p_sigacts
operator|->
name|ps_sigintr
argument_list|,
name|sig
argument_list|)
condition|)
name|rval
operator|=
name|EINTR
expr_stmt|;
else|else
name|rval
operator|=
name|ERESTART
expr_stmt|;
block|}
else|else
name|rval
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|p
operator|->
name|p_sigacts
operator|->
name|ps_mtx
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Block the current thread until it is awakened from its sleep queue.  */
end_comment

begin_function
name|void
name|sleepq_wait
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|)
block|{
name|sleepq_switch
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Block the current thread until it is awakened from its sleep queue  * or it is interrupted by a signal.  */
end_comment

begin_function
name|int
name|sleepq_wait_sig
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|)
block|{
name|int
name|rval
decl_stmt|;
name|sleepq_switch
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|rval
operator|=
name|sleepq_check_signals
argument_list|()
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Block the current thread until it is awakened from its sleep queue  * or it times out while waiting.  */
end_comment

begin_function
name|int
name|sleepq_timedwait
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|,
name|int
name|signal_caught
parameter_list|)
block|{
name|int
name|rval
decl_stmt|;
name|sleepq_switch
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|rval
operator|=
name|sleepq_check_timeout
argument_list|()
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal_caught
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Block the current thread until it is awakened from its sleep queue,  * it is interrupted by a signal, or it times out waiting to be awakened.  */
end_comment

begin_function
name|int
name|sleepq_timedwait_sig
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|,
name|int
name|signal_caught
parameter_list|)
block|{
name|int
name|rvalt
decl_stmt|,
name|rvals
decl_stmt|;
name|sleepq_switch
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|rvalt
operator|=
name|sleepq_check_timeout
argument_list|()
expr_stmt|;
name|rvals
operator|=
name|sleepq_check_signals
argument_list|()
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal_caught
operator|||
name|rvalt
operator|==
literal|0
condition|)
return|return
operator|(
name|rvals
operator|)
return|;
else|else
return|return
operator|(
name|rvalt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Removes a thread from a sleep queue and resumes it.  */
end_comment

begin_function
specifier|static
name|void
name|sleepq_wakeup_thread
parameter_list|(
name|struct
name|sleepqueue
modifier|*
name|sq
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|pri
parameter_list|)
block|{
name|struct
name|sleepqueue_chain
modifier|*
name|sc
decl_stmt|;
name|MPASS
argument_list|(
name|td
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|sq
operator|->
name|sq_wchan
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|td
operator|->
name|td_wchan
operator|==
name|sq
operator|->
name|sq_wchan
argument_list|)
expr_stmt|;
name|sc
operator|=
name|SC_LOOKUP
argument_list|(
name|sq
operator|->
name|sq_wchan
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Remove the thread from the queue. */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sq
operator|->
name|sq_blocked
argument_list|,
name|td
argument_list|,
name|td_slpq
argument_list|)
expr_stmt|;
comment|/* 	 * Get a sleep queue for this thread.  If this is the last waiter, 	 * use the queue itself and take it out of the chain, otherwise, 	 * remove a queue from the free list. 	 */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|sq
operator|->
name|sq_free
argument_list|)
condition|)
block|{
name|td
operator|->
name|td_sleepqueue
operator|=
name|sq
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|sq
operator|->
name|sq_wchan
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|td
operator|->
name|td_sleepqueue
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sq
operator|->
name|sq_free
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|td
operator|->
name|td_sleepqueue
argument_list|,
name|sq_hash
argument_list|)
expr_stmt|;
comment|/* 	 * Finish resuming the thread. 	 */
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"sleepq_wakeup: thread %p (pid %d, %s)"
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_wmesg
operator|=
name|NULL
expr_stmt|;
name|td
operator|->
name|td_wchan
operator|=
name|NULL
expr_stmt|;
name|TD_CLR_SLEEPING
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* Adjust priority if requested. */
name|MPASS
argument_list|(
name|pri
operator|==
operator|-
literal|1
operator|||
operator|(
name|pri
operator|>=
name|PRI_MIN
operator|&&
name|pri
operator|<=
name|PRI_MAX
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pri
operator|!=
operator|-
literal|1
operator|&&
name|td
operator|->
name|td_priority
operator|>
name|pri
condition|)
name|td
operator|->
name|td_priority
operator|=
name|pri
expr_stmt|;
name|setrunnable
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the highest priority thread sleeping on a wait channel and resume it.  */
end_comment

begin_function
name|void
name|sleepq_signal
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|pri
parameter_list|)
block|{
name|struct
name|sleepqueue
modifier|*
name|sq
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_PROC
argument_list|,
literal|"sleepq_signal(%p, %d)"
argument_list|,
name|wchan
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|wchan
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: invalid NULL wait channel"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sq
operator|=
name|sleepq_lookup
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq
operator|==
name|NULL
condition|)
block|{
name|sleepq_release
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|sq
operator|->
name|sq_flags
operator|==
name|flags
argument_list|,
operator|(
literal|"%s: mismatch between sleep/wakeup and cv_*"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX: Do for all sleep queues eventually. */
if|if
condition|(
name|flags
operator|&
name|SLEEPQ_CONDVAR
condition|)
name|mtx_assert
argument_list|(
name|sq
operator|->
name|sq_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sleepq_wakeup_thread
argument_list|(
name|sq
argument_list|,
name|TAILQ_FIRST
argument_list|(
operator|&
name|sq
operator|->
name|sq_blocked
argument_list|)
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|sleepq_release
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Resume all threads sleeping on a specified wait channel.  */
end_comment

begin_function
name|void
name|sleepq_broadcast
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|pri
parameter_list|)
block|{
name|struct
name|sleepqueue
modifier|*
name|sq
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_PROC
argument_list|,
literal|"sleepq_broadcast(%p, %d)"
argument_list|,
name|wchan
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|wchan
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: invalid NULL wait channel"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sq
operator|=
name|sleepq_lookup
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq
operator|==
name|NULL
condition|)
block|{
name|sleepq_release
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|sq
operator|->
name|sq_flags
operator|==
name|flags
argument_list|,
operator|(
literal|"%s: mismatch between sleep/wakeup and cv_*"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX: Do for all sleep queues eventually. */
if|if
condition|(
name|flags
operator|&
name|SLEEPQ_CONDVAR
condition|)
name|mtx_assert
argument_list|(
name|sq
operator|->
name|sq_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sq
operator|->
name|sq_blocked
argument_list|)
condition|)
name|sleepq_wakeup_thread
argument_list|(
name|sq
argument_list|,
name|TAILQ_FIRST
argument_list|(
operator|&
name|sq
operator|->
name|sq_blocked
argument_list|)
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|sleepq_release
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Time sleeping threads out.  When the timeout expires, the thread is  * removed from the sleep queue and made runnable if it is still asleep.  */
end_comment

begin_function
specifier|static
name|void
name|sleepq_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sleepqueue
modifier|*
name|sq
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|void
modifier|*
name|wchan
decl_stmt|;
name|td
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|arg
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"sleepq_timeout: thread %p (pid %d, %s)"
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
comment|/* 	 * First, see if the thread is asleep and get the wait channel if 	 * it is. 	 */
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|wchan
operator|=
name|td
operator|->
name|td_wchan
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|sq
operator|=
name|sleepq_lookup
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wchan
operator|=
name|NULL
expr_stmt|;
name|sq
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * At this point, if the thread is still on the sleep queue, 	 * we have that sleep queue locked as it cannot migrate sleep 	 * queues while we dropped sched_lock.  If it had resumed and 	 * was on another CPU while the lock was dropped, it would have 	 * seen that TDF_TIMEOUT and TDF_TIMOFAIL are clear and the 	 * call to callout_stop() to stop this routine would have failed 	 * meaning that it would have already set TDF_TIMEOUT to 	 * synchronize with this function. 	 */
if|if
condition|(
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|MPASS
argument_list|(
name|td
operator|->
name|td_wchan
operator|==
name|wchan
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|sq
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_flags
operator||=
name|TDF_TIMEOUT
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|sleepq_wakeup_thread
argument_list|(
name|sq
argument_list|,
name|td
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sleepq_release
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|wchan
operator|!=
name|NULL
condition|)
name|sleepq_release
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
comment|/* 	 * Now check for the edge cases.  First, if TDF_TIMEOUT is set, 	 * then the other thread has already yielded to us, so clear 	 * the flag and resume it.  If TDF_TIMEOUT is not set, then the 	 * we know that the other thread is not on a sleep queue, but it 	 * hasn't resumed execution yet.  In that case, set TDF_TIMOFAIL 	 * to let it know that the timeout has already run and doesn't 	 * need to be canceled. 	 */
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_TIMEOUT
condition|)
block|{
name|MPASS
argument_list|(
name|TD_IS_SLEEPING
argument_list|(
name|td
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_TIMEOUT
expr_stmt|;
name|TD_CLR_SLEEPING
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|setrunnable
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
else|else
name|td
operator|->
name|td_flags
operator||=
name|TDF_TIMOFAIL
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Resumes a specific thread from the sleep queue associated with a specific  * wait channel if it is on that queue.  */
end_comment

begin_function
name|void
name|sleepq_remove
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|wchan
parameter_list|)
block|{
name|struct
name|sleepqueue
modifier|*
name|sq
decl_stmt|;
comment|/* 	 * Look up the sleep queue for this wait channel, then re-check 	 * that the thread is asleep on that channel, if it is not, then 	 * bail. 	 */
name|MPASS
argument_list|(
name|wchan
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sq
operator|=
name|sleepq_lookup
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
operator|||
name|td
operator|->
name|td_wchan
operator|!=
name|wchan
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|sleepq_release
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
return|return;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|sq
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Thread is asleep on sleep queue sq, so wake it up. */
name|sleepq_wakeup_thread
argument_list|(
name|sq
argument_list|,
name|td
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sleepq_release
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Abort a thread as if an interrupt had occured.  Only abort  * interruptable waits (unfortunately it isn't safe to abort others).  *  * XXX: What in the world does the comment below mean?  * Also, whatever the signal code does...  */
end_comment

begin_function
name|void
name|sleepq_abort
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|void
modifier|*
name|wchan
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_SINTR
argument_list|)
expr_stmt|;
comment|/* 	 * If the TDF_TIMEOUT flag is set, just leave. A 	 * timeout is scheduled anyhow. 	 */
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_TIMEOUT
condition|)
return|return;
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"sleepq_abort: thread %p (pid %d, %s)"
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|wchan
operator|=
name|td
operator|->
name|td_wchan
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|sleepq_remove
argument_list|(
name|td
argument_list|,
name|wchan
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

