begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005-2008, Sam Leffler<sam@errno.com>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/firmware.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_comment
comment|/*  * Loadable firmware support. See sys/sys/firmware.h and firmware(9)  * form more details on the subsystem.  *  * 'struct firmware' is the user-visible part of the firmware table.  * Additional internal information is stored in a 'struct priv_fw'  * (currently a static array). A slot is in use if FW_INUSE is true:  */
end_comment

begin_define
define|#
directive|define
name|FW_INUSE
parameter_list|(
name|p
parameter_list|)
value|((p)->file != NULL || (p)->fw.name != NULL)
end_define

begin_comment
comment|/*  * fw.name != NULL when an image is registered; file != NULL for  * autoloaded images whose handling has not been completed.  *  * The state of a slot evolves as follows:  *	firmware_register	-->  fw.name = image_name  *	(autoloaded image)	-->  file = module reference  *	firmware_unregister	-->  fw.name = NULL  *	(unloadentry complete)	-->  file = NULL  *  * In order for the above to work, the 'file' field must remain  * unchanged in firmware_unregister().  *  * Images residing in the same module are linked to each other  * through the 'parent' argument of firmware_register().  * One image (typically, one with the same name as the module to let  * the autoloading mechanism work) is considered the parent image for  * all other images in the same module. Children affect the refcount  * on the parent image preventing improper unloading of the image itself.  */
end_comment

begin_struct
struct|struct
name|priv_fw
block|{
name|int
name|refcnt
decl_stmt|;
comment|/* reference count */
comment|/* 	 * parent entry, see above. Set on firmware_register(), 	 * cleared on firmware_unregister(). 	 */
name|struct
name|priv_fw
modifier|*
name|parent
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* record FIRMWARE_UNLOAD requests */
define|#
directive|define
name|FW_UNLOAD
value|0x100
comment|/* 	 * 'file' is private info managed by the autoload/unload code. 	 * Set at the end of firmware_get(), cleared only in the 	 * firmware_unload_task, so the latter can depend on its value even 	 * while the lock is not held. 	 */
name|linker_file_t
name|file
decl_stmt|;
comment|/* module file, if autoloaded */
comment|/* 	 * 'fw' is the externally visible image information. 	 * We do not make it the first field in priv_fw, to avoid the 	 * temptation of casting pointers to each other. 	 * Use PRIV_FW(fw) to get a pointer to the cointainer of fw. 	 * Beware, PRIV_FW does not work for a NULL pointer. 	 */
name|struct
name|firmware
name|fw
decl_stmt|;
comment|/* externally visible information */
block|}
struct|;
end_struct

begin_comment
comment|/*  * PRIV_FW returns the pointer to the container of struct firmware *x.  * Cast to intptr_t to override the 'const' attribute of x  */
end_comment

begin_define
define|#
directive|define
name|PRIV_FW
parameter_list|(
name|x
parameter_list|)
value|((struct priv_fw *)		\ 	((intptr_t)(x) - offsetof(struct priv_fw, fw)) )
end_define

begin_comment
comment|/*  * At the moment we use a static array as backing store for the registry.  * Should we move to a dynamic structure, keep in mind that we cannot  * reallocate the array because pointers are held externally.  * A list may work, though.  */
end_comment

begin_define
define|#
directive|define
name|FIRMWARE_MAX
value|50
end_define

begin_decl_stmt
specifier|static
name|struct
name|priv_fw
name|firmware_table
index|[
name|FIRMWARE_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Firmware module operations are handled in a separate task as they  * might sleep and they require directory context to do i/o.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|taskqueue
modifier|*
name|firmware_tq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|task
name|firmware_unload_task
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This mutex protects accesses to the firmware table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|firmware_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|firmware
argument_list|,
operator|&
name|firmware_mtx
argument_list|,
literal|"firmware table"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Helper function to lookup a name.  * As a side effect, it sets the pointer to a free slot, if any.  * This way we can concentrate most of the registry scanning in  * this function, which makes it easier to replace the registry  * with some other data structure.  */
end_comment

begin_function
specifier|static
name|struct
name|priv_fw
modifier|*
name|lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|priv_fw
modifier|*
modifier|*
name|empty_slot
parameter_list|)
block|{
name|struct
name|priv_fw
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|struct
name|priv_fw
modifier|*
name|dummy
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|empty_slot
operator|==
name|NULL
condition|)
name|empty_slot
operator|=
operator|&
name|dummy
expr_stmt|;
operator|*
name|empty_slot
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRMWARE_MAX
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|firmware_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fw
operator|.
name|name
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|fp
operator|->
name|fw
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|FW_INUSE
argument_list|(
name|fp
argument_list|)
condition|)
operator|*
name|empty_slot
operator|=
name|fp
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|<
name|FIRMWARE_MAX
operator|)
condition|?
name|fp
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Register a firmware image with the specified name.  The  * image name must not already be registered.  If this is a  * subimage then parent refers to a previously registered  * image that this should be associated with.  */
end_comment

begin_function
specifier|const
name|struct
name|firmware
modifier|*
name|firmware_register
parameter_list|(
specifier|const
name|char
modifier|*
name|imagename
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|datasize
parameter_list|,
name|unsigned
name|int
name|version
parameter_list|,
specifier|const
name|struct
name|firmware
modifier|*
name|parent
parameter_list|)
block|{
name|struct
name|priv_fw
modifier|*
name|match
decl_stmt|,
modifier|*
name|frp
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|strdup
argument_list|(
name|imagename
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|firmware_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Do a lookup to make sure the name is unique or find a free slot. 	 */
name|match
operator|=
name|lookup
argument_list|(
name|imagename
argument_list|,
operator|&
name|frp
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|!=
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|firmware_mtx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: image %s already registered!\n"
argument_list|,
name|__func__
argument_list|,
name|imagename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|frp
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|firmware_mtx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: cannot register image %s, firmware table full!\n"
argument_list|,
name|__func__
argument_list|,
name|imagename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|str
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
name|frp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|frp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* start from a clean record */
name|frp
operator|->
name|fw
operator|.
name|name
operator|=
name|str
expr_stmt|;
name|frp
operator|->
name|fw
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|frp
operator|->
name|fw
operator|.
name|datasize
operator|=
name|datasize
expr_stmt|;
name|frp
operator|->
name|fw
operator|.
name|version
operator|=
name|version
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
name|NULL
condition|)
name|frp
operator|->
name|parent
operator|=
name|PRIV_FW
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|firmware_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"firmware: '%s' version %u: %zu bytes loaded at %p\n"
argument_list|,
name|imagename
argument_list|,
name|version
argument_list|,
name|datasize
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
operator|&
name|frp
operator|->
name|fw
return|;
block|}
end_function

begin_comment
comment|/*  * Unregister/remove a firmware image.  If there are outstanding  * references an error is returned and the image is not removed  * from the registry.  */
end_comment

begin_function
name|int
name|firmware_unregister
parameter_list|(
specifier|const
name|char
modifier|*
name|imagename
parameter_list|)
block|{
name|struct
name|priv_fw
modifier|*
name|fp
decl_stmt|;
name|int
name|err
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|firmware_mtx
argument_list|)
expr_stmt|;
name|fp
operator|=
name|lookup
argument_list|(
name|imagename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * It is ok for the lookup to fail; this can happen 		 * when a module is unloaded on last reference and the 		 * module unload handler unregister's each of it's 		 * firmware images. 		 */
name|err
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fp
operator|->
name|refcnt
operator|!=
literal|0
condition|)
block|{
comment|/* cannot unregister */
name|err
operator|=
name|EBUSY
expr_stmt|;
block|}
else|else
block|{
name|linker_file_t
name|x
init|=
name|fp
operator|->
name|file
decl_stmt|;
comment|/* save value */
comment|/* 		 * Clear the whole entry with bzero to make sure we 		 * do not forget anything. Then restore 'file' which is 		 * non-null for autoloaded images. 		 */
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|fp
operator|->
name|fw
operator|.
name|name
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|priv_fw
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|file
operator|=
name|x
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|firmware_mtx
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|loadimage
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|char
modifier|*
name|imagename
init|=
name|arg
decl_stmt|;
name|struct
name|priv_fw
modifier|*
name|fp
decl_stmt|;
name|linker_file_t
name|result
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* synchronize with the thread that dispatched us */
name|mtx_lock
argument_list|(
operator|&
name|firmware_mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|firmware_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_rdir
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: root not mounted yet, no way to load image\n"
argument_list|,
name|imagename
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|error
operator|=
name|linker_reference_module
argument_list|(
name|imagename
argument_list|,
name|NULL
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: could not load firmware image, error %d\n"
argument_list|,
name|imagename
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|firmware_mtx
argument_list|)
expr_stmt|;
name|fp
operator|=
name|lookup
argument_list|(
name|imagename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
operator|||
name|fp
operator|->
name|file
operator|!=
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|firmware_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s: firmware image loaded, "
literal|"but did not register\n"
argument_list|,
name|imagename
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|linker_release_module
argument_list|(
name|imagename
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|fp
operator|->
name|file
operator|=
name|result
expr_stmt|;
comment|/* record the module identity */
name|mtx_unlock
argument_list|(
operator|&
name|firmware_mtx
argument_list|)
expr_stmt|;
name|done
label|:
name|wakeup_one
argument_list|(
name|imagename
argument_list|)
expr_stmt|;
comment|/* we're done */
block|}
end_function

begin_comment
comment|/*  * Lookup and potentially load the specified firmware image.  * If the firmware is not found in the registry, try to load a kernel  * module named as the image name.  * If the firmware is located, a reference is returned. The caller must  * release this reference for the image to be eligible for removal/unload.  */
end_comment

begin_function
specifier|const
name|struct
name|firmware
modifier|*
name|firmware_get
parameter_list|(
specifier|const
name|char
modifier|*
name|imagename
parameter_list|)
block|{
name|struct
name|task
name|fwload_task
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|priv_fw
modifier|*
name|fp
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|firmware_mtx
argument_list|)
expr_stmt|;
name|fp
operator|=
name|lookup
argument_list|(
name|imagename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
goto|goto
name|found
goto|;
comment|/* 	 * Image not present, try to load the module holding it. 	 */
name|td
operator|=
name|curthread
expr_stmt|;
if|if
condition|(
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_FIRMWARE_LOAD
argument_list|)
operator|!=
literal|0
operator|||
name|securelevel_gt
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|firmware_mtx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: insufficient privileges to "
literal|"load firmware image %s\n"
argument_list|,
name|__func__
argument_list|,
name|imagename
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*  	 * Defer load to a thread with known context.  linker_reference_module 	 * may do filesystem i/o which requires root& current dirs, etc. 	 * Also we must not hold any mtx's over this call which is problematic. 	 */
if|if
condition|(
operator|!
name|cold
condition|)
block|{
name|TASK_INIT
argument_list|(
operator|&
name|fwload_task
argument_list|,
literal|0
argument_list|,
name|loadimage
argument_list|,
name|__DECONST
argument_list|(
name|void
operator|*
argument_list|,
name|imagename
argument_list|)
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|firmware_tq
argument_list|,
operator|&
name|fwload_task
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
name|__DECONST
argument_list|(
name|void
operator|*
argument_list|,
name|imagename
argument_list|)
argument_list|,
operator|&
name|firmware_mtx
argument_list|,
literal|0
argument_list|,
literal|"fwload"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * After attempting to load the module, see if the image is registered. 	 */
name|fp
operator|=
name|lookup
argument_list|(
name|imagename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|firmware_mtx
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|found
label|:
comment|/* common exit point on success */
if|if
condition|(
name|fp
operator|->
name|refcnt
operator|==
literal|0
operator|&&
name|fp
operator|->
name|parent
operator|!=
name|NULL
condition|)
name|fp
operator|->
name|parent
operator|->
name|refcnt
operator|++
expr_stmt|;
name|fp
operator|->
name|refcnt
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|firmware_mtx
argument_list|)
expr_stmt|;
return|return
operator|&
name|fp
operator|->
name|fw
return|;
block|}
end_function

begin_comment
comment|/*  * Release a reference to a firmware image returned by firmware_get.  * The caller may specify, with the FIRMWARE_UNLOAD flag, its desire  * to release the resource, but the flag is only advisory.  *  * If this is the last reference to the firmware image, and this is an  * autoloaded module, wake up the firmware_unload_task to figure out  * what to do with the associated module.  */
end_comment

begin_function
name|void
name|firmware_put
parameter_list|(
specifier|const
name|struct
name|firmware
modifier|*
name|p
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|priv_fw
modifier|*
name|fp
init|=
name|PRIV_FW
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|firmware_mtx
argument_list|)
expr_stmt|;
name|fp
operator|->
name|refcnt
operator|--
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|refcnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|parent
operator|!=
name|NULL
condition|)
name|fp
operator|->
name|parent
operator|->
name|refcnt
operator|--
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FIRMWARE_UNLOAD
condition|)
name|fp
operator|->
name|flags
operator||=
name|FW_UNLOAD
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|file
condition|)
name|taskqueue_enqueue
argument_list|(
name|firmware_tq
argument_list|,
operator|&
name|firmware_unload_task
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|firmware_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup directory state for the firmware_tq thread so we can do i/o.  */
end_comment

begin_function
specifier|static
name|void
name|set_rootvnode
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|pwd_ensure_dirs
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|arg
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Event handler called on mounting of /; bounce a task  * into the task queue thread to setup it's directories.  */
end_comment

begin_function
specifier|static
name|void
name|firmware_mountroot
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|task
modifier|*
name|setroot_task
decl_stmt|;
name|setroot_task
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|task
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|setroot_task
operator|!=
name|NULL
condition|)
block|{
name|TASK_INIT
argument_list|(
name|setroot_task
argument_list|,
literal|0
argument_list|,
name|set_rootvnode
argument_list|,
name|setroot_task
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|firmware_tq
argument_list|,
name|setroot_task
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s: no memory for task!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EVENTHANDLER_DEFINE
argument_list|(
name|mountroot
argument_list|,
name|firmware_mountroot
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The body of the task in charge of unloading autoloaded modules  * that are not needed anymore.  * Images can be cross-linked so we may need to make multiple passes,  * but the time we spend in the loop is bounded because we clear entries  * as we touch them.  */
end_comment

begin_function
specifier|static
name|void
name|unloadentry
parameter_list|(
name|void
modifier|*
name|unused1
parameter_list|,
name|int
name|unused2
parameter_list|)
block|{
name|int
name|limit
init|=
name|FIRMWARE_MAX
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* current cycle */
name|mtx_lock
argument_list|(
operator|&
name|firmware_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Scan the table. limit is set to make sure we make another 	 * full sweep after matching an entry that requires unloading. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|priv_fw
modifier|*
name|fp
decl_stmt|;
name|int
name|err
decl_stmt|;
name|fp
operator|=
operator|&
name|firmware_table
index|[
name|i
operator|%
name|FIRMWARE_MAX
index|]
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fw
operator|.
name|name
operator|==
name|NULL
operator|||
name|fp
operator|->
name|file
operator|==
name|NULL
operator|||
name|fp
operator|->
name|refcnt
operator|!=
literal|0
operator|||
operator|(
name|fp
operator|->
name|flags
operator|&
name|FW_UNLOAD
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Found an entry. Now: 		 * 1. bump up limit to make sure we make another full round; 		 * 2. clear FW_UNLOAD so we don't try this entry again. 		 * 3. release the lock while trying to unload the module. 		 * 'file' remains set so that the entry cannot be reused 		 * in the meantime (it also means that fp->file will 		 * not change while we release the lock). 		 */
name|limit
operator|=
name|i
operator|+
name|FIRMWARE_MAX
expr_stmt|;
comment|/* make another full round */
name|fp
operator|->
name|flags
operator|&=
operator|~
name|FW_UNLOAD
expr_stmt|;
comment|/* do not try again */
name|mtx_unlock
argument_list|(
operator|&
name|firmware_mtx
argument_list|)
expr_stmt|;
name|err
operator|=
name|linker_release_module
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|fp
operator|->
name|file
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|firmware_mtx
argument_list|)
expr_stmt|;
comment|/* 		 * We rely on the module to call firmware_unregister() 		 * on unload to actually release the entry. 		 * If err = 0 we can drop our reference as the system 		 * accepted it. Otherwise unloading failed (e.g. the 		 * module itself gave an error) so our reference is 		 * still valid. 		 */
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|fp
operator|->
name|file
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|firmware_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Module glue.  */
end_comment

begin_function
specifier|static
name|int
name|firmware_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|struct
name|priv_fw
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|TASK_INIT
argument_list|(
operator|&
name|firmware_unload_task
argument_list|,
literal|0
argument_list|,
name|unloadentry
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|firmware_tq
operator|=
name|taskqueue_create
argument_list|(
literal|"taskqueue_firmware"
argument_list|,
name|M_WAITOK
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|firmware_tq
argument_list|)
expr_stmt|;
comment|/* NB: use our own loop routine that sets up context */
operator|(
name|void
operator|)
name|taskqueue_start_threads
argument_list|(
operator|&
name|firmware_tq
argument_list|,
literal|1
argument_list|,
name|PWAIT
argument_list|,
literal|"firmware taskq"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rootvnode
operator|!=
name|NULL
condition|)
block|{
comment|/*  			 * Root is already mounted so we won't get an event; 			 * simulate one here. 			 */
name|firmware_mountroot
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|MOD_UNLOAD
case|:
comment|/* request all autoloaded modules to be released */
name|mtx_lock
argument_list|(
operator|&
name|firmware_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRMWARE_MAX
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|firmware_table
index|[
name|i
index|]
expr_stmt|;
name|fp
operator|->
name|flags
operator||=
name|FW_UNLOAD
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|firmware_mtx
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|firmware_tq
argument_list|,
operator|&
name|firmware_unload_task
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|firmware_tq
argument_list|,
operator|&
name|firmware_unload_task
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRMWARE_MAX
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|&
name|firmware_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|fw
operator|.
name|name
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: image %p ref %d still active slot %d\n"
argument_list|,
name|__func__
argument_list|,
name|fp
operator|->
name|fw
operator|.
name|name
argument_list|,
name|fp
operator|->
name|refcnt
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|taskqueue_free
argument_list|(
name|firmware_tq
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
return|return
name|EINVAL
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|firmware_mod
init|=
block|{
literal|"firmware"
block|,
name|firmware_modevent
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|firmware
argument_list|,
name|firmware_mod
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_FIRST
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|firmware
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

