begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 John S. Dyson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Absolutely no warranty of function or purpose is made by the author  *    John S. Dyson.  * 4. This work was done expressly for inclusion into FreeBSD.  Other use  *    is allowed if this notation is included.  * 5. Modifications may be freely made to this file if the above conditions  *    are met.  *  * $Id: vfs_bio.c,v 1.133 1997/11/06 19:29:29 phk Exp $  */
end_comment

begin_comment
comment|/*  * this file contains a new buffer I/O scheme implementing a coherent  * VM object and buffer cache scheme.  Pains have been taken to make  * sure that the performance degradation associated with schemes such  * as this is not realized.  *  * Author:  John S. Dyson  * Significant help during the development and debugging phases  * had been provided by David Greenman, also of the FreeBSD core team.  */
end_comment

begin_include
include|#
directive|include
file|"opt_bounce.h"
end_include

begin_define
define|#
directive|define
name|VMIO
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_prot.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_BIOBUF
argument_list|,
literal|"BIO buffer"
argument_list|,
literal|"BIO buffer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|void
name|vfs_update
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|updateproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kproc_desc
name|up_kp
init|=
block|{
literal|"update"
block|,
name|vfs_update
block|,
operator|&
name|updateproc
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|SYSINIT_KT
argument_list|(
argument|update
argument_list|,
argument|SI_SUB_KTHREAD_UPDATE
argument_list|,
argument|SI_ORDER_FIRST
argument_list|,
argument|kproc_start
argument_list|,
argument|&up_kp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer header pool */
end_comment

begin_decl_stmt
name|struct
name|swqueue
name|bswlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|count_lock_queue
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|vm_hold_free_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|vm_offset_t
name|from
parameter_list|,
name|vm_offset_t
name|to
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vm_hold_load_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|vm_offset_t
name|from
parameter_list|,
name|vm_offset_t
name|to
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vfs_buf_set_valid
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|vm_ooffset_t
name|foff
parameter_list|,
name|vm_offset_t
name|off
parameter_list|,
name|vm_offset_t
name|size
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vfs_page_set_valid
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|vm_ooffset_t
name|off
parameter_list|,
name|int
name|pageno
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vfs_clean_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vfs_setdirty
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vfs_vmio_release
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|flushdirtybuffers
parameter_list|(
name|int
name|slpflag
parameter_list|,
name|int
name|slptimeo
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|needsbuffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Internal update daemon, process 3  *	The variable vfs_update_wakeup allows for internal syncs.  */
end_comment

begin_decl_stmt
name|int
name|vfs_update_wakeup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * buffers base kva  */
end_comment

begin_comment
comment|/*  * bogus page -- for I/O to/from partially complete buffers  * this is a temporary solution to the problem, but it is not  * really that bad.  it would be better to split the buffer  * for input in the case of buffers partially already in memory,  * but the code is intricate enough already.  */
end_comment

begin_decl_stmt
name|vm_page_t
name|bogus_page
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_offset_t
name|bogus_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bufspace
decl_stmt|,
name|maxbufspace
decl_stmt|,
name|vmiospace
decl_stmt|,
name|maxvmiobufspace
decl_stmt|,
name|bufmallocspace
decl_stmt|,
name|maxbufmallocspace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numdirtybuffers
decl_stmt|,
name|lodirtybuffers
decl_stmt|,
name|hidirtybuffers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|numfreebuffers
decl_stmt|,
name|lofreebuffers
decl_stmt|,
name|hifreebuffers
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|numdirtybuffers
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|numdirtybuffers
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|lodirtybuffers
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|lodirtybuffers
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|hidirtybuffers
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|hidirtybuffers
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|numfreebuffers
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|numfreebuffers
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|lofreebuffers
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|lofreebuffers
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|hifreebuffers
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|hifreebuffers
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|maxbufspace
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|maxbufspace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|bufspace
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|bufspace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|maxvmiobufspace
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|maxvmiobufspace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|vmiospace
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|vmiospace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|maxmallocbufspace
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|maxbufmallocspace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|bufmallocspace
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|bufmallocspace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument|bufhashhdr
argument_list|,
argument|buf
argument_list|)
name|bufhashtbl
index|[
name|BUFHSZ
index|]
operator|,
name|invalhash
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument|bqueues
argument_list|,
argument|buf
argument_list|)
name|bufqueues
index|[
name|BUFFER_QUEUES
index|]
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|int
name|vm_swap_size
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BUF_MAXUSE
value|24
end_define

begin_define
define|#
directive|define
name|VFS_BIO_NEED_ANY
value|1
end_define

begin_define
define|#
directive|define
name|VFS_BIO_NEED_LOWLIMIT
value|2
end_define

begin_define
define|#
directive|define
name|VFS_BIO_NEED_FREE
value|4
end_define

begin_comment
comment|/*  * Initialize buffer headers and related structures.  */
end_comment

begin_function
name|void
name|bufinit
parameter_list|()
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|bswlist
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|invalhash
argument_list|)
expr_stmt|;
comment|/* first, make a null hash table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUFHSZ
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|bufhashtbl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* next, make a null set of free lists */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUFFER_QUEUES
condition|;
name|i
operator|++
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|bufqueues
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* finally, initialize each buffer header and stick on empty q */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbuf
condition|;
name|i
operator|++
control|)
block|{
name|bp
operator|=
operator|&
name|buf
index|[
name|i
index|]
expr_stmt|;
name|bzero
argument_list|(
name|bp
argument_list|,
sizeof|sizeof
expr|*
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_INVAL
expr_stmt|;
comment|/* we're just an empty header */
name|bp
operator|->
name|b_dev
operator|=
name|NODEV
expr_stmt|;
name|bp
operator|->
name|b_rcred
operator|=
name|NOCRED
expr_stmt|;
name|bp
operator|->
name|b_wcred
operator|=
name|NOCRED
expr_stmt|;
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_EMPTY
expr_stmt|;
name|bp
operator|->
name|b_vnbufs
operator|.
name|le_next
operator|=
name|NOLIST
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_EMPTY
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|invalhash
argument_list|,
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
block|}
comment|/*  * maxbufspace is currently calculated to support all filesystem blocks  * to be 8K.  If you happen to use a 16K filesystem, the size of the buffer  * cache is still the same as it would be for 8K filesystems.  This  * keeps the size of the buffer cache "in check" for big block filesystems.  */
name|maxbufspace
operator|=
operator|(
name|nbuf
operator|+
literal|8
operator|)
operator|*
name|DFLTBSIZE
expr_stmt|;
comment|/*  * reserve 1/3 of the buffers for metadata (VDIR) which might not be VMIO'ed  */
name|maxvmiobufspace
operator|=
literal|2
operator|*
name|maxbufspace
operator|/
literal|3
expr_stmt|;
comment|/*  * Limit the amount of malloc memory since it is wired permanently into  * the kernel space.  Even though this is accounted for in the buffer  * allocation, we don't want the malloced region to grow uncontrolled.  * The malloc scheme improves memory utilization significantly on average  * (small) directories.  */
name|maxbufmallocspace
operator|=
name|maxbufspace
operator|/
literal|20
expr_stmt|;
comment|/*  * Remove the probability of deadlock conditions by limiting the  * number of dirty buffers.  */
name|hidirtybuffers
operator|=
name|nbuf
operator|/
literal|6
operator|+
literal|20
expr_stmt|;
name|lodirtybuffers
operator|=
name|nbuf
operator|/
literal|12
operator|+
literal|10
expr_stmt|;
name|numdirtybuffers
operator|=
literal|0
expr_stmt|;
name|lofreebuffers
operator|=
name|nbuf
operator|/
literal|18
operator|+
literal|5
expr_stmt|;
name|hifreebuffers
operator|=
literal|2
operator|*
name|lofreebuffers
expr_stmt|;
name|numfreebuffers
operator|=
name|nbuf
expr_stmt|;
name|bogus_offset
operator|=
name|kmem_alloc_pageable
argument_list|(
name|kernel_map
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|bogus_page
operator|=
name|vm_page_alloc
argument_list|(
name|kernel_object
argument_list|,
operator|(
operator|(
name|bogus_offset
operator|-
name|VM_MIN_KERNEL_ADDRESS
operator|)
operator|>>
name|PAGE_SHIFT
operator|)
argument_list|,
name|VM_ALLOC_NORMAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free the kva allocation for a buffer  * Must be called only at splbio or higher,  *  as this is the only locking for buffer_map.  */
end_comment

begin_function
specifier|static
name|void
name|bfreekva
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_kvasize
operator|==
literal|0
condition|)
return|return;
name|vm_map_delete
argument_list|(
name|buffer_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_kvabase
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_kvabase
operator|+
name|bp
operator|->
name|b_kvasize
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_kvasize
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove the buffer from the appropriate free list  */
end_comment

begin_function
name|void
name|bremfree
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_qindex
operator|!=
name|QUEUE_NONE
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bufqueues
index|[
name|bp
operator|->
name|b_qindex
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_NONE
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
name|panic
argument_list|(
literal|"bremfree: removing a buffer when not on a queue"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_INVAL
operator|)
operator|||
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_DELWRI
operator||
name|B_LOCKED
operator|)
operator|)
operator|==
literal|0
condition|)
operator|--
name|numfreebuffers
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a buffer with the specified data.  Look in the cache first.  */
end_comment

begin_function
name|int
name|bread
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|daddr_t
name|blkno
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|buf
modifier|*
modifier|*
name|bpp
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|getblk
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
comment|/* if not found in cache, do some I/O */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CACHE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|curproc
operator|!=
name|NULL
condition|)
name|curproc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_inblock
operator|++
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_READ
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_DONE
operator||
name|B_ERROR
operator||
name|B_INVAL
operator|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_rcred
operator|==
name|NOCRED
condition|)
block|{
if|if
condition|(
name|cred
operator|!=
name|NOCRED
condition|)
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_rcred
operator|=
name|cred
expr_stmt|;
block|}
name|vfs_busy_pages
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_STRATEGY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|biowait
argument_list|(
name|bp
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Operates like bread, but also starts asynchronous I/O on  * read-ahead blocks.  */
end_comment

begin_function
name|int
name|breadn
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|daddr_t
name|blkno
parameter_list|,
name|int
name|size
parameter_list|,
name|daddr_t
modifier|*
name|rablkno
parameter_list|,
name|int
modifier|*
name|rabsize
parameter_list|,
name|int
name|cnt
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|buf
modifier|*
modifier|*
name|bpp
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|rabp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|,
name|readwait
init|=
literal|0
decl_stmt|;
operator|*
name|bpp
operator|=
name|bp
operator|=
name|getblk
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* if not found in cache, do some I/O */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CACHE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|curproc
operator|!=
name|NULL
condition|)
name|curproc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_inblock
operator|++
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_READ
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_DONE
operator||
name|B_ERROR
operator||
name|B_INVAL
operator|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_rcred
operator|==
name|NOCRED
condition|)
block|{
if|if
condition|(
name|cred
operator|!=
name|NOCRED
condition|)
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_rcred
operator|=
name|cred
expr_stmt|;
block|}
name|vfs_busy_pages
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_STRATEGY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
operator|++
name|readwait
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
operator|,
name|rablkno
operator|++
operator|,
name|rabsize
operator|++
control|)
block|{
if|if
condition|(
name|inmem
argument_list|(
name|vp
argument_list|,
operator|*
name|rablkno
argument_list|)
condition|)
continue|continue;
name|rabp
operator|=
name|getblk
argument_list|(
name|vp
argument_list|,
operator|*
name|rablkno
argument_list|,
operator|*
name|rabsize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rabp
operator|->
name|b_flags
operator|&
name|B_CACHE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|curproc
operator|!=
name|NULL
condition|)
name|curproc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_inblock
operator|++
expr_stmt|;
name|rabp
operator|->
name|b_flags
operator||=
name|B_READ
operator||
name|B_ASYNC
expr_stmt|;
name|rabp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_DONE
operator||
name|B_ERROR
operator||
name|B_INVAL
operator|)
expr_stmt|;
if|if
condition|(
name|rabp
operator|->
name|b_rcred
operator|==
name|NOCRED
condition|)
block|{
if|if
condition|(
name|cred
operator|!=
name|NOCRED
condition|)
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|rabp
operator|->
name|b_rcred
operator|=
name|cred
expr_stmt|;
block|}
name|vfs_busy_pages
argument_list|(
name|rabp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_STRATEGY
argument_list|(
name|rabp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|brelse
argument_list|(
name|rabp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|readwait
condition|)
block|{
name|rv
operator|=
name|biowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write, release buffer on completion.  (Done by iodone  * if async.)  */
end_comment

begin_function
name|int
name|bwrite
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|oldflags
init|=
name|bp
operator|->
name|b_flags
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_INVAL
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
operator|)
condition|)
name|panic
argument_list|(
literal|"bwrite: buffer is not busy???"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_READ
operator||
name|B_DONE
operator||
name|B_ERROR
operator||
name|B_DELWRI
operator|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_WRITEINPROG
expr_stmt|;
if|if
condition|(
operator|(
name|oldflags
operator|&
name|B_DELWRI
operator|)
operator|==
name|B_DELWRI
condition|)
block|{
operator|--
name|numdirtybuffers
expr_stmt|;
name|reassignbuf
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|b_vp
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_vp
operator|->
name|v_numoutput
operator|++
expr_stmt|;
name|vfs_busy_pages
argument_list|(
name|bp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|curproc
operator|!=
name|NULL
condition|)
name|curproc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_oublock
operator|++
expr_stmt|;
name|VOP_STRATEGY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oldflags
operator|&
name|B_ASYNC
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|rtval
init|=
name|biowait
argument_list|(
name|bp
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldflags
operator|&
name|B_DELWRI
condition|)
block|{
name|reassignbuf
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|b_vp
argument_list|)
expr_stmt|;
block|}
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rtval
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vfs_bio_need_satisfy
parameter_list|(
name|void
parameter_list|)
block|{
operator|++
name|numfreebuffers
expr_stmt|;
if|if
condition|(
operator|!
name|needsbuffer
condition|)
return|return;
if|if
condition|(
name|numdirtybuffers
operator|<
name|lodirtybuffers
condition|)
block|{
name|needsbuffer
operator|&=
operator|~
operator|(
name|VFS_BIO_NEED_ANY
operator||
name|VFS_BIO_NEED_LOWLIMIT
operator|)
expr_stmt|;
block|}
else|else
block|{
name|needsbuffer
operator|&=
operator|~
name|VFS_BIO_NEED_ANY
expr_stmt|;
block|}
if|if
condition|(
name|numfreebuffers
operator|>=
name|hifreebuffers
condition|)
block|{
name|needsbuffer
operator|&=
operator|~
name|VFS_BIO_NEED_FREE
expr_stmt|;
block|}
name|wakeup
argument_list|(
operator|&
name|needsbuffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Delayed write. (Buffer is marked dirty).  */
end_comment

begin_function
name|void
name|bdwrite
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
operator|)
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"bdwrite: buffer is not busy"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_INVAL
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_TAPE
condition|)
block|{
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_READ
operator||
name|B_RELBUF
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_DONE
operator||
name|B_DELWRI
expr_stmt|;
name|reassignbuf
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|b_vp
argument_list|)
expr_stmt|;
operator|++
name|numdirtybuffers
expr_stmt|;
block|}
comment|/* 	 * This bmap keeps the system from needing to do the bmap later, 	 * perhaps when the system is attempting to do a sync.  Since it 	 * is likely that the indirect block -- or whatever other datastructure 	 * that the filesystem needs is still in memory now, it is a good 	 * thing to do this.  Note also, that if the pageout daemon is 	 * requesting a sync -- there might not be enough memory to do 	 * the bmap then...  So, this is important to do. 	 */
if|if
condition|(
name|bp
operator|->
name|b_lblkno
operator|==
name|bp
operator|->
name|b_blkno
condition|)
block|{
name|VOP_BMAP
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|,
name|bp
operator|->
name|b_lblkno
argument_list|,
name|NULL
argument_list|,
operator|&
name|bp
operator|->
name|b_blkno
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set the *dirty* buffer range based upon the VM system dirty pages. 	 */
name|vfs_setdirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * We need to do this here to satisfy the vnode_pager and the 	 * pageout daemon, so that it thinks that the pages have been 	 * "cleaned".  Note that since the pages are in a delayed write 	 * buffer -- the VFS layer "will" see that the pages get written 	 * out on the next sync, or perhaps the cluster will be completed. 	 */
name|vfs_clean_pages
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|numdirtybuffers
operator|>=
name|hidirtybuffers
condition|)
name|flushdirtybuffers
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Asynchronous write.  * Start output on a buffer, but do not wait for it to complete.  * The buffer is released when the output completes.  */
end_comment

begin_function
name|void
name|bawrite
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ASYNC
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Ordered write.  * Start output on a buffer, but only wait for it to complete if the  * output device cannot guarantee ordering in some other way.  Devices  * that can perform asynchronous ordered writes will set the B_ASYNC  * flag in their strategy routine.  * The buffer is released when the output completes.  */
end_comment

begin_function
name|int
name|bowrite
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
comment|/* 	 * XXX Add in B_ASYNC once the SCSI 	 *     layer can deal with ordered 	 *     writes properly. 	 */
name|bp
operator|->
name|b_flags
operator||=
name|B_ORDERED
expr_stmt|;
return|return
operator|(
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a buffer.  */
end_comment

begin_function
name|void
name|brelse
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CLUSTER
condition|)
block|{
name|relpbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* anyone need a "free" block? */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* anyone need this block? */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_WANTED
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_WANTED
operator||
name|B_AGE
operator|)
expr_stmt|;
name|wakeup
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_LOCKED
condition|)
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ERROR
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_NOCACHE
operator||
name|B_INVAL
operator||
name|B_ERROR
operator|)
operator|)
operator|||
operator|(
name|bp
operator|->
name|b_bufsize
operator|<=
literal|0
operator|)
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
condition|)
operator|--
name|numdirtybuffers
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_DELWRI
operator||
name|B_CACHE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
operator|)
operator|==
literal|0
operator|)
operator|&&
name|bp
operator|->
name|b_vp
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_bufsize
condition|)
name|allocbuf
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|brelvp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * VMIO buffer rundown.  It is not very necessary to keep a VMIO buffer 	 * constituted, so the B_INVAL flag is used to *invalidate* the buffer, 	 * but the VM object is kept around.  The B_NOCACHE flag is used to 	 * invalidate the pages in the VM object. 	 * 	 * If the buffer is a partially filled NFS buffer, keep it 	 * since invalidating it now will lose informatio.  The valid 	 * flags in the vm_pages have only DEV_BSIZE resolution but 	 * the b_validoff, b_validend fields have byte resolution. 	 * This can avoid unnecessary re-reads of the buffer. 	 * XXX this seems to cause performance problems. 	 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
operator|)
operator|&&
operator|!
operator|(
name|bp
operator|->
name|b_vp
operator|->
name|v_tag
operator|==
name|VT_NFS
operator|&&
name|bp
operator|->
name|b_vp
operator|->
name|v_type
operator|!=
name|VBLK
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|!=
literal|0
operator|)
ifdef|#
directive|ifdef
name|notdef
operator|&&
operator|(
name|bp
operator|->
name|b_vp
operator|->
name|v_tag
operator|!=
name|VT_NFS
operator|||
name|bp
operator|->
name|b_vp
operator|->
name|v_type
operator|==
name|VBLK
operator|||
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_NOCACHE
operator||
name|B_INVAL
operator||
name|B_ERROR
operator|)
operator|)
operator|||
name|bp
operator|->
name|b_validend
operator|==
literal|0
operator|||
operator|(
name|bp
operator|->
name|b_validoff
operator|==
literal|0
operator|&&
name|bp
operator|->
name|b_validend
operator|==
name|bp
operator|->
name|b_bufsize
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|vm_ooffset_t
name|foff
decl_stmt|;
name|vm_object_t
name|obj
decl_stmt|;
name|int
name|i
decl_stmt|,
name|resid
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|iototal
init|=
name|bp
operator|->
name|b_bufsize
decl_stmt|;
name|vp
operator|=
name|bp
operator|->
name|b_vp
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
operator|!
name|vp
condition|)
name|panic
argument_list|(
literal|"brelse: missing vp"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bp
operator|->
name|b_npages
condition|)
block|{
name|vm_pindex_t
name|poff
decl_stmt|;
name|obj
operator|=
operator|(
name|vm_object_t
operator|)
name|vp
operator|->
name|v_object
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VBLK
condition|)
name|foff
operator|=
operator|(
operator|(
name|vm_ooffset_t
operator|)
name|bp
operator|->
name|b_lblkno
operator|)
operator|<<
name|DEV_BSHIFT
expr_stmt|;
else|else
name|foff
operator|=
operator|(
name|vm_ooffset_t
operator|)
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
operator|*
name|bp
operator|->
name|b_lblkno
expr_stmt|;
name|poff
operator|=
name|OFF_TO_IDX
argument_list|(
name|foff
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|bogus_page
condition|)
block|{
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
name|poff
operator|+
name|i
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|panic
argument_list|(
literal|"brelse: page missing\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|=
name|m
expr_stmt|;
name|pmap_qenter
argument_list|(
name|trunc_page
argument_list|(
name|bp
operator|->
name|b_data
argument_list|)
argument_list|,
name|bp
operator|->
name|b_pages
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
block|}
name|resid
operator|=
name|IDX_TO_OFF
argument_list|(
name|m
operator|->
name|pindex
operator|+
literal|1
argument_list|)
operator|-
name|foff
expr_stmt|;
if|if
condition|(
name|resid
operator|>
name|iototal
condition|)
name|resid
operator|=
name|iototal
expr_stmt|;
if|if
condition|(
name|resid
operator|>
literal|0
condition|)
block|{
comment|/* 					 * Don't invalidate the page if the local machine has already 					 * modified it.  This is the lesser of two evils, and should 					 * be fixed. 					 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_NOCACHE
operator||
name|B_ERROR
operator|)
condition|)
block|{
name|vm_page_test_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|dirty
operator|==
literal|0
condition|)
block|{
name|vm_page_set_invalid
argument_list|(
name|m
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|foff
argument_list|,
name|resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|valid
operator|==
literal|0
condition|)
name|vm_page_protect
argument_list|(
name|m
argument_list|,
name|VM_PROT_NONE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|resid
operator|>=
name|PAGE_SIZE
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|valid
operator|&
name|VM_PAGE_BITS_ALL
operator|)
operator|!=
name|VM_PAGE_BITS_ALL
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|vm_page_is_valid
argument_list|(
name|m
argument_list|,
operator|(
operator|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
operator|)
operator|&
name|PAGE_MASK
operator|)
argument_list|,
name|resid
argument_list|)
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
expr_stmt|;
block|}
block|}
block|}
name|foff
operator|+=
name|resid
expr_stmt|;
name|iototal
operator|-=
name|resid
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_INVAL
operator||
name|B_RELBUF
operator|)
condition|)
name|vfs_vmio_release
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
name|bp
operator|->
name|b_qindex
operator|!=
name|QUEUE_NONE
condition|)
name|panic
argument_list|(
literal|"brelse: free buffer onto another queue???"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* enqueue */
comment|/* buffers with no memory */
if|if
condition|(
name|bp
operator|->
name|b_bufsize
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
expr_stmt|;
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_EMPTY
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_EMPTY
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|invalhash
argument_list|,
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|NODEV
expr_stmt|;
comment|/* 		 * Get rid of the kva allocation *now* 		 */
name|bfreekva
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* buffers with junk contents */
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_ERROR
operator||
name|B_INVAL
operator||
name|B_NOCACHE
operator||
name|B_RELBUF
operator|)
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
expr_stmt|;
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_AGE
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_AGE
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|invalhash
argument_list|,
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|NODEV
expr_stmt|;
comment|/* buffers that are locked */
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_LOCKED
condition|)
block|{
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_LOCKED
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LOCKED
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
comment|/* buffers with stale but valid contents */
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_AGE
condition|)
block|{
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_AGE
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_AGE
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
comment|/* buffers with valid and quite potentially reuseable contents */
block|}
else|else
block|{
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_LRU
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LRU
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_INVAL
operator|)
operator|||
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_LOCKED
operator||
name|B_DELWRI
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
condition|)
block|{
operator|--
name|numdirtybuffers
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_DELWRI
expr_stmt|;
block|}
name|vfs_bio_need_satisfy
argument_list|()
expr_stmt|;
block|}
comment|/* unlock */
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_ORDERED
operator||
name|B_WANTED
operator||
name|B_BUSY
operator||
name|B_ASYNC
operator||
name|B_NOCACHE
operator||
name|B_AGE
operator||
name|B_RELBUF
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Release a buffer.  */
end_comment

begin_function
name|void
name|bqrelse
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* anyone need this block? */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_WANTED
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_WANTED
operator||
name|B_AGE
operator|)
expr_stmt|;
name|wakeup
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
name|bp
operator|->
name|b_qindex
operator|!=
name|QUEUE_NONE
condition|)
name|panic
argument_list|(
literal|"bqrelse: free buffer onto another queue???"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_LOCKED
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_LOCKED
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LOCKED
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
comment|/* buffers with stale but valid contents */
block|}
else|else
block|{
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_LRU
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LRU
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_LOCKED
operator||
name|B_DELWRI
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|vfs_bio_need_satisfy
argument_list|()
expr_stmt|;
block|}
comment|/* unlock */
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_ORDERED
operator||
name|B_WANTED
operator||
name|B_BUSY
operator||
name|B_ASYNC
operator||
name|B_NOCACHE
operator||
name|B_AGE
operator||
name|B_RELBUF
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vfs_vmio_release
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
expr_stmt|;
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 		 * We don't mess with busy pages, it is 		 * the responsibility of the process that 		 * busied the pages to deal with them. 		 */
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
operator|)
operator|||
operator|(
name|m
operator|->
name|busy
operator|!=
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|m
operator|->
name|wire_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_WANTED
condition|)
block|{
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_WANTED
expr_stmt|;
name|wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * If this is an async free -- we cannot place 			 * pages onto the cache queue.  If it is an 			 * async free, then we don't modify any queues. 			 * This is probably in error (for perf reasons), 			 * and we will eventually need to build 			 * a more complete infrastructure to support I/O 			 * rundown. 			 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ASYNC
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * In the case of sync buffer frees, we can do pretty much 			 * anything to any of the memory queues.  Specifically, 			 * the cache queue is okay to be modified. 			 */
if|if
condition|(
name|m
operator|->
name|valid
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|dirty
operator|==
literal|0
condition|)
name|vm_page_test_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 					 * this keeps pressure off of the process memory 					 */
if|if
condition|(
name|m
operator|->
name|dirty
operator|==
literal|0
operator|&&
name|m
operator|->
name|hold_count
operator|==
literal|0
condition|)
name|vm_page_cache
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|else
name|vm_page_deactivate
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|hold_count
operator|==
literal|0
condition|)
block|{
name|vm_page_protect
argument_list|(
name|m
argument_list|,
name|VM_PROT_NONE
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * If async, then at least we clear the 				 * act_count. 				 */
name|m
operator|->
name|act_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|bufspace
operator|-=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
name|vmiospace
operator|-=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
name|pmap_qremove
argument_list|(
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
argument_list|)
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_npages
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_VMIO
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_vp
condition|)
name|brelvp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see if a block is currently memory resident.  */
end_comment

begin_function
name|struct
name|buf
modifier|*
name|gbincore
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|daddr_t
name|blkno
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|bufhashhdr
modifier|*
name|bh
decl_stmt|;
name|bh
operator|=
name|BUFHASH
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bh
operator|->
name|lh_first
expr_stmt|;
comment|/* Search hash chain */
while|while
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
comment|/* hit */
if|if
condition|(
name|bp
operator|->
name|b_vp
operator|==
name|vp
operator|&&
name|bp
operator|->
name|b_lblkno
operator|==
name|blkno
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_INVAL
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|bp
operator|=
name|bp
operator|->
name|b_hash
operator|.
name|le_next
expr_stmt|;
block|}
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * this routine implements clustered async writes for  * clearing out B_DELWRI buffers...  This is much better  * than the old way of writing only one buffer at a time.  */
end_comment

begin_function
name|int
name|vfs_bio_awrite
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|daddr_t
name|lblkno
init|=
name|bp
operator|->
name|b_lblkno
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|bp
operator|->
name|b_vp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|ncl
decl_stmt|;
name|struct
name|buf
modifier|*
name|bpa
decl_stmt|;
name|int
name|nwritten
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * right now we support clustered writing only to regular files 	 */
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_mount
operator|!=
literal|0
operator|)
operator|&&
comment|/* Only on nodes that have the size info */
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_CLUSTEROK
operator||
name|B_INVAL
operator|)
operator|)
operator|==
name|B_CLUSTEROK
condition|)
block|{
name|int
name|size
decl_stmt|;
name|int
name|maxcl
decl_stmt|;
name|size
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
expr_stmt|;
name|maxcl
operator|=
name|MAXPHYS
operator|/
name|size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|maxcl
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bpa
operator|=
name|gbincore
argument_list|(
name|vp
argument_list|,
name|lblkno
operator|+
name|i
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|bpa
operator|->
name|b_flags
operator|&
operator|(
name|B_BUSY
operator||
name|B_DELWRI
operator||
name|B_CLUSTEROK
operator||
name|B_INVAL
operator|)
operator|)
operator|==
operator|(
name|B_DELWRI
operator||
name|B_CLUSTEROK
operator|)
operator|)
operator|&&
operator|(
name|bpa
operator|->
name|b_bufsize
operator|==
name|size
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|bpa
operator|->
name|b_blkno
operator|==
name|bpa
operator|->
name|b_lblkno
operator|)
operator|||
operator|(
name|bpa
operator|->
name|b_blkno
operator|!=
name|bp
operator|->
name|b_blkno
operator|+
operator|(
operator|(
name|i
operator|*
name|size
operator|)
operator|>>
name|DEV_BSHIFT
operator|)
operator|)
condition|)
break|break;
block|}
else|else
block|{
break|break;
block|}
block|}
name|ncl
operator|=
name|i
expr_stmt|;
comment|/* 		 * this is a possible cluster write 		 */
if|if
condition|(
name|ncl
operator|!=
literal|1
condition|)
block|{
name|nwritten
operator|=
name|cluster_wbuild
argument_list|(
name|vp
argument_list|,
name|size
argument_list|,
name|lblkno
argument_list|,
name|ncl
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|nwritten
return|;
block|}
block|}
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * default (old) behavior, writing out only one block 	 */
name|bp
operator|->
name|b_flags
operator||=
name|B_BUSY
operator||
name|B_ASYNC
expr_stmt|;
name|nwritten
operator|=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|nwritten
return|;
block|}
end_function

begin_comment
comment|/*  * Find a buffer header which is available for use.  */
end_comment

begin_function
specifier|static
name|struct
name|buf
modifier|*
name|getnewbuf
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|int
name|slpflag
parameter_list|,
name|int
name|slptimeo
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|maxsize
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|nbyteswritten
init|=
literal|0
decl_stmt|;
name|vm_offset_t
name|addr
decl_stmt|;
specifier|static
name|int
name|writerecursion
init|=
literal|0
decl_stmt|;
name|start
label|:
if|if
condition|(
name|bufspace
operator|>=
name|maxbufspace
condition|)
goto|goto
name|trytofreespace
goto|;
comment|/* can we constitute a new buffer? */
if|if
condition|(
operator|(
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_EMPTY
index|]
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
name|bp
operator|->
name|b_qindex
operator|!=
name|QUEUE_EMPTY
condition|)
name|panic
argument_list|(
literal|"getnewbuf: inconsistent EMPTY queue, qindex=%d"
argument_list|,
name|bp
operator|->
name|b_qindex
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bp
operator|->
name|b_flags
operator||=
name|B_BUSY
expr_stmt|;
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|fillbuf
goto|;
block|}
name|trytofreespace
label|:
comment|/* 	 * We keep the file I/O from hogging metadata I/O 	 * This is desirable because file data is cached in the 	 * VM/Buffer cache even if a buffer is freed. 	 */
if|if
condition|(
operator|(
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_AGE
index|]
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
name|bp
operator|->
name|b_qindex
operator|!=
name|QUEUE_AGE
condition|)
name|panic
argument_list|(
literal|"getnewbuf: inconsistent AGE queue, qindex=%d"
argument_list|,
name|bp
operator|->
name|b_qindex
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|(
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LRU
index|]
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
name|bp
operator|->
name|b_qindex
operator|!=
name|QUEUE_LRU
condition|)
name|panic
argument_list|(
literal|"getnewbuf: inconsistent LRU queue, qindex=%d"
argument_list|,
name|bp
operator|->
name|b_qindex
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|bp
condition|)
block|{
comment|/* wait for a free buffer of any kind */
name|needsbuffer
operator||=
name|VFS_BIO_NEED_ANY
expr_stmt|;
do|do
name|tsleep
argument_list|(
operator|&
name|needsbuffer
argument_list|,
operator|(
name|PRIBIO
operator|+
literal|1
operator|)
operator||
name|slpflag
argument_list|,
literal|"newbuf"
argument_list|,
name|slptimeo
argument_list|)
expr_stmt|;
do|while
condition|(
name|needsbuffer
operator|&
name|VFS_BIO_NEED_ANY
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
condition|)
block|{
name|panic
argument_list|(
literal|"getnewbuf: busy buffer on free list\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * We are fairly aggressive about freeing VMIO buffers, but since 	 * the buffering is intact without buffer headers, there is not 	 * much loss.  We gain by maintaining non-VMIOed metadata in buffers. 	 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_qindex
operator|==
name|QUEUE_LRU
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_usecount
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
operator|)
operator|==
literal|0
operator|||
operator|(
name|vmiospace
operator|<
name|maxvmiobufspace
operator|)
condition|)
block|{
operator|--
name|bp
operator|->
name|b_usecount
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LRU
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LRU
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LRU
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
goto|goto
name|start
goto|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LRU
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if we are a delayed write, convert to an async write */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_DELWRI
operator||
name|B_INVAL
operator|)
operator|)
operator|==
name|B_DELWRI
condition|)
block|{
if|if
condition|(
name|writerecursion
operator|>
literal|0
condition|)
block|{
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_AGE
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|bp
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
break|break;
name|bp
operator|=
name|TAILQ_NEXT
argument_list|(
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LRU
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|bp
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
break|break;
name|bp
operator|=
name|TAILQ_NEXT
argument_list|(
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"getnewbuf: cannot get buffer, infinite recursion failure"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|++
name|writerecursion
expr_stmt|;
name|nbyteswritten
operator|+=
name|vfs_bio_awrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
operator|--
name|writerecursion
expr_stmt|;
if|if
condition|(
operator|!
name|slpflag
operator|&&
operator|!
name|slptimeo
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
goto|goto
name|start
goto|;
block|}
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_WANTED
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_WANTED
expr_stmt|;
name|wakeup
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_BUSY
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ASYNC
expr_stmt|;
name|vfs_vmio_release
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_vp
condition|)
name|brelvp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|fillbuf
label|:
comment|/* we are not free, nor do we contain interesting data */
if|if
condition|(
name|bp
operator|->
name|b_rcred
operator|!=
name|NOCRED
condition|)
block|{
name|crfree
argument_list|(
name|bp
operator|->
name|b_rcred
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_rcred
operator|=
name|NOCRED
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_wcred
operator|!=
name|NOCRED
condition|)
block|{
name|crfree
argument_list|(
name|bp
operator|->
name|b_wcred
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_wcred
operator|=
name|NOCRED
expr_stmt|;
block|}
name|LIST_REMOVE
argument_list|(
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|invalhash
argument_list|,
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bufsize
condition|)
block|{
name|allocbuf
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|NODEV
expr_stmt|;
name|bp
operator|->
name|b_vp
operator|=
name|NULL
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|bp
operator|->
name|b_lblkno
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_npages
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_dirtyoff
operator|=
name|bp
operator|->
name|b_dirtyend
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_validoff
operator|=
name|bp
operator|->
name|b_validend
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_usecount
operator|=
literal|4
expr_stmt|;
name|maxsize
operator|=
operator|(
name|maxsize
operator|+
name|PAGE_MASK
operator|)
operator|&
operator|~
name|PAGE_MASK
expr_stmt|;
comment|/* 	 * we assume that buffer_map is not at address 0 	 */
name|addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|maxsize
operator|!=
name|bp
operator|->
name|b_kvasize
condition|)
block|{
name|bfreekva
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * See if we have buffer kva space 		 */
if|if
condition|(
name|vm_map_findspace
argument_list|(
name|buffer_map
argument_list|,
name|vm_map_min
argument_list|(
name|buffer_map
argument_list|)
argument_list|,
name|maxsize
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|trytofreespace
goto|;
block|}
block|}
comment|/* 	 * See if we are below are allocated minimum 	 */
if|if
condition|(
name|bufspace
operator|>=
operator|(
name|maxbufspace
operator|+
name|nbyteswritten
operator|)
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|trytofreespace
goto|;
block|}
comment|/* 	 * create a map entry for the buffer -- in essence 	 * reserving the kva space. 	 */
if|if
condition|(
name|addr
condition|)
block|{
name|vm_map_insert
argument_list|(
name|buffer_map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|addr
argument_list|,
name|addr
operator|+
name|maxsize
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|MAP_NOFAULT
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_kvabase
operator|=
operator|(
name|caddr_t
operator|)
name|addr
expr_stmt|;
name|bp
operator|->
name|b_kvasize
operator|=
name|maxsize
expr_stmt|;
block|}
name|bp
operator|->
name|b_data
operator|=
name|bp
operator|->
name|b_kvabase
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|waitfreebuffers
parameter_list|(
name|int
name|slpflag
parameter_list|,
name|int
name|slptimeo
parameter_list|)
block|{
while|while
condition|(
name|numfreebuffers
operator|<
name|hifreebuffers
condition|)
block|{
name|flushdirtybuffers
argument_list|(
name|slpflag
argument_list|,
name|slptimeo
argument_list|)
expr_stmt|;
if|if
condition|(
name|numfreebuffers
operator|<
name|hifreebuffers
condition|)
break|break;
name|needsbuffer
operator||=
name|VFS_BIO_NEED_FREE
expr_stmt|;
if|if
condition|(
name|tsleep
argument_list|(
operator|&
name|needsbuffer
argument_list|,
name|PRIBIO
operator||
name|slpflag
argument_list|,
literal|"biofre"
argument_list|,
name|slptimeo
argument_list|)
condition|)
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|flushdirtybuffers
parameter_list|(
name|int
name|slpflag
parameter_list|,
name|int
name|slptimeo
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
specifier|static
name|pid_t
name|flushing
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|flushing
condition|)
block|{
if|if
condition|(
name|flushing
operator|==
name|curproc
operator|->
name|p_pid
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|flushing
condition|)
block|{
if|if
condition|(
name|tsleep
argument_list|(
operator|&
name|flushing
argument_list|,
name|PRIBIO
operator||
name|slpflag
argument_list|,
literal|"biofls"
argument_list|,
name|slptimeo
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|flushing
operator|=
name|curproc
operator|->
name|p_pid
expr_stmt|;
while|while
condition|(
name|numdirtybuffers
operator|>
name|lodirtybuffers
condition|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|needsbuffer
operator||=
name|VFS_BIO_NEED_LOWLIMIT
expr_stmt|;
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_AGE
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LRU
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|bp
operator|&&
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|bp
operator|=
name|TAILQ_NEXT
argument_list|(
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|vfs_bio_awrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|flushing
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|flushing
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see if a block is currently memory resident.  */
end_comment

begin_function
name|struct
name|buf
modifier|*
name|incore
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|daddr_t
name|blkno
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
name|bp
operator|=
name|gbincore
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if no I/O is needed to access the  * associated VM object.  This is like incore except  * it also hunts around in the VM system for the data.  */
end_comment

begin_function
name|int
name|inmem
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|daddr_t
name|blkno
parameter_list|)
block|{
name|vm_object_t
name|obj
decl_stmt|;
name|vm_offset_t
name|toff
decl_stmt|,
name|tinc
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|vm_ooffset_t
name|off
decl_stmt|;
if|if
condition|(
name|incore
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_object
operator|==
name|NULL
operator|)
operator|||
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|VVMIO
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|obj
operator|=
name|vp
operator|->
name|v_object
expr_stmt|;
name|tinc
operator|=
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|tinc
operator|>
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
condition|)
name|tinc
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
expr_stmt|;
name|off
operator|=
name|blkno
operator|*
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
expr_stmt|;
for|for
control|(
name|toff
operator|=
literal|0
init|;
name|toff
operator|<
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
condition|;
name|toff
operator|+=
name|tinc
control|)
block|{
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|off
operator|+
name|toff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|vm_page_is_valid
argument_list|(
name|m
argument_list|,
call|(
name|vm_offset_t
call|)
argument_list|(
name|toff
operator|+
name|off
argument_list|)
argument_list|,
name|tinc
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * now we set the dirty range for the buffer --  * for NFS -- if the file is mapped and pages have  * been written to, let it know.  We want the  * entire range of the buffer to be marked dirty if  * any of the pages have been written to for consistancy  * with the b_validoff, b_validend set in the nfs write  * code, and used by the nfs read code.  */
end_comment

begin_function
specifier|static
name|void
name|vfs_setdirty
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|vm_offset_t
name|boffset
decl_stmt|,
name|offset
decl_stmt|;
comment|/* 	 * We qualify the scan for modified pages on whether the 	 * object has been flushed yet.  The OBJ_WRITEABLE flag 	 * is not cleared simply by protecting pages off. 	 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
operator|)
operator|&&
operator|(
operator|(
name|object
operator|=
name|bp
operator|->
name|b_pages
index|[
literal|0
index|]
operator|->
name|object
operator|)
operator|->
name|flags
operator|&
operator|(
name|OBJ_WRITEABLE
operator||
name|OBJ_CLEANING
operator|)
operator|)
condition|)
block|{
comment|/* 		 * test the pages to see if they have been modified directly 		 * by users through the VM system. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
name|vm_page_test_dirty
argument_list|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * scan forwards for the first page modified 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|->
name|dirty
condition|)
block|{
break|break;
block|}
block|}
name|boffset
operator|=
operator|(
name|i
operator|<<
name|PAGE_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|boffset
operator|<
name|bp
operator|->
name|b_dirtyoff
condition|)
block|{
name|bp
operator|->
name|b_dirtyoff
operator|=
name|boffset
expr_stmt|;
block|}
comment|/* 		 * scan backwards for the last page modified 		 */
for|for
control|(
name|i
operator|=
name|bp
operator|->
name|b_npages
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|->
name|dirty
condition|)
block|{
break|break;
block|}
block|}
name|boffset
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
name|offset
operator|=
name|boffset
operator|+
name|bp
operator|->
name|b_pages
index|[
literal|0
index|]
operator|->
name|pindex
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|object
operator|->
name|size
condition|)
name|boffset
operator|=
name|object
operator|->
name|size
operator|-
name|bp
operator|->
name|b_pages
index|[
literal|0
index|]
operator|->
name|pindex
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_dirtyend
operator|<
operator|(
name|boffset
operator|<<
name|PAGE_SHIFT
operator|)
condition|)
name|bp
operator|->
name|b_dirtyend
operator|=
operator|(
name|boffset
operator|<<
name|PAGE_SHIFT
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get a block given a specified block and offset into a file/device.  */
end_comment

begin_function
name|struct
name|buf
modifier|*
name|getblk
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|daddr_t
name|blkno
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|slpflag
parameter_list|,
name|int
name|slptimeo
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|bufhashhdr
modifier|*
name|bh
decl_stmt|;
name|int
name|maxsize
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_mount
condition|)
block|{
name|maxsize
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
expr_stmt|;
comment|/* 		 * This happens on mount points. 		 */
if|if
condition|(
name|maxsize
operator|<
name|size
condition|)
name|maxsize
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
name|maxsize
operator|=
name|size
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
name|size
operator|>
name|MAXBSIZE
condition|)
name|panic
argument_list|(
literal|"getblk: size(%d)> MAXBSIZE(%d)\n"
argument_list|,
name|size
argument_list|,
name|MAXBSIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|loop
label|:
if|if
condition|(
name|numfreebuffers
operator|<
name|lofreebuffers
condition|)
block|{
name|waitfreebuffers
argument_list|(
name|slpflag
argument_list|,
name|slptimeo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bp
operator|=
name|gbincore
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_WANTED
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_usecount
operator|<
name|BUF_MAXUSE
condition|)
operator|++
name|bp
operator|->
name|b_usecount
expr_stmt|;
if|if
condition|(
operator|!
name|tsleep
argument_list|(
name|bp
argument_list|,
operator|(
name|PRIBIO
operator|+
literal|1
operator|)
operator||
name|slpflag
argument_list|,
literal|"getblk"
argument_list|,
name|slptimeo
argument_list|)
condition|)
goto|goto
name|loop
goto|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|buf
operator|*
operator|)
name|NULL
return|;
block|}
name|bp
operator|->
name|b_flags
operator||=
name|B_BUSY
operator||
name|B_CACHE
expr_stmt|;
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * check for size inconsistancies (note that they shouldn't 		 * happen but do when filesystems don't handle the size changes 		 * correctly.) We are conservative on metadata and don't just 		 * extend the buffer but write and re-constitute it. 		 */
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|!=
name|size
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
operator|)
operator|&&
operator|(
name|size
operator|<=
name|bp
operator|->
name|b_kvasize
operator|)
condition|)
block|{
name|allocbuf
argument_list|(
name|bp
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_NOCACHE
expr_stmt|;
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
block|}
if|if
condition|(
name|bp
operator|->
name|b_usecount
operator|<
name|BUF_MAXUSE
condition|)
operator|++
name|bp
operator|->
name|b_usecount
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
else|else
block|{
name|vm_object_t
name|obj
decl_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|getnewbuf
argument_list|(
name|vp
argument_list|,
name|slpflag
argument_list|,
name|slptimeo
argument_list|,
name|size
argument_list|,
name|maxsize
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|slpflag
operator|||
name|slptimeo
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
goto|goto
name|loop
goto|;
block|}
comment|/* 		 * This code is used to make sure that a buffer is not 		 * created while the getnewbuf routine is blocked. 		 * Normally the vnode is locked so this isn't a problem. 		 * VBLK type I/O requests, however, don't lock the vnode. 		 */
if|if
condition|(
operator|!
name|VOP_ISLOCKED
argument_list|(
name|vp
argument_list|)
operator|&&
name|gbincore
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|)
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
comment|/* 		 * Insert the buffer into the hash, so that it can 		 * be found by incore. 		 */
name|bp
operator|->
name|b_blkno
operator|=
name|bp
operator|->
name|b_lblkno
operator|=
name|blkno
expr_stmt|;
name|bgetvp
argument_list|(
name|vp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
name|bh
operator|=
name|BUFHASH
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|bh
argument_list|,
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|obj
operator|=
name|vp
operator|->
name|v_object
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|VVMIO
operator|)
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
operator|(
name|B_VMIO
operator||
name|B_CACHE
operator|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VFS_BIO_DEBUG
argument_list|)
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VBLK
condition|)
name|printf
argument_list|(
literal|"getblk: vmioing file type %d???\n"
argument_list|,
name|vp
operator|->
name|v_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_VMIO
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|allocbuf
argument_list|(
name|bp
argument_list|,
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
comment|/* 		 * 1024byte/sector support 		 */
define|#
directive|define
name|B_XXX2
value|0x8000000
if|if
condition|(
name|vp
operator|->
name|v_flag
operator|&
literal|0x10000
condition|)
name|bp
operator|->
name|b_flags
operator||=
name|B_XXX2
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|bp
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get an empty, disassociated buffer of given size.  */
end_comment

begin_function
name|struct
name|buf
modifier|*
name|geteblk
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|getnewbuf
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|size
argument_list|,
name|MAXBSIZE
argument_list|)
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|allocbuf
argument_list|(
name|bp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This code constitutes the buffer memory from either anonymous system  * memory (in the case of non-VMIO operations) or from an associated  * VM object (in the case of VMIO operations).  *  * Note that this code is tricky, and has many complications to resolve  * deadlock or inconsistant data situations.  Tread lightly!!!  *  * Modify the length of a buffer's underlying buffer storage without  * destroying information (unless, of course the buffer is shrinking).  */
end_comment

begin_function
name|int
name|allocbuf
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|newbsize
decl_stmt|,
name|mbsize
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
operator|)
condition|)
name|panic
argument_list|(
literal|"allocbuf: buffer not busy"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_kvasize
operator|<
name|size
condition|)
name|panic
argument_list|(
literal|"allocbuf: buffer too small"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
operator|)
operator|==
literal|0
condition|)
block|{
name|caddr_t
name|origbuf
decl_stmt|;
name|int
name|origbufsize
decl_stmt|;
comment|/* 		 * Just get anonymous memory from the kernel 		 */
name|mbsize
operator|=
operator|(
name|size
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|DEV_BSIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_B_MALLOC
argument_list|)
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_MALLOC
condition|)
name|newbsize
operator|=
name|mbsize
expr_stmt|;
else|else
endif|#
directive|endif
name|newbsize
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|newbsize
operator|<
name|bp
operator|->
name|b_bufsize
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_B_MALLOC
argument_list|)
comment|/* 			 * malloced buffers are not shrunk 			 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_MALLOC
condition|)
block|{
if|if
condition|(
name|newbsize
condition|)
block|{
name|bp
operator|->
name|b_bcount
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|M_BIOBUF
argument_list|)
expr_stmt|;
name|bufspace
operator|-=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
name|bufmallocspace
operator|-=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
name|bp
operator|->
name|b_data
operator|=
name|bp
operator|->
name|b_kvabase
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_MALLOC
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
endif|#
directive|endif
name|vm_hold_free_pages
argument_list|(
name|bp
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
operator|+
name|newbsize
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
operator|+
name|bp
operator|->
name|b_bufsize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newbsize
operator|>
name|bp
operator|->
name|b_bufsize
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_B_MALLOC
argument_list|)
comment|/* 			 * We only use malloced memory on the first allocation. 			 * and revert to page-allocated memory when the buffer grows. 			 */
if|if
condition|(
operator|(
name|bufmallocspace
operator|<
name|maxbufmallocspace
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_bufsize
operator|==
literal|0
operator|)
operator|&&
operator|(
name|mbsize
operator|<=
name|PAGE_SIZE
operator|/
literal|2
operator|)
condition|)
block|{
name|bp
operator|->
name|b_data
operator|=
name|malloc
argument_list|(
name|mbsize
argument_list|,
name|M_BIOBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
name|mbsize
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|size
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_MALLOC
expr_stmt|;
name|bufspace
operator|+=
name|mbsize
expr_stmt|;
name|bufmallocspace
operator|+=
name|mbsize
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
name|origbuf
operator|=
name|NULL
expr_stmt|;
name|origbufsize
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_B_MALLOC
argument_list|)
comment|/* 			 * If the buffer is growing on it's other-than-first allocation, 			 * then we revert to the page-allocation scheme. 			 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_MALLOC
condition|)
block|{
name|origbuf
operator|=
name|bp
operator|->
name|b_data
expr_stmt|;
name|origbufsize
operator|=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
name|bp
operator|->
name|b_data
operator|=
name|bp
operator|->
name|b_kvabase
expr_stmt|;
name|bufspace
operator|-=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
name|bufmallocspace
operator|-=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_MALLOC
expr_stmt|;
name|newbsize
operator|=
name|round_page
argument_list|(
name|newbsize
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|vm_hold_load_pages
argument_list|(
name|bp
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
operator|+
name|bp
operator|->
name|b_bufsize
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
operator|+
name|newbsize
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_B_MALLOC
argument_list|)
if|if
condition|(
name|origbuf
condition|)
block|{
name|bcopy
argument_list|(
name|origbuf
argument_list|,
name|bp
operator|->
name|b_data
argument_list|,
name|origbufsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|origbuf
argument_list|,
name|M_BIOBUF
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|vm_page_t
name|m
decl_stmt|;
name|int
name|desiredpages
decl_stmt|;
name|newbsize
operator|=
operator|(
name|size
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|DEV_BSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|desiredpages
operator|=
operator|(
name|round_page
argument_list|(
name|newbsize
argument_list|)
operator|>>
name|PAGE_SHIFT
operator|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_B_MALLOC
argument_list|)
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_MALLOC
condition|)
name|panic
argument_list|(
literal|"allocbuf: VMIO buffer can't be malloced"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|newbsize
operator|<
name|bp
operator|->
name|b_bufsize
condition|)
block|{
if|if
condition|(
name|desiredpages
operator|<
name|bp
operator|->
name|b_npages
condition|)
block|{
for|for
control|(
name|i
operator|=
name|desiredpages
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
comment|/* 					 * the page is not freed here -- it 					 * is the responsibility of vnode_pager_setsize 					 */
name|m
operator|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
if|if
condition|(
name|m
operator|==
name|bogus_page
condition|)
name|panic
argument_list|(
literal|"allocbuf: bogus page found"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
operator|)
operator|||
operator|(
name|m
operator|->
name|busy
operator|!=
literal|0
operator|)
condition|)
block|{
name|m
operator|->
name|flags
operator||=
name|PG_WANTED
expr_stmt|;
name|tsleep
argument_list|(
name|m
argument_list|,
name|PVM
argument_list|,
literal|"biodep"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|pmap_qremove
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|trunc_page
argument_list|(
name|bp
operator|->
name|b_data
argument_list|)
operator|+
operator|(
name|desiredpages
operator|<<
name|PAGE_SHIFT
operator|)
argument_list|,
operator|(
name|bp
operator|->
name|b_npages
operator|-
name|desiredpages
operator|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_npages
operator|=
name|desiredpages
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|newbsize
operator|>
name|bp
operator|->
name|b_bufsize
condition|)
block|{
name|vm_object_t
name|obj
decl_stmt|;
name|vm_offset_t
name|tinc
decl_stmt|,
name|toff
decl_stmt|;
name|vm_ooffset_t
name|off
decl_stmt|;
name|vm_pindex_t
name|objoff
decl_stmt|;
name|int
name|pageindex
decl_stmt|,
name|curbpnpages
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|bsize
decl_stmt|;
name|vp
operator|=
name|bp
operator|->
name|b_vp
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VBLK
condition|)
name|bsize
operator|=
name|DEV_BSIZE
expr_stmt|;
else|else
name|bsize
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_npages
operator|<
name|desiredpages
condition|)
block|{
name|obj
operator|=
name|vp
operator|->
name|v_object
expr_stmt|;
name|tinc
operator|=
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|tinc
operator|>
name|bsize
condition|)
name|tinc
operator|=
name|bsize
expr_stmt|;
name|off
operator|=
operator|(
name|vm_ooffset_t
operator|)
name|bp
operator|->
name|b_lblkno
operator|*
name|bsize
expr_stmt|;
name|curbpnpages
operator|=
name|bp
operator|->
name|b_npages
expr_stmt|;
name|doretry
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_CACHE
expr_stmt|;
name|bp
operator|->
name|b_validoff
operator|=
name|bp
operator|->
name|b_validend
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|toff
operator|=
literal|0
init|;
name|toff
operator|<
name|newbsize
condition|;
name|toff
operator|+=
name|tinc
control|)
block|{
name|int
name|bytesinpage
decl_stmt|;
name|pageindex
operator|=
name|toff
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|objoff
operator|=
name|OFF_TO_IDX
argument_list|(
name|off
operator|+
name|toff
argument_list|)
expr_stmt|;
if|if
condition|(
name|pageindex
operator|<
name|curbpnpages
condition|)
block|{
name|m
operator|=
name|bp
operator|->
name|b_pages
index|[
name|pageindex
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|VFS_BIO_DIAG
if|if
condition|(
name|m
operator|->
name|pindex
operator|!=
name|objoff
condition|)
name|panic
argument_list|(
literal|"allocbuf: page changed offset??!!!?"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bytesinpage
operator|=
name|tinc
expr_stmt|;
if|if
condition|(
name|tinc
operator|>
operator|(
name|newbsize
operator|-
name|toff
operator|)
condition|)
name|bytesinpage
operator|=
name|newbsize
operator|-
name|toff
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CACHE
condition|)
name|vfs_buf_set_valid
argument_list|(
name|bp
argument_list|,
name|off
argument_list|,
name|toff
argument_list|,
name|bytesinpage
argument_list|,
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
name|objoff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|m
operator|=
name|vm_page_alloc
argument_list|(
name|obj
argument_list|,
name|objoff
argument_list|,
name|VM_ALLOC_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|VM_WAIT
expr_stmt|;
goto|goto
name|doretry
goto|;
block|}
comment|/* 						 * Normally it is unwise to clear PG_BUSY without 						 * PAGE_WAKEUP -- but it is okay here, as there is 						 * no chance for blocking between here and vm_page_alloc 						 */
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_BUSY
expr_stmt|;
name|vm_page_wire
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_CACHE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
condition|)
block|{
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
condition|)
block|{
name|m
operator|->
name|flags
operator||=
name|PG_WANTED
expr_stmt|;
name|tsleep
argument_list|(
name|m
argument_list|,
name|PVM
argument_list|,
literal|"pgtblk"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|doretry
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|curproc
operator|!=
name|pageproc
operator|)
operator|&&
operator|(
operator|(
name|m
operator|->
name|queue
operator|-
name|m
operator|->
name|pc
operator|)
operator|==
name|PQ_CACHE
operator|)
operator|&&
operator|(
operator|(
name|cnt
operator|.
name|v_free_count
operator|+
name|cnt
operator|.
name|v_cache_count
operator|)
operator|<
operator|(
name|cnt
operator|.
name|v_free_min
operator|+
name|cnt
operator|.
name|v_cache_min
operator|)
operator|)
condition|)
block|{
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
block|}
name|bytesinpage
operator|=
name|tinc
expr_stmt|;
if|if
condition|(
name|tinc
operator|>
operator|(
name|newbsize
operator|-
name|toff
operator|)
condition|)
name|bytesinpage
operator|=
name|newbsize
operator|-
name|toff
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CACHE
condition|)
name|vfs_buf_set_valid
argument_list|(
name|bp
argument_list|,
name|off
argument_list|,
name|toff
argument_list|,
name|bytesinpage
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|vm_page_wire
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_pages
index|[
name|pageindex
index|]
operator|=
name|m
expr_stmt|;
name|curbpnpages
operator|=
name|pageindex
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_tag
operator|==
name|VT_NFS
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VBLK
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_dirtyend
operator|>
literal|0
condition|)
block|{
name|bp
operator|->
name|b_validoff
operator|=
name|min
argument_list|(
name|bp
operator|->
name|b_validoff
argument_list|,
name|bp
operator|->
name|b_dirtyoff
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_validend
operator|=
name|max
argument_list|(
name|bp
operator|->
name|b_validend
argument_list|,
name|bp
operator|->
name|b_dirtyend
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_validend
operator|==
literal|0
condition|)
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_CACHE
expr_stmt|;
block|}
name|bp
operator|->
name|b_data
operator|=
operator|(
name|caddr_t
operator|)
name|trunc_page
argument_list|(
name|bp
operator|->
name|b_data
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_npages
operator|=
name|curbpnpages
expr_stmt|;
name|pmap_qenter
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_pages
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
operator|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
operator|)
operator||=
name|off
operator|&
name|PAGE_MASK
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
condition|)
name|vmiospace
operator|+=
operator|(
name|newbsize
operator|-
name|bp
operator|->
name|b_bufsize
operator|)
expr_stmt|;
name|bufspace
operator|+=
operator|(
name|newbsize
operator|-
name|bp
operator|->
name|b_bufsize
operator|)
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
name|newbsize
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|size
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Wait for buffer I/O completion, returning error status.  */
end_comment

begin_function
name|int
name|biowait
parameter_list|(
specifier|register
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
operator|)
operator|==
literal|0
condition|)
if|#
directive|if
name|defined
argument_list|(
name|NO_SCHEDULE_MODS
argument_list|)
name|tsleep
argument_list|(
name|bp
argument_list|,
name|PRIBIO
argument_list|,
literal|"biowait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|tsleep
argument_list|(
name|bp
argument_list|,
name|curproc
operator|->
name|p_usrpri
argument_list|,
literal|"biowait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_EINTR
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_EINTR
expr_stmt|;
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
return|return
operator|(
name|bp
operator|->
name|b_error
condition|?
name|bp
operator|->
name|b_error
else|:
name|EIO
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Finish I/O on a buffer, calling an optional function.  * This is usually called from interrupt level, so process blocking  * is not *a good idea*.  */
end_comment

begin_function
name|void
name|biodone
parameter_list|(
specifier|register
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
operator|)
condition|)
name|panic
argument_list|(
literal|"biodone: buffer not busy"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
name|printf
argument_list|(
literal|"biodone: buffer already done\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|bp
operator|->
name|b_flags
operator||=
name|B_DONE
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
block|{
name|vwakeup
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BOUNCE_BUFFERS
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BOUNCE
condition|)
name|vm_bounce_free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* call optional completion function if requested */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CALL
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_CALL
expr_stmt|;
call|(
modifier|*
name|bp
operator|->
name|b_iodone
call|)
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
condition|)
block|{
name|int
name|i
decl_stmt|,
name|resid
decl_stmt|;
name|vm_ooffset_t
name|foff
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|vm_object_t
name|obj
decl_stmt|;
name|int
name|iosize
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|bp
operator|->
name|b_vp
decl_stmt|;
name|obj
operator|=
name|vp
operator|->
name|v_object
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VFS_BIO_DEBUG
argument_list|)
if|if
condition|(
name|vp
operator|->
name|v_usecount
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"biodone: zero vnode ref count"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_object
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"biodone: missing VM object"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|VVMIO
operator|)
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"biodone: vnode is not setup for merged cache"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VBLK
condition|)
name|foff
operator|=
operator|(
name|vm_ooffset_t
operator|)
name|DEV_BSIZE
operator|*
name|bp
operator|->
name|b_lblkno
expr_stmt|;
else|else
name|foff
operator|=
operator|(
name|vm_ooffset_t
operator|)
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
operator|*
name|bp
operator|->
name|b_lblkno
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|panic
argument_list|(
literal|"biodone: no object"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|VFS_BIO_DEBUG
argument_list|)
if|if
condition|(
name|obj
operator|->
name|paging_in_progress
operator|<
name|bp
operator|->
name|b_npages
condition|)
block|{
name|printf
argument_list|(
literal|"biodone: paging in progress(%d)< bp->b_npages(%d)\n"
argument_list|,
name|obj
operator|->
name|paging_in_progress
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|iosize
operator|=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bogusflag
init|=
literal|0
decl_stmt|;
name|m
operator|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|bogus_page
condition|)
block|{
name|bogusflag
operator|=
literal|1
expr_stmt|;
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|foff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|VFS_BIO_DEBUG
argument_list|)
name|printf
argument_list|(
literal|"biodone: page disappeared\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|obj
operator|->
name|paging_in_progress
expr_stmt|;
continue|continue;
block|}
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|=
name|m
expr_stmt|;
name|pmap_qenter
argument_list|(
name|trunc_page
argument_list|(
name|bp
operator|->
name|b_data
argument_list|)
argument_list|,
name|bp
operator|->
name|b_pages
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|VFS_BIO_DEBUG
argument_list|)
if|if
condition|(
name|OFF_TO_IDX
argument_list|(
name|foff
argument_list|)
operator|!=
name|m
operator|->
name|pindex
condition|)
block|{
name|printf
argument_list|(
literal|"biodone: foff(%d)/m->pindex(%d) mismatch\n"
argument_list|,
name|foff
argument_list|,
name|m
operator|->
name|pindex
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|resid
operator|=
name|IDX_TO_OFF
argument_list|(
name|m
operator|->
name|pindex
operator|+
literal|1
argument_list|)
operator|-
name|foff
expr_stmt|;
if|if
condition|(
name|resid
operator|>
name|iosize
condition|)
name|resid
operator|=
name|iosize
expr_stmt|;
comment|/* 			 * In the write case, the valid and clean bits are 			 * already changed correctly, so we only need to do this 			 * here in the read case. 			 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|&&
operator|!
name|bogusflag
operator|&&
name|resid
operator|>
literal|0
condition|)
block|{
name|vfs_page_set_valid
argument_list|(
name|bp
argument_list|,
name|foff
argument_list|,
name|i
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * when debugging new filesystems or buffer I/O methods, this 			 * is the most common error that pops up.  if you see this, you 			 * have not set the page busy flag correctly!!! 			 */
if|if
condition|(
name|m
operator|->
name|busy
operator|==
literal|0
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
name|printf
argument_list|(
literal|"biodone: page busy< 0, "
literal|"pindex: %d, foff: 0x(%x,%x), "
literal|"resid: %d, index: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|m
operator|->
name|pindex
argument_list|,
call|(
name|int
call|)
argument_list|(
name|foff
operator|>>
literal|32
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|foff
operator|&
literal|0xffffffff
argument_list|,
name|resid
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VBLK
condition|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
name|printf
argument_list|(
literal|" iosize: %ld, lblkno: %d, flags: 0x%lx, npages: %d\n"
argument_list|,
name|bp
operator|->
name|b_vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
argument_list|,
operator|(
name|int
operator|)
name|bp
operator|->
name|b_lblkno
argument_list|,
name|bp
operator|->
name|b_flags
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" VDEV, lblkno: %d, flags: 0x%lx, npages: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|bp
operator|->
name|b_lblkno
argument_list|,
name|bp
operator|->
name|b_flags
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" valid: 0x%x, dirty: 0x%x, wired: %d\n"
argument_list|,
name|m
operator|->
name|valid
argument_list|,
name|m
operator|->
name|dirty
argument_list|,
name|m
operator|->
name|wire_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|panic
argument_list|(
literal|"biodone: page busy< 0\n"
argument_list|)
expr_stmt|;
block|}
operator|--
name|m
operator|->
name|busy
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|busy
operator|==
literal|0
operator|)
operator|&&
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_WANTED
operator|)
condition|)
block|{
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_WANTED
expr_stmt|;
name|wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
operator|--
name|obj
operator|->
name|paging_in_progress
expr_stmt|;
name|foff
operator|+=
name|resid
expr_stmt|;
name|iosize
operator|-=
name|resid
expr_stmt|;
block|}
if|if
condition|(
name|obj
operator|&&
name|obj
operator|->
name|paging_in_progress
operator|==
literal|0
operator|&&
operator|(
name|obj
operator|->
name|flags
operator|&
name|OBJ_PIPWNT
operator|)
condition|)
block|{
name|obj
operator|->
name|flags
operator|&=
operator|~
name|OBJ_PIPWNT
expr_stmt|;
name|wakeup
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * For asynchronous completions, release the buffer now. The brelse 	 * checks for B_WANTED and will do the wakeup there if necessary - so 	 * no need to do a wakeup here in the async case. 	 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ASYNC
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_NOCACHE
operator||
name|B_INVAL
operator||
name|B_ERROR
operator||
name|B_RELBUF
operator|)
operator|)
operator|!=
literal|0
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_WANTED
expr_stmt|;
name|wakeup
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|count_lock_queue
parameter_list|()
block|{
name|int
name|count
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LOCKED
index|]
argument_list|)
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|TAILQ_NEXT
argument_list|(
name|bp
argument_list|,
name|b_freelist
argument_list|)
control|)
name|count
operator|++
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|vfs_update_interval
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|vfs_update
parameter_list|()
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|tsleep
argument_list|(
operator|&
name|vfs_update_wakeup
argument_list|,
name|PUSER
argument_list|,
literal|"update"
argument_list|,
name|hz
operator|*
name|vfs_update_interval
argument_list|)
expr_stmt|;
name|vfs_update_wakeup
operator|=
literal|0
expr_stmt|;
name|sync
argument_list|(
name|curproc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|sysctl_kern_updateinterval
name|SYSCTL_HANDLER_ARGS
block|{
name|int
name|error
init|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
name|oidp
operator|->
name|oid_arg1
argument_list|,
name|oidp
operator|->
name|oid_arg2
argument_list|,
name|req
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|wakeup
argument_list|(
operator|&
name|vfs_update_wakeup
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern
argument_list|,
name|KERN_UPDATEINTERVAL
argument_list|,
name|update
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|vfs_update_interval
argument_list|,
literal|0
argument_list|,
name|sysctl_kern_updateinterval
argument_list|,
literal|"I"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This routine is called in lieu of iodone in the case of  * incomplete I/O.  This keeps the busy status for pages  * consistant.  */
end_comment

begin_function
name|void
name|vfs_unbusy_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
condition|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|bp
operator|->
name|b_vp
decl_stmt|;
name|vm_object_t
name|obj
init|=
name|vp
operator|->
name|v_object
decl_stmt|;
name|vm_ooffset_t
name|foff
decl_stmt|;
name|foff
operator|=
operator|(
name|vm_ooffset_t
operator|)
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
operator|*
name|bp
operator|->
name|b_lblkno
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
name|vm_page_t
name|m
init|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|bogus_page
condition|)
block|{
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|foff
argument_list|)
operator|+
name|i
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|panic
argument_list|(
literal|"vfs_unbusy_pages: page missing\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|=
name|m
expr_stmt|;
name|pmap_qenter
argument_list|(
name|trunc_page
argument_list|(
name|bp
operator|->
name|b_data
argument_list|)
argument_list|,
name|bp
operator|->
name|b_pages
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
block|}
operator|--
name|obj
operator|->
name|paging_in_progress
expr_stmt|;
operator|--
name|m
operator|->
name|busy
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|busy
operator|==
literal|0
operator|)
operator|&&
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_WANTED
operator|)
condition|)
block|{
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_WANTED
expr_stmt|;
name|wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|obj
operator|->
name|paging_in_progress
operator|==
literal|0
operator|&&
operator|(
name|obj
operator|->
name|flags
operator|&
name|OBJ_PIPWNT
operator|)
condition|)
block|{
name|obj
operator|->
name|flags
operator|&=
operator|~
name|OBJ_PIPWNT
expr_stmt|;
name|wakeup
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Set NFS' b_validoff and b_validend fields from the valid bits  * of a page.  If the consumer is not NFS, and the page is not  * valid for the entire range, clear the B_CACHE flag to force  * the consumer to re-read the page.  */
end_comment

begin_function
specifier|static
name|void
name|vfs_buf_set_valid
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|vm_ooffset_t
name|foff
parameter_list|,
name|vm_offset_t
name|off
parameter_list|,
name|vm_offset_t
name|size
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_vp
operator|->
name|v_tag
operator|==
name|VT_NFS
operator|&&
name|bp
operator|->
name|b_vp
operator|->
name|v_type
operator|!=
name|VBLK
condition|)
block|{
name|vm_offset_t
name|svalid
decl_stmt|,
name|evalid
decl_stmt|;
name|int
name|validbits
init|=
name|m
operator|->
name|valid
decl_stmt|;
comment|/* 		 * This only bothers with the first valid range in the 		 * page. 		 */
name|svalid
operator|=
name|off
expr_stmt|;
while|while
condition|(
name|validbits
operator|&&
operator|!
operator|(
name|validbits
operator|&
literal|1
operator|)
condition|)
block|{
name|svalid
operator|+=
name|DEV_BSIZE
expr_stmt|;
name|validbits
operator|>>=
literal|1
expr_stmt|;
block|}
name|evalid
operator|=
name|svalid
expr_stmt|;
while|while
condition|(
name|validbits
operator|&
literal|1
condition|)
block|{
name|evalid
operator|+=
name|DEV_BSIZE
expr_stmt|;
name|validbits
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* 		 * Make sure this range is contiguous with the range 		 * built up from previous pages.  If not, then we will 		 * just use the range from the previous pages. 		 */
if|if
condition|(
name|svalid
operator|==
name|bp
operator|->
name|b_validend
condition|)
block|{
name|bp
operator|->
name|b_validoff
operator|=
name|min
argument_list|(
name|bp
operator|->
name|b_validoff
argument_list|,
name|svalid
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_validend
operator|=
name|max
argument_list|(
name|bp
operator|->
name|b_validend
argument_list|,
name|evalid
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|vm_page_is_valid
argument_list|(
name|m
argument_list|,
call|(
name|vm_offset_t
call|)
argument_list|(
operator|(
name|foff
operator|+
name|off
operator|)
operator|&
name|PAGE_MASK
argument_list|)
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_CACHE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set the valid bits in a page, taking care of the b_validoff,  * b_validend fields which NFS uses to optimise small reads.  Off is  * the offset within the file and pageno is the page index within the buf.  */
end_comment

begin_function
specifier|static
name|void
name|vfs_page_set_valid
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|vm_ooffset_t
name|off
parameter_list|,
name|int
name|pageno
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|bp
operator|->
name|b_vp
decl_stmt|;
name|vm_ooffset_t
name|soff
decl_stmt|,
name|eoff
decl_stmt|;
name|soff
operator|=
name|off
expr_stmt|;
name|eoff
operator|=
name|off
operator|+
name|min
argument_list|(
name|PAGE_SIZE
argument_list|,
name|bp
operator|->
name|b_bufsize
argument_list|)
expr_stmt|;
name|vm_page_set_invalid
argument_list|(
name|m
argument_list|,
call|(
name|vm_offset_t
call|)
argument_list|(
name|soff
operator|&
name|PAGE_MASK
argument_list|)
argument_list|,
call|(
name|vm_offset_t
call|)
argument_list|(
name|eoff
operator|-
name|soff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_tag
operator|==
name|VT_NFS
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VBLK
condition|)
block|{
name|vm_ooffset_t
name|sv
decl_stmt|,
name|ev
decl_stmt|;
name|off
operator|=
name|off
operator|-
name|pageno
operator|*
name|PAGE_SIZE
expr_stmt|;
name|sv
operator|=
name|off
operator|+
operator|(
operator|(
name|bp
operator|->
name|b_validoff
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|ev
operator|=
name|off
operator|+
operator|(
name|bp
operator|->
name|b_validend
operator|&
operator|~
operator|(
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|soff
operator|=
name|max
argument_list|(
name|sv
argument_list|,
name|soff
argument_list|)
expr_stmt|;
name|eoff
operator|=
name|min
argument_list|(
name|ev
argument_list|,
name|eoff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eoff
operator|>
name|soff
condition|)
name|vm_page_set_validclean
argument_list|(
name|m
argument_list|,
call|(
name|vm_offset_t
call|)
argument_list|(
name|soff
operator|&
name|PAGE_MASK
argument_list|)
argument_list|,
call|(
name|vm_offset_t
call|)
argument_list|(
name|eoff
operator|-
name|soff
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine is called before a device strategy routine.  * It is used to tell the VM system that paging I/O is in  * progress, and treat the pages associated with the buffer  * almost as being PG_BUSY.  Also the object paging_in_progress  * flag is handled to make sure that the object doesn't become  * inconsistant.  */
end_comment

begin_function
name|void
name|vfs_busy_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
name|clear_modify
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
condition|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|bp
operator|->
name|b_vp
decl_stmt|;
name|vm_object_t
name|obj
init|=
name|vp
operator|->
name|v_object
decl_stmt|;
name|vm_ooffset_t
name|foff
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VBLK
condition|)
name|foff
operator|=
operator|(
name|vm_ooffset_t
operator|)
name|DEV_BSIZE
operator|*
name|bp
operator|->
name|b_lblkno
expr_stmt|;
else|else
name|foff
operator|=
operator|(
name|vm_ooffset_t
operator|)
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
operator|*
name|bp
operator|->
name|b_lblkno
expr_stmt|;
name|vfs_setdirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
operator|,
name|foff
operator|+=
name|PAGE_SIZE
control|)
block|{
name|vm_page_t
name|m
init|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CLUSTER
operator|)
operator|==
literal|0
condition|)
block|{
name|obj
operator|->
name|paging_in_progress
operator|++
expr_stmt|;
name|m
operator|->
name|busy
operator|++
expr_stmt|;
block|}
name|vm_page_protect
argument_list|(
name|m
argument_list|,
name|VM_PROT_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|clear_modify
condition|)
name|vfs_page_set_valid
argument_list|(
name|bp
argument_list|,
name|foff
argument_list|,
name|i
argument_list|,
name|m
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>=
name|PAGE_SIZE
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|valid
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CACHE
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|=
name|bogus_page
expr_stmt|;
name|pmap_qenter
argument_list|(
name|trunc_page
argument_list|(
name|bp
operator|->
name|b_data
argument_list|)
argument_list|,
name|bp
operator|->
name|b_pages
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Tell the VM system that the pages associated with this buffer  * are clean.  This is used for delayed writes where the data is  * going to go to disk eventually without additional VM intevention.  */
end_comment

begin_function
name|void
name|vfs_clean_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
condition|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|bp
operator|->
name|b_vp
decl_stmt|;
name|vm_ooffset_t
name|foff
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VBLK
condition|)
name|foff
operator|=
operator|(
name|vm_ooffset_t
operator|)
name|DEV_BSIZE
operator|*
name|bp
operator|->
name|b_lblkno
expr_stmt|;
else|else
name|foff
operator|=
operator|(
name|vm_ooffset_t
operator|)
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
operator|*
name|bp
operator|->
name|b_lblkno
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
operator|,
name|foff
operator|+=
name|PAGE_SIZE
control|)
block|{
name|vm_page_t
name|m
init|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
decl_stmt|;
name|vfs_page_set_valid
argument_list|(
name|bp
argument_list|,
name|foff
argument_list|,
name|i
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|vfs_bio_clrbuf
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_npages
operator|==
literal|1
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_bufsize
operator|<
name|PAGE_SIZE
operator|)
condition|)
block|{
name|int
name|mask
decl_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_bufsize
condition|;
name|i
operator|+=
name|DEV_BSIZE
control|)
name|mask
operator||=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|/
name|DEV_BSIZE
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_pages
index|[
literal|0
index|]
operator|->
name|valid
operator|!=
name|mask
condition|)
block|{
name|bzero
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_bufsize
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_pages
index|[
literal|0
index|]
operator|->
name|valid
operator|=
name|mask
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|->
name|valid
operator|==
name|VM_PAGE_BITS_ALL
condition|)
continue|continue;
if|if
condition|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|->
name|valid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|bp
operator|->
name|b_data
operator|+
operator|(
name|i
operator|<<
name|PAGE_SHIFT
operator|)
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|PAGE_SIZE
operator|/
name|DEV_BSIZE
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|->
name|valid
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
operator|)
operator|==
literal|0
condition|)
name|bzero
argument_list|(
name|bp
operator|->
name|b_data
operator|+
operator|(
name|i
operator|<<
name|PAGE_SHIFT
operator|)
operator|+
name|j
operator|*
name|DEV_BSIZE
argument_list|,
name|DEV_BSIZE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* bp->b_pages[i]->valid = VM_PAGE_BITS_ALL; */
block|}
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|clrbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * vm_hold_load_pages and vm_hold_unload pages get pages into  * a buffers address space.  The pages are anonymous and are  * not associated with a file object.  */
end_comment

begin_function
name|void
name|vm_hold_load_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|vm_offset_t
name|from
parameter_list|,
name|vm_offset_t
name|to
parameter_list|)
block|{
name|vm_offset_t
name|pg
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|;
name|int
name|index
decl_stmt|;
name|to
operator|=
name|round_page
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|from
operator|=
name|round_page
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|from
operator|-
name|trunc_page
argument_list|(
name|bp
operator|->
name|b_data
argument_list|)
operator|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
for|for
control|(
name|pg
operator|=
name|from
init|;
name|pg
operator|<
name|to
condition|;
name|pg
operator|+=
name|PAGE_SIZE
operator|,
name|index
operator|++
control|)
block|{
name|tryagain
label|:
name|p
operator|=
name|vm_page_alloc
argument_list|(
name|kernel_object
argument_list|,
operator|(
operator|(
name|pg
operator|-
name|VM_MIN_KERNEL_ADDRESS
operator|)
operator|>>
name|PAGE_SHIFT
operator|)
argument_list|,
name|VM_ALLOC_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|VM_WAIT
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
name|vm_page_wire
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pmap_kenter
argument_list|(
name|pg
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_pages
index|[
name|index
index|]
operator|=
name|p
expr_stmt|;
name|PAGE_WAKEUP
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_npages
operator|=
name|index
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vm_hold_free_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|vm_offset_t
name|from
parameter_list|,
name|vm_offset_t
name|to
parameter_list|)
block|{
name|vm_offset_t
name|pg
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|;
name|int
name|index
decl_stmt|,
name|newnpages
decl_stmt|;
name|from
operator|=
name|round_page
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|to
operator|=
name|round_page
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|newnpages
operator|=
name|index
operator|=
operator|(
name|from
operator|-
name|trunc_page
argument_list|(
name|bp
operator|->
name|b_data
argument_list|)
operator|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
for|for
control|(
name|pg
operator|=
name|from
init|;
name|pg
operator|<
name|to
condition|;
name|pg
operator|+=
name|PAGE_SIZE
operator|,
name|index
operator|++
control|)
block|{
name|p
operator|=
name|bp
operator|->
name|b_pages
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|(
name|index
operator|<
name|bp
operator|->
name|b_npages
operator|)
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
name|p
operator|->
name|busy
condition|)
block|{
name|printf
argument_list|(
literal|"vm_hold_free_pages: blkno: %d, lblkno: %d\n"
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_lblkno
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|bp
operator|->
name|b_pages
index|[
name|index
index|]
operator|=
name|NULL
expr_stmt|;
name|pmap_kremove
argument_list|(
name|pg
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|bp
operator|->
name|b_npages
operator|=
name|newnpages
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|buffer
argument_list|,
argument|db_show_buffer
argument_list|)
end_macro

begin_block
block|{
comment|/* get args */
name|struct
name|buf
modifier|*
name|bp
init|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
operator|!
name|have_addr
condition|)
block|{
name|db_printf
argument_list|(
literal|"usage: show buffer<addr>\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|db_printf
argument_list|(
literal|"b_proc = %p,\nb_flags = 0x%b\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|bp
operator|->
name|b_proc
argument_list|,
name|bp
operator|->
name|b_flags
argument_list|,
literal|"\20\40bounce\37cluster\36vmio\35ram\34ordered"
literal|"\33paging\32xxx\31writeinprog\30wanted\27relbuf\26tape"
literal|"\25read\24raw\23phys\22clusterok\21malloc\20nocache"
literal|"\17locked\16inval\15gathered\14error\13eintr\12done\11dirty"
literal|"\10delwri\7call\6cache\5busy\4bad\3async\2needcommit\1age"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"b_error = %d, b_bufsize = %ld, b_bcount = %ld, "
literal|"b_resid = %ld\nb_dev = 0x%x, b_un.b_addr = %p, "
literal|"b_blkno = %d, b_pblkno = %d\n"
argument_list|,
name|bp
operator|->
name|b_error
argument_list|,
name|bp
operator|->
name|b_bufsize
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|bp
operator|->
name|b_resid
argument_list|,
name|bp
operator|->
name|b_dev
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_pblkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_npages
condition|)
block|{
name|int
name|i
decl_stmt|;
name|db_printf
argument_list|(
literal|"b_npages = %d, pages(OBJ, IDX, PA): "
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|m
operator|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
expr_stmt|;
name|db_printf
argument_list|(
literal|"(0x%x, 0x%x, 0x%x)"
argument_list|,
name|m
operator|->
name|object
argument_list|,
name|m
operator|->
name|pindex
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|bp
operator|->
name|b_npages
condition|)
name|db_printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

end_unit

