begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994,1997 John S. Dyson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Absolutely no warranty of function or purpose is made by the author  *		John S. Dyson.  *  * $Id: vfs_bio.c,v 1.199 1999/01/27 21:49:58 dillon Exp $  */
end_comment

begin_comment
comment|/*  * this file contains a new buffer I/O scheme implementing a coherent  * VM object and buffer cache scheme.  Pains have been taken to make  * sure that the performance degradation associated with schemes such  * as this is not realized.  *  * Author:  John S. Dyson  * Significant help during the development and debugging phases  * had been provided by David Greenman, also of the FreeBSD core team.  *  * see man buf(9) for more info.  */
end_comment

begin_define
define|#
directive|define
name|VMIO
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/specfs/specdev.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_prot.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_BIOBUF
argument_list|,
literal|"BIO buffer"
argument_list|,
literal|"BIO buffer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|bio_ops
name|bioops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* I/O operation notification */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* replaced bu sched_sync */
end_comment

begin_endif
unit|static void vfs_update __P((void)); static struct	proc *updateproc; static struct kproc_desc up_kp = { 	"update", 	vfs_update,&updateproc }; SYSINIT_KT(update, SI_SUB_KTHREAD_UPDATE, SI_ORDER_FIRST, kproc_start,&up_kp)
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|buf
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer header pool */
end_comment

begin_decl_stmt
name|struct
name|swqueue
name|bswlist
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|vm_hold_free_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|vm_offset_t
name|from
parameter_list|,
name|vm_offset_t
name|to
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vm_hold_load_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|vm_offset_t
name|from
parameter_list|,
name|vm_offset_t
name|to
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vfs_buf_set_valid
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|vm_ooffset_t
name|foff
parameter_list|,
name|vm_offset_t
name|off
parameter_list|,
name|vm_offset_t
name|size
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vfs_page_set_valid
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|vm_ooffset_t
name|off
parameter_list|,
name|int
name|pageno
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vfs_clean_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vfs_setdirty
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vfs_vmio_release
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|flushdirtybuffers
parameter_list|(
name|int
name|slpflag
parameter_list|,
name|int
name|slptimeo
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|needsbuffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Internal update daemon, process 3  *	The variable vfs_update_wakeup allows for internal syncs.  */
end_comment

begin_decl_stmt
name|int
name|vfs_update_wakeup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * buffers base kva  */
end_comment

begin_comment
comment|/*  * bogus page -- for I/O to/from partially complete buffers  * this is a temporary solution to the problem, but it is not  * really that bad.  it would be better to split the buffer  * for input in the case of buffers partially already in memory,  * but the code is intricate enough already.  */
end_comment

begin_decl_stmt
name|vm_page_t
name|bogus_page
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_offset_t
name|bogus_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bufspace
decl_stmt|,
name|maxbufspace
decl_stmt|,
name|vmiospace
decl_stmt|,
name|maxvmiobufspace
decl_stmt|,
name|bufmallocspace
decl_stmt|,
name|maxbufmallocspace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numdirtybuffers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|lodirtybuffers
decl_stmt|,
name|hidirtybuffers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|numfreebuffers
decl_stmt|,
name|lofreebuffers
decl_stmt|,
name|hifreebuffers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kvafreespace
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|numdirtybuffers
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|numdirtybuffers
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|lodirtybuffers
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|lodirtybuffers
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|hidirtybuffers
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|hidirtybuffers
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|numfreebuffers
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|numfreebuffers
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|lofreebuffers
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|lofreebuffers
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|hifreebuffers
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|hifreebuffers
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|maxbufspace
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|maxbufspace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|bufspace
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|bufspace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|maxvmiobufspace
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|maxvmiobufspace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|vmiospace
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|vmiospace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|maxmallocbufspace
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|maxbufmallocspace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|bufmallocspace
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|bufmallocspace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|kvafreespace
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|kvafreespace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument|bufhashhdr
argument_list|,
argument|buf
argument_list|)
name|bufhashtbl
index|[
name|BUFHSZ
index|]
operator|,
name|invalhash
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|bqueues
name|bufqueues
index|[
name|BUFFER_QUEUES
index|]
init|=
block|{
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|vm_swap_size
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BUF_MAXUSE
value|24
end_define

begin_define
define|#
directive|define
name|VFS_BIO_NEED_ANY
value|1
end_define

begin_define
define|#
directive|define
name|VFS_BIO_NEED_LOWLIMIT
value|2
end_define

begin_define
define|#
directive|define
name|VFS_BIO_NEED_FREE
value|4
end_define

begin_comment
comment|/*  * Initialize buffer headers and related structures.  */
end_comment

begin_function
name|void
name|bufinit
parameter_list|()
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|bswlist
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|invalhash
argument_list|)
expr_stmt|;
comment|/* first, make a null hash table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUFHSZ
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|bufhashtbl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* next, make a null set of free lists */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUFFER_QUEUES
condition|;
name|i
operator|++
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|bufqueues
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* finally, initialize each buffer header and stick on empty q */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbuf
condition|;
name|i
operator|++
control|)
block|{
name|bp
operator|=
operator|&
name|buf
index|[
name|i
index|]
expr_stmt|;
name|bzero
argument_list|(
name|bp
argument_list|,
sizeof|sizeof
expr|*
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_INVAL
expr_stmt|;
comment|/* we're just an empty header */
name|bp
operator|->
name|b_dev
operator|=
name|NODEV
expr_stmt|;
name|bp
operator|->
name|b_rcred
operator|=
name|NOCRED
expr_stmt|;
name|bp
operator|->
name|b_wcred
operator|=
name|NOCRED
expr_stmt|;
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_EMPTY
expr_stmt|;
name|bp
operator|->
name|b_xflags
operator|=
literal|0
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_EMPTY
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|invalhash
argument_list|,
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
block|}
comment|/*  * maxbufspace is currently calculated to support all filesystem blocks  * to be 8K.  If you happen to use a 16K filesystem, the size of the buffer  * cache is still the same as it would be for 8K filesystems.  This  * keeps the size of the buffer cache "in check" for big block filesystems.  */
name|maxbufspace
operator|=
operator|(
name|nbuf
operator|+
literal|8
operator|)
operator|*
name|DFLTBSIZE
expr_stmt|;
comment|/*  * reserve 1/3 of the buffers for metadata (VDIR) which might not be VMIO'ed  */
name|maxvmiobufspace
operator|=
literal|2
operator|*
name|maxbufspace
operator|/
literal|3
expr_stmt|;
comment|/*  * Limit the amount of malloc memory since it is wired permanently into  * the kernel space.  Even though this is accounted for in the buffer  * allocation, we don't want the malloced region to grow uncontrolled.  * The malloc scheme improves memory utilization significantly on average  * (small) directories.  */
name|maxbufmallocspace
operator|=
name|maxbufspace
operator|/
literal|20
expr_stmt|;
comment|/*  * Remove the probability of deadlock conditions by limiting the  * number of dirty buffers.  */
name|hidirtybuffers
operator|=
name|nbuf
operator|/
literal|8
operator|+
literal|20
expr_stmt|;
name|lodirtybuffers
operator|=
name|nbuf
operator|/
literal|16
operator|+
literal|10
expr_stmt|;
name|numdirtybuffers
operator|=
literal|0
expr_stmt|;
name|lofreebuffers
operator|=
name|nbuf
operator|/
literal|18
operator|+
literal|5
expr_stmt|;
name|hifreebuffers
operator|=
literal|2
operator|*
name|lofreebuffers
expr_stmt|;
name|numfreebuffers
operator|=
name|nbuf
expr_stmt|;
name|kvafreespace
operator|=
literal|0
expr_stmt|;
name|bogus_offset
operator|=
name|kmem_alloc_pageable
argument_list|(
name|kernel_map
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|bogus_page
operator|=
name|vm_page_alloc
argument_list|(
name|kernel_object
argument_list|,
operator|(
operator|(
name|bogus_offset
operator|-
name|VM_MIN_KERNEL_ADDRESS
operator|)
operator|>>
name|PAGE_SHIFT
operator|)
argument_list|,
name|VM_ALLOC_NORMAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free the kva allocation for a buffer  * Must be called only at splbio or higher,  *  as this is the only locking for buffer_map.  */
end_comment

begin_function
specifier|static
name|void
name|bfreekva
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_kvasize
operator|==
literal|0
condition|)
return|return;
name|vm_map_delete
argument_list|(
name|buffer_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_kvabase
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_kvabase
operator|+
name|bp
operator|->
name|b_kvasize
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_kvasize
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove the buffer from the appropriate free list  */
end_comment

begin_function
name|void
name|bremfree
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_qindex
operator|!=
name|QUEUE_NONE
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_qindex
operator|==
name|QUEUE_EMPTY
condition|)
block|{
name|kvafreespace
operator|-=
name|bp
operator|->
name|b_kvasize
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bufqueues
index|[
name|bp
operator|->
name|b_qindex
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_NONE
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
name|panic
argument_list|(
literal|"bremfree: removing a buffer when not on a queue"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_INVAL
operator|)
operator|||
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_DELWRI
operator||
name|B_LOCKED
operator|)
operator|)
operator|==
literal|0
condition|)
operator|--
name|numfreebuffers
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a buffer with the specified data.  Look in the cache first.  */
end_comment

begin_function
name|int
name|bread
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|daddr_t
name|blkno
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|buf
modifier|*
modifier|*
name|bpp
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|getblk
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
comment|/* if not found in cache, do some I/O */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CACHE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|curproc
operator|!=
name|NULL
condition|)
name|curproc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_inblock
operator|++
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_READ
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_DONE
operator||
name|B_ERROR
operator||
name|B_INVAL
operator|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_rcred
operator|==
name|NOCRED
condition|)
block|{
if|if
condition|(
name|cred
operator|!=
name|NOCRED
condition|)
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_rcred
operator|=
name|cred
expr_stmt|;
block|}
name|vfs_busy_pages
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_STRATEGY
argument_list|(
name|vp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|biowait
argument_list|(
name|bp
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Operates like bread, but also starts asynchronous I/O on  * read-ahead blocks.  */
end_comment

begin_function
name|int
name|breadn
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|daddr_t
name|blkno
parameter_list|,
name|int
name|size
parameter_list|,
name|daddr_t
modifier|*
name|rablkno
parameter_list|,
name|int
modifier|*
name|rabsize
parameter_list|,
name|int
name|cnt
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|buf
modifier|*
modifier|*
name|bpp
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|rabp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|,
name|readwait
init|=
literal|0
decl_stmt|;
operator|*
name|bpp
operator|=
name|bp
operator|=
name|getblk
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* if not found in cache, do some I/O */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CACHE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|curproc
operator|!=
name|NULL
condition|)
name|curproc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_inblock
operator|++
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_READ
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_DONE
operator||
name|B_ERROR
operator||
name|B_INVAL
operator|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_rcred
operator|==
name|NOCRED
condition|)
block|{
if|if
condition|(
name|cred
operator|!=
name|NOCRED
condition|)
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_rcred
operator|=
name|cred
expr_stmt|;
block|}
name|vfs_busy_pages
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_STRATEGY
argument_list|(
name|vp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
operator|++
name|readwait
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
operator|,
name|rablkno
operator|++
operator|,
name|rabsize
operator|++
control|)
block|{
if|if
condition|(
name|inmem
argument_list|(
name|vp
argument_list|,
operator|*
name|rablkno
argument_list|)
condition|)
continue|continue;
name|rabp
operator|=
name|getblk
argument_list|(
name|vp
argument_list|,
operator|*
name|rablkno
argument_list|,
operator|*
name|rabsize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rabp
operator|->
name|b_flags
operator|&
name|B_CACHE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|curproc
operator|!=
name|NULL
condition|)
name|curproc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_inblock
operator|++
expr_stmt|;
name|rabp
operator|->
name|b_flags
operator||=
name|B_READ
operator||
name|B_ASYNC
expr_stmt|;
name|rabp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_DONE
operator||
name|B_ERROR
operator||
name|B_INVAL
operator|)
expr_stmt|;
if|if
condition|(
name|rabp
operator|->
name|b_rcred
operator|==
name|NOCRED
condition|)
block|{
if|if
condition|(
name|cred
operator|!=
name|NOCRED
condition|)
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|rabp
operator|->
name|b_rcred
operator|=
name|cred
expr_stmt|;
block|}
name|vfs_busy_pages
argument_list|(
name|rabp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_STRATEGY
argument_list|(
name|vp
argument_list|,
name|rabp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|brelse
argument_list|(
name|rabp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|readwait
condition|)
block|{
name|rv
operator|=
name|biowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write, release buffer on completion.  (Done by iodone  * if async.)  */
end_comment

begin_function
name|int
name|bwrite
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|oldflags
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_INVAL
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|oldflags
operator|=
name|bp
operator|->
name|b_flags
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"bwrite: buffer is not busy???"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_READ
operator||
name|B_DONE
operator||
name|B_ERROR
operator||
name|B_DELWRI
operator|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_WRITEINPROG
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|oldflags
operator|&
name|B_DELWRI
operator|)
operator|==
name|B_DELWRI
condition|)
block|{
operator|--
name|numdirtybuffers
expr_stmt|;
name|reassignbuf
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|b_vp
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_vp
operator|->
name|v_numoutput
operator|++
expr_stmt|;
name|vfs_busy_pages
argument_list|(
name|bp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|curproc
operator|!=
name|NULL
condition|)
name|curproc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_oublock
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|VOP_STRATEGY
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Collect statistics on synchronous and asynchronous writes. 	 * Writes to block devices are charged to their associated 	 * filesystem (if any). 	 */
if|if
condition|(
operator|(
name|vp
operator|=
name|bp
operator|->
name|b_vp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VBLK
condition|)
name|mp
operator|=
name|vp
operator|->
name|v_specmountpoint
expr_stmt|;
else|else
name|mp
operator|=
name|vp
operator|->
name|v_mount
expr_stmt|;
if|if
condition|(
name|mp
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|(
name|oldflags
operator|&
name|B_ASYNC
operator|)
operator|==
literal|0
condition|)
name|mp
operator|->
name|mnt_stat
operator|.
name|f_syncwrites
operator|++
expr_stmt|;
else|else
name|mp
operator|->
name|mnt_stat
operator|.
name|f_asyncwrites
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|oldflags
operator|&
name|B_ASYNC
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|rtval
init|=
name|biowait
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rtval
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vfs_bio_need_satisfy
parameter_list|(
name|void
parameter_list|)
block|{
operator|++
name|numfreebuffers
expr_stmt|;
if|if
condition|(
operator|!
name|needsbuffer
condition|)
return|return;
if|if
condition|(
name|numdirtybuffers
operator|<
name|lodirtybuffers
condition|)
block|{
name|needsbuffer
operator|&=
operator|~
operator|(
name|VFS_BIO_NEED_ANY
operator||
name|VFS_BIO_NEED_LOWLIMIT
operator|)
expr_stmt|;
block|}
else|else
block|{
name|needsbuffer
operator|&=
operator|~
name|VFS_BIO_NEED_ANY
expr_stmt|;
block|}
if|if
condition|(
name|numfreebuffers
operator|>=
name|hifreebuffers
condition|)
block|{
name|needsbuffer
operator|&=
operator|~
name|VFS_BIO_NEED_FREE
expr_stmt|;
block|}
name|wakeup
argument_list|(
operator|&
name|needsbuffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Delayed write. (Buffer is marked dirty).  */
end_comment

begin_function
name|void
name|bdwrite
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
operator|)
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"bdwrite: buffer is not busy"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_INVAL
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_READ
operator||
name|B_RELBUF
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_DONE
operator||
name|B_DELWRI
expr_stmt|;
name|reassignbuf
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|b_vp
argument_list|)
expr_stmt|;
operator|++
name|numdirtybuffers
expr_stmt|;
block|}
comment|/* 	 * This bmap keeps the system from needing to do the bmap later, 	 * perhaps when the system is attempting to do a sync.  Since it 	 * is likely that the indirect block -- or whatever other datastructure 	 * that the filesystem needs is still in memory now, it is a good 	 * thing to do this.  Note also, that if the pageout daemon is 	 * requesting a sync -- there might not be enough memory to do 	 * the bmap then...  So, this is important to do. 	 */
if|if
condition|(
name|bp
operator|->
name|b_lblkno
operator|==
name|bp
operator|->
name|b_blkno
condition|)
block|{
name|VOP_BMAP
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|,
name|bp
operator|->
name|b_lblkno
argument_list|,
name|NULL
argument_list|,
operator|&
name|bp
operator|->
name|b_blkno
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set the *dirty* buffer range based upon the VM system dirty pages. 	 */
name|vfs_setdirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * We need to do this here to satisfy the vnode_pager and the 	 * pageout daemon, so that it thinks that the pages have been 	 * "cleaned".  Note that since the pages are in a delayed write 	 * buffer -- the VFS layer "will" see that the pages get written 	 * out on the next sync, or perhaps the cluster will be completed. 	 */
name|vfs_clean_pages
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * XXX The soft dependency code is not prepared to 	 * have I/O done when a bdwrite is requested. For 	 * now we just let the write be delayed if it is 	 * requested by the soft dependency code. 	 */
if|if
condition|(
operator|(
name|vp
operator|=
name|bp
operator|->
name|b_vp
operator|)
operator|&&
operator|(
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VBLK
operator|&&
name|vp
operator|->
name|v_specmountpoint
operator|&&
operator|(
name|vp
operator|->
name|v_specmountpoint
operator|->
name|mnt_flag
operator|&
name|MNT_SOFTDEP
operator|)
operator|)
operator|||
operator|(
name|vp
operator|->
name|v_mount
operator|&&
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_SOFTDEP
operator|)
operator|)
operator|)
condition|)
return|return;
if|if
condition|(
name|numdirtybuffers
operator|>=
name|hidirtybuffers
condition|)
name|flushdirtybuffers
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Same as first half of bdwrite, mark buffer dirty, but do not release it.  * Check how this compares with vfs_setdirty(); XXX [JRE]  */
end_comment

begin_function
name|void
name|bdirty
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_READ
operator||
name|B_RELBUF
operator|)
expr_stmt|;
comment|/* XXX ??? check this */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_DONE
operator||
name|B_DELWRI
expr_stmt|;
comment|/* why done? XXX JRE */
name|reassignbuf
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|b_vp
argument_list|)
expr_stmt|;
operator|++
name|numdirtybuffers
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Asynchronous write.  * Start output on a buffer, but do not wait for it to complete.  * The buffer is released when the output completes.  */
end_comment

begin_function
name|void
name|bawrite
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ASYNC
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Ordered write.  * Start output on a buffer, and flag it so that the device will write  * it in the order it was queued.  The buffer is released when the output  * completes.  */
end_comment

begin_function
name|int
name|bowrite
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ORDERED
operator||
name|B_ASYNC
expr_stmt|;
return|return
operator|(
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a buffer.  */
end_comment

begin_function
name|void
name|brelse
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CLUSTER
condition|)
block|{
name|relpbuf
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* anyone need this block? */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_WANTED
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_WANTED
operator||
name|B_AGE
operator|)
expr_stmt|;
name|wakeup
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_LOCKED
condition|)
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ERROR
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_READ
operator||
name|B_ERROR
operator|)
operator|)
operator|==
name|B_ERROR
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ERROR
expr_stmt|;
name|bdirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_NOCACHE
operator||
name|B_INVAL
operator||
name|B_ERROR
operator||
name|B_FREEBUF
operator|)
operator|)
operator|||
operator|(
name|bp
operator|->
name|b_bufsize
operator|<=
literal|0
operator|)
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
expr_stmt|;
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|)
operator|!=
name|NULL
operator|&&
name|bioops
operator|.
name|io_deallocate
condition|)
call|(
modifier|*
name|bioops
operator|.
name|io_deallocate
call|)
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
condition|)
operator|--
name|numdirtybuffers
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_DELWRI
operator||
name|B_CACHE
operator||
name|B_FREEBUF
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_bufsize
condition|)
name|allocbuf
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_vp
condition|)
name|brelvp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * We must clear B_RELBUF if B_DELWRI is set.  If vfs_vmio_release()  	 * is called with B_DELWRI set, the underlying pages may wind up 	 * getting freed causing a previous write (bdwrite()) to get 'lost' 	 * because pages associated with a B_DELWRI bp are marked clean. 	 *  	 * We still allow the B_INVAL case to call vfs_vmio_release(), even 	 * if B_DELWRI is set. 	 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
condition|)
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_RELBUF
expr_stmt|;
comment|/* 	 * VMIO buffer rundown.  It is not very necessary to keep a VMIO buffer 	 * constituted, so the B_INVAL flag is used to *invalidate* the buffer, 	 * but the VM object is kept around.  The B_NOCACHE flag is used to 	 * invalidate the pages in the VM object. 	 * 	 * The b_{validoff,validend,dirtyoff,dirtyend} values are relative  	 * to b_offset and currently have byte granularity, whereas the 	 * valid flags in the vm_pages have only DEV_BSIZE resolution. 	 * The byte resolution fields are used to avoid unnecessary re-reads 	 * of the buffer but the code really needs to be genericized so 	 * other filesystem modules can take advantage of these fields. 	 * 	 * XXX this seems to cause performance problems. 	 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
operator|)
operator|&&
operator|!
operator|(
name|bp
operator|->
name|b_vp
operator|->
name|v_tag
operator|==
name|VT_NFS
operator|&&
name|bp
operator|->
name|b_vp
operator|->
name|v_type
operator|!=
name|VBLK
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|!=
literal|0
operator|)
ifdef|#
directive|ifdef
name|notdef
operator|&&
operator|(
name|bp
operator|->
name|b_vp
operator|->
name|v_tag
operator|!=
name|VT_NFS
operator|||
name|bp
operator|->
name|b_vp
operator|->
name|v_type
operator|==
name|VBLK
operator|||
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_NOCACHE
operator||
name|B_INVAL
operator||
name|B_ERROR
operator|)
operator|)
operator|||
name|bp
operator|->
name|b_validend
operator|==
literal|0
operator|||
operator|(
name|bp
operator|->
name|b_validoff
operator|==
literal|0
operator|&&
name|bp
operator|->
name|b_validend
operator|==
name|bp
operator|->
name|b_bufsize
operator|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|resid
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|off_t
name|foff
decl_stmt|;
name|vm_pindex_t
name|poff
decl_stmt|;
name|vm_object_t
name|obj
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|bp
operator|->
name|b_vp
expr_stmt|;
comment|/* 		 * Get the base offset and length of the buffer.  Note that  		 * for block sizes that are less then PAGE_SIZE, the b_data 		 * base of the buffer does not represent exactly b_offset and 		 * neither b_offset nor b_size are necessarily page aligned. 		 * Instead, the starting position of b_offset is: 		 * 		 * 	b_data + (b_offset& PAGE_MASK) 		 * 		 * block sizes less then DEV_BSIZE (usually 512) are not  		 * supported due to the page granularity bits (m->valid, 		 * m->dirty, etc...).  		 * 		 * See man buf(9) for more information 		 */
name|resid
operator|=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
name|foff
operator|=
name|bp
operator|->
name|b_offset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
expr_stmt|;
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|bogus_page
condition|)
block|{
name|obj
operator|=
operator|(
name|vm_object_t
operator|)
name|vp
operator|->
name|v_object
expr_stmt|;
name|poff
operator|=
name|OFF_TO_IDX
argument_list|(
name|bp
operator|->
name|b_offset
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|j
operator|++
control|)
block|{
name|m
operator|=
name|bp
operator|->
name|b_pages
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|bogus_page
condition|)
block|{
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
name|poff
operator|+
name|j
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|panic
argument_list|(
literal|"brelse: page missing\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|bp
operator|->
name|b_pages
index|[
name|j
index|]
operator|=
name|m
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_INVAL
operator|)
operator|==
literal|0
condition|)
block|{
name|pmap_qenter
argument_list|(
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
argument_list|)
argument_list|,
name|bp
operator|->
name|b_pages
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_NOCACHE
operator||
name|B_ERROR
operator|)
condition|)
block|{
name|int
name|poffset
init|=
name|foff
operator|&
name|PAGE_MASK
decl_stmt|;
name|int
name|presid
init|=
name|resid
operator|>
operator|(
name|PAGE_SIZE
operator|-
name|poffset
operator|)
condition|?
operator|(
name|PAGE_SIZE
operator|-
name|poffset
operator|)
else|:
name|resid
decl_stmt|;
name|KASSERT
argument_list|(
name|presid
operator|>=
literal|0
argument_list|,
operator|(
literal|"brelse: extra page"
operator|)
argument_list|)
expr_stmt|;
name|vm_page_set_invalid
argument_list|(
name|m
argument_list|,
name|poffset
argument_list|,
name|presid
argument_list|)
expr_stmt|;
block|}
name|resid
operator|-=
name|PAGE_SIZE
operator|-
operator|(
name|foff
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
name|foff
operator|=
operator|(
name|foff
operator|+
name|PAGE_SIZE
operator|)
operator|&
operator|~
name|PAGE_MASK
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_INVAL
operator||
name|B_RELBUF
operator|)
condition|)
name|vfs_vmio_release
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_INVAL
operator||
name|B_RELBUF
operator|)
condition|)
name|vfs_vmio_release
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
name|bp
operator|->
name|b_qindex
operator|!=
name|QUEUE_NONE
condition|)
name|panic
argument_list|(
literal|"brelse: free buffer onto another queue???"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* enqueue */
comment|/* buffers with no memory */
if|if
condition|(
name|bp
operator|->
name|b_bufsize
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
expr_stmt|;
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_EMPTY
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_EMPTY
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|invalhash
argument_list|,
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|NODEV
expr_stmt|;
name|kvafreespace
operator|+=
name|bp
operator|->
name|b_kvasize
expr_stmt|;
comment|/* buffers with junk contents */
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_ERROR
operator||
name|B_INVAL
operator||
name|B_NOCACHE
operator||
name|B_RELBUF
operator|)
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
expr_stmt|;
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_AGE
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_AGE
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|invalhash
argument_list|,
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|NODEV
expr_stmt|;
comment|/* buffers that are locked */
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_LOCKED
condition|)
block|{
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_LOCKED
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LOCKED
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
comment|/* buffers with stale but valid contents */
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_AGE
condition|)
block|{
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_AGE
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_AGE
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
comment|/* buffers with valid and quite potentially reuseable contents */
block|}
else|else
block|{
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_LRU
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LRU
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_INVAL
operator|)
operator|||
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_LOCKED
operator||
name|B_DELWRI
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
condition|)
block|{
operator|--
name|numdirtybuffers
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_DELWRI
expr_stmt|;
block|}
name|vfs_bio_need_satisfy
argument_list|()
expr_stmt|;
block|}
comment|/* unlock */
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_ORDERED
operator||
name|B_WANTED
operator||
name|B_BUSY
operator||
name|B_ASYNC
operator||
name|B_NOCACHE
operator||
name|B_AGE
operator||
name|B_RELBUF
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Release a buffer.  */
end_comment

begin_function
name|void
name|bqrelse
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* anyone need this block? */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_WANTED
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_WANTED
operator||
name|B_AGE
operator|)
expr_stmt|;
name|wakeup
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
name|bp
operator|->
name|b_qindex
operator|!=
name|QUEUE_NONE
condition|)
name|panic
argument_list|(
literal|"bqrelse: free buffer onto another queue???"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_LOCKED
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_LOCKED
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LOCKED
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
comment|/* buffers with stale but valid contents */
block|}
else|else
block|{
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_LRU
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LRU
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_LOCKED
operator||
name|B_DELWRI
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|vfs_bio_need_satisfy
argument_list|()
expr_stmt|;
block|}
comment|/* unlock */
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_ORDERED
operator||
name|B_WANTED
operator||
name|B_BUSY
operator||
name|B_ASYNC
operator||
name|B_NOCACHE
operator||
name|B_AGE
operator||
name|B_RELBUF
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vfs_vmio_release
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|s
operator|=
name|splvm
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
expr_stmt|;
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * In order to keep page LRU ordering consistent, put 		 * everything on the inactive queue. 		 */
name|vm_page_unwire
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * We don't mess with busy pages, it is 		 * the responsibility of the process that 		 * busied the pages to deal with them. 		 */
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
operator|)
operator|||
operator|(
name|m
operator|->
name|busy
operator|!=
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|m
operator|->
name|wire_count
operator|==
literal|0
condition|)
block|{
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_ZERO
argument_list|)
expr_stmt|;
comment|/* 			 * Might as well free the page if we can and it has 			 * no valid data. 			 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ASYNC
operator|)
operator|==
literal|0
operator|&&
operator|!
name|m
operator|->
name|valid
operator|&&
name|m
operator|->
name|hold_count
operator|==
literal|0
condition|)
block|{
name|vm_page_busy
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_protect
argument_list|(
name|m
argument_list|,
name|VM_PROT_NONE
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bufspace
operator|-=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
name|vmiospace
operator|-=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
name|pmap_qremove
argument_list|(
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
argument_list|)
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_npages
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_VMIO
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_vp
condition|)
name|brelvp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see if a block is currently memory resident.  */
end_comment

begin_function
name|struct
name|buf
modifier|*
name|gbincore
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|daddr_t
name|blkno
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|bufhashhdr
modifier|*
name|bh
decl_stmt|;
name|bh
operator|=
name|BUFHASH
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bh
operator|->
name|lh_first
expr_stmt|;
comment|/* Search hash chain */
while|while
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
comment|/* hit */
if|if
condition|(
name|bp
operator|->
name|b_vp
operator|==
name|vp
operator|&&
name|bp
operator|->
name|b_lblkno
operator|==
name|blkno
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_INVAL
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|bp
operator|=
name|bp
operator|->
name|b_hash
operator|.
name|le_next
expr_stmt|;
block|}
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * this routine implements clustered async writes for  * clearing out B_DELWRI buffers...  This is much better  * than the old way of writing only one buffer at a time.  */
end_comment

begin_function
name|int
name|vfs_bio_awrite
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|daddr_t
name|lblkno
init|=
name|bp
operator|->
name|b_lblkno
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|bp
operator|->
name|b_vp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|ncl
decl_stmt|;
name|struct
name|buf
modifier|*
name|bpa
decl_stmt|;
name|int
name|nwritten
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|maxcl
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * right now we support clustered writing only to regular files 	 */
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_mount
operator|!=
literal|0
operator|)
operator|&&
comment|/* Only on nodes that have the size info */
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_CLUSTEROK
operator||
name|B_INVAL
operator|)
operator|)
operator|==
name|B_CLUSTEROK
condition|)
block|{
name|size
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
expr_stmt|;
name|maxcl
operator|=
name|MAXPHYS
operator|/
name|size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|maxcl
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bpa
operator|=
name|gbincore
argument_list|(
name|vp
argument_list|,
name|lblkno
operator|+
name|i
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|bpa
operator|->
name|b_flags
operator|&
operator|(
name|B_BUSY
operator||
name|B_DELWRI
operator||
name|B_CLUSTEROK
operator||
name|B_INVAL
operator|)
operator|)
operator|==
operator|(
name|B_DELWRI
operator||
name|B_CLUSTEROK
operator|)
operator|)
operator|&&
operator|(
name|bpa
operator|->
name|b_bufsize
operator|==
name|size
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|bpa
operator|->
name|b_blkno
operator|==
name|bpa
operator|->
name|b_lblkno
operator|)
operator|||
operator|(
name|bpa
operator|->
name|b_blkno
operator|!=
name|bp
operator|->
name|b_blkno
operator|+
operator|(
operator|(
name|i
operator|*
name|size
operator|)
operator|>>
name|DEV_BSHIFT
operator|)
operator|)
condition|)
break|break;
block|}
else|else
block|{
break|break;
block|}
block|}
name|ncl
operator|=
name|i
expr_stmt|;
comment|/* 		 * this is a possible cluster write 		 */
if|if
condition|(
name|ncl
operator|!=
literal|1
condition|)
block|{
name|nwritten
operator|=
name|cluster_wbuild
argument_list|(
name|vp
argument_list|,
name|size
argument_list|,
name|lblkno
argument_list|,
name|ncl
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|nwritten
return|;
block|}
block|}
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_BUSY
operator||
name|B_ASYNC
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * default (old) behavior, writing out only one block 	 */
name|nwritten
operator|=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
name|nwritten
return|;
block|}
end_function

begin_comment
comment|/*  * Find a buffer header which is available for use.  */
end_comment

begin_function
specifier|static
name|struct
name|buf
modifier|*
name|getnewbuf
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|daddr_t
name|blkno
parameter_list|,
name|int
name|slpflag
parameter_list|,
name|int
name|slptimeo
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|maxsize
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|bp1
decl_stmt|;
name|int
name|nbyteswritten
init|=
literal|0
decl_stmt|;
name|vm_offset_t
name|addr
decl_stmt|;
specifier|static
name|int
name|writerecursion
init|=
literal|0
decl_stmt|;
name|start
label|:
if|if
condition|(
name|bufspace
operator|>=
name|maxbufspace
condition|)
goto|goto
name|trytofreespace
goto|;
comment|/* can we constitute a new buffer? */
if|if
condition|(
operator|(
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_EMPTY
index|]
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
name|bp
operator|->
name|b_qindex
operator|!=
name|QUEUE_EMPTY
condition|)
name|panic
argument_list|(
literal|"getnewbuf: inconsistent EMPTY queue, qindex=%d"
argument_list|,
name|bp
operator|->
name|b_qindex
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bp
operator|->
name|b_flags
operator||=
name|B_BUSY
expr_stmt|;
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|fillbuf
goto|;
block|}
name|trytofreespace
label|:
comment|/* 	 * We keep the file I/O from hogging metadata I/O 	 * This is desirable because file data is cached in the 	 * VM/Buffer cache even if a buffer is freed. 	 */
if|if
condition|(
operator|(
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_AGE
index|]
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
name|bp
operator|->
name|b_qindex
operator|!=
name|QUEUE_AGE
condition|)
name|panic
argument_list|(
literal|"getnewbuf: inconsistent AGE queue, qindex=%d"
argument_list|,
name|bp
operator|->
name|b_qindex
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|(
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LRU
index|]
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
name|bp
operator|->
name|b_qindex
operator|!=
name|QUEUE_LRU
condition|)
name|panic
argument_list|(
literal|"getnewbuf: inconsistent LRU queue, qindex=%d"
argument_list|,
name|bp
operator|->
name|b_qindex
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|bp
condition|)
block|{
comment|/* wait for a free buffer of any kind */
name|needsbuffer
operator||=
name|VFS_BIO_NEED_ANY
expr_stmt|;
do|do
name|tsleep
argument_list|(
operator|&
name|needsbuffer
argument_list|,
operator|(
name|PRIBIO
operator|+
literal|4
operator|)
operator||
name|slpflag
argument_list|,
literal|"newbuf"
argument_list|,
name|slptimeo
argument_list|)
expr_stmt|;
do|while
condition|(
name|needsbuffer
operator|&
name|VFS_BIO_NEED_ANY
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|KASSERT
argument_list|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
operator|)
argument_list|,
operator|(
literal|"getnewbuf: busy buffer on free list\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * We are fairly aggressive about freeing VMIO buffers, but since 	 * the buffering is intact without buffer headers, there is not 	 * much loss.  We gain by maintaining non-VMIOed metadata in buffers. 	 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_qindex
operator|==
name|QUEUE_LRU
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_usecount
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
operator|)
operator|==
literal|0
operator|||
operator|(
name|vmiospace
operator|<
name|maxvmiobufspace
operator|)
condition|)
block|{
operator|--
name|bp
operator|->
name|b_usecount
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LRU
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LRU
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LRU
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
goto|goto
name|start
goto|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LRU
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if we are a delayed write, convert to an async write */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_DELWRI
operator||
name|B_INVAL
operator|)
operator|)
operator|==
name|B_DELWRI
condition|)
block|{
comment|/* 		 * If our delayed write is likely to be used soon, then 		 * recycle back onto the LRU queue. 		 */
if|if
condition|(
name|vp
operator|&&
operator|(
name|bp
operator|->
name|b_vp
operator|==
name|vp
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_qindex
operator|==
name|QUEUE_LRU
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_lblkno
operator|>=
name|blkno
operator|)
operator|&&
operator|(
name|maxsize
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_usecount
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_lblkno
operator|<
name|blkno
operator|+
operator|(
name|MAXPHYS
operator|/
name|maxsize
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LRU
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LRU
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LRU
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_usecount
operator|--
expr_stmt|;
goto|goto
name|start
goto|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LRU
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * Certain layered filesystems can recursively re-enter the vfs_bio 		 * code, due to delayed writes.  This helps keep the system from 		 * deadlocking. 		 */
if|if
condition|(
name|writerecursion
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|writerecursion
operator|>
literal|5
condition|)
block|{
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_AGE
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|bp
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
break|break;
name|bp
operator|=
name|TAILQ_NEXT
argument_list|(
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LRU
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|bp
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
break|break;
name|bp
operator|=
name|TAILQ_NEXT
argument_list|(
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"getnewbuf: cannot get buffer, infinite recursion failure"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_BUSY
operator||
name|B_AGE
operator||
name|B_ASYNC
expr_stmt|;
name|nbyteswritten
operator|+=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
operator|++
name|writerecursion
expr_stmt|;
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
operator|--
name|writerecursion
expr_stmt|;
if|if
condition|(
operator|!
name|slpflag
operator|&&
operator|!
name|slptimeo
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
goto|goto
name|start
goto|;
block|}
block|}
else|else
block|{
operator|++
name|writerecursion
expr_stmt|;
name|nbyteswritten
operator|+=
name|vfs_bio_awrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
operator|--
name|writerecursion
expr_stmt|;
if|if
condition|(
operator|!
name|slpflag
operator|&&
operator|!
name|slptimeo
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
goto|goto
name|start
goto|;
block|}
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_WANTED
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_WANTED
expr_stmt|;
name|wakeup
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_BUSY
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ASYNC
expr_stmt|;
name|vfs_vmio_release
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_vp
condition|)
name|brelvp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|fillbuf
label|:
comment|/* we are not free, nor do we contain interesting data */
if|if
condition|(
name|bp
operator|->
name|b_rcred
operator|!=
name|NOCRED
condition|)
block|{
name|crfree
argument_list|(
name|bp
operator|->
name|b_rcred
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_rcred
operator|=
name|NOCRED
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_wcred
operator|!=
name|NOCRED
condition|)
block|{
name|crfree
argument_list|(
name|bp
operator|->
name|b_wcred
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_wcred
operator|=
name|NOCRED
expr_stmt|;
block|}
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|)
operator|!=
name|NULL
operator|&&
name|bioops
operator|.
name|io_deallocate
condition|)
call|(
modifier|*
name|bioops
operator|.
name|io_deallocate
call|)
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|invalhash
argument_list|,
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bufsize
condition|)
block|{
name|allocbuf
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|NODEV
expr_stmt|;
name|bp
operator|->
name|b_vp
operator|=
name|NULL
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|bp
operator|->
name|b_lblkno
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_offset
operator|=
name|NOOFFSET
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_npages
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_dirtyoff
operator|=
name|bp
operator|->
name|b_dirtyend
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_validoff
operator|=
name|bp
operator|->
name|b_validend
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_usecount
operator|=
literal|5
expr_stmt|;
comment|/* Here, not kern_physio.c, is where this should be done*/
name|LIST_INIT
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|)
expr_stmt|;
name|maxsize
operator|=
operator|(
name|maxsize
operator|+
name|PAGE_MASK
operator|)
operator|&
operator|~
name|PAGE_MASK
expr_stmt|;
comment|/* 	 * we assume that buffer_map is not at address 0 	 */
name|addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|maxsize
operator|!=
name|bp
operator|->
name|b_kvasize
condition|)
block|{
name|bfreekva
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|findkvaspace
label|:
comment|/* 		 * See if we have buffer kva space 		 */
if|if
condition|(
name|vm_map_findspace
argument_list|(
name|buffer_map
argument_list|,
name|vm_map_min
argument_list|(
name|buffer_map
argument_list|)
argument_list|,
name|maxsize
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|kvafreespace
operator|>
literal|0
condition|)
block|{
name|int
name|totfree
init|=
literal|0
decl_stmt|,
name|freed
decl_stmt|;
do|do
block|{
name|freed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_EMPTY
index|]
argument_list|)
init|;
name|bp1
operator|!=
name|NULL
condition|;
name|bp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|bp1
argument_list|,
name|b_freelist
argument_list|)
control|)
block|{
if|if
condition|(
name|bp1
operator|->
name|b_kvasize
operator|!=
literal|0
condition|)
block|{
name|totfree
operator|+=
name|bp1
operator|->
name|b_kvasize
expr_stmt|;
name|freed
operator|=
name|bp1
operator|->
name|b_kvasize
expr_stmt|;
name|bremfree
argument_list|(
name|bp1
argument_list|)
expr_stmt|;
name|bfreekva
argument_list|(
name|bp1
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|freed
condition|)
do|;
comment|/* 				 * if we found free space, then retry with the same buffer. 				 */
if|if
condition|(
name|totfree
condition|)
goto|goto
name|findkvaspace
goto|;
block|}
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|trytofreespace
goto|;
block|}
block|}
comment|/* 	 * See if we are below are allocated minimum 	 */
if|if
condition|(
name|bufspace
operator|>=
operator|(
name|maxbufspace
operator|+
name|nbyteswritten
operator|)
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|trytofreespace
goto|;
block|}
comment|/* 	 * create a map entry for the buffer -- in essence 	 * reserving the kva space. 	 */
if|if
condition|(
name|addr
condition|)
block|{
name|vm_map_insert
argument_list|(
name|buffer_map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|addr
argument_list|,
name|addr
operator|+
name|maxsize
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|MAP_NOFAULT
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_kvabase
operator|=
operator|(
name|caddr_t
operator|)
name|addr
expr_stmt|;
name|bp
operator|->
name|b_kvasize
operator|=
name|maxsize
expr_stmt|;
block|}
name|bp
operator|->
name|b_data
operator|=
name|bp
operator|->
name|b_kvabase
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|waitfreebuffers
parameter_list|(
name|int
name|slpflag
parameter_list|,
name|int
name|slptimeo
parameter_list|)
block|{
while|while
condition|(
name|numfreebuffers
operator|<
name|hifreebuffers
condition|)
block|{
name|flushdirtybuffers
argument_list|(
name|slpflag
argument_list|,
name|slptimeo
argument_list|)
expr_stmt|;
if|if
condition|(
name|numfreebuffers
operator|<
name|hifreebuffers
condition|)
break|break;
name|needsbuffer
operator||=
name|VFS_BIO_NEED_FREE
expr_stmt|;
if|if
condition|(
name|tsleep
argument_list|(
operator|&
name|needsbuffer
argument_list|,
operator|(
name|PRIBIO
operator|+
literal|4
operator|)
operator||
name|slpflag
argument_list|,
literal|"biofre"
argument_list|,
name|slptimeo
argument_list|)
condition|)
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|flushdirtybuffers
parameter_list|(
name|int
name|slpflag
parameter_list|,
name|int
name|slptimeo
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
specifier|static
name|pid_t
name|flushing
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|flushing
condition|)
block|{
if|if
condition|(
name|flushing
operator|==
name|curproc
operator|->
name|p_pid
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|flushing
condition|)
block|{
if|if
condition|(
name|tsleep
argument_list|(
operator|&
name|flushing
argument_list|,
operator|(
name|PRIBIO
operator|+
literal|4
operator|)
operator||
name|slpflag
argument_list|,
literal|"biofls"
argument_list|,
name|slptimeo
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|flushing
operator|=
name|curproc
operator|->
name|p_pid
expr_stmt|;
while|while
condition|(
name|numdirtybuffers
operator|>
name|lodirtybuffers
condition|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|needsbuffer
operator||=
name|VFS_BIO_NEED_LOWLIMIT
expr_stmt|;
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_AGE
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LRU
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|bp
operator|&&
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|bp
operator|=
name|TAILQ_NEXT
argument_list|(
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
condition|)
block|{
name|vfs_bio_awrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
name|flushing
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|flushing
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see if a block is currently memory resident.  */
end_comment

begin_function
name|struct
name|buf
modifier|*
name|incore
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|daddr_t
name|blkno
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
name|bp
operator|=
name|gbincore
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if no I/O is needed to access the  * associated VM object.  This is like incore except  * it also hunts around in the VM system for the data.  */
end_comment

begin_function
name|int
name|inmem
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|daddr_t
name|blkno
parameter_list|)
block|{
name|vm_object_t
name|obj
decl_stmt|;
name|vm_offset_t
name|toff
decl_stmt|,
name|tinc
decl_stmt|,
name|size
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|vm_ooffset_t
name|off
decl_stmt|;
if|if
condition|(
name|incore
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_object
operator|==
name|NULL
operator|)
operator|||
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|VOBJBUF
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|obj
operator|=
name|vp
operator|->
name|v_object
expr_stmt|;
name|size
operator|=
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
condition|)
name|size
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
expr_stmt|;
name|off
operator|=
operator|(
name|vm_ooffset_t
operator|)
name|blkno
operator|*
operator|(
name|vm_ooffset_t
operator|)
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
expr_stmt|;
for|for
control|(
name|toff
operator|=
literal|0
init|;
name|toff
operator|<
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
condition|;
name|toff
operator|+=
name|tinc
control|)
block|{
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|off
operator|+
name|toff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
literal|0
return|;
name|tinc
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|tinc
operator|>
name|PAGE_SIZE
operator|-
operator|(
operator|(
name|toff
operator|+
name|off
operator|)
operator|&
name|PAGE_MASK
operator|)
condition|)
name|tinc
operator|=
name|PAGE_SIZE
operator|-
operator|(
operator|(
name|toff
operator|+
name|off
operator|)
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|vm_page_is_valid
argument_list|(
name|m
argument_list|,
call|(
name|vm_offset_t
call|)
argument_list|(
operator|(
name|toff
operator|+
name|off
operator|)
operator|&
name|PAGE_MASK
argument_list|)
argument_list|,
name|tinc
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * now we set the dirty range for the buffer --  * for NFS -- if the file is mapped and pages have  * been written to, let it know.  We want the  * entire range of the buffer to be marked dirty if  * any of the pages have been written to for consistancy  * with the b_validoff, b_validend set in the nfs write  * code, and used by the nfs read code.  */
end_comment

begin_function
specifier|static
name|void
name|vfs_setdirty
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|vm_offset_t
name|boffset
decl_stmt|;
if|#
directive|if
literal|0
block|vm_offset_t offset;
endif|#
directive|endif
comment|/* 	 * We qualify the scan for modified pages on whether the 	 * object has been flushed yet.  The OBJ_WRITEABLE flag 	 * is not cleared simply by protecting pages off. 	 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
operator|)
operator|&&
operator|(
operator|(
name|object
operator|=
name|bp
operator|->
name|b_pages
index|[
literal|0
index|]
operator|->
name|object
operator|)
operator|->
name|flags
operator|&
operator|(
name|OBJ_WRITEABLE
operator||
name|OBJ_CLEANING
operator|)
operator|)
condition|)
block|{
comment|/* 		 * test the pages to see if they have been modified directly 		 * by users through the VM system. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
name|vm_page_flag_clear
argument_list|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
argument_list|,
name|PG_ZERO
argument_list|)
expr_stmt|;
name|vm_page_test_dirty
argument_list|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * scan forwards for the first page modified 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|->
name|dirty
condition|)
block|{
break|break;
block|}
block|}
name|boffset
operator|=
operator|(
name|i
operator|<<
name|PAGE_SHIFT
operator|)
operator|-
operator|(
name|bp
operator|->
name|b_offset
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|boffset
operator|<
name|bp
operator|->
name|b_dirtyoff
condition|)
block|{
name|bp
operator|->
name|b_dirtyoff
operator|=
name|max
argument_list|(
name|boffset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * scan backwards for the last page modified 		 */
for|for
control|(
name|i
operator|=
name|bp
operator|->
name|b_npages
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|->
name|dirty
condition|)
block|{
break|break;
block|}
block|}
name|boffset
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
if|#
directive|if
literal|0
block|offset = boffset + bp->b_pages[0]->pindex; 		if (offset>= object->size) 			boffset = object->size - bp->b_pages[0]->pindex;
endif|#
directive|endif
name|boffset
operator|=
operator|(
name|boffset
operator|<<
name|PAGE_SHIFT
operator|)
operator|-
operator|(
name|bp
operator|->
name|b_offset
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_dirtyend
operator|<
name|boffset
condition|)
name|bp
operator|->
name|b_dirtyend
operator|=
name|min
argument_list|(
name|boffset
argument_list|,
name|bp
operator|->
name|b_bufsize
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get a block given a specified block and offset into a file/device.  */
end_comment

begin_function
name|struct
name|buf
modifier|*
name|getblk
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|daddr_t
name|blkno
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|slpflag
parameter_list|,
name|int
name|slptimeo
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|bufhashhdr
modifier|*
name|bh
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
name|size
operator|>
name|MAXBSIZE
condition|)
name|panic
argument_list|(
literal|"getblk: size(%d)> MAXBSIZE(%d)\n"
argument_list|,
name|size
argument_list|,
name|MAXBSIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|loop
label|:
if|if
condition|(
name|numfreebuffers
operator|<
name|lofreebuffers
condition|)
block|{
name|waitfreebuffers
argument_list|(
name|slpflag
argument_list|,
name|slptimeo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bp
operator|=
name|gbincore
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_WANTED
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_usecount
operator|<
name|BUF_MAXUSE
condition|)
operator|++
name|bp
operator|->
name|b_usecount
expr_stmt|;
if|if
condition|(
operator|!
name|tsleep
argument_list|(
name|bp
argument_list|,
operator|(
name|PRIBIO
operator|+
literal|4
operator|)
operator||
name|slpflag
argument_list|,
literal|"getblk"
argument_list|,
name|slptimeo
argument_list|)
condition|)
block|{
goto|goto
name|loop
goto|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|buf
operator|*
operator|)
name|NULL
return|;
block|}
name|bp
operator|->
name|b_flags
operator||=
name|B_BUSY
operator||
name|B_CACHE
expr_stmt|;
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * check for size inconsistancies for non-VMIO case. 		 */
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|!=
name|size
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
operator|)
operator|==
literal|0
operator|||
operator|(
name|size
operator|>
name|bp
operator|->
name|b_kvasize
operator|)
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_NOCACHE
expr_stmt|;
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
operator|)
operator|&&
operator|(
name|LIST_FIRST
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_RELBUF
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_NOCACHE
expr_stmt|;
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|loop
goto|;
block|}
block|}
comment|/* 		 * If the size is inconsistant in the VMIO case, we can resize 		 * the buffer.  This might lead to B_CACHE getting cleared. 		 */
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|!=
name|size
condition|)
name|allocbuf
argument_list|(
name|bp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bp
operator|->
name|b_offset
operator|!=
name|NOOFFSET
argument_list|,
operator|(
literal|"getblk: no buffer offset"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Check that the constituted buffer really deserves for the 		 * B_CACHE bit to be set.  B_VMIO type buffers might not 		 * contain fully valid pages.  Normal (old-style) buffers 		 * should be fully valid.  This might also lead to B_CACHE 		 * getting clear. 		 * 		 * If B_CACHE is already clear, don't bother checking to see  		 * if we have to clear it again. 		 * 		 * XXX this code should not be necessary unless the B_CACHE 		 * handling is broken elsewhere in the kernel.  We need to 		 * check the cases and then turn the clearing part of this 		 * code into a panic. 		 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_VMIO
operator||
name|B_CACHE
operator|)
operator|)
operator|==
operator|(
name|B_VMIO
operator||
name|B_CACHE
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_vp
operator|->
name|v_tag
operator|!=
name|VT_NFS
operator|||
name|bp
operator|->
name|b_validend
operator|<=
literal|0
operator|)
condition|)
block|{
name|int
name|checksize
init|=
name|bp
operator|->
name|b_bufsize
decl_stmt|;
name|int
name|poffset
init|=
name|bp
operator|->
name|b_offset
operator|&
name|PAGE_MASK
decl_stmt|;
name|int
name|resid
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
name|resid
operator|=
operator|(
name|checksize
operator|>
operator|(
name|PAGE_SIZE
operator|-
name|poffset
operator|)
operator|)
condition|?
operator|(
name|PAGE_SIZE
operator|-
name|poffset
operator|)
else|:
name|checksize
expr_stmt|;
if|if
condition|(
operator|!
name|vm_page_is_valid
argument_list|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
argument_list|,
name|poffset
argument_list|,
name|resid
argument_list|)
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_CACHE
operator||
name|B_DONE
operator|)
expr_stmt|;
break|break;
block|}
name|checksize
operator|-=
name|resid
expr_stmt|;
name|poffset
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 		 * If B_DELWRI is set and B_CACHE got cleared ( or was 		 * already clear ), we have to commit the write and 		 * retry.  The NFS code absolutely depends on this, 		 * and so might the FFS code.  In anycase, it formalizes 		 * the B_CACHE rules.  See sys/buf.h. 		 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_CACHE
operator||
name|B_DELWRI
operator|)
operator|)
operator|==
name|B_DELWRI
condition|)
block|{
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_usecount
operator|<
name|BUF_MAXUSE
condition|)
operator|++
name|bp
operator|->
name|b_usecount
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
else|else
block|{
name|int
name|bsize
decl_stmt|,
name|maxsize
decl_stmt|,
name|vmio
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VBLK
condition|)
name|bsize
operator|=
name|DEV_BSIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|vp
operator|->
name|v_mountedhere
condition|)
name|bsize
operator|=
name|vp
operator|->
name|v_mountedhere
operator|->
name|mnt_stat
operator|.
name|f_iosize
expr_stmt|;
elseif|else
if|if
condition|(
name|vp
operator|->
name|v_mount
condition|)
name|bsize
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
expr_stmt|;
else|else
name|bsize
operator|=
name|size
expr_stmt|;
name|offset
operator|=
operator|(
name|off_t
operator|)
name|blkno
operator|*
name|bsize
expr_stmt|;
name|vmio
operator|=
operator|(
name|vp
operator|->
name|v_object
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|VOBJBUF
operator|)
expr_stmt|;
name|maxsize
operator|=
name|vmio
condition|?
name|size
operator|+
operator|(
name|offset
operator|&
name|PAGE_MASK
operator|)
else|:
name|size
expr_stmt|;
name|maxsize
operator|=
name|imax
argument_list|(
name|maxsize
argument_list|,
name|bsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|getnewbuf
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|,
name|slpflag
argument_list|,
name|slptimeo
argument_list|,
name|size
argument_list|,
name|maxsize
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|slpflag
operator|||
name|slptimeo
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
goto|goto
name|loop
goto|;
block|}
comment|/* 		 * This code is used to make sure that a buffer is not 		 * created while the getnewbuf routine is blocked. 		 * Normally the vnode is locked so this isn't a problem. 		 * VBLK type I/O requests, however, don't lock the vnode. 		 */
if|if
condition|(
name|gbincore
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|)
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
comment|/* 		 * Insert the buffer into the hash, so that it can 		 * be found by incore. 		 */
name|bp
operator|->
name|b_blkno
operator|=
name|bp
operator|->
name|b_lblkno
operator|=
name|blkno
expr_stmt|;
name|bp
operator|->
name|b_offset
operator|=
name|offset
expr_stmt|;
name|bgetvp
argument_list|(
name|vp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
name|bh
operator|=
name|BUFHASH
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|bh
argument_list|,
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|vmio
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
operator|(
name|B_VMIO
operator||
name|B_CACHE
operator|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VFS_BIO_DEBUG
argument_list|)
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VBLK
condition|)
name|printf
argument_list|(
literal|"getblk: vmioing file type %d???\n"
argument_list|,
name|vp
operator|->
name|v_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_VMIO
expr_stmt|;
block|}
name|allocbuf
argument_list|(
name|bp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get an empty, disassociated buffer of given size.  */
end_comment

begin_function
name|struct
name|buf
modifier|*
name|geteblk
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|getnewbuf
argument_list|(
literal|0
argument_list|,
operator|(
name|daddr_t
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|size
argument_list|,
name|MAXBSIZE
argument_list|)
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|allocbuf
argument_list|(
name|bp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
expr_stmt|;
comment|/* b_dep cleared by getnewbuf() */
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This code constitutes the buffer memory from either anonymous system  * memory (in the case of non-VMIO operations) or from an associated  * VM object (in the case of VMIO operations).  This code is able to  * resize a buffer up or down.  *  * Note that this code is tricky, and has many complications to resolve  * deadlock or inconsistant data situations.  Tread lightly!!!   * There are B_CACHE and B_DELWRI interactions that must be dealt with by   * the caller.  Calling this code willy nilly can result in the loss of data.  */
end_comment

begin_function
name|int
name|allocbuf
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|newbsize
decl_stmt|,
name|mbsize
decl_stmt|;
name|int
name|i
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
operator|)
condition|)
name|panic
argument_list|(
literal|"allocbuf: buffer not busy"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_kvasize
operator|<
name|size
condition|)
name|panic
argument_list|(
literal|"allocbuf: buffer too small"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
operator|)
operator|==
literal|0
condition|)
block|{
name|caddr_t
name|origbuf
decl_stmt|;
name|int
name|origbufsize
decl_stmt|;
comment|/* 		 * Just get anonymous memory from the kernel 		 */
name|mbsize
operator|=
operator|(
name|size
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|DEV_BSIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_B_MALLOC
argument_list|)
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_MALLOC
condition|)
name|newbsize
operator|=
name|mbsize
expr_stmt|;
else|else
endif|#
directive|endif
name|newbsize
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|newbsize
operator|<
name|bp
operator|->
name|b_bufsize
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_B_MALLOC
argument_list|)
comment|/* 			 * malloced buffers are not shrunk 			 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_MALLOC
condition|)
block|{
if|if
condition|(
name|newbsize
condition|)
block|{
name|bp
operator|->
name|b_bcount
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|M_BIOBUF
argument_list|)
expr_stmt|;
name|bufspace
operator|-=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
name|bufmallocspace
operator|-=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
name|bp
operator|->
name|b_data
operator|=
name|bp
operator|->
name|b_kvabase
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_MALLOC
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
endif|#
directive|endif
name|vm_hold_free_pages
argument_list|(
name|bp
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
operator|+
name|newbsize
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
operator|+
name|bp
operator|->
name|b_bufsize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newbsize
operator|>
name|bp
operator|->
name|b_bufsize
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_B_MALLOC
argument_list|)
comment|/* 			 * We only use malloced memory on the first allocation. 			 * and revert to page-allocated memory when the buffer grows. 			 */
if|if
condition|(
operator|(
name|bufmallocspace
operator|<
name|maxbufmallocspace
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_bufsize
operator|==
literal|0
operator|)
operator|&&
operator|(
name|mbsize
operator|<=
name|PAGE_SIZE
operator|/
literal|2
operator|)
condition|)
block|{
name|bp
operator|->
name|b_data
operator|=
name|malloc
argument_list|(
name|mbsize
argument_list|,
name|M_BIOBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
name|mbsize
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|size
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_MALLOC
expr_stmt|;
name|bufspace
operator|+=
name|mbsize
expr_stmt|;
name|bufmallocspace
operator|+=
name|mbsize
expr_stmt|;
return|return
literal|1
return|;
block|}
endif|#
directive|endif
name|origbuf
operator|=
name|NULL
expr_stmt|;
name|origbufsize
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_B_MALLOC
argument_list|)
comment|/* 			 * If the buffer is growing on its other-than-first allocation, 			 * then we revert to the page-allocation scheme. 			 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_MALLOC
condition|)
block|{
name|origbuf
operator|=
name|bp
operator|->
name|b_data
expr_stmt|;
name|origbufsize
operator|=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
name|bp
operator|->
name|b_data
operator|=
name|bp
operator|->
name|b_kvabase
expr_stmt|;
name|bufspace
operator|-=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
name|bufmallocspace
operator|-=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_MALLOC
expr_stmt|;
name|newbsize
operator|=
name|round_page
argument_list|(
name|newbsize
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|vm_hold_load_pages
argument_list|(
name|bp
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
operator|+
name|bp
operator|->
name|b_bufsize
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
operator|+
name|newbsize
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_B_MALLOC
argument_list|)
if|if
condition|(
name|origbuf
condition|)
block|{
name|bcopy
argument_list|(
name|origbuf
argument_list|,
name|bp
operator|->
name|b_data
argument_list|,
name|origbufsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|origbuf
argument_list|,
name|M_BIOBUF
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|vm_page_t
name|m
decl_stmt|;
name|int
name|desiredpages
decl_stmt|;
name|newbsize
operator|=
operator|(
name|size
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|DEV_BSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|desiredpages
operator|=
operator|(
name|size
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|num_pages
argument_list|(
operator|(
name|bp
operator|->
name|b_offset
operator|&
name|PAGE_MASK
operator|)
operator|+
name|newbsize
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|NO_B_MALLOC
argument_list|)
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_MALLOC
condition|)
name|panic
argument_list|(
literal|"allocbuf: VMIO buffer can't be malloced"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|newbsize
operator|<
name|bp
operator|->
name|b_bufsize
condition|)
block|{
if|if
condition|(
name|desiredpages
operator|<
name|bp
operator|->
name|b_npages
condition|)
block|{
for|for
control|(
name|i
operator|=
name|desiredpages
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
comment|/* 					 * the page is not freed here -- it 					 * is the responsibility of vnode_pager_setsize 					 */
name|m
operator|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|!=
name|bogus_page
argument_list|,
operator|(
literal|"allocbuf: bogus page found"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|vm_page_sleep_busy
argument_list|(
name|m
argument_list|,
name|TRUE
argument_list|,
literal|"biodep"
argument_list|)
condition|)
empty_stmt|;
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|pmap_qremove
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
argument_list|)
operator|+
operator|(
name|desiredpages
operator|<<
name|PAGE_SHIFT
operator|)
argument_list|,
operator|(
name|bp
operator|->
name|b_npages
operator|-
name|desiredpages
operator|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_npages
operator|=
name|desiredpages
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|newbsize
operator|>
name|bp
operator|->
name|b_bufsize
condition|)
block|{
name|vm_object_t
name|obj
decl_stmt|;
name|vm_offset_t
name|tinc
decl_stmt|,
name|toff
decl_stmt|;
name|vm_ooffset_t
name|off
decl_stmt|;
name|vm_pindex_t
name|objoff
decl_stmt|;
name|int
name|pageindex
decl_stmt|,
name|curbpnpages
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|bsize
decl_stmt|;
name|int
name|orig_validoff
init|=
name|bp
operator|->
name|b_validoff
decl_stmt|;
name|int
name|orig_validend
init|=
name|bp
operator|->
name|b_validend
decl_stmt|;
name|vp
operator|=
name|bp
operator|->
name|b_vp
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VBLK
condition|)
name|bsize
operator|=
name|DEV_BSIZE
expr_stmt|;
else|else
name|bsize
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_npages
operator|<
name|desiredpages
condition|)
block|{
name|obj
operator|=
name|vp
operator|->
name|v_object
expr_stmt|;
name|tinc
operator|=
name|PAGE_SIZE
expr_stmt|;
name|off
operator|=
name|bp
operator|->
name|b_offset
expr_stmt|;
name|KASSERT
argument_list|(
name|bp
operator|->
name|b_offset
operator|!=
name|NOOFFSET
argument_list|,
operator|(
literal|"allocbuf: no buffer offset"
operator|)
argument_list|)
expr_stmt|;
name|curbpnpages
operator|=
name|bp
operator|->
name|b_npages
expr_stmt|;
name|doretry
label|:
name|bp
operator|->
name|b_validoff
operator|=
name|orig_validoff
expr_stmt|;
name|bp
operator|->
name|b_validend
operator|=
name|orig_validend
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_CACHE
expr_stmt|;
for|for
control|(
name|toff
operator|=
literal|0
init|;
name|toff
operator|<
name|newbsize
condition|;
name|toff
operator|+=
name|tinc
control|)
block|{
name|objoff
operator|=
name|OFF_TO_IDX
argument_list|(
name|off
operator|+
name|toff
argument_list|)
expr_stmt|;
name|pageindex
operator|=
name|objoff
operator|-
name|OFF_TO_IDX
argument_list|(
name|off
argument_list|)
expr_stmt|;
name|tinc
operator|=
name|PAGE_SIZE
operator|-
operator|(
operator|(
name|off
operator|+
name|toff
operator|)
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|pageindex
operator|<
name|curbpnpages
condition|)
block|{
name|m
operator|=
name|bp
operator|->
name|b_pages
index|[
name|pageindex
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|VFS_BIO_DIAG
if|if
condition|(
name|m
operator|->
name|pindex
operator|!=
name|objoff
condition|)
name|panic
argument_list|(
literal|"allocbuf: page changed offset?!!!?"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tinc
operator|>
operator|(
name|newbsize
operator|-
name|toff
operator|)
condition|)
name|tinc
operator|=
name|newbsize
operator|-
name|toff
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CACHE
condition|)
name|vfs_buf_set_valid
argument_list|(
name|bp
argument_list|,
name|off
argument_list|,
name|toff
argument_list|,
name|tinc
argument_list|,
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
name|objoff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|m
operator|=
name|vm_page_alloc
argument_list|(
name|obj
argument_list|,
name|objoff
argument_list|,
name|VM_ALLOC_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|VM_WAIT
expr_stmt|;
name|vm_pageout_deficit
operator|+=
operator|(
name|desiredpages
operator|-
name|curbpnpages
operator|)
expr_stmt|;
goto|goto
name|doretry
goto|;
block|}
name|vm_page_wire
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_CACHE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vm_page_sleep_busy
argument_list|(
name|m
argument_list|,
name|FALSE
argument_list|,
literal|"pgtblk"
argument_list|)
condition|)
block|{
comment|/* 						 *  If we had to sleep, retry. 						 * 						 *  Also note that we only test 						 *  PG_BUSY here, not m->busy. 						 *   						 *  We cannot sleep on m->busy 						 *  here because a vm_fault -> 						 *  getpages -> cluster-read -> 						 *  ...-> allocbuf sequence  						 *  will convert PG_BUSY to 						 *  m->busy so we have to let  						 *  m->busy through if we do  						 *  not want to deadlock. 						 */
goto|goto
name|doretry
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|curproc
operator|!=
name|pageproc
operator|)
operator|&&
operator|(
operator|(
name|m
operator|->
name|queue
operator|-
name|m
operator|->
name|pc
operator|)
operator|==
name|PQ_CACHE
operator|)
operator|&&
operator|(
operator|(
name|cnt
operator|.
name|v_free_count
operator|+
name|cnt
operator|.
name|v_cache_count
operator|)
operator|<
operator|(
name|cnt
operator|.
name|v_free_min
operator|+
name|cnt
operator|.
name|v_cache_min
operator|)
operator|)
condition|)
block|{
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|tinc
operator|>
operator|(
name|newbsize
operator|-
name|toff
operator|)
condition|)
name|tinc
operator|=
name|newbsize
operator|-
name|toff
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CACHE
condition|)
name|vfs_buf_set_valid
argument_list|(
name|bp
argument_list|,
name|off
argument_list|,
name|toff
argument_list|,
name|tinc
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_ZERO
argument_list|)
expr_stmt|;
name|vm_page_wire
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_pages
index|[
name|pageindex
index|]
operator|=
name|m
expr_stmt|;
name|curbpnpages
operator|=
name|pageindex
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_tag
operator|==
name|VT_NFS
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VBLK
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_dirtyend
operator|>
literal|0
condition|)
block|{
name|bp
operator|->
name|b_validoff
operator|=
name|min
argument_list|(
name|bp
operator|->
name|b_validoff
argument_list|,
name|bp
operator|->
name|b_dirtyoff
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_validend
operator|=
name|max
argument_list|(
name|bp
operator|->
name|b_validend
argument_list|,
name|bp
operator|->
name|b_dirtyend
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_validend
operator|==
literal|0
condition|)
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_CACHE
expr_stmt|;
block|}
name|bp
operator|->
name|b_data
operator|=
operator|(
name|caddr_t
operator|)
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_npages
operator|=
name|curbpnpages
expr_stmt|;
name|pmap_qenter
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_pages
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
operator|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
operator|)
operator||=
name|off
operator|&
name|PAGE_MASK
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
condition|)
name|vmiospace
operator|+=
operator|(
name|newbsize
operator|-
name|bp
operator|->
name|b_bufsize
operator|)
expr_stmt|;
name|bufspace
operator|+=
operator|(
name|newbsize
operator|-
name|bp
operator|->
name|b_bufsize
operator|)
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
name|newbsize
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|size
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Wait for buffer I/O completion, returning error status.  */
end_comment

begin_function
name|int
name|biowait
parameter_list|(
specifier|register
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
operator|)
operator|==
literal|0
condition|)
if|#
directive|if
name|defined
argument_list|(
name|NO_SCHEDULE_MODS
argument_list|)
name|tsleep
argument_list|(
name|bp
argument_list|,
name|PRIBIO
argument_list|,
literal|"biowait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
condition|)
name|tsleep
argument_list|(
name|bp
argument_list|,
name|PRIBIO
argument_list|,
literal|"biord"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|tsleep
argument_list|(
name|bp
argument_list|,
name|PRIBIO
argument_list|,
literal|"biowr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_EINTR
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_EINTR
expr_stmt|;
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
return|return
operator|(
name|bp
operator|->
name|b_error
condition|?
name|bp
operator|->
name|b_error
else|:
name|EIO
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Finish I/O on a buffer, calling an optional function.  * This is usually called from interrupt level, so process blocking  * is not *a good idea*.  */
end_comment

begin_function
name|void
name|biodone
parameter_list|(
specifier|register
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
operator|)
condition|)
name|panic
argument_list|(
literal|"biodone: buffer not busy"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
name|printf
argument_list|(
literal|"biodone: buffer already done\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|bp
operator|->
name|b_flags
operator||=
name|B_DONE
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_FREEBUF
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
block|{
name|vwakeup
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* call optional completion function if requested */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CALL
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_CALL
expr_stmt|;
call|(
modifier|*
name|bp
operator|->
name|b_iodone
call|)
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|bp
operator|->
name|b_dep
argument_list|)
operator|!=
name|NULL
operator|&&
name|bioops
operator|.
name|io_complete
condition|)
call|(
modifier|*
name|bioops
operator|.
name|io_complete
call|)
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
condition|)
block|{
name|int
name|i
decl_stmt|,
name|resid
decl_stmt|;
name|vm_ooffset_t
name|foff
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|vm_object_t
name|obj
decl_stmt|;
name|int
name|iosize
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|bp
operator|->
name|b_vp
decl_stmt|;
name|obj
operator|=
name|vp
operator|->
name|v_object
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VFS_BIO_DEBUG
argument_list|)
if|if
condition|(
name|vp
operator|->
name|v_usecount
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"biodone: zero vnode ref count"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_object
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"biodone: missing VM object"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|VOBJBUF
operator|)
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"biodone: vnode is not setup for merged cache"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|foff
operator|=
name|bp
operator|->
name|b_offset
expr_stmt|;
name|KASSERT
argument_list|(
name|bp
operator|->
name|b_offset
operator|!=
name|NOOFFSET
argument_list|,
operator|(
literal|"biodone: no buffer offset"
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|panic
argument_list|(
literal|"biodone: no object"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|VFS_BIO_DEBUG
argument_list|)
if|if
condition|(
name|obj
operator|->
name|paging_in_progress
operator|<
name|bp
operator|->
name|b_npages
condition|)
block|{
name|printf
argument_list|(
literal|"biodone: paging in progress(%d)< bp->b_npages(%d)\n"
argument_list|,
name|obj
operator|->
name|paging_in_progress
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|iosize
operator|=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bogusflag
init|=
literal|0
decl_stmt|;
name|m
operator|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|bogus_page
condition|)
block|{
name|bogusflag
operator|=
literal|1
expr_stmt|;
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|foff
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|VFS_BIO_DEBUG
argument_list|)
name|printf
argument_list|(
literal|"biodone: page disappeared\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vm_object_pip_subtract
argument_list|(
name|obj
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|=
name|m
expr_stmt|;
name|pmap_qenter
argument_list|(
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
argument_list|)
argument_list|,
name|bp
operator|->
name|b_pages
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|VFS_BIO_DEBUG
argument_list|)
if|if
condition|(
name|OFF_TO_IDX
argument_list|(
name|foff
argument_list|)
operator|!=
name|m
operator|->
name|pindex
condition|)
block|{
name|printf
argument_list|(
literal|"biodone: foff(%lu)/m->pindex(%d) mismatch\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|foff
argument_list|,
name|m
operator|->
name|pindex
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|resid
operator|=
name|IDX_TO_OFF
argument_list|(
name|m
operator|->
name|pindex
operator|+
literal|1
argument_list|)
operator|-
name|foff
expr_stmt|;
if|if
condition|(
name|resid
operator|>
name|iosize
condition|)
name|resid
operator|=
name|iosize
expr_stmt|;
comment|/* 			 * In the write case, the valid and clean bits are 			 * already changed correctly, so we only need to do this 			 * here in the read case. 			 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|&&
operator|!
name|bogusflag
operator|&&
name|resid
operator|>
literal|0
condition|)
block|{
name|vfs_page_set_valid
argument_list|(
name|bp
argument_list|,
name|foff
argument_list|,
name|i
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_ZERO
argument_list|)
expr_stmt|;
comment|/* 			 * when debugging new filesystems or buffer I/O methods, this 			 * is the most common error that pops up.  if you see this, you 			 * have not set the page busy flag correctly!!! 			 */
if|if
condition|(
name|m
operator|->
name|busy
operator|==
literal|0
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
name|printf
argument_list|(
literal|"biodone: page busy< 0, "
literal|"pindex: %d, foff: 0x(%x,%x), "
literal|"resid: %d, index: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|m
operator|->
name|pindex
argument_list|,
call|(
name|int
call|)
argument_list|(
name|foff
operator|>>
literal|32
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|foff
operator|&
literal|0xffffffff
argument_list|,
name|resid
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VBLK
condition|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
name|printf
argument_list|(
literal|" iosize: %ld, lblkno: %d, flags: 0x%lx, npages: %d\n"
argument_list|,
name|bp
operator|->
name|b_vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
argument_list|,
operator|(
name|int
operator|)
name|bp
operator|->
name|b_lblkno
argument_list|,
name|bp
operator|->
name|b_flags
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" VDEV, lblkno: %d, flags: 0x%lx, npages: %d\n"
argument_list|,
operator|(
name|int
operator|)
name|bp
operator|->
name|b_lblkno
argument_list|,
name|bp
operator|->
name|b_flags
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" valid: 0x%x, dirty: 0x%x, wired: %d\n"
argument_list|,
name|m
operator|->
name|valid
argument_list|,
name|m
operator|->
name|dirty
argument_list|,
name|m
operator|->
name|wire_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|panic
argument_list|(
literal|"biodone: page busy< 0\n"
argument_list|)
expr_stmt|;
block|}
name|vm_page_io_finish
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_object_pip_subtract
argument_list|(
name|obj
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|foff
operator|+=
name|resid
expr_stmt|;
name|iosize
operator|-=
name|resid
expr_stmt|;
block|}
if|if
condition|(
name|obj
condition|)
name|vm_object_pip_wakeupn
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * For asynchronous completions, release the buffer now. The brelse 	 * checks for B_WANTED and will do the wakeup there if necessary - so 	 * no need to do a wakeup here in the async case. 	 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ASYNC
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_NOCACHE
operator||
name|B_INVAL
operator||
name|B_ERROR
operator||
name|B_RELBUF
operator|)
operator|)
operator|!=
literal|0
condition|)
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
else|else
name|bqrelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_WANTED
expr_stmt|;
name|wakeup
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* not with kirks code */
end_comment

begin_endif
unit|static int vfs_update_interval = 30;  static void vfs_update() { 	while (1) { 		tsleep(&vfs_update_wakeup, PUSER, "update", 		    hz * vfs_update_interval); 		vfs_update_wakeup = 0; 		sync(curproc, NULL); 	} }  static int sysctl_kern_updateinterval SYSCTL_HANDLER_ARGS { 	int error = sysctl_handle_int(oidp, 		oidp->oid_arg1, oidp->oid_arg2, req); 	if (!error) 		wakeup(&vfs_update_wakeup); 	return error; }  SYSCTL_PROC(_kern, KERN_UPDATEINTERVAL, update, CTLTYPE_INT|CTLFLAG_RW,&vfs_update_interval, 0, sysctl_kern_updateinterval, "I", "");
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This routine is called in lieu of iodone in the case of  * incomplete I/O.  This keeps the busy status for pages  * consistant.  */
end_comment

begin_function
name|void
name|vfs_unbusy_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
condition|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|bp
operator|->
name|b_vp
decl_stmt|;
name|vm_object_t
name|obj
init|=
name|vp
operator|->
name|v_object
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
name|vm_page_t
name|m
init|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|bogus_page
condition|)
block|{
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|bp
operator|->
name|b_offset
argument_list|)
operator|+
name|i
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|panic
argument_list|(
literal|"vfs_unbusy_pages: page missing\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|=
name|m
expr_stmt|;
name|pmap_qenter
argument_list|(
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
argument_list|)
argument_list|,
name|bp
operator|->
name|b_pages
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
block|}
name|vm_object_pip_subtract
argument_list|(
name|obj
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_ZERO
argument_list|)
expr_stmt|;
name|vm_page_io_finish
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|vm_object_pip_wakeupn
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set NFS' b_validoff and b_validend fields from the valid bits  * of a page.  If the consumer is not NFS, and the page is not  * valid for the entire range, clear the B_CACHE flag to force  * the consumer to re-read the page.  *  * B_CACHE interaction is especially tricky.  */
end_comment

begin_function
specifier|static
name|void
name|vfs_buf_set_valid
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|vm_ooffset_t
name|foff
parameter_list|,
name|vm_offset_t
name|off
parameter_list|,
name|vm_offset_t
name|size
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_vp
operator|->
name|v_tag
operator|==
name|VT_NFS
operator|&&
name|bp
operator|->
name|b_vp
operator|->
name|v_type
operator|!=
name|VBLK
condition|)
block|{
name|vm_offset_t
name|svalid
decl_stmt|,
name|evalid
decl_stmt|;
name|int
name|validbits
init|=
name|m
operator|->
name|valid
operator|>>
operator|(
operator|(
operator|(
name|foff
operator|+
name|off
operator|)
operator|&
name|PAGE_MASK
operator|)
operator|/
name|DEV_BSIZE
operator|)
decl_stmt|;
comment|/* 		 * This only bothers with the first valid range in the 		 * page. 		 */
name|svalid
operator|=
name|off
expr_stmt|;
while|while
condition|(
name|validbits
operator|&&
operator|!
operator|(
name|validbits
operator|&
literal|1
operator|)
condition|)
block|{
name|svalid
operator|+=
name|DEV_BSIZE
expr_stmt|;
name|validbits
operator|>>=
literal|1
expr_stmt|;
block|}
name|evalid
operator|=
name|svalid
expr_stmt|;
while|while
condition|(
name|validbits
operator|&
literal|1
condition|)
block|{
name|evalid
operator|+=
name|DEV_BSIZE
expr_stmt|;
name|validbits
operator|>>=
literal|1
expr_stmt|;
block|}
name|evalid
operator|=
name|min
argument_list|(
name|evalid
argument_list|,
name|off
operator|+
name|size
argument_list|)
expr_stmt|;
comment|/* 		 * We can only set b_validoff/end if this range is contiguous 		 * with the range built up already.  If we cannot set 		 * b_validoff/end, we must clear B_CACHE to force an update 		 * to clean the bp up. 		 */
if|if
condition|(
name|svalid
operator|==
name|bp
operator|->
name|b_validend
condition|)
block|{
name|bp
operator|->
name|b_validoff
operator|=
name|min
argument_list|(
name|bp
operator|->
name|b_validoff
argument_list|,
name|svalid
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_validend
operator|=
name|max
argument_list|(
name|bp
operator|->
name|b_validend
argument_list|,
name|evalid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_CACHE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|vm_page_is_valid
argument_list|(
name|m
argument_list|,
call|(
name|vm_offset_t
call|)
argument_list|(
operator|(
name|foff
operator|+
name|off
operator|)
operator|&
name|PAGE_MASK
argument_list|)
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_CACHE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set the valid bits in a page, taking care of the b_validoff,  * b_validend fields which NFS uses to optimise small reads.  Off is  * the offset within the file and pageno is the page index within the buf.  *  * XXX we have to set the valid& clean bits for all page fragments   * touched by b_validoff/validend, even if the page fragment goes somewhat  * beyond b_validoff/validend due to alignment.  */
end_comment

begin_function
specifier|static
name|void
name|vfs_page_set_valid
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|vm_ooffset_t
name|off
parameter_list|,
name|int
name|pageno
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|bp
operator|->
name|b_vp
decl_stmt|;
name|vm_ooffset_t
name|soff
decl_stmt|,
name|eoff
decl_stmt|;
name|soff
operator|=
name|off
expr_stmt|;
name|eoff
operator|=
operator|(
name|off
operator|+
name|PAGE_SIZE
operator|)
operator|&
operator|~
name|PAGE_MASK
expr_stmt|;
if|if
condition|(
name|eoff
operator|>
name|bp
operator|->
name|b_offset
operator|+
name|bp
operator|->
name|b_bufsize
condition|)
name|eoff
operator|=
name|bp
operator|->
name|b_offset
operator|+
name|bp
operator|->
name|b_bufsize
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_tag
operator|==
name|VT_NFS
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VBLK
condition|)
block|{
name|vm_ooffset_t
name|sv
decl_stmt|,
name|ev
decl_stmt|;
name|vm_page_set_invalid
argument_list|(
name|m
argument_list|,
call|(
name|vm_offset_t
call|)
argument_list|(
name|soff
operator|&
name|PAGE_MASK
argument_list|)
argument_list|,
call|(
name|vm_offset_t
call|)
argument_list|(
name|eoff
operator|-
name|soff
argument_list|)
argument_list|)
expr_stmt|;
name|sv
operator|=
operator|(
name|bp
operator|->
name|b_offset
operator|+
name|bp
operator|->
name|b_validoff
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|DEV_BSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|ev
operator|=
operator|(
name|bp
operator|->
name|b_offset
operator|+
name|bp
operator|->
name|b_validend
operator|+
operator|(
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|DEV_BSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|soff
operator|=
name|qmax
argument_list|(
name|sv
argument_list|,
name|soff
argument_list|)
expr_stmt|;
name|eoff
operator|=
name|qmin
argument_list|(
name|ev
argument_list|,
name|eoff
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eoff
operator|>
name|soff
condition|)
name|vm_page_set_validclean
argument_list|(
name|m
argument_list|,
call|(
name|vm_offset_t
call|)
argument_list|(
name|soff
operator|&
name|PAGE_MASK
argument_list|)
argument_list|,
call|(
name|vm_offset_t
call|)
argument_list|(
name|eoff
operator|-
name|soff
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine is called before a device strategy routine.  * It is used to tell the VM system that paging I/O is in  * progress, and treat the pages associated with the buffer  * almost as being PG_BUSY.  Also the object paging_in_progress  * flag is handled to make sure that the object doesn't become  * inconsistant.  */
end_comment

begin_function
name|void
name|vfs_busy_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
name|clear_modify
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|bogus
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
condition|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|bp
operator|->
name|b_vp
decl_stmt|;
name|vm_object_t
name|obj
init|=
name|vp
operator|->
name|v_object
decl_stmt|;
name|vm_ooffset_t
name|foff
decl_stmt|;
name|foff
operator|=
name|bp
operator|->
name|b_offset
expr_stmt|;
name|KASSERT
argument_list|(
name|bp
operator|->
name|b_offset
operator|!=
name|NOOFFSET
argument_list|,
operator|(
literal|"vfs_busy_pages: no buffer offset"
operator|)
argument_list|)
expr_stmt|;
name|vfs_setdirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|retry
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
name|vm_page_t
name|m
init|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|vm_page_sleep_busy
argument_list|(
name|m
argument_list|,
name|FALSE
argument_list|,
literal|"vbpage"
argument_list|)
condition|)
goto|goto
name|retry
goto|;
block|}
name|bogus
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
name|vm_page_t
name|m
init|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
decl_stmt|;
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CLUSTER
operator|)
operator|==
literal|0
condition|)
block|{
name|vm_object_pip_add
argument_list|(
name|obj
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm_page_io_start
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|vm_page_protect
argument_list|(
name|m
argument_list|,
name|VM_PROT_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|clear_modify
condition|)
name|vfs_page_set_valid
argument_list|(
name|bp
argument_list|,
name|foff
argument_list|,
name|i
argument_list|,
name|m
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|->
name|valid
operator|==
name|VM_PAGE_BITS_ALL
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CACHE
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|=
name|bogus_page
expr_stmt|;
name|bogus
operator|++
expr_stmt|;
block|}
name|foff
operator|=
operator|(
name|foff
operator|+
name|PAGE_SIZE
operator|)
operator|&
operator|~
name|PAGE_MASK
expr_stmt|;
block|}
if|if
condition|(
name|bogus
condition|)
name|pmap_qenter
argument_list|(
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
argument_list|)
argument_list|,
name|bp
operator|->
name|b_pages
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Tell the VM system that the pages associated with this buffer  * are clean.  This is used for delayed writes where the data is  * going to go to disk eventually without additional VM intevention.  */
end_comment

begin_function
name|void
name|vfs_clean_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
condition|)
block|{
name|vm_ooffset_t
name|foff
decl_stmt|;
name|foff
operator|=
name|bp
operator|->
name|b_offset
expr_stmt|;
name|KASSERT
argument_list|(
name|bp
operator|->
name|b_offset
operator|!=
name|NOOFFSET
argument_list|,
operator|(
literal|"vfs_clean_pages: no buffer offset"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
name|vm_page_t
name|m
init|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
decl_stmt|;
name|vfs_page_set_valid
argument_list|(
name|bp
argument_list|,
name|foff
argument_list|,
name|i
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|foff
operator|=
operator|(
name|foff
operator|+
name|PAGE_SIZE
operator|)
operator|&
operator|~
name|PAGE_MASK
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|vfs_bio_clrbuf
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|mask
init|=
literal|0
decl_stmt|;
name|caddr_t
name|sa
decl_stmt|,
name|ea
decl_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_VMIO
operator||
name|B_MALLOC
operator|)
operator|)
operator|==
name|B_VMIO
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_npages
operator|==
literal|1
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_bufsize
operator|<
name|PAGE_SIZE
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_offset
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
operator|(
literal|1
operator|<<
operator|(
name|bp
operator|->
name|b_bufsize
operator|/
name|DEV_BSIZE
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|bp
operator|->
name|b_pages
index|[
literal|0
index|]
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|bp
operator|->
name|b_pages
index|[
literal|0
index|]
operator|->
name|valid
operator|&
name|mask
operator|)
operator|!=
name|mask
operator|)
condition|)
block|{
name|bzero
argument_list|(
name|bp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_bufsize
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_pages
index|[
literal|0
index|]
operator|->
name|valid
operator||=
name|mask
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|ea
operator|=
name|sa
operator|=
name|bp
operator|->
name|b_data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
operator|,
name|sa
operator|=
name|ea
control|)
block|{
name|int
name|j
init|=
operator|(
operator|(
name|u_long
operator|)
name|sa
operator|&
name|PAGE_MASK
operator|)
operator|/
name|DEV_BSIZE
decl_stmt|;
name|ea
operator|=
operator|(
name|caddr_t
operator|)
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|sa
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|ea
operator|=
operator|(
name|caddr_t
operator|)
name|ulmin
argument_list|(
operator|(
name|u_long
operator|)
name|ea
argument_list|,
operator|(
name|u_long
operator|)
name|bp
operator|->
name|b_data
operator|+
name|bp
operator|->
name|b_bufsize
argument_list|)
expr_stmt|;
name|mask
operator|=
operator|(
operator|(
literal|1
operator|<<
operator|(
operator|(
name|ea
operator|-
name|sa
operator|)
operator|/
name|DEV_BSIZE
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
name|j
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|->
name|valid
operator|&
name|mask
operator|)
operator|==
name|mask
condition|)
continue|continue;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|->
name|valid
operator|&
name|mask
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|sa
argument_list|,
name|ea
operator|-
name|sa
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
init|;
name|sa
operator|<
name|ea
condition|;
name|sa
operator|+=
name|DEV_BSIZE
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|->
name|valid
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
operator|)
operator|==
literal|0
condition|)
name|bzero
argument_list|(
name|sa
argument_list|,
name|DEV_BSIZE
argument_list|)
expr_stmt|;
block|}
block|}
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|->
name|valid
operator||=
name|mask
expr_stmt|;
name|vm_page_flag_clear
argument_list|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
argument_list|,
name|PG_ZERO
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|clrbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * vm_hold_load_pages and vm_hold_unload pages get pages into  * a buffers address space.  The pages are anonymous and are  * not associated with a file object.  */
end_comment

begin_function
name|void
name|vm_hold_load_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|vm_offset_t
name|from
parameter_list|,
name|vm_offset_t
name|to
parameter_list|)
block|{
name|vm_offset_t
name|pg
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|;
name|int
name|index
decl_stmt|;
name|to
operator|=
name|round_page
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|from
operator|=
name|round_page
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|from
operator|-
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
argument_list|)
operator|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
for|for
control|(
name|pg
operator|=
name|from
init|;
name|pg
operator|<
name|to
condition|;
name|pg
operator|+=
name|PAGE_SIZE
operator|,
name|index
operator|++
control|)
block|{
name|tryagain
label|:
name|p
operator|=
name|vm_page_alloc
argument_list|(
name|kernel_object
argument_list|,
operator|(
operator|(
name|pg
operator|-
name|VM_MIN_KERNEL_ADDRESS
operator|)
operator|>>
name|PAGE_SHIFT
operator|)
argument_list|,
name|VM_ALLOC_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|vm_pageout_deficit
operator|+=
operator|(
name|to
operator|-
name|from
operator|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|VM_WAIT
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
name|vm_page_wire
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|vm_page_flag_clear
argument_list|(
name|p
argument_list|,
name|PG_ZERO
argument_list|)
expr_stmt|;
name|pmap_kenter
argument_list|(
name|pg
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_pages
index|[
name|index
index|]
operator|=
name|p
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_npages
operator|=
name|index
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vm_hold_free_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|vm_offset_t
name|from
parameter_list|,
name|vm_offset_t
name|to
parameter_list|)
block|{
name|vm_offset_t
name|pg
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|;
name|int
name|index
decl_stmt|,
name|newnpages
decl_stmt|;
name|from
operator|=
name|round_page
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|to
operator|=
name|round_page
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|newnpages
operator|=
name|index
operator|=
operator|(
name|from
operator|-
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
argument_list|)
operator|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
for|for
control|(
name|pg
operator|=
name|from
init|;
name|pg
operator|<
name|to
condition|;
name|pg
operator|+=
name|PAGE_SIZE
operator|,
name|index
operator|++
control|)
block|{
name|p
operator|=
name|bp
operator|->
name|b_pages
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|(
name|index
operator|<
name|bp
operator|->
name|b_npages
operator|)
condition|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAX_PERF
argument_list|)
if|if
condition|(
name|p
operator|->
name|busy
condition|)
block|{
name|printf
argument_list|(
literal|"vm_hold_free_pages: blkno: %d, lblkno: %d\n"
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_lblkno
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|bp
operator|->
name|b_pages
index|[
name|index
index|]
operator|=
name|NULL
expr_stmt|;
name|pmap_kremove
argument_list|(
name|pg
argument_list|)
expr_stmt|;
name|vm_page_busy
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|bp
operator|->
name|b_npages
operator|=
name|newnpages
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|buffer
argument_list|,
argument|db_show_buffer
argument_list|)
end_macro

begin_block
block|{
comment|/* get args */
name|struct
name|buf
modifier|*
name|bp
init|=
operator|(
expr|struct
name|buf
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
operator|!
name|have_addr
condition|)
block|{
name|db_printf
argument_list|(
literal|"usage: show buffer<addr>\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|db_printf
argument_list|(
literal|"b_proc = %p,\nb_flags = 0x%b\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|bp
operator|->
name|b_proc
argument_list|,
operator|(
name|u_int
operator|)
name|bp
operator|->
name|b_flags
argument_list|,
name|PRINT_BUF_FLAGS
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"b_error = %d, b_bufsize = %ld, b_bcount = %ld, "
literal|"b_resid = %ld\nb_dev = 0x%x, b_data = %p, "
literal|"b_blkno = %d, b_pblkno = %d\n"
argument_list|,
name|bp
operator|->
name|b_error
argument_list|,
name|bp
operator|->
name|b_bufsize
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|bp
operator|->
name|b_resid
argument_list|,
name|bp
operator|->
name|b_dev
argument_list|,
name|bp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|,
name|bp
operator|->
name|b_pblkno
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_npages
condition|)
block|{
name|int
name|i
decl_stmt|;
name|db_printf
argument_list|(
literal|"b_npages = %d, pages(OBJ, IDX, PA): "
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|m
operator|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
expr_stmt|;
name|db_printf
argument_list|(
literal|"(%p, 0x%lx, 0x%lx)"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|m
operator|->
name|object
argument_list|,
operator|(
name|u_long
operator|)
name|m
operator|->
name|pindex
argument_list|,
operator|(
name|u_long
operator|)
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|<
name|bp
operator|->
name|b_npages
condition|)
name|db_printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
block|}
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

end_unit

