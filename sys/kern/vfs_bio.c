begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1994 John S. Dyson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Absolutely no warranty of function or purpose is made by the author  *    John S. Dyson.  * 4. This work was done expressly for inclusion into FreeBSD.  Other use  *    is allowed if this notation is included.  * 5. Modifications may be freely made to this file if the above conditions  *    are met.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * this file contains a new buffer I/O scheme implementing a coherent  * VM object and buffer cache scheme.  Pains have been taken to make  * sure that the performance degradation associated with schemes such  * as this is not realized.  *  * Author:  John S. Dyson  * Significant help during the development and debugging phases  * had been provided by David Greenman, also of the FreeBSD core team.  */
end_comment

begin_define
define|#
directive|define
name|VMIO
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<miscfs/specfs/specdev.h>
end_include

begin_decl_stmt
name|struct
name|buf
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer header pool */
end_comment

begin_decl_stmt
name|int
name|nbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of buffer headers calculated 				 * elsewhere */
end_comment

begin_decl_stmt
name|struct
name|swqueue
name|bswlist
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|vm_hold_free_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|vm_offset_t
name|from
parameter_list|,
name|vm_offset_t
name|to
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|vm_hold_load_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|vm_offset_t
name|from
parameter_list|,
name|vm_offset_t
name|to
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|vfs_clean_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vfs_setdirty
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|needsbuffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Internal update daemon, process 3  *	The variable vfs_update_wakeup allows for internal syncs.  */
end_comment

begin_decl_stmt
name|int
name|vfs_update_wakeup
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * buffers base kva  */
end_comment

begin_decl_stmt
name|caddr_t
name|buffers_kva
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * bogus page -- for I/O to/from partially complete buffers  * this is a temporary solution to the problem, but it is not  * really that bad.  it would be better to split the buffer  * for input in the case of buffers partially already in memory,  * but the code is intricate enough already.  */
end_comment

begin_decl_stmt
name|vm_page_t
name|bogus_page
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|bogus_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bufspace
decl_stmt|,
name|maxbufspace
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * advisory minimum for size of LRU queue or VMIO queue  */
end_comment

begin_decl_stmt
name|int
name|minbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize buffer headers and related structures.  */
end_comment

begin_function
name|void
name|bufinit
parameter_list|()
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|bswlist
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|invalhash
argument_list|)
expr_stmt|;
comment|/* first, make a null hash table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUFHSZ
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|bufhashtbl
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* next, make a null set of free lists */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BUFFER_QUEUES
condition|;
name|i
operator|++
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|bufqueues
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|buffers_kva
operator|=
operator|(
name|caddr_t
operator|)
name|kmem_alloc_pageable
argument_list|(
name|buffer_map
argument_list|,
name|MAXBSIZE
operator|*
name|nbuf
argument_list|)
expr_stmt|;
comment|/* finally, initialize each buffer header and stick on empty q */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbuf
condition|;
name|i
operator|++
control|)
block|{
name|bp
operator|=
operator|&
name|buf
index|[
name|i
index|]
expr_stmt|;
name|bzero
argument_list|(
name|bp
argument_list|,
sizeof|sizeof
expr|*
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|=
name|B_INVAL
expr_stmt|;
comment|/* we're just an empty header */
name|bp
operator|->
name|b_dev
operator|=
name|NODEV
expr_stmt|;
name|bp
operator|->
name|b_rcred
operator|=
name|NOCRED
expr_stmt|;
name|bp
operator|->
name|b_wcred
operator|=
name|NOCRED
expr_stmt|;
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_EMPTY
expr_stmt|;
name|bp
operator|->
name|b_vnbufs
operator|.
name|le_next
operator|=
name|NOLIST
expr_stmt|;
name|bp
operator|->
name|b_data
operator|=
name|buffers_kva
operator|+
name|i
operator|*
name|MAXBSIZE
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_EMPTY
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|invalhash
argument_list|,
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
block|}
comment|/*  * maxbufspace is currently calculated to support all filesystem blocks  * to be 8K.  If you happen to use a 16K filesystem, the size of the buffer  * cache is still the same as it would be for 8K filesystems.  This  * keeps the size of the buffer cache "in check" for big block filesystems.  */
name|minbuf
operator|=
name|nbuf
operator|/
literal|3
expr_stmt|;
name|maxbufspace
operator|=
literal|2
operator|*
operator|(
name|nbuf
operator|+
literal|8
operator|)
operator|*
name|PAGE_SIZE
expr_stmt|;
name|bogus_offset
operator|=
name|kmem_alloc_pageable
argument_list|(
name|kernel_map
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|bogus_page
operator|=
name|vm_page_alloc
argument_list|(
name|kernel_object
argument_list|,
name|bogus_offset
operator|-
name|VM_MIN_KERNEL_ADDRESS
argument_list|,
name|VM_ALLOC_NORMAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove the buffer from the appropriate free list  */
end_comment

begin_function
name|void
name|bremfree
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_qindex
operator|!=
name|QUEUE_NONE
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|bufqueues
index|[
name|bp
operator|->
name|b_qindex
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_NONE
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"bremfree: removing a buffer when not on a queue"
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a buffer with the specified data.  Look in the cache first.  */
end_comment

begin_function
name|int
name|bread
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|daddr_t
name|blkno
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|buf
modifier|*
modifier|*
name|bpp
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|getblk
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|bpp
operator|=
name|bp
expr_stmt|;
comment|/* if not found in cache, do some I/O */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CACHE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|curproc
operator|!=
name|NULL
condition|)
name|curproc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_inblock
operator|++
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_READ
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_DONE
operator||
name|B_ERROR
operator||
name|B_INVAL
operator|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_rcred
operator|==
name|NOCRED
condition|)
block|{
if|if
condition|(
name|cred
operator|!=
name|NOCRED
condition|)
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_rcred
operator|=
name|cred
expr_stmt|;
block|}
name|vfs_busy_pages
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_STRATEGY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|biowait
argument_list|(
name|bp
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Operates like bread, but also starts asynchronous I/O on  * read-ahead blocks.  */
end_comment

begin_function
name|int
name|breadn
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|daddr_t
name|blkno
parameter_list|,
name|int
name|size
parameter_list|,
name|daddr_t
modifier|*
name|rablkno
parameter_list|,
name|int
modifier|*
name|rabsize
parameter_list|,
name|int
name|cnt
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|buf
modifier|*
modifier|*
name|bpp
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|,
modifier|*
name|rabp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|,
name|readwait
init|=
literal|0
decl_stmt|;
operator|*
name|bpp
operator|=
name|bp
operator|=
name|getblk
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* if not found in cache, do some I/O */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CACHE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|curproc
operator|!=
name|NULL
condition|)
name|curproc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_inblock
operator|++
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_READ
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_DONE
operator||
name|B_ERROR
operator||
name|B_INVAL
operator|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_rcred
operator|==
name|NOCRED
condition|)
block|{
if|if
condition|(
name|cred
operator|!=
name|NOCRED
condition|)
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_rcred
operator|=
name|cred
expr_stmt|;
block|}
name|vfs_busy_pages
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_STRATEGY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
operator|++
name|readwait
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
operator|,
name|rablkno
operator|++
operator|,
name|rabsize
operator|++
control|)
block|{
if|if
condition|(
name|inmem
argument_list|(
name|vp
argument_list|,
operator|*
name|rablkno
argument_list|)
condition|)
continue|continue;
name|rabp
operator|=
name|getblk
argument_list|(
name|vp
argument_list|,
operator|*
name|rablkno
argument_list|,
operator|*
name|rabsize
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rabp
operator|->
name|b_flags
operator|&
name|B_CACHE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|curproc
operator|!=
name|NULL
condition|)
name|curproc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_inblock
operator|++
expr_stmt|;
name|rabp
operator|->
name|b_flags
operator||=
name|B_READ
operator||
name|B_ASYNC
expr_stmt|;
name|rabp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_DONE
operator||
name|B_ERROR
operator||
name|B_INVAL
operator|)
expr_stmt|;
if|if
condition|(
name|rabp
operator|->
name|b_rcred
operator|==
name|NOCRED
condition|)
block|{
if|if
condition|(
name|cred
operator|!=
name|NOCRED
condition|)
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|rabp
operator|->
name|b_rcred
operator|=
name|cred
expr_stmt|;
block|}
name|vfs_busy_pages
argument_list|(
name|rabp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_STRATEGY
argument_list|(
name|rabp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|brelse
argument_list|(
name|rabp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|readwait
condition|)
block|{
name|rv
operator|=
name|biowait
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write, release buffer on completion.  (Done by iodone  * if async.)  */
end_comment

begin_function
name|int
name|bwrite
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|oldflags
init|=
name|bp
operator|->
name|b_flags
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_INVAL
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
operator|)
condition|)
name|panic
argument_list|(
literal|"bwrite: buffer is not busy???"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_READ
operator||
name|B_DONE
operator||
name|B_ERROR
operator||
name|B_DELWRI
operator|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_WRITEINPROG
expr_stmt|;
if|if
condition|(
operator|(
name|oldflags
operator|&
operator|(
name|B_ASYNC
operator||
name|B_DELWRI
operator|)
operator|)
operator|==
operator|(
name|B_ASYNC
operator||
name|B_DELWRI
operator|)
condition|)
block|{
name|reassignbuf
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|b_vp
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_vp
operator|->
name|v_numoutput
operator|++
expr_stmt|;
name|vfs_busy_pages
argument_list|(
name|bp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|curproc
operator|!=
name|NULL
condition|)
name|curproc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_oublock
operator|++
expr_stmt|;
name|VOP_STRATEGY
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oldflags
operator|&
name|B_ASYNC
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|rtval
init|=
name|biowait
argument_list|(
name|bp
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldflags
operator|&
name|B_DELWRI
condition|)
block|{
name|reassignbuf
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|b_vp
argument_list|)
expr_stmt|;
block|}
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rtval
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vn_bwrite
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_bwrite_args
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|bwrite
argument_list|(
name|ap
operator|->
name|a_bp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delayed write. (Buffer is marked dirty).  */
end_comment

begin_function
name|void
name|bdwrite
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
operator|)
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"bdwrite: buffer is not busy"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_INVAL
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_TAPE
condition|)
block|{
name|bawrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_READ
operator||
name|B_RELBUF
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DELWRI
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_DONE
operator||
name|B_DELWRI
expr_stmt|;
name|reassignbuf
argument_list|(
name|bp
argument_list|,
name|bp
operator|->
name|b_vp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This bmap keeps the system from needing to do the bmap later, 	 * perhaps when the system is attempting to do a sync.  Since it 	 * is likely that the indirect block -- or whatever other datastructure 	 * that the filesystem needs is still in memory now, it is a good 	 * thing to do this.  Note also, that if the pageout daemon is 	 * requesting a sync -- there might not be enough memory to do 	 * the bmap then...  So, this is important to do. 	 */
if|if
condition|(
name|bp
operator|->
name|b_lblkno
operator|==
name|bp
operator|->
name|b_blkno
condition|)
block|{
name|VOP_BMAP
argument_list|(
name|bp
operator|->
name|b_vp
argument_list|,
name|bp
operator|->
name|b_lblkno
argument_list|,
name|NULL
argument_list|,
operator|&
name|bp
operator|->
name|b_blkno
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set the *dirty* buffer range based upon the VM system dirty pages. 	 */
name|vfs_setdirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * We need to do this here to satisfy the vnode_pager and the 	 * pageout daemon, so that it thinks that the pages have been 	 * "cleaned".  Note that since the pages are in a delayed write 	 * buffer -- the VFS layer "will" see that the pages get written 	 * out on the next sync, or perhaps the cluster will be completed. 	 */
name|vfs_clean_pages
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Asynchronous write.  * Start output on a buffer, but do not wait for it to complete.  * The buffer is released when the output completes.  */
end_comment

begin_function
name|void
name|bawrite
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ASYNC
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Release a buffer.  */
end_comment

begin_function
name|void
name|brelse
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CLUSTER
condition|)
block|{
name|relpbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* anyone need a "free" block? */
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|needsbuffer
condition|)
block|{
name|needsbuffer
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|needsbuffer
argument_list|)
expr_stmt|;
block|}
comment|/* anyone need this block? */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_WANTED
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_WANTED
operator||
name|B_AGE
operator|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_WANTED
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_LOCKED
condition|)
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ERROR
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_NOCACHE
operator||
name|B_INVAL
operator||
name|B_ERROR
operator|)
operator|)
operator|||
operator|(
name|bp
operator|->
name|b_bufsize
operator|<=
literal|0
operator|)
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_DELWRI
operator||
name|B_CACHE
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
operator|)
operator|==
literal|0
operator|)
operator|&&
name|bp
operator|->
name|b_vp
condition|)
name|brelvp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * VMIO buffer rundown.  It is not very necessary to keep a VMIO buffer 	 * constituted, so the B_INVAL flag is used to *invalidate* the buffer, 	 * but the VM object is kept around.  The B_NOCACHE flag is used to 	 * invalidate the pages in the VM object. 	 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
condition|)
block|{
name|vm_offset_t
name|foff
decl_stmt|;
name|vm_object_t
name|obj
decl_stmt|;
name|int
name|i
decl_stmt|,
name|resid
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|iototal
init|=
name|bp
operator|->
name|b_bufsize
decl_stmt|;
name|vp
operator|=
name|bp
operator|->
name|b_vp
expr_stmt|;
if|if
condition|(
operator|!
name|vp
condition|)
name|panic
argument_list|(
literal|"brelse: missing vp"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vp
operator|->
name|v_mount
condition|)
name|panic
argument_list|(
literal|"brelse: missing mount info"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_npages
condition|)
block|{
name|obj
operator|=
operator|(
name|vm_object_t
operator|)
name|vp
operator|->
name|v_vmdata
expr_stmt|;
name|foff
operator|=
name|trunc_page
argument_list|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
operator|*
name|bp
operator|->
name|b_lblkno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|bogus_page
condition|)
block|{
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
name|foff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|panic
argument_list|(
literal|"brelse: page missing\n"
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|=
name|m
expr_stmt|;
name|pmap_qenter
argument_list|(
name|trunc_page
argument_list|(
name|bp
operator|->
name|b_data
argument_list|)
argument_list|,
name|bp
operator|->
name|b_pages
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
block|}
name|resid
operator|=
operator|(
name|m
operator|->
name|offset
operator|+
name|PAGE_SIZE
operator|)
operator|-
name|foff
expr_stmt|;
if|if
condition|(
name|resid
operator|>
name|iototal
condition|)
name|resid
operator|=
name|iototal
expr_stmt|;
if|if
condition|(
name|resid
operator|>
literal|0
condition|)
block|{
comment|/* 					 * Don't invalidate the page if the local machine has already 					 * modified it.  This is the lesser of two evils, and should 					 * be fixed. 					 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_NOCACHE
operator||
name|B_ERROR
operator|)
condition|)
block|{
name|vm_page_test_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|dirty
operator|==
literal|0
condition|)
block|{
name|vm_page_set_invalid
argument_list|(
name|m
argument_list|,
name|foff
argument_list|,
name|resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|valid
operator|==
literal|0
condition|)
name|vm_page_protect
argument_list|(
name|m
argument_list|,
name|VM_PROT_NONE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|foff
operator|+=
name|resid
expr_stmt|;
name|iototal
operator|-=
name|resid
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_INVAL
operator||
name|B_RELBUF
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
expr_stmt|;
operator|--
name|m
operator|->
name|bmapped
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|bmapped
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_WANTED
condition|)
block|{
name|wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_WANTED
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|m
operator|->
name|busy
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|vm_page_test_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 						 * if page isn't valid, no sense in keeping it around 						 */
if|if
condition|(
name|m
operator|->
name|valid
operator|==
literal|0
condition|)
block|{
name|vm_page_protect
argument_list|(
name|m
argument_list|,
name|VM_PROT_NONE
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 						 * if page isn't dirty and hasn't been referenced by 						 * a process, then cache it 						 */
block|}
elseif|else
if|if
condition|(
operator|(
name|m
operator|->
name|dirty
operator|&
name|m
operator|->
name|valid
operator|)
operator|==
literal|0
operator|&&
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_REFERENCED
operator|)
operator|==
literal|0
operator|&&
operator|!
name|pmap_is_referenced
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
block|{
name|vm_page_cache
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 						 * otherwise activate it 						 */
block|}
elseif|else
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|vm_page_activate
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|act_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|bufspace
operator|-=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
name|pmap_qremove
argument_list|(
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
argument_list|)
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_npages
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_VMIO
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_vp
condition|)
name|brelvp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bp
operator|->
name|b_qindex
operator|!=
name|QUEUE_NONE
condition|)
name|panic
argument_list|(
literal|"brelse: free buffer onto another queue???"
argument_list|)
expr_stmt|;
comment|/* enqueue */
comment|/* buffers with no memory */
if|if
condition|(
name|bp
operator|->
name|b_bufsize
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_EMPTY
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_EMPTY
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|invalhash
argument_list|,
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|NODEV
expr_stmt|;
comment|/* buffers with junk contents */
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_ERROR
operator||
name|B_INVAL
operator||
name|B_NOCACHE
operator||
name|B_RELBUF
operator|)
condition|)
block|{
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_AGE
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_AGE
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|invalhash
argument_list|,
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|NODEV
expr_stmt|;
comment|/* buffers that are locked */
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_LOCKED
condition|)
block|{
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_LOCKED
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LOCKED
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
comment|/* buffers with stale but valid contents */
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_AGE
condition|)
block|{
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_AGE
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_AGE
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
comment|/* buffers with valid and quite potentially reuseable contents */
block|}
else|else
block|{
name|bp
operator|->
name|b_qindex
operator|=
name|QUEUE_LRU
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|bufqueues
index|[
name|QUEUE_LRU
index|]
argument_list|,
name|bp
argument_list|,
name|b_freelist
argument_list|)
expr_stmt|;
block|}
comment|/* unlock */
name|bp
operator|->
name|b_flags
operator|&=
operator|~
operator|(
name|B_WANTED
operator||
name|B_BUSY
operator||
name|B_ASYNC
operator||
name|B_NOCACHE
operator||
name|B_AGE
operator||
name|B_RELBUF
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this routine implements clustered async writes for  * clearing out B_DELWRI buffers...  This is much better  * than the old way of writing only one buffer at a time.  */
end_comment

begin_function
name|void
name|vfs_bio_awrite
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|daddr_t
name|lblkno
init|=
name|bp
operator|->
name|b_lblkno
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|bp
operator|->
name|b_vp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|ncl
decl_stmt|;
name|struct
name|buf
modifier|*
name|bpa
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|&&
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|VVMIO
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_CLUSTEROK
operator||
name|B_INVAL
operator|)
operator|)
operator|==
name|B_CLUSTEROK
condition|)
block|{
name|int
name|size
init|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAXPHYS
operator|/
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bpa
operator|=
name|incore
argument_list|(
name|vp
argument_list|,
name|lblkno
operator|+
name|i
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|bpa
operator|->
name|b_flags
operator|&
operator|(
name|B_BUSY
operator||
name|B_DELWRI
operator||
name|B_CLUSTEROK
operator||
name|B_INVAL
operator|)
operator|)
operator|==
operator|(
name|B_DELWRI
operator||
name|B_CLUSTEROK
operator|)
operator|)
operator|&&
operator|(
name|bpa
operator|->
name|b_bufsize
operator|==
name|size
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|bpa
operator|->
name|b_blkno
operator|==
name|bpa
operator|->
name|b_lblkno
operator|)
operator|||
operator|(
name|bpa
operator|->
name|b_blkno
operator|!=
name|bp
operator|->
name|b_blkno
operator|+
operator|(
name|i
operator|*
name|size
operator|)
operator|/
name|DEV_BSIZE
operator|)
condition|)
break|break;
block|}
else|else
block|{
break|break;
block|}
block|}
name|ncl
operator|=
name|i
expr_stmt|;
comment|/* 		 * this is a possible cluster write 		 */
if|if
condition|(
name|ncl
operator|!=
literal|1
condition|)
block|{
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|cluster_wbuild
argument_list|(
name|vp
argument_list|,
name|bp
argument_list|,
name|size
argument_list|,
name|lblkno
argument_list|,
name|ncl
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * default (old) behavior, writing out only one block 	 */
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_BUSY
operator||
name|B_ASYNC
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find a buffer header which is available for use.  */
end_comment

begin_function
specifier|static
name|struct
name|buf
modifier|*
name|getnewbuf
parameter_list|(
name|int
name|slpflag
parameter_list|,
name|int
name|slptimeo
parameter_list|,
name|int
name|doingvmio
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|firstbp
init|=
literal|1
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|start
label|:
if|if
condition|(
name|bufspace
operator|>=
name|maxbufspace
condition|)
goto|goto
name|trytofreespace
goto|;
comment|/* can we constitute a new buffer? */
if|if
condition|(
operator|(
name|bp
operator|=
name|bufqueues
index|[
name|QUEUE_EMPTY
index|]
operator|.
name|tqh_first
operator|)
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_qindex
operator|!=
name|QUEUE_EMPTY
condition|)
name|panic
argument_list|(
literal|"getnewbuf: inconsistent EMPTY queue, qindex=%d"
argument_list|,
name|bp
operator|->
name|b_qindex
argument_list|)
expr_stmt|;
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|fillbuf
goto|;
block|}
name|trytofreespace
label|:
comment|/* 	 * We keep the file I/O from hogging metadata I/O 	 * This is desirable because file data is cached in the 	 * VM/Buffer cache even if a buffer is freed. 	 */
if|if
condition|(
operator|(
name|bp
operator|=
name|bufqueues
index|[
name|QUEUE_AGE
index|]
operator|.
name|tqh_first
operator|)
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_qindex
operator|!=
name|QUEUE_AGE
condition|)
name|panic
argument_list|(
literal|"getnewbuf: inconsistent AGE queue, qindex=%d"
argument_list|,
name|bp
operator|->
name|b_qindex
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|bp
operator|=
name|bufqueues
index|[
name|QUEUE_LRU
index|]
operator|.
name|tqh_first
operator|)
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_qindex
operator|!=
name|QUEUE_LRU
condition|)
name|panic
argument_list|(
literal|"getnewbuf: inconsistent LRU queue, qindex=%d"
argument_list|,
name|bp
operator|->
name|b_qindex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bp
condition|)
block|{
comment|/* wait for a free buffer of any kind */
name|needsbuffer
operator|=
literal|1
expr_stmt|;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|needsbuffer
argument_list|,
name|PRIBIO
operator||
name|slpflag
argument_list|,
literal|"newbuf"
argument_list|,
name|slptimeo
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* if we are a delayed write, convert to an async write */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
operator|(
name|B_DELWRI
operator||
name|B_INVAL
operator|)
operator|)
operator|==
name|B_DELWRI
condition|)
block|{
name|vfs_bio_awrite
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slpflag
operator|&&
operator|!
name|slptimeo
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
goto|goto
name|start
goto|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_WANTED
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_WANTED
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|)
expr_stmt|;
block|}
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_RELBUF
operator||
name|B_BUSY
operator||
name|B_DONE
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_vp
condition|)
name|brelvp
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|fillbuf
label|:
comment|/* we are not free, nor do we contain interesting data */
if|if
condition|(
name|bp
operator|->
name|b_rcred
operator|!=
name|NOCRED
condition|)
block|{
name|crfree
argument_list|(
name|bp
operator|->
name|b_rcred
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_rcred
operator|=
name|NOCRED
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_wcred
operator|!=
name|NOCRED
condition|)
block|{
name|crfree
argument_list|(
name|bp
operator|->
name|b_wcred
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_wcred
operator|=
name|NOCRED
expr_stmt|;
block|}
name|bp
operator|->
name|b_flags
operator||=
name|B_BUSY
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|invalhash
argument_list|,
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bufsize
condition|)
block|{
name|allocbuf
argument_list|(
name|bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_flags
operator|=
name|B_BUSY
expr_stmt|;
name|bp
operator|->
name|b_dev
operator|=
name|NODEV
expr_stmt|;
name|bp
operator|->
name|b_vp
operator|=
name|NULL
expr_stmt|;
name|bp
operator|->
name|b_blkno
operator|=
name|bp
operator|->
name|b_lblkno
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_iodone
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_npages
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_data
operator|=
name|buffers_kva
operator|+
operator|(
name|bp
operator|-
name|buf
operator|)
operator|*
name|MAXBSIZE
expr_stmt|;
name|bp
operator|->
name|b_dirtyoff
operator|=
name|bp
operator|->
name|b_dirtyend
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_validoff
operator|=
name|bp
operator|->
name|b_validend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bufspace
operator|>=
name|maxbufspace
condition|)
block|{
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|trytofreespace
goto|;
block|}
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if a block is currently memory resident.  */
end_comment

begin_function
name|struct
name|buf
modifier|*
name|incore
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|daddr_t
name|blkno
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|struct
name|bufhashhdr
modifier|*
name|bh
decl_stmt|;
name|int
name|s
init|=
name|splbio
argument_list|()
decl_stmt|;
name|bh
operator|=
name|BUFHASH
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
name|bp
operator|=
name|bh
operator|->
name|lh_first
expr_stmt|;
comment|/* Search hash chain */
while|while
condition|(
name|bp
condition|)
block|{
comment|/* hit */
if|if
condition|(
name|bp
operator|->
name|b_lblkno
operator|==
name|blkno
operator|&&
name|bp
operator|->
name|b_vp
operator|==
name|vp
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_INVAL
operator|)
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
name|bp
operator|=
name|bp
operator|->
name|b_hash
operator|.
name|le_next
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if no I/O is needed to access the  * associated VM object.  This is like incore except  * it also hunts around in the VM system for the data.  */
end_comment

begin_function
name|int
name|inmem
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|daddr_t
name|blkno
parameter_list|)
block|{
name|vm_object_t
name|obj
decl_stmt|;
name|vm_offset_t
name|off
decl_stmt|,
name|toff
decl_stmt|,
name|tinc
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
if|if
condition|(
name|incore
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_vmdata
operator|==
literal|0
operator|)
operator|||
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|VVMIO
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|obj
operator|=
operator|(
name|vm_object_t
operator|)
name|vp
operator|->
name|v_vmdata
expr_stmt|;
name|tinc
operator|=
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|tinc
operator|>
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
condition|)
name|tinc
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
expr_stmt|;
name|off
operator|=
name|blkno
operator|*
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
expr_stmt|;
for|for
control|(
name|toff
operator|=
literal|0
init|;
name|toff
operator|<
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
condition|;
name|toff
operator|+=
name|tinc
control|)
block|{
name|int
name|mask
decl_stmt|;
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
name|trunc_page
argument_list|(
name|toff
operator|+
name|off
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|vm_page_is_valid
argument_list|(
name|m
argument_list|,
name|toff
operator|+
name|off
argument_list|,
name|tinc
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * now we set the dirty range for the buffer --  * for NFS -- if the file is mapped and pages have  * been written to, let it know.  We want the  * entire range of the buffer to be marked dirty if  * any of the pages have been written to for consistancy  * with the b_validoff, b_validend set in the nfs write  * code, and used by the nfs read code.  */
end_comment

begin_function
specifier|static
name|void
name|vfs_setdirty
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|vm_offset_t
name|boffset
decl_stmt|,
name|offset
decl_stmt|;
comment|/* 	 * We qualify the scan for modified pages on whether the 	 * object has been flushed yet.  The OBJ_WRITEABLE flag 	 * is not cleared simply by protecting pages off. 	 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
operator|)
operator|&&
operator|(
operator|(
name|object
operator|=
name|bp
operator|->
name|b_pages
index|[
literal|0
index|]
operator|->
name|object
operator|)
operator|->
name|flags
operator|&
name|OBJ_WRITEABLE
operator|)
condition|)
block|{
comment|/* 		 * test the pages to see if they have been modified directly 		 * by users through the VM system. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
name|vm_page_test_dirty
argument_list|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * scan forwards for the first page modified 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|->
name|dirty
condition|)
block|{
break|break;
block|}
block|}
name|boffset
operator|=
name|i
operator|*
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|boffset
operator|<
name|bp
operator|->
name|b_dirtyoff
condition|)
block|{
name|bp
operator|->
name|b_dirtyoff
operator|=
name|boffset
expr_stmt|;
block|}
comment|/* 		 * scan backwards for the last page modified 		 */
for|for
control|(
name|i
operator|=
name|bp
operator|->
name|b_npages
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|->
name|dirty
condition|)
block|{
break|break;
block|}
block|}
name|boffset
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|PAGE_SIZE
expr_stmt|;
name|offset
operator|=
name|boffset
operator|+
name|bp
operator|->
name|b_pages
index|[
literal|0
index|]
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|object
operator|->
name|size
condition|)
block|{
name|boffset
operator|=
name|object
operator|->
name|size
operator|-
name|bp
operator|->
name|b_pages
index|[
literal|0
index|]
operator|->
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_dirtyend
operator|<
name|boffset
condition|)
block|{
name|bp
operator|->
name|b_dirtyend
operator|=
name|boffset
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Get a block given a specified block and offset into a file/device.  */
end_comment

begin_function
name|struct
name|buf
modifier|*
name|getblk
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|daddr_t
name|blkno
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|slpflag
parameter_list|,
name|int
name|slptimeo
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|bufhashhdr
modifier|*
name|bh
decl_stmt|;
name|vm_offset_t
name|off
decl_stmt|;
name|int
name|nleft
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|loop
label|:
if|if
condition|(
name|bp
operator|=
name|incore
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|)
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_WANTED
expr_stmt|;
if|if
condition|(
operator|!
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
name|PRIBIO
operator||
name|slpflag
argument_list|,
literal|"getblk"
argument_list|,
name|slptimeo
argument_list|)
condition|)
goto|goto
name|loop
goto|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|buf
operator|*
operator|)
name|NULL
return|;
block|}
name|bp
operator|->
name|b_flags
operator||=
name|B_BUSY
operator||
name|B_CACHE
expr_stmt|;
name|bremfree
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 * check for size inconsistancies 		 */
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|!=
name|size
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
condition|)
block|{
name|allocbuf
argument_list|(
name|bp
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_NOCACHE
expr_stmt|;
name|VOP_BWRITE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
else|else
block|{
name|vm_object_t
name|obj
decl_stmt|;
name|int
name|doingvmio
decl_stmt|;
if|if
condition|(
operator|(
name|obj
operator|=
operator|(
name|vm_object_t
operator|)
name|vp
operator|->
name|v_vmdata
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|VVMIO
operator|)
condition|)
block|{
name|doingvmio
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|doingvmio
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bp
operator|=
name|getnewbuf
argument_list|(
name|slpflag
argument_list|,
name|slptimeo
argument_list|,
name|doingvmio
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|slpflag
operator|||
name|slptimeo
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
goto|goto
name|loop
goto|;
block|}
comment|/* 		 * This code is used to make sure that a buffer is not 		 * created while the getnewbuf routine is blocked. 		 * Normally the vnode is locked so this isn't a problem. 		 * VBLK type I/O requests, however, don't lock the vnode. 		 */
if|if
condition|(
operator|!
name|VOP_ISLOCKED
argument_list|(
name|vp
argument_list|)
operator|&&
name|incore
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|)
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
expr_stmt|;
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
comment|/* 		 * Insert the buffer into the hash, so that it can 		 * be found by incore. 		 */
name|bp
operator|->
name|b_blkno
operator|=
name|bp
operator|->
name|b_lblkno
operator|=
name|blkno
expr_stmt|;
name|bgetvp
argument_list|(
name|vp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
name|bh
operator|=
name|BUFHASH
argument_list|(
name|vp
argument_list|,
name|blkno
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|bh
argument_list|,
name|bp
argument_list|,
name|b_hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|doingvmio
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
operator|(
name|B_VMIO
operator||
name|B_CACHE
operator|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VFS_BIO_DEBUG
argument_list|)
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
condition|)
name|printf
argument_list|(
literal|"getblk: vmioing file type %d???\n"
argument_list|,
name|vp
operator|->
name|v_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_VMIO
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|allocbuf
argument_list|(
name|bp
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Get an empty, disassociated buffer of given size.  */
end_comment

begin_function
name|struct
name|buf
modifier|*
name|geteblk
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|getnewbuf
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
empty_stmt|;
name|allocbuf
argument_list|(
name|bp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_INVAL
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This code constitutes the buffer memory from either anonymous system  * memory (in the case of non-VMIO operations) or from an associated  * VM object (in the case of VMIO operations).  *  * Note that this code is tricky, and has many complications to resolve  * deadlock or inconsistant data situations.  Tread lightly!!!  *  * Modify the length of a buffer's underlying buffer storage without  * destroying information (unless, of course the buffer is shrinking).  */
end_comment

begin_function
name|int
name|allocbuf
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|newbsize
decl_stmt|,
name|mbsize
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
operator|)
condition|)
name|panic
argument_list|(
literal|"allocbuf: buffer not busy"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Just get anonymous memory from the kernel 		 */
name|mbsize
operator|=
operator|(
operator|(
name|size
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|/
name|DEV_BSIZE
operator|)
operator|*
name|DEV_BSIZE
expr_stmt|;
name|newbsize
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|newbsize
operator|<
name|bp
operator|->
name|b_bufsize
condition|)
block|{
name|vm_hold_free_pages
argument_list|(
name|bp
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
operator|+
name|newbsize
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
operator|+
name|bp
operator|->
name|b_bufsize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newbsize
operator|>
name|bp
operator|->
name|b_bufsize
condition|)
block|{
name|vm_hold_load_pages
argument_list|(
name|bp
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
operator|+
name|bp
operator|->
name|b_bufsize
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
operator|+
name|newbsize
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|vm_page_t
name|m
decl_stmt|;
name|int
name|desiredpages
decl_stmt|;
name|newbsize
operator|=
operator|(
operator|(
name|size
operator|+
name|DEV_BSIZE
operator|-
literal|1
operator|)
operator|/
name|DEV_BSIZE
operator|)
operator|*
name|DEV_BSIZE
expr_stmt|;
name|desiredpages
operator|=
name|round_page
argument_list|(
name|newbsize
argument_list|)
operator|/
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|newbsize
operator|<
name|bp
operator|->
name|b_bufsize
condition|)
block|{
if|if
condition|(
name|desiredpages
operator|<
name|bp
operator|->
name|b_npages
condition|)
block|{
name|pmap_qremove
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|trunc_page
argument_list|(
name|bp
operator|->
name|b_data
argument_list|)
operator|+
name|desiredpages
operator|*
name|PAGE_SIZE
argument_list|,
operator|(
name|bp
operator|->
name|b_npages
operator|-
name|desiredpages
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|desiredpages
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
operator|)
operator|||
operator|(
name|m
operator|->
name|busy
operator|!=
literal|0
operator|)
condition|)
block|{
name|m
operator|->
name|flags
operator||=
name|PG_WANTED
expr_stmt|;
name|tsleep
argument_list|(
name|m
argument_list|,
name|PVM
argument_list|,
literal|"biodep"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|bmapped
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"allocbuf: bmapped is zero for page %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"allocbuf: error"
argument_list|)
expr_stmt|;
block|}
operator|--
name|m
operator|->
name|bmapped
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|bmapped
operator|==
literal|0
condition|)
block|{
name|vm_page_protect
argument_list|(
name|m
argument_list|,
name|VM_PROT_NONE
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|bp
operator|->
name|b_npages
operator|=
name|desiredpages
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|newbsize
operator|>
name|bp
operator|->
name|b_bufsize
condition|)
block|{
name|vm_object_t
name|obj
decl_stmt|;
name|vm_offset_t
name|tinc
decl_stmt|,
name|off
decl_stmt|,
name|toff
decl_stmt|,
name|objoff
decl_stmt|;
name|int
name|pageindex
decl_stmt|,
name|curbpnpages
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|bsize
decl_stmt|;
name|vp
operator|=
name|bp
operator|->
name|b_vp
expr_stmt|;
name|bsize
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_npages
operator|<
name|desiredpages
condition|)
block|{
name|obj
operator|=
operator|(
name|vm_object_t
operator|)
name|vp
operator|->
name|v_vmdata
expr_stmt|;
name|tinc
operator|=
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|tinc
operator|>
name|bsize
condition|)
name|tinc
operator|=
name|bsize
expr_stmt|;
name|off
operator|=
name|bp
operator|->
name|b_lblkno
operator|*
name|bsize
expr_stmt|;
name|doretry
label|:
name|curbpnpages
operator|=
name|bp
operator|->
name|b_npages
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_CACHE
expr_stmt|;
for|for
control|(
name|toff
operator|=
literal|0
init|;
name|toff
operator|<
name|newbsize
condition|;
name|toff
operator|+=
name|tinc
control|)
block|{
name|int
name|mask
decl_stmt|;
name|int
name|bytesinpage
decl_stmt|;
name|pageindex
operator|=
name|toff
operator|/
name|PAGE_SIZE
expr_stmt|;
name|objoff
operator|=
name|trunc_page
argument_list|(
name|toff
operator|+
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|pageindex
operator|<
name|curbpnpages
condition|)
block|{
name|int
name|pb
decl_stmt|;
name|m
operator|=
name|bp
operator|->
name|b_pages
index|[
name|pageindex
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|offset
operator|!=
name|objoff
condition|)
name|panic
argument_list|(
literal|"allocbuf: page changed offset??!!!?"
argument_list|)
expr_stmt|;
name|bytesinpage
operator|=
name|tinc
expr_stmt|;
if|if
condition|(
name|tinc
operator|>
operator|(
name|newbsize
operator|-
name|toff
operator|)
condition|)
name|bytesinpage
operator|=
name|newbsize
operator|-
name|toff
expr_stmt|;
if|if
condition|(
operator|!
name|vm_page_is_valid
argument_list|(
name|m
argument_list|,
name|toff
operator|+
name|off
argument_list|,
name|bytesinpage
argument_list|)
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_CACHE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|vm_page_activate
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|act_count
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
block|}
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
name|objoff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|m
operator|=
name|vm_page_alloc
argument_list|(
name|obj
argument_list|,
name|objoff
argument_list|,
name|VM_ALLOC_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|bp
operator|->
name|b_npages
init|;
name|j
operator|<
name|pageindex
condition|;
name|j
operator|++
control|)
block|{
name|PAGE_WAKEUP
argument_list|(
name|bp
operator|->
name|b_pages
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|VM_WAIT
expr_stmt|;
goto|goto
name|doretry
goto|;
block|}
name|vm_page_activate
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|act_count
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|valid
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_CACHE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_BUSY
condition|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|bp
operator|->
name|b_npages
init|;
name|j
operator|<
name|pageindex
condition|;
name|j
operator|++
control|)
block|{
name|PAGE_WAKEUP
argument_list|(
name|bp
operator|->
name|b_pages
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|m
operator|->
name|flags
operator||=
name|PG_WANTED
expr_stmt|;
name|tsleep
argument_list|(
name|m
argument_list|,
name|PRIBIO
argument_list|,
literal|"pgtblk"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|doretry
goto|;
block|}
else|else
block|{
name|int
name|pb
decl_stmt|;
if|if
condition|(
operator|(
name|curproc
operator|!=
name|pageproc
operator|)
operator|&&
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_CACHE
operator|)
operator|&&
operator|(
name|cnt
operator|.
name|v_free_count
operator|+
name|cnt
operator|.
name|v_cache_count
operator|)
operator|<
name|cnt
operator|.
name|v_free_min
condition|)
block|{
name|pagedaemon_wakeup
argument_list|()
expr_stmt|;
block|}
name|bytesinpage
operator|=
name|tinc
expr_stmt|;
if|if
condition|(
name|tinc
operator|>
operator|(
name|newbsize
operator|-
name|toff
operator|)
condition|)
name|bytesinpage
operator|=
name|newbsize
operator|-
name|toff
expr_stmt|;
if|if
condition|(
operator|!
name|vm_page_is_valid
argument_list|(
name|m
argument_list|,
name|toff
operator|+
name|off
argument_list|,
name|bytesinpage
argument_list|)
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_CACHE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
name|vm_page_activate
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|act_count
operator|=
literal|0
expr_stmt|;
block|}
name|m
operator|->
name|flags
operator||=
name|PG_BUSY
expr_stmt|;
block|}
name|bp
operator|->
name|b_pages
index|[
name|pageindex
index|]
operator|=
name|m
expr_stmt|;
name|curbpnpages
operator|=
name|pageindex
operator|+
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|bp
operator|->
name|b_npages
init|;
name|i
operator|<
name|curbpnpages
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
expr_stmt|;
name|m
operator|->
name|bmapped
operator|++
expr_stmt|;
name|PAGE_WAKEUP
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_npages
operator|=
name|curbpnpages
expr_stmt|;
name|bp
operator|->
name|b_data
operator|=
name|buffers_kva
operator|+
operator|(
name|bp
operator|-
name|buf
operator|)
operator|*
name|MAXBSIZE
expr_stmt|;
name|pmap_qenter
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|bp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_pages
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_data
operator|+=
name|off
operator|%
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
block|}
name|bufspace
operator|+=
operator|(
name|newbsize
operator|-
name|bp
operator|->
name|b_bufsize
operator|)
expr_stmt|;
name|bp
operator|->
name|b_bufsize
operator|=
name|newbsize
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|size
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Wait for buffer I/O completion, returning error status.  */
end_comment

begin_function
name|int
name|biowait
parameter_list|(
specifier|register
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
operator|)
operator|==
literal|0
condition|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|,
name|PRIBIO
argument_list|,
literal|"biowait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_EINTR
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_EINTR
expr_stmt|;
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ERROR
condition|)
block|{
return|return
operator|(
name|bp
operator|->
name|b_error
condition|?
name|bp
operator|->
name|b_error
else|:
name|EIO
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Finish I/O on a buffer, calling an optional function.  * This is usually called from interrupt level, so process blocking  * is not *a good idea*.  */
end_comment

begin_function
name|void
name|biodone
parameter_list|(
specifier|register
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BUSY
operator|)
condition|)
name|panic
argument_list|(
literal|"biodone: buffer not busy"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_DONE
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"biodone: buffer already done\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|->
name|b_flags
operator||=
name|B_DONE
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|bp
operator|->
name|b_vp
decl_stmt|;
name|vwakeup
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BOUNCE_BUFFERS
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_BOUNCE
condition|)
name|vm_bounce_free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* call optional completion function if requested */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CALL
condition|)
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_CALL
expr_stmt|;
call|(
modifier|*
name|bp
operator|->
name|b_iodone
call|)
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
condition|)
block|{
name|int
name|i
decl_stmt|,
name|resid
decl_stmt|;
name|vm_offset_t
name|foff
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|vm_object_t
name|obj
decl_stmt|;
name|int
name|iosize
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|bp
operator|->
name|b_vp
decl_stmt|;
name|foff
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
operator|*
name|bp
operator|->
name|b_lblkno
expr_stmt|;
name|obj
operator|=
operator|(
name|vm_object_t
operator|)
name|vp
operator|->
name|v_vmdata
expr_stmt|;
if|if
condition|(
operator|!
name|obj
condition|)
block|{
name|panic
argument_list|(
literal|"biodone: no object"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|VFS_BIO_DEBUG
argument_list|)
if|if
condition|(
name|obj
operator|->
name|paging_in_progress
operator|<
name|bp
operator|->
name|b_npages
condition|)
block|{
name|printf
argument_list|(
literal|"biodone: paging in progress(%d)< bp->b_npages(%d)\n"
argument_list|,
name|obj
operator|->
name|paging_in_progress
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|iosize
operator|=
name|bp
operator|->
name|b_bufsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bogusflag
init|=
literal|0
decl_stmt|;
name|m
operator|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|bogus_page
condition|)
block|{
name|bogusflag
operator|=
literal|1
expr_stmt|;
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
name|foff
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|VFS_BIO_DEBUG
argument_list|)
name|printf
argument_list|(
literal|"biodone: page disappeared\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|--
name|obj
operator|->
name|paging_in_progress
expr_stmt|;
continue|continue;
block|}
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|=
name|m
expr_stmt|;
name|pmap_qenter
argument_list|(
name|trunc_page
argument_list|(
name|bp
operator|->
name|b_data
argument_list|)
argument_list|,
name|bp
operator|->
name|b_pages
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|VFS_BIO_DEBUG
argument_list|)
if|if
condition|(
name|trunc_page
argument_list|(
name|foff
argument_list|)
operator|!=
name|m
operator|->
name|offset
condition|)
block|{
name|printf
argument_list|(
literal|"biodone: foff(%d)/m->offset(%d) mismatch\n"
argument_list|,
name|foff
argument_list|,
name|m
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|resid
operator|=
operator|(
name|m
operator|->
name|offset
operator|+
name|PAGE_SIZE
operator|)
operator|-
name|foff
expr_stmt|;
if|if
condition|(
name|resid
operator|>
name|iosize
condition|)
name|resid
operator|=
name|iosize
expr_stmt|;
comment|/* 			 * In the write case, the valid and clean bits are 			 * already changed correctly, so we only need to do this 			 * here in the read case. 			 */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|&&
operator|!
name|bogusflag
operator|&&
name|resid
operator|>
literal|0
condition|)
block|{
name|vm_page_set_valid
argument_list|(
name|m
argument_list|,
name|foff
operator|&
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
argument_list|,
name|resid
argument_list|)
expr_stmt|;
name|vm_page_set_clean
argument_list|(
name|m
argument_list|,
name|foff
operator|&
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
argument_list|,
name|resid
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * when debugging new filesystems or buffer I/O methods, this 			 * is the most common error that pops up.  if you see this, you 			 * have not set the page busy flag correctly!!! 			 */
if|if
condition|(
name|m
operator|->
name|busy
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"biodone: page busy< 0, "
literal|"off: %ld, foff: %ld, "
literal|"resid: %d, index: %d\n"
argument_list|,
name|m
operator|->
name|offset
argument_list|,
name|foff
argument_list|,
name|resid
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" iosize: %ld, lblkno: %ld, flags: 0x%x, npages: %d\n"
argument_list|,
name|bp
operator|->
name|b_vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
argument_list|,
name|bp
operator|->
name|b_lblkno
argument_list|,
name|bp
operator|->
name|b_flags
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" valid: 0x%x, dirty: 0x%x, mapped: %d\n"
argument_list|,
name|m
operator|->
name|valid
argument_list|,
name|m
operator|->
name|dirty
argument_list|,
name|m
operator|->
name|bmapped
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"biodone: page busy< 0\n"
argument_list|)
expr_stmt|;
block|}
operator|--
name|m
operator|->
name|busy
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|busy
operator|==
literal|0
operator|)
operator|&&
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_WANTED
operator|)
condition|)
block|{
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_WANTED
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|m
argument_list|)
expr_stmt|;
block|}
operator|--
name|obj
operator|->
name|paging_in_progress
expr_stmt|;
name|foff
operator|+=
name|resid
expr_stmt|;
name|iosize
operator|-=
name|resid
expr_stmt|;
block|}
if|if
condition|(
name|obj
operator|&&
name|obj
operator|->
name|paging_in_progress
operator|==
literal|0
operator|&&
operator|(
name|obj
operator|->
name|flags
operator|&
name|OBJ_PIPWNT
operator|)
condition|)
block|{
name|obj
operator|->
name|flags
operator|&=
operator|~
name|OBJ_PIPWNT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * For asynchronous completions, release the buffer now. The brelse 	 * checks for B_WANTED and will do the wakeup there if necessary - so 	 * no need to do a wakeup here in the async case. 	 */
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ASYNC
condition|)
block|{
name|brelse
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_WANTED
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|bp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|count_lock_queue
parameter_list|()
block|{
name|int
name|count
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|bufqueues
index|[
name|QUEUE_LOCKED
index|]
operator|.
name|tqh_first
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|bp
operator|->
name|b_freelist
operator|.
name|tqe_next
control|)
name|count
operator|++
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|vfs_update_interval
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|vfs_update
parameter_list|()
block|{
operator|(
name|void
operator|)
name|spl0
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|vfs_update_wakeup
argument_list|,
name|PRIBIO
argument_list|,
literal|"update"
argument_list|,
name|hz
operator|*
name|vfs_update_interval
argument_list|)
expr_stmt|;
name|vfs_update_wakeup
operator|=
literal|0
expr_stmt|;
name|sync
argument_list|(
name|curproc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This routine is called in lieu of iodone in the case of  * incomplete I/O.  This keeps the busy status for pages  * consistant.  */
end_comment

begin_function
name|void
name|vfs_unbusy_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
condition|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|bp
operator|->
name|b_vp
decl_stmt|;
name|vm_object_t
name|obj
init|=
operator|(
name|vm_object_t
operator|)
name|vp
operator|->
name|v_vmdata
decl_stmt|;
name|vm_offset_t
name|foff
decl_stmt|;
name|foff
operator|=
name|trunc_page
argument_list|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
operator|*
name|bp
operator|->
name|b_lblkno
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
name|vm_page_t
name|m
init|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|bogus_page
condition|)
block|{
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
name|foff
operator|+
name|i
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|panic
argument_list|(
literal|"vfs_unbusy_pages: page missing\n"
argument_list|)
expr_stmt|;
block|}
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|=
name|m
expr_stmt|;
name|pmap_qenter
argument_list|(
name|trunc_page
argument_list|(
name|bp
operator|->
name|b_data
argument_list|)
argument_list|,
name|bp
operator|->
name|b_pages
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
block|}
operator|--
name|obj
operator|->
name|paging_in_progress
expr_stmt|;
operator|--
name|m
operator|->
name|busy
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|busy
operator|==
literal|0
operator|)
operator|&&
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_WANTED
operator|)
condition|)
block|{
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_WANTED
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|m
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|obj
operator|->
name|paging_in_progress
operator|==
literal|0
operator|&&
operator|(
name|obj
operator|->
name|flags
operator|&
name|OBJ_PIPWNT
operator|)
condition|)
block|{
name|obj
operator|->
name|flags
operator|&=
operator|~
name|OBJ_PIPWNT
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|obj
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * This routine is called before a device strategy routine.  * It is used to tell the VM system that paging I/O is in  * progress, and treat the pages associated with the buffer  * almost as being PG_BUSY.  Also the object paging_in_progress  * flag is handled to make sure that the object doesn't become  * inconsistant.  */
end_comment

begin_function
name|void
name|vfs_busy_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|int
name|clear_modify
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
condition|)
block|{
name|vm_object_t
name|obj
init|=
operator|(
name|vm_object_t
operator|)
name|bp
operator|->
name|b_vp
operator|->
name|v_vmdata
decl_stmt|;
name|vm_offset_t
name|foff
init|=
name|bp
operator|->
name|b_vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
operator|*
name|bp
operator|->
name|b_lblkno
decl_stmt|;
name|int
name|iocount
init|=
name|bp
operator|->
name|b_bufsize
decl_stmt|;
name|vfs_setdirty
argument_list|(
name|bp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
name|vm_page_t
name|m
init|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
decl_stmt|;
name|int
name|resid
init|=
operator|(
name|m
operator|->
name|offset
operator|+
name|PAGE_SIZE
operator|)
operator|-
name|foff
decl_stmt|;
if|if
condition|(
name|resid
operator|>
name|iocount
condition|)
name|resid
operator|=
name|iocount
expr_stmt|;
name|obj
operator|->
name|paging_in_progress
operator|++
expr_stmt|;
name|m
operator|->
name|busy
operator|++
expr_stmt|;
name|vm_page_protect
argument_list|(
name|m
argument_list|,
name|VM_PROT_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|clear_modify
condition|)
block|{
name|vm_page_set_valid
argument_list|(
name|m
argument_list|,
name|foff
operator|&
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
argument_list|,
name|resid
argument_list|)
expr_stmt|;
name|vm_page_set_clean
argument_list|(
name|m
argument_list|,
name|foff
operator|&
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
argument_list|,
name|resid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>=
name|PAGE_SIZE
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|valid
operator|&&
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_CACHE
operator|)
operator|==
literal|0
condition|)
block|{
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|=
name|bogus_page
expr_stmt|;
name|pmap_qenter
argument_list|(
name|trunc_page
argument_list|(
name|bp
operator|->
name|b_data
argument_list|)
argument_list|,
name|bp
operator|->
name|b_pages
argument_list|,
name|bp
operator|->
name|b_npages
argument_list|)
expr_stmt|;
block|}
block|}
name|foff
operator|+=
name|resid
expr_stmt|;
name|iocount
operator|-=
name|resid
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Tell the VM system that the pages associated with this buffer  * are clean.  This is used for delayed writes where the data is  * going to go to disk eventually without additional VM intevention.  */
end_comment

begin_function
name|void
name|vfs_clean_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
condition|)
block|{
name|vm_offset_t
name|foff
init|=
name|bp
operator|->
name|b_vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_iosize
operator|*
name|bp
operator|->
name|b_lblkno
decl_stmt|;
name|int
name|iocount
init|=
name|bp
operator|->
name|b_bufsize
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
name|vm_page_t
name|m
init|=
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
decl_stmt|;
name|int
name|resid
init|=
operator|(
name|m
operator|->
name|offset
operator|+
name|PAGE_SIZE
operator|)
operator|-
name|foff
decl_stmt|;
if|if
condition|(
name|resid
operator|>
name|iocount
condition|)
name|resid
operator|=
name|iocount
expr_stmt|;
if|if
condition|(
name|resid
operator|>
literal|0
condition|)
block|{
name|vm_page_set_valid
argument_list|(
name|m
argument_list|,
name|foff
operator|&
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
argument_list|,
name|resid
argument_list|)
expr_stmt|;
name|vm_page_set_clean
argument_list|(
name|m
argument_list|,
name|foff
operator|&
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
argument_list|,
name|resid
argument_list|)
expr_stmt|;
block|}
name|foff
operator|+=
name|resid
expr_stmt|;
name|iocount
operator|-=
name|resid
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|vfs_bio_clrbuf
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_VMIO
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_npages
operator|==
literal|1
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_bufsize
operator|<
name|PAGE_SIZE
operator|)
condition|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_pages
index|[
literal|0
index|]
operator|->
name|valid
operator|!=
name|VM_PAGE_BITS_ALL
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|bp
operator|->
name|b_bufsize
operator|/
name|DEV_BSIZE
condition|;
name|j
operator|++
control|)
block|{
name|bzero
argument_list|(
name|bp
operator|->
name|b_data
operator|+
name|j
operator|*
name|DEV_BSIZE
argument_list|,
name|DEV_BSIZE
argument_list|)
expr_stmt|;
block|}
block|}
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bp
operator|->
name|b_npages
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|->
name|valid
operator|==
name|VM_PAGE_BITS_ALL
condition|)
continue|continue;
if|if
condition|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|->
name|valid
operator|==
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|bp
operator|->
name|b_data
operator|+
name|i
operator|*
name|PAGE_SIZE
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|PAGE_SIZE
operator|/
name|DEV_BSIZE
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|->
name|valid
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
operator|)
operator|==
literal|0
condition|)
name|bzero
argument_list|(
name|bp
operator|->
name|b_data
operator|+
name|i
operator|*
name|PAGE_SIZE
operator|+
name|j
operator|*
name|DEV_BSIZE
argument_list|,
name|DEV_BSIZE
argument_list|)
expr_stmt|;
block|}
block|}
name|bp
operator|->
name|b_pages
index|[
name|i
index|]
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
block|}
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|clrbuf
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * vm_hold_load_pages and vm_hold_unload pages get pages into  * a buffers address space.  The pages are anonymous and are  * not associated with a file object.  */
end_comment

begin_function
name|void
name|vm_hold_load_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|vm_offset_t
name|from
parameter_list|,
name|vm_offset_t
name|to
parameter_list|)
block|{
name|vm_offset_t
name|pg
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|;
name|to
operator|=
name|round_page
argument_list|(
name|to
argument_list|)
expr_stmt|;
for|for
control|(
name|pg
operator|=
name|round_page
argument_list|(
name|from
argument_list|)
init|;
name|pg
operator|<
name|to
condition|;
name|pg
operator|+=
name|PAGE_SIZE
control|)
block|{
name|tryagain
label|:
name|p
operator|=
name|vm_page_alloc
argument_list|(
name|kernel_object
argument_list|,
name|pg
operator|-
name|VM_MIN_KERNEL_ADDRESS
argument_list|,
name|VM_ALLOC_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|VM_WAIT
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
name|vm_page_wire
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pmap_kenter
argument_list|(
name|pg
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_pages
index|[
operator|(
name|pg
operator|-
name|trunc_page
argument_list|(
name|bp
operator|->
name|b_data
argument_list|)
operator|)
operator|>>
name|PAGE_SHIFT
index|]
operator|=
name|p
expr_stmt|;
name|PAGE_WAKEUP
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_npages
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|vm_hold_free_pages
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|vm_offset_t
name|from
parameter_list|,
name|vm_offset_t
name|to
parameter_list|)
block|{
name|vm_offset_t
name|pg
decl_stmt|;
name|vm_page_t
name|p
decl_stmt|;
name|int
name|index
decl_stmt|;
name|from
operator|=
name|round_page
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|to
operator|=
name|round_page
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|from
operator|-
name|trunc_page
argument_list|(
name|bp
operator|->
name|b_data
argument_list|)
operator|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
for|for
control|(
name|pg
operator|=
name|from
init|;
name|pg
operator|<
name|to
condition|;
name|pg
operator|+=
name|PAGE_SIZE
operator|,
name|index
operator|++
control|)
block|{
name|p
operator|=
name|bp
operator|->
name|b_pages
index|[
name|index
index|]
expr_stmt|;
name|bp
operator|->
name|b_pages
index|[
name|index
index|]
operator|=
literal|0
expr_stmt|;
name|pmap_kremove
argument_list|(
name|pg
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|--
name|bp
operator|->
name|b_npages
expr_stmt|;
block|}
block|}
end_function

end_unit

