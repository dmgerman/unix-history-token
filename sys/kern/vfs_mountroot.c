begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999-2004 Poul-Henning Kamp  * Copyright (c) 1999 Michael Smith  * Copyright (c) 1989, 1993  *      The Regents of the University of California.  All rights reserved.  * (c) UNIX System Laboratories, Inc.  * All or some portions of this file are derived from material licensed  * to the University of California by American Telephone and Telegraph  * Co. or Unix System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|"opt_rootdevname.h"
end_include

begin_define
define|#
directive|define
name|ROOTNAME
value|"root_device"
end_define

begin_function_decl
specifier|static
name|int
name|vfs_mountroot_ask
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vfs_mountroot_try
parameter_list|(
specifier|const
name|char
modifier|*
name|mountfrom
parameter_list|,
specifier|const
name|char
modifier|*
name|options
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * The vnode of the system's root (/ in the filesystem, without chroot  * active.)  */
end_comment

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|rootvnode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The root filesystem is detailed in the kernel environment variable  * vfs.root.mountfrom, which is expected to be in the general format  *  *<vfsname>:[<path>][<vfsname>:[<path>] ...]  * vfsname   := the name of a VFS known to the kernel and capable  *              of being mounted as root  * path      := disk device name or other data used by the filesystem  *              to locate its physical store  *  * If the environment variable vfs.root.mountfrom is a space separated list,  * each list element is tried in turn and the root filesystem will be mounted  * from the first one that suceeds.  *  * The environment variable vfs.root.mountfrom.options is a comma delimited  * set of string mount options.  These mount options must be parseable  * by nmount() in the kernel.  */
end_comment

begin_comment
comment|/*  * The root specifiers we will try if RB_CDROM is specified.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cdrom_rootdevnames
index|[]
init|=
block|{
literal|"cd9660:cd0"
block|,
literal|"cd9660:acd0"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* legacy find-root code */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rootdevnames
index|[
literal|2
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|ROOTDEVNAME
end_ifndef

begin_define
define|#
directive|define
name|ROOTDEVNAME
value|NULL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ctrootdevname
init|=
name|ROOTDEVNAME
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|root_hold_token
block|{
specifier|const
name|char
modifier|*
name|who
decl_stmt|;
name|LIST_ENTRY
argument_list|(
argument|root_hold_token
argument_list|)
name|list
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|root_hold_token
argument_list|)
name|root_holds
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|root_holds
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|root_mount_complete
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|root_hold_token
modifier|*
name|root_mount_hold
parameter_list|(
specifier|const
name|char
modifier|*
name|identifier
parameter_list|)
block|{
name|struct
name|root_hold_token
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|root_mounted
argument_list|()
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|h
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|h
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|h
operator|->
name|who
operator|=
name|identifier
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|root_holds
argument_list|,
name|h
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|h
operator|)
return|;
block|}
end_function

begin_function
name|void
name|root_mount_rel
parameter_list|(
name|struct
name|root_hold_token
modifier|*
name|h
parameter_list|)
block|{
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|h
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|root_holds
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|h
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|root_mount_prepare
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|root_hold_token
modifier|*
name|h
decl_stmt|;
name|struct
name|timeval
name|lastfail
decl_stmt|;
name|int
name|curfail
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_waitidle
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|root_holds
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ppsratecheck
argument_list|(
operator|&
name|lastfail
argument_list|,
operator|&
name|curfail
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Root mount waiting for:"
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|h
argument_list|,
argument|&root_holds
argument_list|,
argument|list
argument_list|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|h
operator|->
name|who
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|msleep
argument_list|(
operator|&
name|root_holds
argument_list|,
operator|&
name|mountlist_mtx
argument_list|,
name|PZERO
operator||
name|PDROP
argument_list|,
literal|"roothold"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|root_mount_done
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Keep prison0's root in sync with the global rootvnode. */
name|mtx_lock
argument_list|(
operator|&
name|prison0
operator|.
name|pr_mtx
argument_list|)
expr_stmt|;
name|prison0
operator|.
name|pr_root
operator|=
name|rootvnode
expr_stmt|;
name|vref
argument_list|(
name|prison0
operator|.
name|pr_root
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|prison0
operator|.
name|pr_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Use a mutex to prevent the wakeup being missed and waiting for 	 * an extra 1 second sleep. 	 */
name|mtx_lock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
name|root_mount_complete
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|root_mount_complete
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|root_mounted
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* No mutex is acquired here because int stores are atomic. */
return|return
operator|(
name|root_mount_complete
operator|)
return|;
block|}
end_function

begin_function
name|void
name|root_mount_wait
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Panic on an obvious deadlock - the function can't be called from 	 * a thread which is doing the whole SYSINIT stuff. 	 */
name|KASSERT
argument_list|(
name|curthread
operator|->
name|td_proc
operator|->
name|p_pid
operator|!=
literal|0
argument_list|,
operator|(
literal|"root_mount_wait: cannot be called from the swapper thread"
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|root_mount_complete
condition|)
block|{
name|msleep
argument_list|(
operator|&
name|root_mount_complete
argument_list|,
operator|&
name|mountlist_mtx
argument_list|,
name|PZERO
argument_list|,
literal|"rootwait"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_rootvnode
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|VFS_ROOT
argument_list|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|mountlist
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
operator|&
name|rootvnode
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Cannot find root vnode"
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|rootvnode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|curthread
operator|->
name|td_proc
expr_stmt|;
name|FILEDESC_XLOCK
argument_list|(
name|p
operator|->
name|p_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_fd
operator|->
name|fd_cdir
operator|!=
name|NULL
condition|)
name|vrele
argument_list|(
name|p
operator|->
name|p_fd
operator|->
name|fd_cdir
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_fd
operator|->
name|fd_cdir
operator|=
name|rootvnode
expr_stmt|;
name|VREF
argument_list|(
name|rootvnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_fd
operator|->
name|fd_rdir
operator|!=
name|NULL
condition|)
name|vrele
argument_list|(
name|p
operator|->
name|p_fd
operator|->
name|fd_rdir
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_fd
operator|->
name|fd_rdir
operator|=
name|rootvnode
expr_stmt|;
name|VREF
argument_list|(
name|rootvnode
argument_list|)
expr_stmt|;
name|FILEDESC_XUNLOCK
argument_list|(
name|p
operator|->
name|p_fd
argument_list|)
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|mountroot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|devfs_first
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|vfsoptlist
modifier|*
name|opts
decl_stmt|;
name|struct
name|vfsconf
modifier|*
name|vfsp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vfsp
operator|=
name|vfs_byname
argument_list|(
literal|"devfs"
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vfsp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Could not find devfs by name"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfsp
operator|==
name|NULL
condition|)
return|return;
name|mp
operator|=
name|vfs_mount_alloc
argument_list|(
name|NULLVP
argument_list|,
name|vfsp
argument_list|,
literal|"/dev"
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
name|error
operator|=
name|VFS_MOUNT
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"VFS_MOUNT(devfs) failed %d"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return;
name|opts
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vfsoptlist
argument_list|)
argument_list|,
name|M_MOUNT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
name|opts
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_opt
operator|=
name|opts
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|mountlist
argument_list|,
name|mp
argument_list|,
name|mnt_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
name|set_rootvnode
argument_list|()
expr_stmt|;
name|error
operator|=
name|kern_symlink
argument_list|(
name|td
argument_list|,
literal|"/"
argument_list|,
literal|"dev"
argument_list|,
name|UIO_SYSSPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"kern_symlink /dev -> / returns %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|devfs_fixup
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|,
modifier|*
name|dvp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Remove our devfs mount from the mountlist and purge the cache */
name|mtx_lock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
name|mp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|mountlist
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mountlist
argument_list|,
name|mp
argument_list|,
name|mnt_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
name|cache_purgevfs
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|VFS_ROOT
argument_list|(
name|mp
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
operator|&
name|dvp
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|dvp
operator|->
name|v_iflag
operator|&=
operator|~
name|VI_MOUNT
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|dvp
operator|->
name|v_mountedhere
operator|=
name|NULL
expr_stmt|;
comment|/* Set up the real rootvnode, and purge the cache */
name|TAILQ_FIRST
argument_list|(
operator|&
name|mountlist
argument_list|)
operator|->
name|mnt_vnodecovered
operator|=
name|NULL
expr_stmt|;
name|set_rootvnode
argument_list|()
expr_stmt|;
name|cache_purgevfs
argument_list|(
name|rootvnode
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_SYSSPACE
argument_list|,
literal|"/dev"
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"Lookup of /dev for devfs, error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|vfs_unbusy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return;
block|}
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
name|printf
argument_list|(
literal|"/dev is not a directory\n"
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vfs_unbusy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
operator|=
name|vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"vinvalbuf() of /dev failed, error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vfs_unbusy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return;
block|}
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_vnodecovered
operator|=
name|vp
expr_stmt|;
name|vp
operator|->
name|v_mountedhere
operator|=
name|mp
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|mountlist
argument_list|,
name|mp
argument_list|,
name|mnt_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|vfs_unbusy
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* Unlink the no longer needed /dev/dev -> / symlink */
name|error
operator|=
name|kern_unlink
argument_list|(
name|td
argument_list|,
literal|"/dev/dev"
argument_list|,
name|UIO_SYSSPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"kern_unlink of /dev/dev failed, error: %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vfs_mountroot
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cpt
decl_stmt|,
modifier|*
name|options
decl_stmt|,
modifier|*
name|tmpdev
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|asked
init|=
literal|0
decl_stmt|;
name|options
operator|=
name|NULL
expr_stmt|;
name|root_mount_prepare
argument_list|()
expr_stmt|;
name|devfs_first
argument_list|()
expr_stmt|;
comment|/* 	 * We are booted with instructions to prompt for the root filesystem. 	 */
if|if
condition|(
name|boothowto
operator|&
name|RB_ASKNAME
condition|)
block|{
if|if
condition|(
operator|!
name|vfs_mountroot_ask
argument_list|()
condition|)
goto|goto
name|mounted
goto|;
name|asked
operator|=
literal|1
expr_stmt|;
block|}
name|options
operator|=
name|getenv
argument_list|(
literal|"vfs.root.mountfrom.options"
argument_list|)
expr_stmt|;
comment|/* 	 * The root filesystem information is compiled in, and we are 	 * booted with instructions to use it. 	 */
if|if
condition|(
name|ctrootdevname
operator|!=
name|NULL
operator|&&
operator|(
name|boothowto
operator|&
name|RB_DFLTROOT
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|vfs_mountroot_try
argument_list|(
name|ctrootdevname
argument_list|,
name|options
argument_list|)
condition|)
goto|goto
name|mounted
goto|;
name|ctrootdevname
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * We've been given the generic "use CDROM as root" flag.  This is 	 * necessary because one media may be used in many different 	 * devices, so we need to search for them. 	 */
if|if
condition|(
name|boothowto
operator|&
name|RB_CDROM
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|cdrom_rootdevnames
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|vfs_mountroot_try
argument_list|(
name|cdrom_rootdevnames
index|[
name|i
index|]
argument_list|,
name|options
argument_list|)
condition|)
goto|goto
name|mounted
goto|;
block|}
block|}
comment|/* 	 * Try to use the value read by the loader from /etc/fstab, or 	 * supplied via some other means.  This is the preferred 	 * mechanism. 	 */
name|cp
operator|=
name|getenv
argument_list|(
literal|"vfs.root.mountfrom"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|cpt
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|(
name|tmpdev
operator|=
name|strsep
argument_list|(
operator|&
name|cpt
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|vfs_mountroot_try
argument_list|(
name|tmpdev
argument_list|,
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|freeenv
argument_list|(
name|cp
argument_list|)
expr_stmt|;
goto|goto
name|mounted
goto|;
block|}
block|}
name|freeenv
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Try values that may have been computed by code during boot 	 */
if|if
condition|(
operator|!
name|vfs_mountroot_try
argument_list|(
name|rootdevnames
index|[
literal|0
index|]
argument_list|,
name|options
argument_list|)
condition|)
goto|goto
name|mounted
goto|;
if|if
condition|(
operator|!
name|vfs_mountroot_try
argument_list|(
name|rootdevnames
index|[
literal|1
index|]
argument_list|,
name|options
argument_list|)
condition|)
goto|goto
name|mounted
goto|;
comment|/* 	 * If we (still) have a compiled-in default, try it. 	 */
if|if
condition|(
name|ctrootdevname
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|vfs_mountroot_try
argument_list|(
name|ctrootdevname
argument_list|,
name|options
argument_list|)
condition|)
goto|goto
name|mounted
goto|;
comment|/* 	 * Everything so far has failed, prompt on the console if we haven't 	 * already tried that. 	 */
if|if
condition|(
operator|!
name|asked
condition|)
if|if
condition|(
operator|!
name|vfs_mountroot_ask
argument_list|()
condition|)
goto|goto
name|mounted
goto|;
name|panic
argument_list|(
literal|"Root mount failed, startup aborted."
argument_list|)
expr_stmt|;
name|mounted
label|:
name|root_mount_done
argument_list|()
expr_stmt|;
name|freeenv
argument_list|(
name|options
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mntarg
modifier|*
name|parse_mountroot_options
parameter_list|(
name|struct
name|mntarg
modifier|*
name|ma
parameter_list|,
specifier|const
name|char
modifier|*
name|options
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|name_arg
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|,
modifier|*
name|val_arg
decl_stmt|;
name|char
modifier|*
name|opts
decl_stmt|;
if|if
condition|(
name|options
operator|==
name|NULL
operator|||
name|options
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|ma
operator|)
return|;
name|p
operator|=
name|opts
operator|=
name|strdup
argument_list|(
name|options
argument_list|,
name|M_MOUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ma
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|name
operator|=
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
name|val
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|NULL
condition|)
block|{
operator|*
name|val
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|val
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"rw"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"noro"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The first time we mount the root file system, 			 * we need to mount 'ro', so We need to ignore 			 * 'rw' and 'noro' mount options. 			 */
continue|continue;
block|}
name|name_arg
operator|=
name|strdup
argument_list|(
name|name
argument_list|,
name|M_MOUNT
argument_list|)
expr_stmt|;
name|val_arg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|NULL
condition|)
name|val_arg
operator|=
name|strdup
argument_list|(
name|val
argument_list|,
name|M_MOUNT
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_arg
argument_list|(
name|ma
argument_list|,
name|name_arg
argument_list|,
name|val_arg
argument_list|,
operator|(
name|val_arg
operator|!=
name|NULL
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|opts
argument_list|,
name|M_MOUNT
argument_list|)
expr_stmt|;
return|return
operator|(
name|ma
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mount (mountfrom) as the root filesystem.  */
end_comment

begin_function
specifier|static
name|int
name|vfs_mountroot_try
parameter_list|(
specifier|const
name|char
modifier|*
name|mountfrom
parameter_list|,
specifier|const
name|char
modifier|*
name|options
parameter_list|)
block|{
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|mntarg
modifier|*
name|ma
decl_stmt|;
name|char
modifier|*
name|vfsname
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|time_t
name|timebase
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|patt
index|[
literal|32
index|]
decl_stmt|;
name|char
name|errmsg
index|[
literal|255
index|]
decl_stmt|;
name|vfsname
operator|=
name|NULL
expr_stmt|;
name|path
operator|=
name|NULL
expr_stmt|;
name|mp
operator|=
name|NULL
expr_stmt|;
name|ma
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
name|bzero
argument_list|(
name|errmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|errmsg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mountfrom
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* don't complain */
name|printf
argument_list|(
literal|"Trying to mount root from %s\n"
argument_list|,
name|mountfrom
argument_list|)
expr_stmt|;
comment|/* parse vfs name and path */
name|vfsname
operator|=
name|malloc
argument_list|(
name|MFSNAMELEN
argument_list|,
name|M_MOUNT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|path
operator|=
name|malloc
argument_list|(
name|MNAMELEN
argument_list|,
name|M_MOUNT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|vfsname
index|[
literal|0
index|]
operator|=
name|path
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|patt
argument_list|,
literal|"%%%d[a-z0-9]:%%%ds"
argument_list|,
name|MFSNAMELEN
argument_list|,
name|MNAMELEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|mountfrom
argument_list|,
name|patt
argument_list|,
name|vfsname
argument_list|,
name|path
argument_list|)
operator|<
literal|1
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|path
argument_list|,
name|ROOTNAME
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_arg
argument_list|(
name|ma
argument_list|,
literal|"fstype"
argument_list|,
name|vfsname
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_arg
argument_list|(
name|ma
argument_list|,
literal|"fspath"
argument_list|,
literal|"/"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_arg
argument_list|(
name|ma
argument_list|,
literal|"from"
argument_list|,
name|path
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_arg
argument_list|(
name|ma
argument_list|,
literal|"errmsg"
argument_list|,
name|errmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|errmsg
argument_list|)
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_arg
argument_list|(
name|ma
argument_list|,
literal|"ro"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ma
operator|=
name|parse_mountroot_options
argument_list|(
name|ma
argument_list|,
name|options
argument_list|)
expr_stmt|;
name|error
operator|=
name|kernel_mount
argument_list|(
name|ma
argument_list|,
name|MNT_ROOTFS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We mount devfs prior to mounting the / FS, so the first 		 * entry will typically be devfs. 		 */
name|mp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|mountlist
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|mp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: mountlist is empty"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Iterate over all currently mounted file systems and use 		 * the time stamp found to check and/or initialize the RTC. 		 * Typically devfs has no time stamp and the only other FS 		 * is the actual / FS. 		 * Call inittodr() only once and pass it the largest of the 		 * timestamps we encounter. 		 */
name|timebase
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|mp
operator|->
name|mnt_time
operator|>
name|timebase
condition|)
name|timebase
operator|=
name|mp
operator|->
name|mnt_time
expr_stmt|;
name|mp
operator|=
name|TAILQ_NEXT
argument_list|(
name|mp
argument_list|,
name|mnt_list
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|mp
operator|!=
name|NULL
condition|)
do|;
name|inittodr
argument_list|(
name|timebase
argument_list|)
expr_stmt|;
name|devfs_fixup
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ROOT MOUNT ERROR: %s\n"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"If you have invalid mount options, reboot, and "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"first try the following from\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"the loader prompt:\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"     set vfs.root.mountfrom.options=rw\n\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"and then remove invalid mount options from "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"/etc/fstab.\n\n"
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|free
argument_list|(
name|path
argument_list|,
name|M_MOUNT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vfsname
argument_list|,
name|M_MOUNT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vfs_mountroot_ask
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|name
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|mountfrom
decl_stmt|;
name|char
modifier|*
name|options
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|printf
argument_list|(
literal|"Loader variables:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vfs.root.mountfrom="
argument_list|)
expr_stmt|;
name|mountfrom
operator|=
name|getenv
argument_list|(
literal|"vfs.root.mountfrom"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mountfrom
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|mountfrom
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"vfs.root.mountfrom.options="
argument_list|)
expr_stmt|;
name|options
operator|=
name|getenv
argument_list|(
literal|"vfs.root.mountfrom.options"
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|options
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|freeenv
argument_list|(
name|mountfrom
argument_list|)
expr_stmt|;
name|freeenv
argument_list|(
name|options
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nManual root filesystem specification:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"<fstype>:<device>  Mount<device> using filesystem<fstype>\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"                       eg. zfs:tank\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"                       eg. ufs:/dev/da0s1a\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"                       eg. cd9660:/dev/acd0\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"                       This is equivalent to: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mount -t cd9660 /dev/acd0 /\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  ?                  List valid disk boot devices\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"<empty line>       Abort manual input\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nmountroot> "
argument_list|)
expr_stmt|;
name|gets
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'?'
condition|)
block|{
name|printf
argument_list|(
literal|"\nList of GEOM managed disk devices:\n  "
argument_list|)
expr_stmt|;
name|g_dev_print
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|vfs_mountroot_try
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

end_unit

