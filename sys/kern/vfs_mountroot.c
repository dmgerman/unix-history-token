begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010 Marcel Moolenaar  * Copyright (c) 1999-2004 Poul-Henning Kamp  * Copyright (c) 1999 Michael Smith  * Copyright (c) 1989, 1993  *      The Regents of the University of California.  All rights reserved.  * (c) UNIX System Laboratories, Inc.  * All or some portions of this file are derived from material licensed  * to the University of California by American Telephone and Telegraph  * Co. or Unix System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_rootdevname.h"
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mdioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom.h>
end_include

begin_comment
comment|/*  * The root filesystem is detailed in the kernel environment variable  * vfs.root.mountfrom, which is expected to be in the general format  *  *<vfsname>:[<path>][<vfsname>:[<path>] ...]  * vfsname   := the name of a VFS known to the kernel and capable  *              of being mounted as root  * path      := disk device name or other data used by the filesystem  *              to locate its physical store  *  * If the environment variable vfs.root.mountfrom is a space separated list,  * each list element is tried in turn and the root filesystem will be mounted  * from the first one that succeeds.  *  * The environment variable vfs.root.mountfrom.options is a comma delimited  * set of string mount options.  These mount options must be parseable  * by nmount() in the kernel.  */
end_comment

begin_function_decl
specifier|static
name|int
name|parse_mount
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mntarg
modifier|*
name|parse_mountroot_options
parameter_list|(
name|struct
name|mntarg
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_vfs_root_mount_hold
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vfs_mountroot_wait
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vfs_mountroot_wait_if_neccessary
parameter_list|(
specifier|const
name|char
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * The vnode of the system's root (/ in the filesystem, without chroot  * active.)  */
end_comment

begin_decl_stmt
name|struct
name|vnode
modifier|*
name|rootvnode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Mount of the system's /dev.  */
end_comment

begin_decl_stmt
name|struct
name|mount
modifier|*
name|rootdevmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rootdevnames
index|[
literal|2
index|]
init|=
block|{
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mtx
name|root_holds_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|root_holds
argument_list|,
operator|&
name|root_holds_mtx
argument_list|,
literal|"root_holds"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|root_hold_token
block|{
specifier|const
name|char
modifier|*
name|who
decl_stmt|;
name|LIST_ENTRY
argument_list|(
argument|root_hold_token
argument_list|)
name|list
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|root_hold_token
argument_list|)
name|root_holds
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|root_holds
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
name|action
block|{
name|A_CONTINUE
block|,
name|A_PANIC
block|,
name|A_REBOOT
block|,
name|A_RETRY
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|enum
name|action
name|root_mount_onfail
init|=
name|A_CONTINUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|root_mount_mddev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|root_mount_complete
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* By default wait up to 3 seconds for devices to appear. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|root_mount_timeout
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.mountroot.timeout"
argument_list|,
operator|&
name|root_mount_timeout
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|root_mount_always_wait
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|root_mount_always_wait
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|root_mount_always_wait
argument_list|,
literal|0
argument_list|,
literal|"Wait for root mount holds even if the root device already exists"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|root_mount_hold
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_vfs_root_mount_hold
argument_list|,
literal|"A"
argument_list|,
literal|"List of root mount hold tokens"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_vfs_root_mount_hold
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|sbuf
name|sb
decl_stmt|;
name|struct
name|root_hold_token
modifier|*
name|h
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|,
literal|256
argument_list|,
name|SBUF_AUTOEXTEND
operator||
name|SBUF_INCLUDENUL
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|root_holds_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|h
argument_list|,
argument|&root_holds
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|h
operator|!=
name|LIST_FIRST
argument_list|(
operator|&
name|root_holds
argument_list|)
condition|)
name|sbuf_putc
argument_list|(
operator|&
name|sb
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%s"
argument_list|,
name|h
operator|->
name|who
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|root_holds_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|sbuf_len
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|root_hold_token
modifier|*
name|root_mount_hold
parameter_list|(
specifier|const
name|char
modifier|*
name|identifier
parameter_list|)
block|{
name|struct
name|root_hold_token
modifier|*
name|h
decl_stmt|;
name|h
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|h
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|h
operator|->
name|who
operator|=
name|identifier
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|root_holds_mtx
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|root_holds
argument_list|,
name|h
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|root_holds_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|h
operator|)
return|;
block|}
end_function

begin_function
name|void
name|root_mount_rel
parameter_list|(
name|struct
name|root_hold_token
modifier|*
name|h
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: NULL token"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|root_holds_mtx
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|h
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|root_holds
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|root_holds_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|h
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|root_mounted
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* No mutex is acquired here because int stores are atomic. */
return|return
operator|(
name|root_mount_complete
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_rootvnode
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|VFS_ROOT
argument_list|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|mountlist
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
operator|&
name|rootvnode
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Cannot find root vnode"
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|rootvnode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|curthread
operator|->
name|td_proc
expr_stmt|;
name|FILEDESC_XLOCK
argument_list|(
name|p
operator|->
name|p_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_fd
operator|->
name|fd_cdir
operator|!=
name|NULL
condition|)
name|vrele
argument_list|(
name|p
operator|->
name|p_fd
operator|->
name|fd_cdir
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_fd
operator|->
name|fd_cdir
operator|=
name|rootvnode
expr_stmt|;
name|VREF
argument_list|(
name|rootvnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_fd
operator|->
name|fd_rdir
operator|!=
name|NULL
condition|)
name|vrele
argument_list|(
name|p
operator|->
name|p_fd
operator|->
name|fd_rdir
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_fd
operator|->
name|fd_rdir
operator|=
name|rootvnode
expr_stmt|;
name|VREF
argument_list|(
name|rootvnode
argument_list|)
expr_stmt|;
name|FILEDESC_XUNLOCK
argument_list|(
name|p
operator|->
name|p_fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vfs_mountroot_devfs
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|mount
modifier|*
modifier|*
name|mpp
parameter_list|)
block|{
name|struct
name|vfsoptlist
modifier|*
name|opts
decl_stmt|;
name|struct
name|vfsconf
modifier|*
name|vfsp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|mpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rootdevmp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Already have /dev; this happens during rerooting. 		 */
name|error
operator|=
name|vfs_busy
argument_list|(
name|rootdevmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|mpp
operator|=
name|rootdevmp
expr_stmt|;
block|}
else|else
block|{
name|vfsp
operator|=
name|vfs_byname
argument_list|(
literal|"devfs"
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vfsp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Could not find devfs by name"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfsp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|mp
operator|=
name|vfs_mount_alloc
argument_list|(
name|NULLVP
argument_list|,
name|vfsp
argument_list|,
literal|"/dev"
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
name|error
operator|=
name|VFS_MOUNT
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"VFS_MOUNT(devfs) failed %d"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|opts
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vfsoptlist
argument_list|)
argument_list|,
name|M_MOUNT
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
name|opts
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_opt
operator|=
name|opts
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|mountlist
argument_list|,
name|mp
argument_list|,
name|mnt_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
operator|*
name|mpp
operator|=
name|mp
expr_stmt|;
name|rootdevmp
operator|=
name|mp
expr_stmt|;
block|}
name|set_rootvnode
argument_list|()
expr_stmt|;
name|error
operator|=
name|kern_symlinkat
argument_list|(
name|td
argument_list|,
literal|"/"
argument_list|,
name|AT_FDCWD
argument_list|,
literal|"dev"
argument_list|,
name|UIO_SYSSPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"kern_symlink /dev -> / returns %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vfs_mountroot_shuffle
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|mount
modifier|*
name|mpdevfs
parameter_list|)
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|mount
modifier|*
name|mporoot
decl_stmt|,
modifier|*
name|mpnroot
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|,
modifier|*
name|vporoot
decl_stmt|,
modifier|*
name|vpdevfs
decl_stmt|;
name|char
modifier|*
name|fspath
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mpnroot
operator|=
name|TAILQ_NEXT
argument_list|(
name|mpdevfs
argument_list|,
name|mnt_list
argument_list|)
expr_stmt|;
comment|/* Shuffle the mountlist. */
name|mtx_lock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
name|mporoot
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|mountlist
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mountlist
argument_list|,
name|mpdevfs
argument_list|,
name|mnt_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|mporoot
operator|!=
name|mpdevfs
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mountlist
argument_list|,
name|mpnroot
argument_list|,
name|mnt_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|mountlist
argument_list|,
name|mpnroot
argument_list|,
name|mnt_list
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|mountlist
argument_list|,
name|mpdevfs
argument_list|,
name|mnt_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
name|cache_purgevfs
argument_list|(
name|mporoot
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|mporoot
operator|!=
name|mpdevfs
condition|)
name|cache_purgevfs
argument_list|(
name|mpdevfs
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|VFS_ROOT
argument_list|(
name|mporoot
argument_list|,
name|LK_EXCLUSIVE
argument_list|,
operator|&
name|vporoot
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|vporoot
argument_list|)
expr_stmt|;
name|vporoot
operator|->
name|v_iflag
operator|&=
operator|~
name|VI_MOUNT
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vporoot
argument_list|)
expr_stmt|;
name|vporoot
operator|->
name|v_mountedhere
operator|=
name|NULL
expr_stmt|;
name|mporoot
operator|->
name|mnt_flag
operator|&=
operator|~
name|MNT_ROOTFS
expr_stmt|;
name|mporoot
operator|->
name|mnt_vnodecovered
operator|=
name|NULL
expr_stmt|;
name|vput
argument_list|(
name|vporoot
argument_list|)
expr_stmt|;
comment|/* Set up the new rootvnode, and purge the cache */
name|mpnroot
operator|->
name|mnt_vnodecovered
operator|=
name|NULL
expr_stmt|;
name|set_rootvnode
argument_list|()
expr_stmt|;
name|cache_purgevfs
argument_list|(
name|rootvnode
operator|->
name|v_mount
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|mporoot
operator|!=
name|mpdevfs
condition|)
block|{
comment|/* Remount old root under /.mount or /mnt */
name|fspath
operator|=
literal|"/.mount"
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|fspath
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|fspath
operator|=
literal|"/mnt"
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|fspath
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|error
operator|=
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
operator|)
condition|?
literal|0
else|:
name|ENOTDIR
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|mporoot
operator|->
name|mnt_vnodecovered
operator|=
name|vp
expr_stmt|;
name|vp
operator|->
name|v_mountedhere
operator|=
name|mporoot
expr_stmt|;
name|strlcpy
argument_list|(
name|mporoot
operator|->
name|mnt_stat
operator|.
name|f_mntonname
argument_list|,
name|fspath
argument_list|,
name|MNAMELEN
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"mountroot: unable to remount previous root "
literal|"under /.mount or /mnt (error %d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* Remount devfs under /dev */
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_SYSSPACE
argument_list|,
literal|"/dev"
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|error
operator|=
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
operator|)
condition|?
literal|0
else|:
name|ENOTDIR
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|vpdevfs
operator|=
name|mpdevfs
operator|->
name|mnt_vnodecovered
expr_stmt|;
if|if
condition|(
name|vpdevfs
operator|!=
name|NULL
condition|)
block|{
name|cache_purge
argument_list|(
name|vpdevfs
argument_list|)
expr_stmt|;
name|vpdevfs
operator|->
name|v_mountedhere
operator|=
name|NULL
expr_stmt|;
name|vrele
argument_list|(
name|vpdevfs
argument_list|)
expr_stmt|;
block|}
name|mpdevfs
operator|->
name|mnt_vnodecovered
operator|=
name|vp
expr_stmt|;
name|vp
operator|->
name|v_mountedhere
operator|=
name|mpdevfs
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"mountroot: unable to remount devfs under /dev "
literal|"(error %d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|mporoot
operator|==
name|mpdevfs
condition|)
block|{
name|vfs_unbusy
argument_list|(
name|mpdevfs
argument_list|)
expr_stmt|;
comment|/* Unlink the no longer needed /dev/dev -> / symlink */
name|error
operator|=
name|kern_unlinkat
argument_list|(
name|td
argument_list|,
name|AT_FDCWD
argument_list|,
literal|"/dev/dev"
argument_list|,
name|UIO_SYSSPACE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"mountroot: unable to unlink /dev/dev "
literal|"(error %d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Configuration parser.  */
end_comment

begin_comment
comment|/* Parser character classes. */
end_comment

begin_define
define|#
directive|define
name|CC_WHITESPACE
value|-1
end_define

begin_define
define|#
directive|define
name|CC_NONWHITESPACE
value|-2
end_define

begin_comment
comment|/* Parse errors. */
end_comment

begin_define
define|#
directive|define
name|PE_EOF
value|-1
end_define

begin_define
define|#
directive|define
name|PE_EOL
value|-2
end_define

begin_function
specifier|static
name|__inline
name|int
name|parse_peek
parameter_list|(
name|char
modifier|*
modifier|*
name|conf
parameter_list|)
block|{
return|return
operator|(
operator|*
operator|*
name|conf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|parse_poke
parameter_list|(
name|char
modifier|*
modifier|*
name|conf
parameter_list|,
name|int
name|c
parameter_list|)
block|{
operator|*
operator|*
name|conf
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|parse_advance
parameter_list|(
name|char
modifier|*
modifier|*
name|conf
parameter_list|)
block|{
operator|(
operator|*
name|conf
operator|)
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_skipto
parameter_list|(
name|char
modifier|*
modifier|*
name|conf
parameter_list|,
name|int
name|mc
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|match
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|parse_peek
argument_list|(
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
operator|(
name|PE_EOF
operator|)
return|;
switch|switch
condition|(
name|mc
condition|)
block|{
case|case
name|CC_WHITESPACE
case|:
name|match
operator|=
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|CC_NONWHITESPACE
case|:
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
operator|(
name|PE_EOL
operator|)
return|;
name|match
operator|=
operator|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
default|default:
name|match
operator|=
operator|(
name|c
operator|==
name|mc
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|match
condition|)
break|break;
name|parse_advance
argument_list|(
name|conf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_token
parameter_list|(
name|char
modifier|*
modifier|*
name|conf
parameter_list|,
name|char
modifier|*
modifier|*
name|tok
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|tok
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|parse_skipto
argument_list|(
name|conf
argument_list|,
name|CC_NONWHITESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|p
operator|=
operator|*
name|conf
expr_stmt|;
name|error
operator|=
name|parse_skipto
argument_list|(
name|conf
argument_list|,
name|CC_WHITESPACE
argument_list|)
expr_stmt|;
name|len
operator|=
operator|*
name|conf
operator|-
name|p
expr_stmt|;
operator|*
name|tok
operator|=
name|malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|p
argument_list|,
operator|*
name|tok
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_dir_ask_printenv
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|)
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|val
operator|=
name|kern_getenv
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"  %s=%s\n"
argument_list|,
name|var
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|freeenv
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|parse_dir_ask
parameter_list|(
name|char
modifier|*
modifier|*
name|conf
parameter_list|)
block|{
name|char
name|name
index|[
literal|80
index|]
decl_stmt|;
name|char
modifier|*
name|mnt
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vfs_mountroot_wait
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"\nLoader variables:\n"
argument_list|)
expr_stmt|;
name|parse_dir_ask_printenv
argument_list|(
literal|"vfs.root.mountfrom"
argument_list|)
expr_stmt|;
name|parse_dir_ask_printenv
argument_list|(
literal|"vfs.root.mountfrom.options"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nManual root filesystem specification:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"<fstype>:<device> [options]\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      Mount<device> using filesystem<fstype>\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"      and with the specified (optional) option list.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"    eg. ufs:/dev/da0s1a\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        zfs:tank\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"        cd9660:/dev/cd0 ro\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"          (which is equivalent to: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"mount -t cd9660 -o ro /dev/cd0 /)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  ?               List valid disk boot devices\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  .               Yield 1 second (for background tasks)\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"<empty line>    Abort manual input\n"
argument_list|)
expr_stmt|;
do|do
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|printf
argument_list|(
literal|"\nmountroot> "
argument_list|)
expr_stmt|;
name|cngets
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
name|GETS_ECHO
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'?'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"\nList of GEOM managed disk devices:\n  "
argument_list|)
expr_stmt|;
name|g_dev_print
argument_list|()
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|pause
argument_list|(
literal|"rmask"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|mnt
operator|=
name|name
expr_stmt|;
name|error
operator|=
name|parse_mount
argument_list|(
operator|&
name|mnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
name|printf
argument_list|(
literal|"Invalid file system specification.\n"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|!=
literal|0
condition|)
do|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_dir_md
parameter_list|(
name|char
modifier|*
modifier|*
name|conf
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|md_ioctl
modifier|*
name|mdio
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|tok
decl_stmt|;
name|int
name|error
decl_stmt|,
name|fd
decl_stmt|,
name|len
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|error
operator|=
name|parse_token
argument_list|(
name|conf
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|len
operator|=
name|strlen
argument_list|(
name|tok
argument_list|)
expr_stmt|;
name|mdio
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mdio
argument_list|)
operator|+
name|len
operator|+
literal|1
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|path
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|mdio
operator|+
literal|1
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|tok
argument_list|,
name|path
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tok
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
comment|/* Get file status. */
name|error
operator|=
name|kern_statat
argument_list|(
name|td
argument_list|,
literal|0
argument_list|,
name|AT_FDCWD
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
operator|&
name|sb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* Open /dev/mdctl so that we can attach/detach. */
name|error
operator|=
name|kern_openat
argument_list|(
name|td
argument_list|,
name|AT_FDCWD
argument_list|,
literal|"/dev/"
name|MDCTL_NAME
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|O_RDWR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|fd
operator|=
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
expr_stmt|;
name|mdio
operator|->
name|md_version
operator|=
name|MDIOVERSION
expr_stmt|;
name|mdio
operator|->
name|md_type
operator|=
name|MD_VNODE
expr_stmt|;
if|if
condition|(
name|root_mount_mddev
operator|!=
operator|-
literal|1
condition|)
block|{
name|mdio
operator|->
name|md_unit
operator|=
name|root_mount_mddev
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|error
operator|=
name|kern_ioctl
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
name|MDIOCDETACH
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mdio
argument_list|)
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
comment|/* Ignore errors. We don't care. */
name|root_mount_mddev
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|mdio
operator|->
name|md_file
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|mdio
operator|+
literal|1
operator|)
expr_stmt|;
name|mdio
operator|->
name|md_options
operator|=
name|MD_AUTOUNIT
operator||
name|MD_READONLY
expr_stmt|;
name|mdio
operator|->
name|md_mediasize
operator|=
name|sb
operator|.
name|st_size
expr_stmt|;
name|mdio
operator|->
name|md_unit
operator|=
literal|0
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|error
operator|=
name|kern_ioctl
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
name|MDIOCATTACH
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mdio
argument_list|)
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|mdio
operator|->
name|md_unit
operator|>
literal|9
condition|)
block|{
name|printf
argument_list|(
literal|"rootmount: too many md units\n"
argument_list|)
expr_stmt|;
name|mdio
operator|->
name|md_file
operator|=
name|NULL
expr_stmt|;
name|mdio
operator|->
name|md_options
operator|=
literal|0
expr_stmt|;
name|mdio
operator|->
name|md_mediasize
operator|=
literal|0
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|error
operator|=
name|kern_ioctl
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
name|MDIOCDETACH
argument_list|,
operator|(
name|void
operator|*
operator|)
name|mdio
argument_list|)
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
comment|/* Ignore errors. We don't care. */
name|error
operator|=
name|ERANGE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|root_mount_mddev
operator|=
name|mdio
operator|->
name|md_unit
expr_stmt|;
name|printf
argument_list|(
name|MD_NAME
literal|"%u attached to %s\n"
argument_list|,
name|root_mount_mddev
argument_list|,
name|mdio
operator|->
name|md_file
argument_list|)
expr_stmt|;
name|error
operator|=
name|kern_close
argument_list|(
name|td
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|mdio
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_dir_onfail
parameter_list|(
name|char
modifier|*
modifier|*
name|conf
parameter_list|)
block|{
name|char
modifier|*
name|action
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|parse_token
argument_list|(
name|conf
argument_list|,
operator|&
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|action
argument_list|,
literal|"continue"
argument_list|)
condition|)
name|root_mount_onfail
operator|=
name|A_CONTINUE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|action
argument_list|,
literal|"panic"
argument_list|)
condition|)
name|root_mount_onfail
operator|=
name|A_PANIC
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|action
argument_list|,
literal|"reboot"
argument_list|)
condition|)
name|root_mount_onfail
operator|=
name|A_REBOOT
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|action
argument_list|,
literal|"retry"
argument_list|)
condition|)
name|root_mount_onfail
operator|=
name|A_RETRY
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"rootmount: %s: unknown action\n"
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|free
argument_list|(
name|action
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_dir_timeout
parameter_list|(
name|char
modifier|*
modifier|*
name|conf
parameter_list|)
block|{
name|char
modifier|*
name|tok
decl_stmt|,
modifier|*
name|endtok
decl_stmt|;
name|long
name|secs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|parse_token
argument_list|(
name|conf
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|secs
operator|=
name|strtol
argument_list|(
name|tok
argument_list|,
operator|&
name|endtok
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
operator|(
name|secs
operator|<
literal|0
operator|||
operator|*
name|endtok
operator|!=
literal|'\0'
operator|)
condition|?
name|EINVAL
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|root_mount_timeout
operator|=
name|secs
expr_stmt|;
name|free
argument_list|(
name|tok
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_directive
parameter_list|(
name|char
modifier|*
modifier|*
name|conf
parameter_list|)
block|{
name|char
modifier|*
name|dir
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|parse_token
argument_list|(
name|conf
argument_list|,
operator|&
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|dir
argument_list|,
literal|".ask"
argument_list|)
operator|==
literal|0
condition|)
name|error
operator|=
name|parse_dir_ask
argument_list|(
name|conf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|dir
argument_list|,
literal|".md"
argument_list|)
operator|==
literal|0
condition|)
name|error
operator|=
name|parse_dir_md
argument_list|(
name|conf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|dir
argument_list|,
literal|".onfail"
argument_list|)
operator|==
literal|0
condition|)
name|error
operator|=
name|parse_dir_onfail
argument_list|(
name|conf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|dir
argument_list|,
literal|".timeout"
argument_list|)
operator|==
literal|0
condition|)
name|error
operator|=
name|parse_dir_timeout
argument_list|(
name|conf
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"mountroot: invalid directive `%s'\n"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
comment|/* Ignore the rest of the line. */
operator|(
name|void
operator|)
name|parse_skipto
argument_list|(
name|conf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|free
argument_list|(
name|dir
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_mount_dev_present
parameter_list|(
specifier|const
name|char
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|dev
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|vput
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|!=
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ERRMSGL
value|255
end_define

begin_function
specifier|static
name|int
name|parse_mount
parameter_list|(
name|char
modifier|*
modifier|*
name|conf
parameter_list|)
block|{
name|char
modifier|*
name|errmsg
decl_stmt|;
name|struct
name|mntarg
modifier|*
name|ma
decl_stmt|;
name|char
modifier|*
name|dev
decl_stmt|,
modifier|*
name|fs
decl_stmt|,
modifier|*
name|opts
decl_stmt|,
modifier|*
name|tok
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|parse_token
argument_list|(
name|conf
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|fs
operator|=
name|tok
expr_stmt|;
name|error
operator|=
name|parse_skipto
argument_list|(
operator|&
name|tok
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|fs
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|parse_poke
argument_list|(
operator|&
name|tok
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|parse_advance
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
name|dev
operator|=
name|tok
expr_stmt|;
if|if
condition|(
name|root_mount_mddev
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Handle substitution for the md unit number. */
name|tok
operator|=
name|strstr
argument_list|(
name|dev
argument_list|,
literal|"md#"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|!=
name|NULL
condition|)
name|tok
index|[
literal|2
index|]
operator|=
literal|'0'
operator|+
name|root_mount_mddev
expr_stmt|;
block|}
comment|/* Parse options. */
name|error
operator|=
name|parse_token
argument_list|(
name|conf
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|opts
operator|=
operator|(
name|error
operator|==
literal|0
operator|)
condition|?
name|tok
else|:
name|NULL
expr_stmt|;
name|printf
argument_list|(
literal|"Trying to mount root from %s:%s [%s]...\n"
argument_list|,
name|fs
argument_list|,
name|dev
argument_list|,
operator|(
name|opts
operator|!=
name|NULL
operator|)
condition|?
name|opts
else|:
literal|""
argument_list|)
expr_stmt|;
name|errmsg
operator|=
name|malloc
argument_list|(
name|ERRMSGL
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfs_byname
argument_list|(
name|fs
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|strlcpy
argument_list|(
name|errmsg
argument_list|,
literal|"unknown file system"
argument_list|,
name|ERRMSGL
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|vfs_mountroot_wait_if_neccessary
argument_list|(
name|fs
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|ma
operator|=
name|NULL
expr_stmt|;
name|ma
operator|=
name|mount_arg
argument_list|(
name|ma
argument_list|,
literal|"fstype"
argument_list|,
name|fs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_arg
argument_list|(
name|ma
argument_list|,
literal|"fspath"
argument_list|,
literal|"/"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_arg
argument_list|(
name|ma
argument_list|,
literal|"from"
argument_list|,
name|dev
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_arg
argument_list|(
name|ma
argument_list|,
literal|"errmsg"
argument_list|,
name|errmsg
argument_list|,
name|ERRMSGL
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_arg
argument_list|(
name|ma
argument_list|,
literal|"ro"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ma
operator|=
name|parse_mountroot_options
argument_list|(
name|ma
argument_list|,
name|opts
argument_list|)
expr_stmt|;
name|error
operator|=
name|kernel_mount
argument_list|(
name|ma
argument_list|,
name|MNT_ROOTFS
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"Mounting from %s:%s failed with error %d"
argument_list|,
name|fs
argument_list|,
name|dev
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|printf
argument_list|(
literal|": %s"
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|fs
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|errmsg
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|opts
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
comment|/* kernel_mount can return -1 on error. */
return|return
operator|(
operator|(
name|error
operator|<
literal|0
operator|)
condition|?
name|EDOOFUS
else|:
name|error
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|ERRMSGL
end_undef

begin_function
specifier|static
name|int
name|vfs_mountroot_parse
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|mount
modifier|*
name|mpdevfs
parameter_list|)
block|{
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|conf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|root_mount_mddev
operator|=
operator|-
literal|1
expr_stmt|;
name|retry
label|:
name|conf
operator|=
name|sbuf_data
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|mp
operator|=
name|TAILQ_NEXT
argument_list|(
name|mpdevfs
argument_list|,
name|mnt_list
argument_list|)
expr_stmt|;
name|error
operator|=
operator|(
name|mp
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|EDOOFUS
expr_stmt|;
name|root_mount_onfail
operator|=
name|A_CONTINUE
expr_stmt|;
while|while
condition|(
name|mp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|parse_skipto
argument_list|(
operator|&
name|conf
argument_list|,
name|CC_NONWHITESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|PE_EOL
condition|)
block|{
name|parse_advance
argument_list|(
operator|&
name|conf
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|error
operator|<
literal|0
condition|)
break|break;
switch|switch
condition|(
name|parse_peek
argument_list|(
operator|&
name|conf
argument_list|)
condition|)
block|{
case|case
literal|'#'
case|:
name|error
operator|=
name|parse_skipto
argument_list|(
operator|&
name|conf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|error
operator|=
name|parse_directive
argument_list|(
operator|&
name|conf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|parse_mount
argument_list|(
operator|&
name|conf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"mountroot: invalid file system "
literal|"specification.\n"
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|error
operator|<
literal|0
condition|)
break|break;
comment|/* Ignore any trailing garbage on the line. */
if|if
condition|(
name|parse_peek
argument_list|(
operator|&
name|conf
argument_list|)
operator|!=
literal|'\n'
condition|)
block|{
name|printf
argument_list|(
literal|"mountroot: advancing to next directive...\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|parse_skipto
argument_list|(
operator|&
name|conf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|mp
operator|=
name|TAILQ_NEXT
argument_list|(
name|mpdevfs
argument_list|,
name|mnt_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mp
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * We failed to mount (a new) root. 	 */
switch|switch
condition|(
name|root_mount_onfail
condition|)
block|{
case|case
name|A_CONTINUE
case|:
break|break;
case|case
name|A_PANIC
case|:
name|panic
argument_list|(
literal|"mountroot: unable to (re-)mount root."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|A_RETRY
case|:
goto|goto
name|retry
goto|;
case|case
name|A_REBOOT
case|:
name|kern_reboot
argument_list|(
name|RB_NOSYNC
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vfs_mountroot_conf0
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|tok
decl_stmt|,
modifier|*
name|mnt
decl_stmt|,
modifier|*
name|opt
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|".onfail panic\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|".timeout %d\n"
argument_list|,
name|root_mount_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|boothowto
operator|&
name|RB_ASKNAME
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|".ask\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ROOTDEVNAME
if|if
condition|(
name|boothowto
operator|&
name|RB_DFLTROOT
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s\n"
argument_list|,
name|ROOTDEVNAME
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|boothowto
operator|&
name|RB_CDROM
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"cd9660:/dev/cd0 ro\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|".timeout 0\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"cd9660:/dev/cd1 ro\n"
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|".timeout %d\n"
argument_list|,
name|root_mount_timeout
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|kern_getenv
argument_list|(
literal|"vfs.root.mountfrom"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
block|{
name|opt
operator|=
name|kern_getenv
argument_list|(
literal|"vfs.root.mountfrom.options"
argument_list|)
expr_stmt|;
name|tok
operator|=
name|s
expr_stmt|;
name|error
operator|=
name|parse_token
argument_list|(
operator|&
name|tok
argument_list|,
operator|&
name|mnt
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|error
condition|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s %s\n"
argument_list|,
name|mnt
argument_list|,
operator|(
name|opt
operator|!=
name|NULL
operator|)
condition|?
name|opt
else|:
literal|""
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mnt
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|parse_token
argument_list|(
operator|&
name|tok
argument_list|,
operator|&
name|mnt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opt
operator|!=
name|NULL
condition|)
name|freeenv
argument_list|(
name|opt
argument_list|)
expr_stmt|;
name|freeenv
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rootdevnames
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s\n"
argument_list|,
name|rootdevnames
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rootdevnames
index|[
literal|1
index|]
operator|!=
name|NULL
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s\n"
argument_list|,
name|rootdevnames
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ROOTDEVNAME
if|if
condition|(
operator|!
operator|(
name|boothowto
operator|&
name|RB_DFLTROOT
operator|)
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s\n"
argument_list|,
name|ROOTDEVNAME
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|boothowto
operator|&
name|RB_ASKNAME
operator|)
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|".ask\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vfs_mountroot_readconf
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|off_t
name|ofs
decl_stmt|;
name|ssize_t
name|resid
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|,
name|len
decl_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
argument_list|,
name|UIO_SYSSPACE
argument_list|,
literal|"/.mount.conf"
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|flags
operator|=
name|FREAD
expr_stmt|;
name|error
operator|=
name|vn_open
argument_list|(
operator|&
name|nd
argument_list|,
operator|&
name|flags
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|ofs
operator|=
literal|0
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|ofs
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|resid
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|resid
operator|==
name|len
condition|)
break|break;
name|buf
index|[
name|len
operator|-
name|resid
index|]
operator|=
literal|0
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|ofs
operator|+=
name|len
operator|-
name|resid
expr_stmt|;
block|}
name|VOP_UNLOCK
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vn_close
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
name|FREAD
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vfs_mountroot_wait
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|root_hold_token
modifier|*
name|h
decl_stmt|;
name|struct
name|timeval
name|lastfail
decl_stmt|;
name|int
name|curfail
decl_stmt|;
name|curfail
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_waitidle
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|root_holds_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|root_holds
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|root_holds_mtx
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ppsratecheck
argument_list|(
operator|&
name|lastfail
argument_list|,
operator|&
name|curfail
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Root mount waiting for:"
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|h
argument_list|,
argument|&root_holds
argument_list|,
argument|list
argument_list|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|h
operator|->
name|who
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|msleep
argument_list|(
operator|&
name|root_holds
argument_list|,
operator|&
name|root_holds_mtx
argument_list|,
name|PZERO
operator||
name|PDROP
argument_list|,
literal|"roothold"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vfs_mountroot_wait_if_neccessary
parameter_list|(
specifier|const
name|char
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|delay
decl_stmt|,
name|timeout
decl_stmt|;
comment|/* 	 * In case of ZFS and NFS we don't have a way to wait for 	 * specific device.  Also do the wait if the user forced that 	 * behaviour by setting vfs.root_mount_always_wait=1. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|fs
argument_list|,
literal|"zfs"
argument_list|)
operator|==
literal|0
operator|||
name|strstr
argument_list|(
name|fs
argument_list|,
literal|"nfs"
argument_list|)
operator|!=
name|NULL
operator|||
name|dev
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|root_mount_always_wait
operator|!=
literal|0
condition|)
block|{
name|vfs_mountroot_wait
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Otherwise, no point in waiting if the device is already there. 	 * Note that we must wait for GEOM to finish reconfiguring itself, 	 * eg for geom_part(4) to finish tasting. 	 */
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|g_waitidle
argument_list|()
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
if|if
condition|(
name|parse_mount_dev_present
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * No luck.  Let's wait.  This code looks weird, but it's that way 	 * to behave exactly as it used to work before. 	 */
name|vfs_mountroot_wait
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"mountroot: waiting for device %s...\n"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|delay
operator|=
name|hz
operator|/
literal|10
expr_stmt|;
name|timeout
operator|=
name|root_mount_timeout
operator|*
name|hz
expr_stmt|;
do|do
block|{
name|pause
argument_list|(
literal|"rmdev"
argument_list|,
name|delay
argument_list|)
expr_stmt|;
name|timeout
operator|-=
name|delay
expr_stmt|;
block|}
do|while
condition|(
name|timeout
operator|>
literal|0
operator|&&
operator|!
name|parse_mount_dev_present
argument_list|(
name|dev
argument_list|)
condition|)
do|;
if|if
condition|(
name|timeout
operator|<=
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vfs_mountroot
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|time_t
name|timebase
decl_stmt|;
name|int
name|error
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|sb
operator|=
name|sbuf_new_auto
argument_list|()
expr_stmt|;
name|vfs_mountroot_conf0
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|error
operator|=
name|vfs_mountroot_devfs
argument_list|(
name|td
argument_list|,
operator|&
name|mp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|vfs_mountroot_parse
argument_list|(
name|sb
argument_list|,
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|vfs_mountroot_shuffle
argument_list|(
name|td
argument_list|,
name|mp
argument_list|)
expr_stmt|;
name|sbuf_clear
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|error
operator|=
name|vfs_mountroot_readconf
argument_list|(
name|td
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
block|}
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|/* 	 * Iterate over all currently mounted file systems and use 	 * the time stamp found to check and/or initialize the RTC. 	 * Call inittodr() only once and pass it the largest of the 	 * timestamps we encounter. 	 */
name|timebase
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
name|mp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|mountlist
argument_list|)
expr_stmt|;
while|while
condition|(
name|mp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mp
operator|->
name|mnt_time
operator|>
name|timebase
condition|)
name|timebase
operator|=
name|mp
operator|->
name|mnt_time
expr_stmt|;
name|mp
operator|=
name|TAILQ_NEXT
argument_list|(
name|mp
argument_list|,
name|mnt_list
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|mountlist_mtx
argument_list|)
expr_stmt|;
name|inittodr
argument_list|(
name|timebase
argument_list|)
expr_stmt|;
comment|/* Keep prison0's root in sync with the global rootvnode. */
name|mtx_lock
argument_list|(
operator|&
name|prison0
operator|.
name|pr_mtx
argument_list|)
expr_stmt|;
name|prison0
operator|.
name|pr_root
operator|=
name|rootvnode
expr_stmt|;
name|vref
argument_list|(
name|prison0
operator|.
name|pr_root
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|prison0
operator|.
name|pr_mtx
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|root_holds_mtx
argument_list|)
expr_stmt|;
name|atomic_store_rel_int
argument_list|(
operator|&
name|root_mount_complete
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|root_mount_complete
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|root_holds_mtx
argument_list|)
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|mountroot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mntarg
modifier|*
name|parse_mountroot_options
parameter_list|(
name|struct
name|mntarg
modifier|*
name|ma
parameter_list|,
specifier|const
name|char
modifier|*
name|options
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|name_arg
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|,
modifier|*
name|val_arg
decl_stmt|;
name|char
modifier|*
name|opts
decl_stmt|;
if|if
condition|(
name|options
operator|==
name|NULL
operator|||
name|options
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|ma
operator|)
return|;
name|p
operator|=
name|opts
operator|=
name|strdup
argument_list|(
name|options
argument_list|,
name|M_MOUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ma
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|name
operator|=
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
name|val
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|NULL
condition|)
block|{
operator|*
name|val
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|val
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"rw"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"noro"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The first time we mount the root file system, 			 * we need to mount 'ro', so We need to ignore 			 * 'rw' and 'noro' mount options. 			 */
continue|continue;
block|}
name|name_arg
operator|=
name|strdup
argument_list|(
name|name
argument_list|,
name|M_MOUNT
argument_list|)
expr_stmt|;
name|val_arg
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|NULL
condition|)
name|val_arg
operator|=
name|strdup
argument_list|(
name|val
argument_list|,
name|M_MOUNT
argument_list|)
expr_stmt|;
name|ma
operator|=
name|mount_arg
argument_list|(
name|ma
argument_list|,
name|name_arg
argument_list|,
name|val_arg
argument_list|,
operator|(
name|val_arg
operator|!=
name|NULL
condition|?
operator|-
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|opts
argument_list|,
name|M_MOUNT
argument_list|)
expr_stmt|;
return|return
operator|(
name|ma
operator|)
return|;
block|}
end_function

end_unit

