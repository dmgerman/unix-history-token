begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Edward Tomasz Napierala under sponsorship  * from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/loginclass.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/racct.h>
end_include

begin_include
include|#
directive|include
file|<sys/rctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/tree.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RCTL
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|RACCT
end_ifndef

begin_error
error|#
directive|error
literal|"The RCTL option requires the RACCT option"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|FEATURE
argument_list|(
name|rctl
argument_list|,
literal|"Resource Limits"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|HRF_DEFAULT
value|0
end_define

begin_define
define|#
directive|define
name|HRF_DONT_INHERIT
value|1
end_define

begin_define
define|#
directive|define
name|HRF_DONT_ACCUMULATE
value|2
end_define

begin_comment
comment|/* Default buffer size for rctl_get_rules(2). */
end_comment

begin_define
define|#
directive|define
name|RCTL_DEFAULT_BUFSIZE
value|4096
end_define

begin_define
define|#
directive|define
name|RCTL_LOG_BUFSIZE
value|128
end_define

begin_comment
comment|/*  * 'rctl_rule_link' connects a rule with every racct it's related to.  * For example, rule 'user:X:openfiles:deny=N/process' is linked  * with uidinfo for user X, and to each process of that user.  */
end_comment

begin_struct
struct|struct
name|rctl_rule_link
block|{
name|LIST_ENTRY
argument_list|(
argument|rctl_rule_link
argument_list|)
name|rrl_next
expr_stmt|;
name|struct
name|rctl_rule
modifier|*
name|rrl_rule
decl_stmt|;
name|int
name|rrl_exceeded
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dict
block|{
specifier|const
name|char
modifier|*
name|d_name
decl_stmt|;
name|int
name|d_value
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|dict
name|subjectnames
index|[]
init|=
block|{
block|{
literal|"process"
block|,
name|RCTL_SUBJECT_TYPE_PROCESS
block|}
block|,
block|{
literal|"user"
block|,
name|RCTL_SUBJECT_TYPE_USER
block|}
block|,
block|{
literal|"loginclass"
block|,
name|RCTL_SUBJECT_TYPE_LOGINCLASS
block|}
block|,
block|{
literal|"jail"
block|,
name|RCTL_SUBJECT_TYPE_JAIL
block|}
block|,
block|{
name|NULL
block|,
operator|-
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dict
name|resourcenames
index|[]
init|=
block|{
block|{
literal|"cputime"
block|,
name|RACCT_CPU
block|}
block|,
block|{
literal|"datasize"
block|,
name|RACCT_DATA
block|}
block|,
block|{
literal|"stacksize"
block|,
name|RACCT_STACK
block|}
block|,
block|{
literal|"coredumpsize"
block|,
name|RACCT_CORE
block|}
block|,
block|{
literal|"memoryuse"
block|,
name|RACCT_RSS
block|}
block|,
block|{
literal|"memorylocked"
block|,
name|RACCT_MEMLOCK
block|}
block|,
block|{
literal|"maxproc"
block|,
name|RACCT_NPROC
block|}
block|,
block|{
literal|"openfiles"
block|,
name|RACCT_NOFILE
block|}
block|,
block|{
literal|"vmemoryuse"
block|,
name|RACCT_VMEM
block|}
block|,
block|{
literal|"pseudoterminals"
block|,
name|RACCT_NPTS
block|}
block|,
block|{
literal|"swapuse"
block|,
name|RACCT_SWAP
block|}
block|,
block|{
literal|"nthr"
block|,
name|RACCT_NTHR
block|}
block|,
block|{
literal|"msgqqueued"
block|,
name|RACCT_MSGQQUEUED
block|}
block|,
block|{
literal|"msgqsize"
block|,
name|RACCT_MSGQSIZE
block|}
block|,
block|{
literal|"nmsgq"
block|,
name|RACCT_NMSGQ
block|}
block|,
block|{
literal|"nsem"
block|,
name|RACCT_NSEM
block|}
block|,
block|{
literal|"nsemop"
block|,
name|RACCT_NSEMOP
block|}
block|,
block|{
literal|"nshm"
block|,
name|RACCT_NSHM
block|}
block|,
block|{
literal|"shmsize"
block|,
name|RACCT_SHMSIZE
block|}
block|,
block|{
literal|"wallclock"
block|,
name|RACCT_WALLCLOCK
block|}
block|,
block|{
name|NULL
block|,
operator|-
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dict
name|actionnames
index|[]
init|=
block|{
block|{
literal|"sighup"
block|,
name|RCTL_ACTION_SIGHUP
block|}
block|,
block|{
literal|"sigint"
block|,
name|RCTL_ACTION_SIGINT
block|}
block|,
block|{
literal|"sigquit"
block|,
name|RCTL_ACTION_SIGQUIT
block|}
block|,
block|{
literal|"sigill"
block|,
name|RCTL_ACTION_SIGILL
block|}
block|,
block|{
literal|"sigtrap"
block|,
name|RCTL_ACTION_SIGTRAP
block|}
block|,
block|{
literal|"sigabrt"
block|,
name|RCTL_ACTION_SIGABRT
block|}
block|,
block|{
literal|"sigemt"
block|,
name|RCTL_ACTION_SIGEMT
block|}
block|,
block|{
literal|"sigfpe"
block|,
name|RCTL_ACTION_SIGFPE
block|}
block|,
block|{
literal|"sigkill"
block|,
name|RCTL_ACTION_SIGKILL
block|}
block|,
block|{
literal|"sigbus"
block|,
name|RCTL_ACTION_SIGBUS
block|}
block|,
block|{
literal|"sigsegv"
block|,
name|RCTL_ACTION_SIGSEGV
block|}
block|,
block|{
literal|"sigsys"
block|,
name|RCTL_ACTION_SIGSYS
block|}
block|,
block|{
literal|"sigpipe"
block|,
name|RCTL_ACTION_SIGPIPE
block|}
block|,
block|{
literal|"sigalrm"
block|,
name|RCTL_ACTION_SIGALRM
block|}
block|,
block|{
literal|"sigterm"
block|,
name|RCTL_ACTION_SIGTERM
block|}
block|,
block|{
literal|"sigurg"
block|,
name|RCTL_ACTION_SIGURG
block|}
block|,
block|{
literal|"sigstop"
block|,
name|RCTL_ACTION_SIGSTOP
block|}
block|,
block|{
literal|"sigtstp"
block|,
name|RCTL_ACTION_SIGTSTP
block|}
block|,
block|{
literal|"sigchld"
block|,
name|RCTL_ACTION_SIGCHLD
block|}
block|,
block|{
literal|"sigttin"
block|,
name|RCTL_ACTION_SIGTTIN
block|}
block|,
block|{
literal|"sigttou"
block|,
name|RCTL_ACTION_SIGTTOU
block|}
block|,
block|{
literal|"sigio"
block|,
name|RCTL_ACTION_SIGIO
block|}
block|,
block|{
literal|"sigxcpu"
block|,
name|RCTL_ACTION_SIGXCPU
block|}
block|,
block|{
literal|"sigxfsz"
block|,
name|RCTL_ACTION_SIGXFSZ
block|}
block|,
block|{
literal|"sigvtalrm"
block|,
name|RCTL_ACTION_SIGVTALRM
block|}
block|,
block|{
literal|"sigprof"
block|,
name|RCTL_ACTION_SIGPROF
block|}
block|,
block|{
literal|"sigwinch"
block|,
name|RCTL_ACTION_SIGWINCH
block|}
block|,
block|{
literal|"siginfo"
block|,
name|RCTL_ACTION_SIGINFO
block|}
block|,
block|{
literal|"sigusr1"
block|,
name|RCTL_ACTION_SIGUSR1
block|}
block|,
block|{
literal|"sigusr2"
block|,
name|RCTL_ACTION_SIGUSR2
block|}
block|,
block|{
literal|"sigthr"
block|,
name|RCTL_ACTION_SIGTHR
block|}
block|,
block|{
literal|"deny"
block|,
name|RCTL_ACTION_DENY
block|}
block|,
block|{
literal|"log"
block|,
name|RCTL_ACTION_LOG
block|}
block|,
block|{
literal|"devctl"
block|,
name|RCTL_ACTION_DEVCTL
block|}
block|,
block|{
name|NULL
block|,
operator|-
literal|1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|rctl_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSINIT
argument_list|(
name|rctl
argument_list|,
name|SI_SUB_RACCT
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|rctl_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|rctl_rule_link_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|rctl_rule_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rwlock
name|rctl_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|RW_SYSINIT
argument_list|(
name|rctl_lock
argument_list|,
operator|&
name|rctl_lock
argument_list|,
literal|"RCTL lock"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|rctl_rule_fully_specified
parameter_list|(
specifier|const
name|struct
name|rctl_rule
modifier|*
name|rule
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rctl_rule_to_sbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|struct
name|rctl_rule
modifier|*
name|rule
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_RCTL
argument_list|,
literal|"rctl"
argument_list|,
literal|"Resource Limits"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|rctl_subject_type_name
parameter_list|(
name|int
name|subject
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|subjectnames
index|[
name|i
index|]
operator|.
name|d_name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|subjectnames
index|[
name|i
index|]
operator|.
name|d_value
operator|==
name|subject
condition|)
return|return
operator|(
name|subjectnames
index|[
name|i
index|]
operator|.
name|d_name
operator|)
return|;
block|}
name|panic
argument_list|(
literal|"rctl_subject_type_name: unknown subject type %d"
argument_list|,
name|subject
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|rctl_action_name
parameter_list|(
name|int
name|action
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|actionnames
index|[
name|i
index|]
operator|.
name|d_name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|actionnames
index|[
name|i
index|]
operator|.
name|d_value
operator|==
name|action
condition|)
return|return
operator|(
name|actionnames
index|[
name|i
index|]
operator|.
name|d_name
operator|)
return|;
block|}
name|panic
argument_list|(
literal|"rctl_action_name: unknown action %d"
argument_list|,
name|action
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|rctl_resource_name
parameter_list|(
name|int
name|resource
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|resourcenames
index|[
name|i
index|]
operator|.
name|d_name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|resourcenames
index|[
name|i
index|]
operator|.
name|d_value
operator|==
name|resource
condition|)
return|return
operator|(
name|resourcenames
index|[
name|i
index|]
operator|.
name|d_name
operator|)
return|;
block|}
name|panic
argument_list|(
literal|"rctl_resource_name: unknown resource %d"
argument_list|,
name|resource
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the amount of resource that can be allocated by 'p' before  * hitting 'rule'.  */
end_comment

begin_function
specifier|static
name|int64_t
name|rctl_available_resource
parameter_list|(
specifier|const
name|struct
name|proc
modifier|*
name|p
parameter_list|,
specifier|const
name|struct
name|rctl_rule
modifier|*
name|rule
parameter_list|)
block|{
name|int
name|resource
decl_stmt|;
name|int64_t
name|available
init|=
name|INT64_MAX
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|p
operator|->
name|p_ucred
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|rctl_lock
argument_list|,
name|RA_LOCKED
argument_list|)
expr_stmt|;
name|resource
operator|=
name|rule
operator|->
name|rr_resource
expr_stmt|;
switch|switch
condition|(
name|rule
operator|->
name|rr_per
condition|)
block|{
case|case
name|RCTL_SUBJECT_TYPE_PROCESS
case|:
name|available
operator|=
name|rule
operator|->
name|rr_amount
operator|-
name|p
operator|->
name|p_racct
operator|->
name|r_resources
index|[
name|resource
index|]
expr_stmt|;
break|break;
case|case
name|RCTL_SUBJECT_TYPE_USER
case|:
name|available
operator|=
name|rule
operator|->
name|rr_amount
operator|-
name|cred
operator|->
name|cr_ruidinfo
operator|->
name|ui_racct
operator|->
name|r_resources
index|[
name|resource
index|]
expr_stmt|;
break|break;
case|case
name|RCTL_SUBJECT_TYPE_LOGINCLASS
case|:
name|available
operator|=
name|rule
operator|->
name|rr_amount
operator|-
name|cred
operator|->
name|cr_loginclass
operator|->
name|lc_racct
operator|->
name|r_resources
index|[
name|resource
index|]
expr_stmt|;
break|break;
case|case
name|RCTL_SUBJECT_TYPE_JAIL
case|:
name|available
operator|=
name|rule
operator|->
name|rr_amount
operator|-
name|cred
operator|->
name|cr_prison
operator|->
name|pr_prison_racct
operator|->
name|prr_racct
operator|->
name|r_resources
index|[
name|resource
index|]
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"rctl_compute_available: unknown per %d"
argument_list|,
name|rule
operator|->
name|rr_per
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|available
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return non-zero if allocating 'amount' by proc 'p' would exceed  * resource limit specified by 'rule'.  */
end_comment

begin_function
specifier|static
name|int
name|rctl_would_exceed
parameter_list|(
specifier|const
name|struct
name|proc
modifier|*
name|p
parameter_list|,
specifier|const
name|struct
name|rctl_rule
modifier|*
name|rule
parameter_list|,
name|int64_t
name|amount
parameter_list|)
block|{
name|int64_t
name|available
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|rctl_lock
argument_list|,
name|RA_LOCKED
argument_list|)
expr_stmt|;
name|available
operator|=
name|rctl_available_resource
argument_list|(
name|p
argument_list|,
name|rule
argument_list|)
expr_stmt|;
if|if
condition|(
name|available
operator|>=
name|amount
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check whether the proc 'p' can allocate 'amount' of 'resource' in addition  * to what it keeps allocated now.  Returns non-zero if the allocation should  * be denied, 0 otherwise.  */
end_comment

begin_function
name|int
name|rctl_enforce
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|int
name|resource
parameter_list|,
name|uint64_t
name|amount
parameter_list|)
block|{
name|struct
name|rctl_rule
modifier|*
name|rule
decl_stmt|;
name|struct
name|rctl_rule_link
modifier|*
name|link
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|int
name|should_deny
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
specifier|static
name|int
name|curtime
init|=
literal|0
decl_stmt|;
specifier|static
name|struct
name|timeval
name|lasttime
decl_stmt|;
name|rw_rlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
comment|/* 	 * There may be more than one matching rule; go through all of them. 	 * Denial should be done last, after logging and sending signals. 	 */
name|LIST_FOREACH
argument_list|(
argument|link
argument_list|,
argument|&p->p_racct->r_rule_links
argument_list|,
argument|rrl_next
argument_list|)
block|{
name|rule
operator|=
name|link
operator|->
name|rrl_rule
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|rr_resource
operator|!=
name|resource
condition|)
continue|continue;
if|if
condition|(
operator|!
name|rctl_would_exceed
argument_list|(
name|p
argument_list|,
name|rule
argument_list|,
name|amount
argument_list|)
condition|)
block|{
name|link
operator|->
name|rrl_exceeded
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|rule
operator|->
name|rr_action
condition|)
block|{
case|case
name|RCTL_ACTION_DENY
case|:
name|should_deny
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
name|RCTL_ACTION_LOG
case|:
comment|/* 			 * If rrl_exceeded != 0, it means we've already 			 * logged a warning for this process. 			 */
if|if
condition|(
name|link
operator|->
name|rrl_exceeded
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|ppsratecheck
argument_list|(
operator|&
name|lasttime
argument_list|,
operator|&
name|curtime
argument_list|,
literal|10
argument_list|)
condition|)
continue|continue;
name|buf
operator|=
name|malloc
argument_list|(
name|RCTL_LOG_BUFSIZE
argument_list|,
name|M_RCTL
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"rctl_enforce: out of memory\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|buf
argument_list|,
name|RCTL_LOG_BUFSIZE
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|rctl_rule_to_sbuf
argument_list|(
operator|&
name|sb
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"rctl: rule \"%s\" matched by pid %d "
literal|"(%s), uid %d, jail %s\n"
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
argument_list|,
name|p
operator|->
name|p_ucred
operator|->
name|cr_prison
operator|->
name|pr_prison_racct
operator|->
name|prr_name
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_RCTL
argument_list|)
expr_stmt|;
name|link
operator|->
name|rrl_exceeded
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
name|RCTL_ACTION_DEVCTL
case|:
if|if
condition|(
name|link
operator|->
name|rrl_exceeded
operator|!=
literal|0
condition|)
continue|continue;
name|buf
operator|=
name|malloc
argument_list|(
name|RCTL_LOG_BUFSIZE
argument_list|,
name|M_RCTL
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"rctl_enforce: out of memory\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sbuf_new
argument_list|(
operator|&
name|sb
argument_list|,
name|buf
argument_list|,
name|RCTL_LOG_BUFSIZE
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"rule="
argument_list|)
expr_stmt|;
name|rctl_rule_to_sbuf
argument_list|(
operator|&
name|sb
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|" pid=%d ruid=%d jail=%s"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_ucred
operator|->
name|cr_ruid
argument_list|,
name|p
operator|->
name|p_ucred
operator|->
name|cr_prison
operator|->
name|pr_prison_racct
operator|->
name|prr_name
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|devctl_notify_f
argument_list|(
literal|"RCTL"
argument_list|,
literal|"rule"
argument_list|,
literal|"matched"
argument_list|,
name|sbuf_data
argument_list|(
operator|&
name|sb
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_RCTL
argument_list|)
expr_stmt|;
name|link
operator|->
name|rrl_exceeded
operator|=
literal|1
expr_stmt|;
continue|continue;
default|default:
if|if
condition|(
name|link
operator|->
name|rrl_exceeded
operator|!=
literal|0
condition|)
continue|continue;
name|KASSERT
argument_list|(
name|rule
operator|->
name|rr_action
operator|>
literal|0
operator|&&
name|rule
operator|->
name|rr_action
operator|<=
name|RCTL_ACTION_SIGNAL_MAX
argument_list|,
operator|(
literal|"rctl_enforce: unknown action %d"
operator|,
name|rule
operator|->
name|rr_action
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * We're supposed to send a signal, but the process 			 * is not fully initialized yet, probably because we 			 * got called from fork1().  For now just deny the 			 * allocation instead. 			 */
if|if
condition|(
name|p
operator|->
name|p_state
operator|!=
name|PRS_NORMAL
condition|)
block|{
name|should_deny
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * We're using the fact that RCTL_ACTION_SIG* values 			 * are equal to their counterparts from sys/signal.h. 			 */
name|kern_psignal
argument_list|(
name|p
argument_list|,
name|rule
operator|->
name|rr_action
argument_list|)
expr_stmt|;
name|link
operator|->
name|rrl_exceeded
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
name|rw_runlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|should_deny
condition|)
block|{
comment|/* 		 * Return fake error code; the caller should change it 		 * into one proper for the situation - EFSIZ, ENOMEM etc. 		 */
return|return
operator|(
name|EDOOFUS
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|rctl_get_limit
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|int
name|resource
parameter_list|)
block|{
name|struct
name|rctl_rule
modifier|*
name|rule
decl_stmt|;
name|struct
name|rctl_rule_link
modifier|*
name|link
decl_stmt|;
name|uint64_t
name|amount
init|=
name|UINT64_MAX
decl_stmt|;
name|rw_rlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
comment|/* 	 * There may be more than one matching rule; go through all of them. 	 * Denial should be done last, after logging and sending signals. 	 */
name|LIST_FOREACH
argument_list|(
argument|link
argument_list|,
argument|&p->p_racct->r_rule_links
argument_list|,
argument|rrl_next
argument_list|)
block|{
name|rule
operator|=
name|link
operator|->
name|rrl_rule
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|rr_resource
operator|!=
name|resource
condition|)
continue|continue;
if|if
condition|(
name|rule
operator|->
name|rr_action
operator|!=
name|RCTL_ACTION_DENY
condition|)
continue|continue;
if|if
condition|(
name|rule
operator|->
name|rr_amount
operator|<
name|amount
condition|)
name|amount
operator|=
name|rule
operator|->
name|rr_amount
expr_stmt|;
block|}
name|rw_runlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|amount
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|rctl_get_available
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|int
name|resource
parameter_list|)
block|{
name|struct
name|rctl_rule
modifier|*
name|rule
decl_stmt|;
name|struct
name|rctl_rule_link
modifier|*
name|link
decl_stmt|;
name|int64_t
name|available
decl_stmt|,
name|minavailable
decl_stmt|,
name|allocated
decl_stmt|;
name|minavailable
operator|=
name|INT64_MAX
expr_stmt|;
name|rw_rlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
comment|/* 	 * There may be more than one matching rule; go through all of them. 	 * Denial should be done last, after logging and sending signals. 	 */
name|LIST_FOREACH
argument_list|(
argument|link
argument_list|,
argument|&p->p_racct->r_rule_links
argument_list|,
argument|rrl_next
argument_list|)
block|{
name|rule
operator|=
name|link
operator|->
name|rrl_rule
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|rr_resource
operator|!=
name|resource
condition|)
continue|continue;
if|if
condition|(
name|rule
operator|->
name|rr_action
operator|!=
name|RCTL_ACTION_DENY
condition|)
continue|continue;
name|available
operator|=
name|rctl_available_resource
argument_list|(
name|p
argument_list|,
name|rule
argument_list|)
expr_stmt|;
if|if
condition|(
name|available
operator|<
name|minavailable
condition|)
name|minavailable
operator|=
name|available
expr_stmt|;
block|}
name|rw_runlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: Think about this _hard_. 	 */
name|allocated
operator|=
name|p
operator|->
name|p_racct
operator|->
name|r_resources
index|[
name|resource
index|]
expr_stmt|;
if|if
condition|(
name|minavailable
operator|<
name|INT64_MAX
operator|-
name|allocated
condition|)
name|minavailable
operator|+=
name|allocated
expr_stmt|;
if|if
condition|(
name|minavailable
operator|<
literal|0
condition|)
name|minavailable
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|minavailable
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rctl_rule_matches
parameter_list|(
specifier|const
name|struct
name|rctl_rule
modifier|*
name|rule
parameter_list|,
specifier|const
name|struct
name|rctl_rule
modifier|*
name|filter
parameter_list|)
block|{
if|if
condition|(
name|filter
operator|->
name|rr_subject_type
operator|!=
name|RCTL_SUBJECT_TYPE_UNDEFINED
condition|)
block|{
if|if
condition|(
name|rule
operator|->
name|rr_subject_type
operator|!=
name|filter
operator|->
name|rr_subject_type
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|filter
operator|->
name|rr_subject_type
condition|)
block|{
case|case
name|RCTL_SUBJECT_TYPE_PROCESS
case|:
if|if
condition|(
name|filter
operator|->
name|rr_subject
operator|.
name|rs_proc
operator|!=
name|NULL
operator|&&
name|rule
operator|->
name|rr_subject
operator|.
name|rs_proc
operator|!=
name|filter
operator|->
name|rr_subject
operator|.
name|rs_proc
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|RCTL_SUBJECT_TYPE_USER
case|:
if|if
condition|(
name|filter
operator|->
name|rr_subject
operator|.
name|rs_uip
operator|!=
name|NULL
operator|&&
name|rule
operator|->
name|rr_subject
operator|.
name|rs_uip
operator|!=
name|filter
operator|->
name|rr_subject
operator|.
name|rs_uip
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|RCTL_SUBJECT_TYPE_LOGINCLASS
case|:
if|if
condition|(
name|filter
operator|->
name|rr_subject
operator|.
name|rs_loginclass
operator|!=
name|NULL
operator|&&
name|rule
operator|->
name|rr_subject
operator|.
name|rs_loginclass
operator|!=
name|filter
operator|->
name|rr_subject
operator|.
name|rs_loginclass
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|RCTL_SUBJECT_TYPE_JAIL
case|:
if|if
condition|(
name|filter
operator|->
name|rr_subject
operator|.
name|rs_prison_racct
operator|!=
name|NULL
operator|&&
name|rule
operator|->
name|rr_subject
operator|.
name|rs_prison_racct
operator|!=
name|filter
operator|->
name|rr_subject
operator|.
name|rs_prison_racct
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
default|default:
name|panic
argument_list|(
literal|"rctl_rule_matches: unknown subject type %d"
argument_list|,
name|filter
operator|->
name|rr_subject_type
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|filter
operator|->
name|rr_resource
operator|!=
name|RACCT_UNDEFINED
condition|)
block|{
if|if
condition|(
name|rule
operator|->
name|rr_resource
operator|!=
name|filter
operator|->
name|rr_resource
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|filter
operator|->
name|rr_action
operator|!=
name|RCTL_ACTION_UNDEFINED
condition|)
block|{
if|if
condition|(
name|rule
operator|->
name|rr_action
operator|!=
name|filter
operator|->
name|rr_action
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|filter
operator|->
name|rr_amount
operator|!=
name|RCTL_AMOUNT_UNDEFINED
condition|)
block|{
if|if
condition|(
name|rule
operator|->
name|rr_amount
operator|!=
name|filter
operator|->
name|rr_amount
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|filter
operator|->
name|rr_per
operator|!=
name|RCTL_SUBJECT_TYPE_UNDEFINED
condition|)
block|{
if|if
condition|(
name|rule
operator|->
name|rr_per
operator|!=
name|filter
operator|->
name|rr_per
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|str2value
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
modifier|*
name|value
parameter_list|,
name|struct
name|dict
modifier|*
name|table
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|table
index|[
name|i
index|]
operator|.
name|d_name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|table
index|[
name|i
index|]
operator|.
name|d_name
argument_list|,
name|str
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|value
operator|=
name|table
index|[
name|i
index|]
operator|.
name|d_value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|str2id
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|id_t
modifier|*
name|value
parameter_list|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|value
operator|=
name|strtoul
argument_list|(
name|str
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|end
operator|-
name|str
argument_list|)
operator|!=
name|strlen
argument_list|(
name|str
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|str2int64
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int64_t
modifier|*
name|value
parameter_list|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|value
operator|=
name|strtoul
argument_list|(
name|str
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|end
operator|-
name|str
argument_list|)
operator|!=
name|strlen
argument_list|(
name|str
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Connect the rule to the racct, increasing refcount for the rule.  */
end_comment

begin_function
specifier|static
name|void
name|rctl_racct_add_rule
parameter_list|(
name|struct
name|racct
modifier|*
name|racct
parameter_list|,
name|struct
name|rctl_rule
modifier|*
name|rule
parameter_list|)
block|{
name|struct
name|rctl_rule_link
modifier|*
name|link
decl_stmt|;
name|KASSERT
argument_list|(
name|rctl_rule_fully_specified
argument_list|(
name|rule
argument_list|)
argument_list|,
operator|(
literal|"rule not fully specified"
operator|)
argument_list|)
expr_stmt|;
name|rctl_rule_acquire
argument_list|(
name|rule
argument_list|)
expr_stmt|;
name|link
operator|=
name|uma_zalloc
argument_list|(
name|rctl_rule_link_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|link
operator|->
name|rrl_rule
operator|=
name|rule
expr_stmt|;
name|link
operator|->
name|rrl_exceeded
operator|=
literal|0
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|racct
operator|->
name|r_rule_links
argument_list|,
name|link
argument_list|,
name|rrl_next
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|rctl_racct_add_rule_locked
parameter_list|(
name|struct
name|racct
modifier|*
name|racct
parameter_list|,
name|struct
name|rctl_rule
modifier|*
name|rule
parameter_list|)
block|{
name|struct
name|rctl_rule_link
modifier|*
name|link
decl_stmt|;
name|KASSERT
argument_list|(
name|rctl_rule_fully_specified
argument_list|(
name|rule
argument_list|)
argument_list|,
operator|(
literal|"rule not fully specified"
operator|)
argument_list|)
expr_stmt|;
name|rw_assert
argument_list|(
operator|&
name|rctl_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|link
operator|=
name|uma_zalloc
argument_list|(
name|rctl_rule_link_zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|rctl_rule_acquire
argument_list|(
name|rule
argument_list|)
expr_stmt|;
name|link
operator|->
name|rrl_rule
operator|=
name|rule
expr_stmt|;
name|link
operator|->
name|rrl_exceeded
operator|=
literal|0
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|racct
operator|->
name|r_rule_links
argument_list|,
name|link
argument_list|,
name|rrl_next
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove limits for a rules matching the filter and release  * the refcounts for the rules, possibly freeing them.  Returns  * the number of limit structures removed.  */
end_comment

begin_function
specifier|static
name|int
name|rctl_racct_remove_rules
parameter_list|(
name|struct
name|racct
modifier|*
name|racct
parameter_list|,
specifier|const
name|struct
name|rctl_rule
modifier|*
name|filter
parameter_list|)
block|{
name|int
name|removed
init|=
literal|0
decl_stmt|;
name|struct
name|rctl_rule_link
modifier|*
name|link
decl_stmt|,
modifier|*
name|linktmp
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|rctl_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|link
argument_list|,
argument|&racct->r_rule_links
argument_list|,
argument|rrl_next
argument_list|,
argument|linktmp
argument_list|)
block|{
if|if
condition|(
operator|!
name|rctl_rule_matches
argument_list|(
name|link
operator|->
name|rrl_rule
argument_list|,
name|filter
argument_list|)
condition|)
continue|continue;
name|LIST_REMOVE
argument_list|(
name|link
argument_list|,
name|rrl_next
argument_list|)
expr_stmt|;
name|rctl_rule_release
argument_list|(
name|link
operator|->
name|rrl_rule
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|rctl_rule_link_zone
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|removed
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|removed
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rctl_rule_acquire_subject
parameter_list|(
name|struct
name|rctl_rule
modifier|*
name|rule
parameter_list|)
block|{
switch|switch
condition|(
name|rule
operator|->
name|rr_subject_type
condition|)
block|{
case|case
name|RCTL_SUBJECT_TYPE_UNDEFINED
case|:
case|case
name|RCTL_SUBJECT_TYPE_PROCESS
case|:
break|break;
case|case
name|RCTL_SUBJECT_TYPE_JAIL
case|:
if|if
condition|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_prison_racct
operator|!=
name|NULL
condition|)
name|prison_racct_hold
argument_list|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_prison_racct
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCTL_SUBJECT_TYPE_USER
case|:
if|if
condition|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_uip
operator|!=
name|NULL
condition|)
name|uihold
argument_list|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_uip
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCTL_SUBJECT_TYPE_LOGINCLASS
case|:
if|if
condition|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_loginclass
operator|!=
name|NULL
condition|)
name|loginclass_hold
argument_list|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_loginclass
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"rctl_rule_acquire_subject: unknown subject type %d"
argument_list|,
name|rule
operator|->
name|rr_subject_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rctl_rule_release_subject
parameter_list|(
name|struct
name|rctl_rule
modifier|*
name|rule
parameter_list|)
block|{
switch|switch
condition|(
name|rule
operator|->
name|rr_subject_type
condition|)
block|{
case|case
name|RCTL_SUBJECT_TYPE_UNDEFINED
case|:
case|case
name|RCTL_SUBJECT_TYPE_PROCESS
case|:
break|break;
case|case
name|RCTL_SUBJECT_TYPE_JAIL
case|:
if|if
condition|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_prison_racct
operator|!=
name|NULL
condition|)
name|prison_racct_free
argument_list|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_prison_racct
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCTL_SUBJECT_TYPE_USER
case|:
if|if
condition|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_uip
operator|!=
name|NULL
condition|)
name|uifree
argument_list|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_uip
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCTL_SUBJECT_TYPE_LOGINCLASS
case|:
if|if
condition|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_loginclass
operator|!=
name|NULL
condition|)
name|loginclass_free
argument_list|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_loginclass
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"rctl_rule_release_subject: unknown subject type %d"
argument_list|,
name|rule
operator|->
name|rr_subject_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|rctl_rule
modifier|*
name|rctl_rule_alloc
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|struct
name|rctl_rule
modifier|*
name|rule
decl_stmt|;
name|rule
operator|=
name|uma_zalloc
argument_list|(
name|rctl_rule_zone
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rule
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|rule
operator|->
name|rr_subject_type
operator|=
name|RCTL_SUBJECT_TYPE_UNDEFINED
expr_stmt|;
name|rule
operator|->
name|rr_subject
operator|.
name|rs_proc
operator|=
name|NULL
expr_stmt|;
name|rule
operator|->
name|rr_subject
operator|.
name|rs_uip
operator|=
name|NULL
expr_stmt|;
name|rule
operator|->
name|rr_subject
operator|.
name|rs_loginclass
operator|=
name|NULL
expr_stmt|;
name|rule
operator|->
name|rr_subject
operator|.
name|rs_prison_racct
operator|=
name|NULL
expr_stmt|;
name|rule
operator|->
name|rr_per
operator|=
name|RCTL_SUBJECT_TYPE_UNDEFINED
expr_stmt|;
name|rule
operator|->
name|rr_resource
operator|=
name|RACCT_UNDEFINED
expr_stmt|;
name|rule
operator|->
name|rr_action
operator|=
name|RCTL_ACTION_UNDEFINED
expr_stmt|;
name|rule
operator|->
name|rr_amount
operator|=
name|RCTL_AMOUNT_UNDEFINED
expr_stmt|;
name|refcount_init
argument_list|(
operator|&
name|rule
operator|->
name|rr_refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|rule
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|rctl_rule
modifier|*
name|rctl_rule_duplicate
parameter_list|(
specifier|const
name|struct
name|rctl_rule
modifier|*
name|rule
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|rctl_rule
modifier|*
name|copy
decl_stmt|;
name|copy
operator|=
name|uma_zalloc
argument_list|(
name|rctl_rule_zone
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|copy
operator|->
name|rr_subject_type
operator|=
name|rule
operator|->
name|rr_subject_type
expr_stmt|;
name|copy
operator|->
name|rr_subject
operator|.
name|rs_proc
operator|=
name|rule
operator|->
name|rr_subject
operator|.
name|rs_proc
expr_stmt|;
name|copy
operator|->
name|rr_subject
operator|.
name|rs_uip
operator|=
name|rule
operator|->
name|rr_subject
operator|.
name|rs_uip
expr_stmt|;
name|copy
operator|->
name|rr_subject
operator|.
name|rs_loginclass
operator|=
name|rule
operator|->
name|rr_subject
operator|.
name|rs_loginclass
expr_stmt|;
name|copy
operator|->
name|rr_subject
operator|.
name|rs_prison_racct
operator|=
name|rule
operator|->
name|rr_subject
operator|.
name|rs_prison_racct
expr_stmt|;
name|copy
operator|->
name|rr_per
operator|=
name|rule
operator|->
name|rr_per
expr_stmt|;
name|copy
operator|->
name|rr_resource
operator|=
name|rule
operator|->
name|rr_resource
expr_stmt|;
name|copy
operator|->
name|rr_action
operator|=
name|rule
operator|->
name|rr_action
expr_stmt|;
name|copy
operator|->
name|rr_amount
operator|=
name|rule
operator|->
name|rr_amount
expr_stmt|;
name|refcount_init
argument_list|(
operator|&
name|copy
operator|->
name|rr_refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rctl_rule_acquire_subject
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return
operator|(
name|copy
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rctl_rule_acquire
parameter_list|(
name|struct
name|rctl_rule
modifier|*
name|rule
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|rule
operator|->
name|rr_refcount
operator|>
literal|0
argument_list|,
operator|(
literal|"rule->rr_refcount<= 0"
operator|)
argument_list|)
expr_stmt|;
name|refcount_acquire
argument_list|(
operator|&
name|rule
operator|->
name|rr_refcount
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rctl_rule_free
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|rctl_rule
modifier|*
name|rule
decl_stmt|;
name|rule
operator|=
operator|(
expr|struct
name|rctl_rule
operator|*
operator|)
name|context
expr_stmt|;
name|KASSERT
argument_list|(
name|rule
operator|->
name|rr_refcount
operator|==
literal|0
argument_list|,
operator|(
literal|"rule->rr_refcount != 0"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * We don't need locking here; rule is guaranteed to be inaccessible. 	 */
name|rctl_rule_release_subject
argument_list|(
name|rule
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|rctl_rule_zone
argument_list|,
name|rule
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rctl_rule_release
parameter_list|(
name|struct
name|rctl_rule
modifier|*
name|rule
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|rule
operator|->
name|rr_refcount
operator|>
literal|0
argument_list|,
operator|(
literal|"rule->rr_refcount<= 0"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|refcount_release
argument_list|(
operator|&
name|rule
operator|->
name|rr_refcount
argument_list|)
condition|)
block|{
comment|/* 		 * rctl_rule_release() is often called when iterating 		 * over all the uidinfo structures in the system, 		 * holding uihashtbl_lock.  Since rctl_rule_free() 		 * might end up calling uifree(), this would lead 		 * to lock recursion.  Use taskqueue to avoid this. 		 */
name|TASK_INIT
argument_list|(
operator|&
name|rule
operator|->
name|rr_task
argument_list|,
literal|0
argument_list|,
name|rctl_rule_free
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|rule
operator|->
name|rr_task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|rctl_rule_fully_specified
parameter_list|(
specifier|const
name|struct
name|rctl_rule
modifier|*
name|rule
parameter_list|)
block|{
switch|switch
condition|(
name|rule
operator|->
name|rr_subject_type
condition|)
block|{
case|case
name|RCTL_SUBJECT_TYPE_UNDEFINED
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RCTL_SUBJECT_TYPE_PROCESS
case|:
if|if
condition|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_proc
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|RCTL_SUBJECT_TYPE_USER
case|:
if|if
condition|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_uip
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|RCTL_SUBJECT_TYPE_LOGINCLASS
case|:
if|if
condition|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_loginclass
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|RCTL_SUBJECT_TYPE_JAIL
case|:
if|if
condition|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_prison_racct
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
default|default:
name|panic
argument_list|(
literal|"rctl_rule_fully_specified: unknown subject type %d"
argument_list|,
name|rule
operator|->
name|rr_subject_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rule
operator|->
name|rr_resource
operator|==
name|RACCT_UNDEFINED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|rule
operator|->
name|rr_action
operator|==
name|RCTL_ACTION_UNDEFINED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|rule
operator|->
name|rr_amount
operator|==
name|RCTL_AMOUNT_UNDEFINED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|rule
operator|->
name|rr_per
operator|==
name|RCTL_SUBJECT_TYPE_UNDEFINED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rctl_string_to_rule
parameter_list|(
name|char
modifier|*
name|rulestr
parameter_list|,
name|struct
name|rctl_rule
modifier|*
modifier|*
name|rulep
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|subjectstr
decl_stmt|,
modifier|*
name|subject_idstr
decl_stmt|,
modifier|*
name|resourcestr
decl_stmt|,
modifier|*
name|actionstr
decl_stmt|,
modifier|*
name|amountstr
decl_stmt|,
modifier|*
name|perstr
decl_stmt|;
name|struct
name|rctl_rule
modifier|*
name|rule
decl_stmt|;
name|id_t
name|id
decl_stmt|;
name|rule
operator|=
name|rctl_rule_alloc
argument_list|(
name|M_WAITOK
argument_list|)
expr_stmt|;
name|subjectstr
operator|=
name|strsep
argument_list|(
operator|&
name|rulestr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|subject_idstr
operator|=
name|strsep
argument_list|(
operator|&
name|rulestr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|resourcestr
operator|=
name|strsep
argument_list|(
operator|&
name|rulestr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|actionstr
operator|=
name|strsep
argument_list|(
operator|&
name|rulestr
argument_list|,
literal|"=/"
argument_list|)
expr_stmt|;
name|amountstr
operator|=
name|strsep
argument_list|(
operator|&
name|rulestr
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|perstr
operator|=
name|rulestr
expr_stmt|;
if|if
condition|(
name|subjectstr
operator|==
name|NULL
operator|||
name|subjectstr
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|rule
operator|->
name|rr_subject_type
operator|=
name|RCTL_SUBJECT_TYPE_UNDEFINED
expr_stmt|;
else|else
block|{
name|error
operator|=
name|str2value
argument_list|(
name|subjectstr
argument_list|,
operator|&
name|rule
operator|->
name|rr_subject_type
argument_list|,
name|subjectnames
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|subject_idstr
operator|==
name|NULL
operator|||
name|subject_idstr
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|rule
operator|->
name|rr_subject
operator|.
name|rs_proc
operator|=
name|NULL
expr_stmt|;
name|rule
operator|->
name|rr_subject
operator|.
name|rs_uip
operator|=
name|NULL
expr_stmt|;
name|rule
operator|->
name|rr_subject
operator|.
name|rs_loginclass
operator|=
name|NULL
expr_stmt|;
name|rule
operator|->
name|rr_subject
operator|.
name|rs_prison_racct
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|rule
operator|->
name|rr_subject_type
condition|)
block|{
case|case
name|RCTL_SUBJECT_TYPE_UNDEFINED
case|:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|RCTL_SUBJECT_TYPE_PROCESS
case|:
name|error
operator|=
name|str2id
argument_list|(
name|subject_idstr
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|sx_assert
argument_list|(
operator|&
name|allproc_lock
argument_list|,
name|SA_LOCKED
argument_list|)
expr_stmt|;
name|rule
operator|->
name|rr_subject
operator|.
name|rs_proc
operator|=
name|pfind
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_proc
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ESRCH
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|PROC_UNLOCK
argument_list|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_proc
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCTL_SUBJECT_TYPE_USER
case|:
name|error
operator|=
name|str2id
argument_list|(
name|subject_idstr
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|rule
operator|->
name|rr_subject
operator|.
name|rs_uip
operator|=
name|uifind
argument_list|(
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCTL_SUBJECT_TYPE_LOGINCLASS
case|:
name|rule
operator|->
name|rr_subject
operator|.
name|rs_loginclass
operator|=
name|loginclass_find
argument_list|(
name|subject_idstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_loginclass
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENAMETOOLONG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
case|case
name|RCTL_SUBJECT_TYPE_JAIL
case|:
name|rule
operator|->
name|rr_subject
operator|.
name|rs_prison_racct
operator|=
name|prison_racct_find
argument_list|(
name|subject_idstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_prison_racct
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENAMETOOLONG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"rctl_string_to_rule: unknown subject type %d"
argument_list|,
name|rule
operator|->
name|rr_subject_type
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|resourcestr
operator|==
name|NULL
operator|||
name|resourcestr
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|rule
operator|->
name|rr_resource
operator|=
name|RACCT_UNDEFINED
expr_stmt|;
else|else
block|{
name|error
operator|=
name|str2value
argument_list|(
name|resourcestr
argument_list|,
operator|&
name|rule
operator|->
name|rr_resource
argument_list|,
name|resourcenames
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|actionstr
operator|==
name|NULL
operator|||
name|actionstr
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|rule
operator|->
name|rr_action
operator|=
name|RCTL_ACTION_UNDEFINED
expr_stmt|;
else|else
block|{
name|error
operator|=
name|str2value
argument_list|(
name|actionstr
argument_list|,
operator|&
name|rule
operator|->
name|rr_action
argument_list|,
name|actionnames
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|amountstr
operator|==
name|NULL
operator|||
name|amountstr
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|rule
operator|->
name|rr_amount
operator|=
name|RCTL_AMOUNT_UNDEFINED
expr_stmt|;
else|else
block|{
name|error
operator|=
name|str2int64
argument_list|(
name|amountstr
argument_list|,
operator|&
name|rule
operator|->
name|rr_amount
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|RACCT_IS_IN_MILLIONS
argument_list|(
name|rule
operator|->
name|rr_resource
argument_list|)
condition|)
name|rule
operator|->
name|rr_amount
operator|*=
literal|1000000
expr_stmt|;
block|}
if|if
condition|(
name|perstr
operator|==
name|NULL
operator|||
name|perstr
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|rule
operator|->
name|rr_per
operator|=
name|RCTL_SUBJECT_TYPE_UNDEFINED
expr_stmt|;
else|else
block|{
name|error
operator|=
name|str2value
argument_list|(
name|perstr
argument_list|,
operator|&
name|rule
operator|->
name|rr_per
argument_list|,
name|subjectnames
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|rulep
operator|=
name|rule
expr_stmt|;
else|else
name|rctl_rule_release
argument_list|(
name|rule
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Link a rule with all the subjects it applies to.  */
end_comment

begin_function
name|int
name|rctl_rule_add
parameter_list|(
name|struct
name|rctl_rule
modifier|*
name|rule
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|uidinfo
modifier|*
name|uip
decl_stmt|;
name|struct
name|prison
modifier|*
name|pr
decl_stmt|;
name|struct
name|prison_racct
modifier|*
name|prr
decl_stmt|;
name|struct
name|loginclass
modifier|*
name|lc
decl_stmt|;
name|struct
name|rctl_rule
modifier|*
name|rule2
decl_stmt|;
name|int
name|match
decl_stmt|;
name|KASSERT
argument_list|(
name|rctl_rule_fully_specified
argument_list|(
name|rule
argument_list|)
argument_list|,
operator|(
literal|"rule not fully specified"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Some rules just don't make sense.  Note that the one below 	 * cannot be rewritten using RACCT_IS_DENIABLE(); the RACCT_PCTCPU, 	 * for example, is not deniable in the racct sense, but the 	 * limit is enforced in a different way, so "deny" rules for %CPU 	 * do make sense. 	 */
if|if
condition|(
name|rule
operator|->
name|rr_action
operator|==
name|RCTL_ACTION_DENY
operator|&&
operator|(
name|rule
operator|->
name|rr_resource
operator|==
name|RACCT_CPU
operator|||
name|rule
operator|->
name|rr_resource
operator|==
name|RACCT_WALLCLOCK
operator|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
name|rule
operator|->
name|rr_per
operator|==
name|RCTL_SUBJECT_TYPE_PROCESS
operator|&&
name|RACCT_IS_SLOPPY
argument_list|(
name|rule
operator|->
name|rr_resource
argument_list|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
comment|/* 	 * Make sure there are no duplicated rules.  Also, for the "deny" 	 * rules, remove ones differing only by "amount". 	 */
if|if
condition|(
name|rule
operator|->
name|rr_action
operator|==
name|RCTL_ACTION_DENY
condition|)
block|{
name|rule2
operator|=
name|rctl_rule_duplicate
argument_list|(
name|rule
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|rule2
operator|->
name|rr_amount
operator|=
name|RCTL_AMOUNT_UNDEFINED
expr_stmt|;
name|rctl_rule_remove
argument_list|(
name|rule2
argument_list|)
expr_stmt|;
name|rctl_rule_release
argument_list|(
name|rule2
argument_list|)
expr_stmt|;
block|}
else|else
name|rctl_rule_remove
argument_list|(
name|rule
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rule
operator|->
name|rr_subject_type
condition|)
block|{
case|case
name|RCTL_SUBJECT_TYPE_PROCESS
case|:
name|p
operator|=
name|rule
operator|->
name|rr_subject
operator|.
name|rs_proc
expr_stmt|;
name|KASSERT
argument_list|(
name|p
operator|!=
name|NULL
argument_list|,
operator|(
literal|"rctl_rule_add: NULL proc"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * No resource limits for system processes. 		 */
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_SYSTEM
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|rctl_racct_add_rule
argument_list|(
name|p
operator|->
name|p_racct
argument_list|,
name|rule
argument_list|)
expr_stmt|;
comment|/* 		 * In case of per-process rule, we don't have anything more 		 * to do. 		 */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|RCTL_SUBJECT_TYPE_USER
case|:
name|uip
operator|=
name|rule
operator|->
name|rr_subject
operator|.
name|rs_uip
expr_stmt|;
name|KASSERT
argument_list|(
name|uip
operator|!=
name|NULL
argument_list|,
operator|(
literal|"rctl_rule_add: NULL uip"
operator|)
argument_list|)
expr_stmt|;
name|rctl_racct_add_rule
argument_list|(
name|uip
operator|->
name|ui_racct
argument_list|,
name|rule
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCTL_SUBJECT_TYPE_LOGINCLASS
case|:
name|lc
operator|=
name|rule
operator|->
name|rr_subject
operator|.
name|rs_loginclass
expr_stmt|;
name|KASSERT
argument_list|(
name|lc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"rctl_rule_add: NULL loginclass"
operator|)
argument_list|)
expr_stmt|;
name|rctl_racct_add_rule
argument_list|(
name|lc
operator|->
name|lc_racct
argument_list|,
name|rule
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCTL_SUBJECT_TYPE_JAIL
case|:
name|prr
operator|=
name|rule
operator|->
name|rr_subject
operator|.
name|rs_prison_racct
expr_stmt|;
name|KASSERT
argument_list|(
name|prr
operator|!=
name|NULL
argument_list|,
operator|(
literal|"rctl_rule_add: NULL pr"
operator|)
argument_list|)
expr_stmt|;
name|rctl_racct_add_rule
argument_list|(
name|prr
operator|->
name|prr_racct
argument_list|,
name|rule
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"rctl_rule_add: unknown subject type %d"
argument_list|,
name|rule
operator|->
name|rr_subject_type
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now go through all the processes and add the new rule to the ones 	 * it applies to. 	 */
name|sx_assert
argument_list|(
operator|&
name|allproc_lock
argument_list|,
name|SA_LOCKED
argument_list|)
expr_stmt|;
name|FOREACH_PROC_IN_SYSTEM
argument_list|(
argument|p
argument_list|)
block|{
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_SYSTEM
condition|)
continue|continue;
name|cred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
switch|switch
condition|(
name|rule
operator|->
name|rr_subject_type
condition|)
block|{
case|case
name|RCTL_SUBJECT_TYPE_USER
case|:
if|if
condition|(
name|cred
operator|->
name|cr_uidinfo
operator|==
name|rule
operator|->
name|rr_subject
operator|.
name|rs_uip
operator|||
name|cred
operator|->
name|cr_ruidinfo
operator|==
name|rule
operator|->
name|rr_subject
operator|.
name|rs_uip
condition|)
break|break;
continue|continue;
case|case
name|RCTL_SUBJECT_TYPE_LOGINCLASS
case|:
if|if
condition|(
name|cred
operator|->
name|cr_loginclass
operator|==
name|rule
operator|->
name|rr_subject
operator|.
name|rs_loginclass
condition|)
break|break;
continue|continue;
case|case
name|RCTL_SUBJECT_TYPE_JAIL
case|:
name|match
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|cred
operator|->
name|cr_prison
init|;
name|pr
operator|!=
name|NULL
condition|;
name|pr
operator|=
name|pr
operator|->
name|pr_parent
control|)
block|{
if|if
condition|(
name|pr
operator|->
name|pr_prison_racct
operator|==
name|rule
operator|->
name|rr_subject
operator|.
name|rs_prison_racct
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|match
condition|)
break|break;
continue|continue;
default|default:
name|panic
argument_list|(
literal|"rctl_rule_add: unknown subject type %d"
argument_list|,
name|rule
operator|->
name|rr_subject_type
argument_list|)
expr_stmt|;
block|}
name|rctl_racct_add_rule
argument_list|(
name|p
operator|->
name|p_racct
argument_list|,
name|rule
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rctl_rule_remove_callback
parameter_list|(
name|struct
name|racct
modifier|*
name|racct
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|void
modifier|*
name|arg3
parameter_list|)
block|{
name|struct
name|rctl_rule
modifier|*
name|filter
init|=
operator|(
expr|struct
name|rctl_rule
operator|*
operator|)
name|arg2
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
name|found
operator|+=
name|rctl_racct_remove_rules
argument_list|(
name|racct
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|int
operator|*
operator|)
name|arg3
operator|)
operator|+=
name|found
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove all rules that match the filter.  */
end_comment

begin_function
name|int
name|rctl_rule_remove
parameter_list|(
name|struct
name|rctl_rule
modifier|*
name|filter
parameter_list|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|filter
operator|->
name|rr_subject_type
operator|==
name|RCTL_SUBJECT_TYPE_PROCESS
operator|&&
name|filter
operator|->
name|rr_subject
operator|.
name|rs_proc
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|filter
operator|->
name|rr_subject
operator|.
name|rs_proc
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
name|found
operator|=
name|rctl_racct_remove_rules
argument_list|(
name|p
operator|->
name|p_racct
argument_list|,
name|filter
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
name|loginclass_racct_foreach
argument_list|(
name|rctl_rule_remove_callback
argument_list|,
name|filter
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|found
argument_list|)
expr_stmt|;
name|ui_racct_foreach
argument_list|(
name|rctl_rule_remove_callback
argument_list|,
name|filter
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|found
argument_list|)
expr_stmt|;
name|prison_racct_foreach
argument_list|(
name|rctl_rule_remove_callback
argument_list|,
name|filter
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|found
argument_list|)
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|allproc_lock
argument_list|,
name|SA_LOCKED
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
name|FOREACH_PROC_IN_SYSTEM
argument_list|(
argument|p
argument_list|)
block|{
name|found
operator|+=
name|rctl_racct_remove_rules
argument_list|(
name|p
operator|->
name|p_racct
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Appends a rule to the sbuf.  */
end_comment

begin_function
specifier|static
name|void
name|rctl_rule_to_sbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
specifier|const
name|struct
name|rctl_rule
modifier|*
name|rule
parameter_list|)
block|{
name|int64_t
name|amount
decl_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s:"
argument_list|,
name|rctl_subject_type_name
argument_list|(
name|rule
operator|->
name|rr_subject_type
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rule
operator|->
name|rr_subject_type
condition|)
block|{
case|case
name|RCTL_SUBJECT_TYPE_PROCESS
case|:
if|if
condition|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_proc
operator|==
name|NULL
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%d:"
argument_list|,
name|rule
operator|->
name|rr_subject
operator|.
name|rs_proc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCTL_SUBJECT_TYPE_USER
case|:
if|if
condition|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_uip
operator|==
name|NULL
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%d:"
argument_list|,
name|rule
operator|->
name|rr_subject
operator|.
name|rs_uip
operator|->
name|ui_uid
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCTL_SUBJECT_TYPE_LOGINCLASS
case|:
if|if
condition|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_loginclass
operator|==
name|NULL
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s:"
argument_list|,
name|rule
operator|->
name|rr_subject
operator|.
name|rs_loginclass
operator|->
name|lc_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCTL_SUBJECT_TYPE_JAIL
case|:
if|if
condition|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_prison_racct
operator|==
name|NULL
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
else|else
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s:"
argument_list|,
name|rule
operator|->
name|rr_subject
operator|.
name|rs_prison_racct
operator|->
name|prr_name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"rctl_rule_to_sbuf: unknown subject type %d"
argument_list|,
name|rule
operator|->
name|rr_subject_type
argument_list|)
expr_stmt|;
block|}
name|amount
operator|=
name|rule
operator|->
name|rr_amount
expr_stmt|;
if|if
condition|(
name|amount
operator|!=
name|RCTL_AMOUNT_UNDEFINED
operator|&&
name|RACCT_IS_IN_MILLIONS
argument_list|(
name|rule
operator|->
name|rr_resource
argument_list|)
condition|)
name|amount
operator|/=
literal|1000000
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s:%s=%jd"
argument_list|,
name|rctl_resource_name
argument_list|(
name|rule
operator|->
name|rr_resource
argument_list|)
argument_list|,
name|rctl_action_name
argument_list|(
name|rule
operator|->
name|rr_action
argument_list|)
argument_list|,
name|amount
argument_list|)
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|rr_per
operator|!=
name|rule
operator|->
name|rr_subject_type
condition|)
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"/%s"
argument_list|,
name|rctl_subject_type_name
argument_list|(
name|rule
operator|->
name|rr_per
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine used by RCTL syscalls to read in input string.  */
end_comment

begin_function
specifier|static
name|int
name|rctl_read_inbuf
parameter_list|(
name|char
modifier|*
modifier|*
name|inputstr
parameter_list|,
specifier|const
name|char
modifier|*
name|inbufp
parameter_list|,
name|size_t
name|inbuflen
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|inbuflen
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|str
operator|=
name|malloc
argument_list|(
name|inbuflen
operator|+
literal|1
argument_list|,
name|M_RCTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyinstr
argument_list|(
name|inbufp
argument_list|,
name|str
argument_list|,
name|inbuflen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|str
argument_list|,
name|M_RCTL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|inputstr
operator|=
name|str
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routine used by RCTL syscalls to write out output string.  */
end_comment

begin_function
specifier|static
name|int
name|rctl_write_outbuf
parameter_list|(
name|struct
name|sbuf
modifier|*
name|outputsbuf
parameter_list|,
name|char
modifier|*
name|outbufp
parameter_list|,
name|size_t
name|outbuflen
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|outputsbuf
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sbuf_finish
argument_list|(
name|outputsbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|outbuflen
operator|<
name|sbuf_len
argument_list|(
name|outputsbuf
argument_list|)
operator|+
literal|1
condition|)
block|{
name|sbuf_delete
argument_list|(
name|outputsbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERANGE
operator|)
return|;
block|}
name|error
operator|=
name|copyout
argument_list|(
name|sbuf_data
argument_list|(
name|outputsbuf
argument_list|)
argument_list|,
name|outbufp
argument_list|,
name|sbuf_len
argument_list|(
name|outputsbuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|outputsbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sbuf
modifier|*
name|rctl_racct_to_sbuf
parameter_list|(
name|struct
name|racct
modifier|*
name|racct
parameter_list|,
name|int
name|sloppy
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int64_t
name|amount
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|sb
operator|=
name|sbuf_new_auto
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|RACCT_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sloppy
operator|==
literal|0
operator|&&
name|RACCT_IS_SLOPPY
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
name|amount
operator|=
name|racct
operator|->
name|r_resources
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|RACCT_IS_IN_MILLIONS
argument_list|(
name|i
argument_list|)
condition|)
name|amount
operator|/=
literal|1000000
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s=%jd,"
argument_list|,
name|rctl_resource_name
argument_list|(
name|i
argument_list|)
argument_list|,
name|amount
argument_list|)
expr_stmt|;
block|}
name|sbuf_setpos
argument_list|(
name|sb
argument_list|,
name|sbuf_len
argument_list|(
name|sb
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|sb
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sys_rctl_get_racct
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|rctl_get_racct_args
modifier|*
name|uap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|inputstr
decl_stmt|;
name|struct
name|rctl_rule
modifier|*
name|filter
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|outputsbuf
init|=
name|NULL
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|uidinfo
modifier|*
name|uip
decl_stmt|;
name|struct
name|loginclass
modifier|*
name|lc
decl_stmt|;
name|struct
name|prison_racct
modifier|*
name|prr
decl_stmt|;
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_RCTL_GET_RACCT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|rctl_read_inbuf
argument_list|(
operator|&
name|inputstr
argument_list|,
name|uap
operator|->
name|inbufp
argument_list|,
name|uap
operator|->
name|inbuflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sx_slock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|rctl_string_to_rule
argument_list|(
name|inputstr
argument_list|,
operator|&
name|filter
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inputstr
argument_list|,
name|M_RCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
switch|switch
condition|(
name|filter
operator|->
name|rr_subject_type
condition|)
block|{
case|case
name|RCTL_SUBJECT_TYPE_PROCESS
case|:
name|p
operator|=
name|filter
operator|->
name|rr_subject
operator|.
name|rs_proc
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_SYSTEM
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|outputsbuf
operator|=
name|rctl_racct_to_sbuf
argument_list|(
name|p
operator|->
name|p_racct
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCTL_SUBJECT_TYPE_USER
case|:
name|uip
operator|=
name|filter
operator|->
name|rr_subject
operator|.
name|rs_uip
expr_stmt|;
if|if
condition|(
name|uip
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|outputsbuf
operator|=
name|rctl_racct_to_sbuf
argument_list|(
name|uip
operator|->
name|ui_racct
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCTL_SUBJECT_TYPE_LOGINCLASS
case|:
name|lc
operator|=
name|filter
operator|->
name|rr_subject
operator|.
name|rs_loginclass
expr_stmt|;
if|if
condition|(
name|lc
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|outputsbuf
operator|=
name|rctl_racct_to_sbuf
argument_list|(
name|lc
operator|->
name|lc_racct
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|RCTL_SUBJECT_TYPE_JAIL
case|:
name|prr
operator|=
name|filter
operator|->
name|rr_subject
operator|.
name|rs_prison_racct
expr_stmt|;
if|if
condition|(
name|prr
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|outputsbuf
operator|=
name|rctl_racct_to_sbuf
argument_list|(
name|prr
operator|->
name|prr_racct
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|out
label|:
name|rctl_rule_release
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|rctl_write_outbuf
argument_list|(
name|outputsbuf
argument_list|,
name|uap
operator|->
name|outbufp
argument_list|,
name|uap
operator|->
name|outbuflen
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rctl_get_rules_callback
parameter_list|(
name|struct
name|racct
modifier|*
name|racct
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|void
modifier|*
name|arg3
parameter_list|)
block|{
name|struct
name|rctl_rule
modifier|*
name|filter
init|=
operator|(
expr|struct
name|rctl_rule
operator|*
operator|)
name|arg2
decl_stmt|;
name|struct
name|rctl_rule_link
modifier|*
name|link
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
init|=
operator|(
expr|struct
name|sbuf
operator|*
operator|)
name|arg3
decl_stmt|;
name|rw_rlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|link
argument_list|,
argument|&racct->r_rule_links
argument_list|,
argument|rrl_next
argument_list|)
block|{
if|if
condition|(
operator|!
name|rctl_rule_matches
argument_list|(
name|link
operator|->
name|rrl_rule
argument_list|,
name|filter
argument_list|)
condition|)
continue|continue;
name|rctl_rule_to_sbuf
argument_list|(
name|sb
argument_list|,
name|link
operator|->
name|rrl_rule
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|rw_runlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sys_rctl_get_rules
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|rctl_get_rules_args
modifier|*
name|uap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|size_t
name|bufsize
init|=
name|RCTL_DEFAULT_BUFSIZE
decl_stmt|;
name|char
modifier|*
name|inputstr
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|struct
name|rctl_rule
modifier|*
name|filter
decl_stmt|;
name|struct
name|rctl_rule_link
modifier|*
name|link
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_RCTL_GET_RULES
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|rctl_read_inbuf
argument_list|(
operator|&
name|inputstr
argument_list|,
name|uap
operator|->
name|inbufp
argument_list|,
name|uap
operator|->
name|inbuflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sx_slock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|rctl_string_to_rule
argument_list|(
name|inputstr
argument_list|,
operator|&
name|filter
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inputstr
argument_list|,
name|M_RCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|again
label|:
name|buf
operator|=
name|malloc
argument_list|(
name|bufsize
argument_list|,
name|M_RCTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sb
operator|=
name|sbuf_new
argument_list|(
name|NULL
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"sbuf_new failed"
operator|)
argument_list|)
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|allproc_lock
argument_list|,
name|SA_LOCKED
argument_list|)
expr_stmt|;
name|FOREACH_PROC_IN_SYSTEM
argument_list|(
argument|p
argument_list|)
block|{
name|rw_rlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|link
argument_list|,
argument|&p->p_racct->r_rule_links
argument_list|,
argument|rrl_next
argument_list|)
block|{
comment|/* 			 * Non-process rules will be added to the buffer later. 			 * Adding them here would result in duplicated output. 			 */
if|if
condition|(
name|link
operator|->
name|rrl_rule
operator|->
name|rr_subject_type
operator|!=
name|RCTL_SUBJECT_TYPE_PROCESS
condition|)
continue|continue;
if|if
condition|(
operator|!
name|rctl_rule_matches
argument_list|(
name|link
operator|->
name|rrl_rule
argument_list|,
name|filter
argument_list|)
condition|)
continue|continue;
name|rctl_rule_to_sbuf
argument_list|(
name|sb
argument_list|,
name|link
operator|->
name|rrl_rule
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|rw_runlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
block|}
name|loginclass_racct_foreach
argument_list|(
name|rctl_get_rules_callback
argument_list|,
name|filter
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|ui_racct_foreach
argument_list|(
name|rctl_get_rules_callback
argument_list|,
name|filter
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|prison_racct_foreach
argument_list|(
name|rctl_get_rules_callback
argument_list|,
name|filter
argument_list|,
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbuf_error
argument_list|(
name|sb
argument_list|)
operator|==
name|ENOMEM
condition|)
block|{
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_RCTL
argument_list|)
expr_stmt|;
name|bufsize
operator|*=
literal|4
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* 	 * Remove trailing ",". 	 */
if|if
condition|(
name|sbuf_len
argument_list|(
name|sb
argument_list|)
operator|>
literal|0
condition|)
name|sbuf_setpos
argument_list|(
name|sb
argument_list|,
name|sbuf_len
argument_list|(
name|sb
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|rctl_write_outbuf
argument_list|(
name|sb
argument_list|,
name|uap
operator|->
name|outbufp
argument_list|,
name|uap
operator|->
name|outbuflen
argument_list|)
expr_stmt|;
name|rctl_rule_release
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_RCTL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sys_rctl_get_limits
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|rctl_get_limits_args
modifier|*
name|uap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|size_t
name|bufsize
init|=
name|RCTL_DEFAULT_BUFSIZE
decl_stmt|;
name|char
modifier|*
name|inputstr
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|struct
name|rctl_rule
modifier|*
name|filter
decl_stmt|;
name|struct
name|rctl_rule_link
modifier|*
name|link
decl_stmt|;
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_RCTL_GET_LIMITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|rctl_read_inbuf
argument_list|(
operator|&
name|inputstr
argument_list|,
name|uap
operator|->
name|inbufp
argument_list|,
name|uap
operator|->
name|inbuflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sx_slock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|rctl_string_to_rule
argument_list|(
name|inputstr
argument_list|,
operator|&
name|filter
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inputstr
argument_list|,
name|M_RCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|filter
operator|->
name|rr_subject_type
operator|==
name|RCTL_SUBJECT_TYPE_UNDEFINED
condition|)
block|{
name|rctl_rule_release
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|filter
operator|->
name|rr_subject_type
operator|!=
name|RCTL_SUBJECT_TYPE_PROCESS
condition|)
block|{
name|rctl_rule_release
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
if|if
condition|(
name|filter
operator|->
name|rr_subject
operator|.
name|rs_proc
operator|==
name|NULL
condition|)
block|{
name|rctl_rule_release
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|again
label|:
name|buf
operator|=
name|malloc
argument_list|(
name|bufsize
argument_list|,
name|M_RCTL
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sb
operator|=
name|sbuf_new
argument_list|(
name|NULL
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"sbuf_new failed"
operator|)
argument_list|)
expr_stmt|;
name|rw_rlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|link
argument_list|,
argument|&filter->rr_subject.rs_proc->p_racct->r_rule_links
argument_list|,
argument|rrl_next
argument_list|)
block|{
name|rctl_rule_to_sbuf
argument_list|(
name|sb
argument_list|,
name|link
operator|->
name|rrl_rule
argument_list|)
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|rw_runlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbuf_error
argument_list|(
name|sb
argument_list|)
operator|==
name|ENOMEM
condition|)
block|{
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_RCTL
argument_list|)
expr_stmt|;
name|bufsize
operator|*=
literal|4
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* 	 * Remove trailing ",". 	 */
if|if
condition|(
name|sbuf_len
argument_list|(
name|sb
argument_list|)
operator|>
literal|0
condition|)
name|sbuf_setpos
argument_list|(
name|sb
argument_list|,
name|sbuf_len
argument_list|(
name|sb
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|rctl_write_outbuf
argument_list|(
name|sb
argument_list|,
name|uap
operator|->
name|outbufp
argument_list|,
name|uap
operator|->
name|outbuflen
argument_list|)
expr_stmt|;
name|rctl_rule_release
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_RCTL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sys_rctl_add_rule
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|rctl_add_rule_args
modifier|*
name|uap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|rctl_rule
modifier|*
name|rule
decl_stmt|;
name|char
modifier|*
name|inputstr
decl_stmt|;
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_RCTL_ADD_RULE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|rctl_read_inbuf
argument_list|(
operator|&
name|inputstr
argument_list|,
name|uap
operator|->
name|inbufp
argument_list|,
name|uap
operator|->
name|inbuflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sx_slock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|rctl_string_to_rule
argument_list|(
name|inputstr
argument_list|,
operator|&
name|rule
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inputstr
argument_list|,
name|M_RCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * The 'per' part of a rule is optional. 	 */
if|if
condition|(
name|rule
operator|->
name|rr_per
operator|==
name|RCTL_SUBJECT_TYPE_UNDEFINED
operator|&&
name|rule
operator|->
name|rr_subject_type
operator|!=
name|RCTL_SUBJECT_TYPE_UNDEFINED
condition|)
name|rule
operator|->
name|rr_per
operator|=
name|rule
operator|->
name|rr_subject_type
expr_stmt|;
if|if
condition|(
operator|!
name|rctl_rule_fully_specified
argument_list|(
name|rule
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|rctl_rule_add
argument_list|(
name|rule
argument_list|)
expr_stmt|;
name|out
label|:
name|rctl_rule_release
argument_list|(
name|rule
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sys_rctl_remove_rule
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|rctl_remove_rule_args
modifier|*
name|uap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|rctl_rule
modifier|*
name|filter
decl_stmt|;
name|char
modifier|*
name|inputstr
decl_stmt|;
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_RCTL_REMOVE_RULE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|rctl_read_inbuf
argument_list|(
operator|&
name|inputstr
argument_list|,
name|uap
operator|->
name|inbufp
argument_list|,
name|uap
operator|->
name|inbuflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sx_slock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|rctl_string_to_rule
argument_list|(
name|inputstr
argument_list|,
operator|&
name|filter
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inputstr
argument_list|,
name|M_RCTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|rctl_rule_remove
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|rctl_rule_release
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update RCTL rule list after credential change.  */
end_comment

begin_function
name|void
name|rctl_proc_ucred_changed
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ucred
modifier|*
name|newcred
parameter_list|)
block|{
name|int
name|rulecnt
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|rctl_rule_link
modifier|*
name|link
decl_stmt|,
modifier|*
name|newlink
decl_stmt|;
name|struct
name|uidinfo
modifier|*
name|newuip
decl_stmt|;
name|struct
name|loginclass
modifier|*
name|newlc
decl_stmt|;
name|struct
name|prison_racct
modifier|*
name|newprr
decl_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|rctl_rule_link
argument_list|)
name|newrules
expr_stmt|;
name|newuip
operator|=
name|newcred
operator|->
name|cr_ruidinfo
expr_stmt|;
name|newlc
operator|=
name|newcred
operator|->
name|cr_loginclass
expr_stmt|;
name|newprr
operator|=
name|newcred
operator|->
name|cr_prison
operator|->
name|pr_prison_racct
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|newrules
argument_list|)
expr_stmt|;
name|again
label|:
comment|/* 	 * First, count the rules that apply to the process with new 	 * credentials. 	 */
name|rulecnt
operator|=
literal|0
expr_stmt|;
name|rw_rlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|link
argument_list|,
argument|&p->p_racct->r_rule_links
argument_list|,
argument|rrl_next
argument_list|)
block|{
if|if
condition|(
name|link
operator|->
name|rrl_rule
operator|->
name|rr_subject_type
operator|==
name|RCTL_SUBJECT_TYPE_PROCESS
condition|)
name|rulecnt
operator|++
expr_stmt|;
block|}
name|LIST_FOREACH
argument_list|(
argument|link
argument_list|,
argument|&newuip->ui_racct->r_rule_links
argument_list|,
argument|rrl_next
argument_list|)
name|rulecnt
operator|++
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|link
argument_list|,
argument|&newlc->lc_racct->r_rule_links
argument_list|,
argument|rrl_next
argument_list|)
name|rulecnt
operator|++
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|link
argument_list|,
argument|&newprr->prr_racct->r_rule_links
argument_list|,
argument|rrl_next
argument_list|)
name|rulecnt
operator|++
expr_stmt|;
name|rw_runlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Create temporary list.  We've dropped the rctl_lock in order 	 * to use M_WAITOK. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rulecnt
condition|;
name|i
operator|++
control|)
block|{
name|newlink
operator|=
name|uma_zalloc
argument_list|(
name|rctl_rule_link_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|newlink
operator|->
name|rrl_rule
operator|=
name|NULL
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|newrules
argument_list|,
name|newlink
argument_list|,
name|rrl_next
argument_list|)
expr_stmt|;
block|}
name|newlink
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|newrules
argument_list|)
expr_stmt|;
comment|/* 	 * Assign rules to the newly allocated list entries. 	 */
name|rw_wlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|link
argument_list|,
argument|&p->p_racct->r_rule_links
argument_list|,
argument|rrl_next
argument_list|)
block|{
if|if
condition|(
name|link
operator|->
name|rrl_rule
operator|->
name|rr_subject_type
operator|==
name|RCTL_SUBJECT_TYPE_PROCESS
condition|)
block|{
if|if
condition|(
name|newlink
operator|==
name|NULL
condition|)
goto|goto
name|goaround
goto|;
name|rctl_rule_acquire
argument_list|(
name|link
operator|->
name|rrl_rule
argument_list|)
expr_stmt|;
name|newlink
operator|->
name|rrl_rule
operator|=
name|link
operator|->
name|rrl_rule
expr_stmt|;
name|newlink
operator|=
name|LIST_NEXT
argument_list|(
name|newlink
argument_list|,
name|rrl_next
argument_list|)
expr_stmt|;
name|rulecnt
operator|--
expr_stmt|;
block|}
block|}
name|LIST_FOREACH
argument_list|(
argument|link
argument_list|,
argument|&newuip->ui_racct->r_rule_links
argument_list|,
argument|rrl_next
argument_list|)
block|{
if|if
condition|(
name|newlink
operator|==
name|NULL
condition|)
goto|goto
name|goaround
goto|;
name|rctl_rule_acquire
argument_list|(
name|link
operator|->
name|rrl_rule
argument_list|)
expr_stmt|;
name|newlink
operator|->
name|rrl_rule
operator|=
name|link
operator|->
name|rrl_rule
expr_stmt|;
name|newlink
operator|=
name|LIST_NEXT
argument_list|(
name|newlink
argument_list|,
name|rrl_next
argument_list|)
expr_stmt|;
name|rulecnt
operator|--
expr_stmt|;
block|}
name|LIST_FOREACH
argument_list|(
argument|link
argument_list|,
argument|&newlc->lc_racct->r_rule_links
argument_list|,
argument|rrl_next
argument_list|)
block|{
if|if
condition|(
name|newlink
operator|==
name|NULL
condition|)
goto|goto
name|goaround
goto|;
name|rctl_rule_acquire
argument_list|(
name|link
operator|->
name|rrl_rule
argument_list|)
expr_stmt|;
name|newlink
operator|->
name|rrl_rule
operator|=
name|link
operator|->
name|rrl_rule
expr_stmt|;
name|newlink
operator|=
name|LIST_NEXT
argument_list|(
name|newlink
argument_list|,
name|rrl_next
argument_list|)
expr_stmt|;
name|rulecnt
operator|--
expr_stmt|;
block|}
name|LIST_FOREACH
argument_list|(
argument|link
argument_list|,
argument|&newprr->prr_racct->r_rule_links
argument_list|,
argument|rrl_next
argument_list|)
block|{
if|if
condition|(
name|newlink
operator|==
name|NULL
condition|)
goto|goto
name|goaround
goto|;
name|rctl_rule_acquire
argument_list|(
name|link
operator|->
name|rrl_rule
argument_list|)
expr_stmt|;
name|newlink
operator|->
name|rrl_rule
operator|=
name|link
operator|->
name|rrl_rule
expr_stmt|;
name|newlink
operator|=
name|LIST_NEXT
argument_list|(
name|newlink
argument_list|,
name|rrl_next
argument_list|)
expr_stmt|;
name|rulecnt
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|rulecnt
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Free the old rule list. 		 */
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|p
operator|->
name|p_racct
operator|->
name|r_rule_links
argument_list|)
condition|)
block|{
name|link
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|p
operator|->
name|p_racct
operator|->
name|r_rule_links
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|link
argument_list|,
name|rrl_next
argument_list|)
expr_stmt|;
name|rctl_rule_release
argument_list|(
name|link
operator|->
name|rrl_rule
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|rctl_rule_link_zone
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Replace lists and we're done. 		 * 		 * XXX: Is there any way to switch list heads instead 		 *      of iterating here? 		 */
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|newrules
argument_list|)
condition|)
block|{
name|newlink
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|newrules
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|newlink
argument_list|,
name|rrl_next
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|p
operator|->
name|p_racct
operator|->
name|r_rule_links
argument_list|,
name|newlink
argument_list|,
name|rrl_next
argument_list|)
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|goaround
label|:
name|rw_wunlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Rule list changed while we were not holding the rctl_lock. 	 * Free the new list and try again. 	 */
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|newrules
argument_list|)
condition|)
block|{
name|newlink
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|newrules
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|newlink
argument_list|,
name|rrl_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlink
operator|->
name|rrl_rule
operator|!=
name|NULL
condition|)
name|rctl_rule_release
argument_list|(
name|newlink
operator|->
name|rrl_rule
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|rctl_rule_link_zone
argument_list|,
name|newlink
argument_list|)
expr_stmt|;
block|}
goto|goto
name|again
goto|;
block|}
end_function

begin_comment
comment|/*  * Assign RCTL rules to the newly created process.  */
end_comment

begin_function
name|int
name|rctl_proc_fork
parameter_list|(
name|struct
name|proc
modifier|*
name|parent
parameter_list|,
name|struct
name|proc
modifier|*
name|child
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|rctl_rule_link
modifier|*
name|link
decl_stmt|;
name|struct
name|rctl_rule
modifier|*
name|rule
decl_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|child
operator|->
name|p_racct
operator|->
name|r_rule_links
argument_list|)
expr_stmt|;
comment|/* 	 * No limits for kernel processes. 	 */
if|if
condition|(
name|child
operator|->
name|p_flag
operator|&
name|P_SYSTEM
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Nothing to inherit from P_SYSTEM parents. 	 */
if|if
condition|(
name|parent
operator|->
name|p_racct
operator|==
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|parent
operator|->
name|p_flag
operator|&
name|P_SYSTEM
argument_list|,
operator|(
literal|"non-system process without racct; p = %p"
operator|,
name|parent
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|rw_wlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Go through limits applicable to the parent and assign them 	 * to the child.  Rules with 'process' subject have to be duplicated 	 * in order to make their rr_subject point to the new process. 	 */
name|LIST_FOREACH
argument_list|(
argument|link
argument_list|,
argument|&parent->p_racct->r_rule_links
argument_list|,
argument|rrl_next
argument_list|)
block|{
if|if
condition|(
name|link
operator|->
name|rrl_rule
operator|->
name|rr_subject_type
operator|==
name|RCTL_SUBJECT_TYPE_PROCESS
condition|)
block|{
name|rule
operator|=
name|rctl_rule_duplicate
argument_list|(
name|link
operator|->
name|rrl_rule
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rule
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
name|KASSERT
argument_list|(
name|rule
operator|->
name|rr_subject
operator|.
name|rs_proc
operator|==
name|parent
argument_list|,
operator|(
literal|"rule->rr_subject.rs_proc != parent"
operator|)
argument_list|)
expr_stmt|;
name|rule
operator|->
name|rr_subject
operator|.
name|rs_proc
operator|=
name|child
expr_stmt|;
name|error
operator|=
name|rctl_racct_add_rule_locked
argument_list|(
name|child
operator|->
name|p_racct
argument_list|,
name|rule
argument_list|)
expr_stmt|;
name|rctl_rule_release
argument_list|(
name|rule
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
block|}
else|else
block|{
name|error
operator|=
name|rctl_racct_add_rule_locked
argument_list|(
name|child
operator|->
name|p_racct
argument_list|,
name|link
operator|->
name|rrl_rule
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
block|}
block|}
name|rw_wunlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|child
operator|->
name|p_racct
operator|->
name|r_rule_links
argument_list|)
condition|)
block|{
name|link
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|child
operator|->
name|p_racct
operator|->
name|r_rule_links
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|link
argument_list|,
name|rrl_next
argument_list|)
expr_stmt|;
name|rctl_rule_release
argument_list|(
name|link
operator|->
name|rrl_rule
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|rctl_rule_link_zone
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release rules attached to the racct.  */
end_comment

begin_function
name|void
name|rctl_racct_release
parameter_list|(
name|struct
name|racct
modifier|*
name|racct
parameter_list|)
block|{
name|struct
name|rctl_rule_link
modifier|*
name|link
decl_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|racct
operator|->
name|r_rule_links
argument_list|)
condition|)
block|{
name|link
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|racct
operator|->
name|r_rule_links
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|link
argument_list|,
name|rrl_next
argument_list|)
expr_stmt|;
name|rctl_rule_release
argument_list|(
name|link
operator|->
name|rrl_rule
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|rctl_rule_link_zone
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|rctl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rctl_init
parameter_list|(
name|void
parameter_list|)
block|{
name|rctl_rule_link_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"rctl_rule_link"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rctl_rule_link
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
name|rctl_rule_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"rctl_rule"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rctl_rule
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !RCTL */
end_comment

begin_function
name|int
name|sys_rctl_get_racct
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|rctl_get_racct_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sys_rctl_get_rules
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|rctl_get_rules_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sys_rctl_get_limits
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|rctl_get_limits_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sys_rctl_add_rule
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|rctl_add_rule_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sys_rctl_remove_rule
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|rctl_remove_rule_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !RCTL */
end_comment

end_unit

