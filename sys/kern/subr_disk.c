begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@FreeBSD.ORG> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_geom.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom_disk.h>
end_include

begin_comment
comment|/*-  * Disk error is the preface to plaintive error messages  * about failing disk transfers.  It prints messages of the form  * 	"hp0g: BLABLABLA cmd=read fsbn 12345 of 12344-12347"  * blkdone should be -1 if the position of the error is unknown.  * The message is printed with printf.  */
end_comment

begin_function
name|void
name|disk_err
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|int
name|blkdone
parameter_list|,
name|int
name|nl
parameter_list|)
block|{
name|daddr_t
name|sn
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_dev
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s: %s "
argument_list|,
name|devtoname
argument_list|(
name|bp
operator|->
name|bio_dev
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bp
operator|->
name|bio_disk
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s%d: %s "
argument_list|,
name|bp
operator|->
name|bio_disk
operator|->
name|d_name
argument_list|,
name|bp
operator|->
name|bio_disk
operator|->
name|d_unit
argument_list|,
name|what
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"disk??: %s "
argument_list|,
name|what
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
name|printf
argument_list|(
literal|"cmd=read "
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_WRITE
case|:
name|printf
argument_list|(
literal|"cmd=write "
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_DELETE
case|:
name|printf
argument_list|(
literal|"cmd=delete "
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_GETATTR
case|:
name|printf
argument_list|(
literal|"cmd=getattr "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"cmd=%x "
argument_list|,
name|bp
operator|->
name|bio_cmd
argument_list|)
expr_stmt|;
break|break;
block|}
name|sn
operator|=
name|bp
operator|->
name|bio_pblkno
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_bcount
operator|<=
name|DEV_BSIZE
condition|)
block|{
name|printf
argument_list|(
literal|"fsbn %jd%s"
argument_list|,
operator|(
name|intmax_t
operator|)
name|sn
argument_list|,
name|nl
condition|?
literal|"\n"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|blkdone
operator|>=
literal|0
condition|)
block|{
name|sn
operator|+=
name|blkdone
expr_stmt|;
name|printf
argument_list|(
literal|"fsbn %jd of "
argument_list|,
operator|(
name|intmax_t
operator|)
name|sn
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%jd-%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|bp
operator|->
name|bio_pblkno
argument_list|,
call|(
name|intmax_t
call|)
argument_list|(
name|bp
operator|->
name|bio_pblkno
operator|+
operator|(
name|bp
operator|->
name|bio_bcount
operator|-
literal|1
operator|)
operator|/
name|DEV_BSIZE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * BIO queue implementation  */
end_comment

begin_function
name|void
name|bioq_init
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|head
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|)
expr_stmt|;
name|head
operator|->
name|last_offset
operator|=
literal|0
expr_stmt|;
name|head
operator|->
name|insert_point
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bioq_remove
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|head
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
name|bp
operator|==
name|head
operator|->
name|insert_point
condition|)
block|{
name|head
operator|->
name|last_offset
operator|=
name|bp
operator|->
name|bio_offset
expr_stmt|;
name|head
operator|->
name|insert_point
operator|=
name|TAILQ_NEXT
argument_list|(
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|insert_point
operator|==
name|NULL
condition|)
block|{
name|head
operator|->
name|last_offset
operator|=
literal|0
expr_stmt|;
name|head
operator|->
name|insert_point
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|)
expr_stmt|;
block|}
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bioq_flush
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|head
parameter_list|,
name|struct
name|devstat
modifier|*
name|stp
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|bioq_takefirst
argument_list|(
name|head
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|biofinish
argument_list|(
name|bp
argument_list|,
name|stp
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bioq_insert_head
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|head
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|)
operator|==
name|NULL
condition|)
name|head
operator|->
name|insert_point
operator|=
name|bp
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bioq_insert_tail
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|head
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|)
operator|==
name|NULL
condition|)
name|head
operator|->
name|insert_point
operator|=
name|bp
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|bio
modifier|*
name|bioq_first
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|head
parameter_list|)
block|{
return|return
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|bio
modifier|*
name|bioq_takefirst
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|bioq_remove
argument_list|(
name|head
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Seek sort for disks.  *  * The disksort algorithm sorts all requests in a single queue while keeping  * track of the current position of the disk with insert_point and  * last_offset.  last_offset is the offset of the last block sent to disk, or  * 0 once we reach the end.  insert_point points to the first buf after  * last_offset, and is used to slightly speed up insertions.  Blocks are  * always sorted in ascending order and the queue always restarts at 0.  * This implements the one-way scan which optimizes disk seek times.  */
end_comment

begin_function
name|void
name|bioq_disksort
parameter_list|(
name|bioq
parameter_list|,
name|bp
parameter_list|)
name|struct
name|bio_queue_head
modifier|*
name|bioq
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|bio
modifier|*
name|bq
decl_stmt|;
name|struct
name|bio
modifier|*
name|bn
decl_stmt|;
comment|/* 	 * If the queue is empty then it's easy. 	 */
if|if
condition|(
name|bioq_first
argument_list|(
name|bioq
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|bioq_insert_tail
argument_list|(
name|bioq
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Optimize for sequential I/O by seeing if we go at the tail. 	 */
name|bq
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|bioq
operator|->
name|queue
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_offset
operator|>
name|bq
operator|->
name|bio_offset
condition|)
block|{
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|bioq
operator|->
name|queue
argument_list|,
name|bq
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Pick our scan start based on the last request.  A poor man's 	 * binary search. 	 */
if|if
condition|(
name|bp
operator|->
name|bio_offset
operator|>=
name|bioq
operator|->
name|last_offset
condition|)
block|{
name|bq
operator|=
name|bioq
operator|->
name|insert_point
expr_stmt|;
comment|/* 		 * If we're before the next bio and after the last offset, 		 * update insert_point; 		 */
if|if
condition|(
name|bp
operator|->
name|bio_offset
operator|<
name|bq
operator|->
name|bio_offset
condition|)
block|{
name|bioq
operator|->
name|insert_point
operator|=
name|bp
expr_stmt|;
name|TAILQ_INSERT_BEFORE
argument_list|(
name|bq
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|bq
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|bioq
operator|->
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_offset
operator|<
name|bq
operator|->
name|bio_offset
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|bq
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Insertion sort */
while|while
condition|(
operator|(
name|bn
operator|=
name|TAILQ_NEXT
argument_list|(
name|bq
argument_list|,
name|bio_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bio_offset
operator|<
name|bn
operator|->
name|bio_offset
condition|)
break|break;
name|bq
operator|=
name|bn
expr_stmt|;
block|}
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|bioq
operator|->
name|queue
argument_list|,
name|bq
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

