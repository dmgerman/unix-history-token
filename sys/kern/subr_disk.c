begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@FreeBSD.ORG> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  *  * The bioq_disksort() (and the specification of the bioq API)  * have been written by Luigi Rizzo and Fabio Checconi under the same  * license as above.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_geom.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom_disk.h>
end_include

begin_comment
comment|/*-  * Disk error is the preface to plaintive error messages  * about failing disk transfers.  It prints messages of the form  * 	"hp0g: BLABLABLA cmd=read fsbn 12345 of 12344-12347"  * blkdone should be -1 if the position of the error is unknown.  * The message is printed with printf.  */
end_comment

begin_function
name|void
name|disk_err
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|int
name|blkdone
parameter_list|,
name|int
name|nl
parameter_list|)
block|{
name|daddr_t
name|sn
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_dev
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s: %s "
argument_list|,
name|devtoname
argument_list|(
name|bp
operator|->
name|bio_dev
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bp
operator|->
name|bio_disk
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s%d: %s "
argument_list|,
name|bp
operator|->
name|bio_disk
operator|->
name|d_name
argument_list|,
name|bp
operator|->
name|bio_disk
operator|->
name|d_unit
argument_list|,
name|what
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"disk??: %s "
argument_list|,
name|what
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
name|printf
argument_list|(
literal|"cmd=read "
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_WRITE
case|:
name|printf
argument_list|(
literal|"cmd=write "
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_DELETE
case|:
name|printf
argument_list|(
literal|"cmd=delete "
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_GETATTR
case|:
name|printf
argument_list|(
literal|"cmd=getattr "
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_FLUSH
case|:
name|printf
argument_list|(
literal|"cmd=flush "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"cmd=%x "
argument_list|,
name|bp
operator|->
name|bio_cmd
argument_list|)
expr_stmt|;
break|break;
block|}
name|sn
operator|=
name|bp
operator|->
name|bio_pblkno
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_bcount
operator|<=
name|DEV_BSIZE
condition|)
block|{
name|printf
argument_list|(
literal|"fsbn %jd%s"
argument_list|,
operator|(
name|intmax_t
operator|)
name|sn
argument_list|,
name|nl
condition|?
literal|"\n"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|blkdone
operator|>=
literal|0
condition|)
block|{
name|sn
operator|+=
name|blkdone
expr_stmt|;
name|printf
argument_list|(
literal|"fsbn %jd of "
argument_list|,
operator|(
name|intmax_t
operator|)
name|sn
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%jd-%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|bp
operator|->
name|bio_pblkno
argument_list|,
call|(
name|intmax_t
call|)
argument_list|(
name|bp
operator|->
name|bio_pblkno
operator|+
operator|(
name|bp
operator|->
name|bio_bcount
operator|-
literal|1
operator|)
operator|/
name|DEV_BSIZE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * BIO queue implementation  *  * Please read carefully the description below before making any change  * to the code, or you might change the behaviour of the data structure  * in undesirable ways.  *  * A bioq stores disk I/O request (bio), normally sorted according to  * the distance of the requested position (bio->bio_offset) from the  * current head position (bioq->last_offset) in the scan direction, i.e.  *  * 	(uoff_t)(bio_offset - last_offset)  *  * Note that the cast to unsigned (uoff_t) is fundamental to insure  * that the distance is computed in the scan direction.  *  * The main methods for manipulating the bioq are:  *  *   bioq_disksort()	performs an ordered insertion;  *  *   bioq_first()	return the head of the queue, without removing;  *  *   bioq_takefirst()	return and remove the head of the queue,  *		updating the 'current head position' as  *		bioq->last_offset = bio->bio_offset + bio->bio_length;  *  * When updating the 'current head position', we assume that the result of  * bioq_takefirst() is dispatched to the device, so bioq->last_offset  * represents the head position once the request is complete.  *  * If the bioq is manipulated using only the above calls, it starts  * with a sorted sequence of requests with bio_offset>= last_offset,  * possibly followed by another sorted sequence of requests with  * 0<= bio_offset< bioq->last_offset   *  * NOTE: historical behaviour was to ignore bio->bio_length in the  *	update, but its use tracks the head position in a better way.  *	Historical behaviour was also to update the head position when  *	the request under service is complete, rather than when the  *	request is extracted from the queue. However, the current API  *	has no method to update the head position; secondly, once  *	a request has been submitted to the disk, we have no idea of  *	the actual head position, so the final one is our best guess.  *  * --- Direct queue manipulation ---  *  * A bioq uses an underlying TAILQ to store requests, so we also  * export methods to manipulate the TAILQ, in particular:  *  * bioq_insert_tail()	insert an entry at the end.  *		It also creates a 'barrier' so all subsequent  *		insertions through bioq_disksort() will end up  *		after this entry;  *  * bioq_insert_head()	insert an entry at the head, update  *		bioq->last_offset = bio->bio_offset so that  *		all subsequent insertions through bioq_disksort()  *		will end up after this entry;  *  * bioq_remove()	remove a generic element from the queue, act as  *		bioq_takefirst() if invoked on the head of the queue.  *  * The semantic of these methods is the same as the operations  * on the underlying TAILQ, but with additional guarantees on  * subsequent bioq_disksort() calls. E.g. bioq_insert_tail()  * can be useful for making sure that all previous ops are flushed  * to disk before continuing.  *  * Updating bioq->last_offset on a bioq_insert_head() guarantees  * that the bio inserted with the last bioq_insert_head() will stay  * at the head of the queue even after subsequent bioq_disksort().  *  * Note that when the direct queue manipulation functions are used,  * the queue may contain multiple inversion points (i.e. more than  * two sorted sequences of requests).  *  */
end_comment

begin_function
name|void
name|bioq_init
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|head
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|)
expr_stmt|;
name|head
operator|->
name|last_offset
operator|=
literal|0
expr_stmt|;
name|head
operator|->
name|insert_point
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bioq_remove
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|head
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
name|head
operator|->
name|insert_point
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bp
operator|==
name|TAILQ_FIRST
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|)
condition|)
name|head
operator|->
name|last_offset
operator|=
name|bp
operator|->
name|bio_offset
operator|+
name|bp
operator|->
name|bio_length
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|==
name|head
operator|->
name|insert_point
condition|)
name|head
operator|->
name|insert_point
operator|=
name|NULL
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bioq_flush
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|head
parameter_list|,
name|struct
name|devstat
modifier|*
name|stp
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|bioq_takefirst
argument_list|(
name|head
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|biofinish
argument_list|(
name|bp
argument_list|,
name|stp
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bioq_insert_head
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|head
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
name|head
operator|->
name|insert_point
operator|==
name|NULL
condition|)
name|head
operator|->
name|last_offset
operator|=
name|bp
operator|->
name|bio_offset
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bioq_insert_tail
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|head
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
name|head
operator|->
name|insert_point
operator|=
name|bp
expr_stmt|;
name|head
operator|->
name|last_offset
operator|=
name|bp
operator|->
name|bio_offset
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|bio
modifier|*
name|bioq_first
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|head
parameter_list|)
block|{
return|return
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|bio
modifier|*
name|bioq_takefirst
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|bioq_remove
argument_list|(
name|head
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the sorting key. The cast to unsigned is  * fundamental for correctness, see the description  * near the beginning of the file.  */
end_comment

begin_function
specifier|static
specifier|inline
name|uoff_t
name|bioq_bio_key
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|head
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
return|return
operator|(
call|(
name|uoff_t
call|)
argument_list|(
name|bp
operator|->
name|bio_offset
operator|-
name|head
operator|->
name|last_offset
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Seek sort for disks.  *  * Sort all requests in a single queue while keeping  * track of the current position of the disk with last_offset.  * See above for details.  */
end_comment

begin_function
name|void
name|bioq_disksort
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|head
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|cur
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|uoff_t
name|key
decl_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|bio_flags
operator|&
name|BIO_ORDERED
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Ordered transactions can only be dispatched 		 * after any currently queued transactions.  They 		 * also have barrier semantics - no transactions 		 * queued in the future can pass them. 		 */
name|bioq_insert_tail
argument_list|(
name|head
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|prev
operator|=
name|NULL
expr_stmt|;
name|key
operator|=
name|bioq_bio_key
argument_list|(
name|head
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|cur
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|insert_point
condition|)
block|{
name|prev
operator|=
name|head
operator|->
name|insert_point
expr_stmt|;
name|cur
operator|=
name|TAILQ_NEXT
argument_list|(
name|head
operator|->
name|insert_point
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|cur
operator|!=
name|NULL
operator|&&
name|key
operator|>=
name|bioq_bio_key
argument_list|(
name|head
argument_list|,
name|cur
argument_list|)
condition|)
block|{
name|prev
operator|=
name|cur
expr_stmt|;
name|cur
operator|=
name|TAILQ_NEXT
argument_list|(
name|cur
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|,
name|prev
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

