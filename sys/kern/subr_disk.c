begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@FreeBSD.ORG> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_geom.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<geom/geom_disk.h>
end_include

begin_comment
comment|/*-  * Disk error is the preface to plaintive error messages  * about failing disk transfers.  It prints messages of the form  * 	"hp0g: BLABLABLA cmd=read fsbn 12345 of 12344-12347"  * blkdone should be -1 if the position of the error is unknown.  * The message is printed with printf.  */
end_comment

begin_function
name|void
name|disk_err
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|int
name|blkdone
parameter_list|,
name|int
name|nl
parameter_list|)
block|{
name|daddr_t
name|sn
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_dev
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s: %s "
argument_list|,
name|devtoname
argument_list|(
name|bp
operator|->
name|bio_dev
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bp
operator|->
name|bio_disk
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s%d: %s "
argument_list|,
name|bp
operator|->
name|bio_disk
operator|->
name|d_name
argument_list|,
name|bp
operator|->
name|bio_disk
operator|->
name|d_unit
argument_list|,
name|what
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"disk??: %s "
argument_list|,
name|what
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
name|printf
argument_list|(
literal|"cmd=read "
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_WRITE
case|:
name|printf
argument_list|(
literal|"cmd=write "
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_DELETE
case|:
name|printf
argument_list|(
literal|"cmd=delete "
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_GETATTR
case|:
name|printf
argument_list|(
literal|"cmd=getattr "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"cmd=%x "
argument_list|,
name|bp
operator|->
name|bio_cmd
argument_list|)
expr_stmt|;
break|break;
block|}
name|sn
operator|=
name|bp
operator|->
name|bio_blkno
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_bcount
operator|<=
name|DEV_BSIZE
condition|)
block|{
name|printf
argument_list|(
literal|"fsbn %jd%s"
argument_list|,
operator|(
name|intmax_t
operator|)
name|sn
argument_list|,
name|nl
condition|?
literal|"\n"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|blkdone
operator|>=
literal|0
condition|)
block|{
name|sn
operator|+=
name|blkdone
expr_stmt|;
name|printf
argument_list|(
literal|"fsbn %jd of "
argument_list|,
operator|(
name|intmax_t
operator|)
name|sn
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%jd-%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|bp
operator|->
name|bio_blkno
argument_list|,
call|(
name|intmax_t
call|)
argument_list|(
name|bp
operator|->
name|bio_blkno
operator|+
operator|(
name|bp
operator|->
name|bio_bcount
operator|-
literal|1
operator|)
operator|/
name|DEV_BSIZE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * BIO queue implementation  */
end_comment

begin_function
name|void
name|bioq_init
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|head
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|)
expr_stmt|;
name|head
operator|->
name|last_pblkno
operator|=
literal|0
expr_stmt|;
name|head
operator|->
name|insert_point
operator|=
name|NULL
expr_stmt|;
name|head
operator|->
name|switch_point
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bioq_remove
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|head
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
name|bp
operator|==
name|head
operator|->
name|switch_point
condition|)
name|head
operator|->
name|switch_point
operator|=
name|TAILQ_NEXT
argument_list|(
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|head
operator|->
name|insert_point
condition|)
block|{
name|head
operator|->
name|insert_point
operator|=
name|TAILQ_PREV
argument_list|(
name|bp
argument_list|,
name|bio_queue
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|insert_point
operator|==
name|NULL
condition|)
name|head
operator|->
name|last_pblkno
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|==
name|TAILQ_FIRST
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|)
condition|)
name|head
operator|->
name|last_pblkno
operator|=
name|bp
operator|->
name|bio_pblkno
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|)
operator|==
name|head
operator|->
name|switch_point
condition|)
name|head
operator|->
name|switch_point
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bioq_flush
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|head
parameter_list|,
name|struct
name|devstat
modifier|*
name|stp
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bp
operator|=
name|bioq_first
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
break|break;
name|bioq_remove
argument_list|(
name|head
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|biofinish
argument_list|(
name|bp
argument_list|,
name|stp
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|bioq_insert_tail
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|head
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|bio
modifier|*
name|bioq_first
parameter_list|(
name|struct
name|bio_queue_head
modifier|*
name|head
parameter_list|)
block|{
return|return
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|head
operator|->
name|queue
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Seek sort for disks.  *  * The buf_queue keep two queues, sorted in ascending block order.  The first  * queue holds those requests which are positioned after the current block  * (in the first request); the second, which starts at queue->switch_point,  * holds requests which came in after their block number was passed.  Thus  * we implement a one way scan, retracting after reaching the end of the drive  * to the first request on the second queue, at which time it becomes the  * first queue.  *  * A one-way scan is natural because of the way UNIX read-ahead blocks are  * allocated.  */
end_comment

begin_function
name|void
name|bioq_disksort
parameter_list|(
name|bioq
parameter_list|,
name|bp
parameter_list|)
name|struct
name|bio_queue_head
modifier|*
name|bioq
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|bio
modifier|*
name|bq
decl_stmt|;
name|struct
name|bio
modifier|*
name|bn
decl_stmt|;
name|struct
name|bio
modifier|*
name|be
decl_stmt|;
name|be
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|bioq
operator|->
name|queue
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
comment|/* 	 * If the queue is empty or we are an 	 * ordered transaction, then it's easy. 	 */
if|if
condition|(
operator|(
name|bq
operator|=
name|bioq_first
argument_list|(
name|bioq
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bioq_insert_tail
argument_list|(
name|bioq
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|bioq
operator|->
name|insert_point
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * A certain portion of the list is 		 * "locked" to preserve ordering, so 		 * we can only insert after the insert 		 * point. 		 */
name|bq
operator|=
name|bioq
operator|->
name|insert_point
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If we lie before the last removed (currently active) 		 * request, and are not inserting ourselves into the 		 * "locked" portion of the list, then we must add ourselves 		 * to the second request list. 		 */
if|if
condition|(
name|bp
operator|->
name|bio_pblkno
operator|<
name|bioq
operator|->
name|last_pblkno
condition|)
block|{
name|bq
operator|=
name|bioq
operator|->
name|switch_point
expr_stmt|;
comment|/* 			 * If we are starting a new secondary list, 			 * then it's easy. 			 */
if|if
condition|(
name|bq
operator|==
name|NULL
condition|)
block|{
name|bioq
operator|->
name|switch_point
operator|=
name|bp
expr_stmt|;
name|bioq_insert_tail
argument_list|(
name|bioq
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 			 * If we lie ahead of the current switch point, 			 * insert us before the switch point and move 			 * the switch point. 			 */
if|if
condition|(
name|bp
operator|->
name|bio_pblkno
operator|<
name|bq
operator|->
name|bio_pblkno
condition|)
block|{
name|bioq
operator|->
name|switch_point
operator|=
name|bp
expr_stmt|;
name|TAILQ_INSERT_BEFORE
argument_list|(
name|bq
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
name|bioq
operator|->
name|switch_point
operator|!=
name|NULL
condition|)
name|be
operator|=
name|TAILQ_PREV
argument_list|(
name|bioq
operator|->
name|switch_point
argument_list|,
name|bio_queue
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
comment|/* 			 * If we lie between last_pblkno and bq, 			 * insert before bq. 			 */
if|if
condition|(
name|bp
operator|->
name|bio_pblkno
operator|<
name|bq
operator|->
name|bio_pblkno
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|bq
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* 	 * Request is at/after our current position in the list. 	 * Optimize for sequential I/O by seeing if we go at the tail. 	 */
if|if
condition|(
name|bp
operator|->
name|bio_pblkno
operator|>
name|be
operator|->
name|bio_pblkno
condition|)
block|{
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|bioq
operator|->
name|queue
argument_list|,
name|be
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, insertion sort */
while|while
condition|(
operator|(
name|bn
operator|=
name|TAILQ_NEXT
argument_list|(
name|bq
argument_list|,
name|bio_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We want to go after the current request if it is the end 		 * of the first request list, or if the next request is a 		 * larger cylinder than our request. 		 */
if|if
condition|(
name|bn
operator|==
name|bioq
operator|->
name|switch_point
operator|||
name|bp
operator|->
name|bio_pblkno
operator|<
name|bn
operator|->
name|bio_pblkno
condition|)
break|break;
name|bq
operator|=
name|bn
expr_stmt|;
block|}
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|bioq
operator|->
name|queue
argument_list|,
name|bq
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

