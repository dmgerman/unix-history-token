begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@FreeBSD.ORG> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|"opt_geom.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/diskslice.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NO_GEOM
end_ifdef

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_DISK
argument_list|,
literal|"disk"
argument_list|,
literal|"disk data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|d_strategy_t
name|diskstrategy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|diskopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|diskclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|diskioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_psize_t
name|diskpsize
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|disk
argument_list|)
name|disklist
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
operator|&
name|disklist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
name|void
name|disk_dev_synth
parameter_list|(
name|dev_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|disk_dev_synth
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|struct
name|disk
modifier|*
name|dp
decl_stmt|;
name|int
name|u
decl_stmt|,
name|s
decl_stmt|,
name|p
decl_stmt|;
name|dev_t
name|pdev
decl_stmt|;
if|if
condition|(
name|dksparebits
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
name|LIST_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|&disklist
argument_list|,
argument|d_list
argument_list|)
block|{
if|if
condition|(
name|major
argument_list|(
name|dev
argument_list|)
operator|!=
name|dp
operator|->
name|d_devsw
operator|->
name|d_maj
condition|)
continue|continue;
name|u
operator|=
name|dkunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|p
operator|=
name|RAW_PART
expr_stmt|;
name|s
operator|=
name|WHOLE_DISK_SLICE
expr_stmt|;
name|pdev
operator|=
name|makedev
argument_list|(
name|dp
operator|->
name|d_devsw
operator|->
name|d_maj
argument_list|,
name|dkmakeminor
argument_list|(
name|u
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdev
operator|->
name|si_devsw
operator|==
name|NULL
condition|)
return|return;
comment|/* Probably a unit we don't have */
name|s
operator|=
name|dkslice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|p
operator|=
name|dkpart
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|WHOLE_DISK_SLICE
operator|&&
name|p
operator|==
name|RAW_PART
condition|)
block|{
comment|/* XXX: actually should not happen */
name|dev
operator|=
name|make_dev
argument_list|(
name|pdev
operator|->
name|si_devsw
argument_list|,
name|dkmakeminor
argument_list|(
name|u
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"%s%d"
argument_list|,
name|dp
operator|->
name|d_devsw
operator|->
name|d_name
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|dev_depends
argument_list|(
name|pdev
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|s
operator|==
name|COMPATIBILITY_SLICE
condition|)
block|{
name|dev
operator|=
name|make_dev
argument_list|(
name|pdev
operator|->
name|si_devsw
argument_list|,
name|dkmakeminor
argument_list|(
name|u
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"%s%d%c"
argument_list|,
name|dp
operator|->
name|d_devsw
operator|->
name|d_name
argument_list|,
name|u
argument_list|,
literal|'a'
operator|+
name|p
argument_list|)
expr_stmt|;
name|dev_depends
argument_list|(
name|pdev
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|!=
name|RAW_PART
condition|)
block|{
name|dev
operator|=
name|make_dev
argument_list|(
name|pdev
operator|->
name|si_devsw
argument_list|,
name|dkmakeminor
argument_list|(
name|u
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"%s%ds%d%c"
argument_list|,
name|dp
operator|->
name|d_devsw
operator|->
name|d_name
argument_list|,
name|u
argument_list|,
name|s
operator|-
name|BASE_SLICE
operator|+
literal|1
argument_list|,
literal|'a'
operator|+
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|=
name|make_dev
argument_list|(
name|pdev
operator|->
name|si_devsw
argument_list|,
name|dkmakeminor
argument_list|(
name|u
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"%s%ds%d"
argument_list|,
name|dp
operator|->
name|d_devsw
operator|->
name|d_name
argument_list|,
name|u
argument_list|,
name|s
operator|-
name|BASE_SLICE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|make_dev_alias
argument_list|(
name|dev
argument_list|,
literal|"%s%ds%dc"
argument_list|,
name|dp
operator|->
name|d_devsw
operator|->
name|d_name
argument_list|,
name|u
argument_list|,
name|s
operator|-
name|BASE_SLICE
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|dev_depends
argument_list|(
name|pdev
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|disk_clone
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|dev_t
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|disk
modifier|*
name|dp
decl_stmt|;
name|char
specifier|const
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
name|int
name|j
decl_stmt|,
name|u
decl_stmt|,
name|s
decl_stmt|,
name|p
decl_stmt|;
name|dev_t
name|pdev
decl_stmt|;
if|if
condition|(
operator|*
name|dev
operator|!=
name|NODEV
condition|)
return|return;
name|LIST_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|&disklist
argument_list|,
argument|d_list
argument_list|)
block|{
name|d
operator|=
name|dp
operator|->
name|d_devsw
operator|->
name|d_name
expr_stmt|;
name|j
operator|=
name|dev_stdclone
argument_list|(
name|name
argument_list|,
operator|&
name|e
argument_list|,
name|d
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|u
operator|>
name|DKMAXUNIT
condition|)
continue|continue;
name|p
operator|=
name|RAW_PART
expr_stmt|;
name|s
operator|=
name|WHOLE_DISK_SLICE
expr_stmt|;
name|pdev
operator|=
name|makedev
argument_list|(
name|dp
operator|->
name|d_devsw
operator|->
name|d_maj
argument_list|,
name|dkmakeminor
argument_list|(
name|u
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdev
operator|->
name|si_disk
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|*
name|e
operator|!=
literal|'\0'
condition|)
block|{
name|j
operator|=
name|dev_stdclone
argument_list|(
name|e
argument_list|,
operator|&
name|e
argument_list|,
literal|"s"
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|s
operator|=
name|COMPATIBILITY_SLICE
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|==
literal|1
operator|||
name|j
operator|==
literal|2
condition|)
name|s
operator|+=
name|BASE_SLICE
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|e
condition|)
empty_stmt|;
comment|/* ad0s1 case */
elseif|else
if|if
condition|(
name|e
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return;
comment|/* can never be a disk name */
elseif|else
if|if
condition|(
operator|*
name|e
operator|<
literal|'a'
operator|||
operator|*
name|e
operator|>
literal|'h'
condition|)
return|return;
comment|/* can never be a disk name */
else|else
name|p
operator|=
operator|*
name|e
operator|-
literal|'a'
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
name|WHOLE_DISK_SLICE
operator|&&
name|p
operator|==
name|RAW_PART
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|s
operator|>=
name|BASE_SLICE
operator|&&
name|p
operator|!=
name|RAW_PART
condition|)
block|{
operator|*
name|dev
operator|=
name|make_dev
argument_list|(
name|pdev
operator|->
name|si_devsw
argument_list|,
name|dkmakeminor
argument_list|(
name|u
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"%s%ds%d%c"
argument_list|,
name|pdev
operator|->
name|si_devsw
operator|->
name|d_name
argument_list|,
name|u
argument_list|,
name|s
operator|-
name|BASE_SLICE
operator|+
literal|1
argument_list|,
name|p
operator|+
literal|'a'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|>=
name|BASE_SLICE
condition|)
block|{
operator|*
name|dev
operator|=
name|make_dev
argument_list|(
name|pdev
operator|->
name|si_devsw
argument_list|,
name|dkmakeminor
argument_list|(
name|u
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"%s%ds%d"
argument_list|,
name|pdev
operator|->
name|si_devsw
operator|->
name|d_name
argument_list|,
name|u
argument_list|,
name|s
operator|-
name|BASE_SLICE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|make_dev_alias
argument_list|(
operator|*
name|dev
argument_list|,
literal|"%s%ds%dc"
argument_list|,
name|pdev
operator|->
name|si_devsw
operator|->
name|d_name
argument_list|,
name|u
argument_list|,
name|s
operator|-
name|BASE_SLICE
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dev
operator|=
name|make_dev
argument_list|(
name|pdev
operator|->
name|si_devsw
argument_list|,
name|dkmakeminor
argument_list|(
name|u
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"%s%d%c"
argument_list|,
name|pdev
operator|->
name|si_devsw
operator|->
name|d_name
argument_list|,
name|u
argument_list|,
name|p
operator|+
literal|'a'
argument_list|)
expr_stmt|;
block|}
name|dev_depends
argument_list|(
name|pdev
argument_list|,
operator|*
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|inherit_raw
parameter_list|(
name|dev_t
name|pdev
parameter_list|,
name|dev_t
name|dev
parameter_list|)
block|{
name|dev
operator|->
name|si_disk
operator|=
name|pdev
operator|->
name|si_disk
expr_stmt|;
name|dev
operator|->
name|si_drv1
operator|=
name|pdev
operator|->
name|si_drv1
expr_stmt|;
name|dev
operator|->
name|si_drv2
operator|=
name|pdev
operator|->
name|si_drv2
expr_stmt|;
name|dev
operator|->
name|si_iosize_max
operator|=
name|pdev
operator|->
name|si_iosize_max
expr_stmt|;
name|dev
operator|->
name|si_bsize_phys
operator|=
name|pdev
operator|->
name|si_bsize_phys
expr_stmt|;
name|dev
operator|->
name|si_bsize_best
operator|=
name|pdev
operator|->
name|si_bsize_best
expr_stmt|;
block|}
end_function

begin_function
name|dev_t
name|disk_create
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|disk
modifier|*
name|dp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|cdevsw
modifier|*
name|cdevsw
parameter_list|,
name|struct
name|cdevsw
modifier|*
name|proto
parameter_list|)
block|{
specifier|static
name|int
name|once
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|once
condition|)
block|{
name|EVENTHANDLER_REGISTER
argument_list|(
name|dev_clone
argument_list|,
name|disk_clone
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|once
operator|++
expr_stmt|;
block|}
name|bzero
argument_list|(
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_label
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|dp
operator|->
name|d_label
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|->
name|d_open
operator|!=
name|diskopen
condition|)
block|{
operator|*
name|proto
operator|=
operator|*
name|cdevsw
expr_stmt|;
name|proto
operator|->
name|d_open
operator|=
name|diskopen
expr_stmt|;
name|proto
operator|->
name|d_close
operator|=
name|diskclose
expr_stmt|;
name|proto
operator|->
name|d_ioctl
operator|=
name|diskioctl
expr_stmt|;
name|proto
operator|->
name|d_strategy
operator|=
name|diskstrategy
expr_stmt|;
name|proto
operator|->
name|d_psize
operator|=
name|diskpsize
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Creating DISK %s%d\n"
argument_list|,
name|cdevsw
operator|->
name|d_name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|dev
operator|=
name|make_dev
argument_list|(
name|proto
argument_list|,
name|dkmakeminor
argument_list|(
name|unit
argument_list|,
name|WHOLE_DISK_SLICE
argument_list|,
name|RAW_PART
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"%s%d"
argument_list|,
name|cdevsw
operator|->
name|d_name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|dev
operator|->
name|si_disk
operator|=
name|dp
expr_stmt|;
name|dp
operator|->
name|d_dev
operator|=
name|dev
expr_stmt|;
name|dp
operator|->
name|d_dsflags
operator|=
name|flags
expr_stmt|;
name|dp
operator|->
name|d_devsw
operator|=
name|cdevsw
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|disklist
argument_list|,
name|dp
argument_list|,
name|d_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|dev
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|diskdumpconf
parameter_list|(
name|u_int
name|onoff
parameter_list|,
name|dev_t
name|dev
parameter_list|,
name|struct
name|disk
modifier|*
name|dp
parameter_list|)
block|{
name|struct
name|dumperinfo
name|di
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|dl
decl_stmt|;
if|if
condition|(
operator|!
name|onoff
condition|)
return|return
operator|(
name|set_dumper
argument_list|(
name|NULL
argument_list|)
operator|)
return|;
name|dl
operator|=
name|dsgetlabel
argument_list|(
name|dev
argument_list|,
name|dp
operator|->
name|d_slice
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dl
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|di
argument_list|,
sizeof|sizeof
name|di
argument_list|)
expr_stmt|;
name|di
operator|.
name|dumper
operator|=
operator|(
name|dumper_t
operator|*
operator|)
name|dp
operator|->
name|d_devsw
operator|->
name|d_dump
expr_stmt|;
name|di
operator|.
name|priv
operator|=
name|dp
operator|->
name|d_dev
expr_stmt|;
name|di
operator|.
name|blocksize
operator|=
name|dl
operator|->
name|d_secsize
expr_stmt|;
name|di
operator|.
name|mediaoffset
operator|=
call|(
name|off_t
call|)
argument_list|(
name|dl
operator|->
name|d_partitions
index|[
name|dkpart
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|p_offset
operator|+
name|dp
operator|->
name|d_slice
operator|->
name|dss_slices
index|[
name|dkslice
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|ds_offset
argument_list|)
operator|*
name|DEV_BSIZE
expr_stmt|;
name|di
operator|.
name|mediasize
operator|=
call|(
name|off_t
call|)
argument_list|(
name|dl
operator|->
name|d_partitions
index|[
name|dkpart
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|p_size
argument_list|)
operator|*
name|DEV_BSIZE
expr_stmt|;
if|if
condition|(
name|di
operator|.
name|mediasize
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|set_dumper
argument_list|(
operator|&
name|di
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|disk_invalidate
parameter_list|(
name|struct
name|disk
modifier|*
name|disk
parameter_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_slice
condition|)
name|dsgone
argument_list|(
operator|&
name|disk
operator|->
name|d_slice
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|disk_destroy
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|dev
operator|->
name|si_disk
argument_list|,
name|d_list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dev
operator|->
name|si_disk
operator|->
name|d_label
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dev
operator|->
name|si_disk
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dev
operator|->
name|si_disk
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|si_disk
operator|=
name|NULL
expr_stmt|;
name|destroy_dev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|struct
name|disk
modifier|*
name|disk_enumerate
parameter_list|(
name|struct
name|disk
modifier|*
name|disk
parameter_list|)
block|{
if|if
condition|(
operator|!
name|disk
condition|)
return|return
operator|(
name|LIST_FIRST
argument_list|(
operator|&
name|disklist
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|LIST_NEXT
argument_list|(
name|disk
argument_list|,
name|d_list
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_disks
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|disk
modifier|*
name|disk
decl_stmt|;
name|int
name|error
decl_stmt|,
name|first
decl_stmt|;
name|disk
operator|=
name|NULL
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|disk
operator|=
name|disk_enumerate
argument_list|(
name|disk
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
block|{
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
else|else
block|{
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|disk
operator|->
name|d_dev
operator|->
name|si_name
argument_list|,
name|strlen
argument_list|(
name|disk
operator|->
name|d_dev
operator|->
name|si_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|disks
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_disks
argument_list|,
literal|"A"
argument_list|,
literal|"names of available disks"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The cdevsw functions  */
end_comment

begin_function
specifier|static
name|int
name|diskopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|dev_t
name|pdev
decl_stmt|;
name|struct
name|disk
modifier|*
name|dp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|pdev
operator|=
name|dkmodpart
argument_list|(
name|dkmodslice
argument_list|(
name|dev
argument_list|,
name|WHOLE_DISK_SLICE
argument_list|)
argument_list|,
name|RAW_PART
argument_list|)
expr_stmt|;
name|dp
operator|=
name|pdev
operator|->
name|si_disk
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
while|while
condition|(
name|dp
operator|->
name|d_flags
operator|&
name|DISKFLAG_LOCK
condition|)
block|{
name|dp
operator|->
name|d_flags
operator||=
name|DISKFLAG_WANTED
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|dp
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"diskopen"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dp
operator|->
name|d_flags
operator||=
name|DISKFLAG_LOCK
expr_stmt|;
if|if
condition|(
operator|!
name|dsisopen
argument_list|(
name|dp
operator|->
name|d_slice
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|pdev
operator|->
name|si_iosize_max
condition|)
name|pdev
operator|->
name|si_iosize_max
operator|=
name|dev
operator|->
name|si_iosize_max
expr_stmt|;
name|error
operator|=
name|dp
operator|->
name|d_devsw
operator|->
name|d_open
argument_list|(
name|pdev
argument_list|,
name|oflags
argument_list|,
name|devtype
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_label
operator|->
name|d_secsize
operator|=
name|dp
operator|->
name|d_sectorsize
expr_stmt|;
name|dp
operator|->
name|d_label
operator|->
name|d_secperunit
operator|=
name|dp
operator|->
name|d_mediasize
operator|/
name|dp
operator|->
name|d_sectorsize
expr_stmt|;
name|dp
operator|->
name|d_label
operator|->
name|d_nsectors
operator|=
name|dp
operator|->
name|d_fwsectors
expr_stmt|;
name|dp
operator|->
name|d_label
operator|->
name|d_ntracks
operator|=
name|dp
operator|->
name|d_fwheads
expr_stmt|;
block|}
comment|/* Inherit properties from the whole/raw dev_t */
name|inherit_raw
argument_list|(
name|pdev
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|dsopen
argument_list|(
name|dev
argument_list|,
name|devtype
argument_list|,
name|dp
operator|->
name|d_dsflags
argument_list|,
operator|&
name|dp
operator|->
name|d_slice
argument_list|,
name|dp
operator|->
name|d_label
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dsisopen
argument_list|(
name|dp
operator|->
name|d_slice
argument_list|)
condition|)
name|dp
operator|->
name|d_devsw
operator|->
name|d_close
argument_list|(
name|pdev
argument_list|,
name|oflags
argument_list|,
name|devtype
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|out
label|:
name|dp
operator|->
name|d_flags
operator|&=
operator|~
name|DISKFLAG_LOCK
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_flags
operator|&
name|DISKFLAG_WANTED
condition|)
block|{
name|dp
operator|->
name|d_flags
operator|&=
operator|~
name|DISKFLAG_WANTED
expr_stmt|;
name|wakeup
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|diskclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|disk
modifier|*
name|dp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dev_t
name|pdev
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|pdev
operator|=
name|dkmodpart
argument_list|(
name|dkmodslice
argument_list|(
name|dev
argument_list|,
name|WHOLE_DISK_SLICE
argument_list|)
argument_list|,
name|RAW_PART
argument_list|)
expr_stmt|;
name|dp
operator|=
name|pdev
operator|->
name|si_disk
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|dsclose
argument_list|(
name|dev
argument_list|,
name|devtype
argument_list|,
name|dp
operator|->
name|d_slice
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dsisopen
argument_list|(
name|dp
operator|->
name|d_slice
argument_list|)
condition|)
name|error
operator|=
name|dp
operator|->
name|d_devsw
operator|->
name|d_close
argument_list|(
name|dp
operator|->
name|d_dev
argument_list|,
name|fflag
argument_list|,
name|devtype
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|diskstrategy
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|dev_t
name|pdev
decl_stmt|;
name|struct
name|disk
modifier|*
name|dp
decl_stmt|;
name|pdev
operator|=
name|dkmodpart
argument_list|(
name|dkmodslice
argument_list|(
name|bp
operator|->
name|bio_dev
argument_list|,
name|WHOLE_DISK_SLICE
argument_list|)
argument_list|,
name|RAW_PART
argument_list|)
expr_stmt|;
name|dp
operator|=
name|pdev
operator|->
name|si_disk
expr_stmt|;
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|bp
operator|->
name|bio_dev
operator|->
name|si_disk
condition|)
name|inherit_raw
argument_list|(
name|pdev
argument_list|,
name|bp
operator|->
name|bio_dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
block|{
name|biofinish
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dscheck
argument_list|(
name|bp
argument_list|,
name|dp
operator|->
name|d_slice
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bp
operator|->
name|bio_bcount
operator|==
literal|0
condition|)
block|{
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|dp
operator|->
name|d_devsw
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL devsw"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|dp
operator|->
name|d_devsw
operator|->
name|d_strategy
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL d_strategy"
operator|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_devsw
operator|->
name|d_strategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|diskioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|disk
modifier|*
name|dp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|u
decl_stmt|;
name|dev_t
name|pdev
decl_stmt|;
name|pdev
operator|=
name|dkmodpart
argument_list|(
name|dkmodslice
argument_list|(
name|dev
argument_list|,
name|WHOLE_DISK_SLICE
argument_list|)
argument_list|,
name|RAW_PART
argument_list|)
expr_stmt|;
name|dp
operator|=
name|pdev
operator|->
name|si_disk
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|cmd
operator|==
name|DIOCSKERNELDUMP
condition|)
block|{
name|u
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
expr_stmt|;
return|return
operator|(
name|diskdumpconf
argument_list|(
name|u
argument_list|,
name|dev
argument_list|,
name|dp
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|cmd
operator|==
name|DIOCGFRONTSTUFF
condition|)
block|{
operator|*
operator|(
name|off_t
operator|*
operator|)
name|data
operator|=
literal|8192
expr_stmt|;
comment|/* XXX: crude but enough) */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
name|dsioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|fflag
argument_list|,
operator|&
name|dp
operator|->
name|d_slice
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
name|error
operator|=
name|dp
operator|->
name|d_devsw
operator|->
name|d_ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|fflag
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|diskpsize
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|struct
name|disk
modifier|*
name|dp
decl_stmt|;
name|dev_t
name|pdev
decl_stmt|;
name|pdev
operator|=
name|dkmodpart
argument_list|(
name|dkmodslice
argument_list|(
name|dev
argument_list|,
name|WHOLE_DISK_SLICE
argument_list|)
argument_list|,
name|RAW_PART
argument_list|)
expr_stmt|;
name|dp
operator|=
name|pdev
operator|->
name|si_disk
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|dp
operator|!=
name|dev
operator|->
name|si_disk
condition|)
block|{
name|dev
operator|->
name|si_drv1
operator|=
name|pdev
operator|->
name|si_drv1
expr_stmt|;
name|dev
operator|->
name|si_drv2
operator|=
name|pdev
operator|->
name|si_drv2
expr_stmt|;
comment|/* XXX: don't set bp->b_dev->si_disk (?) */
block|}
return|return
operator|(
name|dssize
argument_list|(
name|dev
argument_list|,
operator|&
name|dp
operator|->
name|d_slice
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_sizeof
argument_list|,
name|OID_AUTO
argument_list|,
name|disklabel
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|disklabel
argument_list|)
argument_list|,
literal|"sizeof(struct disklabel)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_sizeof
argument_list|,
name|OID_AUTO
argument_list|,
name|diskslices
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|diskslices
argument_list|)
argument_list|,
literal|"sizeof(struct diskslices)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_sizeof
argument_list|,
name|OID_AUTO
argument_list|,
name|disk
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|disk
argument_list|)
argument_list|,
literal|"sizeof(struct disk)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_GEOM */
end_comment

begin_comment
comment|/*-  * Disk error is the preface to plaintive error messages  * about failing disk transfers.  It prints messages of the form  * 	"hp0g: BLABLABLA cmd=read fsbn 12345 of 12344-12347"  * blkdone should be -1 if the position of the error is unknown.  * The message is printed with printf.  */
end_comment

begin_function
name|void
name|disk_err
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|int
name|blkdone
parameter_list|,
name|int
name|nl
parameter_list|)
block|{
name|daddr_t
name|sn
decl_stmt|;
name|printf
argument_list|(
literal|"%s: %s "
argument_list|,
name|devtoname
argument_list|(
name|bp
operator|->
name|bio_dev
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
name|printf
argument_list|(
literal|"cmd=read "
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_WRITE
case|:
name|printf
argument_list|(
literal|"cmd=write "
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_DELETE
case|:
name|printf
argument_list|(
literal|"cmd=delete "
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_GETATTR
case|:
name|printf
argument_list|(
literal|"cmd=getattr "
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_SETATTR
case|:
name|printf
argument_list|(
literal|"cmd=setattr "
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"cmd=%x "
argument_list|,
name|bp
operator|->
name|bio_cmd
argument_list|)
expr_stmt|;
break|break;
block|}
name|sn
operator|=
name|bp
operator|->
name|bio_blkno
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_bcount
operator|<=
name|DEV_BSIZE
condition|)
block|{
name|printf
argument_list|(
literal|"fsbn %jd%s"
argument_list|,
operator|(
name|intmax_t
operator|)
name|sn
argument_list|,
name|nl
condition|?
literal|"\n"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|blkdone
operator|>=
literal|0
condition|)
block|{
name|sn
operator|+=
name|blkdone
expr_stmt|;
name|printf
argument_list|(
literal|"fsbn %jd of "
argument_list|,
operator|(
name|intmax_t
operator|)
name|sn
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%jd-%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|bp
operator|->
name|bio_blkno
argument_list|,
call|(
name|intmax_t
call|)
argument_list|(
name|bp
operator|->
name|bio_blkno
operator|+
operator|(
name|bp
operator|->
name|bio_bcount
operator|-
literal|1
operator|)
operator|/
name|DEV_BSIZE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notquite
end_ifdef

begin_comment
comment|/*  * Mutex to use when delaying niced I/O bound processes in bioq_disksort().  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|dksort_mtx
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dksort_init
parameter_list|(
name|void
parameter_list|)
block|{
name|mtx_init
argument_list|(
operator|&
name|dksort_mtx
argument_list|,
literal|"dksort"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|dksort
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE
argument_list|,
argument|dksort_init
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Seek sort for disks.  *  * The buf_queue keep two queues, sorted in ascending block order.  The first  * queue holds those requests which are positioned after the current block  * (in the first request); the second, which starts at queue->switch_point,  * holds requests which came in after their block number was passed.  Thus  * we implement a one way scan, retracting after reaching the end of the drive  * to the first request on the second queue, at which time it becomes the  * first queue.  *  * A one-way scan is natural because of the way UNIX read-ahead blocks are  * allocated.  */
end_comment

begin_function
name|void
name|bioq_disksort
parameter_list|(
name|bioq
parameter_list|,
name|bp
parameter_list|)
name|struct
name|bio_queue_head
modifier|*
name|bioq
decl_stmt|;
name|struct
name|bio
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|bio
modifier|*
name|bq
decl_stmt|;
name|struct
name|bio
modifier|*
name|bn
decl_stmt|;
name|struct
name|bio
modifier|*
name|be
decl_stmt|;
ifdef|#
directive|ifdef
name|notquite
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
if|if
condition|(
name|td
operator|&&
name|td
operator|->
name|td_ksegrp
operator|->
name|kg_nice
operator|>
literal|0
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|bn
argument_list|,
argument|&bioq->queue
argument_list|,
argument|bio_queue
argument_list|)
if|if
condition|(
name|BIOTOBUF
argument_list|(
name|bp
argument_list|)
operator|->
name|b_vp
operator|!=
name|BIOTOBUF
argument_list|(
name|bn
argument_list|)
operator|->
name|b_vp
condition|)
break|break;
if|if
condition|(
name|bn
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|dksort_mtx
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|dksort_mtx
argument_list|,
operator|&
name|dksort_mtx
argument_list|,
name|PPAUSE
operator||
name|PCATCH
operator||
name|PDROP
argument_list|,
literal|"ioslow"
argument_list|,
name|td
operator|->
name|td_ksegrp
operator|->
name|kg_nice
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|atomic_cmpset_int
argument_list|(
operator|&
name|bioq
operator|->
name|busy
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Recursing in bioq_disksort()"
argument_list|)
expr_stmt|;
name|be
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|bioq
operator|->
name|queue
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
comment|/* 	 * If the queue is empty or we are an 	 * ordered transaction, then it's easy. 	 */
if|if
condition|(
operator|(
name|bq
operator|=
name|bioq_first
argument_list|(
name|bioq
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bioq_insert_tail
argument_list|(
name|bioq
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bioq
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|bioq
operator|->
name|insert_point
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * A certain portion of the list is 		 * "locked" to preserve ordering, so 		 * we can only insert after the insert 		 * point. 		 */
name|bq
operator|=
name|bioq
operator|->
name|insert_point
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If we lie before the last removed (currently active) 		 * request, and are not inserting ourselves into the 		 * "locked" portion of the list, then we must add ourselves 		 * to the second request list. 		 */
if|if
condition|(
name|bp
operator|->
name|bio_pblkno
operator|<
name|bioq
operator|->
name|last_pblkno
condition|)
block|{
name|bq
operator|=
name|bioq
operator|->
name|switch_point
expr_stmt|;
comment|/* 			 * If we are starting a new secondary list, 			 * then it's easy. 			 */
if|if
condition|(
name|bq
operator|==
name|NULL
condition|)
block|{
name|bioq
operator|->
name|switch_point
operator|=
name|bp
expr_stmt|;
name|bioq_insert_tail
argument_list|(
name|bioq
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bioq
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 			 * If we lie ahead of the current switch point, 			 * insert us before the switch point and move 			 * the switch point. 			 */
if|if
condition|(
name|bp
operator|->
name|bio_pblkno
operator|<
name|bq
operator|->
name|bio_pblkno
condition|)
block|{
name|bioq
operator|->
name|switch_point
operator|=
name|bp
expr_stmt|;
name|TAILQ_INSERT_BEFORE
argument_list|(
name|bq
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
name|bioq
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
name|bioq
operator|->
name|switch_point
operator|!=
name|NULL
condition|)
name|be
operator|=
name|TAILQ_PREV
argument_list|(
name|bioq
operator|->
name|switch_point
argument_list|,
name|bio_queue
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
comment|/* 			 * If we lie between last_pblkno and bq, 			 * insert before bq. 			 */
if|if
condition|(
name|bp
operator|->
name|bio_pblkno
operator|<
name|bq
operator|->
name|bio_pblkno
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|bq
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
name|bioq
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|/* 	 * Request is at/after our current position in the list. 	 * Optimize for sequential I/O by seeing if we go at the tail. 	 */
if|if
condition|(
name|bp
operator|->
name|bio_pblkno
operator|>
name|be
operator|->
name|bio_pblkno
condition|)
block|{
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|bioq
operator|->
name|queue
argument_list|,
name|be
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
name|bioq
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, insertion sort */
while|while
condition|(
operator|(
name|bn
operator|=
name|TAILQ_NEXT
argument_list|(
name|bq
argument_list|,
name|bio_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We want to go after the current request if it is the end 		 * of the first request list, or if the next request is a 		 * larger cylinder than our request. 		 */
if|if
condition|(
name|bn
operator|==
name|bioq
operator|->
name|switch_point
operator|||
name|bp
operator|->
name|bio_pblkno
operator|<
name|bn
operator|->
name|bio_pblkno
condition|)
break|break;
name|bq
operator|=
name|bn
expr_stmt|;
block|}
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|bioq
operator|->
name|queue
argument_list|,
name|bq
argument_list|,
name|bp
argument_list|,
name|bio_queue
argument_list|)
expr_stmt|;
name|bioq
operator|->
name|busy
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

