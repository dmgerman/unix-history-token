begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@FreeBSD.ORG> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|"opt_geom.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/disk.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|GEOM
end_ifndef

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_DISK
argument_list|,
literal|"disk"
argument_list|,
literal|"disk data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|d_strategy_t
name|diskstrategy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|diskopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|diskclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|diskioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_psize_t
name|diskpsize
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|disk
argument_list|)
name|disklist
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
operator|&
name|disklist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
name|void
name|disk_dev_synth
parameter_list|(
name|dev_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|disk_dev_synth
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|struct
name|disk
modifier|*
name|dp
decl_stmt|;
name|int
name|u
decl_stmt|,
name|s
decl_stmt|,
name|p
decl_stmt|;
name|dev_t
name|pdev
decl_stmt|;
if|if
condition|(
name|dksparebits
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
name|LIST_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|&disklist
argument_list|,
argument|d_list
argument_list|)
block|{
if|if
condition|(
name|major
argument_list|(
name|dev
argument_list|)
operator|!=
name|dp
operator|->
name|d_devsw
operator|->
name|d_maj
condition|)
continue|continue;
name|u
operator|=
name|dkunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|p
operator|=
name|RAW_PART
expr_stmt|;
name|s
operator|=
name|WHOLE_DISK_SLICE
expr_stmt|;
name|pdev
operator|=
name|makedev
argument_list|(
name|dp
operator|->
name|d_devsw
operator|->
name|d_maj
argument_list|,
name|dkmakeminor
argument_list|(
name|u
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdev
operator|->
name|si_devsw
operator|==
name|NULL
condition|)
return|return;
comment|/* Probably a unit we don't have */
name|s
operator|=
name|dkslice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|p
operator|=
name|dkpart
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|WHOLE_DISK_SLICE
operator|&&
name|p
operator|==
name|RAW_PART
condition|)
block|{
comment|/* XXX: actually should not happen */
name|dev
operator|=
name|make_dev
argument_list|(
name|pdev
operator|->
name|si_devsw
argument_list|,
name|dkmakeminor
argument_list|(
name|u
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"%s%d"
argument_list|,
name|dp
operator|->
name|d_devsw
operator|->
name|d_name
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|dev_depends
argument_list|(
name|pdev
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|s
operator|==
name|COMPATIBILITY_SLICE
condition|)
block|{
name|dev
operator|=
name|make_dev
argument_list|(
name|pdev
operator|->
name|si_devsw
argument_list|,
name|dkmakeminor
argument_list|(
name|u
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"%s%d%c"
argument_list|,
name|dp
operator|->
name|d_devsw
operator|->
name|d_name
argument_list|,
name|u
argument_list|,
literal|'a'
operator|+
name|p
argument_list|)
expr_stmt|;
name|dev_depends
argument_list|(
name|pdev
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|!=
name|RAW_PART
condition|)
block|{
name|dev
operator|=
name|make_dev
argument_list|(
name|pdev
operator|->
name|si_devsw
argument_list|,
name|dkmakeminor
argument_list|(
name|u
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"%s%ds%d%c"
argument_list|,
name|dp
operator|->
name|d_devsw
operator|->
name|d_name
argument_list|,
name|u
argument_list|,
name|s
operator|-
name|BASE_SLICE
operator|+
literal|1
argument_list|,
literal|'a'
operator|+
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|=
name|make_dev
argument_list|(
name|pdev
operator|->
name|si_devsw
argument_list|,
name|dkmakeminor
argument_list|(
name|u
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"%s%ds%d"
argument_list|,
name|dp
operator|->
name|d_devsw
operator|->
name|d_name
argument_list|,
name|u
argument_list|,
name|s
operator|-
name|BASE_SLICE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|make_dev_alias
argument_list|(
name|dev
argument_list|,
literal|"%s%ds%dc"
argument_list|,
name|dp
operator|->
name|d_devsw
operator|->
name|d_name
argument_list|,
name|u
argument_list|,
name|s
operator|-
name|BASE_SLICE
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|dev_depends
argument_list|(
name|pdev
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|disk_clone
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|dev_t
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|disk
modifier|*
name|dp
decl_stmt|;
name|char
specifier|const
modifier|*
name|d
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
name|int
name|j
decl_stmt|,
name|u
decl_stmt|,
name|s
decl_stmt|,
name|p
decl_stmt|;
name|dev_t
name|pdev
decl_stmt|;
if|if
condition|(
operator|*
name|dev
operator|!=
name|NODEV
condition|)
return|return;
name|LIST_FOREACH
argument_list|(
argument|dp
argument_list|,
argument|&disklist
argument_list|,
argument|d_list
argument_list|)
block|{
name|d
operator|=
name|dp
operator|->
name|d_devsw
operator|->
name|d_name
expr_stmt|;
name|j
operator|=
name|dev_stdclone
argument_list|(
name|name
argument_list|,
operator|&
name|e
argument_list|,
name|d
argument_list|,
operator|&
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|u
operator|>
name|DKMAXUNIT
condition|)
continue|continue;
name|p
operator|=
name|RAW_PART
expr_stmt|;
name|s
operator|=
name|WHOLE_DISK_SLICE
expr_stmt|;
name|pdev
operator|=
name|makedev
argument_list|(
name|dp
operator|->
name|d_devsw
operator|->
name|d_maj
argument_list|,
name|dkmakeminor
argument_list|(
name|u
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdev
operator|->
name|si_disk
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|*
name|e
operator|!=
literal|'\0'
condition|)
block|{
name|j
operator|=
name|dev_stdclone
argument_list|(
name|e
argument_list|,
operator|&
name|e
argument_list|,
literal|"s"
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
condition|)
name|s
operator|=
name|COMPATIBILITY_SLICE
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|==
literal|1
operator|||
name|j
operator|==
literal|2
condition|)
name|s
operator|+=
name|BASE_SLICE
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|e
condition|)
empty_stmt|;
comment|/* ad0s1 case */
elseif|else
if|if
condition|(
name|e
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
return|return;
comment|/* can never be a disk name */
elseif|else
if|if
condition|(
operator|*
name|e
operator|<
literal|'a'
operator|||
operator|*
name|e
operator|>
literal|'h'
condition|)
return|return;
comment|/* can never be a disk name */
else|else
name|p
operator|=
operator|*
name|e
operator|-
literal|'a'
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
name|WHOLE_DISK_SLICE
operator|&&
name|p
operator|==
name|RAW_PART
condition|)
block|{
return|return;
block|}
elseif|else
if|if
condition|(
name|s
operator|>=
name|BASE_SLICE
operator|&&
name|p
operator|!=
name|RAW_PART
condition|)
block|{
operator|*
name|dev
operator|=
name|make_dev
argument_list|(
name|pdev
operator|->
name|si_devsw
argument_list|,
name|dkmakeminor
argument_list|(
name|u
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"%s%ds%d%c"
argument_list|,
name|pdev
operator|->
name|si_devsw
operator|->
name|d_name
argument_list|,
name|u
argument_list|,
name|s
operator|-
name|BASE_SLICE
operator|+
literal|1
argument_list|,
name|p
operator|+
literal|'a'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|>=
name|BASE_SLICE
condition|)
block|{
operator|*
name|dev
operator|=
name|make_dev
argument_list|(
name|pdev
operator|->
name|si_devsw
argument_list|,
name|dkmakeminor
argument_list|(
name|u
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"%s%ds%d"
argument_list|,
name|pdev
operator|->
name|si_devsw
operator|->
name|d_name
argument_list|,
name|u
argument_list|,
name|s
operator|-
name|BASE_SLICE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|make_dev_alias
argument_list|(
operator|*
name|dev
argument_list|,
literal|"%s%ds%dc"
argument_list|,
name|pdev
operator|->
name|si_devsw
operator|->
name|d_name
argument_list|,
name|u
argument_list|,
name|s
operator|-
name|BASE_SLICE
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dev
operator|=
name|make_dev
argument_list|(
name|pdev
operator|->
name|si_devsw
argument_list|,
name|dkmakeminor
argument_list|(
name|u
argument_list|,
name|s
argument_list|,
name|p
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"%s%d%c"
argument_list|,
name|pdev
operator|->
name|si_devsw
operator|->
name|d_name
argument_list|,
name|u
argument_list|,
name|p
operator|+
literal|'a'
argument_list|)
expr_stmt|;
block|}
name|dev_depends
argument_list|(
name|pdev
argument_list|,
operator|*
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|inherit_raw
parameter_list|(
name|dev_t
name|pdev
parameter_list|,
name|dev_t
name|dev
parameter_list|)
block|{
name|dev
operator|->
name|si_disk
operator|=
name|pdev
operator|->
name|si_disk
expr_stmt|;
name|dev
operator|->
name|si_drv1
operator|=
name|pdev
operator|->
name|si_drv1
expr_stmt|;
name|dev
operator|->
name|si_drv2
operator|=
name|pdev
operator|->
name|si_drv2
expr_stmt|;
name|dev
operator|->
name|si_iosize_max
operator|=
name|pdev
operator|->
name|si_iosize_max
expr_stmt|;
name|dev
operator|->
name|si_bsize_phys
operator|=
name|pdev
operator|->
name|si_bsize_phys
expr_stmt|;
name|dev
operator|->
name|si_bsize_best
operator|=
name|pdev
operator|->
name|si_bsize_best
expr_stmt|;
block|}
end_function

begin_function
name|dev_t
name|disk_create
parameter_list|(
name|int
name|unit
parameter_list|,
name|struct
name|disk
modifier|*
name|dp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|cdevsw
modifier|*
name|cdevsw
parameter_list|,
name|struct
name|cdevsw
modifier|*
name|proto
parameter_list|)
block|{
specifier|static
name|int
name|once
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|once
condition|)
block|{
name|EVENTHANDLER_REGISTER
argument_list|(
name|dev_clone
argument_list|,
name|disk_clone
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|once
operator|++
expr_stmt|;
block|}
name|bzero
argument_list|(
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto
operator|->
name|d_open
operator|!=
name|diskopen
condition|)
block|{
operator|*
name|proto
operator|=
operator|*
name|cdevsw
expr_stmt|;
name|proto
operator|->
name|d_open
operator|=
name|diskopen
expr_stmt|;
name|proto
operator|->
name|d_close
operator|=
name|diskclose
expr_stmt|;
name|proto
operator|->
name|d_ioctl
operator|=
name|diskioctl
expr_stmt|;
name|proto
operator|->
name|d_strategy
operator|=
name|diskstrategy
expr_stmt|;
name|proto
operator|->
name|d_psize
operator|=
name|diskpsize
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Creating DISK %s%d\n"
argument_list|,
name|cdevsw
operator|->
name|d_name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|dev
operator|=
name|make_dev
argument_list|(
name|proto
argument_list|,
name|dkmakeminor
argument_list|(
name|unit
argument_list|,
name|WHOLE_DISK_SLICE
argument_list|,
name|RAW_PART
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"%s%d"
argument_list|,
name|cdevsw
operator|->
name|d_name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|dev
operator|->
name|si_disk
operator|=
name|dp
expr_stmt|;
name|dp
operator|->
name|d_dev
operator|=
name|dev
expr_stmt|;
name|dp
operator|->
name|d_dsflags
operator|=
name|flags
expr_stmt|;
name|dp
operator|->
name|d_devsw
operator|=
name|cdevsw
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|disklist
argument_list|,
name|dp
argument_list|,
name|d_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|dev
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|diskdumpconf
parameter_list|(
name|u_int
name|onoff
parameter_list|,
name|dev_t
name|dev
parameter_list|,
name|struct
name|disk
modifier|*
name|dp
parameter_list|)
block|{
name|struct
name|dumperinfo
name|di
decl_stmt|;
name|struct
name|disklabel
modifier|*
name|dl
decl_stmt|;
if|if
condition|(
operator|!
name|onoff
condition|)
return|return
operator|(
name|set_dumper
argument_list|(
name|NULL
argument_list|)
operator|)
return|;
name|dl
operator|=
name|dsgetlabel
argument_list|(
name|dev
argument_list|,
name|dp
operator|->
name|d_slice
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dl
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|di
argument_list|,
sizeof|sizeof
name|di
argument_list|)
expr_stmt|;
name|di
operator|.
name|dumper
operator|=
operator|(
name|dumper_t
operator|*
operator|)
name|dp
operator|->
name|d_devsw
operator|->
name|d_dump
expr_stmt|;
name|di
operator|.
name|priv
operator|=
name|dp
operator|->
name|d_dev
expr_stmt|;
name|di
operator|.
name|blocksize
operator|=
name|dl
operator|->
name|d_secsize
expr_stmt|;
name|di
operator|.
name|mediaoffset
operator|=
call|(
name|off_t
call|)
argument_list|(
name|dl
operator|->
name|d_partitions
index|[
name|dkpart
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|p_offset
operator|+
name|dp
operator|->
name|d_slice
operator|->
name|dss_slices
index|[
name|dkslice
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|ds_offset
argument_list|)
operator|*
name|DEV_BSIZE
expr_stmt|;
name|di
operator|.
name|mediasize
operator|=
call|(
name|off_t
call|)
argument_list|(
name|dl
operator|->
name|d_partitions
index|[
name|dkpart
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|p_size
argument_list|)
operator|*
name|DEV_BSIZE
expr_stmt|;
return|return
operator|(
name|set_dumper
argument_list|(
operator|&
name|di
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|disk_invalidate
parameter_list|(
name|struct
name|disk
modifier|*
name|disk
parameter_list|)
block|{
if|if
condition|(
name|disk
operator|->
name|d_slice
condition|)
name|dsgone
argument_list|(
operator|&
name|disk
operator|->
name|d_slice
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|disk_destroy
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|dev
operator|->
name|si_disk
argument_list|,
name|d_list
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dev
operator|->
name|si_disk
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dev
operator|->
name|si_disk
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|si_disk
operator|=
name|NULL
expr_stmt|;
name|destroy_dev
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|struct
name|disk
modifier|*
name|disk_enumerate
parameter_list|(
name|struct
name|disk
modifier|*
name|disk
parameter_list|)
block|{
if|if
condition|(
operator|!
name|disk
condition|)
return|return
operator|(
name|LIST_FIRST
argument_list|(
operator|&
name|disklist
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|LIST_NEXT
argument_list|(
name|disk
argument_list|,
name|d_list
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_disks
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|disk
modifier|*
name|disk
decl_stmt|;
name|int
name|error
decl_stmt|,
name|first
decl_stmt|;
name|disk
operator|=
name|NULL
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|disk
operator|=
name|disk_enumerate
argument_list|(
name|disk
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|first
condition|)
block|{
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
literal|" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
else|else
block|{
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|disk
operator|->
name|d_dev
operator|->
name|si_name
argument_list|,
name|strlen
argument_list|(
name|disk
operator|->
name|d_dev
operator|->
name|si_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|disks
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_disks
argument_list|,
literal|"A"
argument_list|,
literal|"names of available disks"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The cdevsw functions  */
end_comment

begin_function
specifier|static
name|int
name|diskopen
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|dev_t
name|pdev
decl_stmt|;
name|struct
name|disk
modifier|*
name|dp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|pdev
operator|=
name|dkmodpart
argument_list|(
name|dkmodslice
argument_list|(
name|dev
argument_list|,
name|WHOLE_DISK_SLICE
argument_list|)
argument_list|,
name|RAW_PART
argument_list|)
expr_stmt|;
name|dp
operator|=
name|pdev
operator|->
name|si_disk
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
while|while
condition|(
name|dp
operator|->
name|d_flags
operator|&
name|DISKFLAG_LOCK
condition|)
block|{
name|dp
operator|->
name|d_flags
operator||=
name|DISKFLAG_WANTED
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|dp
argument_list|,
name|PRIBIO
operator||
name|PCATCH
argument_list|,
literal|"diskopen"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dp
operator|->
name|d_flags
operator||=
name|DISKFLAG_LOCK
expr_stmt|;
if|if
condition|(
operator|!
name|dsisopen
argument_list|(
name|dp
operator|->
name|d_slice
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|pdev
operator|->
name|si_iosize_max
condition|)
name|pdev
operator|->
name|si_iosize_max
operator|=
name|dev
operator|->
name|si_iosize_max
expr_stmt|;
name|error
operator|=
name|dp
operator|->
name|d_devsw
operator|->
name|d_open
argument_list|(
name|pdev
argument_list|,
name|oflags
argument_list|,
name|devtype
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
comment|/* Inherit properties from the whole/raw dev_t */
name|inherit_raw
argument_list|(
name|pdev
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|dsopen
argument_list|(
name|dev
argument_list|,
name|devtype
argument_list|,
name|dp
operator|->
name|d_dsflags
argument_list|,
operator|&
name|dp
operator|->
name|d_slice
argument_list|,
operator|&
name|dp
operator|->
name|d_label
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dsisopen
argument_list|(
name|dp
operator|->
name|d_slice
argument_list|)
condition|)
name|dp
operator|->
name|d_devsw
operator|->
name|d_close
argument_list|(
name|pdev
argument_list|,
name|oflags
argument_list|,
name|devtype
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|out
label|:
name|dp
operator|->
name|d_flags
operator|&=
operator|~
name|DISKFLAG_LOCK
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_flags
operator|&
name|DISKFLAG_WANTED
condition|)
block|{
name|dp
operator|->
name|d_flags
operator|&=
operator|~
name|DISKFLAG_WANTED
expr_stmt|;
name|wakeup
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|diskclose
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|fflag
parameter_list|,
name|int
name|devtype
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|disk
modifier|*
name|dp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dev_t
name|pdev
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|pdev
operator|=
name|dkmodpart
argument_list|(
name|dkmodslice
argument_list|(
name|dev
argument_list|,
name|WHOLE_DISK_SLICE
argument_list|)
argument_list|,
name|RAW_PART
argument_list|)
expr_stmt|;
name|dp
operator|=
name|pdev
operator|->
name|si_disk
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|dsclose
argument_list|(
name|dev
argument_list|,
name|devtype
argument_list|,
name|dp
operator|->
name|d_slice
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dsisopen
argument_list|(
name|dp
operator|->
name|d_slice
argument_list|)
condition|)
name|error
operator|=
name|dp
operator|->
name|d_devsw
operator|->
name|d_close
argument_list|(
name|dp
operator|->
name|d_dev
argument_list|,
name|fflag
argument_list|,
name|devtype
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|diskstrategy
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|dev_t
name|pdev
decl_stmt|;
name|struct
name|disk
modifier|*
name|dp
decl_stmt|;
name|pdev
operator|=
name|dkmodpart
argument_list|(
name|dkmodslice
argument_list|(
name|bp
operator|->
name|bio_dev
argument_list|,
name|WHOLE_DISK_SLICE
argument_list|)
argument_list|,
name|RAW_PART
argument_list|)
expr_stmt|;
name|dp
operator|=
name|pdev
operator|->
name|si_disk
expr_stmt|;
name|bp
operator|->
name|bio_resid
operator|=
name|bp
operator|->
name|bio_bcount
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|bp
operator|->
name|bio_dev
operator|->
name|si_disk
condition|)
name|inherit_raw
argument_list|(
name|pdev
argument_list|,
name|bp
operator|->
name|bio_dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
block|{
name|biofinish
argument_list|(
name|bp
argument_list|,
name|NULL
argument_list|,
name|ENXIO
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dscheck
argument_list|(
name|bp
argument_list|,
name|dp
operator|->
name|d_slice
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bp
operator|->
name|bio_bcount
operator|==
literal|0
condition|)
block|{
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|dp
operator|->
name|d_devsw
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL devsw"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|dp
operator|->
name|d_devsw
operator|->
name|d_strategy
operator|!=
name|NULL
argument_list|,
operator|(
literal|"NULL d_strategy"
operator|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_devsw
operator|->
name|d_strategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|diskioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fflag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|disk
modifier|*
name|dp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|u
decl_stmt|;
name|dev_t
name|pdev
decl_stmt|;
name|pdev
operator|=
name|dkmodpart
argument_list|(
name|dkmodslice
argument_list|(
name|dev
argument_list|,
name|WHOLE_DISK_SLICE
argument_list|)
argument_list|,
name|RAW_PART
argument_list|)
expr_stmt|;
name|dp
operator|=
name|pdev
operator|->
name|si_disk
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|cmd
operator|==
name|DIOCSKERNELDUMP
condition|)
block|{
name|u
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
expr_stmt|;
return|return
operator|(
name|diskdumpconf
argument_list|(
name|u
argument_list|,
name|dev
argument_list|,
name|dp
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|cmd
operator|==
name|DIOCGFRONTSTUFF
condition|)
block|{
operator|*
operator|(
name|off_t
operator|*
operator|)
name|data
operator|=
literal|8192
expr_stmt|;
comment|/* XXX: crude but enough) */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
name|dsioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|fflag
argument_list|,
operator|&
name|dp
operator|->
name|d_slice
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
name|error
operator|=
name|dp
operator|->
name|d_devsw
operator|->
name|d_ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|fflag
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|diskpsize
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|struct
name|disk
modifier|*
name|dp
decl_stmt|;
name|dev_t
name|pdev
decl_stmt|;
name|pdev
operator|=
name|dkmodpart
argument_list|(
name|dkmodslice
argument_list|(
name|dev
argument_list|,
name|WHOLE_DISK_SLICE
argument_list|)
argument_list|,
name|RAW_PART
argument_list|)
expr_stmt|;
name|dp
operator|=
name|pdev
operator|->
name|si_disk
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|dp
operator|!=
name|dev
operator|->
name|si_disk
condition|)
block|{
name|dev
operator|->
name|si_drv1
operator|=
name|pdev
operator|->
name|si_drv1
expr_stmt|;
name|dev
operator|->
name|si_drv2
operator|=
name|pdev
operator|->
name|si_drv2
expr_stmt|;
comment|/* XXX: don't set bp->b_dev->si_disk (?) */
block|}
return|return
operator|(
name|dssize
argument_list|(
name|dev
argument_list|,
operator|&
name|dp
operator|->
name|d_slice
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_sizeof
argument_list|,
name|OID_AUTO
argument_list|,
name|disklabel
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|disklabel
argument_list|)
argument_list|,
literal|"sizeof(struct disklabel)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_sizeof
argument_list|,
name|OID_AUTO
argument_list|,
name|diskslices
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|diskslices
argument_list|)
argument_list|,
literal|"sizeof(struct diskslices)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_sizeof
argument_list|,
name|OID_AUTO
argument_list|,
name|disk
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|disk
argument_list|)
argument_list|,
literal|"sizeof(struct disk)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  * Disk error is the preface to plaintive error messages  * about failing disk transfers.  It prints messages of the form  * 	"hp0g: BLABLABLA cmd=read fsbn 12345 of 12344-12347"  * blkdone should be -1 if the position of the error is unknown.  * The message is printed with printf.  */
end_comment

begin_function
name|void
name|disk_err
parameter_list|(
name|struct
name|bio
modifier|*
name|bp
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|int
name|blkdone
parameter_list|,
name|int
name|nl
parameter_list|)
block|{
name|daddr_t
name|sn
decl_stmt|;
name|printf
argument_list|(
literal|"%s: %s"
argument_list|,
name|devtoname
argument_list|(
name|bp
operator|->
name|bio_dev
argument_list|)
argument_list|,
name|what
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bio_cmd
condition|)
block|{
case|case
name|BIO_READ
case|:
name|printf
argument_list|(
literal|"cmd=read"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_WRITE
case|:
name|printf
argument_list|(
literal|"cmd=write"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_DELETE
case|:
name|printf
argument_list|(
literal|"cmd=delete"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_GETATTR
case|:
name|printf
argument_list|(
literal|"cmd=getattr"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIO_SETATTR
case|:
name|printf
argument_list|(
literal|"cmd=setattr"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"cmd=%x"
argument_list|,
name|bp
operator|->
name|bio_cmd
argument_list|)
expr_stmt|;
break|break;
block|}
name|sn
operator|=
name|bp
operator|->
name|bio_blkno
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_bcount
operator|<=
name|DEV_BSIZE
condition|)
block|{
name|printf
argument_list|(
literal|"fsbn %jd%s"
argument_list|,
operator|(
name|intmax_t
operator|)
name|sn
argument_list|,
name|nl
condition|?
literal|"\n"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|blkdone
operator|>=
literal|0
condition|)
block|{
name|sn
operator|+=
name|blkdone
expr_stmt|;
name|printf
argument_list|(
literal|"fsbn %jd of "
argument_list|,
operator|(
name|intmax_t
operator|)
name|sn
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%jd-%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|bp
operator|->
name|bio_blkno
argument_list|,
call|(
name|intmax_t
call|)
argument_list|(
name|bp
operator|->
name|bio_blkno
operator|+
operator|(
name|bp
operator|->
name|bio_bcount
operator|-
literal|1
operator|)
operator|/
name|DEV_BSIZE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

