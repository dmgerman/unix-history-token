begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Copyright (C) 2001 Julian Elischer<julian@freebsd.org>.  *  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice(s), this list of conditions and the following disclaimer as  *    the first lines of this file unmodified other than the possible   *    addition of one or more copyright notices.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice(s), this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kse.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucontext.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_comment
comment|/*  * KSEGRP related storage.  */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|ksegrp_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|kse_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|thread_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DEBUG ONLY */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|threads
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"thread allocation"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|oiks_debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 disable, 1 printf, 2 enter debugger */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_threads
argument_list|,
name|OID_AUTO
argument_list|,
name|oiks
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|oiks_debug
argument_list|,
literal|0
argument_list|,
literal|"OIKS thread debug"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|max_threads_per_proc
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_threads
argument_list|,
name|OID_AUTO
argument_list|,
name|max_per_proc
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|max_threads_per_proc
argument_list|,
literal|0
argument_list|,
literal|"Limit on threads per proc"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|RANGEOF
parameter_list|(
name|type
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
value|(offsetof(type, end) - offsetof(type, start))
end_define

begin_decl_stmt
name|struct
name|threadqueue
name|zombie_threads
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|zombie_threads
argument_list|)
decl_stmt|;
end_decl_stmt

begin_macro
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|kse
argument_list|)
end_macro

begin_expr_stmt
name|zombie_kses
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|zombie_kses
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|ksegrp
argument_list|)
end_macro

begin_expr_stmt
name|zombie_ksegrps
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|zombie_ksegrps
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|mtx
name|zombie_thread_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|zombie_thread_lock
argument_list|,
operator|&
name|zombie_thread_lock
argument_list|,
literal|"zombie_thread_lock"
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
name|void
name|kse_purge
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Pepare a thread for use.  */
end_comment

begin_function
specifier|static
name|void
name|thread_ctor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|size
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
operator|)
argument_list|,
operator|(
literal|"size mismatch: %d != %d\n"
operator|,
name|size
operator|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|td
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|mem
expr_stmt|;
name|td
operator|->
name|td_state
operator|=
name|TDS_INACTIVE
expr_stmt|;
name|td
operator|->
name|td_flags
operator||=
name|TDF_UNBOUND
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reclaim a thread after use.  */
end_comment

begin_function
specifier|static
name|void
name|thread_dtor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|size
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
operator|)
argument_list|,
operator|(
literal|"size mismatch: %d != %d\n"
operator|,
name|size
operator|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|td
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|mem
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
comment|/* Verify that this thread is in a safe state to free. */
switch|switch
condition|(
name|td
operator|->
name|td_state
condition|)
block|{
case|case
name|TDS_INHIBITED
case|:
case|case
name|TDS_RUNNING
case|:
case|case
name|TDS_CAN_RUN
case|:
case|case
name|TDS_RUNQ
case|:
comment|/* 		 * We must never unlink a thread that is in one of 		 * these states, because it is currently active. 		 */
name|panic
argument_list|(
literal|"bad state for thread unlinking"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|TDS_INACTIVE
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"bad thread state"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Initialize type-stable parts of a thread (when newly created).  */
end_comment

begin_function
specifier|static
name|void
name|thread_init
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|size
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
operator|)
argument_list|,
operator|(
literal|"size mismatch: %d != %d\n"
operator|,
name|size
operator|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|td
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|mem
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|pmap_new_thread
argument_list|(
name|td
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|cpu_thread_setup
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Tear down type-stable parts of a thread (just before being discarded).  */
end_comment

begin_function
specifier|static
name|void
name|thread_fini
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|size
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
operator|)
argument_list|,
operator|(
literal|"size mismatch: %d != %d\n"
operator|,
name|size
operator|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|td
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|mem
expr_stmt|;
name|pmap_dispose_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * KSE is linked onto the idle queue.  */
end_comment

begin_function
name|void
name|kse_link
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|,
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|kg
operator|->
name|kg_proc
decl_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|kg
operator|->
name|kg_kseq
argument_list|,
name|ke
argument_list|,
name|ke_kglist
argument_list|)
expr_stmt|;
name|kg
operator|->
name|kg_kses
operator|++
expr_stmt|;
name|ke
operator|->
name|ke_state
operator|=
name|KES_UNQUEUED
expr_stmt|;
name|ke
operator|->
name|ke_proc
operator|=
name|p
expr_stmt|;
name|ke
operator|->
name|ke_ksegrp
operator|=
name|kg
expr_stmt|;
name|ke
operator|->
name|ke_thread
operator|=
name|NULL
expr_stmt|;
name|ke
operator|->
name|ke_oncpu
operator|=
name|NOCPU
expr_stmt|;
block|}
end_function

begin_function
name|void
name|kse_unlink
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|kg
operator|=
name|ke
operator|->
name|ke_ksegrp
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_state
operator|==
name|KES_IDLE
condition|)
block|{
name|kg
operator|->
name|kg_idle_kses
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kg
operator|->
name|kg_iq
argument_list|,
name|ke
argument_list|,
name|ke_kgrlist
argument_list|)
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kg
operator|->
name|kg_kseq
argument_list|,
name|ke
argument_list|,
name|ke_kglist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|kg
operator|->
name|kg_kses
operator|==
literal|0
condition|)
block|{
name|ksegrp_unlink
argument_list|(
name|kg
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Aggregate stats from the KSE 	 */
name|kse_stash
argument_list|(
name|ke
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ksegrp_link
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|kg
operator|->
name|kg_threads
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|kg
operator|->
name|kg_runq
argument_list|)
expr_stmt|;
comment|/* links with td_runq */
name|TAILQ_INIT
argument_list|(
operator|&
name|kg
operator|->
name|kg_slpq
argument_list|)
expr_stmt|;
comment|/* links with td_runq */
name|TAILQ_INIT
argument_list|(
operator|&
name|kg
operator|->
name|kg_kseq
argument_list|)
expr_stmt|;
comment|/* all kses in ksegrp */
name|TAILQ_INIT
argument_list|(
operator|&
name|kg
operator|->
name|kg_iq
argument_list|)
expr_stmt|;
comment|/* idle kses in ksegrp */
name|TAILQ_INIT
argument_list|(
operator|&
name|kg
operator|->
name|kg_lq
argument_list|)
expr_stmt|;
comment|/* loan kses in ksegrp */
name|kg
operator|->
name|kg_proc
operator|=
name|p
expr_stmt|;
comment|/* the following counters are in the -zero- section and may not need clearing */
name|kg
operator|->
name|kg_numthreads
operator|=
literal|0
expr_stmt|;
name|kg
operator|->
name|kg_runnable
operator|=
literal|0
expr_stmt|;
name|kg
operator|->
name|kg_kses
operator|=
literal|0
expr_stmt|;
name|kg
operator|->
name|kg_idle_kses
operator|=
literal|0
expr_stmt|;
name|kg
operator|->
name|kg_loan_kses
operator|=
literal|0
expr_stmt|;
name|kg
operator|->
name|kg_runq_kses
operator|=
literal|0
expr_stmt|;
comment|/* XXXKSE change name */
comment|/* link it in now that it's consistent */
name|p
operator|->
name|p_numksegrps
operator|++
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|p
operator|->
name|p_ksegrps
argument_list|,
name|kg
argument_list|,
name|kg_ksegrp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ksegrp_unlink
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|p
operator|=
name|kg
operator|->
name|kg_proc
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|kg
operator|->
name|kg_numthreads
operator|==
literal|0
operator|)
operator|&&
operator|(
name|kg
operator|->
name|kg_kses
operator|==
literal|0
operator|)
operator|)
argument_list|,
operator|(
literal|"kseg_unlink: residual threads or KSEs"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|p
operator|->
name|p_ksegrps
argument_list|,
name|kg
argument_list|,
name|kg_ksegrp
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_numksegrps
operator|--
expr_stmt|;
comment|/* 	 * Aggregate stats from the KSE 	 */
name|ksegrp_stash
argument_list|(
name|kg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * for a newly created process,  * link up a the structure and its initial threads etc.  */
end_comment

begin_function
name|void
name|proc_linkup
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|,
name|struct
name|kse
modifier|*
name|ke
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|p
operator|->
name|p_ksegrps
argument_list|)
expr_stmt|;
comment|/* all ksegrps in proc */
name|TAILQ_INIT
argument_list|(
operator|&
name|p
operator|->
name|p_threads
argument_list|)
expr_stmt|;
comment|/* all threads in proc */
name|TAILQ_INIT
argument_list|(
operator|&
name|p
operator|->
name|p_suspended
argument_list|)
expr_stmt|;
comment|/* Threads suspended */
name|p
operator|->
name|p_numksegrps
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|p_numthreads
operator|=
literal|0
expr_stmt|;
name|ksegrp_link
argument_list|(
name|kg
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|kse_link
argument_list|(
name|ke
argument_list|,
name|kg
argument_list|)
expr_stmt|;
name|thread_link
argument_list|(
name|td
argument_list|,
name|kg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|kse_thr_interrupt
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kse_thr_interrupt_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kse_exit
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kse_exit_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
comment|/* KSE-enabled processes only, please. */
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_KSES
operator|)
condition|)
return|return
name|EINVAL
return|;
comment|/* must be a bound thread */
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_UNBOUND
condition|)
return|return
name|EINVAL
return|;
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
comment|/* serialize killing kse */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kg
operator|->
name|kg_kses
operator|==
literal|1
operator|)
operator|&&
operator|(
name|kg
operator|->
name|kg_numthreads
operator|>
literal|1
operator|)
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EDEADLK
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|p
operator|->
name|p_numthreads
operator|==
literal|1
operator|)
operator|&&
operator|(
name|p
operator|->
name|p_numksegrps
operator|==
literal|1
operator|)
condition|)
block|{
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_KSES
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|mtx_owned
argument_list|(
operator|&
name|Giant
argument_list|)
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_kse
operator|->
name|ke_flags
operator||=
name|KEF_EXIT
expr_stmt|;
name|thread_exit
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|kse_release
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kse_release_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
comment|/* KSE-enabled processes only, please. */
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_KSES
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|thread_exit
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* struct kse_wakeup_args { 	struct kse_mailbox *mbx; }; */
end_comment

begin_function
name|int
name|kse_wakeup
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kse_wakeup_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|,
modifier|*
name|ke2
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
comment|/* KSE-enabled processes only, please. */
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_KSES
operator|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|td
operator|->
name|td_standin
operator|==
name|NULL
condition|)
name|td
operator|->
name|td_standin
operator|=
name|thread_alloc
argument_list|()
expr_stmt|;
name|ke
operator|=
name|NULL
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|mbx
condition|)
block|{
name|FOREACH_KSEGRP_IN_PROC
argument_list|(
argument|p
argument_list|,
argument|kg
argument_list|)
block|{
name|FOREACH_KSE_IN_GROUP
argument_list|(
argument|kg
argument_list|,
argument|ke2
argument_list|)
block|{
if|if
condition|(
name|ke2
operator|->
name|ke_mailbox
operator|!=
name|uap
operator|->
name|mbx
condition|)
continue|continue;
if|if
condition|(
name|ke2
operator|->
name|ke_state
operator|==
name|KES_IDLE
condition|)
block|{
name|ke
operator|=
name|ke2
expr_stmt|;
goto|goto
name|found
goto|;
block|}
else|else
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
else|else
block|{
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
name|ke
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|kg
operator|->
name|kg_iq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ke
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
return|return
name|ESRCH
return|;
block|}
name|found
label|:
name|thread_schedule_upcall
argument_list|(
name|td
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*   * No new KSEG: first call: use current KSE, don't schedule an upcall  * All other situations, do allocate a new KSE and schedule an upcall on it.  */
end_comment

begin_comment
comment|/* struct kse_create_args { 	struct kse_mailbox *mbx; 	int newgroup; }; */
end_comment

begin_function
name|int
name|kse_create
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kse_create_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|newke
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|newkg
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|kse_mailbox
name|mbx
decl_stmt|;
name|int
name|err
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|mbx
argument_list|,
operator|&
name|mbx
argument_list|,
sizeof|sizeof
argument_list|(
name|mbx
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|p
operator|->
name|p_flag
operator||=
name|P_KSES
expr_stmt|;
comment|/* easier to just set it than to test and set */
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|newgroup
condition|)
block|{
comment|/*  		 * If we want a new KSEGRP it doesn't matter whether 		 * we have already fired up KSE mode before or not. 		 * We put the process in KSE mode and create a new KSEGRP 		 * and KSE. If our KSE has not got a mailbox yet then 		 * that doesn't matter, just leave it that way. It will  		 * ensure that this thread stay BOUND. It's possible 		 * that the call came form a threaded library and the main  		 * program knows nothing of threads. 		 */
name|newkg
operator|=
name|ksegrp_alloc
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|newkg
operator|->
name|kg_startzero
argument_list|,
name|RANGEOF
argument_list|(
expr|struct
name|ksegrp
argument_list|,
name|kg_startzero
argument_list|,
name|kg_endzero
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|kg
operator|->
name|kg_startcopy
argument_list|,
operator|&
name|newkg
operator|->
name|kg_startcopy
argument_list|,
name|RANGEOF
argument_list|(
expr|struct
name|ksegrp
argument_list|,
name|kg_startcopy
argument_list|,
name|kg_endcopy
argument_list|)
argument_list|)
expr_stmt|;
name|newke
operator|=
name|kse_alloc
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/*  		 * Otherwise, if we have already set this KSE 		 * to have a mailbox, we want to make another KSE here, 		 * but only if there are not already the limit, which  		 * is 1 per CPU max. 		 *  		 * If the current KSE doesn't have a mailbox we just use it 		 * and give it one. 		 * 		 * Because we don't like to access 		 * the KSE outside of schedlock if we are UNBOUND, 		 * (because it can change if we are preempted by an interrupt)  		 * we can deduce it as having a mailbox if we are UNBOUND, 		 * and only need to actually look at it if we are BOUND, 		 * which is safe. 		 */
if|if
condition|(
operator|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_UNBOUND
operator|)
operator|||
name|td
operator|->
name|td_kse
operator|->
name|ke_mailbox
condition|)
block|{
if|#
directive|if
literal|0
comment|/* while debugging */
ifdef|#
directive|ifdef
name|SMP
block|if (kg->kg_kses> mp_ncpus)
endif|#
directive|endif
block|return (EPROCLIM);
endif|#
directive|endif
name|newke
operator|=
name|kse_alloc
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|newke
operator|=
name|NULL
expr_stmt|;
block|}
name|newkg
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|newke
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|newke
operator|->
name|ke_startzero
argument_list|,
name|RANGEOF
argument_list|(
expr|struct
name|kse
argument_list|,
name|ke_startzero
argument_list|,
name|ke_endzero
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|bcopy(&ke->ke_startcopy,&newke->ke_startcopy, 		      RANGEOF(struct kse, ke_startcopy, ke_endcopy));
endif|#
directive|endif
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|SIGPENDING
argument_list|(
name|p
argument_list|)
condition|)
name|newke
operator|->
name|ke_flags
operator||=
name|KEF_ASTPENDING
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* For the first call this may not have been set */
if|if
condition|(
name|td
operator|->
name|td_standin
operator|==
name|NULL
condition|)
block|{
name|td
operator|->
name|td_standin
operator|=
name|thread_alloc
argument_list|()
expr_stmt|;
block|}
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|newkg
condition|)
name|ksegrp_link
argument_list|(
name|newkg
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|newkg
operator|=
name|kg
expr_stmt|;
name|kse_link
argument_list|(
name|newke
argument_list|,
name|newkg
argument_list|)
expr_stmt|;
name|newke
operator|->
name|ke_mailbox
operator|=
name|uap
operator|->
name|mbx
expr_stmt|;
name|newke
operator|->
name|ke_upcall
operator|=
name|mbx
operator|.
name|km_func
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|mbx
operator|.
name|km_stack
argument_list|,
operator|&
name|newke
operator|->
name|ke_stack
argument_list|,
sizeof|sizeof
argument_list|(
name|stack_t
argument_list|)
argument_list|)
expr_stmt|;
name|thread_schedule_upcall
argument_list|(
name|td
argument_list|,
name|newke
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If we didn't allocate a new KSE then the we are using 		 * the exisiting (BOUND) kse. 		 */
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|ke
operator|->
name|ke_mailbox
operator|=
name|uap
operator|->
name|mbx
expr_stmt|;
name|ke
operator|->
name|ke_upcall
operator|=
name|mbx
operator|.
name|km_func
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|mbx
operator|.
name|km_stack
argument_list|,
operator|&
name|ke
operator|->
name|ke_stack
argument_list|,
sizeof|sizeof
argument_list|(
name|stack_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fill out the KSE-mode specific fields of the new kse. 	 */
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill a ucontext_t with a thread's context information.  *  * This is an analogue to getcontext(3).  */
end_comment

begin_function
name|void
name|thread_getcontext
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|ucontext_t
modifier|*
name|uc
parameter_list|)
block|{
comment|/*  * XXX this is declared in a MD include file, i386/include/ucontext.h but  * is used in MI code.  */
ifdef|#
directive|ifdef
name|__i386__
name|get_mcontext
argument_list|(
name|td
argument_list|,
operator|&
name|uc
operator|->
name|uc_mcontext
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|uc
operator|->
name|uc_sigmask
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_sigmask
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set a thread's context from a ucontext_t.  *  * This is an analogue to setcontext(3).  */
end_comment

begin_function
name|int
name|thread_setcontext
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|ucontext_t
modifier|*
name|uc
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
comment|/*  * XXX this is declared in a MD include file, i386/include/ucontext.h but  * is used in MI code.  */
ifdef|#
directive|ifdef
name|__i386__
name|ret
operator|=
name|set_mcontext
argument_list|(
name|td
argument_list|,
operator|&
name|uc
operator|->
name|uc_mcontext
argument_list|)
expr_stmt|;
else|#
directive|else
name|ret
operator|=
name|ENOSYS
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|SIG_CANTMASK
argument_list|(
name|uc
operator|->
name|uc_sigmask
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_proc
operator|->
name|p_sigmask
operator|=
name|uc
operator|->
name|uc_sigmask
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize global thread allocation resources.  */
end_comment

begin_function
name|void
name|threadinit
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|__ia64__
name|thread_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"THREAD"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
argument_list|,
name|thread_ctor
argument_list|,
name|thread_dtor
argument_list|,
name|thread_init
argument_list|,
name|thread_fini
argument_list|,
name|UMA_ALIGN_CACHE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	 * XXX the ia64 kstack allocator is really lame and is at the mercy 	 * of contigmallloc().  This hackery is to pre-construct a whole 	 * pile of thread structures with associated kernel stacks early 	 * in the system startup while contigmalloc() still works. Once we 	 * have them, keep them.  Sigh. 	 */
name|thread_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"THREAD"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
argument_list|,
name|thread_ctor
argument_list|,
name|thread_dtor
argument_list|,
name|thread_init
argument_list|,
name|thread_fini
argument_list|,
name|UMA_ALIGN_CACHE
argument_list|,
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
name|uma_prealloc
argument_list|(
name|thread_zone
argument_list|,
literal|512
argument_list|)
expr_stmt|;
comment|/* XXX arbitary */
endif|#
directive|endif
name|ksegrp_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"KSEGRP"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ksegrp
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_CACHE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kse_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"KSE"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kse
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_CACHE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stash an embarasingly extra thread into the zombie thread queue.  */
end_comment

begin_function
name|void
name|thread_stash
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|zombie_thread_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|zombie_threads
argument_list|,
name|td
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|zombie_thread_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stash an embarasingly extra kse into the zombie kse queue.  */
end_comment

begin_function
name|void
name|kse_stash
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|zombie_thread_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|zombie_kses
argument_list|,
name|ke
argument_list|,
name|ke_procq
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|zombie_thread_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stash an embarasingly extra ksegrp into the zombie ksegrp queue.  */
end_comment

begin_function
name|void
name|ksegrp_stash
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|zombie_thread_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|zombie_ksegrps
argument_list|,
name|kg
argument_list|,
name|kg_ksegrp
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|zombie_thread_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reap zombie threads.  */
end_comment

begin_function
name|void
name|thread_reap
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td_first
decl_stmt|,
modifier|*
name|td_next
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke_first
decl_stmt|,
modifier|*
name|ke_next
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg_first
decl_stmt|,
modifier|*
name|kg_next
decl_stmt|;
comment|/* 	 * don't even bother to lock if none at this instant 	 * We really don't care about the next instant.. 	 */
if|if
condition|(
operator|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|zombie_threads
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|zombie_kses
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|zombie_ksegrps
argument_list|)
operator|)
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|zombie_thread_lock
argument_list|)
expr_stmt|;
name|td_first
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|zombie_threads
argument_list|)
expr_stmt|;
name|ke_first
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|zombie_kses
argument_list|)
expr_stmt|;
name|kg_first
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|zombie_ksegrps
argument_list|)
expr_stmt|;
if|if
condition|(
name|td_first
condition|)
name|TAILQ_INIT
argument_list|(
operator|&
name|zombie_threads
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke_first
condition|)
name|TAILQ_INIT
argument_list|(
operator|&
name|zombie_kses
argument_list|)
expr_stmt|;
if|if
condition|(
name|kg_first
condition|)
name|TAILQ_INIT
argument_list|(
operator|&
name|zombie_ksegrps
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|zombie_thread_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|td_first
condition|)
block|{
name|td_next
operator|=
name|TAILQ_NEXT
argument_list|(
name|td_first
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
name|thread_free
argument_list|(
name|td_first
argument_list|)
expr_stmt|;
name|td_first
operator|=
name|td_next
expr_stmt|;
block|}
while|while
condition|(
name|ke_first
condition|)
block|{
name|ke_next
operator|=
name|TAILQ_NEXT
argument_list|(
name|ke_first
argument_list|,
name|ke_procq
argument_list|)
expr_stmt|;
name|kse_free
argument_list|(
name|ke_first
argument_list|)
expr_stmt|;
name|ke_first
operator|=
name|ke_next
expr_stmt|;
block|}
while|while
condition|(
name|kg_first
condition|)
block|{
name|kg_next
operator|=
name|TAILQ_NEXT
argument_list|(
name|kg_first
argument_list|,
name|kg_ksegrp
argument_list|)
expr_stmt|;
name|ksegrp_free
argument_list|(
name|kg_first
argument_list|)
expr_stmt|;
name|kg_first
operator|=
name|kg_next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a ksegrp.  */
end_comment

begin_function
name|struct
name|ksegrp
modifier|*
name|ksegrp_alloc
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|uma_zalloc
argument_list|(
name|ksegrp_zone
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a kse.  */
end_comment

begin_function
name|struct
name|kse
modifier|*
name|kse_alloc
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|uma_zalloc
argument_list|(
name|kse_zone
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a thread.  */
end_comment

begin_function
name|struct
name|thread
modifier|*
name|thread_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|thread_reap
argument_list|()
expr_stmt|;
comment|/* check if any zombies to get */
return|return
operator|(
name|uma_zalloc
argument_list|(
name|thread_zone
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Deallocate a ksegrp.  */
end_comment

begin_function
name|void
name|ksegrp_free
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|td
parameter_list|)
block|{
name|uma_zfree
argument_list|(
name|ksegrp_zone
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Deallocate a kse.  */
end_comment

begin_function
name|void
name|kse_free
parameter_list|(
name|struct
name|kse
modifier|*
name|td
parameter_list|)
block|{
name|uma_zfree
argument_list|(
name|kse_zone
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Deallocate a thread.  */
end_comment

begin_function
name|void
name|thread_free
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|uma_zfree
argument_list|(
name|thread_zone
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Store the thread context in the UTS's mailbox.  * then add the mailbox at the head of a list we are building in user space.  * The list is anchored in the ksegrp structure.  */
end_comment

begin_function
name|int
name|thread_export_context
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|uintptr_t
name|mbx
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ucontext_t
name|uc
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
comment|/* Export the user/machine context. */
if|#
directive|if
literal|0
block|addr = (caddr_t)td->td_mailbox + 	    offsetof(struct kse_thr_mailbox, tm_context);
else|#
directive|else
comment|/* if user pointer arithmetic is valid in the kernel */
name|addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|td
operator|->
name|td_mailbox
operator|->
name|tm_context
operator|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|copyin
argument_list|(
name|addr
argument_list|,
operator|&
name|uc
argument_list|,
sizeof|sizeof
argument_list|(
name|ucontext_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|thread_getcontext
argument_list|(
name|td
argument_list|,
operator|&
name|uc
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|uc
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ucontext_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGSEGV
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* get address in latest mbox of list pointer */
if|#
directive|if
literal|0
block|addr = (caddr_t)td->td_mailbox 	    + offsetof(struct kse_thr_mailbox , tm_next);
else|#
directive|else
comment|/* if user pointer arithmetic is valid in the kernel */
name|addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|td
operator|->
name|td_mailbox
operator|->
name|tm_next
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Put the saved address of the previous first 	 * entry into this one 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|mbx
operator|=
operator|(
name|uintptr_t
operator|)
name|kg
operator|->
name|kg_completed
expr_stmt|;
if|if
condition|(
name|suword
argument_list|(
name|addr
argument_list|,
name|mbx
argument_list|)
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGSEGV
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbx
operator|==
operator|(
name|uintptr_t
operator|)
name|kg
operator|->
name|kg_completed
condition|)
block|{
name|kg
operator|->
name|kg_completed
operator|=
name|td
operator|->
name|td_mailbox
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Take the list of completed mailboxes for this KSEGRP and put them on this  * KSE's mailbox as it's the next one going up.  */
end_comment

begin_function
specifier|static
name|int
name|thread_link_mboxes
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|,
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|kg
operator|->
name|kg_proc
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
name|uintptr_t
name|mbx
decl_stmt|;
if|#
directive|if
literal|0
block|addr = (caddr_t)ke->ke_mailbox 	    + offsetof(struct kse_mailbox, km_completed);
else|#
directive|else
comment|/* if user pointer arithmetic is valid in the kernel */
name|addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|ke
operator|->
name|ke_mailbox
operator|->
name|km_completed
operator|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
name|mbx
operator|=
operator|(
name|uintptr_t
operator|)
name|kg
operator|->
name|kg_completed
expr_stmt|;
if|if
condition|(
name|suword
argument_list|(
name|addr
argument_list|,
name|mbx
argument_list|)
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|p
argument_list|,
name|SIGSEGV
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
comment|/* XXXKSE could use atomic CMPXCH here */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbx
operator|==
operator|(
name|uintptr_t
operator|)
name|kg
operator|->
name|kg_completed
condition|)
block|{
name|kg
operator|->
name|kg_completed
operator|=
name|NULL
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Discard the current thread and exit from its context.  *  * Because we can't free a thread while we're operating under its context,  * push the current thread into our KSE's ke_tdspare slot, freeing the  * thread that might be there currently. Because we know that only this  * processor will run our KSE, we needn't worry about someone else grabbing  * our context before we do a cpu_throw.  */
end_comment

begin_function
name|void
name|thread_exit
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|p
operator|!=
name|NULL
argument_list|,
operator|(
literal|"thread exiting without a process"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ke
operator|!=
name|NULL
argument_list|,
operator|(
literal|"thread exiting without a kse"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|kg
operator|!=
name|NULL
argument_list|,
operator|(
literal|"thread exiting without a kse group"
operator|)
argument_list|)
expr_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_PROC
argument_list|,
literal|"thread_exit: thread %p"
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|mtx_owned
argument_list|(
operator|&
name|Giant
argument_list|)
argument_list|,
operator|(
literal|"dying thread owns giant"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_tdspare
operator|!=
name|NULL
condition|)
block|{
name|thread_stash
argument_list|(
name|ke
operator|->
name|ke_tdspare
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_tdspare
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|td
operator|->
name|td_standin
operator|!=
name|NULL
condition|)
block|{
name|thread_stash
argument_list|(
name|td
operator|->
name|td_standin
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_standin
operator|=
name|NULL
expr_stmt|;
block|}
name|cpu_thread_exit
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* XXXSMP */
comment|/* 	 * The last thread is left attached to the process 	 * So that the whole bundle gets recycled. Skip 	 * all this stuff. 	 */
if|if
condition|(
name|p
operator|->
name|p_numthreads
operator|>
literal|1
condition|)
block|{
comment|/* 		 * Unlink this thread from its proc and the kseg. 		 * In keeping with the other structs we probably should 		 * have a thread_unlink() that does some of this but it 		 * would only be called from here (I think) so it would 		 * be a waste. (might be useful for proc_fini() as well.)  		 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|p
operator|->
name|p_threads
argument_list|,
name|td
argument_list|,
name|td_plist
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_numthreads
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kg
operator|->
name|kg_threads
argument_list|,
name|td
argument_list|,
name|td_kglist
argument_list|)
expr_stmt|;
name|kg
operator|->
name|kg_numthreads
operator|--
expr_stmt|;
comment|/* 		 * The test below is NOT true if we are the 		 * sole exiting thread. P_STOPPED_SNGL is unset 		 * in exit1() after it is the only survivor. 		 */
if|if
condition|(
name|P_SHOULDSTOP
argument_list|(
name|p
argument_list|)
operator|==
name|P_STOPPED_SINGLE
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_numthreads
operator|==
name|p
operator|->
name|p_suspcount
condition|)
block|{
name|thread_unsuspend_one
argument_list|(
name|p
operator|->
name|p_singlethread
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Reassign this thread's KSE. */
name|ke
operator|->
name|ke_thread
operator|=
name|NULL
expr_stmt|;
name|td
operator|->
name|td_kse
operator|=
name|NULL
expr_stmt|;
name|ke
operator|->
name|ke_state
operator|=
name|KES_UNQUEUED
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ke
operator|->
name|ke_bound
operator|!=
name|td
operator|)
argument_list|,
operator|(
literal|"thread_exit: entered with ke_bound set"
operator|)
argument_list|)
expr_stmt|;
comment|/*  		 * The reason for all this hoopla is  		 * an attempt to stop our thread stack from being freed  		 * until AFTER we have stopped running on it. 		 * Since we are under schedlock, almost any method where 		 * it is eventually freed by someone else is probably ok. 		 * (Especially if they do it under schedlock). We could  		 * almost free it here if we could be certain that  		 * the uma code wouldn't pull it apart immediatly,  		 * but unfortunatly we can not guarantee that. 		 * 		 * For threads that are exiting and NOT killing their 		 * KSEs we can just stash it in the KSE, however 		 * in the case where the KSE is also being deallocated, 		 * we need to store it somewhere else. It turns out that 		 * we will never free the last KSE, so there is always one 		 * other KSE available. We might as well just choose one 		 * and stash it there. Being under schedlock should make that 		 * safe. 		 * 		 * In borrower threads, we can stash it in the lender 		 * Where it won't be needed until this thread is long gone. 		 * Borrower threads can't kill their KSE anyhow, so even 		 * the KSE would be a safe place for them. It is not 		 * necessary to have a KSE (or KSEGRP) at all beyond this 		 * point, while we are under the protection of schedlock. 		 * 		 * Either give the KSE to another thread to use (or make 		 * it idle), or free it entirely, possibly along with its 		 * ksegrp if it's the last one. 		 */
if|if
condition|(
name|ke
operator|->
name|ke_flags
operator|&
name|KEF_EXIT
condition|)
block|{
name|kse_unlink
argument_list|(
name|ke
argument_list|)
expr_stmt|;
comment|/* 			 * Designate another KSE to hold our thread. 			 * Safe as long as we abide by whatever lock  			 * we control it with.. The other KSE will not 			 * be able to run it until we release the schelock, 			 * but we need to be careful about it deciding to  			 * write to the stack before then. Luckily 			 * I believe that while another thread's 			 * standin thread can be used in this way, the 			 * spare thread for the KSE cannot be used without 			 * holding schedlock at least once. 			 */
name|ke
operator|=
name|FIRST_KSE_IN_PROC
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kse_reassign
argument_list|(
name|ke
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ke
operator|->
name|ke_bound
condition|)
block|{
comment|/* 			 * WE are a borrower.. 			 * stash our thread with the owner. 			 */
if|if
condition|(
name|ke
operator|->
name|ke_bound
operator|->
name|td_standin
condition|)
block|{
name|thread_stash
argument_list|(
name|ke
operator|->
name|ke_bound
operator|->
name|td_standin
argument_list|)
expr_stmt|;
block|}
name|ke
operator|->
name|ke_bound
operator|->
name|td_standin
operator|=
name|td
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ke
operator|->
name|ke_tdspare
operator|!=
name|NULL
condition|)
block|{
name|thread_stash
argument_list|(
name|ke
operator|->
name|ke_tdspare
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_tdspare
operator|=
name|NULL
expr_stmt|;
block|}
name|ke
operator|->
name|ke_tdspare
operator|=
name|td
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_state
operator|=
name|TDS_INACTIVE
expr_stmt|;
name|td
operator|->
name|td_proc
operator|=
name|NULL
expr_stmt|;
name|td
operator|->
name|td_ksegrp
operator|=
name|NULL
expr_stmt|;
name|td
operator|->
name|td_last_kse
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|cpu_throw
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Link a thread to a process.  * set up anything that needs to be initialized for it to  * be used by the process.  *  * Note that we do not link to the proc's ucred here.  * The thread is linked as if running but no KSE assigned.  */
end_comment

begin_function
name|void
name|thread_link
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|kg
operator|->
name|kg_proc
expr_stmt|;
name|td
operator|->
name|td_state
operator|=
name|TDS_INACTIVE
expr_stmt|;
name|td
operator|->
name|td_proc
operator|=
name|p
expr_stmt|;
name|td
operator|->
name|td_ksegrp
operator|=
name|kg
expr_stmt|;
name|td
operator|->
name|td_last_kse
operator|=
name|NULL
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|td
operator|->
name|td_contested
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|td
operator|->
name|td_slpcallout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|p
operator|->
name|p_threads
argument_list|,
name|td
argument_list|,
name|td_plist
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|kg
operator|->
name|kg_threads
argument_list|,
name|td
argument_list|,
name|td_kglist
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_numthreads
operator|++
expr_stmt|;
name|kg
operator|->
name|kg_numthreads
operator|++
expr_stmt|;
if|if
condition|(
name|oiks_debug
operator|&&
name|p
operator|->
name|p_numthreads
operator|>
name|max_threads_per_proc
condition|)
block|{
name|printf
argument_list|(
literal|"OIKS %d\n"
argument_list|,
name|p
operator|->
name|p_numthreads
argument_list|)
expr_stmt|;
if|if
condition|(
name|oiks_debug
operator|>
literal|1
condition|)
name|Debugger
argument_list|(
literal|"OIKS"
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_kse
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|kse_purge
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|KASSERT
argument_list|(
name|p
operator|->
name|p_numthreads
operator|==
literal|1
argument_list|,
operator|(
literal|"bad thread number"
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|kg
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|p
operator|->
name|p_ksegrps
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|ke
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|kg
operator|->
name|kg_iq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kg
operator|->
name|kg_iq
argument_list|,
name|ke
argument_list|,
name|ke_kgrlist
argument_list|)
expr_stmt|;
name|kg
operator|->
name|kg_idle_kses
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kg
operator|->
name|kg_kseq
argument_list|,
name|ke
argument_list|,
name|ke_kglist
argument_list|)
expr_stmt|;
name|kg
operator|->
name|kg_kses
operator|--
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_tdspare
condition|)
name|thread_stash
argument_list|(
name|ke
operator|->
name|ke_tdspare
argument_list|)
expr_stmt|;
name|kse_stash
argument_list|(
name|ke
argument_list|)
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|p
operator|->
name|p_ksegrps
argument_list|,
name|kg
argument_list|,
name|kg_ksegrp
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_numksegrps
operator|--
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|kg
operator|->
name|kg_kses
operator|==
literal|0
operator|)
operator|&&
operator|(
name|kg
operator|!=
name|td
operator|->
name|td_ksegrp
operator|)
operator|)
operator|||
operator|(
operator|(
name|kg
operator|->
name|kg_kses
operator|==
literal|1
operator|)
operator|&&
operator|(
name|kg
operator|==
name|td
operator|->
name|td_ksegrp
operator|)
operator|)
argument_list|,
operator|(
literal|"wrong kg_kses"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kg
operator|!=
name|td
operator|->
name|td_ksegrp
condition|)
block|{
name|ksegrp_stash
argument_list|(
name|kg
argument_list|)
expr_stmt|;
block|}
block|}
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|p
operator|->
name|p_ksegrps
argument_list|,
name|td
operator|->
name|td_ksegrp
argument_list|,
name|kg_ksegrp
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_numksegrps
operator|++
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a thread and schedule it for upcall on the KSE given.  */
end_comment

begin_function
name|struct
name|thread
modifier|*
name|thread_schedule_upcall
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td2
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|int
name|newkse
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|newkse
operator|=
operator|(
name|ke
operator|!=
name|td
operator|->
name|td_kse
operator|)
expr_stmt|;
comment|/*  	 * If the kse is already owned by another thread then we can't 	 * schedule an upcall because the other thread must be BOUND 	 * which means it is not in a position to take an upcall. 	 * We must be borrowing the KSE to allow us to complete some in-kernel 	 * work. When we complete, the Bound thread will have teh chance to  	 * complete. This thread will sleep as planned. Hopefully there will 	 * eventually be un unbound thread that can be converted to an 	 * upcall to report the completion of this thread. 	 */
if|if
condition|(
name|ke
operator|->
name|ke_bound
operator|&&
operator|(
operator|(
name|ke
operator|->
name|ke_bound
operator|->
name|td_flags
operator|&
name|TDF_UNBOUND
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|KASSERT
argument_list|(
operator|(
name|ke
operator|->
name|ke_bound
operator|==
name|NULL
operator|)
argument_list|,
operator|(
literal|"kse already bound"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_state
operator|==
name|KES_IDLE
condition|)
block|{
name|kg
operator|=
name|ke
operator|->
name|ke_ksegrp
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kg
operator|->
name|kg_iq
argument_list|,
name|ke
argument_list|,
name|ke_kgrlist
argument_list|)
expr_stmt|;
name|kg
operator|->
name|kg_idle_kses
operator|--
expr_stmt|;
name|ke
operator|->
name|ke_state
operator|=
name|KES_UNQUEUED
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|td2
operator|=
name|td
operator|->
name|td_standin
operator|)
operator|!=
name|NULL
condition|)
block|{
name|td
operator|->
name|td_standin
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|newkse
condition|)
name|panic
argument_list|(
literal|"no reserve thread when called with a new kse"
argument_list|)
expr_stmt|;
comment|/* 		 * If called from (e.g.) sleep and we do not have 		 * a reserve thread, then we've used it, so do not 		 * create an upcall. 		 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"thread_schedule_upcall: thread %p (pid %d, %s)"
argument_list|,
name|td2
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|td2
operator|->
name|td_startzero
argument_list|,
operator|(
name|unsigned
operator|)
name|RANGEOF
argument_list|(
expr|struct
name|thread
argument_list|,
name|td_startzero
argument_list|,
name|td_endzero
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|td
operator|->
name|td_startcopy
argument_list|,
operator|&
name|td2
operator|->
name|td_startcopy
argument_list|,
operator|(
name|unsigned
operator|)
name|RANGEOF
argument_list|(
expr|struct
name|thread
argument_list|,
name|td_startcopy
argument_list|,
name|td_endcopy
argument_list|)
argument_list|)
expr_stmt|;
name|thread_link
argument_list|(
name|td2
argument_list|,
name|ke
operator|->
name|ke_ksegrp
argument_list|)
expr_stmt|;
name|cpu_set_upcall
argument_list|(
name|td2
argument_list|,
name|td
operator|->
name|td_pcb
argument_list|)
expr_stmt|;
comment|/* 	 * XXXKSE do we really need this? (default values for the 	 * frame). 	 */
name|bcopy
argument_list|(
name|td
operator|->
name|td_frame
argument_list|,
name|td2
operator|->
name|td_frame
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|trapframe
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Bind the new thread to the KSE, 	 * and if it's our KSE, lend it back to ourself 	 * so we can continue running. 	 */
name|td2
operator|->
name|td_ucred
operator|=
name|crhold
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
name|td2
operator|->
name|td_flags
operator|=
name|TDF_UPCALLING
expr_stmt|;
comment|/* note: BOUND */
name|td2
operator|->
name|td_kse
operator|=
name|ke
expr_stmt|;
name|td2
operator|->
name|td_state
operator|=
name|TDS_CAN_RUN
expr_stmt|;
name|td2
operator|->
name|td_inhibitors
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If called from msleep(), we are working on the current 	 * KSE so fake that we borrowed it. If called from 	 * kse_create(), don't, as we have a new kse too. 	 */
if|if
condition|(
operator|!
name|newkse
condition|)
block|{
comment|/* 		 * This thread will be scheduled when the current thread 		 * blocks, exits or tries to enter userspace, (which ever 		 * happens first). When that happens the KSe will "revert" 		 * to this thread in a BOUND manner. Since we are called 		 * from msleep() this is going to be "very soon" in nearly 		 * all cases. 		 */
name|ke
operator|->
name|ke_bound
operator|=
name|td2
expr_stmt|;
name|TD_SET_LOAN
argument_list|(
name|td2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ke
operator|->
name|ke_bound
operator|=
name|NULL
expr_stmt|;
name|ke
operator|->
name|ke_thread
operator|=
name|td2
expr_stmt|;
name|ke
operator|->
name|ke_state
operator|=
name|KES_THREAD
expr_stmt|;
name|setrunqueue
argument_list|(
name|td2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|td2
operator|)
return|;
comment|/* bogus.. should be a void function */
block|}
end_function

begin_comment
comment|/*  * Schedule an upcall to notify a KSE process recieved signals.  *  * XXX - Modifying a sigset_t like this is totally bogus.  */
end_comment

begin_function
name|struct
name|thread
modifier|*
name|signal_upcall
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|int
name|sig
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|,
modifier|*
name|td2
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|sigset_t
name|ss
decl_stmt|;
name|int
name|error
decl_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
name|td
operator|=
name|FIRST_THREAD_IN_PROC
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
operator|&
name|ke
operator|->
name|ke_mailbox
operator|->
name|km_sigscaught
argument_list|,
operator|&
name|ss
argument_list|,
sizeof|sizeof
argument_list|(
name|sigset_t
argument_list|)
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|SIGADDSET
argument_list|(
name|ss
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|ss
argument_list|,
operator|&
name|ke
operator|->
name|ke_mailbox
operator|->
name|km_sigscaught
argument_list|,
sizeof|sizeof
argument_list|(
name|sigset_t
argument_list|)
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|td
operator|->
name|td_standin
operator|==
name|NULL
condition|)
name|td
operator|->
name|td_standin
operator|=
name|thread_alloc
argument_list|()
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|td2
operator|=
name|thread_schedule_upcall
argument_list|(
name|td
argument_list|,
name|ke
argument_list|)
expr_stmt|;
comment|/* Bogus JRE */
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|td2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * setup done on the thread when it enters the kernel.  * XXXKSE Presently only for syscalls but eventually all kernel entries.  */
end_comment

begin_function
name|void
name|thread_user_enter
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
comment|/* 	 * First check that we shouldn't just abort. 	 * But check if we are the single thread first! 	 * XXX p_singlethread not locked, but should be safe. 	 */
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_WEXIT
operator|)
operator|&&
operator|(
name|p
operator|->
name|p_singlethread
operator|!=
name|td
operator|)
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|thread_exit
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* 	 * If we are doing a syscall in a KSE environment, 	 * note where our mailbox is. There is always the 	 * possibility that we could do this lazily (in sleep()), 	 * but for now do it every time. 	 */
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_mailbox
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
literal|0
block|td->td_mailbox = (void *)fuword((caddr_t)ke->ke_mailbox 		    + offsetof(struct kse_mailbox, km_curthread));
else|#
directive|else
comment|/* if user pointer arithmetic is ok in the kernel */
name|td
operator|->
name|td_mailbox
operator|=
operator|(
name|void
operator|*
operator|)
name|fuword
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|ke
operator|->
name|ke_mailbox
operator|->
name|km_curthread
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|td
operator|->
name|td_mailbox
operator|==
name|NULL
operator|)
operator|||
operator|(
name|td
operator|->
name|td_mailbox
operator|==
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
name|td
operator|->
name|td_mailbox
operator|=
name|NULL
expr_stmt|;
comment|/* single thread it.. */
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_UNBOUND
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|td
operator|->
name|td_standin
operator|==
name|NULL
condition|)
name|td
operator|->
name|td_standin
operator|=
name|thread_alloc
argument_list|()
expr_stmt|;
name|td
operator|->
name|td_flags
operator||=
name|TDF_UNBOUND
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * The extra work we go through if we are a threaded process when we  * return to userland.  *  * If we are a KSE process and returning to user mode, check for  * extra work to do before we return (e.g. for more syscalls  * to complete first).  If we were in a critical section, we should  * just return to let it finish. Same if we were in the UTS (in  * which case the mailbox's context's busy indicator will be set).  * The only traps we suport will have set the mailbox.  * We will clear it here.  */
end_comment

begin_function
name|int
name|thread_userret
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|unbound
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|struct
name|thread
modifier|*
name|td2
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|unbound
operator|=
name|td
operator|->
name|td_flags
operator|&
name|TDF_UNBOUND
expr_stmt|;
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
comment|/* 	 * We need to check to see if we have to exit or wait due to a 	 * single threading requirement or some other STOP condition. 	 * Don't bother doing all the work if the stop bits are not set 	 * at this time.. If we miss it, we miss it.. no big deal. 	 */
if|if
condition|(
name|P_SHOULDSTOP
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|thread_suspend_check
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Can suspend or kill */
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Originally bound threads never upcall but they may  	 * loan out their KSE at this point. 	 * Upcalls imply bound.. They also may want to do some Philantropy. 	 * Unbound threads on the other hand either yield to other work 	 * or transform into an upcall. 	 * (having saved their context to user space in both cases) 	 */
if|if
condition|(
name|unbound
condition|)
block|{
comment|/* 		 * We are an unbound thread, looking to return to  		 * user space. 		 * THere are several possibilities: 		 * 1) we are using a borrowed KSE. save state and exit. 		 *    kse_reassign() will recycle the kse as needed, 		 * 2) we are not.. save state, and then convert ourself 		 *    to be an upcall, bound to the KSE. 		 *    if there are others that need the kse, 		 *    give them a chance by doing an mi_switch(). 		 *    Because we are bound, control will eventually return 		 *    to us here. 		 * *** 		 * Save the thread's context, and link it 		 * into the KSEGRP's list of completed threads. 		 */
name|error
operator|=
name|thread_export_context
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_mailbox
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 			 * If we are not running on a borrowed KSE, then 			 * failing to do the KSE operation just defaults 			 * back to synchonous operation, so just return from 			 * the syscall. If it IS borrowed, there is nothing 			 * we can do. We just lose that context. We 			 * probably should note this somewhere and send 			 * the process a signal. 			 */
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|SIGSEGV
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_kse
operator|->
name|ke_bound
operator|==
name|NULL
condition|)
block|{
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_UNBOUND
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
comment|/* go sync */
block|}
name|thread_exit
argument_list|()
expr_stmt|;
block|}
comment|/* 		 * if the KSE is owned and we are borrowing it, 		 * don't make an upcall, just exit so that the owner 		 * can get its KSE if it wants it. 		 * Our context is already safely stored for later 		 * use by the UTS. 		 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_kse
operator|->
name|ke_bound
condition|)
block|{
name|thread_exit
argument_list|()
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 		 * Turn ourself into a bound upcall. 		 * We will rely on kse_reassign() 		 * to make us run at a later time. 		 * We should look just like a sheduled upcall 		 * from msleep() or cv_wait(). 		 */
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_UNBOUND
expr_stmt|;
name|td
operator|->
name|td_flags
operator||=
name|TDF_UPCALLING
expr_stmt|;
comment|/* Only get here if we have become an upcall */
block|}
else|else
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
comment|/*  	 * We ARE going back to userland with this KSE. 	 * Check for threads that need to borrow it. 	 * Optimisation: don't call mi_switch if no-one wants the KSE. 	 * Any other thread that comes ready after this missed the boat. 	 */
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
if|if
condition|(
operator|(
name|td2
operator|=
name|kg
operator|->
name|kg_last_assigned
operator|)
condition|)
name|td2
operator|=
name|TAILQ_NEXT
argument_list|(
name|td2
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
else|else
name|td2
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|kg
operator|->
name|kg_runq
argument_list|)
expr_stmt|;
if|if
condition|(
name|td2
condition|)
block|{
comment|/*  		 * force a switch to more urgent 'in kernel' 		 * work. Control will return to this thread 		 * when there is no more work to do. 		 * kse_reassign() will do tha for us. 		 */
name|TD_SET_LOAN
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_bound
operator|=
name|td
expr_stmt|;
name|ke
operator|->
name|ke_thread
operator|=
name|NULL
expr_stmt|;
name|mi_switch
argument_list|()
expr_stmt|;
comment|/* kse_reassign() will (re)find td2 */
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Optimisation: 	 * Ensure that we have a spare thread available, 	 * for when we re-enter the kernel. 	 */
if|if
condition|(
name|td
operator|->
name|td_standin
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ke
operator|->
name|ke_tdspare
condition|)
block|{
name|td
operator|->
name|td_standin
operator|=
name|ke
operator|->
name|ke_tdspare
expr_stmt|;
name|ke
operator|->
name|ke_tdspare
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|td_standin
operator|=
name|thread_alloc
argument_list|()
expr_stmt|;
block|}
block|}
comment|/*  	 * To get here, we know there is no other need for our 	 * KSE so we can proceed. If not upcalling, go back to  	 * userspace. If we are, get the upcall set up. 	 */
if|if
condition|(
operator|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_UPCALLING
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  	 * We must be an upcall to get this far. 	 * There is no more work to do and we are going to ride 	 * this thead/KSE up to userland as an upcall. 	 * Do the last parts of the setup needed for the upcall. 	 */
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"userret: upcall thread %p (pid %d, %s)"
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
comment|/* 	 * Set user context to the UTS. 	 */
name|cpu_set_upcall_kse
argument_list|(
name|td
argument_list|,
name|ke
argument_list|)
expr_stmt|;
comment|/* 	 * Put any completed mailboxes on this KSE's list. 	 */
name|error
operator|=
name|thread_link_mboxes
argument_list|(
name|kg
argument_list|,
name|ke
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * Set state and mailbox. 	 * From now on we are just a bound outgoing process. 	 * **Problem** userret is often called several times. 	 * it would be nice if this all happenned only on the first time  	 * through. (the scan for extra work etc.) 	 */
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_UPCALLING
expr_stmt|;
if|#
directive|if
literal|0
block|error = suword((caddr_t)ke->ke_mailbox + 	    offsetof(struct kse_mailbox, km_curthread), 0);
else|#
directive|else
comment|/* if user pointer arithmetic is ok in the kernel */
name|error
operator|=
name|suword
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ke
operator|->
name|ke_mailbox
operator|->
name|km_curthread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|error
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
comment|/* 	 * Things are going to be so screwed we should just kill the process.  	 * how do we do that? 	 */
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|SIGSEGV
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
comment|/* go sync */
block|}
end_function

begin_comment
comment|/*  * Enforce single-threading.  *  * Returns 1 if the caller must abort (another thread is waiting to  * exit the process or similar). Process is locked!  * Returns 0 when you are successfully the only thread running.  * A process has successfully single threaded in the suspend mode when  * There are no threads in user mode. Threads in the kernel must be  * allowed to continue until they get to the user boundary. They may even  * copy out their return values and data before suspending. They may however be  * accellerated in reaching the user boundary as we will wake up  * any sleeping threads that are interruptable. (PCATCH).  */
end_comment

begin_function
name|int
name|thread_single
parameter_list|(
name|int
name|force_exit
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|thread
modifier|*
name|td2
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|td
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"curthread is NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_KSES
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Is someone already single threading? */
if|if
condition|(
name|p
operator|->
name|p_singlethread
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|force_exit
operator|==
name|SINGLE_EXIT
condition|)
name|p
operator|->
name|p_flag
operator||=
name|P_SINGLE_EXIT
expr_stmt|;
else|else
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_SINGLE_EXIT
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|P_STOPPED_SINGLE
expr_stmt|;
name|p
operator|->
name|p_singlethread
operator|=
name|td
expr_stmt|;
comment|/* XXXKSE Which lock protects the below values? */
while|while
condition|(
operator|(
name|p
operator|->
name|p_numthreads
operator|-
name|p
operator|->
name|p_suspcount
operator|)
operator|!=
literal|1
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|FOREACH_THREAD_IN_PROC
argument_list|(
argument|p
argument_list|,
argument|td2
argument_list|)
block|{
if|if
condition|(
name|td2
operator|==
name|td
condition|)
continue|continue;
if|if
condition|(
name|TD_IS_INHIBITED
argument_list|(
name|td2
argument_list|)
condition|)
block|{
if|if
condition|(
name|force_exit
operator|==
name|SINGLE_EXIT
condition|)
block|{
if|if
condition|(
name|TD_IS_SUSPENDED
argument_list|(
name|td2
argument_list|)
condition|)
block|{
name|thread_unsuspend_one
argument_list|(
name|td2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TD_ON_SLEEPQ
argument_list|(
name|td2
argument_list|)
operator|&&
operator|(
name|td2
operator|->
name|td_flags
operator|&
name|TDF_SINTR
operator|)
condition|)
block|{
if|if
condition|(
name|td2
operator|->
name|td_flags
operator|&
name|TDF_CVWAITQ
condition|)
name|cv_abort
argument_list|(
name|td2
argument_list|)
expr_stmt|;
else|else
name|abortsleep
argument_list|(
name|td2
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|TD_IS_SUSPENDED
argument_list|(
name|td2
argument_list|)
condition|)
continue|continue;
comment|/* maybe other inhibitted states too? */
if|if
condition|(
name|TD_IS_SLEEPING
argument_list|(
name|td2
argument_list|)
condition|)
name|thread_suspend_one
argument_list|(
name|td2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*  		 * Maybe we suspended some threads.. was it enough?  		 */
if|if
condition|(
operator|(
name|p
operator|->
name|p_numthreads
operator|-
name|p
operator|->
name|p_suspcount
operator|)
operator|==
literal|1
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Wake us up when everyone else has suspended. 		 * In the mean time we suspend as well. 		 */
name|thread_suspend_one
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mi_switch
argument_list|()
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|force_exit
operator|==
name|SINGLE_EXIT
condition|)
name|kse_purge
argument_list|(
name|p
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called in from locations that can safely check to see  * whether we have to suspend or at least throttle for a  * single-thread event (e.g. fork).  *  * Such locations include userret().  * If the "return_instead" argument is non zero, the thread must be able to  * accept 0 (caller may continue), or 1 (caller must abort) as a result.  *  * The 'return_instead' argument tells the function if it may do a  * thread_exit() or suspend, or whether the caller must abort and back  * out instead.  *  * If the thread that set the single_threading request has set the  * P_SINGLE_EXIT bit in the process flags then this call will never return  * if 'return_instead' is false, but will exit.  *  * P_SINGLE_EXIT | return_instead == 0| return_instead != 0  *---------------+--------------------+---------------------  *       0       | returns 0          |   returns 0 or 1  *               | when ST ends       |   immediatly  *---------------+--------------------+---------------------  *       1       | thread exits       |   returns 1  *               |                    |  immediatly  * 0 = thread_exit() or suspension ok,  * other = return error instead of stopping the thread.  *  * While a full suspension is under effect, even a single threading  * thread would be suspended if it made this call (but it shouldn't).  * This call should only be made from places where  * thread_exit() would be safe as that may be the outcome unless   * return_instead is set.  */
end_comment

begin_function
name|int
name|thread_suspend_check
parameter_list|(
name|int
name|return_instead
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
while|while
condition|(
name|P_SHOULDSTOP
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|P_SHOULDSTOP
argument_list|(
name|p
argument_list|)
operator|==
name|P_STOPPED_SINGLE
condition|)
block|{
name|KASSERT
argument_list|(
name|p
operator|->
name|p_singlethread
operator|!=
name|NULL
argument_list|,
operator|(
literal|"singlethread not set"
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * The only suspension in action is a 			 * single-threading. Single threader need not stop. 			 * XXX Should be safe to access unlocked  			 * as it can only be set to be true by us. 			 */
if|if
condition|(
name|p
operator|->
name|p_singlethread
operator|==
name|td
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Exempt from stopping. */
block|}
if|if
condition|(
name|return_instead
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 		 * If the process is waiting for us to exit, 		 * this thread should just suicide. 		 * Assumes that P_SINGLE_EXIT implies P_STOPPED_SINGLE. 		 */
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_SINGLE_EXIT
operator|)
operator|&&
operator|(
name|p
operator|->
name|p_singlethread
operator|!=
name|td
operator|)
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|mtx_owned
argument_list|(
operator|&
name|Giant
argument_list|)
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/*  			 * free extra kses and ksegrps, we needn't worry  			 * about if current thread is in same ksegrp as  			 * p_singlethread and last kse in the group 			 * could be killed, this is protected by kg_numthreads, 			 * in this case, we deduce that kg_numthreads must> 1. 			 */
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_bound
operator|==
name|NULL
operator|&&
operator|(
operator|(
name|kg
operator|->
name|kg_kses
operator|!=
literal|1
operator|)
operator|||
operator|(
name|kg
operator|->
name|kg_numthreads
operator|==
literal|1
operator|)
operator|)
condition|)
name|ke
operator|->
name|ke_flags
operator||=
name|KEF_EXIT
expr_stmt|;
name|thread_exit
argument_list|()
expr_stmt|;
block|}
comment|/* 		 * When a thread suspends, it just 		 * moves to the processes's suspend queue 		 * and stays there. 		 * 		 * XXXKSE if TDF_BOUND is true 		 * it will not release it's KSE which might 		 * lead to deadlock if there are not enough KSEs 		 * to complete all waiting threads. 		 * Maybe be able to 'lend' it out again. 		 * (lent kse's can not go back to userland?) 		 * and can only be lent in STOPPED state. 		 */
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_STOPPED_SIG
operator|)
operator|&&
operator|(
name|p
operator|->
name|p_suspcount
operator|+
literal|1
operator|==
name|p
operator|->
name|p_numthreads
operator|)
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
operator|->
name|p_pptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|p_pptr
operator|->
name|p_procsig
operator|->
name|ps_flag
operator|&
name|PS_NOCLDSTOP
operator|)
operator|==
literal|0
condition|)
block|{
name|psignal
argument_list|(
name|p
operator|->
name|p_pptr
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
operator|->
name|p_pptr
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|thread_suspend_one
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|P_SHOULDSTOP
argument_list|(
name|p
argument_list|)
operator|==
name|P_STOPPED_SINGLE
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_numthreads
operator|==
name|p
operator|->
name|p_suspcount
condition|)
block|{
name|thread_unsuspend_one
argument_list|(
name|p
operator|->
name|p_singlethread
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_nivcsw
operator|++
expr_stmt|;
name|mi_switch
argument_list|()
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|thread_suspend_one
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_suspcount
operator|++
expr_stmt|;
name|TD_SET_SUSPENDED
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|p
operator|->
name|p_suspended
argument_list|,
name|td
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
comment|/* 	 * Hack: If we are suspending but are on the sleep queue 	 * then we are in msleep or the cv equivalent. We 	 * want to look like we have two Inhibitors. 	 * May already be set.. doesn't matter. 	 */
if|if
condition|(
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
condition|)
name|TD_SET_SLEEPING
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|thread_unsuspend_one
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|p
operator|->
name|p_suspended
argument_list|,
name|td
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
name|TD_CLR_SUSPENDED
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_suspcount
operator|--
expr_stmt|;
name|setrunnable
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allow all threads blocked by single threading to continue running.  */
end_comment

begin_function
name|void
name|thread_unsuspend
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|P_SHOULDSTOP
argument_list|(
name|p
argument_list|)
condition|)
block|{
while|while
condition|(
operator|(
name|td
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|p
operator|->
name|p_suspended
argument_list|)
operator|)
condition|)
block|{
name|thread_unsuspend_one
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|P_SHOULDSTOP
argument_list|(
name|p
argument_list|)
operator|==
name|P_STOPPED_SINGLE
operator|)
operator|&&
operator|(
name|p
operator|->
name|p_numthreads
operator|==
name|p
operator|->
name|p_suspcount
operator|)
condition|)
block|{
comment|/* 		 * Stopping everything also did the job for the single 		 * threading request. Now we've downgraded to single-threaded, 		 * let it continue. 		 */
name|thread_unsuspend_one
argument_list|(
name|p
operator|->
name|p_singlethread
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|thread_single_end
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_STOPPED_SINGLE
expr_stmt|;
name|p
operator|->
name|p_singlethread
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If there are other threads they mey now run, 	 * unless of course there is a blanket 'stop order' 	 * on the process. The single threader must be allowed 	 * to continue however as this is a bad place to stop. 	 */
if|if
condition|(
operator|(
name|p
operator|->
name|p_numthreads
operator|!=
literal|1
operator|)
operator|&&
operator|(
operator|!
name|P_SHOULDSTOP
argument_list|(
name|p
argument_list|)
operator|)
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|td
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|p
operator|->
name|p_suspended
argument_list|)
operator|)
condition|)
block|{
name|thread_unsuspend_one
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

