begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Copyright (C) 2001 Julian Elischer<julian@freebsd.org>.  *  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice(s), this list of conditions and the following disclaimer as  *    the first lines of this file unmodified other than the possible   *    addition of one or more copyright notices.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice(s), this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) BE LIABLE FOR ANY  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kse.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_comment
comment|/*  * Thread related storage.  */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|thread_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|allocated_threads
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|active_threads
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cached_threads
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|threads
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"thread allocation"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_threads
argument_list|,
name|OID_AUTO
argument_list|,
name|active
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|active_threads
argument_list|,
literal|0
argument_list|,
literal|"Number of active threads in system."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_threads
argument_list|,
name|OID_AUTO
argument_list|,
name|cached
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|cached_threads
argument_list|,
literal|0
argument_list|,
literal|"Number of threads in thread cache."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_threads
argument_list|,
name|OID_AUTO
argument_list|,
name|allocated
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|allocated_threads
argument_list|,
literal|0
argument_list|,
literal|"Number of threads in zone."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|oiks_debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0 disable, 1 printf, 2 enter debugger */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_threads
argument_list|,
name|OID_AUTO
argument_list|,
name|oiks
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|oiks_debug
argument_list|,
literal|0
argument_list|,
literal|"OIKS thread debug"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|RANGEOF
parameter_list|(
name|type
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|)
value|(offsetof(type, end) - offsetof(type, start))
end_define

begin_decl_stmt
name|struct
name|threadqueue
name|zombie_threads
init|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|zombie_threads
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mtx
name|zombie_thread_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|zombie_thread_lock
argument_list|,
operator|&
name|zombie_thread_lock
argument_list|,
literal|"zombie_thread_lock"
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Pepare a thread for use.  */
end_comment

begin_function
specifier|static
name|void
name|thread_ctor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|size
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
operator|)
argument_list|,
operator|(
literal|"size mismatch: %d != %d\n"
operator|,
name|size
operator|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|td
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|mem
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|td
operator|->
name|td_startzero
argument_list|,
operator|(
name|unsigned
operator|)
name|RANGEOF
argument_list|(
expr|struct
name|thread
argument_list|,
name|td_startzero
argument_list|,
name|td_endzero
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_state
operator|=
name|TDS_NEW
expr_stmt|;
name|td
operator|->
name|td_flags
operator||=
name|TDF_UNBOUND
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 	 * Maybe move these here from process creation, but maybe not.    	 * Moving them here takes them away from their "natural" place 	 * in the fork process. 	 */
comment|/* XXX td_contested does not appear to be initialized for threads! */
block|LIST_INIT(&td->td_contested); 	callout_init(&td->td_slpcallout, 1);
endif|#
directive|endif
name|cached_threads
operator|--
expr_stmt|;
comment|/* XXXSMP */
name|active_threads
operator|++
expr_stmt|;
comment|/* XXXSMP */
block|}
end_function

begin_comment
comment|/*  * Reclaim a thread after use.  */
end_comment

begin_function
specifier|static
name|void
name|thread_dtor
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|size
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
operator|)
argument_list|,
operator|(
literal|"size mismatch: %d != %d\n"
operator|,
name|size
operator|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|td
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|mem
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
comment|/* Verify that this thread is in a safe state to free. */
switch|switch
condition|(
name|td
operator|->
name|td_state
condition|)
block|{
case|case
name|TDS_SLP
case|:
case|case
name|TDS_MTX
case|:
case|case
name|TDS_RUNQ
case|:
comment|/* 		 * We must never unlink a thread that is in one of 		 * these states, because it is currently active. 		 */
name|panic
argument_list|(
literal|"bad state for thread unlinking"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|TDS_UNQUEUED
case|:
case|case
name|TDS_NEW
case|:
case|case
name|TDS_RUNNING
case|:
case|case
name|TDS_SURPLUS
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"bad thread state"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
endif|#
directive|endif
comment|/* Update counters. */
name|active_threads
operator|--
expr_stmt|;
comment|/* XXXSMP */
name|cached_threads
operator|++
expr_stmt|;
comment|/* XXXSMP */
block|}
end_function

begin_comment
comment|/*  * Initialize type-stable parts of a thread (when newly created).  */
end_comment

begin_function
specifier|static
name|void
name|thread_init
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|size
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
operator|)
argument_list|,
operator|(
literal|"size mismatch: %d != %d\n"
operator|,
name|size
operator|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|td
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|mem
expr_stmt|;
name|pmap_new_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|cpu_thread_setup
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|cached_threads
operator|++
expr_stmt|;
comment|/* XXXSMP */
name|allocated_threads
operator|++
expr_stmt|;
comment|/* XXXSMP */
block|}
end_function

begin_comment
comment|/*  * Tear down type-stable parts of a thread (just before being discarded).  */
end_comment

begin_function
specifier|static
name|void
name|thread_fini
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|size
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
operator|)
argument_list|,
operator|(
literal|"size mismatch: %d != %d\n"
operator|,
name|size
operator|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|td
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|mem
expr_stmt|;
name|pmap_dispose_thread
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|cached_threads
operator|--
expr_stmt|;
comment|/* XXXSMP */
name|allocated_threads
operator|--
expr_stmt|;
comment|/* XXXSMP */
block|}
end_function

begin_comment
comment|/*  * Initialize global thread allocation resources.  */
end_comment

begin_function
name|void
name|threadinit
parameter_list|(
name|void
parameter_list|)
block|{
name|thread_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"THREAD"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
argument_list|,
name|thread_ctor
argument_list|,
name|thread_dtor
argument_list|,
name|thread_init
argument_list|,
name|thread_fini
argument_list|,
name|UMA_ALIGN_CACHE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stash an embarasingly esxtra thread into the zombie thread queue.  */
end_comment

begin_function
name|void
name|thread_stash
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|zombie_thread_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|zombie_threads
argument_list|,
name|td
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|zombie_thread_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * reap any  zombie threads for this Processor.  */
end_comment

begin_function
name|void
name|thread_reap
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td_reaped
decl_stmt|;
comment|/* 	 * don't even bother to lock if none at this instant 	 * We really don't care about the next instant.. 	 */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|zombie_threads
argument_list|)
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|zombie_thread_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|zombie_threads
argument_list|)
condition|)
block|{
name|td_reaped
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|zombie_threads
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|zombie_threads
argument_list|,
name|td_reaped
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|zombie_thread_lock
argument_list|)
expr_stmt|;
name|thread_free
argument_list|(
name|td_reaped
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|zombie_thread_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|zombie_thread_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a thread.  */
end_comment

begin_function
name|struct
name|thread
modifier|*
name|thread_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|thread_reap
argument_list|()
expr_stmt|;
comment|/* check if any zombies to get */
return|return
operator|(
name|uma_zalloc
argument_list|(
name|thread_zone
argument_list|,
name|M_WAITOK
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Deallocate a thread.  */
end_comment

begin_function
name|void
name|thread_free
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|uma_zfree
argument_list|(
name|thread_zone
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Store the thread context in the UTS's mailbox.  */
end_comment

begin_function
name|int
name|thread_export_context
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|uintptr_t
name|td2_mbx
decl_stmt|;
name|void
modifier|*
name|addr1
decl_stmt|;
name|void
modifier|*
name|addr2
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|__ia64__
name|td2_mbx
operator|=
literal|0
expr_stmt|;
comment|/* pacify gcc (!) */
endif|#
directive|endif
comment|/* Export the register contents. */
name|error
operator|=
name|cpu_export_context
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|addr1
operator|=
operator|(
name|caddr_t
operator|)
name|ke
operator|->
name|ke_mailbox
operator|+
name|offsetof
argument_list|(
expr|struct
name|kse_mailbox
argument_list|,
name|kmbx_completed_threads
argument_list|)
expr_stmt|;
name|addr2
operator|=
operator|(
name|caddr_t
operator|)
name|td
operator|->
name|td_mailbox
operator|+
name|offsetof
argument_list|(
expr|struct
name|thread_mailbox
argument_list|,
name|next_completed
argument_list|)
expr_stmt|;
comment|/* Then link it into it's KSE's list of completed threads. */
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|td2_mbx
operator|=
name|fuword
argument_list|(
name|addr1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
name|error
operator|=
name|EFAULT
expr_stmt|;
else|else
name|error
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|suword
argument_list|(
name|addr2
argument_list|,
name|td2_mbx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|suword
argument_list|(
name|addr1
argument_list|,
operator|(
name|u_long
operator|)
name|td
operator|->
name|td_mailbox
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
condition|)
name|error
operator|=
name|EFAULT
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Discard the current thread and exit from its context.  *  * Because we can't free a thread while we're operating under its context,  * push the current thread into our KSE's ke_tdspare slot, freeing the  * thread that might be there currently. Because we know that only this  * processor will run our KSE, we needn't worry about someone else grabbing  * our context before we do a cpu_throw.  */
end_comment

begin_function
name|void
name|thread_exit
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_PROC
argument_list|,
literal|"thread_exit: thread %p"
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|mtx_owned
argument_list|(
operator|&
name|Giant
argument_list|)
argument_list|,
operator|(
literal|"dying thread owns giant"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_tdspare
operator|!=
name|NULL
condition|)
block|{
name|thread_stash
argument_list|(
name|ke
operator|->
name|ke_tdspare
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_tdspare
operator|=
name|NULL
expr_stmt|;
block|}
name|cpu_thread_exit
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* XXXSMP */
comment|/* Reassign this thread's KSE. */
if|if
condition|(
name|ke
operator|!=
name|NULL
condition|)
block|{
name|ke
operator|->
name|ke_thread
operator|=
name|NULL
expr_stmt|;
name|td
operator|->
name|td_kse
operator|=
name|NULL
expr_stmt|;
name|ke
operator|->
name|ke_state
operator|=
name|KES_UNQUEUED
expr_stmt|;
name|kse_reassign
argument_list|(
name|ke
argument_list|)
expr_stmt|;
block|}
comment|/* Unlink this thread from its proc. and the kseg */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|p
operator|->
name|p_threads
argument_list|,
name|td
argument_list|,
name|td_plist
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_numthreads
operator|--
expr_stmt|;
if|if
condition|(
name|kg
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kg
operator|->
name|kg_threads
argument_list|,
name|td
argument_list|,
name|td_kglist
argument_list|)
expr_stmt|;
name|kg
operator|->
name|kg_numthreads
operator|--
expr_stmt|;
block|}
comment|/* 		 * The test below is NOT true if we are the 		 * sole exiting thread. P_STOPPED_SNGL is unset 		 * in exit1() after it is the only survivor. 		 */
if|if
condition|(
name|P_SHOULDSTOP
argument_list|(
name|p
argument_list|)
operator|==
name|P_STOPPED_SNGL
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_numthreads
operator|==
name|p
operator|->
name|p_suspcount
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|p
operator|->
name|p_suspended
argument_list|,
name|p
operator|->
name|p_singlethread
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
name|setrunqueue
argument_list|(
name|p
operator|->
name|p_singlethread
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_suspcount
operator|--
expr_stmt|;
block|}
block|}
block|}
name|td
operator|->
name|td_state
operator|=
name|TDS_SURPLUS
expr_stmt|;
name|td
operator|->
name|td_proc
operator|=
name|NULL
expr_stmt|;
name|td
operator|->
name|td_ksegrp
operator|=
name|NULL
expr_stmt|;
name|td
operator|->
name|td_last_kse
operator|=
name|NULL
expr_stmt|;
name|ke
operator|->
name|ke_tdspare
operator|=
name|td
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cpu_throw
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Link a thread to a process.  *  * Note that we do not link to the proc's ucred here.  * The thread is linked as if running but no KSE assigned.  */
end_comment

begin_function
name|void
name|thread_link
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|kg
operator|->
name|kg_proc
expr_stmt|;
name|td
operator|->
name|td_state
operator|=
name|TDS_NEW
expr_stmt|;
name|td
operator|->
name|td_proc
operator|=
name|p
expr_stmt|;
name|td
operator|->
name|td_ksegrp
operator|=
name|kg
expr_stmt|;
name|td
operator|->
name|td_last_kse
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|p
operator|->
name|p_threads
argument_list|,
name|td
argument_list|,
name|td_plist
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|kg
operator|->
name|kg_threads
argument_list|,
name|td
argument_list|,
name|td_kglist
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_numthreads
operator|++
expr_stmt|;
name|kg
operator|->
name|kg_numthreads
operator|++
expr_stmt|;
if|if
condition|(
name|oiks_debug
operator|&&
name|p
operator|->
name|p_numthreads
operator|>
literal|4
condition|)
block|{
name|printf
argument_list|(
literal|"OIKS %d\n"
argument_list|,
name|p
operator|->
name|p_numthreads
argument_list|)
expr_stmt|;
if|if
condition|(
name|oiks_debug
operator|>
literal|1
condition|)
name|Debugger
argument_list|(
literal|"OIKS"
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_critnest
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_kse
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up the upcall pcb in either a given thread or a new one  * if none given. Use the upcall for the given KSE  * XXXKSE possibly fix cpu_set_upcall() to not need td->td_kse set.  */
end_comment

begin_function
name|struct
name|thread
modifier|*
name|thread_schedule_upcall
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td2
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_tdspare
operator|!=
name|NULL
condition|)
block|{
name|td2
operator|=
name|ke
operator|->
name|ke_tdspare
expr_stmt|;
name|ke
operator|->
name|ke_tdspare
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|td2
operator|=
name|thread_alloc
argument_list|()
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"thread_schedule_upcall: thread %p (pid %d, %s)"
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|thread_link
argument_list|(
name|td2
argument_list|,
name|ke
operator|->
name|ke_ksegrp
argument_list|)
expr_stmt|;
name|cpu_set_upcall
argument_list|(
name|td2
argument_list|,
name|ke
operator|->
name|ke_pcb
argument_list|)
expr_stmt|;
name|td2
operator|->
name|td_ucred
operator|=
name|crhold
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
name|td2
operator|->
name|td_flags
operator|=
name|TDF_UNBOUND
operator||
name|TDF_UPCALLING
expr_stmt|;
name|td2
operator|->
name|td_priority
operator|=
name|td
operator|->
name|td_priority
expr_stmt|;
name|setrunqueue
argument_list|(
name|td2
argument_list|)
expr_stmt|;
return|return
operator|(
name|td2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The extra work we go through if we are a threaded process when we   * return to userland  *  * If we are a KSE process and returning to user mode, check for  * extra work to do before we return (e.g. for more syscalls  * to complete first).  If we were in a critical section, we should  * just return to let it finish. Same if we were in the UTS (in  * which case we will have no thread mailbox registered).  The only  * traps we suport will have set the mailbox.  We will clear it here.  */
end_comment

begin_function
name|int
name|thread_userret
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|,
name|struct
name|kse
modifier|*
name|ke
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_tdspare
operator|==
name|NULL
condition|)
block|{
name|ke
operator|->
name|ke_tdspare
operator|=
name|thread_alloc
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_UNBOUND
condition|)
block|{
comment|/* 		 * Are we returning from a thread that had a mailbox? 		 * 		 * XXX Maybe this should be in a separate function. 		 */
if|if
condition|(
operator|(
operator|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_UPCALLING
operator|)
operator|==
literal|0
operator|)
operator|&&
name|td
operator|->
name|td_mailbox
condition|)
block|{
comment|/* 			 * [XXXKSE Future enhancement] 			 * We could also go straight back to the syscall 			 * if we never had to do an upcall since then. 			 * If the KSE's copy is == the thread's copy.. 			 * AND there are no other completed threads. 			 */
comment|/* 			 * We will go back as an upcall or go do another thread. 			 * Either way we need to save the context back to 			 * the user thread mailbox. 			 * So the UTS can restart it later. 			 */
name|error
operator|=
name|thread_export_context
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_mailbox
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 				 * Failing to do the KSE 				 * operation just defaults operation 				 * back to synchonous operation. 				 */
goto|goto
name|cont
goto|;
block|}
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|kg
operator|->
name|kg_runq
argument_list|)
condition|)
block|{
comment|/* 				 * Uh-oh.. don't return to the user. 				 * Instead, switch to the thread that 				 * needs to run. The question is: 				 * What do we do with the thread we have now? 				 * We have put the completion block 				 * on the kse mailbox. If we had more energy, 				 * we could lazily do so, assuming someone 				 * else might get to userland earlier 				 * and deliver it earlier than we could. 				 * To do that we could save it off the KSEG. 				 * An upcalling KSE would 'reap' all completed 				 * threads. 				 * Being in a hurry, we'll do nothing and 				 * leave it on the current KSE for now. 				 * 				 * As for the other threads to run; 				 * we COULD rush through all the threads 				 * in this KSEG at this priority, or we 				 * could throw the ball back into the court 				 * and just run the highest prio kse available. 				 * What is OUR priority? 				 * the priority of the highest sycall waiting 				 * to be returned? 				 * For now, just let another KSE run (easiest). 				 */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|thread_exit
argument_list|()
expr_stmt|;
comment|/* Abandon current thread. */
comment|/* NOTREACHED */
block|}
else|else
block|{
comment|/* if (number of returning syscalls = 1) */
comment|/* 				 * Swap our frame for the upcall frame. 				 * 				 * XXXKSE Assumes we are going to user land 				 * and not nested in the kernel 				 */
name|td
operator|->
name|td_flags
operator||=
name|TDF_UPCALLING
expr_stmt|;
block|}
block|}
comment|/* 		 * This is NOT just an 'else' clause for the above test... 		 */
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_UPCALLING
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"userret: upcall thread %p (pid %d, %s)"
argument_list|,
name|td
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
comment|/* 			 * Make sure that it has the correct frame loaded. 			 * While we know that we are on the same KSEGRP 			 * as we were created on, we could very easily 			 * have come in on another KSE. We therefore need 			 * to do the copy of the frame after the last 			 * possible switch() (the one above). 			 */
name|bcopy
argument_list|(
name|ke
operator|->
name|ke_frame
argument_list|,
name|frame
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|trapframe
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Decide what we are sending to the user 			 * upcall sets one argument. The address of the mbox. 			 */
name|cpu_set_args
argument_list|(
name|td
argument_list|,
name|ke
argument_list|)
expr_stmt|;
comment|/* 			 * There is no more work to do and we are going to ride 			 * this thead/KSE up to userland. Make sure the user's 			 * pointer to the thread mailbox is cleared before we 			 * re-enter the kernel next time for any reason.. 			 * We might as well do it here. 			 */
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_UPCALLING
expr_stmt|;
comment|/* Hmmmm. */
name|error
operator|=
name|suword
argument_list|(
operator|(
name|caddr_t
operator|)
name|td
operator|->
name|td_kse
operator|->
name|ke_mailbox
operator|+
name|offsetof
argument_list|(
expr|struct
name|kse_mailbox
argument_list|,
name|kmbx_current_thread
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Stop any chance that we may be separated from 		 * the KSE we are currently on. This is "biting the bullet", 		 * we are committing to go to user space as as THIS KSE here. 		 */
name|cont
label|:
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_UNBOUND
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enforce single-threading.  *  * Returns 1 if the caller must abort (another thread is waiting to  * exit the process or similar). Process is locked!  * Returns 0 when you are successfully the only thread running.  * A process has successfully single threaded in the suspend mode when  * There are no threads in user mode. Threads in the kernel must be  * allowed to continue until they get to the user boundary. They may even  * copy out their return values and data before suspending. They may however be  * accellerated in reaching the user boundary as we will wake up  * any sleeping threads that are interruptable. (PCATCH).  */
end_comment

begin_function
name|int
name|thread_single
parameter_list|(
name|int
name|force_exit
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|thread
modifier|*
name|td2
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|td
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"curthread is NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_KSES
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|p_singlethread
condition|)
block|{
comment|/* 		 * Someone is already single threading! 		 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|force_exit
operator|==
name|SNGLE_EXIT
condition|)
name|p
operator|->
name|p_flag
operator||=
name|P_SINGLE_EXIT
expr_stmt|;
else|else
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_SINGLE_EXIT
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|P_STOPPED_SNGL
expr_stmt|;
name|p
operator|->
name|p_singlethread
operator|=
name|td
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|->
name|p_numthreads
operator|-
name|p
operator|->
name|p_suspcount
operator|)
operator|!=
literal|1
condition|)
block|{
name|FOREACH_THREAD_IN_PROC
argument_list|(
argument|p
argument_list|,
argument|td2
argument_list|)
block|{
if|if
condition|(
name|td2
operator|==
name|td
condition|)
continue|continue;
switch|switch
condition|(
name|td2
operator|->
name|td_state
condition|)
block|{
case|case
name|TDS_SUSPENDED
case|:
if|if
condition|(
name|force_exit
operator|==
name|SNGLE_EXIT
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|p
operator|->
name|p_suspended
argument_list|,
name|td
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
name|setrunqueue
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* Should suicide. */
block|}
case|case
name|TDS_SLP
case|:
if|if
condition|(
name|td2
operator|->
name|td_flags
operator|&
name|TDF_CVWAITQ
condition|)
block|{
name|cv_abort
argument_list|(
name|td2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|abortsleep
argument_list|(
name|td2
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* etc. XXXKSE */
default|default:
empty_stmt|;
block|}
block|}
comment|/* 		 * XXXKSE-- idea 		 * It's possible that we can just wake up when 		 * there are no runnable KSEs, because that would 		 * indicate that only this thread is runnable and 		 * there are no running KSEs in userland. 		 * -- 		 * Wake us up when everyone else has suspended. 		 * (or died) 		 */
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|p
operator|->
name|p_suspended
argument_list|,
name|td
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_state
operator|=
name|TDS_SUSPENDED
expr_stmt|;
name|p
operator|->
name|p_suspcount
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mi_switch
argument_list|()
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called in from locations that can safely check to see  * whether we have to suspend or at least throttle for a  * single-thread event (e.g. fork).  *  * Such locations include userret().  * If the "return_instead" argument is non zero, the thread must be able to  * accept 0 (caller may continue), or 1 (caller must abort) as a result.  *  * The 'return_instead' argument tells the function if it may do a  * thread_exit() or suspend, or whether the caller must abort and back  * out instead.  *  * If the thread that set the single_threading request has set the  * P_SINGLE_EXIT bit in the process flags then this call will never return  * if 'return_instead' is false, but will exit.  *  * P_SINGLE_EXIT | return_instead == 0| return_instead != 0  *---------------+--------------------+---------------------  *       0       | returns 0          |   returns 0 or 1  *               | when ST ends       |   immediatly  *---------------+--------------------+---------------------  *       1       | thread exits       |   returns 1  *               |                    |  immediatly  * 0 = thread_exit() or suspension ok,  * other = return error instead of stopping the thread.  *  * While a full suspension is under effect, even a single threading  * thread would be suspended if it made this call (but it shouldn't).  * This call should only be made from places where  * thread_exit() would be safe as that may be the outcome unless   * return_instead is set.  */
end_comment

begin_function
name|int
name|thread_suspend_check
parameter_list|(
name|int
name|return_instead
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
while|while
condition|(
name|P_SHOULDSTOP
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|P_SHOULDSTOP
argument_list|(
name|p
argument_list|)
operator|==
name|P_STOPPED_SNGL
condition|)
block|{
name|KASSERT
argument_list|(
name|p
operator|->
name|p_singlethread
operator|!=
name|NULL
argument_list|,
operator|(
literal|"singlethread not set"
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * The only suspension in action is 			 * a single-threading. Treat it ever 			 * so slightly different if it is 			 * in a special situation. 			 */
if|if
condition|(
name|p
operator|->
name|p_singlethread
operator|==
name|td
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Exempt from stopping. */
block|}
block|}
if|if
condition|(
name|return_instead
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * If the process is waiting for us to exit, 		 * this thread should just suicide. 		 * Assumes that P_SINGLE_EXIT implies P_STOPPED_SNGL. 		 */
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_SINGLE_EXIT
operator|)
operator|&&
operator|(
name|p
operator|->
name|p_singlethread
operator|!=
name|td
operator|)
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|mtx_owned
argument_list|(
operator|&
name|Giant
argument_list|)
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|thread_exit
argument_list|()
expr_stmt|;
block|}
comment|/* 		 * When a thread suspends, it just 		 * moves to the processes's suspend queue 		 * and stays there. 		 * 		 * XXXKSE if TDF_BOUND is true 		 * it will not release it's KSE which might 		 * lead to deadlock if there are not enough KSEs 		 * to complete all waiting threads. 		 * Maybe be able to 'lend' it out again. 		 * (lent kse's can not go back to userland?) 		 * and can only be lent in STOPPED state. 		 */
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_suspcount
operator|++
expr_stmt|;
name|td
operator|->
name|td_state
operator|=
name|TDS_SUSPENDED
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|p
operator|->
name|p_suspended
argument_list|,
name|td
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mi_switch
argument_list|()
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allow all threads blocked by single threading to continue running.  */
end_comment

begin_function
name|void
name|thread_unsuspend
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|P_SHOULDSTOP
argument_list|(
name|p
argument_list|)
condition|)
block|{
while|while
condition|(
operator|(
name|td
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|p
operator|->
name|p_suspended
argument_list|)
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|p
operator|->
name|p_suspended
argument_list|,
name|td
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_suspcount
operator|--
expr_stmt|;
name|setrunqueue
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|P_SHOULDSTOP
argument_list|(
name|p
argument_list|)
operator|==
name|P_STOPPED_SNGL
operator|)
operator|&&
operator|(
name|p
operator|->
name|p_numthreads
operator|==
name|p
operator|->
name|p_suspcount
operator|)
condition|)
block|{
comment|/* 		 * Stopping everything also did the job for the single 		 * threading request. Now we've downgraded to single-threaded, 		 * let it continue. 		 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|p
operator|->
name|p_suspended
argument_list|,
name|p
operator|->
name|p_singlethread
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_suspcount
operator|--
expr_stmt|;
name|setrunqueue
argument_list|(
name|p
operator|->
name|p_singlethread
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|thread_single_end
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_STOPPED_SNGL
expr_stmt|;
name|p
operator|->
name|p_singlethread
operator|=
name|NULL
expr_stmt|;
name|thread_unsuspend
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

