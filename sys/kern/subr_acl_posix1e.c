begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999, 2000, 2001, 2002 Robert N. M. Watson  * All rights reserved.  *  * This software was developed by Robert Watson for the TrustedBSD Project.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Developed by the TrustedBSD Project.  * Support for POSIX.1e access control lists.  */
end_comment

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mac.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/acl.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_ACL
argument_list|,
literal|"acl"
argument_list|,
literal|"access control list"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|vacl_set_acl
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|acl_type_t
name|type
parameter_list|,
name|struct
name|acl
modifier|*
name|aclp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vacl_get_acl
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|acl_type_t
name|type
parameter_list|,
name|struct
name|acl
modifier|*
name|aclp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|vacl_aclcheck
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|acl_type_t
name|type
parameter_list|,
name|struct
name|acl
modifier|*
name|aclp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Implement a version of vaccess() that understands POSIX.1e ACL semantics.  * Return 0 on success, else an errno value.  Should be merged into  * vaccess() eventually.  */
end_comment

begin_function
name|int
name|vaccess_acl_posix1e
parameter_list|(
name|enum
name|vtype
name|type
parameter_list|,
name|uid_t
name|file_uid
parameter_list|,
name|gid_t
name|file_gid
parameter_list|,
name|struct
name|acl
modifier|*
name|acl
parameter_list|,
name|mode_t
name|acc_mode
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
modifier|*
name|privused
parameter_list|)
block|{
name|struct
name|acl_entry
modifier|*
name|acl_other
decl_stmt|,
modifier|*
name|acl_mask
decl_stmt|;
name|mode_t
name|dac_granted
decl_stmt|;
name|mode_t
name|cap_granted
decl_stmt|;
name|mode_t
name|acl_mask_granted
decl_stmt|;
name|int
name|group_matched
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Look for a normal, non-privileged way to access the file/directory 	 * as requested.  If it exists, go with that.  Otherwise, attempt 	 * to use privileges granted via cap_granted.  In some cases, 	 * which privileges to use may be ambiguous due to "best match", 	 * in which case fall back on first match for the time being. 	 */
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Determine privileges now, but don't apply until we've found 	 * a DAC entry that matches but has failed to allow access. 	 */
ifndef|#
directive|ifndef
name|CAPABILITIES
if|if
condition|(
name|suser_cred
argument_list|(
name|cred
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|==
literal|0
condition|)
name|cap_granted
operator|=
name|VALLPERM
expr_stmt|;
else|else
name|cap_granted
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|cap_granted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|VDIR
condition|)
block|{
if|if
condition|(
operator|(
name|acc_mode
operator|&
name|VEXEC
operator|)
operator|&&
operator|!
name|cap_check
argument_list|(
name|cred
argument_list|,
name|NULL
argument_list|,
name|CAP_DAC_READ_SEARCH
argument_list|,
name|PRISON_ROOT
argument_list|)
condition|)
name|cap_granted
operator||=
name|VEXEC
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|acc_mode
operator|&
name|VEXEC
operator|)
operator|&&
operator|!
name|cap_check
argument_list|(
name|cred
argument_list|,
name|NULL
argument_list|,
name|CAP_DAC_EXECUTE
argument_list|,
name|PRISON_ROOT
argument_list|)
condition|)
name|cap_granted
operator||=
name|VEXEC
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|acc_mode
operator|&
name|VREAD
operator|)
operator|&&
operator|!
name|cap_check
argument_list|(
name|cred
argument_list|,
name|NULL
argument_list|,
name|CAP_DAC_READ_SEARCH
argument_list|,
name|PRISON_ROOT
argument_list|)
condition|)
name|cap_granted
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|acc_mode
operator|&
name|VWRITE
operator|)
operator|||
operator|(
name|acc_mode
operator|&
name|VAPPEND
operator|)
operator|)
operator|&&
operator|!
name|cap_check
argument_list|(
name|cred
argument_list|,
name|NULL
argument_list|,
name|CAP_DAC_WRITE
argument_list|,
name|PRISON_ROOT
argument_list|)
condition|)
name|cap_granted
operator||=
operator|(
name|VWRITE
operator||
name|VAPPEND
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|acc_mode
operator|&
name|VADMIN
operator|)
operator|&&
operator|!
name|cap_check
argument_list|(
name|cred
argument_list|,
name|NULL
argument_list|,
name|CAP_FOWNER
argument_list|,
name|PRISON_ROOT
argument_list|)
condition|)
name|cap_granted
operator||=
name|VADMIN
expr_stmt|;
endif|#
directive|endif
comment|/* CAPABILITIES */
comment|/* 	 * The owner matches if the effective uid associated with the 	 * credential matches that of the ACL_USER_OBJ entry.  While we're 	 * doing the first scan, also cache the location of the ACL_MASK 	 * and ACL_OTHER entries, preventing some future iterations. 	 */
name|acl_mask
operator|=
name|acl_other
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acl
operator|->
name|acl_cnt
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_tag
condition|)
block|{
case|case
name|ACL_USER_OBJ
case|:
if|if
condition|(
name|file_uid
operator|!=
name|cred
operator|->
name|cr_uid
condition|)
break|break;
name|dac_granted
operator|=
literal|0
expr_stmt|;
name|dac_granted
operator||=
name|VADMIN
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
name|dac_granted
operator||=
name|VEXEC
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_READ
condition|)
name|dac_granted
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_WRITE
condition|)
name|dac_granted
operator||=
operator|(
name|VWRITE
operator||
name|VAPPEND
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|acc_mode
operator|&
name|dac_granted
operator|)
operator|==
name|acc_mode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|acc_mode
operator|&
operator|(
name|dac_granted
operator||
name|cap_granted
operator|)
operator|)
operator|==
name|acc_mode
condition|)
block|{
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
goto|goto
name|error
goto|;
case|case
name|ACL_MASK
case|:
name|acl_mask
operator|=
operator|&
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|ACL_OTHER
case|:
name|acl_other
operator|=
operator|&
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* 	 * An ACL_OTHER entry should always exist in a valid access 	 * ACL.  If it doesn't, then generate a serious failure.  For now, 	 * this means a debugging message and EPERM, but in the future 	 * should probably be a panic. 	 */
if|if
condition|(
name|acl_other
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * XXX This should never happen 		 */
name|printf
argument_list|(
literal|"vaccess_acl_posix1e: ACL_OTHER missing\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
comment|/* 	 * Checks against ACL_USER, ACL_GROUP_OBJ, and ACL_GROUP fields 	 * are masked by an ACL_MASK entry, if any.  As such, first identify 	 * the ACL_MASK field, then iterate through identifying potential 	 * user matches, then group matches.  If there is no ACL_MASK, 	 * assume that the mask allows all requests to succeed. 	 */
if|if
condition|(
name|acl_mask
operator|!=
name|NULL
condition|)
block|{
name|acl_mask_granted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acl_mask
operator|->
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
name|acl_mask_granted
operator||=
name|VEXEC
expr_stmt|;
if|if
condition|(
name|acl_mask
operator|->
name|ae_perm
operator|&
name|ACL_READ
condition|)
name|acl_mask_granted
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
name|acl_mask
operator|->
name|ae_perm
operator|&
name|ACL_WRITE
condition|)
name|acl_mask_granted
operator||=
operator|(
name|VWRITE
operator||
name|VAPPEND
operator|)
expr_stmt|;
block|}
else|else
name|acl_mask_granted
operator|=
name|VEXEC
operator||
name|VREAD
operator||
name|VWRITE
operator||
name|VAPPEND
expr_stmt|;
comment|/* 	 * Iterate through user ACL entries.  Do checks twice, first 	 * without privilege, and then if a match is found but failed, 	 * a second time with privilege. 	 */
comment|/* 	 * Check ACL_USER ACL entries. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acl
operator|->
name|acl_cnt
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_tag
condition|)
block|{
case|case
name|ACL_USER
case|:
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
operator|!=
name|cred
operator|->
name|cr_uid
condition|)
break|break;
name|dac_granted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
name|dac_granted
operator||=
name|VEXEC
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_READ
condition|)
name|dac_granted
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_WRITE
condition|)
name|dac_granted
operator||=
operator|(
name|VWRITE
operator||
name|VAPPEND
operator|)
expr_stmt|;
name|dac_granted
operator|&=
name|acl_mask_granted
expr_stmt|;
if|if
condition|(
operator|(
name|acc_mode
operator|&
name|dac_granted
operator|)
operator|==
name|acc_mode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|acc_mode
operator|&
operator|(
name|dac_granted
operator||
name|cap_granted
operator|)
operator|)
operator|!=
name|acc_mode
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * Group match is best-match, not first-match, so find a  	 * "best" match.  Iterate across, testing each potential group 	 * match.  Make sure we keep track of whether we found a match 	 * or not, so that we know if we should try again with any 	 * available privilege, or if we should move on to ACL_OTHER. 	 */
name|group_matched
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acl
operator|->
name|acl_cnt
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_tag
condition|)
block|{
case|case
name|ACL_GROUP_OBJ
case|:
if|if
condition|(
operator|!
name|groupmember
argument_list|(
name|file_gid
argument_list|,
name|cred
argument_list|)
condition|)
break|break;
name|dac_granted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
name|dac_granted
operator||=
name|VEXEC
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_READ
condition|)
name|dac_granted
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_WRITE
condition|)
name|dac_granted
operator||=
operator|(
name|VWRITE
operator||
name|VAPPEND
operator|)
expr_stmt|;
name|dac_granted
operator|&=
name|acl_mask_granted
expr_stmt|;
if|if
condition|(
operator|(
name|acc_mode
operator|&
name|dac_granted
operator|)
operator|==
name|acc_mode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|group_matched
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ACL_GROUP
case|:
if|if
condition|(
operator|!
name|groupmember
argument_list|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
argument_list|,
name|cred
argument_list|)
condition|)
break|break;
name|dac_granted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
name|dac_granted
operator||=
name|VEXEC
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_READ
condition|)
name|dac_granted
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_WRITE
condition|)
name|dac_granted
operator||=
operator|(
name|VWRITE
operator||
name|VAPPEND
operator|)
expr_stmt|;
name|dac_granted
operator|&=
name|acl_mask_granted
expr_stmt|;
if|if
condition|(
operator|(
name|acc_mode
operator|&
name|dac_granted
operator|)
operator|==
name|acc_mode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|group_matched
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|group_matched
operator|==
literal|1
condition|)
block|{
comment|/* 		 * There was a match, but it did not grant rights via 		 * pure DAC.  Try again, this time with privilege. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acl
operator|->
name|acl_cnt
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_tag
condition|)
block|{
case|case
name|ACL_GROUP_OBJ
case|:
if|if
condition|(
operator|!
name|groupmember
argument_list|(
name|file_gid
argument_list|,
name|cred
argument_list|)
condition|)
break|break;
name|dac_granted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
name|dac_granted
operator||=
name|VEXEC
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_READ
condition|)
name|dac_granted
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_WRITE
condition|)
name|dac_granted
operator||=
operator|(
name|VWRITE
operator||
name|VAPPEND
operator|)
expr_stmt|;
name|dac_granted
operator|&=
name|acl_mask_granted
expr_stmt|;
if|if
condition|(
operator|(
name|acc_mode
operator|&
operator|(
name|dac_granted
operator||
name|cap_granted
operator|)
operator|)
operator|!=
name|acc_mode
condition|)
break|break;
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ACL_GROUP
case|:
if|if
condition|(
operator|!
name|groupmember
argument_list|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
argument_list|,
name|cred
argument_list|)
condition|)
break|break;
name|dac_granted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
name|dac_granted
operator||=
name|VEXEC
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_READ
condition|)
name|dac_granted
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_WRITE
condition|)
name|dac_granted
operator||=
operator|(
name|VWRITE
operator||
name|VAPPEND
operator|)
expr_stmt|;
name|dac_granted
operator|&=
name|acl_mask_granted
expr_stmt|;
if|if
condition|(
operator|(
name|acc_mode
operator|&
operator|(
name|dac_granted
operator||
name|cap_granted
operator|)
operator|)
operator|!=
name|acc_mode
condition|)
break|break;
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
break|break;
block|}
block|}
comment|/* 		 * Even with privilege, group membership was not sufficient. 		 * Return failure. 		 */
goto|goto
name|error
goto|;
block|}
comment|/* 	 * Fall back on ACL_OTHER.  ACL_MASK is not applied to ACL_OTHER. 	 */
name|dac_granted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acl_other
operator|->
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
name|dac_granted
operator||=
name|VEXEC
expr_stmt|;
if|if
condition|(
name|acl_other
operator|->
name|ae_perm
operator|&
name|ACL_READ
condition|)
name|dac_granted
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
name|acl_other
operator|->
name|ae_perm
operator|&
name|ACL_WRITE
condition|)
name|dac_granted
operator||=
operator|(
name|VWRITE
operator||
name|VAPPEND
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|acc_mode
operator|&
name|dac_granted
operator|)
operator|==
name|acc_mode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|acc_mode
operator|&
operator|(
name|dac_granted
operator||
name|cap_granted
operator|)
operator|)
operator|==
name|acc_mode
condition|)
block|{
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
label|:
return|return
operator|(
operator|(
name|acc_mode
operator|&
name|VADMIN
operator|)
condition|?
name|EPERM
else|:
name|EACCES
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For the purposes of filesystems maintaining the _OBJ entries in an  * inode with a mode_t field, this routine converts a mode_t entry  * to an acl_perm_t.  */
end_comment

begin_function
name|acl_perm_t
name|acl_posix1e_mode_to_perm
parameter_list|(
name|acl_tag_t
name|tag
parameter_list|,
name|mode_t
name|mode
parameter_list|)
block|{
name|acl_perm_t
name|perm
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|ACL_USER_OBJ
case|:
if|if
condition|(
name|mode
operator|&
name|S_IXUSR
condition|)
name|perm
operator||=
name|ACL_EXECUTE
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IRUSR
condition|)
name|perm
operator||=
name|ACL_READ
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWUSR
condition|)
name|perm
operator||=
name|ACL_WRITE
expr_stmt|;
return|return
operator|(
name|perm
operator|)
return|;
case|case
name|ACL_GROUP_OBJ
case|:
if|if
condition|(
name|mode
operator|&
name|S_IXGRP
condition|)
name|perm
operator||=
name|ACL_EXECUTE
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IRGRP
condition|)
name|perm
operator||=
name|ACL_READ
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWGRP
condition|)
name|perm
operator||=
name|ACL_WRITE
expr_stmt|;
return|return
operator|(
name|perm
operator|)
return|;
case|case
name|ACL_OTHER
case|:
if|if
condition|(
name|mode
operator|&
name|S_IXOTH
condition|)
name|perm
operator||=
name|ACL_EXECUTE
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IROTH
condition|)
name|perm
operator||=
name|ACL_READ
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWOTH
condition|)
name|perm
operator||=
name|ACL_WRITE
expr_stmt|;
return|return
operator|(
name|perm
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"acl_posix1e_mode_to_perm: invalid tag (%d)\n"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Given inode information (uid, gid, mode), return an acl entry of the  * appropriate type.  */
end_comment

begin_function
name|struct
name|acl_entry
name|acl_posix1e_mode_to_entry
parameter_list|(
name|acl_tag_t
name|tag
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|gid_t
name|gid
parameter_list|,
name|mode_t
name|mode
parameter_list|)
block|{
name|struct
name|acl_entry
name|acl_entry
decl_stmt|;
name|acl_entry
operator|.
name|ae_tag
operator|=
name|tag
expr_stmt|;
name|acl_entry
operator|.
name|ae_perm
operator|=
name|acl_posix1e_mode_to_perm
argument_list|(
name|tag
argument_list|,
name|mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|ACL_USER_OBJ
case|:
name|acl_entry
operator|.
name|ae_id
operator|=
name|uid
expr_stmt|;
break|break;
case|case
name|ACL_GROUP_OBJ
case|:
name|acl_entry
operator|.
name|ae_id
operator|=
name|gid
expr_stmt|;
break|break;
case|case
name|ACL_OTHER
case|:
name|acl_entry
operator|.
name|ae_id
operator|=
name|ACL_UNDEFINED_ID
expr_stmt|;
break|break;
default|default:
name|acl_entry
operator|.
name|ae_id
operator|=
name|ACL_UNDEFINED_ID
expr_stmt|;
name|printf
argument_list|(
literal|"acl_posix1e_mode_to_entry: invalid tag (%d)\n"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|acl_entry
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Utility function to generate a file mode given appropriate ACL entries.  */
end_comment

begin_function
name|mode_t
name|acl_posix1e_perms_to_mode
parameter_list|(
name|struct
name|acl_entry
modifier|*
name|acl_user_obj_entry
parameter_list|,
name|struct
name|acl_entry
modifier|*
name|acl_group_obj_entry
parameter_list|,
name|struct
name|acl_entry
modifier|*
name|acl_other_entry
parameter_list|)
block|{
name|mode_t
name|mode
decl_stmt|;
name|mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acl_user_obj_entry
operator|->
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
name|mode
operator||=
name|S_IXUSR
expr_stmt|;
if|if
condition|(
name|acl_user_obj_entry
operator|->
name|ae_perm
operator|&
name|ACL_READ
condition|)
name|mode
operator||=
name|S_IRUSR
expr_stmt|;
if|if
condition|(
name|acl_user_obj_entry
operator|->
name|ae_perm
operator|&
name|ACL_WRITE
condition|)
name|mode
operator||=
name|S_IWUSR
expr_stmt|;
if|if
condition|(
name|acl_group_obj_entry
operator|->
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
name|mode
operator||=
name|S_IXGRP
expr_stmt|;
if|if
condition|(
name|acl_group_obj_entry
operator|->
name|ae_perm
operator|&
name|ACL_READ
condition|)
name|mode
operator||=
name|S_IRGRP
expr_stmt|;
if|if
condition|(
name|acl_group_obj_entry
operator|->
name|ae_perm
operator|&
name|ACL_WRITE
condition|)
name|mode
operator||=
name|S_IWGRP
expr_stmt|;
if|if
condition|(
name|acl_other_entry
operator|->
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
name|mode
operator||=
name|S_IXOTH
expr_stmt|;
if|if
condition|(
name|acl_other_entry
operator|->
name|ae_perm
operator|&
name|ACL_READ
condition|)
name|mode
operator||=
name|S_IROTH
expr_stmt|;
if|if
condition|(
name|acl_other_entry
operator|->
name|ae_perm
operator|&
name|ACL_WRITE
condition|)
name|mode
operator||=
name|S_IWOTH
expr_stmt|;
return|return
operator|(
name|mode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform a syntactic check of the ACL, sufficient to allow an  * implementing filesystem to determine if it should accept this and  * rely on the POSIX.1e ACL properties.  */
end_comment

begin_function
name|int
name|acl_posix1e_check
parameter_list|(
name|struct
name|acl
modifier|*
name|acl
parameter_list|)
block|{
name|int
name|num_acl_user_obj
decl_stmt|,
name|num_acl_user
decl_stmt|,
name|num_acl_group_obj
decl_stmt|,
name|num_acl_group
decl_stmt|;
name|int
name|num_acl_mask
decl_stmt|,
name|num_acl_other
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Verify that the number of entries does not exceed the maximum 	 * defined for acl_t. 	 * Verify that the correct number of various sorts of ae_tags are 	 * present: 	 *   Exactly one ACL_USER_OBJ 	 *   Exactly one ACL_GROUP_OBJ 	 *   Exactly one ACL_OTHER 	 *   If any ACL_USER or ACL_GROUP entries appear, then exactly one 	 *   ACL_MASK entry must also appear. 	 * Verify that all ae_perm entries are in ACL_PERM_BITS. 	 * Verify all ae_tag entries are understood by this implementation. 	 * Note: Does not check for uniqueness of qualifier (ae_id) field. 	 */
name|num_acl_user_obj
operator|=
name|num_acl_user
operator|=
name|num_acl_group_obj
operator|=
name|num_acl_group
operator|=
name|num_acl_mask
operator|=
name|num_acl_other
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_cnt
operator|>
name|ACL_MAX_ENTRIES
operator|||
name|acl
operator|->
name|acl_cnt
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acl
operator|->
name|acl_cnt
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Check for a valid tag. 		 */
switch|switch
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_tag
condition|)
block|{
case|case
name|ACL_USER_OBJ
case|:
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
operator|=
name|ACL_UNDEFINED_ID
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
operator|!=
name|ACL_UNDEFINED_ID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|num_acl_user_obj
operator|++
expr_stmt|;
break|break;
case|case
name|ACL_GROUP_OBJ
case|:
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
operator|=
name|ACL_UNDEFINED_ID
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
operator|!=
name|ACL_UNDEFINED_ID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|num_acl_group_obj
operator|++
expr_stmt|;
break|break;
case|case
name|ACL_USER
case|:
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
operator|==
name|ACL_UNDEFINED_ID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|num_acl_user
operator|++
expr_stmt|;
break|break;
case|case
name|ACL_GROUP
case|:
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
operator|==
name|ACL_UNDEFINED_ID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|num_acl_group
operator|++
expr_stmt|;
break|break;
case|case
name|ACL_OTHER
case|:
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
operator|=
name|ACL_UNDEFINED_ID
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
operator|!=
name|ACL_UNDEFINED_ID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|num_acl_other
operator|++
expr_stmt|;
break|break;
case|case
name|ACL_MASK
case|:
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
operator|=
name|ACL_UNDEFINED_ID
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
operator|!=
name|ACL_UNDEFINED_ID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|num_acl_mask
operator|++
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 		 * Check for valid perm entries. 		 */
if|if
condition|(
operator|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator||
name|ACL_PERM_BITS
operator|)
operator|!=
name|ACL_PERM_BITS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|num_acl_user_obj
operator|!=
literal|1
operator|)
operator|||
operator|(
name|num_acl_group_obj
operator|!=
literal|1
operator|)
operator|||
operator|(
name|num_acl_other
operator|!=
literal|1
operator|)
operator|||
operator|(
name|num_acl_mask
operator|!=
literal|0
operator|&&
name|num_acl_mask
operator|!=
literal|1
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|num_acl_group
operator|!=
literal|0
operator|)
operator|||
operator|(
name|num_acl_user
operator|!=
literal|0
operator|)
operator|)
operator|&&
operator|(
name|num_acl_mask
operator|!=
literal|1
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * These calls wrap the real vnode operations, and are called by the   * syscall code once the syscall has converted the path or file  * descriptor to a vnode (unlocked).  The aclp pointer is assumed  * still to point to userland, so this should not be consumed within  * the kernel except by syscall code.  Other code should directly  * invoke VOP_{SET,GET}ACL.  */
end_comment

begin_comment
comment|/*  * Given a vnode, set its ACL.  */
end_comment

begin_function
specifier|static
name|int
name|vacl_set_acl
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|acl_type_t
name|type
parameter_list|,
name|struct
name|acl
modifier|*
name|aclp
parameter_list|)
block|{
name|struct
name|acl
name|inkernacl
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|aclp
argument_list|,
operator|&
name|inkernacl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|acl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|vn_start_write
argument_list|(
name|vp
argument_list|,
operator|&
name|mp
argument_list|,
name|V_WAIT
operator||
name|PCATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|VOP_LEASE
argument_list|(
name|vp
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|LEASE_WRITE
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_vnode_setacl
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|vp
argument_list|,
name|type
argument_list|,
operator|&
name|inkernacl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
endif|#
directive|endif
name|error
operator|=
name|VOP_SETACL
argument_list|(
name|vp
argument_list|,
name|type
argument_list|,
operator|&
name|inkernacl
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|out
label|:
endif|#
directive|endif
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a vnode, get its ACL.  */
end_comment

begin_function
specifier|static
name|int
name|vacl_get_acl
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|acl_type_t
name|type
parameter_list|,
name|struct
name|acl
modifier|*
name|aclp
parameter_list|)
block|{
name|struct
name|acl
name|inkernelacl
decl_stmt|;
name|int
name|error
decl_stmt|;
name|VOP_LEASE
argument_list|(
name|vp
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|LEASE_WRITE
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_vnode_getacl
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|vp
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
endif|#
directive|endif
name|error
operator|=
name|VOP_GETACL
argument_list|(
name|vp
argument_list|,
name|type
argument_list|,
operator|&
name|inkernelacl
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|out
label|:
endif|#
directive|endif
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|inkernelacl
argument_list|,
name|aclp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|acl
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a vnode, delete its ACL.  */
end_comment

begin_function
specifier|static
name|int
name|vacl_delete
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|acl_type_t
name|type
parameter_list|)
block|{
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|vn_start_write
argument_list|(
name|vp
argument_list|,
operator|&
name|mp
argument_list|,
name|V_WAIT
operator||
name|PCATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|VOP_LEASE
argument_list|(
name|vp
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|LEASE_WRITE
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_vnode_deleteacl
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|vp
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
endif|#
directive|endif
name|error
operator|=
name|VOP_SETACL
argument_list|(
name|vp
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|out
label|:
endif|#
directive|endif
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a vnode, check whether an ACL is appropriate for it  */
end_comment

begin_function
specifier|static
name|int
name|vacl_aclcheck
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|acl_type_t
name|type
parameter_list|,
name|struct
name|acl
modifier|*
name|aclp
parameter_list|)
block|{
name|struct
name|acl
name|inkernelacl
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|aclp
argument_list|,
operator|&
name|inkernelacl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|acl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|VOP_ACLCHECK
argument_list|(
name|vp
argument_list|,
name|type
argument_list|,
operator|&
name|inkernelacl
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * syscalls -- convert the path/fd to a vnode, and call vacl_whatever.  * Don't need to lock, as the vacl_ code will get/release any locks  * required.  */
end_comment

begin_comment
comment|/*  * Given a file path, get an ACL for it  *  * MPSAFE  */
end_comment

begin_function
name|int
name|__acl_get_file
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|__acl_get_file_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|path
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|vacl_get_acl
argument_list|(
name|td
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
name|uap
operator|->
name|type
argument_list|,
name|uap
operator|->
name|aclp
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a file path, get an ACL for it; don't follow links.  *  * MPSAFE  */
end_comment

begin_function
name|int
name|__acl_get_link
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|__acl_get_link_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|NOFOLLOW
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|path
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|vacl_get_acl
argument_list|(
name|td
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
name|uap
operator|->
name|type
argument_list|,
name|uap
operator|->
name|aclp
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a file path, set an ACL for it  *  * MPSAFE  */
end_comment

begin_function
name|int
name|__acl_set_file
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|__acl_set_file_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|path
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|vacl_set_acl
argument_list|(
name|td
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
name|uap
operator|->
name|type
argument_list|,
name|uap
operator|->
name|aclp
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a file path, set an ACL for it; don't follow links.  *  * MPSAFE  */
end_comment

begin_function
name|int
name|__acl_set_link
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|__acl_set_link_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|NOFOLLOW
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|path
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|vacl_set_acl
argument_list|(
name|td
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
name|uap
operator|->
name|type
argument_list|,
name|uap
operator|->
name|aclp
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a file descriptor, get an ACL for it  *  * MPSAFE  */
end_comment

begin_function
name|int
name|__acl_get_fd
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|__acl_get_fd_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|error
operator|=
name|getvnode
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|,
name|uap
operator|->
name|filedes
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|vacl_get_acl
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|fp
operator|->
name|f_data
argument_list|,
name|uap
operator|->
name|type
argument_list|,
name|uap
operator|->
name|aclp
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a file descriptor, set an ACL for it  *  * MPSAFE  */
end_comment

begin_function
name|int
name|__acl_set_fd
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|__acl_set_fd_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|error
operator|=
name|getvnode
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|,
name|uap
operator|->
name|filedes
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|vacl_set_acl
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|fp
operator|->
name|f_data
argument_list|,
name|uap
operator|->
name|type
argument_list|,
name|uap
operator|->
name|aclp
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a file path, delete an ACL from it.  *  * MPSAFE  */
end_comment

begin_function
name|int
name|__acl_delete_file
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|__acl_delete_file_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|path
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|vacl_delete
argument_list|(
name|td
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
name|uap
operator|->
name|type
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a file path, delete an ACL from it; don't follow links.  *  * MPSAFE  */
end_comment

begin_function
name|int
name|__acl_delete_link
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|__acl_delete_link_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|NOFOLLOW
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|path
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|vacl_delete
argument_list|(
name|td
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
name|uap
operator|->
name|type
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a file path, delete an ACL from it.  *  * MPSAFE  */
end_comment

begin_function
name|int
name|__acl_delete_fd
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|__acl_delete_fd_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|error
operator|=
name|getvnode
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|,
name|uap
operator|->
name|filedes
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|vacl_delete
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|fp
operator|->
name|f_data
argument_list|,
name|uap
operator|->
name|type
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a file path, check an ACL for it  *  * MPSAFE  */
end_comment

begin_function
name|int
name|__acl_aclcheck_file
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|__acl_aclcheck_file_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|path
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|vacl_aclcheck
argument_list|(
name|td
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
name|uap
operator|->
name|type
argument_list|,
name|uap
operator|->
name|aclp
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a file path, check an ACL for it; don't follow links.  *  * MPSAFE  */
end_comment

begin_function
name|int
name|__acl_aclcheck_link
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|__acl_aclcheck_link_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|NOFOLLOW
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|path
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|vacl_aclcheck
argument_list|(
name|td
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
name|uap
operator|->
name|type
argument_list|,
name|uap
operator|->
name|aclp
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a file descriptor, check an ACL for it  *  * MPSAFE  */
end_comment

begin_function
name|int
name|__acl_aclcheck_fd
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|__acl_aclcheck_fd_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|error
operator|=
name|getvnode
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|,
name|uap
operator|->
name|filedes
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|vacl_aclcheck
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|fp
operator|->
name|f_data
argument_list|,
name|uap
operator|->
name|type
argument_list|,
name|uap
operator|->
name|aclp
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

