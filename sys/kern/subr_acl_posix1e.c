begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999-2006 Robert N. M. Watson  * All rights reserved.  *  * This software was developed by Robert Watson for the TrustedBSD Project.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Developed by the TrustedBSD Project.  *  * ACL support routines specific to POSIX.1e access control lists.  These are  * utility routines for code common across file systems implementing POSIX.1e  * ACLs.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/acl.h>
end_include

begin_comment
comment|/*  * Implement a version of vaccess() that understands POSIX.1e ACL semantics;  * the access ACL has already been prepared for evaluation by the file system  * and is passed via 'uid', 'gid', and 'acl'.  Return 0 on success, else an  * errno value.  */
end_comment

begin_function
name|int
name|vaccess_acl_posix1e
parameter_list|(
name|enum
name|vtype
name|type
parameter_list|,
name|uid_t
name|file_uid
parameter_list|,
name|gid_t
name|file_gid
parameter_list|,
name|struct
name|acl
modifier|*
name|acl
parameter_list|,
name|mode_t
name|acc_mode
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
modifier|*
name|privused
parameter_list|)
block|{
name|struct
name|acl_entry
modifier|*
name|acl_other
decl_stmt|,
modifier|*
name|acl_mask
decl_stmt|;
name|mode_t
name|dac_granted
decl_stmt|;
name|mode_t
name|priv_granted
decl_stmt|;
name|mode_t
name|acl_mask_granted
decl_stmt|;
name|int
name|group_matched
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Look for a normal, non-privileged way to access the file/directory 	 * as requested.  If it exists, go with that.  Otherwise, attempt to 	 * use privileges granted via priv_granted.  In some cases, which 	 * privileges to use may be ambiguous due to "best match", in which 	 * case fall back on first match for the time being. 	 */
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Determine privileges now, but don't apply until we've found a DAC 	 * entry that matches but has failed to allow access. 	 * 	 * XXXRW: Ideally, we'd determine the privileges required before 	 * asking for them. 	 */
name|priv_granted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|VDIR
condition|)
block|{
if|if
condition|(
operator|(
name|acc_mode
operator|&
name|VEXEC
operator|)
operator|&&
operator|!
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_LOOKUP
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
condition|)
name|priv_granted
operator||=
name|VEXEC
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|acc_mode
operator|&
name|VEXEC
operator|)
operator|&&
operator|!
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_EXEC
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
condition|)
name|priv_granted
operator||=
name|VEXEC
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|acc_mode
operator|&
name|VREAD
operator|)
operator|&&
operator|!
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_READ
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
condition|)
name|priv_granted
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|acc_mode
operator|&
name|VWRITE
operator|)
operator|||
operator|(
name|acc_mode
operator|&
name|VAPPEND
operator|)
operator|)
operator|&&
operator|!
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_WRITE
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
condition|)
name|priv_granted
operator||=
operator|(
name|VWRITE
operator||
name|VAPPEND
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|acc_mode
operator|&
name|VADMIN
operator|)
operator|&&
operator|!
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_ADMIN
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
condition|)
name|priv_granted
operator||=
name|VADMIN
expr_stmt|;
comment|/* 	 * The owner matches if the effective uid associated with the 	 * credential matches that of the ACL_USER_OBJ entry.  While we're 	 * doing the first scan, also cache the location of the ACL_MASK and 	 * ACL_OTHER entries, preventing some future iterations. 	 */
name|acl_mask
operator|=
name|acl_other
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acl
operator|->
name|acl_cnt
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_tag
condition|)
block|{
case|case
name|ACL_USER_OBJ
case|:
if|if
condition|(
name|file_uid
operator|!=
name|cred
operator|->
name|cr_uid
condition|)
break|break;
name|dac_granted
operator|=
literal|0
expr_stmt|;
name|dac_granted
operator||=
name|VADMIN
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
name|dac_granted
operator||=
name|VEXEC
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_READ
condition|)
name|dac_granted
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_WRITE
condition|)
name|dac_granted
operator||=
operator|(
name|VWRITE
operator||
name|VAPPEND
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|acc_mode
operator|&
name|dac_granted
operator|)
operator|==
name|acc_mode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 			 * XXXRW: Do privilege lookup here. 			 */
if|if
condition|(
operator|(
name|acc_mode
operator|&
operator|(
name|dac_granted
operator||
name|priv_granted
operator|)
operator|)
operator|==
name|acc_mode
condition|)
block|{
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
goto|goto
name|error
goto|;
case|case
name|ACL_MASK
case|:
name|acl_mask
operator|=
operator|&
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|ACL_OTHER
case|:
name|acl_other
operator|=
operator|&
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* 	 * An ACL_OTHER entry should always exist in a valid access ACL.  If 	 * it doesn't, then generate a serious failure.  For now, this means 	 * a debugging message and EPERM, but in the future should probably 	 * be a panic. 	 */
if|if
condition|(
name|acl_other
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * XXX This should never happen 		 */
name|printf
argument_list|(
literal|"vaccess_acl_posix1e: ACL_OTHER missing\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
comment|/* 	 * Checks against ACL_USER, ACL_GROUP_OBJ, and ACL_GROUP fields are 	 * masked by an ACL_MASK entry, if any.  As such, first identify the 	 * ACL_MASK field, then iterate through identifying potential user 	 * matches, then group matches.  If there is no ACL_MASK, assume that 	 * the mask allows all requests to succeed. 	 */
if|if
condition|(
name|acl_mask
operator|!=
name|NULL
condition|)
block|{
name|acl_mask_granted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acl_mask
operator|->
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
name|acl_mask_granted
operator||=
name|VEXEC
expr_stmt|;
if|if
condition|(
name|acl_mask
operator|->
name|ae_perm
operator|&
name|ACL_READ
condition|)
name|acl_mask_granted
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
name|acl_mask
operator|->
name|ae_perm
operator|&
name|ACL_WRITE
condition|)
name|acl_mask_granted
operator||=
operator|(
name|VWRITE
operator||
name|VAPPEND
operator|)
expr_stmt|;
block|}
else|else
name|acl_mask_granted
operator|=
name|VEXEC
operator||
name|VREAD
operator||
name|VWRITE
operator||
name|VAPPEND
expr_stmt|;
comment|/* 	 * Check ACL_USER ACL entries.  There will either be one or no 	 * matches; if there is one, we accept or rejected based on the 	 * match; otherwise, we continue on to groups. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acl
operator|->
name|acl_cnt
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_tag
condition|)
block|{
case|case
name|ACL_USER
case|:
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
operator|!=
name|cred
operator|->
name|cr_uid
condition|)
break|break;
name|dac_granted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
name|dac_granted
operator||=
name|VEXEC
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_READ
condition|)
name|dac_granted
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_WRITE
condition|)
name|dac_granted
operator||=
operator|(
name|VWRITE
operator||
name|VAPPEND
operator|)
expr_stmt|;
name|dac_granted
operator|&=
name|acl_mask_granted
expr_stmt|;
if|if
condition|(
operator|(
name|acc_mode
operator|&
name|dac_granted
operator|)
operator|==
name|acc_mode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 			 * XXXRW: Do privilege lookup here. 			 */
if|if
condition|(
operator|(
name|acc_mode
operator|&
operator|(
name|dac_granted
operator||
name|priv_granted
operator|)
operator|)
operator|!=
name|acc_mode
condition|)
goto|goto
name|error
goto|;
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * Group match is best-match, not first-match, so find a "best" 	 * match.  Iterate across, testing each potential group match.  Make 	 * sure we keep track of whether we found a match or not, so that we 	 * know if we should try again with any available privilege, or if we 	 * should move on to ACL_OTHER. 	 */
name|group_matched
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acl
operator|->
name|acl_cnt
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_tag
condition|)
block|{
case|case
name|ACL_GROUP_OBJ
case|:
if|if
condition|(
operator|!
name|groupmember
argument_list|(
name|file_gid
argument_list|,
name|cred
argument_list|)
condition|)
break|break;
name|dac_granted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
name|dac_granted
operator||=
name|VEXEC
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_READ
condition|)
name|dac_granted
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_WRITE
condition|)
name|dac_granted
operator||=
operator|(
name|VWRITE
operator||
name|VAPPEND
operator|)
expr_stmt|;
name|dac_granted
operator|&=
name|acl_mask_granted
expr_stmt|;
if|if
condition|(
operator|(
name|acc_mode
operator|&
name|dac_granted
operator|)
operator|==
name|acc_mode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|group_matched
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ACL_GROUP
case|:
if|if
condition|(
operator|!
name|groupmember
argument_list|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
argument_list|,
name|cred
argument_list|)
condition|)
break|break;
name|dac_granted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
name|dac_granted
operator||=
name|VEXEC
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_READ
condition|)
name|dac_granted
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_WRITE
condition|)
name|dac_granted
operator||=
operator|(
name|VWRITE
operator||
name|VAPPEND
operator|)
expr_stmt|;
name|dac_granted
operator|&=
name|acl_mask_granted
expr_stmt|;
if|if
condition|(
operator|(
name|acc_mode
operator|&
name|dac_granted
operator|)
operator|==
name|acc_mode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|group_matched
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|group_matched
operator|==
literal|1
condition|)
block|{
comment|/* 		 * There was a match, but it did not grant rights via pure 		 * DAC.  Try again, this time with privilege. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acl
operator|->
name|acl_cnt
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_tag
condition|)
block|{
case|case
name|ACL_GROUP_OBJ
case|:
if|if
condition|(
operator|!
name|groupmember
argument_list|(
name|file_gid
argument_list|,
name|cred
argument_list|)
condition|)
break|break;
name|dac_granted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
name|dac_granted
operator||=
name|VEXEC
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_READ
condition|)
name|dac_granted
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_WRITE
condition|)
name|dac_granted
operator||=
operator|(
name|VWRITE
operator||
name|VAPPEND
operator|)
expr_stmt|;
name|dac_granted
operator|&=
name|acl_mask_granted
expr_stmt|;
comment|/* 				 * XXXRW: Do privilege lookup here. 				 */
if|if
condition|(
operator|(
name|acc_mode
operator|&
operator|(
name|dac_granted
operator||
name|priv_granted
operator|)
operator|)
operator|!=
name|acc_mode
condition|)
break|break;
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ACL_GROUP
case|:
if|if
condition|(
operator|!
name|groupmember
argument_list|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
argument_list|,
name|cred
argument_list|)
condition|)
break|break;
name|dac_granted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
name|dac_granted
operator||=
name|VEXEC
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_READ
condition|)
name|dac_granted
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator|&
name|ACL_WRITE
condition|)
name|dac_granted
operator||=
operator|(
name|VWRITE
operator||
name|VAPPEND
operator|)
expr_stmt|;
name|dac_granted
operator|&=
name|acl_mask_granted
expr_stmt|;
comment|/* 				 * XXXRW: Do privilege lookup here. 				 */
if|if
condition|(
operator|(
name|acc_mode
operator|&
operator|(
name|dac_granted
operator||
name|priv_granted
operator|)
operator|)
operator|!=
name|acc_mode
condition|)
break|break;
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
break|break;
block|}
block|}
comment|/* 		 * Even with privilege, group membership was not sufficient. 		 * Return failure. 		 */
goto|goto
name|error
goto|;
block|}
comment|/* 	 * Fall back on ACL_OTHER.  ACL_MASK is not applied to ACL_OTHER. 	 */
name|dac_granted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acl_other
operator|->
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
name|dac_granted
operator||=
name|VEXEC
expr_stmt|;
if|if
condition|(
name|acl_other
operator|->
name|ae_perm
operator|&
name|ACL_READ
condition|)
name|dac_granted
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
name|acl_other
operator|->
name|ae_perm
operator|&
name|ACL_WRITE
condition|)
name|dac_granted
operator||=
operator|(
name|VWRITE
operator||
name|VAPPEND
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|acc_mode
operator|&
name|dac_granted
operator|)
operator|==
name|acc_mode
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * XXXRW: Do privilege lookup here. 	 */
if|if
condition|(
operator|(
name|acc_mode
operator|&
operator|(
name|dac_granted
operator||
name|priv_granted
operator|)
operator|)
operator|==
name|acc_mode
condition|)
block|{
if|if
condition|(
name|privused
operator|!=
name|NULL
condition|)
operator|*
name|privused
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
label|:
return|return
operator|(
operator|(
name|acc_mode
operator|&
name|VADMIN
operator|)
condition|?
name|EPERM
else|:
name|EACCES
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For the purposes of filesystems maintaining the _OBJ entries in an inode  * with a mode_t field, this routine converts a mode_t entry to an  * acl_perm_t.  */
end_comment

begin_function
name|acl_perm_t
name|acl_posix1e_mode_to_perm
parameter_list|(
name|acl_tag_t
name|tag
parameter_list|,
name|mode_t
name|mode
parameter_list|)
block|{
name|acl_perm_t
name|perm
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|ACL_USER_OBJ
case|:
if|if
condition|(
name|mode
operator|&
name|S_IXUSR
condition|)
name|perm
operator||=
name|ACL_EXECUTE
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IRUSR
condition|)
name|perm
operator||=
name|ACL_READ
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWUSR
condition|)
name|perm
operator||=
name|ACL_WRITE
expr_stmt|;
return|return
operator|(
name|perm
operator|)
return|;
case|case
name|ACL_GROUP_OBJ
case|:
if|if
condition|(
name|mode
operator|&
name|S_IXGRP
condition|)
name|perm
operator||=
name|ACL_EXECUTE
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IRGRP
condition|)
name|perm
operator||=
name|ACL_READ
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWGRP
condition|)
name|perm
operator||=
name|ACL_WRITE
expr_stmt|;
return|return
operator|(
name|perm
operator|)
return|;
case|case
name|ACL_OTHER
case|:
if|if
condition|(
name|mode
operator|&
name|S_IXOTH
condition|)
name|perm
operator||=
name|ACL_EXECUTE
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IROTH
condition|)
name|perm
operator||=
name|ACL_READ
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|S_IWOTH
condition|)
name|perm
operator||=
name|ACL_WRITE
expr_stmt|;
return|return
operator|(
name|perm
operator|)
return|;
default|default:
name|printf
argument_list|(
literal|"acl_posix1e_mode_to_perm: invalid tag (%d)\n"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Given inode information (uid, gid, mode), return an acl entry of the  * appropriate type.  */
end_comment

begin_function
name|struct
name|acl_entry
name|acl_posix1e_mode_to_entry
parameter_list|(
name|acl_tag_t
name|tag
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|gid_t
name|gid
parameter_list|,
name|mode_t
name|mode
parameter_list|)
block|{
name|struct
name|acl_entry
name|acl_entry
decl_stmt|;
name|acl_entry
operator|.
name|ae_tag
operator|=
name|tag
expr_stmt|;
name|acl_entry
operator|.
name|ae_perm
operator|=
name|acl_posix1e_mode_to_perm
argument_list|(
name|tag
argument_list|,
name|mode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|ACL_USER_OBJ
case|:
name|acl_entry
operator|.
name|ae_id
operator|=
name|uid
expr_stmt|;
break|break;
case|case
name|ACL_GROUP_OBJ
case|:
name|acl_entry
operator|.
name|ae_id
operator|=
name|gid
expr_stmt|;
break|break;
case|case
name|ACL_OTHER
case|:
name|acl_entry
operator|.
name|ae_id
operator|=
name|ACL_UNDEFINED_ID
expr_stmt|;
break|break;
default|default:
name|acl_entry
operator|.
name|ae_id
operator|=
name|ACL_UNDEFINED_ID
expr_stmt|;
name|printf
argument_list|(
literal|"acl_posix1e_mode_to_entry: invalid tag (%d)\n"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|acl_entry
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Utility function to generate a file mode given appropriate ACL entries.  */
end_comment

begin_function
name|mode_t
name|acl_posix1e_perms_to_mode
parameter_list|(
name|struct
name|acl_entry
modifier|*
name|acl_user_obj_entry
parameter_list|,
name|struct
name|acl_entry
modifier|*
name|acl_group_obj_entry
parameter_list|,
name|struct
name|acl_entry
modifier|*
name|acl_other_entry
parameter_list|)
block|{
name|mode_t
name|mode
decl_stmt|;
name|mode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acl_user_obj_entry
operator|->
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
name|mode
operator||=
name|S_IXUSR
expr_stmt|;
if|if
condition|(
name|acl_user_obj_entry
operator|->
name|ae_perm
operator|&
name|ACL_READ
condition|)
name|mode
operator||=
name|S_IRUSR
expr_stmt|;
if|if
condition|(
name|acl_user_obj_entry
operator|->
name|ae_perm
operator|&
name|ACL_WRITE
condition|)
name|mode
operator||=
name|S_IWUSR
expr_stmt|;
if|if
condition|(
name|acl_group_obj_entry
operator|->
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
name|mode
operator||=
name|S_IXGRP
expr_stmt|;
if|if
condition|(
name|acl_group_obj_entry
operator|->
name|ae_perm
operator|&
name|ACL_READ
condition|)
name|mode
operator||=
name|S_IRGRP
expr_stmt|;
if|if
condition|(
name|acl_group_obj_entry
operator|->
name|ae_perm
operator|&
name|ACL_WRITE
condition|)
name|mode
operator||=
name|S_IWGRP
expr_stmt|;
if|if
condition|(
name|acl_other_entry
operator|->
name|ae_perm
operator|&
name|ACL_EXECUTE
condition|)
name|mode
operator||=
name|S_IXOTH
expr_stmt|;
if|if
condition|(
name|acl_other_entry
operator|->
name|ae_perm
operator|&
name|ACL_READ
condition|)
name|mode
operator||=
name|S_IROTH
expr_stmt|;
if|if
condition|(
name|acl_other_entry
operator|->
name|ae_perm
operator|&
name|ACL_WRITE
condition|)
name|mode
operator||=
name|S_IWOTH
expr_stmt|;
return|return
operator|(
name|mode
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Utility function to generate a file mode given a complete POSIX.1e access  * ACL.  Note that if the ACL is improperly formed, this may result in a  * panic.  */
end_comment

begin_function
name|mode_t
name|acl_posix1e_acl_to_mode
parameter_list|(
name|struct
name|acl
modifier|*
name|acl
parameter_list|)
block|{
name|struct
name|acl_entry
modifier|*
name|acl_mask
decl_stmt|,
modifier|*
name|acl_user_obj
decl_stmt|,
modifier|*
name|acl_group_obj
decl_stmt|,
modifier|*
name|acl_other
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Find the ACL entries relevant to a POSIX permission mode. 	 */
name|acl_user_obj
operator|=
name|acl_group_obj
operator|=
name|acl_other
operator|=
name|acl_mask
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acl
operator|->
name|acl_cnt
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_tag
condition|)
block|{
case|case
name|ACL_USER_OBJ
case|:
name|acl_user_obj
operator|=
operator|&
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|ACL_GROUP_OBJ
case|:
name|acl_group_obj
operator|=
operator|&
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|ACL_OTHER
case|:
name|acl_other
operator|=
operator|&
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|ACL_MASK
case|:
name|acl_mask
operator|=
operator|&
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|ACL_USER
case|:
case|case
name|ACL_GROUP
case|:
break|break;
default|default:
name|panic
argument_list|(
literal|"acl_posix1e_acl_to_mode: bad ae_tag"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|acl_user_obj
operator|==
name|NULL
operator|||
name|acl_group_obj
operator|==
name|NULL
operator|||
name|acl_other
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"acl_posix1e_acl_to_mode: missing base ae_tags"
argument_list|)
expr_stmt|;
comment|/* 	 * POSIX.1e specifies that if there is an ACL_MASK entry, we replace 	 * the mode "group" bits with its permissions.  If there isn't, we 	 * use the ACL_GROUP_OBJ permissions. 	 */
if|if
condition|(
name|acl_mask
operator|!=
name|NULL
condition|)
return|return
operator|(
name|acl_posix1e_perms_to_mode
argument_list|(
name|acl_user_obj
argument_list|,
name|acl_mask
argument_list|,
name|acl_other
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|acl_posix1e_perms_to_mode
argument_list|(
name|acl_user_obj
argument_list|,
name|acl_group_obj
argument_list|,
name|acl_other
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform a syntactic check of the ACL, sufficient to allow an implementing  * filesystem to determine if it should accept this and rely on the POSIX.1e  * ACL properties.  */
end_comment

begin_function
name|int
name|acl_posix1e_check
parameter_list|(
name|struct
name|acl
modifier|*
name|acl
parameter_list|)
block|{
name|int
name|num_acl_user_obj
decl_stmt|,
name|num_acl_user
decl_stmt|,
name|num_acl_group_obj
decl_stmt|,
name|num_acl_group
decl_stmt|;
name|int
name|num_acl_mask
decl_stmt|,
name|num_acl_other
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Verify that the number of entries does not exceed the maximum 	 * defined for acl_t. 	 * 	 * Verify that the correct number of various sorts of ae_tags are 	 * present: 	 *   Exactly one ACL_USER_OBJ 	 *   Exactly one ACL_GROUP_OBJ 	 *   Exactly one ACL_OTHER 	 *   If any ACL_USER or ACL_GROUP entries appear, then exactly one 	 *   ACL_MASK entry must also appear. 	 * 	 * Verify that all ae_perm entries are in ACL_PERM_BITS. 	 * 	 * Verify all ae_tag entries are understood by this implementation. 	 * 	 * Note: Does not check for uniqueness of qualifier (ae_id) field. 	 */
name|num_acl_user_obj
operator|=
name|num_acl_user
operator|=
name|num_acl_group_obj
operator|=
name|num_acl_group
operator|=
name|num_acl_mask
operator|=
name|num_acl_other
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|acl
operator|->
name|acl_cnt
operator|>
name|ACL_MAX_ENTRIES
operator|||
name|acl
operator|->
name|acl_cnt
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|acl
operator|->
name|acl_cnt
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Check for a valid tag. 		 */
switch|switch
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_tag
condition|)
block|{
case|case
name|ACL_USER_OBJ
case|:
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
operator|=
name|ACL_UNDEFINED_ID
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
operator|!=
name|ACL_UNDEFINED_ID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|num_acl_user_obj
operator|++
expr_stmt|;
break|break;
case|case
name|ACL_GROUP_OBJ
case|:
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
operator|=
name|ACL_UNDEFINED_ID
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
operator|!=
name|ACL_UNDEFINED_ID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|num_acl_group_obj
operator|++
expr_stmt|;
break|break;
case|case
name|ACL_USER
case|:
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
operator|==
name|ACL_UNDEFINED_ID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|num_acl_user
operator|++
expr_stmt|;
break|break;
case|case
name|ACL_GROUP
case|:
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
operator|==
name|ACL_UNDEFINED_ID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|num_acl_group
operator|++
expr_stmt|;
break|break;
case|case
name|ACL_OTHER
case|:
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
operator|=
name|ACL_UNDEFINED_ID
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
operator|!=
name|ACL_UNDEFINED_ID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|num_acl_other
operator|++
expr_stmt|;
break|break;
case|case
name|ACL_MASK
case|:
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
operator|=
name|ACL_UNDEFINED_ID
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_id
operator|!=
name|ACL_UNDEFINED_ID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|num_acl_mask
operator|++
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 		 * Check for valid perm entries. 		 */
if|if
condition|(
operator|(
name|acl
operator|->
name|acl_entry
index|[
name|i
index|]
operator|.
name|ae_perm
operator||
name|ACL_PERM_BITS
operator|)
operator|!=
name|ACL_PERM_BITS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|num_acl_user_obj
operator|!=
literal|1
operator|)
operator|||
operator|(
name|num_acl_group_obj
operator|!=
literal|1
operator|)
operator|||
operator|(
name|num_acl_other
operator|!=
literal|1
operator|)
operator|||
operator|(
name|num_acl_mask
operator|!=
literal|0
operator|&&
name|num_acl_mask
operator|!=
literal|1
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|num_acl_group
operator|!=
literal|0
operator|)
operator|||
operator|(
name|num_acl_user
operator|!=
literal|0
operator|)
operator|)
operator|&&
operator|(
name|num_acl_mask
operator|!=
literal|1
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a requested mode for a new object, and a default ACL, combine the  * two to produce a new mode.  Be careful not to clear any bits that aren't  * intended to be affected by the POSIX.1e ACL.  Eventually, this might also  * take the cmask as an argument, if we push that down into  * per-filesystem-code.  */
end_comment

begin_function
name|mode_t
name|acl_posix1e_newfilemode
parameter_list|(
name|mode_t
name|cmode
parameter_list|,
name|struct
name|acl
modifier|*
name|dacl
parameter_list|)
block|{
name|mode_t
name|mode
decl_stmt|;
name|mode
operator|=
name|cmode
expr_stmt|;
comment|/* 	 * The current composition policy is that a permission bit must be 	 * set in *both* the ACL and the requested creation mode for it to 	 * appear in the resulting mode/ACL.  First clear any possibly 	 * effected bits, then reconstruct. 	 */
name|mode
operator|&=
name|ACL_PRESERVE_MASK
expr_stmt|;
name|mode
operator||=
operator|(
name|ACL_OVERRIDE_MASK
operator|&
name|cmode
operator|&
name|acl_posix1e_acl_to_mode
argument_list|(
name|dacl
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|mode
operator|)
return|;
block|}
end_function

end_unit

