begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005 David Xu<davidxu@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/*  * POSIX message queue implementation.  *  * 1) A mqueue filesystem can be mounted, each message queue appears  *    in mounted directory, user can change queue's permission and  *    ownership, or remove a queue. Manually creating a file in the  *    directory causes a message queue to be created in the kernel with  *    default message queue attributes applied and same name used, this  *    method is not advocated since mq_open syscall allows user to specify  *    different attributes. Also the file system can be mounted multiple  *    times at different mount points but shows same contents.  *  * 2) Standard POSIX message queue API. The syscalls do not use vfs layer,  *    but directly operate on internal data structure, this allows user to  *    use the IPC facility without having to mount mqueue file system.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/posix4.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_comment
comment|/*  * Limits and constants  */
end_comment

begin_define
define|#
directive|define
name|MQFS_NAMELEN
value|NAME_MAX
end_define

begin_define
define|#
directive|define
name|MQFS_DELEN
value|(8 + MQFS_NAMELEN)
end_define

begin_comment
comment|/* node types */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|mqfstype_none
init|=
literal|0
block|,
name|mqfstype_root
block|,
name|mqfstype_dir
block|,
name|mqfstype_this
block|,
name|mqfstype_parent
block|,
name|mqfstype_file
block|,
name|mqfstype_symlink
block|, }
name|mqfs_type_t
typedef|;
end_typedef

begin_struct_decl
struct_decl|struct
name|mqfs_node
struct_decl|;
end_struct_decl

begin_comment
comment|/*  * mqfs_info: describes a mqfs instance  */
end_comment

begin_struct
struct|struct
name|mqfs_info
block|{
name|struct
name|sx
name|mi_lock
decl_stmt|;
name|struct
name|mqfs_node
modifier|*
name|mi_root
decl_stmt|;
name|struct
name|unrhdr
modifier|*
name|mi_unrhdr
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mqfs_vdata
block|{
name|LIST_ENTRY
argument_list|(
argument|mqfs_vdata
argument_list|)
name|mv_link
expr_stmt|;
name|struct
name|mqfs_node
modifier|*
name|mv_node
decl_stmt|;
name|struct
name|vnode
modifier|*
name|mv_vnode
decl_stmt|;
name|struct
name|task
name|mv_task
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * mqfs_node: describes a node (file or directory) within a mqfs  */
end_comment

begin_struct
struct|struct
name|mqfs_node
block|{
name|char
name|mn_name
index|[
name|MQFS_NAMELEN
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|mqfs_info
modifier|*
name|mn_info
decl_stmt|;
name|struct
name|mqfs_node
modifier|*
name|mn_parent
decl_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|mqfs_node
argument_list|)
name|mn_children
expr_stmt|;
name|LIST_ENTRY
argument_list|(
argument|mqfs_node
argument_list|)
name|mn_sibling
expr_stmt|;
name|LIST_HEAD
argument_list|(
argument_list|,
argument|mqfs_vdata
argument_list|)
name|mn_vnodes
expr_stmt|;
name|int
name|mn_refcount
decl_stmt|;
name|mqfs_type_t
name|mn_type
decl_stmt|;
name|int
name|mn_deleted
decl_stmt|;
name|u_int32_t
name|mn_fileno
decl_stmt|;
name|void
modifier|*
name|mn_data
decl_stmt|;
name|struct
name|timespec
name|mn_birth
decl_stmt|;
name|struct
name|timespec
name|mn_ctime
decl_stmt|;
name|struct
name|timespec
name|mn_atime
decl_stmt|;
name|struct
name|timespec
name|mn_mtime
decl_stmt|;
name|uid_t
name|mn_uid
decl_stmt|;
name|gid_t
name|mn_gid
decl_stmt|;
name|int
name|mn_mode
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|VTON
parameter_list|(
name|vp
parameter_list|)
value|(((struct mqfs_vdata *)((vp)->v_data))->mv_node)
end_define

begin_define
define|#
directive|define
name|VTOMQ
parameter_list|(
name|vp
parameter_list|)
value|((struct mqueue *)(VTON(vp)->mn_data))
end_define

begin_define
define|#
directive|define
name|VFSTOMQFS
parameter_list|(
name|m
parameter_list|)
value|((struct mqfs_info *)((m)->mnt_data))
end_define

begin_define
define|#
directive|define
name|FPTOMQ
parameter_list|(
name|fp
parameter_list|)
value|((struct mqueue *)(((struct mqfs_node *) \ 				(fp)->f_data)->mn_data))
end_define

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|msgq
argument_list|,
name|mqueue_msg
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct_decl
struct_decl|struct
name|mqueue
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|mqueue_notifier
block|{
name|LIST_ENTRY
argument_list|(
argument|mqueue_notifier
argument_list|)
name|nt_link
expr_stmt|;
name|struct
name|sigevent
name|nt_sigev
decl_stmt|;
name|ksiginfo_t
name|nt_ksi
decl_stmt|;
name|struct
name|proc
modifier|*
name|nt_proc
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mqueue
block|{
name|struct
name|mtx
name|mq_mutex
decl_stmt|;
name|int
name|mq_flags
decl_stmt|;
name|long
name|mq_maxmsg
decl_stmt|;
name|long
name|mq_msgsize
decl_stmt|;
name|long
name|mq_curmsgs
decl_stmt|;
name|long
name|mq_totalbytes
decl_stmt|;
name|struct
name|msgq
name|mq_msgq
decl_stmt|;
name|int
name|mq_receivers
decl_stmt|;
name|int
name|mq_senders
decl_stmt|;
name|struct
name|selinfo
name|mq_rsel
decl_stmt|;
name|struct
name|selinfo
name|mq_wsel
decl_stmt|;
name|struct
name|mqueue_notifier
modifier|*
name|mq_notifier
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MQ_RSEL
value|0x01
end_define

begin_define
define|#
directive|define
name|MQ_WSEL
value|0x02
end_define

begin_struct
struct|struct
name|mqueue_msg
block|{
name|TAILQ_ENTRY
argument_list|(
argument|mqueue_msg
argument_list|)
name|msg_link
expr_stmt|;
name|unsigned
name|int
name|msg_prio
decl_stmt|;
name|unsigned
name|int
name|msg_size
decl_stmt|;
comment|/* following real data... */
block|}
struct|;
end_struct

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|mqueue
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"POSIX real time message queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|default_maxmsg
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|default_msgsize
init|=
literal|1024
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|maxmsg
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_mqueue
argument_list|,
name|OID_AUTO
argument_list|,
name|maxmsg
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|maxmsg
argument_list|,
literal|0
argument_list|,
literal|"Default maximum messages in queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|maxmsgsize
init|=
literal|16384
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_mqueue
argument_list|,
name|OID_AUTO
argument_list|,
name|maxmsgsize
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|maxmsgsize
argument_list|,
literal|0
argument_list|,
literal|"Default maximum message size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|maxmq
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_mqueue
argument_list|,
name|OID_AUTO
argument_list|,
name|maxmq
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|maxmq
argument_list|,
literal|0
argument_list|,
literal|"maximum message queues"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|curmq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_mqueue
argument_list|,
name|OID_AUTO
argument_list|,
name|curmq
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|curmq
argument_list|,
literal|0
argument_list|,
literal|"current message queue number"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|unloadable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_MQUEUEDATA
argument_list|,
literal|"mqdata"
argument_list|,
literal|"mqueue data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|exit_tag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Only one instance per-system */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mqfs_info
name|mqfs_data
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|mqnode_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|mqueue_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|mvdata_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|mqnoti_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vop_vector
name|mqfs_vnodeops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fileops
name|mqueueops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Directory structure construction and manipulation  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function_decl
specifier|static
name|struct
name|mqfs_node
modifier|*
name|mqfs_create_dir
parameter_list|(
name|struct
name|mqfs_node
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mqfs_node
modifier|*
name|mqfs_create_link
parameter_list|(
name|struct
name|mqfs_node
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|mqfs_node
modifier|*
name|mqfs_create_file
parameter_list|(
name|struct
name|mqfs_node
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mqfs_destroy
parameter_list|(
name|struct
name|mqfs_node
modifier|*
name|mn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mqfs_fileno_alloc
parameter_list|(
name|struct
name|mqfs_info
modifier|*
name|mi
parameter_list|,
name|struct
name|mqfs_node
modifier|*
name|mn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mqfs_fileno_free
parameter_list|(
name|struct
name|mqfs_info
modifier|*
name|mi
parameter_list|,
name|struct
name|mqfs_node
modifier|*
name|mn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mqfs_allocv
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|mqfs_node
modifier|*
name|pn
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Message queue construction and maniplation  */
end_comment

begin_function_decl
specifier|static
name|struct
name|mqueue
modifier|*
name|mqueue_alloc
parameter_list|(
specifier|const
name|struct
name|mq_attr
modifier|*
name|attr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mqueue_free
parameter_list|(
name|struct
name|mqueue
modifier|*
name|mq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mqueue_send
parameter_list|(
name|struct
name|mqueue
modifier|*
name|mq
parameter_list|,
specifier|const
name|char
modifier|*
name|msg_ptr
parameter_list|,
name|size_t
name|msg_len
parameter_list|,
name|unsigned
name|msg_prio
parameter_list|,
name|int
name|waitok
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|abs_timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mqueue_receive
parameter_list|(
name|struct
name|mqueue
modifier|*
name|mq
parameter_list|,
name|char
modifier|*
name|msg_ptr
parameter_list|,
name|size_t
name|msg_len
parameter_list|,
name|unsigned
modifier|*
name|msg_prio
parameter_list|,
name|int
name|waitok
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|abs_timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_mqueue_send
parameter_list|(
name|struct
name|mqueue
modifier|*
name|mq
parameter_list|,
name|struct
name|mqueue_msg
modifier|*
name|msg
parameter_list|,
name|int
name|timo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_mqueue_recv
parameter_list|(
name|struct
name|mqueue
modifier|*
name|mq
parameter_list|,
name|struct
name|mqueue_msg
modifier|*
modifier|*
name|msg
parameter_list|,
name|int
name|timo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mqueue_send_notification
parameter_list|(
name|struct
name|mqueue
modifier|*
name|mq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mqueue_fdclose
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|file
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mq_proc_exit
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * kqueue filters  */
end_comment

begin_function_decl
specifier|static
name|void
name|filt_mqdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_mqread
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_mqwrite
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|filterops
name|mq_rfiltops
init|=
block|{
literal|1
block|,
name|NULL
block|,
name|filt_mqdetach
block|,
name|filt_mqread
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|filterops
name|mq_wfiltops
init|=
block|{
literal|1
block|,
name|NULL
block|,
name|filt_mqdetach
block|,
name|filt_mqwrite
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize fileno bitmap  */
end_comment

begin_function
specifier|static
name|void
name|mqfs_fileno_init
parameter_list|(
name|struct
name|mqfs_info
modifier|*
name|mi
parameter_list|)
block|{
name|struct
name|unrhdr
modifier|*
name|up
decl_stmt|;
name|up
operator|=
name|new_unrhdr
argument_list|(
literal|1
argument_list|,
name|INT_MAX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mi
operator|->
name|mi_unrhdr
operator|=
name|up
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Tear down fileno bitmap  */
end_comment

begin_function
specifier|static
name|void
name|mqfs_fileno_uninit
parameter_list|(
name|struct
name|mqfs_info
modifier|*
name|mi
parameter_list|)
block|{
name|struct
name|unrhdr
modifier|*
name|up
decl_stmt|;
name|up
operator|=
name|mi
operator|->
name|mi_unrhdr
expr_stmt|;
name|mi
operator|->
name|mi_unrhdr
operator|=
name|NULL
expr_stmt|;
name|delete_unrhdr
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a file number  */
end_comment

begin_function
specifier|static
name|void
name|mqfs_fileno_alloc
parameter_list|(
name|struct
name|mqfs_info
modifier|*
name|mi
parameter_list|,
name|struct
name|mqfs_node
modifier|*
name|mn
parameter_list|)
block|{
comment|/* make sure our parent has a file number */
if|if
condition|(
name|mn
operator|->
name|mn_parent
operator|&&
operator|!
name|mn
operator|->
name|mn_parent
operator|->
name|mn_fileno
condition|)
name|mqfs_fileno_alloc
argument_list|(
name|mi
argument_list|,
name|mn
operator|->
name|mn_parent
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mn
operator|->
name|mn_type
condition|)
block|{
case|case
name|mqfstype_root
case|:
case|case
name|mqfstype_dir
case|:
case|case
name|mqfstype_file
case|:
case|case
name|mqfstype_symlink
case|:
name|mn
operator|->
name|mn_fileno
operator|=
name|alloc_unr
argument_list|(
name|mi
operator|->
name|mi_unrhdr
argument_list|)
expr_stmt|;
break|break;
case|case
name|mqfstype_this
case|:
name|KASSERT
argument_list|(
name|mn
operator|->
name|mn_parent
operator|!=
name|NULL
argument_list|,
operator|(
literal|"mqfstype_this node has no parent"
operator|)
argument_list|)
expr_stmt|;
name|mn
operator|->
name|mn_fileno
operator|=
name|mn
operator|->
name|mn_parent
operator|->
name|mn_fileno
expr_stmt|;
break|break;
case|case
name|mqfstype_parent
case|:
name|KASSERT
argument_list|(
name|mn
operator|->
name|mn_parent
operator|!=
name|NULL
argument_list|,
operator|(
literal|"mqfstype_parent node has no parent"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mn
operator|->
name|mn_parent
operator|==
name|mi
operator|->
name|mi_root
condition|)
block|{
name|mn
operator|->
name|mn_fileno
operator|=
name|mn
operator|->
name|mn_parent
operator|->
name|mn_fileno
expr_stmt|;
break|break;
block|}
name|KASSERT
argument_list|(
name|mn
operator|->
name|mn_parent
operator|->
name|mn_parent
operator|!=
name|NULL
argument_list|,
operator|(
literal|"mqfstype_parent node has no grandparent"
operator|)
argument_list|)
expr_stmt|;
name|mn
operator|->
name|mn_fileno
operator|=
name|mn
operator|->
name|mn_parent
operator|->
name|mn_parent
operator|->
name|mn_fileno
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"mqfs_fileno_alloc() called for unknown type node: %d"
operator|,
name|mn
operator|->
name|mn_type
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Release a file number  */
end_comment

begin_function
specifier|static
name|void
name|mqfs_fileno_free
parameter_list|(
name|struct
name|mqfs_info
modifier|*
name|mi
parameter_list|,
name|struct
name|mqfs_node
modifier|*
name|mn
parameter_list|)
block|{
switch|switch
condition|(
name|mn
operator|->
name|mn_type
condition|)
block|{
case|case
name|mqfstype_root
case|:
case|case
name|mqfstype_dir
case|:
case|case
name|mqfstype_file
case|:
case|case
name|mqfstype_symlink
case|:
name|free_unr
argument_list|(
name|mi
operator|->
name|mi_unrhdr
argument_list|,
name|mn
operator|->
name|mn_fileno
argument_list|)
expr_stmt|;
break|break;
case|case
name|mqfstype_this
case|:
case|case
name|mqfstype_parent
case|:
comment|/* ignore these, as they don't "own" their file number */
break|break;
default|default:
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"mqfs_fileno_free() called for unknown type node: %d"
operator|,
name|mn
operator|->
name|mn_type
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|mqfs_node
operator|*
name|mqnode_alloc
argument_list|(
argument|void
argument_list|)
block|{
return|return
name|uma_zalloc
argument_list|(
name|mqnode_zone
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|__inline
name|void
name|mqnode_free
parameter_list|(
name|struct
name|mqfs_node
modifier|*
name|node
parameter_list|)
block|{
name|uma_zfree
argument_list|(
name|mqnode_zone
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|mqnode_addref
parameter_list|(
name|struct
name|mqfs_node
modifier|*
name|node
parameter_list|)
block|{
name|atomic_fetchadd_int
argument_list|(
operator|&
name|node
operator|->
name|mn_refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|mqnode_release
parameter_list|(
name|struct
name|mqfs_node
modifier|*
name|node
parameter_list|)
block|{
name|int
name|old
decl_stmt|,
name|exp
decl_stmt|;
name|old
operator|=
name|atomic_fetchadd_int
argument_list|(
operator|&
name|node
operator|->
name|mn_refcount
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|mn_type
operator|==
name|mqfstype_dir
operator|||
name|node
operator|->
name|mn_type
operator|==
name|mqfstype_root
condition|)
name|exp
operator|=
literal|3
expr_stmt|;
comment|/* include . and .. */
else|else
name|exp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|exp
condition|)
name|mqfs_destroy
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a node to a directory  */
end_comment

begin_function
specifier|static
name|int
name|mqfs_add_node
parameter_list|(
name|struct
name|mqfs_node
modifier|*
name|parent
parameter_list|,
name|struct
name|mqfs_node
modifier|*
name|node
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|parent
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s(): parent is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|parent
operator|->
name|mn_info
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s(): parent has no mn_info"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|parent
operator|->
name|mn_type
operator|==
name|mqfstype_dir
operator|||
name|parent
operator|->
name|mn_type
operator|==
name|mqfstype_root
argument_list|,
operator|(
literal|"%s(): parent is not a directory"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|mn_info
operator|=
name|parent
operator|->
name|mn_info
expr_stmt|;
name|node
operator|->
name|mn_parent
operator|=
name|parent
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|node
operator|->
name|mn_children
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|node
operator|->
name|mn_vnodes
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|parent
operator|->
name|mn_children
argument_list|,
name|node
argument_list|,
name|mn_sibling
argument_list|)
expr_stmt|;
name|mqnode_addref
argument_list|(
name|parent
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mqfs_node
modifier|*
name|mqfs_create_node
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|nodetype
parameter_list|)
block|{
name|struct
name|mqfs_node
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|mqnode_alloc
argument_list|()
expr_stmt|;
name|strncpy
argument_list|(
name|node
operator|->
name|mn_name
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|node
operator|->
name|mn_type
operator|=
name|nodetype
expr_stmt|;
name|node
operator|->
name|mn_refcount
operator|=
literal|1
expr_stmt|;
name|getnanotime
argument_list|(
operator|&
name|node
operator|->
name|mn_birth
argument_list|)
expr_stmt|;
name|node
operator|->
name|mn_ctime
operator|=
name|node
operator|->
name|mn_atime
operator|=
name|node
operator|->
name|mn_mtime
operator|=
name|node
operator|->
name|mn_birth
expr_stmt|;
name|node
operator|->
name|mn_uid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|node
operator|->
name|mn_gid
operator|=
name|cred
operator|->
name|cr_gid
expr_stmt|;
name|node
operator|->
name|mn_mode
operator|=
name|mode
expr_stmt|;
return|return
operator|(
name|node
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a file  */
end_comment

begin_function
specifier|static
name|struct
name|mqfs_node
modifier|*
name|mqfs_create_file
parameter_list|(
name|struct
name|mqfs_node
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|mqfs_node
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|mqfs_create_node
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|,
name|cred
argument_list|,
name|mode
argument_list|,
name|mqfstype_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|mqfs_add_node
argument_list|(
name|parent
argument_list|,
name|node
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mqnode_free
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|node
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add . and .. to a directory  */
end_comment

begin_function
specifier|static
name|int
name|mqfs_fixup_dir
parameter_list|(
name|struct
name|mqfs_node
modifier|*
name|parent
parameter_list|)
block|{
name|struct
name|mqfs_node
modifier|*
name|dir
decl_stmt|;
name|dir
operator|=
name|mqnode_alloc
argument_list|()
expr_stmt|;
name|dir
operator|->
name|mn_name
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|dir
operator|->
name|mn_type
operator|=
name|mqfstype_this
expr_stmt|;
name|dir
operator|->
name|mn_refcount
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mqfs_add_node
argument_list|(
name|parent
argument_list|,
name|dir
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mqnode_free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|dir
operator|=
name|mqnode_alloc
argument_list|()
expr_stmt|;
name|dir
operator|->
name|mn_name
index|[
literal|0
index|]
operator|=
name|dir
operator|->
name|mn_name
index|[
literal|1
index|]
operator|=
literal|'.'
expr_stmt|;
name|dir
operator|->
name|mn_type
operator|=
name|mqfstype_parent
expr_stmt|;
name|dir
operator|->
name|mn_refcount
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mqfs_add_node
argument_list|(
name|parent
argument_list|,
name|dir
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mqnode_free
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_comment
comment|/*  * Create a directory  */
end_comment

begin_function
specifier|static
name|struct
name|mqfs_node
modifier|*
name|mqfs_create_dir
parameter_list|(
name|struct
name|mqfs_node
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|mqfs_node
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|mqfs_create_node
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|,
name|cred
argument_list|,
name|mode
argument_list|,
name|mqfstype_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|mqfs_add_node
argument_list|(
name|parent
argument_list|,
name|node
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mqnode_free
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|mqfs_fixup_dir
argument_list|(
name|node
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mqfs_destroy
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|node
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a symlink  */
end_comment

begin_function
specifier|static
name|struct
name|mqfs_node
modifier|*
name|mqfs_create_link
parameter_list|(
name|struct
name|mqfs_node
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|struct
name|mqfs_node
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|mqfs_create_node
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|,
name|cred
argument_list|,
name|mode
argument_list|,
name|mqfstype_symlink
argument_list|)
expr_stmt|;
if|if
condition|(
name|mqfs_add_node
argument_list|(
name|parent
argument_list|,
name|node
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mqnode_free
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|node
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Destroy a node or a tree of nodes  */
end_comment

begin_function
specifier|static
name|int
name|mqfs_destroy
parameter_list|(
name|struct
name|mqfs_node
modifier|*
name|node
parameter_list|)
block|{
name|struct
name|mqfs_node
modifier|*
name|parent
decl_stmt|;
name|KASSERT
argument_list|(
name|node
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s(): node is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|node
operator|->
name|mn_info
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s(): node has no mn_info"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* destroy children */
if|if
condition|(
name|node
operator|->
name|mn_type
operator|==
name|mqfstype_dir
operator|||
name|node
operator|->
name|mn_type
operator|==
name|mqfstype_root
condition|)
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|node
operator|->
name|mn_children
argument_list|)
condition|)
name|mqfs_destroy
argument_list|(
name|LIST_FIRST
argument_list|(
operator|&
name|node
operator|->
name|mn_children
argument_list|)
argument_list|)
expr_stmt|;
comment|/* unlink from parent */
if|if
condition|(
operator|(
name|parent
operator|=
name|node
operator|->
name|mn_parent
operator|)
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|parent
operator|->
name|mn_info
operator|==
name|node
operator|->
name|mn_info
argument_list|,
operator|(
literal|"%s(): parent has different mn_info"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|node
argument_list|,
name|mn_sibling
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|node
operator|->
name|mn_fileno
operator|!=
literal|0
condition|)
name|mqfs_fileno_free
argument_list|(
name|node
operator|->
name|mn_info
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|mn_data
operator|!=
name|NULL
condition|)
name|mqueue_free
argument_list|(
name|node
operator|->
name|mn_data
argument_list|)
expr_stmt|;
name|mqnode_free
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mount a mqfs instance  */
end_comment

begin_function
specifier|static
name|int
name|mqfs_mount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|statfs
modifier|*
name|sbp
decl_stmt|;
if|if
condition|(
name|mp
operator|->
name|mnt_flag
operator|&
name|MNT_UPDATE
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|mp
operator|->
name|mnt_data
operator|=
operator|&
name|mqfs_data
expr_stmt|;
name|MNT_ILOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|mnt_flag
operator||=
name|MNT_LOCAL
expr_stmt|;
name|mp
operator|->
name|mnt_kern_flag
operator||=
name|MNTK_MPSAFE
expr_stmt|;
name|MNT_IUNLOCK
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|vfs_getnewfsid
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|sbp
operator|=
operator|&
name|mp
operator|->
name|mnt_stat
expr_stmt|;
name|vfs_mountedfrom
argument_list|(
name|mp
argument_list|,
literal|"mqueue"
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|f_bsize
operator|=
name|PAGE_SIZE
expr_stmt|;
name|sbp
operator|->
name|f_iosize
operator|=
name|PAGE_SIZE
expr_stmt|;
name|sbp
operator|->
name|f_blocks
operator|=
literal|1
expr_stmt|;
name|sbp
operator|->
name|f_bfree
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_bavail
operator|=
literal|0
expr_stmt|;
name|sbp
operator|->
name|f_files
operator|=
literal|1
expr_stmt|;
name|sbp
operator|->
name|f_ffree
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unmount a mqfs instance  */
end_comment

begin_function
specifier|static
name|int
name|mqfs_unmount
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|mntflags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|vflush
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
operator|(
name|mntflags
operator|&
name|MNT_FORCE
operator|)
condition|?
name|FORCECLOSE
else|:
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a root vnode  */
end_comment

begin_function
specifier|static
name|int
name|mqfs_root
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mqfs_info
modifier|*
name|mqfs
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|mqfs
operator|=
name|VFSTOMQFS
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|mqfs
operator|->
name|mi_lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mqfs_allocv
argument_list|(
name|mp
argument_list|,
name|vpp
argument_list|,
name|mqfs
operator|->
name|mi_root
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|mqfs
operator|->
name|mi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return filesystem stats  */
end_comment

begin_function
specifier|static
name|int
name|mqfs_statfs
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|statfs
modifier|*
name|sbp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
comment|/* XXX update statistics */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a mqfs instance  */
end_comment

begin_function
specifier|static
name|int
name|mqfs_init
parameter_list|(
name|struct
name|vfsconf
modifier|*
name|vfc
parameter_list|)
block|{
name|struct
name|mqfs_node
modifier|*
name|root
decl_stmt|;
name|struct
name|mqfs_info
modifier|*
name|mi
decl_stmt|;
name|mqnode_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"mqnode"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mqfs_node
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mqueue_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"mqueue"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mqueue
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mvdata_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"mvdata"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mqfs_vdata
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mqnoti_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"mqnotifier"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mqueue_notifier
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mi
operator|=
operator|&
name|mqfs_data
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|mi
operator|->
name|mi_lock
argument_list|,
literal|"mqfs lock"
argument_list|)
expr_stmt|;
comment|/* set up the root diretory */
name|root
operator|=
name|mqfs_create_node
argument_list|(
literal|"/"
argument_list|,
literal|1
argument_list|,
name|curthread
operator|->
name|td_ucred
argument_list|,
literal|01777
argument_list|,
name|mqfstype_root
argument_list|)
expr_stmt|;
name|root
operator|->
name|mn_info
operator|=
name|mi
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|root
operator|->
name|mn_children
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|root
operator|->
name|mn_vnodes
argument_list|)
expr_stmt|;
name|mi
operator|->
name|mi_root
operator|=
name|root
expr_stmt|;
name|mqfs_fileno_init
argument_list|(
name|mi
argument_list|)
expr_stmt|;
name|mqfs_fileno_alloc
argument_list|(
name|mi
argument_list|,
name|root
argument_list|)
expr_stmt|;
name|mqfs_fixup_dir
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|exit_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|process_exit
argument_list|,
name|mq_proc_exit
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|mq_fdclose
operator|=
name|mqueue_fdclose
expr_stmt|;
name|p31b_setcfg
argument_list|(
name|CTL_P1003_1B_MESSAGE_PASSING
argument_list|,
name|_POSIX_MESSAGE_PASSING
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy a mqfs instance  */
end_comment

begin_function
specifier|static
name|int
name|mqfs_uninit
parameter_list|(
name|struct
name|vfsconf
modifier|*
name|vfc
parameter_list|)
block|{
name|struct
name|mqfs_info
modifier|*
name|mi
decl_stmt|;
if|if
condition|(
operator|!
name|unloadable
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|process_exit
argument_list|,
name|exit_tag
argument_list|)
expr_stmt|;
name|mi
operator|=
operator|&
name|mqfs_data
expr_stmt|;
name|mqfs_destroy
argument_list|(
name|mi
operator|->
name|mi_root
argument_list|)
expr_stmt|;
name|mi
operator|->
name|mi_root
operator|=
name|NULL
expr_stmt|;
name|mqfs_fileno_uninit
argument_list|(
name|mi
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|mi
operator|->
name|mi_lock
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|mqnode_zone
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|mqueue_zone
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|mvdata_zone
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|mqnoti_zone
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * task routine  */
end_comment

begin_function
specifier|static
name|void
name|do_recycle
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|context
decl_stmt|;
name|vrecycle
argument_list|(
name|vp
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|vdrop
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a vnode  */
end_comment

begin_function
specifier|static
name|int
name|mqfs_allocv
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|mqfs_node
modifier|*
name|pn
parameter_list|)
block|{
name|struct
name|mqfs_vdata
modifier|*
name|vd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|vd
argument_list|,
argument|&pn->mn_vnodes
argument_list|,
argument|mv_link
argument_list|)
block|{
if|if
condition|(
name|vd
operator|->
name|mv_vnode
operator|->
name|v_mount
operator|==
name|mp
condition|)
break|break;
block|}
if|if
condition|(
name|vd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|vget
argument_list|(
name|vd
operator|->
name|mv_vnode
argument_list|,
literal|0
argument_list|,
name|curthread
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|vpp
operator|=
name|vd
operator|->
name|mv_vnode
expr_stmt|;
name|vn_lock
argument_list|(
operator|*
name|vpp
argument_list|,
name|LK_RETRY
operator||
name|LK_EXCLUSIVE
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* XXX if this can happen, we're in trouble */
block|}
name|error
operator|=
name|getnewvnode
argument_list|(
literal|"mqueue"
argument_list|,
name|mp
argument_list|,
operator|&
name|mqfs_vnodeops
argument_list|,
name|vpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vd
operator|=
name|uma_zalloc
argument_list|(
name|mvdata_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_data
operator|=
name|vd
expr_stmt|;
name|vd
operator|->
name|mv_vnode
operator|=
operator|*
name|vpp
expr_stmt|;
name|vd
operator|->
name|mv_node
operator|=
name|pn
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|vd
operator|->
name|mv_task
argument_list|,
literal|0
argument_list|,
name|do_recycle
argument_list|,
operator|*
name|vpp
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pn
operator|->
name|mn_vnodes
argument_list|,
name|vd
argument_list|,
name|mv_link
argument_list|)
expr_stmt|;
name|mqnode_addref
argument_list|(
name|pn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pn
operator|->
name|mn_type
condition|)
block|{
case|case
name|mqfstype_root
case|:
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_vflag
operator|=
name|VV_ROOT
expr_stmt|;
comment|/* fall through */
case|case
name|mqfstype_dir
case|:
case|case
name|mqfstype_this
case|:
case|case
name|mqfstype_parent
case|:
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_type
operator|=
name|VDIR
expr_stmt|;
break|break;
case|case
name|mqfstype_file
case|:
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_type
operator|=
name|VREG
expr_stmt|;
break|break;
case|case
name|mqfstype_symlink
case|:
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_type
operator|=
name|VLNK
expr_stmt|;
break|break;
case|case
name|mqfstype_none
case|:
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"mqfs_allocf called for null node\n"
operator|)
argument_list|)
expr_stmt|;
default|default:
name|panic
argument_list|(
literal|"%s has unexpected type: %d"
argument_list|,
name|pn
operator|->
name|mn_name
argument_list|,
name|pn
operator|->
name|mn_type
argument_list|)
expr_stmt|;
block|}
name|vn_lock
argument_list|(
operator|*
name|vpp
argument_list|,
name|LK_RETRY
operator||
name|LK_EXCLUSIVE
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * Search a directory entry  */
end_comment

begin_function
specifier|static
name|struct
name|mqfs_node
modifier|*
name|mqfs_search
parameter_list|(
name|struct
name|mqfs_node
modifier|*
name|pd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|mqfs_node
modifier|*
name|pn
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pn
argument_list|,
argument|&pd->mn_children
argument_list|,
argument|mn_sibling
argument_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|pn
operator|->
name|mn_name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|pn
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up a file or directory.  */
end_comment

begin_function
specifier|static
name|int
name|mqfs_lookupx
parameter_list|(
name|struct
name|vop_cachedlookup_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|componentname
modifier|*
name|cnp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|,
modifier|*
modifier|*
name|vpp
decl_stmt|;
name|struct
name|mqfs_node
modifier|*
name|pd
decl_stmt|;
name|struct
name|mqfs_node
modifier|*
name|pn
decl_stmt|;
name|int
name|nameiop
decl_stmt|,
name|flags
decl_stmt|,
name|error
decl_stmt|,
name|namelen
decl_stmt|;
name|char
modifier|*
name|pname
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|cnp
operator|=
name|ap
operator|->
name|a_cnp
expr_stmt|;
name|vpp
operator|=
name|ap
operator|->
name|a_vpp
expr_stmt|;
name|dvp
operator|=
name|ap
operator|->
name|a_dvp
expr_stmt|;
name|pname
operator|=
name|cnp
operator|->
name|cn_nameptr
expr_stmt|;
name|namelen
operator|=
name|cnp
operator|->
name|cn_namelen
expr_stmt|;
name|td
operator|=
name|cnp
operator|->
name|cn_thread
expr_stmt|;
name|flags
operator|=
name|cnp
operator|->
name|cn_flags
expr_stmt|;
name|nameiop
operator|=
name|cnp
operator|->
name|cn_nameiop
expr_stmt|;
name|pd
operator|=
name|VTON
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|pn
operator|=
name|NULL
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULLVP
expr_stmt|;
if|if
condition|(
name|dvp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
return|return
operator|(
name|ENOTDIR
operator|)
return|;
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|dvp
argument_list|,
name|VEXEC
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* shortcut: check if the name is too long */
if|if
condition|(
name|cnp
operator|->
name|cn_namelen
operator|>=
name|MQFS_NAMELEN
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* self */
if|if
condition|(
name|namelen
operator|==
literal|1
operator|&&
name|pname
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
operator|&&
name|nameiop
operator|!=
name|LOOKUP
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pn
operator|=
name|pd
expr_stmt|;
operator|*
name|vpp
operator|=
name|dvp
expr_stmt|;
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* parent */
if|if
condition|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
condition|)
block|{
if|if
condition|(
name|dvp
operator|->
name|v_vflag
operator|&
name|VV_ROOT
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
operator|&&
name|nameiop
operator|!=
name|LOOKUP
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pd
operator|->
name|mn_parent
argument_list|,
operator|(
literal|"non-root directory has no parent"
operator|)
argument_list|)
expr_stmt|;
name|pn
operator|=
name|pd
operator|->
name|mn_parent
expr_stmt|;
name|error
operator|=
name|mqfs_allocv
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|,
name|vpp
argument_list|,
name|pn
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* named node */
name|pn
operator|=
name|mqfs_search
argument_list|(
name|pd
argument_list|,
name|pname
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
comment|/* found */
if|if
condition|(
name|pn
operator|!=
name|NULL
condition|)
block|{
comment|/* DELETE */
if|if
condition|(
name|nameiop
operator|==
name|DELETE
operator|&&
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
condition|)
block|{
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|dvp
argument_list|,
name|VWRITE
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|*
name|vpp
operator|==
name|dvp
condition|)
block|{
name|VREF
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|dvp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* allocate vnode */
name|error
operator|=
name|mqfs_allocv
argument_list|(
name|dvp
operator|->
name|v_mount
argument_list|,
name|vpp
argument_list|,
name|pn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
condition|)
name|cache_enter
argument_list|(
name|dvp
argument_list|,
operator|*
name|vpp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* not found */
comment|/* will create a new entry in the directory ? */
if|if
condition|(
operator|(
name|nameiop
operator|==
name|CREATE
operator|||
name|nameiop
operator|==
name|RENAME
operator|)
operator|&&
operator|(
name|flags
operator|&
name|LOCKPARENT
operator|)
operator|&&
operator|(
name|flags
operator|&
name|ISLASTCN
operator|)
condition|)
block|{
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|dvp
argument_list|,
name|VWRITE
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
return|return
operator|(
name|EJUSTRETURN
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct vop_lookup_args { 	struct vop_generic_args a_gen; 	struct vnode *a_dvp; 	struct vnode **a_vpp; 	struct componentname *a_cnp; };
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * vnode lookup operation  */
end_comment

begin_function
specifier|static
name|int
name|mqfs_lookup
parameter_list|(
name|struct
name|vop_cachedlookup_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|mqfs_info
modifier|*
name|mqfs
init|=
name|VFSTOMQFS
argument_list|(
name|ap
operator|->
name|a_dvp
operator|->
name|v_mount
argument_list|)
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|mqfs
operator|->
name|mi_lock
argument_list|)
expr_stmt|;
name|rc
operator|=
name|mqfs_lookupx
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|mqfs
operator|->
name|mi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct vop_create_args { 	struct vnode *a_dvp; 	struct vnode **a_vpp; 	struct componentname *a_cnp; 	struct vattr *a_vap; };
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * vnode creation operation  */
end_comment

begin_function
specifier|static
name|int
name|mqfs_create
parameter_list|(
name|struct
name|vop_create_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|mqfs_info
modifier|*
name|mqfs
init|=
name|VFSTOMQFS
argument_list|(
name|ap
operator|->
name|a_dvp
operator|->
name|v_mount
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|mqfs_node
modifier|*
name|pd
decl_stmt|;
name|struct
name|mqfs_node
modifier|*
name|pn
decl_stmt|;
name|struct
name|mqueue
modifier|*
name|mq
decl_stmt|;
name|int
name|error
decl_stmt|;
name|pd
operator|=
name|VTON
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pd
operator|->
name|mn_type
operator|!=
name|mqfstype_root
operator|&&
name|pd
operator|->
name|mn_type
operator|!=
name|mqfstype_dir
condition|)
return|return
operator|(
name|ENOTDIR
operator|)
return|;
name|mq
operator|=
name|mqueue_alloc
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mq
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|mqfs
operator|->
name|mi_lock
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* named node */
block|pn = mqfs_search(pd, cnp->cn_nameptr, cnp->cn_namelen); 	if (pn != NULL) { 		mqueue_free(mq); 		sx_xunlock(&mqfs->mi_lock); 		return (EEXIST); 	}
else|#
directive|else
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|HASBUF
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: no name"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pn
operator|=
name|mqfs_create_file
argument_list|(
name|pd
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|ap
operator|->
name|a_vap
operator|->
name|va_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOSPC
expr_stmt|;
else|else
block|{
name|error
operator|=
name|mqfs_allocv
argument_list|(
name|ap
operator|->
name|a_dvp
operator|->
name|v_mount
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|pn
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|mqfs_destroy
argument_list|(
name|pn
argument_list|)
expr_stmt|;
else|else
name|pn
operator|->
name|mn_data
operator|=
name|mq
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|mqfs
operator|->
name|mi_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|mqueue_free
argument_list|(
name|mq
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove an entry  */
end_comment

begin_function
specifier|static
name|int
name|do_unlink
parameter_list|(
name|struct
name|mqfs_node
modifier|*
name|pn
parameter_list|,
name|struct
name|ucred
modifier|*
name|ucred
parameter_list|)
block|{
name|struct
name|mqfs_node
modifier|*
name|parent
decl_stmt|;
name|struct
name|mqfs_vdata
modifier|*
name|vd
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pn
operator|->
name|mn_info
operator|->
name|mi_lock
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
comment|/* 	 * XXXRW: Other instances of the message queue primitive are 	 * allowed in jail? 	 */
if|if
condition|(
name|ucred
operator|->
name|cr_uid
operator|!=
name|pn
operator|->
name|mn_uid
operator|&&
operator|(
name|error
operator|=
name|priv_check_cred
argument_list|(
name|ucred
argument_list|,
name|PRIV_MQ_ADMIN
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|error
operator|=
name|EACCES
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|pn
operator|->
name|mn_deleted
condition|)
block|{
name|parent
operator|=
name|pn
operator|->
name|mn_parent
expr_stmt|;
name|pn
operator|->
name|mn_parent
operator|=
name|NULL
expr_stmt|;
name|pn
operator|->
name|mn_deleted
operator|=
literal|1
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|pn
argument_list|,
name|mn_sibling
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|vd
argument_list|,
argument|&pn->mn_vnodes
argument_list|,
argument|mv_link
argument_list|)
block|{
name|cache_purge
argument_list|(
name|vd
operator|->
name|mv_vnode
argument_list|)
expr_stmt|;
name|vhold
argument_list|(
name|vd
operator|->
name|mv_vnode
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|vd
operator|->
name|mv_task
argument_list|)
expr_stmt|;
block|}
name|mqnode_release
argument_list|(
name|pn
argument_list|)
expr_stmt|;
name|mqnode_release
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct vop_remove_args { 	struct vnode *a_dvp; 	struct vnode *a_vp; 	struct componentname *a_cnp; };
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * vnode removal operation  */
end_comment

begin_function
specifier|static
name|int
name|mqfs_remove
parameter_list|(
name|struct
name|vop_remove_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|mqfs_info
modifier|*
name|mqfs
init|=
name|VFSTOMQFS
argument_list|(
name|ap
operator|->
name|a_dvp
operator|->
name|v_mount
argument_list|)
decl_stmt|;
name|struct
name|mqfs_node
modifier|*
name|pn
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|pn
operator|=
name|VTON
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|mqfs
operator|->
name|mi_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|do_unlink
argument_list|(
name|pn
argument_list|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_cred
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|mqfs
operator|->
name|mi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct vop_inactive_args { 	struct vnode *a_vp; 	struct thread *a_td; };
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|mqfs_inactive
parameter_list|(
name|struct
name|vop_inactive_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|mqfs_node
modifier|*
name|pn
init|=
name|VTON
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
if|if
condition|(
name|pn
operator|->
name|mn_deleted
condition|)
name|vrecycle
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct vop_reclaim_args { 	struct vop_generic_args a_gen; 	struct vnode *a_vp; 	struct thread *a_td; };
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|mqfs_reclaim
parameter_list|(
name|struct
name|vop_reclaim_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|mqfs_info
modifier|*
name|mqfs
init|=
name|VFSTOMQFS
argument_list|(
name|ap
operator|->
name|a_vp
operator|->
name|v_mount
argument_list|)
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|mqfs_node
modifier|*
name|pn
decl_stmt|;
name|struct
name|mqfs_vdata
modifier|*
name|vd
decl_stmt|;
name|vd
operator|=
name|vp
operator|->
name|v_data
expr_stmt|;
name|pn
operator|=
name|vd
operator|->
name|mv_node
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|mqfs
operator|->
name|mi_lock
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|NULL
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|vd
argument_list|,
name|mv_link
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|mvdata_zone
argument_list|,
name|vd
argument_list|)
expr_stmt|;
name|mqnode_release
argument_list|(
name|pn
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|mqfs
operator|->
name|mi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct vop_open_args { 	struct vop_generic_args a_gen; 	struct vnode *a_vp; 	int a_mode; 	struct ucred *a_cred; 	struct thread *a_td; 	int a_fdidx; };
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|mqfs_open
parameter_list|(
name|struct
name|vop_open_args
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct vop_close_args { 	struct vop_generic_args a_gen; 	struct vnode *a_vp; 	int a_fflag; 	struct ucred *a_cred; 	struct thread *a_td; };
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|mqfs_close
parameter_list|(
name|struct
name|vop_close_args
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct vop_access_args { 	struct vop_generic_args a_gen; 	struct vnode *a_vp; 	int a_mode; 	struct ucred *a_cred; 	struct thread *a_td; };
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Verify permissions  */
end_comment

begin_function
specifier|static
name|int
name|mqfs_access
parameter_list|(
name|struct
name|vop_access_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|vaccess
argument_list|(
name|vp
operator|->
name|v_type
argument_list|,
name|vattr
operator|.
name|va_mode
argument_list|,
name|vattr
operator|.
name|va_uid
argument_list|,
name|vattr
operator|.
name|va_gid
argument_list|,
name|ap
operator|->
name|a_mode
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct vop_getattr_args { 	struct vop_generic_args a_gen; 	struct vnode *a_vp; 	struct vattr *a_vap; 	struct ucred *a_cred; 	struct thread *a_td; };
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Get file attributes  */
end_comment

begin_function
specifier|static
name|int
name|mqfs_getattr
parameter_list|(
name|struct
name|vop_getattr_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|mqfs_node
modifier|*
name|pn
init|=
name|VTON
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|VATTR_NULL
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_type
operator|=
name|vp
operator|->
name|v_type
expr_stmt|;
name|vap
operator|->
name|va_mode
operator|=
name|pn
operator|->
name|mn_mode
expr_stmt|;
name|vap
operator|->
name|va_nlink
operator|=
literal|1
expr_stmt|;
name|vap
operator|->
name|va_uid
operator|=
name|pn
operator|->
name|mn_uid
expr_stmt|;
name|vap
operator|->
name|va_gid
operator|=
name|pn
operator|->
name|mn_gid
expr_stmt|;
name|vap
operator|->
name|va_fsid
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
name|vap
operator|->
name|va_fileid
operator|=
name|pn
operator|->
name|mn_fileno
expr_stmt|;
name|vap
operator|->
name|va_size
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_blocksize
operator|=
name|PAGE_SIZE
expr_stmt|;
name|vap
operator|->
name|va_bytes
operator|=
name|vap
operator|->
name|va_size
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_atime
operator|=
name|pn
operator|->
name|mn_atime
expr_stmt|;
name|vap
operator|->
name|va_mtime
operator|=
name|pn
operator|->
name|mn_mtime
expr_stmt|;
name|vap
operator|->
name|va_ctime
operator|=
name|pn
operator|->
name|mn_ctime
expr_stmt|;
name|vap
operator|->
name|va_birthtime
operator|=
name|pn
operator|->
name|mn_birth
expr_stmt|;
name|vap
operator|->
name|va_gen
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_flags
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_rdev
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_bytes
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_filerev
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_vaflags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct vop_setattr_args { 	struct vop_generic_args a_gen; 	struct vnode *a_vp; 	struct vattr *a_vap; 	struct ucred *a_cred; 	struct thread *a_td; };
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Set attributes  */
end_comment

begin_function
specifier|static
name|int
name|mqfs_setattr
parameter_list|(
name|struct
name|vop_setattr_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|mqfs_node
modifier|*
name|pn
decl_stmt|;
name|struct
name|vattr
modifier|*
name|vap
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|c
decl_stmt|,
name|error
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|vap
operator|=
name|ap
operator|->
name|a_vap
expr_stmt|;
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
if|if
condition|(
operator|(
name|vap
operator|->
name|va_type
operator|!=
name|VNON
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_nlink
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_fsid
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_fileid
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_blocksize
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_flags
operator|!=
name|VNOVAL
operator|&&
name|vap
operator|->
name|va_flags
operator|!=
literal|0
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_rdev
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
operator|(
name|int
operator|)
name|vap
operator|->
name|va_bytes
operator|!=
name|VNOVAL
operator|)
operator|||
operator|(
name|vap
operator|->
name|va_gen
operator|!=
name|VNOVAL
operator|)
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|pn
operator|=
name|VTON
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_uid
operator|==
operator|(
name|uid_t
operator|)
name|VNOVAL
condition|)
name|uid
operator|=
name|pn
operator|->
name|mn_uid
expr_stmt|;
else|else
name|uid
operator|=
name|vap
operator|->
name|va_uid
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_gid
operator|==
operator|(
name|gid_t
operator|)
name|VNOVAL
condition|)
name|gid
operator|=
name|pn
operator|->
name|mn_gid
expr_stmt|;
else|else
name|gid
operator|=
name|vap
operator|->
name|va_gid
expr_stmt|;
if|if
condition|(
name|uid
operator|!=
name|pn
operator|->
name|mn_uid
operator|||
name|gid
operator|!=
name|pn
operator|->
name|mn_gid
condition|)
block|{
comment|/* 		 * To modify the ownership of a file, must possess VADMIN 		 * for that file. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VADMIN
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * XXXRW: Why is there a privilege check here: shouldn't the 		 * check in VOP_ACCESS() be enough?  Also, are the group bits 		 * below definitely right? 		 */
if|if
condition|(
operator|(
operator|(
name|ap
operator|->
name|a_cred
operator|->
name|cr_uid
operator|!=
name|pn
operator|->
name|mn_uid
operator|)
operator|||
name|uid
operator|!=
name|pn
operator|->
name|mn_uid
operator|||
operator|(
name|gid
operator|!=
name|pn
operator|->
name|mn_gid
operator|&&
operator|!
name|groupmember
argument_list|(
name|gid
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|error
operator|=
name|priv_check_cred
argument_list|(
name|ap
operator|->
name|a_td
operator|->
name|td_ucred
argument_list|,
name|PRIV_MQ_ADMIN
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pn
operator|->
name|mn_uid
operator|=
name|uid
expr_stmt|;
name|pn
operator|->
name|mn_gid
operator|=
name|gid
expr_stmt|;
name|c
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_mode
operator|!=
operator|(
name|mode_t
operator|)
name|VNOVAL
condition|)
block|{
if|if
condition|(
operator|(
name|ap
operator|->
name|a_cred
operator|->
name|cr_uid
operator|!=
name|pn
operator|->
name|mn_uid
operator|)
operator|&&
operator|(
name|error
operator|=
name|priv_check_cred
argument_list|(
name|ap
operator|->
name|a_td
operator|->
name|td_ucred
argument_list|,
name|PRIV_MQ_ADMIN
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|pn
operator|->
name|mn_mode
operator|=
name|vap
operator|->
name|va_mode
expr_stmt|;
name|c
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
operator|||
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
block|{
comment|/* See the comment in ufs_vnops::ufs_setattr(). */
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VADMIN
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|vap
operator|->
name|va_vaflags
operator|&
name|VA_UTIMES_NULL
operator|)
operator|==
literal|0
operator|||
operator|(
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VWRITE
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
operator|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|vap
operator|->
name|va_atime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
block|{
name|pn
operator|->
name|mn_atime
operator|=
name|vap
operator|->
name|va_atime
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_mtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
block|{
name|pn
operator|->
name|mn_mtime
operator|=
name|vap
operator|->
name|va_mtime
expr_stmt|;
block|}
name|c
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|c
condition|)
block|{
name|vfs_timestamp
argument_list|(
operator|&
name|pn
operator|->
name|mn_ctime
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct vop_read_args { 	struct vop_generic_args a_gen; 	struct vnode *a_vp; 	struct uio *a_uio; 	int a_ioflag; 	struct ucred *a_cred; };
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Read from a file  */
end_comment

begin_function
specifier|static
name|int
name|mqfs_read
parameter_list|(
name|struct
name|vop_read_args
modifier|*
name|ap
parameter_list|)
block|{
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|struct
name|mqfs_node
modifier|*
name|pn
decl_stmt|;
name|struct
name|mqueue
modifier|*
name|mq
decl_stmt|;
name|int
name|len
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pn
operator|=
name|VTON
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|mq
operator|=
name|VTOMQ
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"QSIZE:%-10ld MAXMSG:%-10ld CURMSG:%-10ld MSGSIZE:%-10ld\n"
argument_list|,
name|mq
operator|->
name|mq_totalbytes
argument_list|,
name|mq
operator|->
name|mq_maxmsg
argument_list|,
name|mq
operator|->
name|mq_curmsgs
argument_list|,
name|mq
operator|->
name|mq_msgsize
argument_list|)
expr_stmt|;
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove_frombuf
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct vop_readdir_args { 	struct vop_generic_args a_gen; 	struct vnode *a_vp; 	struct uio *a_uio; 	struct ucred *a_cred; 	int *a_eofflag; 	int *a_ncookies; 	u_long **a_cookies; };
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Return directory entries.  */
end_comment

begin_function
specifier|static
name|int
name|mqfs_readdir
parameter_list|(
name|struct
name|vop_readdir_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|mqfs_info
modifier|*
name|mi
decl_stmt|;
name|struct
name|mqfs_node
modifier|*
name|pd
decl_stmt|;
name|struct
name|mqfs_node
modifier|*
name|pn
decl_stmt|;
name|struct
name|dirent
name|entry
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
modifier|*
name|tmp_ncookies
init|=
name|NULL
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
name|mi
operator|=
name|VFSTOMQFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|pd
operator|=
name|VTON
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|uio
operator|=
name|ap
operator|->
name|a_uio
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
return|return
operator|(
name|ENOTDIR
operator|)
return|;
if|if
condition|(
name|uio
operator|->
name|uio_offset
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ap
operator|->
name|a_ncookies
operator|!=
name|NULL
condition|)
block|{
name|tmp_ncookies
operator|=
name|ap
operator|->
name|a_ncookies
expr_stmt|;
operator|*
name|ap
operator|->
name|a_ncookies
operator|=
literal|0
expr_stmt|;
name|ap
operator|->
name|a_ncookies
operator|=
name|NULL
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|mi
operator|->
name|mi_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pn
argument_list|,
argument|&pd->mn_children
argument_list|,
argument|mn_sibling
argument_list|)
block|{
name|entry
operator|.
name|d_reclen
operator|=
sizeof|sizeof
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pn
operator|->
name|mn_fileno
condition|)
name|mqfs_fileno_alloc
argument_list|(
name|mi
argument_list|,
name|pn
argument_list|)
expr_stmt|;
name|entry
operator|.
name|d_fileno
operator|=
name|pn
operator|->
name|mn_fileno
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MQFS_NAMELEN
operator|-
literal|1
operator|&&
name|pn
operator|->
name|mn_name
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
operator|++
name|i
control|)
name|entry
operator|.
name|d_name
index|[
name|i
index|]
operator|=
name|pn
operator|->
name|mn_name
index|[
name|i
index|]
expr_stmt|;
name|entry
operator|.
name|d_name
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|entry
operator|.
name|d_namlen
operator|=
name|i
expr_stmt|;
switch|switch
condition|(
name|pn
operator|->
name|mn_type
condition|)
block|{
case|case
name|mqfstype_root
case|:
case|case
name|mqfstype_dir
case|:
case|case
name|mqfstype_this
case|:
case|case
name|mqfstype_parent
case|:
name|entry
operator|.
name|d_type
operator|=
name|DT_DIR
expr_stmt|;
break|break;
case|case
name|mqfstype_file
case|:
name|entry
operator|.
name|d_type
operator|=
name|DT_REG
expr_stmt|;
break|break;
case|case
name|mqfstype_symlink
case|:
name|entry
operator|.
name|d_type
operator|=
name|DT_LNK
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s has unexpected node type: %d"
argument_list|,
name|pn
operator|->
name|mn_name
argument_list|,
name|pn
operator|->
name|mn_type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|entry
operator|.
name|d_reclen
operator|>
name|uio
operator|->
name|uio_resid
condition|)
break|break;
if|if
condition|(
name|offset
operator|>=
name|uio
operator|->
name|uio_offset
condition|)
block|{
name|error
operator|=
name|vfs_read_dirent
argument_list|(
name|ap
argument_list|,
operator|&
name|entry
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|offset
operator|+=
name|entry
operator|.
name|d_reclen
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|mi
operator|->
name|mi_lock
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_offset
operator|=
name|offset
expr_stmt|;
if|if
condition|(
name|tmp_ncookies
operator|!=
name|NULL
condition|)
name|ap
operator|->
name|a_ncookies
operator|=
name|tmp_ncookies
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct vop_mkdir_args { 	struct vnode *a_dvp; 	struvt vnode **a_vpp; 	struvt componentname *a_cnp; 	struct vattr *a_vap; };
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Create a directory.  */
end_comment

begin_function
specifier|static
name|int
name|mqfs_mkdir
parameter_list|(
name|struct
name|vop_mkdir_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|mqfs_info
modifier|*
name|mqfs
init|=
name|VFSTOMQFS
argument_list|(
name|ap
operator|->
name|a_dvp
operator|->
name|v_mount
argument_list|)
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|struct
name|mqfs_node
modifier|*
name|pd
init|=
name|VTON
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|)
decl_stmt|;
name|struct
name|mqfs_node
modifier|*
name|pn
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|pd
operator|->
name|mn_type
operator|!=
name|mqfstype_root
operator|&&
name|pd
operator|->
name|mn_type
operator|!=
name|mqfstype_dir
condition|)
return|return
operator|(
name|ENOTDIR
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|mqfs
operator|->
name|mi_lock
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* named node */
block|pn = mqfs_search(pd, cnp->cn_nameptr, cnp->cn_namelen); 	if (pn != NULL) { 		sx_xunlock(&mqfs->mi_lock); 		return (EEXIST); 	}
else|#
directive|else
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|HASBUF
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: no name"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pn
operator|=
name|mqfs_create_dir
argument_list|(
name|pd
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_namelen
argument_list|,
name|ap
operator|->
name|a_vap
operator|->
name|cn_cred
argument_list|,
name|ap
operator|->
name|a_vap
operator|->
name|va_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOSPC
expr_stmt|;
else|else
name|error
operator|=
name|mqfs_allocv
argument_list|(
name|ap
operator|->
name|a_dvp
operator|->
name|v_mount
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|pn
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|mqfs
operator|->
name|mi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct vop_rmdir_args { 	struct vnode *a_dvp; 	struct vnode *a_vp; 	struct componentname *a_cnp; };
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Remove a directory.  */
end_comment

begin_function
specifier|static
name|int
name|mqfs_rmdir
parameter_list|(
name|struct
name|vop_rmdir_args
modifier|*
name|ap
parameter_list|)
block|{
name|struct
name|mqfs_info
modifier|*
name|mqfs
init|=
name|VFSTOMQFS
argument_list|(
name|ap
operator|->
name|a_dvp
operator|->
name|v_mount
argument_list|)
decl_stmt|;
name|struct
name|mqfs_node
modifier|*
name|pn
init|=
name|VTON
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
decl_stmt|;
name|struct
name|mqfs_node
modifier|*
name|pt
decl_stmt|;
if|if
condition|(
name|pn
operator|->
name|mn_type
operator|!=
name|mqfstype_dir
condition|)
return|return
operator|(
name|ENOTDIR
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|mqfs
operator|->
name|mi_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
operator|->
name|mn_deleted
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|mqfs
operator|->
name|mi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|pt
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|pn
operator|->
name|mn_children
argument_list|)
expr_stmt|;
name|pt
operator|=
name|LIST_NEXT
argument_list|(
name|pt
argument_list|,
name|mn_sibling
argument_list|)
expr_stmt|;
name|pt
operator|=
name|LIST_NEXT
argument_list|(
name|pt
argument_list|,
name|mn_sibling
argument_list|)
expr_stmt|;
if|if
condition|(
name|pt
operator|!=
name|NULL
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|mqfs
operator|->
name|mi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTEMPTY
operator|)
return|;
block|}
name|pt
operator|=
name|pn
operator|->
name|mn_parent
expr_stmt|;
name|pn
operator|->
name|mn_parent
operator|=
name|NULL
expr_stmt|;
name|pn
operator|->
name|mn_deleted
operator|=
literal|1
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|pn
argument_list|,
name|mn_sibling
argument_list|)
expr_stmt|;
name|mqnode_release
argument_list|(
name|pn
argument_list|)
expr_stmt|;
name|mqnode_release
argument_list|(
name|pt
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|mqfs
operator|->
name|mi_lock
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* notyet */
end_comment

begin_comment
comment|/*  * Allocate a message queue  */
end_comment

begin_function
specifier|static
name|struct
name|mqueue
modifier|*
name|mqueue_alloc
parameter_list|(
specifier|const
name|struct
name|mq_attr
modifier|*
name|attr
parameter_list|)
block|{
name|struct
name|mqueue
modifier|*
name|mq
decl_stmt|;
if|if
condition|(
name|curmq
operator|>=
name|maxmq
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|mq
operator|=
name|uma_zalloc
argument_list|(
name|mqueue_zone
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|mq
operator|->
name|mq_msgq
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|!=
name|NULL
condition|)
block|{
name|mq
operator|->
name|mq_maxmsg
operator|=
name|attr
operator|->
name|mq_maxmsg
expr_stmt|;
name|mq
operator|->
name|mq_msgsize
operator|=
name|attr
operator|->
name|mq_msgsize
expr_stmt|;
block|}
else|else
block|{
name|mq
operator|->
name|mq_maxmsg
operator|=
name|default_maxmsg
expr_stmt|;
name|mq
operator|->
name|mq_msgsize
operator|=
name|default_msgsize
expr_stmt|;
block|}
name|mtx_init
argument_list|(
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|,
literal|"mqueue"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|knlist_init
argument_list|(
operator|&
name|mq
operator|->
name|mq_rsel
operator|.
name|si_note
argument_list|,
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|knlist_init
argument_list|(
operator|&
name|mq
operator|->
name|mq_wsel
operator|.
name|si_note
argument_list|,
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|curmq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|mq
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy a message queue  */
end_comment

begin_function
specifier|static
name|void
name|mqueue_free
parameter_list|(
name|struct
name|mqueue
modifier|*
name|mq
parameter_list|)
block|{
name|struct
name|mqueue_msg
modifier|*
name|msg
decl_stmt|;
while|while
condition|(
operator|(
name|msg
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|mq
operator|->
name|mq_msgq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mq
operator|->
name|mq_msgq
argument_list|,
name|msg
argument_list|,
name|msg_link
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|msg
argument_list|,
name|M_MQUEUEDATA
argument_list|)
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|)
expr_stmt|;
name|knlist_destroy
argument_list|(
operator|&
name|mq
operator|->
name|mq_rsel
operator|.
name|si_note
argument_list|)
expr_stmt|;
name|knlist_destroy
argument_list|(
operator|&
name|mq
operator|->
name|mq_wsel
operator|.
name|si_note
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|mqueue_zone
argument_list|,
name|mq
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|curmq
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Load a message from user space  */
end_comment

begin_function
specifier|static
name|struct
name|mqueue_msg
modifier|*
name|mqueue_loadmsg
parameter_list|(
specifier|const
name|char
modifier|*
name|msg_ptr
parameter_list|,
name|size_t
name|msg_size
parameter_list|,
name|int
name|msg_prio
parameter_list|)
block|{
name|struct
name|mqueue_msg
modifier|*
name|msg
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mqueue_msg
argument_list|)
operator|+
name|msg_size
expr_stmt|;
name|MALLOC
argument_list|(
name|msg
argument_list|,
expr|struct
name|mqueue_msg
operator|*
argument_list|,
name|len
argument_list|,
name|M_MQUEUEDATA
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|msg_ptr
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|msg
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mqueue_msg
argument_list|)
argument_list|,
name|msg_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|FREE
argument_list|(
name|msg
argument_list|,
name|M_MQUEUEDATA
argument_list|)
expr_stmt|;
name|msg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|->
name|msg_size
operator|=
name|msg_size
expr_stmt|;
name|msg
operator|->
name|msg_prio
operator|=
name|msg_prio
expr_stmt|;
block|}
return|return
operator|(
name|msg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Save a message to user space  */
end_comment

begin_function
specifier|static
name|int
name|mqueue_savemsg
parameter_list|(
name|struct
name|mqueue_msg
modifier|*
name|msg
parameter_list|,
name|char
modifier|*
name|msg_ptr
parameter_list|,
name|int
modifier|*
name|msg_prio
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|msg
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|msg
argument_list|)
argument_list|,
name|msg_ptr
argument_list|,
name|msg
operator|->
name|msg_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|msg_prio
operator|!=
name|NULL
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|msg
operator|->
name|msg_prio
argument_list|,
name|msg_prio
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a message's memory  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|mqueue_freemsg
parameter_list|(
name|struct
name|mqueue_msg
modifier|*
name|msg
parameter_list|)
block|{
name|FREE
argument_list|(
name|msg
argument_list|,
name|M_MQUEUEDATA
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a message. if waitok is false, thread will not be  * blocked if there is no data in queue, otherwise, absolute  * time will be checked.  */
end_comment

begin_function
name|int
name|mqueue_send
parameter_list|(
name|struct
name|mqueue
modifier|*
name|mq
parameter_list|,
specifier|const
name|char
modifier|*
name|msg_ptr
parameter_list|,
name|size_t
name|msg_len
parameter_list|,
name|unsigned
name|msg_prio
parameter_list|,
name|int
name|waitok
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|abs_timeout
parameter_list|)
block|{
name|struct
name|mqueue_msg
modifier|*
name|msg
decl_stmt|;
name|struct
name|timespec
name|ets
decl_stmt|,
name|ts
decl_stmt|,
name|ts2
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|msg_prio
operator|>=
name|MQ_PRIO_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|msg_len
operator|>
name|mq
operator|->
name|mq_msgsize
condition|)
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
name|msg
operator|=
name|mqueue_loadmsg
argument_list|(
name|msg_ptr
argument_list|,
name|msg_len
argument_list|,
name|msg_prio
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* O_NONBLOCK case */
if|if
condition|(
operator|!
name|waitok
condition|)
block|{
name|error
operator|=
name|_mqueue_send
argument_list|(
name|mq
argument_list|,
name|msg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* we allow a null timeout (wait forever) */
if|if
condition|(
name|abs_timeout
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|_mqueue_send
argument_list|(
name|mq
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* send it before checking time */
name|error
operator|=
name|_mqueue_send
argument_list|(
name|mq
argument_list|,
name|msg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|error
operator|!=
name|EAGAIN
condition|)
goto|goto
name|bad
goto|;
name|error
operator|=
name|copyin
argument_list|(
name|abs_timeout
argument_list|,
operator|&
name|ets
argument_list|,
sizeof|sizeof
argument_list|(
name|ets
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|ets
operator|.
name|tv_nsec
operator|>=
literal|1000000000
operator|||
name|ets
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|ts2
operator|=
name|ets
expr_stmt|;
name|getnanotime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|timespecsub
argument_list|(
operator|&
name|ts2
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts2
operator|.
name|tv_sec
operator|<
literal|0
operator|||
operator|(
name|ts2
operator|.
name|tv_sec
operator|==
literal|0
operator|&&
name|ts2
operator|.
name|tv_nsec
operator|<=
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
break|break;
block|}
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|ts2
argument_list|)
expr_stmt|;
name|error
operator|=
name|_mqueue_send
argument_list|(
name|mq
argument_list|,
name|msg
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ETIMEDOUT
condition|)
break|break;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|mqueue_freemsg
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Common routine to send a message  */
end_comment

begin_function
specifier|static
name|int
name|_mqueue_send
parameter_list|(
name|struct
name|mqueue
modifier|*
name|mq
parameter_list|,
name|struct
name|mqueue_msg
modifier|*
name|msg
parameter_list|,
name|int
name|timo
parameter_list|)
block|{
name|struct
name|mqueue_msg
modifier|*
name|msg2
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|)
expr_stmt|;
while|while
condition|(
name|mq
operator|->
name|mq_curmsgs
operator|>=
name|mq
operator|->
name|mq_maxmsg
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|timo
operator|<
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
name|mq
operator|->
name|mq_senders
operator|++
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
operator|&
name|mq
operator|->
name|mq_senders
argument_list|,
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|,
name|PCATCH
argument_list|,
literal|"mqsend"
argument_list|,
name|timo
argument_list|)
expr_stmt|;
name|mq
operator|->
name|mq_senders
operator|--
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EAGAIN
condition|)
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
block|}
if|if
condition|(
name|mq
operator|->
name|mq_curmsgs
operator|>=
name|mq
operator|->
name|mq_maxmsg
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|mq
operator|->
name|mq_msgq
argument_list|)
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|mq
operator|->
name|mq_msgq
argument_list|,
name|msg
argument_list|,
name|msg_link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|msg
operator|->
name|msg_prio
operator|<=
name|TAILQ_LAST
argument_list|(
operator|&
name|mq
operator|->
name|mq_msgq
argument_list|,
name|msgq
argument_list|)
operator|->
name|msg_prio
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|mq
operator|->
name|mq_msgq
argument_list|,
name|msg
argument_list|,
name|msg_link
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_FOREACH
argument_list|(
argument|msg2
argument_list|,
argument|&mq->mq_msgq
argument_list|,
argument|msg_link
argument_list|)
block|{
if|if
condition|(
name|msg2
operator|->
name|msg_prio
operator|<
name|msg
operator|->
name|msg_prio
condition|)
break|break;
block|}
name|TAILQ_INSERT_BEFORE
argument_list|(
name|msg2
argument_list|,
name|msg
argument_list|,
name|msg_link
argument_list|)
expr_stmt|;
block|}
block|}
name|mq
operator|->
name|mq_curmsgs
operator|++
expr_stmt|;
name|mq
operator|->
name|mq_totalbytes
operator|+=
name|msg
operator|->
name|msg_size
expr_stmt|;
if|if
condition|(
name|mq
operator|->
name|mq_receivers
condition|)
name|wakeup_one
argument_list|(
operator|&
name|mq
operator|->
name|mq_receivers
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mq
operator|->
name|mq_notifier
operator|!=
name|NULL
condition|)
name|mqueue_send_notification
argument_list|(
name|mq
argument_list|)
expr_stmt|;
if|if
condition|(
name|mq
operator|->
name|mq_flags
operator|&
name|MQ_RSEL
condition|)
block|{
name|mq
operator|->
name|mq_flags
operator|&=
operator|~
name|MQ_RSEL
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|mq
operator|->
name|mq_rsel
argument_list|)
expr_stmt|;
block|}
name|KNOTE_LOCKED
argument_list|(
operator|&
name|mq
operator|->
name|mq_rsel
operator|.
name|si_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send realtime a signal to process which registered itself  * successfully by mq_notify.  */
end_comment

begin_function
specifier|static
name|void
name|mqueue_send_notification
parameter_list|(
name|struct
name|mqueue
modifier|*
name|mq
parameter_list|)
block|{
name|struct
name|mqueue_notifier
modifier|*
name|nt
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|nt
operator|=
name|mq
operator|->
name|mq_notifier
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|nt_sigev
operator|.
name|sigev_notify
operator|!=
name|SIGEV_NONE
condition|)
block|{
name|p
operator|=
name|nt
operator|->
name|nt_proc
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|KSI_ONQ
argument_list|(
operator|&
name|nt
operator|->
name|nt_ksi
argument_list|)
condition|)
name|psignal_event
argument_list|(
name|p
argument_list|,
operator|&
name|nt
operator|->
name|nt_sigev
argument_list|,
operator|&
name|nt
operator|->
name|nt_ksi
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|mq
operator|->
name|mq_notifier
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a message. if waitok is false, thread will not be  * blocked if there is no data in queue, otherwise, absolute  * time will be checked.  */
end_comment

begin_function
name|int
name|mqueue_receive
parameter_list|(
name|struct
name|mqueue
modifier|*
name|mq
parameter_list|,
name|char
modifier|*
name|msg_ptr
parameter_list|,
name|size_t
name|msg_len
parameter_list|,
name|unsigned
modifier|*
name|msg_prio
parameter_list|,
name|int
name|waitok
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|abs_timeout
parameter_list|)
block|{
name|struct
name|mqueue_msg
modifier|*
name|msg
decl_stmt|;
name|struct
name|timespec
name|ets
decl_stmt|,
name|ts
decl_stmt|,
name|ts2
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|msg_len
operator|<
name|mq
operator|->
name|mq_msgsize
condition|)
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
comment|/* O_NONBLOCK case */
if|if
condition|(
operator|!
name|waitok
condition|)
block|{
name|error
operator|=
name|_mqueue_recv
argument_list|(
name|mq
argument_list|,
operator|&
name|msg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
goto|goto
name|received
goto|;
block|}
comment|/* we allow a null timeout (wait forever). */
if|if
condition|(
name|abs_timeout
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|_mqueue_recv
argument_list|(
name|mq
argument_list|,
operator|&
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
goto|goto
name|received
goto|;
block|}
comment|/* try to get a message before checking time */
name|error
operator|=
name|_mqueue_recv
argument_list|(
name|mq
argument_list|,
operator|&
name|msg
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
goto|goto
name|received
goto|;
if|if
condition|(
name|error
operator|!=
name|EAGAIN
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
name|abs_timeout
argument_list|,
operator|&
name|ets
argument_list|,
sizeof|sizeof
argument_list|(
name|ets
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|ets
operator|.
name|tv_nsec
operator|>=
literal|1000000000
operator|||
name|ets
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|ts2
operator|=
name|ets
expr_stmt|;
name|getnanotime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|timespecsub
argument_list|(
operator|&
name|ts2
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts2
operator|.
name|tv_sec
operator|<
literal|0
operator|||
operator|(
name|ts2
operator|.
name|tv_sec
operator|==
literal|0
operator|&&
name|ts2
operator|.
name|tv_nsec
operator|<=
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|ts2
argument_list|)
expr_stmt|;
name|error
operator|=
name|_mqueue_recv
argument_list|(
name|mq
argument_list|,
operator|&
name|msg
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|error
operator|!=
name|ETIMEDOUT
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|received
label|:
name|error
operator|=
name|mqueue_savemsg
argument_list|(
name|msg
argument_list|,
name|msg_ptr
argument_list|,
name|msg_prio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|curthread
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|msg
operator|->
name|msg_size
expr_stmt|;
name|curthread
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|mqueue_freemsg
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Common routine to receive a message  */
end_comment

begin_function
specifier|static
name|int
name|_mqueue_recv
parameter_list|(
name|struct
name|mqueue
modifier|*
name|mq
parameter_list|,
name|struct
name|mqueue_msg
modifier|*
modifier|*
name|msg
parameter_list|,
name|int
name|timo
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|msg
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|mq
operator|->
name|mq_msgq
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|timo
operator|<
literal|0
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
name|mq
operator|->
name|mq_receivers
operator|++
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
operator|&
name|mq
operator|->
name|mq_receivers
argument_list|,
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|,
name|PCATCH
argument_list|,
literal|"mqrecv"
argument_list|,
name|timo
argument_list|)
expr_stmt|;
name|mq
operator|->
name|mq_receivers
operator|--
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EAGAIN
condition|)
name|error
operator|=
name|ETIMEDOUT
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|msg
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mq
operator|->
name|mq_msgq
argument_list|,
operator|*
name|msg
argument_list|,
name|msg_link
argument_list|)
expr_stmt|;
name|mq
operator|->
name|mq_curmsgs
operator|--
expr_stmt|;
name|mq
operator|->
name|mq_totalbytes
operator|-=
operator|(
operator|*
name|msg
operator|)
operator|->
name|msg_size
expr_stmt|;
if|if
condition|(
name|mq
operator|->
name|mq_senders
condition|)
name|wakeup_one
argument_list|(
operator|&
name|mq
operator|->
name|mq_senders
argument_list|)
expr_stmt|;
if|if
condition|(
name|mq
operator|->
name|mq_flags
operator|&
name|MQ_WSEL
condition|)
block|{
name|mq
operator|->
name|mq_flags
operator|&=
operator|~
name|MQ_WSEL
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|mq
operator|->
name|mq_wsel
argument_list|)
expr_stmt|;
block|}
name|KNOTE_LOCKED
argument_list|(
operator|&
name|mq
operator|->
name|mq_wsel
operator|.
name|si_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mq
operator|->
name|mq_notifier
operator|!=
name|NULL
operator|&&
name|mq
operator|->
name|mq_receivers
operator|==
literal|0
operator|&&
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|mq
operator|->
name|mq_msgq
argument_list|)
condition|)
block|{
name|mqueue_send_notification
argument_list|(
name|mq
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|mqueue_notifier
operator|*
name|notifier_alloc
argument_list|(
argument|void
argument_list|)
block|{
return|return
operator|(
name|uma_zalloc
argument_list|(
name|mqnoti_zone
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|__inline
name|void
name|notifier_free
parameter_list|(
name|struct
name|mqueue_notifier
modifier|*
name|p
parameter_list|)
block|{
name|uma_zfree
argument_list|(
name|mqnoti_zone
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mqueue_notifier
modifier|*
name|notifier_search
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|struct
name|mqueue_notifier
modifier|*
name|nt
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|nt
argument_list|,
argument|&p->p_mqnotifier
argument_list|,
argument|nt_link
argument_list|)
block|{
if|if
condition|(
name|nt
operator|->
name|nt_ksi
operator|.
name|ksi_mqd
operator|==
name|fd
condition|)
break|break;
block|}
return|return
operator|(
name|nt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|notifier_insert
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|mqueue_notifier
modifier|*
name|nt
parameter_list|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|p
operator|->
name|p_mqnotifier
argument_list|,
name|nt
argument_list|,
name|nt_link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|notifier_delete
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|mqueue_notifier
modifier|*
name|nt
parameter_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|nt
argument_list|,
name|nt_link
argument_list|)
expr_stmt|;
name|notifier_free
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|notifier_remove
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|mqueue
modifier|*
name|mq
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|struct
name|mqueue_notifier
modifier|*
name|nt
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|nt
operator|=
name|notifier_search
argument_list|(
name|p
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mq
operator|->
name|mq_notifier
operator|==
name|nt
condition|)
name|mq
operator|->
name|mq_notifier
operator|=
name|NULL
expr_stmt|;
name|sigqueue_take
argument_list|(
operator|&
name|nt
operator|->
name|nt_ksi
argument_list|)
expr_stmt|;
name|notifier_delete
argument_list|(
name|p
argument_list|,
name|nt
argument_list|)
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Syscall to open a message queue.  */
end_comment

begin_function
name|int
name|kmq_open
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kmq_open_args
modifier|*
name|uap
parameter_list|)
block|{
name|char
name|path
index|[
name|MQFS_NAMELEN
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|mq_attr
name|attr
decl_stmt|,
modifier|*
name|pattr
decl_stmt|;
name|struct
name|mqfs_node
modifier|*
name|pn
decl_stmt|;
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|mqueue
modifier|*
name|mq
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|error
decl_stmt|,
name|len
decl_stmt|,
name|flags
decl_stmt|,
name|cmode
decl_stmt|;
if|if
condition|(
operator|(
name|uap
operator|->
name|flags
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_ACCMODE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|fdp
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_fd
expr_stmt|;
name|flags
operator|=
name|FFLAGS
argument_list|(
name|uap
operator|->
name|flags
argument_list|)
expr_stmt|;
name|cmode
operator|=
operator|(
operator|(
operator|(
name|uap
operator|->
name|mode
operator|&
operator|~
name|fdp
operator|->
name|fd_cmask
operator|)
operator|&
name|ALLPERMS
operator|)
operator|&
operator|~
name|S_ISTXT
operator|)
expr_stmt|;
name|mq
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|O_CREAT
operator|)
operator|&&
operator|(
name|uap
operator|->
name|attr
operator|!=
name|NULL
operator|)
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|attr
argument_list|,
operator|&
name|attr
argument_list|,
sizeof|sizeof
argument_list|(
name|attr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|attr
operator|.
name|mq_maxmsg
operator|<=
literal|0
operator|||
name|attr
operator|.
name|mq_maxmsg
operator|>
name|maxmsg
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|attr
operator|.
name|mq_msgsize
operator|<=
literal|0
operator|||
name|attr
operator|.
name|mq_msgsize
operator|>
name|maxmsgsize
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pattr
operator|=
operator|&
name|attr
expr_stmt|;
block|}
else|else
name|pattr
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|copyinstr
argument_list|(
name|uap
operator|->
name|path
argument_list|,
name|path
argument_list|,
name|MQFS_NAMELEN
operator|+
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * The first character of name must be a slash  (/) character 	 * and the remaining characters of name cannot include any slash 	 * characters.  	 */
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|2
operator|||
name|path
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|||
name|index
argument_list|(
name|path
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|falloc
argument_list|(
name|td
argument_list|,
operator|&
name|fp
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|mqfs_data
operator|.
name|mi_lock
argument_list|)
expr_stmt|;
name|pn
operator|=
name|mqfs_search
argument_list|(
name|mqfs_data
operator|.
name|mi_root
argument_list|,
name|path
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|O_CREAT
operator|)
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
else|else
block|{
name|mq
operator|=
name|mqueue_alloc
argument_list|(
name|pattr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mq
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENFILE
expr_stmt|;
block|}
else|else
block|{
name|pn
operator|=
name|mqfs_create_file
argument_list|(
name|mqfs_data
operator|.
name|mi_root
argument_list|,
name|path
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|cmode
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOSPC
expr_stmt|;
name|mqueue_free
argument_list|(
name|mq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|pn
operator|->
name|mn_data
operator|=
name|mq
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|O_CREAT
operator||
name|O_EXCL
operator|)
operator|)
operator|==
operator|(
name|O_CREAT
operator||
name|O_EXCL
operator|)
condition|)
block|{
name|error
operator|=
name|EEXIST
expr_stmt|;
block|}
else|else
block|{
name|int
name|acc_mode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|FREAD
condition|)
name|acc_mode
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FWRITE
condition|)
name|acc_mode
operator||=
name|VWRITE
expr_stmt|;
name|error
operator|=
name|vaccess
argument_list|(
name|VREG
argument_list|,
name|pn
operator|->
name|mn_mode
argument_list|,
name|pn
operator|->
name|mn_uid
argument_list|,
name|pn
operator|->
name|mn_gid
argument_list|,
name|acc_mode
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|mqfs_data
operator|.
name|mi_lock
argument_list|)
expr_stmt|;
name|fdclose
argument_list|(
name|fdp
argument_list|,
name|fp
argument_list|,
name|fd
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mqnode_addref
argument_list|(
name|pn
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|mqfs_data
operator|.
name|mi_lock
argument_list|)
expr_stmt|;
name|FILE_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_flag
operator|=
operator|(
name|flags
operator|&
operator|(
name|FREAD
operator||
name|FWRITE
operator||
name|O_NONBLOCK
operator|)
operator|)
expr_stmt|;
name|fp
operator|->
name|f_type
operator|=
name|DTYPE_MQUEUE
expr_stmt|;
name|fp
operator|->
name|f_ops
operator|=
operator|&
name|mqueueops
expr_stmt|;
name|fp
operator|->
name|f_data
operator|=
name|pn
expr_stmt|;
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|FILEDESC_LOCK_FAST
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
operator|==
name|fp
condition|)
name|fdp
operator|->
name|fd_ofileflags
index|[
name|fd
index|]
operator||=
name|UF_EXCLOSE
expr_stmt|;
name|FILEDESC_UNLOCK_FAST
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|fd
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Syscall to unlink a message queue.  */
end_comment

begin_function
name|int
name|kmq_unlink
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kmq_unlink_args
modifier|*
name|uap
parameter_list|)
block|{
name|char
name|path
index|[
name|MQFS_NAMELEN
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|mqfs_node
modifier|*
name|pn
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|;
name|error
operator|=
name|copyinstr
argument_list|(
name|uap
operator|->
name|path
argument_list|,
name|path
argument_list|,
name|MQFS_NAMELEN
operator|+
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|2
operator|||
name|path
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|||
name|index
argument_list|(
name|path
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|mqfs_data
operator|.
name|mi_lock
argument_list|)
expr_stmt|;
name|pn
operator|=
name|mqfs_search
argument_list|(
name|mqfs_data
operator|.
name|mi_root
argument_list|,
name|path
operator|+
literal|1
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pn
operator|!=
name|NULL
condition|)
name|error
operator|=
name|do_unlink
argument_list|(
name|pn
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ENOENT
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|mqfs_data
operator|.
name|mi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|_fgetf
function_decl|)
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|file
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/*  * Get message queue by giving file slot  */
end_comment

begin_function
specifier|static
name|int
name|_getmq
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|fd
parameter_list|,
name|_fgetf
name|func
parameter_list|,
name|struct
name|file
modifier|*
modifier|*
name|fpp
parameter_list|,
name|struct
name|mqfs_node
modifier|*
modifier|*
name|ppn
parameter_list|,
name|struct
name|mqueue
modifier|*
modifier|*
name|pmq
parameter_list|)
block|{
name|struct
name|mqfs_node
modifier|*
name|pn
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|func
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
name|fpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|&
name|mqueueops
operator|!=
operator|(
operator|*
name|fpp
operator|)
operator|->
name|f_ops
condition|)
block|{
name|fdrop
argument_list|(
operator|*
name|fpp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
name|pn
operator|=
operator|(
operator|*
name|fpp
operator|)
operator|->
name|f_data
expr_stmt|;
if|if
condition|(
name|ppn
condition|)
operator|*
name|ppn
operator|=
name|pn
expr_stmt|;
if|if
condition|(
name|pmq
condition|)
operator|*
name|pmq
operator|=
name|pn
operator|->
name|mn_data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|getmq
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|file
modifier|*
modifier|*
name|fpp
parameter_list|,
name|struct
name|mqfs_node
modifier|*
modifier|*
name|ppn
parameter_list|,
name|struct
name|mqueue
modifier|*
modifier|*
name|pmq
parameter_list|)
block|{
return|return
name|_getmq
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
name|fget
argument_list|,
name|fpp
argument_list|,
name|ppn
argument_list|,
name|pmq
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|getmq_read
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|file
modifier|*
modifier|*
name|fpp
parameter_list|,
name|struct
name|mqfs_node
modifier|*
modifier|*
name|ppn
parameter_list|,
name|struct
name|mqueue
modifier|*
modifier|*
name|pmq
parameter_list|)
block|{
return|return
name|_getmq
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
name|fget_read
argument_list|,
name|fpp
argument_list|,
name|ppn
argument_list|,
name|pmq
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|getmq_write
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|file
modifier|*
modifier|*
name|fpp
parameter_list|,
name|struct
name|mqfs_node
modifier|*
modifier|*
name|ppn
parameter_list|,
name|struct
name|mqueue
modifier|*
modifier|*
name|pmq
parameter_list|)
block|{
return|return
name|_getmq
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
name|fget_write
argument_list|,
name|fpp
argument_list|,
name|ppn
argument_list|,
name|pmq
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|kmq_setattr
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kmq_setattr_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|mqueue
modifier|*
name|mq
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|mq_attr
name|attr
decl_stmt|,
name|oattr
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|attr
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|attr
argument_list|,
operator|&
name|attr
argument_list|,
sizeof|sizeof
argument_list|(
name|attr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|attr
operator|.
name|mq_flags
operator|&
operator|~
name|O_NONBLOCK
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|getmq
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|mqd
argument_list|,
operator|&
name|fp
argument_list|,
name|NULL
argument_list|,
operator|&
name|mq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|oattr
operator|.
name|mq_maxmsg
operator|=
name|mq
operator|->
name|mq_maxmsg
expr_stmt|;
name|oattr
operator|.
name|mq_msgsize
operator|=
name|mq
operator|->
name|mq_msgsize
expr_stmt|;
name|oattr
operator|.
name|mq_curmsgs
operator|=
name|mq
operator|->
name|mq_curmsgs
expr_stmt|;
name|FILE_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|oattr
operator|.
name|mq_flags
operator|=
operator|(
name|O_NONBLOCK
operator|&
name|fp
operator|->
name|f_flag
operator|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|attr
condition|)
block|{
name|fp
operator|->
name|f_flag
operator|&=
operator|~
name|O_NONBLOCK
expr_stmt|;
name|fp
operator|->
name|f_flag
operator||=
operator|(
name|attr
operator|.
name|mq_flags
operator|&
name|O_NONBLOCK
operator|)
expr_stmt|;
block|}
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|oattr
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|oattr
argument_list|,
name|uap
operator|->
name|oattr
argument_list|,
sizeof|sizeof
argument_list|(
name|oattr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kmq_timedreceive
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kmq_timedreceive_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|mqueue
modifier|*
name|mq
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|waitok
decl_stmt|;
name|error
operator|=
name|getmq_read
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|mqd
argument_list|,
operator|&
name|fp
argument_list|,
name|NULL
argument_list|,
operator|&
name|mq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|waitok
operator|=
operator|!
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|O_NONBLOCK
operator|)
expr_stmt|;
name|error
operator|=
name|mqueue_receive
argument_list|(
name|mq
argument_list|,
name|uap
operator|->
name|msg_ptr
argument_list|,
name|uap
operator|->
name|msg_len
argument_list|,
name|uap
operator|->
name|msg_prio
argument_list|,
name|waitok
argument_list|,
name|uap
operator|->
name|abs_timeout
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kmq_timedsend
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kmq_timedsend_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|mqueue
modifier|*
name|mq
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|waitok
decl_stmt|;
name|error
operator|=
name|getmq_write
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|mqd
argument_list|,
operator|&
name|fp
argument_list|,
name|NULL
argument_list|,
operator|&
name|mq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|waitok
operator|=
operator|!
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|O_NONBLOCK
operator|)
expr_stmt|;
name|error
operator|=
name|mqueue_send
argument_list|(
name|mq
argument_list|,
name|uap
operator|->
name|msg_ptr
argument_list|,
name|uap
operator|->
name|msg_len
argument_list|,
name|uap
operator|->
name|msg_prio
argument_list|,
name|waitok
argument_list|,
name|uap
operator|->
name|abs_timeout
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kmq_notify
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kmq_notify_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|sigevent
name|ev
decl_stmt|;
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|mqueue
modifier|*
name|mq
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|mqueue_notifier
modifier|*
name|nt
decl_stmt|,
modifier|*
name|newnt
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|fdp
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_fd
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|sigev
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|sigev
argument_list|,
operator|&
name|ev
argument_list|,
sizeof|sizeof
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|ev
operator|.
name|sigev_notify
operator|!=
name|SIGEV_SIGNAL
operator|&&
name|ev
operator|.
name|sigev_notify
operator|!=
name|SIGEV_THREAD_ID
operator|&&
name|ev
operator|.
name|sigev_notify
operator|!=
name|SIGEV_NONE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|ev
operator|.
name|sigev_notify
operator|==
name|SIGEV_SIGNAL
operator|||
name|ev
operator|.
name|sigev_notify
operator|==
name|SIGEV_THREAD_ID
operator|)
operator|&&
operator|!
name|_SIG_VALID
argument_list|(
name|ev
operator|.
name|sigev_signo
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|getmq
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|mqd
argument_list|,
operator|&
name|fp
argument_list|,
name|NULL
argument_list|,
operator|&
name|mq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|again
label|:
name|FILEDESC_LOCK_FAST
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fget_locked
argument_list|(
name|fdp
argument_list|,
name|uap
operator|->
name|mqd
argument_list|)
operator|!=
name|fp
condition|)
block|{
name|FILEDESC_UNLOCK_FAST
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBADF
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|)
expr_stmt|;
name|FILEDESC_UNLOCK_FAST
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|sigev
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mq
operator|->
name|mq_notifier
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
block|}
else|else
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|nt
operator|=
name|notifier_search
argument_list|(
name|p
argument_list|,
name|uap
operator|->
name|mqd
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|newnt
operator|==
name|NULL
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|)
expr_stmt|;
name|newnt
operator|=
name|notifier_alloc
argument_list|()
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
if|if
condition|(
name|nt
operator|!=
name|NULL
condition|)
block|{
name|sigqueue_take
argument_list|(
operator|&
name|nt
operator|->
name|nt_ksi
argument_list|)
expr_stmt|;
if|if
condition|(
name|newnt
operator|!=
name|NULL
condition|)
block|{
name|notifier_free
argument_list|(
name|newnt
argument_list|)
expr_stmt|;
name|newnt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|nt
operator|=
name|newnt
expr_stmt|;
name|newnt
operator|=
name|NULL
expr_stmt|;
name|ksiginfo_init
argument_list|(
operator|&
name|nt
operator|->
name|nt_ksi
argument_list|)
expr_stmt|;
name|nt
operator|->
name|nt_ksi
operator|.
name|ksi_flags
operator||=
name|KSI_INS
operator||
name|KSI_EXT
expr_stmt|;
name|nt
operator|->
name|nt_ksi
operator|.
name|ksi_code
operator|=
name|SI_MESGQ
expr_stmt|;
name|nt
operator|->
name|nt_proc
operator|=
name|p
expr_stmt|;
name|nt
operator|->
name|nt_ksi
operator|.
name|ksi_mqd
operator|=
name|uap
operator|->
name|mqd
expr_stmt|;
name|notifier_insert
argument_list|(
name|p
argument_list|,
name|nt
argument_list|)
expr_stmt|;
block|}
name|nt
operator|->
name|nt_sigev
operator|=
name|ev
expr_stmt|;
name|mq
operator|->
name|mq_notifier
operator|=
name|nt
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 			 * if there is no receivers and message queue 			 * is not empty, we should send notification 			 * as soon as possible. 			 */
if|if
condition|(
name|mq
operator|->
name|mq_receivers
operator|==
literal|0
operator|&&
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|mq
operator|->
name|mq_msgq
argument_list|)
condition|)
name|mqueue_send_notification
argument_list|(
name|mq
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|notifier_remove
argument_list|(
name|p
argument_list|,
name|mq
argument_list|,
name|uap
operator|->
name|mqd
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|)
expr_stmt|;
name|out
label|:
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|newnt
operator|!=
name|NULL
condition|)
name|notifier_free
argument_list|(
name|newnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mqueue_fdclose
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|file
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|mqueue
modifier|*
name|mq
decl_stmt|;
name|fdp
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_fd
expr_stmt|;
name|FILEDESC_LOCK_ASSERT
argument_list|(
name|fdp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_ops
operator|==
operator|&
name|mqueueops
condition|)
block|{
name|mq
operator|=
name|FPTOMQ
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|)
expr_stmt|;
name|notifier_remove
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|mq
argument_list|,
name|fd
argument_list|)
expr_stmt|;
comment|/* have to wakeup thread in same process */
if|if
condition|(
name|mq
operator|->
name|mq_flags
operator|&
name|MQ_RSEL
condition|)
block|{
name|mq
operator|->
name|mq_flags
operator|&=
operator|~
name|MQ_RSEL
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|mq
operator|->
name|mq_rsel
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mq
operator|->
name|mq_flags
operator|&
name|MQ_WSEL
condition|)
block|{
name|mq
operator|->
name|mq_flags
operator|&=
operator|~
name|MQ_WSEL
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|mq
operator|->
name|mq_wsel
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mq_proc_exit
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|mqueue
modifier|*
name|mq
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fdp
operator|=
name|p
operator|->
name|p_fd
expr_stmt|;
name|FILEDESC_LOCK_FAST
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fdp
operator|->
name|fd_nfiles
condition|;
operator|++
name|i
control|)
block|{
name|fp
operator|=
name|fget_locked
argument_list|(
name|fdp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
operator|&&
name|fp
operator|->
name|f_ops
operator|==
operator|&
name|mqueueops
condition|)
block|{
name|mq
operator|=
name|FPTOMQ
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|)
expr_stmt|;
name|notifier_remove
argument_list|(
name|p
argument_list|,
name|FPTOMQ
argument_list|(
name|fp
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|)
expr_stmt|;
block|}
block|}
name|FILEDESC_UNLOCK_FAST
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|p
operator|->
name|p_mqnotifier
argument_list|)
argument_list|,
operator|(
literal|"mq notifiers left"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mqf_read
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mqf_write
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mqf_ioctl
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mqf_poll
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mqueue
modifier|*
name|mq
init|=
name|FPTOMQ
argument_list|(
name|fp
argument_list|)
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
if|if
condition|(
name|mq
operator|->
name|mq_curmsgs
condition|)
block|{
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
else|else
block|{
name|mq
operator|->
name|mq_flags
operator||=
name|MQ_RSEL
expr_stmt|;
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|mq
operator|->
name|mq_rsel
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|events
operator|&
name|POLLOUT
condition|)
block|{
if|if
condition|(
name|mq
operator|->
name|mq_curmsgs
operator|<
name|mq
operator|->
name|mq_maxmsg
condition|)
name|revents
operator||=
name|POLLOUT
expr_stmt|;
else|else
block|{
name|mq
operator|->
name|mq_flags
operator||=
name|MQ_WSEL
expr_stmt|;
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|mq
operator|->
name|mq_wsel
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mqf_close
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mqfs_node
modifier|*
name|pn
decl_stmt|;
name|FILE_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_ops
operator|=
operator|&
name|badfileops
expr_stmt|;
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|pn
operator|=
name|fp
operator|->
name|f_data
expr_stmt|;
name|fp
operator|->
name|f_data
operator|=
name|NULL
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|mqfs_data
operator|.
name|mi_lock
argument_list|)
expr_stmt|;
name|mqnode_release
argument_list|(
name|pn
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|mqfs_data
operator|.
name|mi_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mqf_stat
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mqfs_node
modifier|*
name|pn
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
name|bzero
argument_list|(
name|st
argument_list|,
sizeof|sizeof
expr|*
name|st
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_atimespec
operator|=
name|pn
operator|->
name|mn_atime
expr_stmt|;
name|st
operator|->
name|st_mtimespec
operator|=
name|pn
operator|->
name|mn_mtime
expr_stmt|;
name|st
operator|->
name|st_ctimespec
operator|=
name|pn
operator|->
name|mn_ctime
expr_stmt|;
name|st
operator|->
name|st_birthtimespec
operator|=
name|pn
operator|->
name|mn_birth
expr_stmt|;
name|st
operator|->
name|st_uid
operator|=
name|pn
operator|->
name|mn_uid
expr_stmt|;
name|st
operator|->
name|st_gid
operator|=
name|pn
operator|->
name|mn_gid
expr_stmt|;
name|st
operator|->
name|st_mode
operator|=
name|S_IFIFO
operator||
name|pn
operator|->
name|mn_mode
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mqf_kqfilter
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|mqueue
modifier|*
name|mq
init|=
name|FPTOMQ
argument_list|(
name|fp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_filter
operator|==
name|EVFILT_READ
condition|)
block|{
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|mq_rfiltops
expr_stmt|;
name|knlist_add
argument_list|(
operator|&
name|mq
operator|->
name|mq_rsel
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kn
operator|->
name|kn_filter
operator|==
name|EVFILT_WRITE
condition|)
block|{
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|mq_wfiltops
expr_stmt|;
name|knlist_add
argument_list|(
operator|&
name|mq
operator|->
name|mq_wsel
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|filt_mqdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|mqueue
modifier|*
name|mq
init|=
name|FPTOMQ
argument_list|(
name|kn
operator|->
name|kn_fp
argument_list|)
decl_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_filter
operator|==
name|EVFILT_READ
condition|)
name|knlist_remove
argument_list|(
operator|&
name|mq
operator|->
name|mq_rsel
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|kn
operator|->
name|kn_filter
operator|==
name|EVFILT_WRITE
condition|)
name|knlist_remove
argument_list|(
operator|&
name|mq
operator|->
name|mq_wsel
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"filt_mqdetach"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|filt_mqread
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|mqueue
modifier|*
name|mq
init|=
name|FPTOMQ
argument_list|(
name|kn
operator|->
name|kn_fp
argument_list|)
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
return|return
operator|(
name|mq
operator|->
name|mq_curmsgs
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|filt_mqwrite
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|mqueue
modifier|*
name|mq
init|=
name|FPTOMQ
argument_list|(
name|kn
operator|->
name|kn_fp
argument_list|)
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|mq
operator|->
name|mq_mutex
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
return|return
operator|(
name|mq
operator|->
name|mq_curmsgs
operator|<
name|mq
operator|->
name|mq_maxmsg
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|fileops
name|mqueueops
init|=
block|{
operator|.
name|fo_read
operator|=
name|mqf_read
block|,
operator|.
name|fo_write
operator|=
name|mqf_write
block|,
operator|.
name|fo_ioctl
operator|=
name|mqf_ioctl
block|,
operator|.
name|fo_poll
operator|=
name|mqf_poll
block|,
operator|.
name|fo_kqfilter
operator|=
name|mqf_kqfilter
block|,
operator|.
name|fo_stat
operator|=
name|mqf_stat
block|,
operator|.
name|fo_close
operator|=
name|mqf_close
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vop_vector
name|mqfs_vnodeops
init|=
block|{
operator|.
name|vop_default
operator|=
operator|&
name|default_vnodeops
block|,
operator|.
name|vop_access
operator|=
name|mqfs_access
block|,
operator|.
name|vop_cachedlookup
operator|=
name|mqfs_lookup
block|,
operator|.
name|vop_lookup
operator|=
name|vfs_cache_lookup
block|,
operator|.
name|vop_reclaim
operator|=
name|mqfs_reclaim
block|,
operator|.
name|vop_create
operator|=
name|mqfs_create
block|,
operator|.
name|vop_remove
operator|=
name|mqfs_remove
block|,
operator|.
name|vop_inactive
operator|=
name|mqfs_inactive
block|,
operator|.
name|vop_open
operator|=
name|mqfs_open
block|,
operator|.
name|vop_close
operator|=
name|mqfs_close
block|,
operator|.
name|vop_getattr
operator|=
name|mqfs_getattr
block|,
operator|.
name|vop_setattr
operator|=
name|mqfs_setattr
block|,
operator|.
name|vop_read
operator|=
name|mqfs_read
block|,
operator|.
name|vop_write
operator|=
name|VOP_EOPNOTSUPP
block|,
operator|.
name|vop_readdir
operator|=
name|mqfs_readdir
block|,
operator|.
name|vop_mkdir
operator|=
name|VOP_EOPNOTSUPP
block|,
operator|.
name|vop_rmdir
operator|=
name|VOP_EOPNOTSUPP
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vfsops
name|mqfs_vfsops
init|=
block|{
operator|.
name|vfs_init
operator|=
name|mqfs_init
block|,
operator|.
name|vfs_uninit
operator|=
name|mqfs_uninit
block|,
operator|.
name|vfs_mount
operator|=
name|mqfs_mount
block|,
operator|.
name|vfs_unmount
operator|=
name|mqfs_unmount
block|,
operator|.
name|vfs_root
operator|=
name|mqfs_root
block|,
operator|.
name|vfs_statfs
operator|=
name|mqfs_statfs
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|kmq_open
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|kmq_setattr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|kmq_timedsend
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|kmq_timedreceive
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|kmq_notify
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|kmq_unlink
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VFS_SET
argument_list|(
name|mqfs_vfsops
argument_list|,
name|mqueuefs
argument_list|,
name|VFCF_SYNTHETIC
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|mqueuefs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

