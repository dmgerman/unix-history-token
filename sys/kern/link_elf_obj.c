begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 Doug Rabson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<machine/elf.h>
end_include

begin_function_decl
specifier|static
name|int
name|link_elf_load_file
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|linker_file_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_elf_lookup_symbol
parameter_list|(
name|linker_file_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|linker_sym_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|link_elf_symbol_values
parameter_list|(
name|linker_file_t
parameter_list|,
name|linker_sym_t
parameter_list|,
name|linker_symval_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_elf_search_symbol
parameter_list|(
name|linker_file_t
parameter_list|,
name|caddr_t
name|value
parameter_list|,
name|linker_sym_t
modifier|*
name|sym
parameter_list|,
name|long
modifier|*
name|diffp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|link_elf_unload
parameter_list|(
name|linker_file_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * The file representing the currently running kernel.  This contains  * the global symbol table.  */
end_comment

begin_decl_stmt
name|linker_file_t
name|linker_kernel_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|linker_class_ops
name|link_elf_class_ops
init|=
block|{
name|link_elf_load_file
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|linker_file_ops
name|link_elf_file_ops
init|=
block|{
name|link_elf_lookup_symbol
block|,
name|link_elf_symbol_values
block|,
name|link_elf_search_symbol
block|,
name|link_elf_unload
block|, }
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|elf_file
block|{
name|caddr_t
name|address
decl_stmt|;
comment|/* Load address */
name|Elf_Dyn
modifier|*
name|dynamic
decl_stmt|;
comment|/* Symbol table etc. */
name|Elf_Off
name|nbuckets
decl_stmt|;
comment|/* DT_HASH info */
name|Elf_Off
name|nchains
decl_stmt|;
specifier|const
name|Elf_Off
modifier|*
name|buckets
decl_stmt|;
specifier|const
name|Elf_Off
modifier|*
name|chains
decl_stmt|;
name|caddr_t
name|hash
decl_stmt|;
name|caddr_t
name|strtab
decl_stmt|;
comment|/* DT_STRTAB */
name|Elf_Sym
modifier|*
name|symtab
decl_stmt|;
comment|/* DT_SYMTAB */
block|}
typedef|*
name|elf_file_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|int
name|parse_dynamic
parameter_list|(
name|linker_file_t
name|lf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|load_dependancies
parameter_list|(
name|linker_file_t
name|lf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|relocate_file
parameter_list|(
name|linker_file_t
name|lf
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * The kernel symbol table starts here.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|_dynamic
name|_DYNAMIC
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|link_elf_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|Elf_Dyn
modifier|*
name|dp
init|=
operator|(
name|Elf_Dyn
operator|*
operator|)
operator|&
name|_DYNAMIC
decl_stmt|;
if|#
directive|if
name|ELF_TARG_CLASS
operator|==
name|ELFCLASS32
name|linker_add_class
argument_list|(
literal|"elf32"
argument_list|,
name|NULL
argument_list|,
operator|&
name|link_elf_class_ops
argument_list|)
expr_stmt|;
else|#
directive|else
name|linker_add_class
argument_list|(
literal|"elf64"
argument_list|,
name|NULL
argument_list|,
operator|&
name|link_elf_class_ops
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dp
condition|)
block|{
name|elf_file_t
name|ef
decl_stmt|;
name|ef
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|elf_file
argument_list|)
argument_list|,
name|M_LINKER
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"link_elf_init: Can't create linker structures for kernel"
argument_list|)
expr_stmt|;
name|ef
operator|->
name|address
operator|=
literal|0
expr_stmt|;
name|ef
operator|->
name|dynamic
operator|=
name|dp
expr_stmt|;
name|linker_kernel_file
operator|=
name|linker_make_file
argument_list|(
name|kernelname
argument_list|,
name|ef
argument_list|,
operator|&
name|link_elf_file_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|linker_kernel_file
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"link_elf_init: Can't create linker structures for kernel"
argument_list|)
expr_stmt|;
name|parse_dynamic
argument_list|(
name|linker_kernel_file
argument_list|)
expr_stmt|;
comment|/* 	 * XXX there must be a better way of getting these constants. 	 */
ifdef|#
directive|ifdef
name|__alpha__
name|linker_kernel_file
operator|->
name|address
operator|=
operator|(
name|caddr_t
operator|)
literal|0xfffffc0000300000
expr_stmt|;
else|#
directive|else
name|linker_kernel_file
operator|->
name|address
operator|=
operator|(
name|caddr_t
operator|)
literal|0xf0100000
expr_stmt|;
endif|#
directive|endif
name|linker_kernel_file
operator|->
name|size
operator|=
operator|-
operator|(
name|long
operator|)
name|linker_kernel_file
operator|->
name|address
expr_stmt|;
name|linker_current_file
operator|=
name|linker_kernel_file
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|link_elf
argument_list|,
name|SI_SUB_KMEM
argument_list|,
name|SI_ORDER_THIRD
argument_list|,
name|link_elf_init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|parse_dynamic
parameter_list|(
name|linker_file_t
name|lf
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
name|lf
operator|->
name|priv
decl_stmt|;
name|Elf_Dyn
modifier|*
name|dp
decl_stmt|;
for|for
control|(
name|dp
operator|=
name|ef
operator|->
name|dynamic
init|;
name|dp
operator|->
name|d_tag
operator|!=
name|DT_NULL
condition|;
name|dp
operator|++
control|)
block|{
switch|switch
condition|(
name|dp
operator|->
name|d_tag
condition|)
block|{
case|case
name|DT_HASH
case|:
block|{
comment|/* From src/libexec/rtld-elf/rtld.c */
specifier|const
name|Elf_Off
modifier|*
name|hashtab
init|=
operator|(
specifier|const
name|Elf_Off
operator|*
operator|)
operator|(
name|ef
operator|->
name|address
operator|+
name|dp
operator|->
name|d_un
operator|.
name|d_ptr
operator|)
decl_stmt|;
name|ef
operator|->
name|nbuckets
operator|=
name|hashtab
index|[
literal|0
index|]
expr_stmt|;
name|ef
operator|->
name|nchains
operator|=
name|hashtab
index|[
literal|1
index|]
expr_stmt|;
name|ef
operator|->
name|buckets
operator|=
name|hashtab
operator|+
literal|2
expr_stmt|;
name|ef
operator|->
name|chains
operator|=
name|ef
operator|->
name|buckets
operator|+
name|ef
operator|->
name|nbuckets
expr_stmt|;
break|break;
block|}
case|case
name|DT_STRTAB
case|:
name|ef
operator|->
name|strtab
operator|=
operator|(
name|caddr_t
operator|)
name|dp
operator|->
name|d_un
operator|.
name|d_ptr
expr_stmt|;
break|break;
case|case
name|DT_SYMTAB
case|:
name|ef
operator|->
name|symtab
operator|=
operator|(
name|Elf_Sym
operator|*
operator|)
name|dp
operator|->
name|d_un
operator|.
name|d_ptr
expr_stmt|;
break|break;
case|case
name|DT_SYMENT
case|:
if|if
condition|(
name|dp
operator|->
name|d_un
operator|.
name|d_val
operator|!=
sizeof|sizeof
argument_list|(
name|Elf_Sym
argument_list|)
condition|)
return|return
name|ENOEXEC
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|link_elf_load_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|linker_file_t
modifier|*
name|result
parameter_list|)
block|{
if|#
directive|if
literal|0
block|struct nameidata nd;     struct proc* p = curproc;
comment|/* XXX */
block|int error = 0;     int resid;     struct exec header;     elf_file_t ef;     linker_file_t lf;      NDINIT(&nd, LOOKUP, FOLLOW, UIO_SYSSPACE, filename, p);     error = vn_open(&nd, FREAD, 0);     if (error) 	return error;
comment|/*      * Read the a.out header from the file.      */
block|error = vn_rdwr(UIO_READ, nd.ni_vp, (void*)&header, sizeof header, 0, 		    UIO_SYSSPACE, IO_NODELOCKED, p->p_ucred,&resid, p);     if (error) 	goto out;      if (N_BADMAG(header) || !(N_GETFLAG(header)& EX_DYNAMIC)) 	goto out;
comment|/*      * We have an a.out file, so make some space to read it in.      */
block|ef = malloc(sizeof(struct elf_file), M_LINKER, M_WAITOK);     ef->address = malloc(header.a_text + header.a_data + header.a_bss, 			 M_LINKER, M_WAITOK);
comment|/*      * Read the text and data sections and zero the bss.      */
block|error = vn_rdwr(UIO_READ, nd.ni_vp, (void*) ef->address, 		    header.a_text + header.a_data, 0, 		    UIO_SYSSPACE, IO_NODELOCKED, p->p_ucred,&resid, p);     if (error) 	goto out;     bzero(ef->address + header.a_text + header.a_data, header.a_bss);
comment|/*      * Assume _DYNAMIC is the first data item.      */
block|ef->dynamic = (struct _dynamic*) (ef->address + header.a_text);     if (ef->dynamic->d_version != LD_VERSION_BSD) { 	free(ef->address, M_LINKER); 	free(ef, M_LINKER); 	goto out;     }     (long) ef->dynamic->d_un.d_sdt += ef->address;      lf = linker_make_file(filename, ef,&link_elf_file_ops);     if (lf == NULL) { 	free(ef->address, M_LINKER); 	free(ef, M_LINKER); 	error = ENOMEM; 	goto out;     }     lf->address = ef->address;     lf->size = header.a_text + header.a_data + header.a_bss;      if ((error = load_dependancies(lf)) != 0 	|| (error = relocate_file(lf)) != 0) { 	linker_file_unload(lf); 	goto out;     }      *result = lf;  out:     VOP_UNLOCK(nd.ni_vp, 0, p);     vn_close(nd.ni_vp, FREAD, p->p_ucred, p);      return error;
else|#
directive|else
return|return
name|ENOEXEC
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|link_elf_unload
parameter_list|(
name|linker_file_t
name|file
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
name|file
operator|->
name|priv
decl_stmt|;
if|if
condition|(
name|ef
condition|)
block|{
if|if
condition|(
name|ef
operator|->
name|address
condition|)
name|free
argument_list|(
name|ef
operator|->
name|address
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ef
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|ELF_RELOC
parameter_list|(
name|ef
parameter_list|,
name|type
parameter_list|,
name|off
parameter_list|)
value|(type*) ((ef)->address + (off))
end_define

begin_function
specifier|static
name|int
name|load_dependancies
parameter_list|(
name|linker_file_t
name|lf
parameter_list|)
block|{
if|#
directive|if
literal|0
block|elf_file_t ef = lf->priv;     linker_file_t lfdep;     long off;     struct sod* sodp;     char* name;     char* filename = 0;     int error = 0;
comment|/*      * All files are dependant on /kernel.      */
block|linker_kernel_file->refs++;     linker_file_add_dependancy(lf, linker_kernel_file);      off = LD_NEED(ef->dynamic);
comment|/*      * Load the dependancies.      */
block|while (off != 0) { 	sodp = ELF_RELOC(ef, struct sod, off); 	name = ELF_RELOC(ef, char, sodp->sod_name);
comment|/* 	 * Prepend pathname if dep is not an absolute filename. 	 */
block|if (name[0] != '/') { 	    char* p; 	    filename = malloc(MAXPATHLEN, M_TEMP, M_WAITOK); 	    p = lf->filename + strlen(lf->filename) - 1; 	    while (p>= lf->filename&& *p != '/') 		p--; 	    if (p>= lf->filename) { 		strncpy(filename, lf->filename, p - lf->filename); 		filename[p - lf->filename] = '\0'; 		strcat(filename, "/"); 		strcat(filename, name); 		name = filename; 	    } 	} 	error = linker_load_file(name,&lfdep); 	if (error) 	    goto out; 	error = linker_file_add_dependancy(lf, lfdep); 	if (error) 	    goto out; 	off = sodp->sod_next;     }  out:     if (filename) 	free(filename, M_TEMP);     return error;
else|#
directive|else
return|return
name|ENOEXEC
return|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * XXX i386 dependant.  */
end_comment

begin_comment
unit|static long read_relocation(struct relocation_info* r, char* addr) {     int length = r->r_length;     if (length == 0) 	return *(u_char*) addr;     else if (length == 1) 	return *(u_short*) addr;     else if (length == 2) 	return *(u_int*) addr;     else 	printf("link_elf: unsupported relocation size %d\n", r->r_length);     return 0; }  static void write_relocation(struct relocation_info* r, char* addr, long value) {     int length = r->r_length;     if (length == 0) 	*(u_char*) addr = value;     else if (length == 1) 	*(u_short*) addr = value;     else if (length == 2) 	*(u_int*) addr = value;     else 	printf("link_elf: unsupported relocation size %d\n", r->r_length); }  static int relocate_file(linker_file_t lf) {     elf_file_t ef = lf->priv;     struct relocation_info* rel;     struct relocation_info* erel;     struct relocation_info* r;     struct nzlist* symbolbase;     char* stringbase;     struct nzlist* np;     char* sym;     long relocation;      rel = ELF_RELOC(ef, struct relocation_info, LD_REL(ef->dynamic));     erel = ELF_RELOC(ef, struct relocation_info, 		      LD_REL(ef->dynamic) + LD_RELSZ(ef->dynamic));     symbolbase = ELF_RELOC(ef, struct nzlist, LD_SYMBOL(ef->dynamic));     stringbase = ELF_RELOC(ef, char, LD_STRINGS(ef->dynamic));      for (r = rel; r< erel; r++) { 	char* addr;  	if (r->r_address == 0) 	    break;  	addr = ELF_RELOC(ef, char, r->r_address); 	if (r->r_extern) { 	    np =&symbolbase[r->r_symbolnum]; 	    sym =&stringbase[np->nz_strx];  	    if (sym[0] != '_') { 		printf("link_elf: bad symbol name %s\n", sym); 		relocation = 0; 	    } else 		relocation = (long) 		    linker_file_lookup_symbol(lf, sym + 1, 					      np->nz_type != (N_SETV+N_EXT)); 	    if (!relocation) { 		printf("link_elf: symbol %s not found\n", sym); 		return ENOENT; 	    } 	     	    relocation += read_relocation(r, addr);  	    if (r->r_jmptable) { 		printf("link_elf: can't cope with jump table relocations\n"); 		continue; 	    }  	    if (r->r_pcrel) 		relocation -= (long) ef->address;  	    if (r->r_copy) { 		printf("link_elf: can't cope with copy relocations\n"); 		continue; 	    } 	     	    write_relocation(r, addr, relocation); 	} else { 	    write_relocation(r, addr, 			     (long)(read_relocation(r, addr) + ef->address)); 	} 	     }      return 0; }  static long symbol_hash_value(elf_file_t ef, const char* name) {     long hashval;     const char* p;      hashval = '_';
comment|/* fake a starting '_' for C symbols */
end_comment

begin_endif
unit|for (p = name; *p; p++) 	hashval = (hashval<< 1) + *p;      return (hashval& 0x7fffffff) % LD_BUCKETS(ef->dynamic); }
endif|#
directive|endif
end_endif

begin_function
name|int
name|link_elf_lookup_symbol
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|linker_sym_t
modifier|*
name|sym
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
name|lf
operator|->
name|priv
decl_stmt|;
name|int
name|symcount
init|=
name|ef
operator|->
name|nchains
decl_stmt|;
name|Elf_Sym
modifier|*
name|es
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* XXX use hash table */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|es
operator|=
name|ef
operator|->
name|symtab
init|;
name|i
operator|<
name|ef
operator|->
name|nchains
condition|;
name|i
operator|++
operator|,
name|es
operator|++
control|)
block|{
if|if
condition|(
name|es
operator|->
name|st_name
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ef
operator|->
name|strtab
operator|+
name|es
operator|->
name|st_name
argument_list|,
name|name
argument_list|)
condition|)
block|{
operator|*
name|sym
operator|=
operator|(
name|linker_sym_t
operator|)
name|es
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|ENOENT
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|link_elf_symbol_values
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
name|linker_sym_t
name|sym
parameter_list|,
name|linker_symval_t
modifier|*
name|symval
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
name|lf
operator|->
name|priv
decl_stmt|;
name|Elf_Sym
modifier|*
name|es
init|=
operator|(
name|Elf_Sym
operator|*
operator|)
name|sym
decl_stmt|;
name|symval
operator|->
name|name
operator|=
name|ef
operator|->
name|strtab
operator|+
name|es
operator|->
name|st_name
expr_stmt|;
name|symval
operator|->
name|value
operator|=
operator|(
name|caddr_t
operator|)
name|es
operator|->
name|st_value
expr_stmt|;
name|symval
operator|->
name|size
operator|=
name|es
operator|->
name|st_size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|link_elf_search_symbol
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
name|caddr_t
name|value
parameter_list|,
name|linker_sym_t
modifier|*
name|sym
parameter_list|,
name|long
modifier|*
name|diffp
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
name|lf
operator|->
name|priv
decl_stmt|;
name|u_long
name|off
init|=
operator|(
name|u_long
operator|)
name|value
decl_stmt|;
name|u_long
name|diff
init|=
name|off
decl_stmt|;
name|int
name|symcount
init|=
name|ef
operator|->
name|nchains
decl_stmt|;
name|Elf_Sym
modifier|*
name|es
decl_stmt|;
name|Elf_Sym
modifier|*
name|best
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|es
operator|=
name|ef
operator|->
name|symtab
init|;
name|i
operator|<
name|ef
operator|->
name|nchains
condition|;
name|i
operator|++
operator|,
name|es
operator|++
control|)
block|{
if|if
condition|(
name|es
operator|->
name|st_name
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|off
operator|>=
name|es
operator|->
name|st_value
condition|)
block|{
if|if
condition|(
name|off
operator|-
name|es
operator|->
name|st_value
operator|<
name|diff
condition|)
block|{
name|diff
operator|=
name|off
operator|-
name|es
operator|->
name|st_value
expr_stmt|;
name|best
operator|=
name|es
expr_stmt|;
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|off
operator|-
name|es
operator|->
name|st_value
operator|==
name|diff
condition|)
block|{
name|best
operator|=
name|es
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|best
operator|==
literal|0
condition|)
operator|*
name|diffp
operator|=
name|off
expr_stmt|;
else|else
operator|*
name|diffp
operator|=
name|diff
expr_stmt|;
operator|*
name|sym
operator|=
operator|(
name|linker_sym_t
operator|)
name|best
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

