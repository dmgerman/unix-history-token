begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998-2000 Doug Rabson  * Copyright (c) 2004 Peter Wemm  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<machine/elf.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<sys/link_elf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB_CTF
end_ifdef

begin_include
include|#
directive|include
file|<net/zlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"linker_if.h"
end_include

begin_typedef
typedef|typedef
struct|struct
block|{
name|void
modifier|*
name|addr
decl_stmt|;
name|Elf_Off
name|size
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|sec
decl_stmt|;
comment|/* Original section */
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|Elf_progent
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|Elf_Rel
modifier|*
name|rel
decl_stmt|;
name|int
name|nrel
decl_stmt|;
name|int
name|sec
decl_stmt|;
block|}
name|Elf_relent
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|Elf_Rela
modifier|*
name|rela
decl_stmt|;
name|int
name|nrela
decl_stmt|;
name|int
name|sec
decl_stmt|;
block|}
name|Elf_relaent
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|elf_file
block|{
name|struct
name|linker_file
name|lf
decl_stmt|;
comment|/* Common fields */
name|int
name|preloaded
decl_stmt|;
name|caddr_t
name|address
decl_stmt|;
comment|/* Relocation address */
name|vm_object_t
name|object
decl_stmt|;
comment|/* VM object to hold file pages */
name|Elf_Shdr
modifier|*
name|e_shdr
decl_stmt|;
name|Elf_progent
modifier|*
name|progtab
decl_stmt|;
name|int
name|nprogtab
decl_stmt|;
name|Elf_relaent
modifier|*
name|relatab
decl_stmt|;
name|int
name|nrelatab
decl_stmt|;
name|Elf_relent
modifier|*
name|reltab
decl_stmt|;
name|int
name|nreltab
decl_stmt|;
name|Elf_Sym
modifier|*
name|ddbsymtab
decl_stmt|;
comment|/* The symbol table we are using */
name|long
name|ddbsymcnt
decl_stmt|;
comment|/* Number of symbols */
name|caddr_t
name|ddbstrtab
decl_stmt|;
comment|/* String table */
name|long
name|ddbstrcnt
decl_stmt|;
comment|/* number of bytes in string table */
name|caddr_t
name|shstrtab
decl_stmt|;
comment|/* Section name string table */
name|long
name|shstrcnt
decl_stmt|;
comment|/* number of bytes in string table */
name|caddr_t
name|ctftab
decl_stmt|;
comment|/* CTF table */
name|long
name|ctfcnt
decl_stmt|;
comment|/* number of bytes in CTF table */
name|caddr_t
name|ctfoff
decl_stmt|;
comment|/* CTF offset table */
name|caddr_t
name|typoff
decl_stmt|;
comment|/* Type offset table */
name|long
name|typlen
decl_stmt|;
comment|/* Number of type entries. */
block|}
typedef|*
name|elf_file_t
typedef|;
end_typedef

begin_include
include|#
directive|include
file|<kern/kern_ctf.c>
end_include

begin_function_decl
specifier|static
name|int
name|link_elf_link_preload
parameter_list|(
name|linker_class_t
name|cls
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|linker_file_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_elf_link_preload_finish
parameter_list|(
name|linker_file_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_elf_load_file
parameter_list|(
name|linker_class_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|linker_file_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_elf_lookup_symbol
parameter_list|(
name|linker_file_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|c_linker_sym_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_elf_symbol_values
parameter_list|(
name|linker_file_t
parameter_list|,
name|c_linker_sym_t
parameter_list|,
name|linker_symval_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_elf_search_symbol
parameter_list|(
name|linker_file_t
parameter_list|,
name|caddr_t
name|value
parameter_list|,
name|c_linker_sym_t
modifier|*
name|sym
parameter_list|,
name|long
modifier|*
name|diffp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|link_elf_unload_file
parameter_list|(
name|linker_file_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_elf_lookup_set
parameter_list|(
name|linker_file_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_elf_each_function_name
parameter_list|(
name|linker_file_t
parameter_list|,
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|link_elf_each_function_nameval
parameter_list|(
name|linker_file_t
parameter_list|,
name|linker_function_nameval_callback_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|link_elf_reloc_local
parameter_list|(
name|linker_file_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|link_elf_symtab_get
parameter_list|(
name|linker_file_t
parameter_list|,
specifier|const
name|Elf_Sym
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|link_elf_strtab_get
parameter_list|(
name|linker_file_t
parameter_list|,
name|caddr_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Elf_Addr
name|elf_obj_lookup
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
name|Elf_Size
name|symidx
parameter_list|,
name|int
name|deps
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|kobj_method_t
name|link_elf_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|linker_lookup_symbol
argument_list|,
name|link_elf_lookup_symbol
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|linker_symbol_values
argument_list|,
name|link_elf_symbol_values
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|linker_search_symbol
argument_list|,
name|link_elf_search_symbol
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|linker_unload
argument_list|,
name|link_elf_unload_file
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|linker_load_file
argument_list|,
name|link_elf_load_file
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|linker_link_preload
argument_list|,
name|link_elf_link_preload
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|linker_link_preload_finish
argument_list|,
name|link_elf_link_preload_finish
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|linker_lookup_set
argument_list|,
name|link_elf_lookup_set
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|linker_each_function_name
argument_list|,
name|link_elf_each_function_name
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|linker_each_function_nameval
argument_list|,
name|link_elf_each_function_nameval
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|linker_ctf_get
argument_list|,
name|link_elf_ctf_get
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|linker_symtab_get
argument_list|,
name|link_elf_symtab_get
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|linker_strtab_get
argument_list|,
name|link_elf_strtab_get
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|linker_class
name|link_elf_class
init|=
block|{
if|#
directive|if
name|ELF_TARG_CLASS
operator|==
name|ELFCLASS32
literal|"elf32_obj"
block|,
else|#
directive|else
literal|"elf64_obj"
block|,
endif|#
directive|endif
name|link_elf_methods
block|,
expr|sizeof
operator|(
expr|struct
name|elf_file
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|relocate_file
parameter_list|(
name|elf_file_t
name|ef
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|link_elf_error
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"kldload: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"kldload: %s: %s\n"
argument_list|,
name|filename
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|link_elf_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|linker_add_class
argument_list|(
operator|&
name|link_elf_class
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|link_elf_obj
argument_list|,
name|SI_SUB_KLD
argument_list|,
name|SI_ORDER_SECOND
argument_list|,
name|link_elf_init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|link_elf_link_preload
parameter_list|(
name|linker_class_t
name|cls
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|linker_file_t
modifier|*
name|result
parameter_list|)
block|{
name|Elf_Ehdr
modifier|*
name|hdr
decl_stmt|;
name|Elf_Shdr
modifier|*
name|shdr
decl_stmt|;
name|Elf_Sym
modifier|*
name|es
decl_stmt|;
name|void
modifier|*
name|modptr
decl_stmt|,
modifier|*
name|baseptr
decl_stmt|,
modifier|*
name|sizeptr
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|elf_file_t
name|ef
decl_stmt|;
name|linker_file_t
name|lf
decl_stmt|;
name|Elf_Addr
name|off
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|pb
decl_stmt|,
name|ra
decl_stmt|,
name|rl
decl_stmt|,
name|shstrindex
decl_stmt|,
name|symstrindex
decl_stmt|,
name|symtabindex
decl_stmt|;
comment|/* Look to see if we have the file preloaded */
name|modptr
operator|=
name|preload_search_by_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|modptr
operator|==
name|NULL
condition|)
return|return
name|ENOENT
return|;
name|type
operator|=
operator|(
name|char
operator|*
operator|)
name|preload_search_info
argument_list|(
name|modptr
argument_list|,
name|MODINFO_TYPE
argument_list|)
expr_stmt|;
name|baseptr
operator|=
name|preload_search_info
argument_list|(
name|modptr
argument_list|,
name|MODINFO_ADDR
argument_list|)
expr_stmt|;
name|sizeptr
operator|=
name|preload_search_info
argument_list|(
name|modptr
argument_list|,
name|MODINFO_SIZE
argument_list|)
expr_stmt|;
name|hdr
operator|=
operator|(
name|Elf_Ehdr
operator|*
operator|)
name|preload_search_info
argument_list|(
name|modptr
argument_list|,
name|MODINFO_METADATA
operator||
name|MODINFOMD_ELFHDR
argument_list|)
expr_stmt|;
name|shdr
operator|=
operator|(
name|Elf_Shdr
operator|*
operator|)
name|preload_search_info
argument_list|(
name|modptr
argument_list|,
name|MODINFO_METADATA
operator||
name|MODINFOMD_SHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
operator|||
operator|(
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"elf"
name|__XSTRING
argument_list|(
name|__ELF_WORD_SIZE
argument_list|)
literal|" obj module"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"elf obj module"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
return|return
operator|(
name|EFTYPE
operator|)
return|;
block|}
if|if
condition|(
name|baseptr
operator|==
name|NULL
operator|||
name|sizeptr
operator|==
name|NULL
operator|||
name|hdr
operator|==
name|NULL
operator|||
name|shdr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|lf
operator|=
name|linker_make_file
argument_list|(
name|filename
argument_list|,
operator|&
name|link_elf_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|lf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|ef
operator|=
operator|(
name|elf_file_t
operator|)
name|lf
expr_stmt|;
name|ef
operator|->
name|preloaded
operator|=
literal|1
expr_stmt|;
name|ef
operator|->
name|address
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|baseptr
expr_stmt|;
name|lf
operator|->
name|address
operator|=
operator|*
operator|(
name|caddr_t
operator|*
operator|)
name|baseptr
expr_stmt|;
name|lf
operator|->
name|size
operator|=
operator|*
operator|(
name|size_t
operator|*
operator|)
name|sizeptr
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|ELF_TARG_CLASS
operator|||
name|hdr
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
operator|!=
name|ELF_TARG_DATA
operator|||
name|hdr
operator|->
name|e_ident
index|[
name|EI_VERSION
index|]
operator|!=
name|EV_CURRENT
operator|||
name|hdr
operator|->
name|e_version
operator|!=
name|EV_CURRENT
operator|||
name|hdr
operator|->
name|e_type
operator|!=
name|ET_REL
operator|||
name|hdr
operator|->
name|e_machine
operator|!=
name|ELF_TARG_MACH
condition|)
block|{
name|error
operator|=
name|EFTYPE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ef
operator|->
name|e_shdr
operator|=
name|shdr
expr_stmt|;
comment|/* Scan the section header for information and table sizing. */
name|symtabindex
operator|=
operator|-
literal|1
expr_stmt|;
name|symstrindex
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|e_shnum
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|shdr
index|[
name|i
index|]
operator|.
name|sh_type
condition|)
block|{
case|case
name|SHT_PROGBITS
case|:
case|case
name|SHT_NOBITS
case|:
name|ef
operator|->
name|nprogtab
operator|++
expr_stmt|;
break|break;
case|case
name|SHT_SYMTAB
case|:
name|symtabindex
operator|=
name|i
expr_stmt|;
name|symstrindex
operator|=
name|shdr
index|[
name|i
index|]
operator|.
name|sh_link
expr_stmt|;
break|break;
case|case
name|SHT_REL
case|:
name|ef
operator|->
name|nreltab
operator|++
expr_stmt|;
break|break;
case|case
name|SHT_RELA
case|:
name|ef
operator|->
name|nrelatab
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|shstrindex
operator|=
name|hdr
operator|->
name|e_shstrndx
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|nprogtab
operator|==
literal|0
operator|||
name|symstrindex
operator|<
literal|0
operator|||
name|symstrindex
operator|>=
name|hdr
operator|->
name|e_shnum
operator|||
name|shdr
index|[
name|symstrindex
index|]
operator|.
name|sh_type
operator|!=
name|SHT_STRTAB
operator|||
name|shstrindex
operator|==
literal|0
operator|||
name|shstrindex
operator|>=
name|hdr
operator|->
name|e_shnum
operator|||
name|shdr
index|[
name|shstrindex
index|]
operator|.
name|sh_type
operator|!=
name|SHT_STRTAB
condition|)
block|{
name|printf
argument_list|(
literal|"%s: bad/missing section headers\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Allocate space for tracking the load chunks */
if|if
condition|(
name|ef
operator|->
name|nprogtab
operator|!=
literal|0
condition|)
name|ef
operator|->
name|progtab
operator|=
name|malloc
argument_list|(
name|ef
operator|->
name|nprogtab
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ef
operator|->
name|progtab
argument_list|)
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|nreltab
operator|!=
literal|0
condition|)
name|ef
operator|->
name|reltab
operator|=
name|malloc
argument_list|(
name|ef
operator|->
name|nreltab
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ef
operator|->
name|reltab
argument_list|)
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|nrelatab
operator|!=
literal|0
condition|)
name|ef
operator|->
name|relatab
operator|=
name|malloc
argument_list|(
name|ef
operator|->
name|nrelatab
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ef
operator|->
name|relatab
argument_list|)
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ef
operator|->
name|nprogtab
operator|!=
literal|0
operator|&&
name|ef
operator|->
name|progtab
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ef
operator|->
name|nreltab
operator|!=
literal|0
operator|&&
name|ef
operator|->
name|reltab
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ef
operator|->
name|nrelatab
operator|!=
literal|0
operator|&&
name|ef
operator|->
name|relatab
operator|==
name|NULL
operator|)
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* XXX, relocate the sh_addr fields saved by the loader. */
name|off
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|e_shnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|shdr
index|[
name|i
index|]
operator|.
name|sh_addr
operator|!=
literal|0
operator|&&
operator|(
name|off
operator|==
literal|0
operator|||
name|shdr
index|[
name|i
index|]
operator|.
name|sh_addr
operator|<
name|off
operator|)
condition|)
name|off
operator|=
name|shdr
index|[
name|i
index|]
operator|.
name|sh_addr
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|e_shnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|shdr
index|[
name|i
index|]
operator|.
name|sh_addr
operator|!=
literal|0
condition|)
name|shdr
index|[
name|i
index|]
operator|.
name|sh_addr
operator|=
name|shdr
index|[
name|i
index|]
operator|.
name|sh_addr
operator|-
name|off
operator|+
operator|(
name|Elf_Addr
operator|)
name|ef
operator|->
name|address
expr_stmt|;
block|}
name|ef
operator|->
name|ddbsymcnt
operator|=
name|shdr
index|[
name|symtabindex
index|]
operator|.
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_Sym
argument_list|)
expr_stmt|;
name|ef
operator|->
name|ddbsymtab
operator|=
operator|(
name|Elf_Sym
operator|*
operator|)
name|shdr
index|[
name|symtabindex
index|]
operator|.
name|sh_addr
expr_stmt|;
name|ef
operator|->
name|ddbstrcnt
operator|=
name|shdr
index|[
name|symstrindex
index|]
operator|.
name|sh_size
expr_stmt|;
name|ef
operator|->
name|ddbstrtab
operator|=
operator|(
name|char
operator|*
operator|)
name|shdr
index|[
name|symstrindex
index|]
operator|.
name|sh_addr
expr_stmt|;
name|ef
operator|->
name|shstrcnt
operator|=
name|shdr
index|[
name|shstrindex
index|]
operator|.
name|sh_size
expr_stmt|;
name|ef
operator|->
name|shstrtab
operator|=
operator|(
name|char
operator|*
operator|)
name|shdr
index|[
name|shstrindex
index|]
operator|.
name|sh_addr
expr_stmt|;
comment|/* Now fill out progtab and the relocation tables. */
name|pb
operator|=
literal|0
expr_stmt|;
name|rl
operator|=
literal|0
expr_stmt|;
name|ra
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|e_shnum
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|shdr
index|[
name|i
index|]
operator|.
name|sh_type
condition|)
block|{
case|case
name|SHT_PROGBITS
case|:
case|case
name|SHT_NOBITS
case|:
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|addr
operator|=
operator|(
name|void
operator|*
operator|)
name|shdr
index|[
name|i
index|]
operator|.
name|sh_addr
expr_stmt|;
if|if
condition|(
name|shdr
index|[
name|i
index|]
operator|.
name|sh_type
operator|==
name|SHT_PROGBITS
condition|)
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|name
operator|=
literal|"<<PROGBITS>>"
expr_stmt|;
else|else
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|name
operator|=
literal|"<<NOBITS>>"
expr_stmt|;
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|size
operator|=
name|shdr
index|[
name|i
index|]
operator|.
name|sh_size
expr_stmt|;
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|sec
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|shstrtab
operator|&&
name|shdr
index|[
name|i
index|]
operator|.
name|sh_name
operator|!=
literal|0
condition|)
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|name
operator|=
name|ef
operator|->
name|shstrtab
operator|+
name|shdr
index|[
name|i
index|]
operator|.
name|sh_name
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|name
argument_list|,
literal|"set_pcpu"
argument_list|)
condition|)
block|{
name|void
modifier|*
name|dpcpu
decl_stmt|;
name|dpcpu
operator|=
name|dpcpu_alloc
argument_list|(
name|shdr
index|[
name|i
index|]
operator|.
name|sh_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpcpu
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|memcpy
argument_list|(
name|dpcpu
argument_list|,
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|addr
argument_list|,
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
name|dpcpu_copy
argument_list|(
name|dpcpu
argument_list|,
name|shdr
index|[
name|i
index|]
operator|.
name|sh_size
argument_list|)
expr_stmt|;
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|addr
operator|=
name|dpcpu
expr_stmt|;
block|}
comment|/* Update all symbol values with the offset. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ef
operator|->
name|ddbsymcnt
condition|;
name|j
operator|++
control|)
block|{
name|es
operator|=
operator|&
name|ef
operator|->
name|ddbsymtab
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|es
operator|->
name|st_shndx
operator|!=
name|i
condition|)
continue|continue;
name|es
operator|->
name|st_value
operator|+=
operator|(
name|Elf_Addr
operator|)
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|addr
expr_stmt|;
block|}
name|pb
operator|++
expr_stmt|;
break|break;
case|case
name|SHT_REL
case|:
name|ef
operator|->
name|reltab
index|[
name|rl
index|]
operator|.
name|rel
operator|=
operator|(
name|Elf_Rel
operator|*
operator|)
name|shdr
index|[
name|i
index|]
operator|.
name|sh_addr
expr_stmt|;
name|ef
operator|->
name|reltab
index|[
name|rl
index|]
operator|.
name|nrel
operator|=
name|shdr
index|[
name|i
index|]
operator|.
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_Rel
argument_list|)
expr_stmt|;
name|ef
operator|->
name|reltab
index|[
name|rl
index|]
operator|.
name|sec
operator|=
name|shdr
index|[
name|i
index|]
operator|.
name|sh_info
expr_stmt|;
name|rl
operator|++
expr_stmt|;
break|break;
case|case
name|SHT_RELA
case|:
name|ef
operator|->
name|relatab
index|[
name|ra
index|]
operator|.
name|rela
operator|=
operator|(
name|Elf_Rela
operator|*
operator|)
name|shdr
index|[
name|i
index|]
operator|.
name|sh_addr
expr_stmt|;
name|ef
operator|->
name|relatab
index|[
name|ra
index|]
operator|.
name|nrela
operator|=
name|shdr
index|[
name|i
index|]
operator|.
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_Rela
argument_list|)
expr_stmt|;
name|ef
operator|->
name|relatab
index|[
name|ra
index|]
operator|.
name|sec
operator|=
name|shdr
index|[
name|i
index|]
operator|.
name|sh_info
expr_stmt|;
name|ra
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pb
operator|!=
name|ef
operator|->
name|nprogtab
condition|)
name|panic
argument_list|(
literal|"lost progbits"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|!=
name|ef
operator|->
name|nreltab
condition|)
name|panic
argument_list|(
literal|"lost reltab"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ra
operator|!=
name|ef
operator|->
name|nrelatab
condition|)
name|panic
argument_list|(
literal|"lost relatab"
argument_list|)
expr_stmt|;
comment|/* Local intra-module relocations */
name|link_elf_reloc_local
argument_list|(
name|lf
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|lf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|out
label|:
comment|/* preload not done this way */
name|linker_file_unload
argument_list|(
name|lf
argument_list|,
name|LINKER_UNLOAD_FORCE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|link_elf_link_preload_finish
parameter_list|(
name|linker_file_t
name|lf
parameter_list|)
block|{
name|elf_file_t
name|ef
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ef
operator|=
operator|(
name|elf_file_t
operator|)
name|lf
expr_stmt|;
name|error
operator|=
name|relocate_file
argument_list|(
name|ef
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
comment|/* Notify MD code that a module is being loaded. */
name|error
operator|=
name|elf_cpu_load_file
argument_list|(
name|lf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|link_elf_load_file
parameter_list|(
name|linker_class_t
name|cls
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|linker_file_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
comment|/* XXX */
name|Elf_Ehdr
modifier|*
name|hdr
decl_stmt|;
name|Elf_Shdr
modifier|*
name|shdr
decl_stmt|;
name|Elf_Sym
modifier|*
name|es
decl_stmt|;
name|int
name|nbytes
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|vm_offset_t
name|mapbase
decl_stmt|;
name|size_t
name|mapsize
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|resid
decl_stmt|,
name|flags
decl_stmt|;
name|elf_file_t
name|ef
decl_stmt|;
name|linker_file_t
name|lf
decl_stmt|;
name|int
name|symtabindex
decl_stmt|;
name|int
name|symstrindex
decl_stmt|;
name|int
name|shstrindex
decl_stmt|;
name|int
name|nsym
decl_stmt|;
name|int
name|pb
decl_stmt|,
name|rl
decl_stmt|,
name|ra
decl_stmt|;
name|int
name|alignmask
decl_stmt|;
name|int
name|vfslocked
decl_stmt|;
name|shdr
operator|=
name|NULL
expr_stmt|;
name|lf
operator|=
name|NULL
expr_stmt|;
name|mapsize
operator|=
literal|0
expr_stmt|;
name|hdr
operator|=
name|NULL
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|MPSAFE
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|filename
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|flags
operator|=
name|FREAD
expr_stmt|;
name|error
operator|=
name|vn_open
argument_list|(
operator|&
name|nd
argument_list|,
operator|&
name|flags
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|vfslocked
operator|=
name|NDHASGIANT
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|.
name|ni_vp
operator|->
name|v_type
operator|!=
name|VREG
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_kld_check_load
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
comment|/* Read the elf header from the file. */
name|hdr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hdr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|resid
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|resid
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|IS_ELF
argument_list|(
operator|*
name|hdr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|hdr
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|ELF_TARG_CLASS
operator|||
name|hdr
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
operator|!=
name|ELF_TARG_DATA
condition|)
block|{
name|link_elf_error
argument_list|(
name|filename
argument_list|,
literal|"Unsupported file layout"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|hdr
operator|->
name|e_ident
index|[
name|EI_VERSION
index|]
operator|!=
name|EV_CURRENT
operator|||
name|hdr
operator|->
name|e_version
operator|!=
name|EV_CURRENT
condition|)
block|{
name|link_elf_error
argument_list|(
name|filename
argument_list|,
literal|"Unsupported file version"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|hdr
operator|->
name|e_type
operator|!=
name|ET_REL
condition|)
block|{
name|error
operator|=
name|ENOSYS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|hdr
operator|->
name|e_machine
operator|!=
name|ELF_TARG_MACH
condition|)
block|{
name|link_elf_error
argument_list|(
name|filename
argument_list|,
literal|"Unsupported machine"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|lf
operator|=
name|linker_make_file
argument_list|(
name|filename
argument_list|,
operator|&
name|link_elf_class
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lf
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ef
operator|=
operator|(
name|elf_file_t
operator|)
name|lf
expr_stmt|;
name|ef
operator|->
name|nprogtab
operator|=
literal|0
expr_stmt|;
name|ef
operator|->
name|e_shdr
operator|=
literal|0
expr_stmt|;
name|ef
operator|->
name|nreltab
operator|=
literal|0
expr_stmt|;
name|ef
operator|->
name|nrelatab
operator|=
literal|0
expr_stmt|;
comment|/* Allocate and read in the section header */
name|nbytes
operator|=
name|hdr
operator|->
name|e_shnum
operator|*
name|hdr
operator|->
name|e_shentsize
expr_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|0
operator|||
name|hdr
operator|->
name|e_shoff
operator|==
literal|0
operator|||
name|hdr
operator|->
name|e_shentsize
operator|!=
sizeof|sizeof
argument_list|(
name|Elf_Shdr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|shdr
operator|=
name|malloc
argument_list|(
name|nbytes
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|shdr
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ef
operator|->
name|e_shdr
operator|=
name|shdr
expr_stmt|;
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
operator|(
name|caddr_t
operator|)
name|shdr
argument_list|,
name|nbytes
argument_list|,
name|hdr
operator|->
name|e_shoff
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|resid
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|resid
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Scan the section header for information and table sizing. */
name|nsym
operator|=
literal|0
expr_stmt|;
name|symtabindex
operator|=
operator|-
literal|1
expr_stmt|;
name|symstrindex
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|e_shnum
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|shdr
index|[
name|i
index|]
operator|.
name|sh_type
condition|)
block|{
case|case
name|SHT_PROGBITS
case|:
case|case
name|SHT_NOBITS
case|:
name|ef
operator|->
name|nprogtab
operator|++
expr_stmt|;
break|break;
case|case
name|SHT_SYMTAB
case|:
name|nsym
operator|++
expr_stmt|;
name|symtabindex
operator|=
name|i
expr_stmt|;
name|symstrindex
operator|=
name|shdr
index|[
name|i
index|]
operator|.
name|sh_link
expr_stmt|;
break|break;
case|case
name|SHT_REL
case|:
name|ef
operator|->
name|nreltab
operator|++
expr_stmt|;
break|break;
case|case
name|SHT_RELA
case|:
name|ef
operator|->
name|nrelatab
operator|++
expr_stmt|;
break|break;
case|case
name|SHT_STRTAB
case|:
break|break;
block|}
block|}
if|if
condition|(
name|ef
operator|->
name|nprogtab
operator|==
literal|0
condition|)
block|{
name|link_elf_error
argument_list|(
name|filename
argument_list|,
literal|"file has no contents"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|nsym
operator|!=
literal|1
condition|)
block|{
comment|/* Only allow one symbol table for now */
name|link_elf_error
argument_list|(
name|filename
argument_list|,
literal|"file has no valid symbol table"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|symstrindex
operator|<
literal|0
operator|||
name|symstrindex
operator|>
name|hdr
operator|->
name|e_shnum
operator|||
name|shdr
index|[
name|symstrindex
index|]
operator|.
name|sh_type
operator|!=
name|SHT_STRTAB
condition|)
block|{
name|link_elf_error
argument_list|(
name|filename
argument_list|,
literal|"file has invalid symbol strings"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Allocate space for tracking the load chunks */
if|if
condition|(
name|ef
operator|->
name|nprogtab
operator|!=
literal|0
condition|)
name|ef
operator|->
name|progtab
operator|=
name|malloc
argument_list|(
name|ef
operator|->
name|nprogtab
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ef
operator|->
name|progtab
argument_list|)
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|nreltab
operator|!=
literal|0
condition|)
name|ef
operator|->
name|reltab
operator|=
name|malloc
argument_list|(
name|ef
operator|->
name|nreltab
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ef
operator|->
name|reltab
argument_list|)
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|nrelatab
operator|!=
literal|0
condition|)
name|ef
operator|->
name|relatab
operator|=
name|malloc
argument_list|(
name|ef
operator|->
name|nrelatab
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ef
operator|->
name|relatab
argument_list|)
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ef
operator|->
name|nprogtab
operator|!=
literal|0
operator|&&
name|ef
operator|->
name|progtab
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ef
operator|->
name|nreltab
operator|!=
literal|0
operator|&&
name|ef
operator|->
name|reltab
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ef
operator|->
name|nrelatab
operator|!=
literal|0
operator|&&
name|ef
operator|->
name|relatab
operator|==
name|NULL
operator|)
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|symtabindex
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"lost symbol table index"
argument_list|)
expr_stmt|;
comment|/* Allocate space for and load the symbol table */
name|ef
operator|->
name|ddbsymcnt
operator|=
name|shdr
index|[
name|symtabindex
index|]
operator|.
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_Sym
argument_list|)
expr_stmt|;
name|ef
operator|->
name|ddbsymtab
operator|=
name|malloc
argument_list|(
name|shdr
index|[
name|symtabindex
index|]
operator|.
name|sh_size
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|ddbsymtab
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ef
operator|->
name|ddbsymtab
argument_list|,
name|shdr
index|[
name|symtabindex
index|]
operator|.
name|sh_size
argument_list|,
name|shdr
index|[
name|symtabindex
index|]
operator|.
name|sh_offset
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|resid
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|resid
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|symstrindex
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"lost symbol string index"
argument_list|)
expr_stmt|;
comment|/* Allocate space for and load the symbol strings */
name|ef
operator|->
name|ddbstrcnt
operator|=
name|shdr
index|[
name|symstrindex
index|]
operator|.
name|sh_size
expr_stmt|;
name|ef
operator|->
name|ddbstrtab
operator|=
name|malloc
argument_list|(
name|shdr
index|[
name|symstrindex
index|]
operator|.
name|sh_size
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|ddbstrtab
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
name|ef
operator|->
name|ddbstrtab
argument_list|,
name|shdr
index|[
name|symstrindex
index|]
operator|.
name|sh_size
argument_list|,
name|shdr
index|[
name|symstrindex
index|]
operator|.
name|sh_offset
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|resid
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|resid
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Do we have a string table for the section names?  */
name|shstrindex
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|hdr
operator|->
name|e_shstrndx
operator|!=
literal|0
operator|&&
name|shdr
index|[
name|hdr
operator|->
name|e_shstrndx
index|]
operator|.
name|sh_type
operator|==
name|SHT_STRTAB
condition|)
block|{
name|shstrindex
operator|=
name|hdr
operator|->
name|e_shstrndx
expr_stmt|;
name|ef
operator|->
name|shstrcnt
operator|=
name|shdr
index|[
name|shstrindex
index|]
operator|.
name|sh_size
expr_stmt|;
name|ef
operator|->
name|shstrtab
operator|=
name|malloc
argument_list|(
name|shdr
index|[
name|shstrindex
index|]
operator|.
name|sh_size
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|shstrtab
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
name|ef
operator|->
name|shstrtab
argument_list|,
name|shdr
index|[
name|shstrindex
index|]
operator|.
name|sh_size
argument_list|,
name|shdr
index|[
name|shstrindex
index|]
operator|.
name|sh_offset
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|resid
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|resid
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* Size up code/data(progbits) and bss(nobits). */
name|alignmask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|e_shnum
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|shdr
index|[
name|i
index|]
operator|.
name|sh_type
condition|)
block|{
case|case
name|SHT_PROGBITS
case|:
case|case
name|SHT_NOBITS
case|:
name|alignmask
operator|=
name|shdr
index|[
name|i
index|]
operator|.
name|sh_addralign
operator|-
literal|1
expr_stmt|;
name|mapsize
operator|+=
name|alignmask
expr_stmt|;
name|mapsize
operator|&=
operator|~
name|alignmask
expr_stmt|;
name|mapsize
operator|+=
name|shdr
index|[
name|i
index|]
operator|.
name|sh_size
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * We know how much space we need for the text/data/bss/etc. 	 * This stuff needs to be in a single chunk so that profiling etc 	 * can get the bounds and gdb can associate offsets with modules 	 */
name|ef
operator|->
name|object
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|round_page
argument_list|(
name|mapsize
argument_list|)
operator|>>
name|PAGE_SHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|object
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ef
operator|->
name|address
operator|=
operator|(
name|caddr_t
operator|)
name|vm_map_min
argument_list|(
name|kernel_map
argument_list|)
expr_stmt|;
comment|/* 	 * In order to satisfy amd64's architectural requirements on the 	 * location of code and data in the kernel's address space, request a 	 * mapping that is above the kernel.   	 */
name|mapbase
operator|=
name|KERNBASE
expr_stmt|;
name|error
operator|=
name|vm_map_find
argument_list|(
name|kernel_map
argument_list|,
name|ef
operator|->
name|object
argument_list|,
literal|0
argument_list|,
operator|&
name|mapbase
argument_list|,
name|round_page
argument_list|(
name|mapsize
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vm_object_deallocate
argument_list|(
name|ef
operator|->
name|object
argument_list|)
expr_stmt|;
name|ef
operator|->
name|object
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Wire the pages */
name|error
operator|=
name|vm_map_wire
argument_list|(
name|kernel_map
argument_list|,
name|mapbase
argument_list|,
name|mapbase
operator|+
name|round_page
argument_list|(
name|mapsize
argument_list|)
argument_list|,
name|VM_MAP_WIRE_SYSTEM
operator||
name|VM_MAP_WIRE_NOHOLES
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Inform the kld system about the situation */
name|lf
operator|->
name|address
operator|=
name|ef
operator|->
name|address
operator|=
operator|(
name|caddr_t
operator|)
name|mapbase
expr_stmt|;
name|lf
operator|->
name|size
operator|=
name|mapsize
expr_stmt|;
comment|/* 	 * Now load code/data(progbits), zero bss(nobits), allocate space for 	 * and load relocs 	 */
name|pb
operator|=
literal|0
expr_stmt|;
name|rl
operator|=
literal|0
expr_stmt|;
name|ra
operator|=
literal|0
expr_stmt|;
name|alignmask
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|e_shnum
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|shdr
index|[
name|i
index|]
operator|.
name|sh_type
condition|)
block|{
case|case
name|SHT_PROGBITS
case|:
case|case
name|SHT_NOBITS
case|:
name|alignmask
operator|=
name|shdr
index|[
name|i
index|]
operator|.
name|sh_addralign
operator|-
literal|1
expr_stmt|;
name|mapbase
operator|+=
name|alignmask
expr_stmt|;
name|mapbase
operator|&=
operator|~
name|alignmask
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|shstrtab
operator|&&
name|shdr
index|[
name|i
index|]
operator|.
name|sh_name
operator|!=
literal|0
condition|)
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|name
operator|=
name|ef
operator|->
name|shstrtab
operator|+
name|shdr
index|[
name|i
index|]
operator|.
name|sh_name
expr_stmt|;
elseif|else
if|if
condition|(
name|shdr
index|[
name|i
index|]
operator|.
name|sh_type
operator|==
name|SHT_PROGBITS
condition|)
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|name
operator|=
literal|"<<PROGBITS>>"
expr_stmt|;
else|else
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|name
operator|=
literal|"<<NOBITS>>"
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|name
operator|!=
name|NULL
operator|&&
operator|!
name|strcmp
argument_list|(
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|name
argument_list|,
literal|"set_pcpu"
argument_list|)
condition|)
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|addr
operator|=
name|dpcpu_alloc
argument_list|(
name|shdr
index|[
name|i
index|]
operator|.
name|sh_size
argument_list|)
expr_stmt|;
else|else
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|mapbase
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|addr
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|size
operator|=
name|shdr
index|[
name|i
index|]
operator|.
name|sh_size
expr_stmt|;
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|sec
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|shdr
index|[
name|i
index|]
operator|.
name|sh_type
operator|==
name|SHT_PROGBITS
condition|)
block|{
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|addr
argument_list|,
name|shdr
index|[
name|i
index|]
operator|.
name|sh_size
argument_list|,
name|shdr
index|[
name|i
index|]
operator|.
name|sh_offset
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|resid
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|resid
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Initialize the per-cpu area. */
if|if
condition|(
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|addr
operator|!=
operator|(
name|void
operator|*
operator|)
name|mapbase
condition|)
name|dpcpu_copy
argument_list|(
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|addr
argument_list|,
name|shdr
index|[
name|i
index|]
operator|.
name|sh_size
argument_list|)
expr_stmt|;
block|}
else|else
name|bzero
argument_list|(
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|addr
argument_list|,
name|shdr
index|[
name|i
index|]
operator|.
name|sh_size
argument_list|)
expr_stmt|;
comment|/* Update all symbol values with the offset. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ef
operator|->
name|ddbsymcnt
condition|;
name|j
operator|++
control|)
block|{
name|es
operator|=
operator|&
name|ef
operator|->
name|ddbsymtab
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|es
operator|->
name|st_shndx
operator|!=
name|i
condition|)
continue|continue;
name|es
operator|->
name|st_value
operator|+=
operator|(
name|Elf_Addr
operator|)
name|ef
operator|->
name|progtab
index|[
name|pb
index|]
operator|.
name|addr
expr_stmt|;
block|}
name|mapbase
operator|+=
name|shdr
index|[
name|i
index|]
operator|.
name|sh_size
expr_stmt|;
name|pb
operator|++
expr_stmt|;
break|break;
case|case
name|SHT_REL
case|:
name|ef
operator|->
name|reltab
index|[
name|rl
index|]
operator|.
name|rel
operator|=
name|malloc
argument_list|(
name|shdr
index|[
name|i
index|]
operator|.
name|sh_size
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ef
operator|->
name|reltab
index|[
name|rl
index|]
operator|.
name|nrel
operator|=
name|shdr
index|[
name|i
index|]
operator|.
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_Rel
argument_list|)
expr_stmt|;
name|ef
operator|->
name|reltab
index|[
name|rl
index|]
operator|.
name|sec
operator|=
name|shdr
index|[
name|i
index|]
operator|.
name|sh_info
expr_stmt|;
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ef
operator|->
name|reltab
index|[
name|rl
index|]
operator|.
name|rel
argument_list|,
name|shdr
index|[
name|i
index|]
operator|.
name|sh_size
argument_list|,
name|shdr
index|[
name|i
index|]
operator|.
name|sh_offset
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|resid
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|resid
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|rl
operator|++
expr_stmt|;
break|break;
case|case
name|SHT_RELA
case|:
name|ef
operator|->
name|relatab
index|[
name|ra
index|]
operator|.
name|rela
operator|=
name|malloc
argument_list|(
name|shdr
index|[
name|i
index|]
operator|.
name|sh_size
argument_list|,
name|M_LINKER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ef
operator|->
name|relatab
index|[
name|ra
index|]
operator|.
name|nrela
operator|=
name|shdr
index|[
name|i
index|]
operator|.
name|sh_size
operator|/
sizeof|sizeof
argument_list|(
name|Elf_Rela
argument_list|)
expr_stmt|;
name|ef
operator|->
name|relatab
index|[
name|ra
index|]
operator|.
name|sec
operator|=
name|shdr
index|[
name|i
index|]
operator|.
name|sh_info
expr_stmt|;
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ef
operator|->
name|relatab
index|[
name|ra
index|]
operator|.
name|rela
argument_list|,
name|shdr
index|[
name|i
index|]
operator|.
name|sh_size
argument_list|,
name|shdr
index|[
name|i
index|]
operator|.
name|sh_offset
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|resid
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|resid
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ra
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pb
operator|!=
name|ef
operator|->
name|nprogtab
condition|)
name|panic
argument_list|(
literal|"lost progbits"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|!=
name|ef
operator|->
name|nreltab
condition|)
name|panic
argument_list|(
literal|"lost reltab"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ra
operator|!=
name|ef
operator|->
name|nrelatab
condition|)
name|panic
argument_list|(
literal|"lost relatab"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapbase
operator|!=
operator|(
name|vm_offset_t
operator|)
name|ef
operator|->
name|address
operator|+
name|mapsize
condition|)
name|panic
argument_list|(
literal|"mapbase 0x%lx != address %p + mapsize 0x%lx (0x%lx)\n"
argument_list|,
name|mapbase
argument_list|,
name|ef
operator|->
name|address
argument_list|,
name|mapsize
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|ef
operator|->
name|address
operator|+
name|mapsize
argument_list|)
expr_stmt|;
comment|/* Local intra-module relocations */
name|link_elf_reloc_local
argument_list|(
name|lf
argument_list|)
expr_stmt|;
comment|/* Pull in dependencies */
name|VOP_UNLOCK
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|linker_load_dependencies
argument_list|(
name|lf
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* External relocations */
name|error
operator|=
name|relocate_file
argument_list|(
name|ef
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* Notify MD code that a module is being loaded. */
name|error
operator|=
name|elf_cpu_load_file
argument_list|(
name|lf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
operator|*
name|result
operator|=
name|lf
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
operator|&&
name|lf
condition|)
name|linker_file_unload
argument_list|(
name|lf
argument_list|,
name|LINKER_UNLOAD_FORCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
condition|)
name|free
argument_list|(
name|hdr
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vn_close
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
name|FREAD
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|link_elf_unload_file
parameter_list|(
name|linker_file_t
name|file
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
operator|(
name|elf_file_t
operator|)
name|file
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Notify MD code that a module is being unloaded. */
name|elf_cpu_unload_file
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|progtab
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ef
operator|->
name|nprogtab
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ef
operator|->
name|progtab
index|[
name|i
index|]
operator|.
name|size
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ef
operator|->
name|progtab
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ef
operator|->
name|progtab
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"set_pcpu"
argument_list|)
condition|)
name|dpcpu_free
argument_list|(
name|ef
operator|->
name|progtab
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
name|ef
operator|->
name|progtab
index|[
name|i
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ef
operator|->
name|preloaded
condition|)
block|{
if|if
condition|(
name|ef
operator|->
name|reltab
condition|)
name|free
argument_list|(
name|ef
operator|->
name|reltab
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|relatab
condition|)
name|free
argument_list|(
name|ef
operator|->
name|relatab
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|progtab
condition|)
name|free
argument_list|(
name|ef
operator|->
name|progtab
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|ctftab
condition|)
name|free
argument_list|(
name|ef
operator|->
name|ctftab
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|ctfoff
condition|)
name|free
argument_list|(
name|ef
operator|->
name|ctfoff
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|typoff
condition|)
name|free
argument_list|(
name|ef
operator|->
name|typoff
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|filename
operator|!=
name|NULL
condition|)
name|preload_delete_name
argument_list|(
name|file
operator|->
name|filename
argument_list|)
expr_stmt|;
comment|/* XXX reclaim module memory? */
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ef
operator|->
name|nreltab
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ef
operator|->
name|reltab
index|[
name|i
index|]
operator|.
name|rel
condition|)
name|free
argument_list|(
name|ef
operator|->
name|reltab
index|[
name|i
index|]
operator|.
name|rel
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ef
operator|->
name|nrelatab
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ef
operator|->
name|relatab
index|[
name|i
index|]
operator|.
name|rela
condition|)
name|free
argument_list|(
name|ef
operator|->
name|relatab
index|[
name|i
index|]
operator|.
name|rela
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|reltab
condition|)
name|free
argument_list|(
name|ef
operator|->
name|reltab
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|relatab
condition|)
name|free
argument_list|(
name|ef
operator|->
name|relatab
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|progtab
condition|)
name|free
argument_list|(
name|ef
operator|->
name|progtab
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|object
condition|)
block|{
name|vm_map_remove
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|ef
operator|->
name|address
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|ef
operator|->
name|address
operator|+
operator|(
name|ef
operator|->
name|object
operator|->
name|size
operator|<<
name|PAGE_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ef
operator|->
name|e_shdr
condition|)
name|free
argument_list|(
name|ef
operator|->
name|e_shdr
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|ddbsymtab
condition|)
name|free
argument_list|(
name|ef
operator|->
name|ddbsymtab
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|ddbstrtab
condition|)
name|free
argument_list|(
name|ef
operator|->
name|ddbstrtab
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|shstrtab
condition|)
name|free
argument_list|(
name|ef
operator|->
name|shstrtab
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|ctftab
condition|)
name|free
argument_list|(
name|ef
operator|->
name|ctftab
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|ctfoff
condition|)
name|free
argument_list|(
name|ef
operator|->
name|ctfoff
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ef
operator|->
name|typoff
condition|)
name|free
argument_list|(
name|ef
operator|->
name|typoff
argument_list|,
name|M_LINKER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|symbol_name
parameter_list|(
name|elf_file_t
name|ef
parameter_list|,
name|Elf_Size
name|r_info
parameter_list|)
block|{
specifier|const
name|Elf_Sym
modifier|*
name|ref
decl_stmt|;
if|if
condition|(
name|ELF_R_SYM
argument_list|(
name|r_info
argument_list|)
condition|)
block|{
name|ref
operator|=
name|ef
operator|->
name|ddbsymtab
operator|+
name|ELF_R_SYM
argument_list|(
name|r_info
argument_list|)
expr_stmt|;
return|return
name|ef
operator|->
name|ddbstrtab
operator|+
name|ref
operator|->
name|st_name
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|Elf_Addr
name|findbase
parameter_list|(
name|elf_file_t
name|ef
parameter_list|,
name|int
name|sec
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Elf_Addr
name|base
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ef
operator|->
name|nprogtab
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sec
operator|==
name|ef
operator|->
name|progtab
index|[
name|i
index|]
operator|.
name|sec
condition|)
block|{
name|base
operator|=
operator|(
name|Elf_Addr
operator|)
name|ef
operator|->
name|progtab
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
break|break;
block|}
block|}
return|return
name|base
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|relocate_file
parameter_list|(
name|elf_file_t
name|ef
parameter_list|)
block|{
specifier|const
name|Elf_Rel
modifier|*
name|rellim
decl_stmt|;
specifier|const
name|Elf_Rel
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Rela
modifier|*
name|relalim
decl_stmt|;
specifier|const
name|Elf_Rela
modifier|*
name|rela
decl_stmt|;
specifier|const
name|char
modifier|*
name|symname
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|sym
decl_stmt|;
name|int
name|i
decl_stmt|;
name|Elf_Size
name|symidx
decl_stmt|;
name|Elf_Addr
name|base
decl_stmt|;
comment|/* Perform relocations without addend if there are any: */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ef
operator|->
name|nreltab
condition|;
name|i
operator|++
control|)
block|{
name|rel
operator|=
name|ef
operator|->
name|reltab
index|[
name|i
index|]
operator|.
name|rel
expr_stmt|;
if|if
condition|(
name|rel
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"lost a reltab!"
argument_list|)
expr_stmt|;
name|rellim
operator|=
name|rel
operator|+
name|ef
operator|->
name|reltab
index|[
name|i
index|]
operator|.
name|nrel
expr_stmt|;
name|base
operator|=
name|findbase
argument_list|(
name|ef
argument_list|,
name|ef
operator|->
name|reltab
index|[
name|i
index|]
operator|.
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"lost base for reltab"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|rellim
condition|;
name|rel
operator|++
control|)
block|{
name|symidx
operator|=
name|ELF_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|symidx
operator|>=
name|ef
operator|->
name|ddbsymcnt
condition|)
continue|continue;
name|sym
operator|=
name|ef
operator|->
name|ddbsymtab
operator|+
name|symidx
expr_stmt|;
comment|/* Local relocs are already done */
if|if
condition|(
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STB_LOCAL
condition|)
continue|continue;
if|if
condition|(
name|elf_reloc
argument_list|(
operator|&
name|ef
operator|->
name|lf
argument_list|,
name|base
argument_list|,
name|rel
argument_list|,
name|ELF_RELOC_REL
argument_list|,
name|elf_obj_lookup
argument_list|)
condition|)
block|{
name|symname
operator|=
name|symbol_name
argument_list|(
name|ef
argument_list|,
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"link_elf_obj: symbol %s undefined\n"
argument_list|,
name|symname
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
block|}
block|}
comment|/* Perform relocations with addend if there are any: */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ef
operator|->
name|nrelatab
condition|;
name|i
operator|++
control|)
block|{
name|rela
operator|=
name|ef
operator|->
name|relatab
index|[
name|i
index|]
operator|.
name|rela
expr_stmt|;
if|if
condition|(
name|rela
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"lost a relatab!"
argument_list|)
expr_stmt|;
name|relalim
operator|=
name|rela
operator|+
name|ef
operator|->
name|relatab
index|[
name|i
index|]
operator|.
name|nrela
expr_stmt|;
name|base
operator|=
name|findbase
argument_list|(
name|ef
argument_list|,
name|ef
operator|->
name|relatab
index|[
name|i
index|]
operator|.
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"lost base for relatab"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|rela
operator|<
name|relalim
condition|;
name|rela
operator|++
control|)
block|{
name|symidx
operator|=
name|ELF_R_SYM
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|symidx
operator|>=
name|ef
operator|->
name|ddbsymcnt
condition|)
continue|continue;
name|sym
operator|=
name|ef
operator|->
name|ddbsymtab
operator|+
name|symidx
expr_stmt|;
comment|/* Local relocs are already done */
if|if
condition|(
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|==
name|STB_LOCAL
condition|)
continue|continue;
if|if
condition|(
name|elf_reloc
argument_list|(
operator|&
name|ef
operator|->
name|lf
argument_list|,
name|base
argument_list|,
name|rela
argument_list|,
name|ELF_RELOC_RELA
argument_list|,
name|elf_obj_lookup
argument_list|)
condition|)
block|{
name|symname
operator|=
name|symbol_name
argument_list|(
name|ef
argument_list|,
name|rela
operator|->
name|r_info
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"link_elf_obj: symbol %s undefined\n"
argument_list|,
name|symname
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|link_elf_lookup_symbol
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|c_linker_sym_t
modifier|*
name|sym
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
operator|(
name|elf_file_t
operator|)
name|lf
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|symp
decl_stmt|;
specifier|const
name|char
modifier|*
name|strp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|symp
operator|=
name|ef
operator|->
name|ddbsymtab
init|;
name|i
operator|<
name|ef
operator|->
name|ddbsymcnt
condition|;
name|i
operator|++
operator|,
name|symp
operator|++
control|)
block|{
name|strp
operator|=
name|ef
operator|->
name|ddbstrtab
operator|+
name|symp
operator|->
name|st_name
expr_stmt|;
if|if
condition|(
name|symp
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|strp
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|sym
operator|=
operator|(
name|c_linker_sym_t
operator|)
name|symp
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|ENOENT
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|link_elf_symbol_values
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
name|c_linker_sym_t
name|sym
parameter_list|,
name|linker_symval_t
modifier|*
name|symval
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
operator|(
name|elf_file_t
operator|)
name|lf
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|es
init|=
operator|(
specifier|const
name|Elf_Sym
operator|*
operator|)
name|sym
decl_stmt|;
if|if
condition|(
name|es
operator|>=
name|ef
operator|->
name|ddbsymtab
operator|&&
name|es
operator|<
operator|(
name|ef
operator|->
name|ddbsymtab
operator|+
name|ef
operator|->
name|ddbsymcnt
operator|)
condition|)
block|{
name|symval
operator|->
name|name
operator|=
name|ef
operator|->
name|ddbstrtab
operator|+
name|es
operator|->
name|st_name
expr_stmt|;
name|symval
operator|->
name|value
operator|=
operator|(
name|caddr_t
operator|)
name|es
operator|->
name|st_value
expr_stmt|;
name|symval
operator|->
name|size
operator|=
name|es
operator|->
name|st_size
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|ENOENT
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|link_elf_search_symbol
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
name|caddr_t
name|value
parameter_list|,
name|c_linker_sym_t
modifier|*
name|sym
parameter_list|,
name|long
modifier|*
name|diffp
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
operator|(
name|elf_file_t
operator|)
name|lf
decl_stmt|;
name|u_long
name|off
init|=
operator|(
name|uintptr_t
operator|)
operator|(
name|void
operator|*
operator|)
name|value
decl_stmt|;
name|u_long
name|diff
init|=
name|off
decl_stmt|;
name|u_long
name|st_value
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|es
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|best
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|es
operator|=
name|ef
operator|->
name|ddbsymtab
init|;
name|i
operator|<
name|ef
operator|->
name|ddbsymcnt
condition|;
name|i
operator|++
operator|,
name|es
operator|++
control|)
block|{
if|if
condition|(
name|es
operator|->
name|st_name
operator|==
literal|0
condition|)
continue|continue;
name|st_value
operator|=
name|es
operator|->
name|st_value
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|st_value
condition|)
block|{
if|if
condition|(
name|off
operator|-
name|st_value
operator|<
name|diff
condition|)
block|{
name|diff
operator|=
name|off
operator|-
name|st_value
expr_stmt|;
name|best
operator|=
name|es
expr_stmt|;
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|off
operator|-
name|st_value
operator|==
name|diff
condition|)
block|{
name|best
operator|=
name|es
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|best
operator|==
literal|0
condition|)
operator|*
name|diffp
operator|=
name|off
expr_stmt|;
else|else
operator|*
name|diffp
operator|=
name|diff
expr_stmt|;
operator|*
name|sym
operator|=
operator|(
name|c_linker_sym_t
operator|)
name|best
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Look up a linker set on an ELF system.  */
end_comment

begin_function
specifier|static
name|int
name|link_elf_lookup_set
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
modifier|*
modifier|*
name|startp
parameter_list|,
name|void
modifier|*
modifier|*
modifier|*
name|stopp
parameter_list|,
name|int
modifier|*
name|countp
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
operator|(
name|elf_file_t
operator|)
name|lf
decl_stmt|;
name|void
modifier|*
modifier|*
name|start
decl_stmt|,
modifier|*
modifier|*
name|stop
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
comment|/* Relative to section number */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ef
operator|->
name|nprogtab
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|ef
operator|->
name|progtab
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"set_"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|strcmp
argument_list|(
name|ef
operator|->
name|progtab
index|[
name|i
index|]
operator|.
name|name
operator|+
literal|4
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|start
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
name|ef
operator|->
name|progtab
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
name|stop
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ef
operator|->
name|progtab
index|[
name|i
index|]
operator|.
name|addr
operator|+
name|ef
operator|->
name|progtab
index|[
name|i
index|]
operator|.
name|size
operator|)
expr_stmt|;
name|count
operator|=
name|stop
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|startp
condition|)
operator|*
name|startp
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|stopp
condition|)
operator|*
name|stopp
operator|=
name|stop
expr_stmt|;
if|if
condition|(
name|countp
condition|)
operator|*
name|countp
operator|=
name|count
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|link_elf_each_function_name
parameter_list|(
name|linker_file_t
name|file
parameter_list|,
name|int
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|opaque
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
operator|(
name|elf_file_t
operator|)
name|file
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|symp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
comment|/* Exhaustive search */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|symp
operator|=
name|ef
operator|->
name|ddbsymtab
init|;
name|i
operator|<
name|ef
operator|->
name|ddbsymcnt
condition|;
name|i
operator|++
operator|,
name|symp
operator|++
control|)
block|{
if|if
condition|(
name|symp
operator|->
name|st_value
operator|!=
literal|0
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|symp
operator|->
name|st_info
argument_list|)
operator|==
name|STT_FUNC
condition|)
block|{
name|error
operator|=
name|callback
argument_list|(
name|ef
operator|->
name|ddbstrtab
operator|+
name|symp
operator|->
name|st_name
argument_list|,
name|opaque
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|link_elf_each_function_nameval
parameter_list|(
name|linker_file_t
name|file
parameter_list|,
name|linker_function_nameval_callback_t
name|callback
parameter_list|,
name|void
modifier|*
name|opaque
parameter_list|)
block|{
name|linker_symval_t
name|symval
decl_stmt|;
name|elf_file_t
name|ef
init|=
operator|(
name|elf_file_t
operator|)
name|file
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|symp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
comment|/* Exhaustive search */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|symp
operator|=
name|ef
operator|->
name|ddbsymtab
init|;
name|i
operator|<
name|ef
operator|->
name|ddbsymcnt
condition|;
name|i
operator|++
operator|,
name|symp
operator|++
control|)
block|{
if|if
condition|(
name|symp
operator|->
name|st_value
operator|!=
literal|0
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|symp
operator|->
name|st_info
argument_list|)
operator|==
name|STT_FUNC
condition|)
block|{
name|error
operator|=
name|link_elf_symbol_values
argument_list|(
name|file
argument_list|,
operator|(
name|c_linker_sym_t
operator|)
name|symp
argument_list|,
operator|&
name|symval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|callback
argument_list|(
name|file
argument_list|,
name|i
argument_list|,
operator|&
name|symval
argument_list|,
name|opaque
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Symbol lookup function that can be used when the symbol index is known (ie  * in relocations). It uses the symbol index instead of doing a fully fledged  * hash table based lookup when such is valid. For example for local symbols.  * This is not only more efficient, it's also more correct. It's not always  * the case that the symbol can be found through the hash table.  */
end_comment

begin_function
specifier|static
name|Elf_Addr
name|elf_obj_lookup
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
name|Elf_Size
name|symidx
parameter_list|,
name|int
name|deps
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
operator|(
name|elf_file_t
operator|)
name|lf
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|symbol
decl_stmt|;
name|Elf_Addr
name|ret
decl_stmt|;
comment|/* Don't even try to lookup the symbol if the index is bogus. */
if|if
condition|(
name|symidx
operator|>=
name|ef
operator|->
name|ddbsymcnt
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sym
operator|=
name|ef
operator|->
name|ddbsymtab
operator|+
name|symidx
expr_stmt|;
comment|/* Quick answer if there is a definition included. */
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
condition|)
return|return
operator|(
name|sym
operator|->
name|st_value
operator|)
return|;
comment|/* If we get here, then it is undefined and needs a lookup. */
switch|switch
condition|(
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
condition|)
block|{
case|case
name|STB_LOCAL
case|:
comment|/* Local, but undefined? huh? */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|STB_GLOBAL
case|:
comment|/* Relative to Data or Function name */
name|symbol
operator|=
name|ef
operator|->
name|ddbstrtab
operator|+
name|sym
operator|->
name|st_name
expr_stmt|;
comment|/* Force a lookup failure if the symbol name is bogus. */
if|if
condition|(
operator|*
name|symbol
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ret
operator|=
operator|(
operator|(
name|Elf_Addr
operator|)
name|linker_file_lookup_symbol
argument_list|(
name|lf
argument_list|,
name|symbol
argument_list|,
name|deps
argument_list|)
operator|)
expr_stmt|;
return|return
name|ret
return|;
case|case
name|STB_WEAK
case|:
name|printf
argument_list|(
literal|"link_elf_obj: Weak symbols not supported\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|link_elf_fix_link_set
parameter_list|(
name|elf_file_t
name|ef
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|startn
index|[]
init|=
literal|"__start_"
decl_stmt|;
specifier|static
specifier|const
name|char
name|stopn
index|[]
init|=
literal|"__stop_"
decl_stmt|;
name|Elf_Sym
modifier|*
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
name|sym_name
decl_stmt|,
modifier|*
name|linkset_name
decl_stmt|;
name|Elf_Addr
name|startp
decl_stmt|,
name|stopp
decl_stmt|;
name|Elf_Size
name|symidx
decl_stmt|;
name|int
name|start
decl_stmt|,
name|i
decl_stmt|;
name|startp
operator|=
name|stopp
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|symidx
operator|=
literal|1
comment|/* zero entry is special */
init|;
name|symidx
operator|<
name|ef
operator|->
name|ddbsymcnt
condition|;
name|symidx
operator|++
control|)
block|{
name|sym
operator|=
name|ef
operator|->
name|ddbsymtab
operator|+
name|symidx
expr_stmt|;
if|if
condition|(
name|sym
operator|->
name|st_shndx
operator|!=
name|SHN_UNDEF
condition|)
continue|continue;
name|sym_name
operator|=
name|ef
operator|->
name|ddbstrtab
operator|+
name|sym
operator|->
name|st_name
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|sym_name
argument_list|,
name|startn
argument_list|,
sizeof|sizeof
argument_list|(
name|startn
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|start
operator|=
literal|1
expr_stmt|;
name|linkset_name
operator|=
name|sym_name
operator|+
sizeof|sizeof
argument_list|(
name|startn
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|sym_name
argument_list|,
name|stopn
argument_list|,
sizeof|sizeof
argument_list|(
name|stopn
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|start
operator|=
literal|0
expr_stmt|;
name|linkset_name
operator|=
name|sym_name
operator|+
sizeof|sizeof
argument_list|(
name|stopn
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ef
operator|->
name|nprogtab
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ef
operator|->
name|progtab
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|linkset_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|startp
operator|=
operator|(
name|Elf_Addr
operator|)
name|ef
operator|->
name|progtab
index|[
name|i
index|]
operator|.
name|addr
expr_stmt|;
name|stopp
operator|=
call|(
name|Elf_Addr
call|)
argument_list|(
name|startp
operator|+
name|ef
operator|->
name|progtab
index|[
name|i
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|ef
operator|->
name|nprogtab
condition|)
continue|continue;
name|sym
operator|->
name|st_value
operator|=
name|start
condition|?
name|startp
else|:
name|stopp
expr_stmt|;
name|sym
operator|->
name|st_shndx
operator|=
name|i
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|link_elf_reloc_local
parameter_list|(
name|linker_file_t
name|lf
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
operator|(
name|elf_file_t
operator|)
name|lf
decl_stmt|;
specifier|const
name|Elf_Rel
modifier|*
name|rellim
decl_stmt|;
specifier|const
name|Elf_Rel
modifier|*
name|rel
decl_stmt|;
specifier|const
name|Elf_Rela
modifier|*
name|relalim
decl_stmt|;
specifier|const
name|Elf_Rela
modifier|*
name|rela
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|sym
decl_stmt|;
name|Elf_Addr
name|base
decl_stmt|;
name|int
name|i
decl_stmt|;
name|Elf_Size
name|symidx
decl_stmt|;
name|link_elf_fix_link_set
argument_list|(
name|ef
argument_list|)
expr_stmt|;
comment|/* Perform relocations without addend if there are any: */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ef
operator|->
name|nreltab
condition|;
name|i
operator|++
control|)
block|{
name|rel
operator|=
name|ef
operator|->
name|reltab
index|[
name|i
index|]
operator|.
name|rel
expr_stmt|;
if|if
condition|(
name|rel
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"lost a reltab!"
argument_list|)
expr_stmt|;
name|rellim
operator|=
name|rel
operator|+
name|ef
operator|->
name|reltab
index|[
name|i
index|]
operator|.
name|nrel
expr_stmt|;
name|base
operator|=
name|findbase
argument_list|(
name|ef
argument_list|,
name|ef
operator|->
name|reltab
index|[
name|i
index|]
operator|.
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"lost base for reltab"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|rel
operator|<
name|rellim
condition|;
name|rel
operator|++
control|)
block|{
name|symidx
operator|=
name|ELF_R_SYM
argument_list|(
name|rel
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|symidx
operator|>=
name|ef
operator|->
name|ddbsymcnt
condition|)
continue|continue;
name|sym
operator|=
name|ef
operator|->
name|ddbsymtab
operator|+
name|symidx
expr_stmt|;
comment|/* Only do local relocs */
if|if
condition|(
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STB_LOCAL
condition|)
continue|continue;
name|elf_reloc_local
argument_list|(
name|lf
argument_list|,
name|base
argument_list|,
name|rel
argument_list|,
name|ELF_RELOC_REL
argument_list|,
name|elf_obj_lookup
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Perform relocations with addend if there are any: */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ef
operator|->
name|nrelatab
condition|;
name|i
operator|++
control|)
block|{
name|rela
operator|=
name|ef
operator|->
name|relatab
index|[
name|i
index|]
operator|.
name|rela
expr_stmt|;
if|if
condition|(
name|rela
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"lost a relatab!"
argument_list|)
expr_stmt|;
name|relalim
operator|=
name|rela
operator|+
name|ef
operator|->
name|relatab
index|[
name|i
index|]
operator|.
name|nrela
expr_stmt|;
name|base
operator|=
name|findbase
argument_list|(
name|ef
argument_list|,
name|ef
operator|->
name|relatab
index|[
name|i
index|]
operator|.
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"lost base for relatab"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|rela
operator|<
name|relalim
condition|;
name|rela
operator|++
control|)
block|{
name|symidx
operator|=
name|ELF_R_SYM
argument_list|(
name|rela
operator|->
name|r_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|symidx
operator|>=
name|ef
operator|->
name|ddbsymcnt
condition|)
continue|continue;
name|sym
operator|=
name|ef
operator|->
name|ddbsymtab
operator|+
name|symidx
expr_stmt|;
comment|/* Only do local relocs */
if|if
condition|(
name|ELF_ST_BIND
argument_list|(
name|sym
operator|->
name|st_info
argument_list|)
operator|!=
name|STB_LOCAL
condition|)
continue|continue;
name|elf_reloc_local
argument_list|(
name|lf
argument_list|,
name|base
argument_list|,
name|rela
argument_list|,
name|ELF_RELOC_RELA
argument_list|,
name|elf_obj_lookup
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|long
name|link_elf_symtab_get
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
specifier|const
name|Elf_Sym
modifier|*
modifier|*
name|symtab
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
operator|(
name|elf_file_t
operator|)
name|lf
decl_stmt|;
operator|*
name|symtab
operator|=
name|ef
operator|->
name|ddbsymtab
expr_stmt|;
if|if
condition|(
operator|*
name|symtab
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|ef
operator|->
name|ddbsymcnt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|link_elf_strtab_get
parameter_list|(
name|linker_file_t
name|lf
parameter_list|,
name|caddr_t
modifier|*
name|strtab
parameter_list|)
block|{
name|elf_file_t
name|ef
init|=
operator|(
name|elf_file_t
operator|)
name|lf
decl_stmt|;
operator|*
name|strtab
operator|=
name|ef
operator|->
name|ddbstrtab
expr_stmt|;
if|if
condition|(
operator|*
name|strtab
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|ef
operator|->
name|ddbstrcnt
operator|)
return|;
block|}
end_function

end_unit

