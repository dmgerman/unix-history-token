begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008,  Jeffrey Roberson<jeff@freebsd.org>  * All rights reserved.  *   * Copyright (c) 2008 Nokia Corporation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

begin_comment
comment|/*  * cpusets provide a mechanism for creating and manipulating sets of  * processors for the purpose of constraining the scheduling of threads to  * specific processors.  *  * Each process belongs to an identified set, by default this is set 1.  Each  * thread may further restrict the cpus it may run on to a subset of this  * named set.  This creates an anonymous set which other threads and processes  * may not join by number.  *  * The named set is referred to herein as the 'base' set to avoid ambiguity.  * This set is usually a child of a 'root' set while the anonymous set may  * simply be referred to as a mask.  In the syscall api these are referred to  * as the ROOT, CPUSET, and MASK levels where CPUSET is called 'base' here.  *  * Threads inherit their set from their creator whether it be anonymous or  * not.  This means that anonymous sets are immutable because they may be  * shared.  To modify an anonymous set a new set is created with the desired  * mask and the same parent as the existing anonymous set.  This gives the  * illusion of each thread having a private mask.  *  * Via the syscall apis a user may ask to retrieve or modify the root, base,  * or mask that is discovered via a pid, tid, or setid.  Modifying a set  * modifies all numbered and anonymous child sets to comply with the new mask.  * Modifying a pid or tid's mask applies only to that tid but must still  * exist within the assigned parent set.  *  * A thread may not be assigned to a group separate from other threads in  * the process.  This is to remove ambiguity when the setid is queried with  * a pid argument.  There is no other technical limitation.  *  * This somewhat complex arrangement is intended to make it easy for  * applications to query available processors and bind their threads to  * specific processors while also allowing administrators to dynamically  * reprovision by changing sets which apply to groups of processes.  *  * A simple application should not concern itself with sets at all and  * rather apply masks to its own threads via CPU_WHICH_TID and a -1 id  * meaning 'curthread'.  It may query available cpus for that tid with a  * getaffinity call using (CPU_LEVEL_CPUSET, CPU_WHICH_PID, -1, ...).  */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|cpuset_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|cpuset_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|setlist
name|cpuset_ids
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|unrhdr
modifier|*
name|cpuset_unr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cpuset
modifier|*
name|cpuset_zero
decl_stmt|,
modifier|*
name|cpuset_default
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the size of cpuset_t at the kernel level */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|cpusetsize
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_CAPRD
argument_list|,
name|SYSCTL_NULL_INT_PTR
argument_list|,
sizeof|sizeof
argument_list|(
name|cpuset_t
argument_list|)
argument_list|,
literal|"sizeof(cpuset_t)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|cpuset_t
modifier|*
name|cpuset_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|cpuset_t
name|cpuset_domain
index|[
name|MAXMEMDOM
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Acquire a reference to a cpuset, all pointers must be tracked with refs.  */
end_comment

begin_function
name|struct
name|cpuset
modifier|*
name|cpuset_ref
parameter_list|(
name|struct
name|cpuset
modifier|*
name|set
parameter_list|)
block|{
name|refcount_acquire
argument_list|(
operator|&
name|set
operator|->
name|cs_ref
argument_list|)
expr_stmt|;
return|return
operator|(
name|set
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Walks up the tree from 'set' to find the root.  Returns the root  * referenced.  */
end_comment

begin_function
specifier|static
name|struct
name|cpuset
modifier|*
name|cpuset_refroot
parameter_list|(
name|struct
name|cpuset
modifier|*
name|set
parameter_list|)
block|{
for|for
control|(
init|;
name|set
operator|->
name|cs_parent
operator|!=
name|NULL
condition|;
name|set
operator|=
name|set
operator|->
name|cs_parent
control|)
if|if
condition|(
name|set
operator|->
name|cs_flags
operator|&
name|CPU_SET_ROOT
condition|)
break|break;
name|cpuset_ref
argument_list|(
name|set
argument_list|)
expr_stmt|;
return|return
operator|(
name|set
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the first non-anonymous set starting from 'set'.  Returns this set  * referenced.  May return the passed in set with an extra ref if it is  * not anonymous.   */
end_comment

begin_function
specifier|static
name|struct
name|cpuset
modifier|*
name|cpuset_refbase
parameter_list|(
name|struct
name|cpuset
modifier|*
name|set
parameter_list|)
block|{
if|if
condition|(
name|set
operator|->
name|cs_id
operator|==
name|CPUSET_INVALID
condition|)
name|set
operator|=
name|set
operator|->
name|cs_parent
expr_stmt|;
name|cpuset_ref
argument_list|(
name|set
argument_list|)
expr_stmt|;
return|return
operator|(
name|set
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a reference in a context where it is safe to allocate.  */
end_comment

begin_function
name|void
name|cpuset_rel
parameter_list|(
name|struct
name|cpuset
modifier|*
name|set
parameter_list|)
block|{
name|cpusetid_t
name|id
decl_stmt|;
if|if
condition|(
name|refcount_release
argument_list|(
operator|&
name|set
operator|->
name|cs_ref
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|mtx_lock_spin
argument_list|(
operator|&
name|cpuset_lock
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|set
argument_list|,
name|cs_siblings
argument_list|)
expr_stmt|;
name|id
operator|=
name|set
operator|->
name|cs_id
expr_stmt|;
if|if
condition|(
name|id
operator|!=
name|CPUSET_INVALID
condition|)
name|LIST_REMOVE
argument_list|(
name|set
argument_list|,
name|cs_link
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|cpuset_lock
argument_list|)
expr_stmt|;
name|cpuset_rel
argument_list|(
name|set
operator|->
name|cs_parent
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|cpuset_zone
argument_list|,
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
name|CPUSET_INVALID
condition|)
name|free_unr
argument_list|(
name|cpuset_unr
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Deferred release must be used when in a context that is not safe to  * allocate/free.  This places any unreferenced sets on the list 'head'.  */
end_comment

begin_function
specifier|static
name|void
name|cpuset_rel_defer
parameter_list|(
name|struct
name|setlist
modifier|*
name|head
parameter_list|,
name|struct
name|cpuset
modifier|*
name|set
parameter_list|)
block|{
if|if
condition|(
name|refcount_release
argument_list|(
operator|&
name|set
operator|->
name|cs_ref
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|mtx_lock_spin
argument_list|(
operator|&
name|cpuset_lock
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|set
argument_list|,
name|cs_siblings
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|->
name|cs_id
operator|!=
name|CPUSET_INVALID
condition|)
name|LIST_REMOVE
argument_list|(
name|set
argument_list|,
name|cs_link
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|set
argument_list|,
name|cs_link
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|cpuset_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete a deferred release.  Removes the set from the list provided to  * cpuset_rel_defer.  */
end_comment

begin_function
specifier|static
name|void
name|cpuset_rel_complete
parameter_list|(
name|struct
name|cpuset
modifier|*
name|set
parameter_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|set
argument_list|,
name|cs_link
argument_list|)
expr_stmt|;
name|cpuset_rel
argument_list|(
name|set
operator|->
name|cs_parent
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|cpuset_zone
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find a set based on an id.  Returns it with a ref.  */
end_comment

begin_function
specifier|static
name|struct
name|cpuset
modifier|*
name|cpuset_lookup
parameter_list|(
name|cpusetid_t
name|setid
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|cpuset
modifier|*
name|set
decl_stmt|;
if|if
condition|(
name|setid
operator|==
name|CPUSET_INVALID
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|mtx_lock_spin
argument_list|(
operator|&
name|cpuset_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|set
argument_list|,
argument|&cpuset_ids
argument_list|,
argument|cs_link
argument_list|)
if|if
condition|(
name|set
operator|->
name|cs_id
operator|==
name|setid
condition|)
break|break;
if|if
condition|(
name|set
condition|)
name|cpuset_ref
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|cpuset_lock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|td
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[%s:%d] td is NULL"
operator|,
name|__func__
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|!=
name|NULL
operator|&&
name|jailed
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
condition|)
block|{
name|struct
name|cpuset
modifier|*
name|jset
decl_stmt|,
modifier|*
name|tset
decl_stmt|;
name|jset
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_prison
operator|->
name|pr_cpuset
expr_stmt|;
for|for
control|(
name|tset
operator|=
name|set
init|;
name|tset
operator|!=
name|NULL
condition|;
name|tset
operator|=
name|tset
operator|->
name|cs_parent
control|)
if|if
condition|(
name|tset
operator|==
name|jset
condition|)
break|break;
if|if
condition|(
name|tset
operator|==
name|NULL
condition|)
block|{
name|cpuset_rel
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|set
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|set
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a set in the space provided in 'set' with the provided parameters.  * The set is returned with a single ref.  May return EDEADLK if the set  * will have no valid cpu based on restrictions from the parent.  */
end_comment

begin_function
specifier|static
name|int
name|_cpuset_create
parameter_list|(
name|struct
name|cpuset
modifier|*
name|set
parameter_list|,
name|struct
name|cpuset
modifier|*
name|parent
parameter_list|,
specifier|const
name|cpuset_t
modifier|*
name|mask
parameter_list|,
name|cpusetid_t
name|id
parameter_list|)
block|{
if|if
condition|(
operator|!
name|CPU_OVERLAP
argument_list|(
operator|&
name|parent
operator|->
name|cs_mask
argument_list|,
name|mask
argument_list|)
condition|)
return|return
operator|(
name|EDEADLK
operator|)
return|;
name|CPU_COPY
argument_list|(
name|mask
argument_list|,
operator|&
name|set
operator|->
name|cs_mask
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|set
operator|->
name|cs_children
argument_list|)
expr_stmt|;
name|refcount_init
argument_list|(
operator|&
name|set
operator|->
name|cs_ref
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set
operator|->
name|cs_flags
operator|=
literal|0
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|cpuset_lock
argument_list|)
expr_stmt|;
name|CPU_AND
argument_list|(
operator|&
name|set
operator|->
name|cs_mask
argument_list|,
operator|&
name|parent
operator|->
name|cs_mask
argument_list|)
expr_stmt|;
name|set
operator|->
name|cs_id
operator|=
name|id
expr_stmt|;
name|set
operator|->
name|cs_parent
operator|=
name|cpuset_ref
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|parent
operator|->
name|cs_children
argument_list|,
name|set
argument_list|,
name|cs_siblings
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|->
name|cs_id
operator|!=
name|CPUSET_INVALID
condition|)
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|cpuset_ids
argument_list|,
name|set
argument_list|,
name|cs_link
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|cpuset_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new non-anonymous set with the requested parent and mask.  May  * return failures if the mask is invalid or a new number can not be  * allocated.  */
end_comment

begin_function
specifier|static
name|int
name|cpuset_create
parameter_list|(
name|struct
name|cpuset
modifier|*
modifier|*
name|setp
parameter_list|,
name|struct
name|cpuset
modifier|*
name|parent
parameter_list|,
specifier|const
name|cpuset_t
modifier|*
name|mask
parameter_list|)
block|{
name|struct
name|cpuset
modifier|*
name|set
decl_stmt|;
name|cpusetid_t
name|id
decl_stmt|;
name|int
name|error
decl_stmt|;
name|id
operator|=
name|alloc_unr
argument_list|(
name|cpuset_unr
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|ENFILE
operator|)
return|;
operator|*
name|setp
operator|=
name|set
operator|=
name|uma_zalloc
argument_list|(
name|cpuset_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|_cpuset_create
argument_list|(
name|set
argument_list|,
name|parent
argument_list|,
name|mask
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|free_unr
argument_list|(
name|cpuset_unr
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|cpuset_zone
argument_list|,
name|set
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Recursively check for errors that would occur from applying mask to  * the tree of sets starting at 'set'.  Checks for sets that would become  * empty as well as RDONLY flags.  */
end_comment

begin_function
specifier|static
name|int
name|cpuset_testupdate
parameter_list|(
name|struct
name|cpuset
modifier|*
name|set
parameter_list|,
name|cpuset_t
modifier|*
name|mask
parameter_list|,
name|int
name|check_mask
parameter_list|)
block|{
name|struct
name|cpuset
modifier|*
name|nset
decl_stmt|;
name|cpuset_t
name|newmask
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|cpuset_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|->
name|cs_flags
operator|&
name|CPU_SET_RDONLY
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|check_mask
condition|)
block|{
if|if
condition|(
operator|!
name|CPU_OVERLAP
argument_list|(
operator|&
name|set
operator|->
name|cs_mask
argument_list|,
name|mask
argument_list|)
condition|)
return|return
operator|(
name|EDEADLK
operator|)
return|;
name|CPU_COPY
argument_list|(
operator|&
name|set
operator|->
name|cs_mask
argument_list|,
operator|&
name|newmask
argument_list|)
expr_stmt|;
name|CPU_AND
argument_list|(
operator|&
name|newmask
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
name|CPU_COPY
argument_list|(
name|mask
argument_list|,
operator|&
name|newmask
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|nset
argument_list|,
argument|&set->cs_children
argument_list|,
argument|cs_siblings
argument_list|)
if|if
condition|(
operator|(
name|error
operator|=
name|cpuset_testupdate
argument_list|(
name|nset
argument_list|,
operator|&
name|newmask
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Applies the mask 'mask' without checking for empty sets or permissions.  */
end_comment

begin_function
specifier|static
name|void
name|cpuset_update
parameter_list|(
name|struct
name|cpuset
modifier|*
name|set
parameter_list|,
name|cpuset_t
modifier|*
name|mask
parameter_list|)
block|{
name|struct
name|cpuset
modifier|*
name|nset
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|cpuset_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|CPU_AND
argument_list|(
operator|&
name|set
operator|->
name|cs_mask
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|nset
argument_list|,
argument|&set->cs_children
argument_list|,
argument|cs_siblings
argument_list|)
name|cpuset_update
argument_list|(
name|nset
argument_list|,
operator|&
name|set
operator|->
name|cs_mask
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Modify the set 'set' to use a copy of the mask provided.  Apply this new  * mask to restrict all children in the tree.  Checks for validity before  * applying the changes.  */
end_comment

begin_function
specifier|static
name|int
name|cpuset_modify
parameter_list|(
name|struct
name|cpuset
modifier|*
name|set
parameter_list|,
name|cpuset_t
modifier|*
name|mask
parameter_list|)
block|{
name|struct
name|cpuset
modifier|*
name|root
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|priv_check
argument_list|(
name|curthread
argument_list|,
name|PRIV_SCHED_CPUSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * In case we are called from within the jail 	 * we do not allow modifying the dedicated root 	 * cpuset of the jail but may still allow to 	 * change child sets. 	 */
if|if
condition|(
name|jailed
argument_list|(
name|curthread
operator|->
name|td_ucred
argument_list|)
operator|&&
name|set
operator|->
name|cs_flags
operator|&
name|CPU_SET_ROOT
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* 	 * Verify that we have access to this set of 	 * cpus. 	 */
name|root
operator|=
name|set
operator|->
name|cs_parent
expr_stmt|;
if|if
condition|(
name|root
operator|&&
operator|!
name|CPU_SUBSET
argument_list|(
operator|&
name|root
operator|->
name|cs_mask
argument_list|,
name|mask
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mtx_lock_spin
argument_list|(
operator|&
name|cpuset_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|cpuset_testupdate
argument_list|(
name|set
argument_list|,
name|mask
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|CPU_COPY
argument_list|(
name|mask
argument_list|,
operator|&
name|set
operator|->
name|cs_mask
argument_list|)
expr_stmt|;
name|cpuset_update
argument_list|(
name|set
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|out
label|:
name|mtx_unlock_spin
argument_list|(
operator|&
name|cpuset_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Resolve the 'which' parameter of several cpuset apis.  *  * For WHICH_PID and WHICH_TID return a locked proc and valid proc/tid.  Also  * checks for permission via p_cansched().  *  * For WHICH_SET returns a valid set with a new reference.  *  * -1 may be supplied for any argument to mean the current proc/thread or  * the base set of the current thread.  May fail with ESRCH/EPERM.  */
end_comment

begin_function
name|int
name|cpuset_which
parameter_list|(
name|cpuwhich_t
name|which
parameter_list|,
name|id_t
name|id
parameter_list|,
name|struct
name|proc
modifier|*
modifier|*
name|pp
parameter_list|,
name|struct
name|thread
modifier|*
modifier|*
name|tdp
parameter_list|,
name|struct
name|cpuset
modifier|*
modifier|*
name|setp
parameter_list|)
block|{
name|struct
name|cpuset
modifier|*
name|set
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|pp
operator|=
name|p
operator|=
name|NULL
expr_stmt|;
operator|*
name|tdp
operator|=
name|td
operator|=
name|NULL
expr_stmt|;
operator|*
name|setp
operator|=
name|set
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|CPU_WHICH_PID
case|:
if|if
condition|(
name|id
operator|==
operator|-
literal|1
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
name|p
operator|=
name|curproc
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|p
operator|=
name|pfind
argument_list|(
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
break|break;
case|case
name|CPU_WHICH_TID
case|:
if|if
condition|(
name|id
operator|==
operator|-
literal|1
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|curproc
argument_list|)
expr_stmt|;
name|p
operator|=
name|curproc
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
break|break;
block|}
name|td
operator|=
name|tdfind
argument_list|(
name|id
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
break|break;
case|case
name|CPU_WHICH_CPUSET
case|:
if|if
condition|(
name|id
operator|==
operator|-
literal|1
condition|)
block|{
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|set
operator|=
name|cpuset_refbase
argument_list|(
name|curthread
operator|->
name|td_cpuset
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
else|else
name|set
operator|=
name|cpuset_lookup
argument_list|(
name|id
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
operator|*
name|setp
operator|=
name|set
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ESRCH
operator|)
return|;
case|case
name|CPU_WHICH_JAIL
case|:
block|{
comment|/* Find `set' for prison with given id. */
name|struct
name|prison
modifier|*
name|pr
decl_stmt|;
name|sx_slock
argument_list|(
operator|&
name|allprison_lock
argument_list|)
expr_stmt|;
name|pr
operator|=
name|prison_find_child
argument_list|(
name|curthread
operator|->
name|td_ucred
operator|->
name|cr_prison
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|allprison_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
name|cpuset_ref
argument_list|(
name|pr
operator|->
name|pr_cpuset
argument_list|)
expr_stmt|;
operator|*
name|setp
operator|=
name|pr
operator|->
name|pr_cpuset
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pr
operator|->
name|pr_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|CPU_WHICH_IRQ
case|:
case|case
name|CPU_WHICH_DOMAIN
case|:
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|p_cansched
argument_list|(
name|curthread
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
name|td
operator|=
name|FIRST_THREAD_IN_PROC
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
operator|*
name|tdp
operator|=
name|td
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create an anonymous set with the provided mask in the space provided by  * 'fset'.  If the passed in set is anonymous we use its parent otherwise  * the new set is a child of 'set'.  */
end_comment

begin_function
specifier|static
name|int
name|cpuset_shadow
parameter_list|(
name|struct
name|cpuset
modifier|*
name|set
parameter_list|,
name|struct
name|cpuset
modifier|*
name|fset
parameter_list|,
specifier|const
name|cpuset_t
modifier|*
name|mask
parameter_list|)
block|{
name|struct
name|cpuset
modifier|*
name|parent
decl_stmt|;
if|if
condition|(
name|set
operator|->
name|cs_id
operator|==
name|CPUSET_INVALID
condition|)
name|parent
operator|=
name|set
operator|->
name|cs_parent
expr_stmt|;
else|else
name|parent
operator|=
name|set
expr_stmt|;
if|if
condition|(
operator|!
name|CPU_SUBSET
argument_list|(
operator|&
name|parent
operator|->
name|cs_mask
argument_list|,
name|mask
argument_list|)
condition|)
return|return
operator|(
name|EDEADLK
operator|)
return|;
return|return
operator|(
name|_cpuset_create
argument_list|(
name|fset
argument_list|,
name|parent
argument_list|,
name|mask
argument_list|,
name|CPUSET_INVALID
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle two cases for replacing the base set or mask of an entire process.  *  * 1) Set is non-null and mask is null.  This reparents all anonymous sets  *    to the provided set and replaces all non-anonymous td_cpusets with the  *    provided set.  * 2) Mask is non-null and set is null.  This replaces or creates anonymous  *    sets for every thread with the existing base as a parent.  *  * This is overly complicated because we can't allocate while holding a   * spinlock and spinlocks must be held while changing and examining thread  * state.  */
end_comment

begin_function
specifier|static
name|int
name|cpuset_setproc
parameter_list|(
name|pid_t
name|pid
parameter_list|,
name|struct
name|cpuset
modifier|*
name|set
parameter_list|,
name|cpuset_t
modifier|*
name|mask
parameter_list|)
block|{
name|struct
name|setlist
name|freelist
decl_stmt|;
name|struct
name|setlist
name|droplist
decl_stmt|;
name|struct
name|cpuset
modifier|*
name|tdset
decl_stmt|;
name|struct
name|cpuset
modifier|*
name|nset
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|threads
decl_stmt|;
name|int
name|nfree
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * The algorithm requires two passes due to locking considerations. 	 *  	 * 1) Lookup the process and acquire the locks in the required order. 	 * 2) If enough cpusets have not been allocated release the locks and 	 *    allocate them.  Loop. 	 */
name|LIST_INIT
argument_list|(
operator|&
name|freelist
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|droplist
argument_list|)
expr_stmt|;
name|nfree
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
name|cpuset_which
argument_list|(
name|CPU_WHICH_PID
argument_list|,
name|pid
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|td
argument_list|,
operator|&
name|nset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|nfree
operator|>=
name|p
operator|->
name|p_numthreads
condition|)
break|break;
name|threads
operator|=
name|p
operator|->
name|p_numthreads
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|nfree
operator|<
name|threads
condition|;
name|nfree
operator|++
control|)
block|{
name|nset
operator|=
name|uma_zalloc
argument_list|(
name|cpuset_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|freelist
argument_list|,
name|nset
argument_list|,
name|cs_link
argument_list|)
expr_stmt|;
block|}
block|}
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Now that the appropriate locks are held and we have enough cpusets, 	 * make sure the operation will succeed before applying changes.  The 	 * proc lock prevents td_cpuset from changing between calls. 	 */
name|error
operator|=
literal|0
expr_stmt|;
name|FOREACH_THREAD_IN_PROC
argument_list|(
argument|p
argument_list|,
argument|td
argument_list|)
block|{
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|tdset
operator|=
name|td
operator|->
name|td_cpuset
expr_stmt|;
comment|/* 		 * Verify that a new mask doesn't specify cpus outside of 		 * the set the thread is a member of. 		 */
if|if
condition|(
name|mask
condition|)
block|{
if|if
condition|(
name|tdset
operator|->
name|cs_id
operator|==
name|CPUSET_INVALID
condition|)
name|tdset
operator|=
name|tdset
operator|->
name|cs_parent
expr_stmt|;
if|if
condition|(
operator|!
name|CPU_SUBSET
argument_list|(
operator|&
name|tdset
operator|->
name|cs_mask
argument_list|,
name|mask
argument_list|)
condition|)
name|error
operator|=
name|EDEADLK
expr_stmt|;
comment|/* 		 * Verify that a new set won't leave an existing thread 		 * mask without a cpu to run on.  It can, however, restrict 		 * the set. 		 */
block|}
elseif|else
if|if
condition|(
name|tdset
operator|->
name|cs_id
operator|==
name|CPUSET_INVALID
condition|)
block|{
if|if
condition|(
operator|!
name|CPU_OVERLAP
argument_list|(
operator|&
name|set
operator|->
name|cs_mask
argument_list|,
operator|&
name|tdset
operator|->
name|cs_mask
argument_list|)
condition|)
name|error
operator|=
name|EDEADLK
expr_stmt|;
block|}
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|unlock_out
goto|;
block|}
comment|/* 	 * Replace each thread's cpuset while using deferred release.  We 	 * must do this because the thread lock must be held while operating 	 * on the thread and this limits the type of operations allowed. 	 */
name|FOREACH_THREAD_IN_PROC
argument_list|(
argument|p
argument_list|,
argument|td
argument_list|)
block|{
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* 		 * If we presently have an anonymous set or are applying a 		 * mask we must create an anonymous shadow set.  That is 		 * either parented to our existing base or the supplied set. 		 * 		 * If we have a base set with no anonymous shadow we simply 		 * replace it outright. 		 */
name|tdset
operator|=
name|td
operator|->
name|td_cpuset
expr_stmt|;
if|if
condition|(
name|tdset
operator|->
name|cs_id
operator|==
name|CPUSET_INVALID
operator|||
name|mask
condition|)
block|{
name|nset
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|freelist
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|nset
argument_list|,
name|cs_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
condition|)
name|error
operator|=
name|cpuset_shadow
argument_list|(
name|tdset
argument_list|,
name|nset
argument_list|,
name|mask
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|_cpuset_create
argument_list|(
name|nset
argument_list|,
name|set
argument_list|,
operator|&
name|tdset
operator|->
name|cs_mask
argument_list|,
name|CPUSET_INVALID
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|freelist
argument_list|,
name|nset
argument_list|,
name|cs_link
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|nset
operator|=
name|cpuset_ref
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|cpuset_rel_defer
argument_list|(
operator|&
name|droplist
argument_list|,
name|tdset
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_cpuset
operator|=
name|nset
expr_stmt|;
name|sched_affinity
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
name|unlock_out
label|:
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|out
label|:
while|while
condition|(
operator|(
name|nset
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|droplist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cpuset_rel_complete
argument_list|(
name|nset
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|nset
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|freelist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|nset
argument_list|,
name|cs_link
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|cpuset_zone
argument_list|,
name|nset
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a string representing a valid layout for a cpuset_t object.  * It expects an incoming buffer at least sized as CPUSETBUFSIZ.  */
end_comment

begin_function
name|char
modifier|*
name|cpusetobj_strprint
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|cpuset_t
modifier|*
name|set
parameter_list|)
block|{
name|char
modifier|*
name|tbuf
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|bytesp
decl_stmt|,
name|bufsiz
decl_stmt|;
name|tbuf
operator|=
name|buf
expr_stmt|;
name|bytesp
operator|=
literal|0
expr_stmt|;
name|bufsiz
operator|=
name|CPUSETBUFSIZ
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|_NCPUWORDS
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|bytesp
operator|=
name|snprintf
argument_list|(
name|tbuf
argument_list|,
name|bufsiz
argument_list|,
literal|"%lx,"
argument_list|,
name|set
operator|->
name|__bits
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bufsiz
operator|-=
name|bytesp
expr_stmt|;
name|tbuf
operator|+=
name|bytesp
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|tbuf
argument_list|,
name|bufsiz
argument_list|,
literal|"%lx"
argument_list|,
name|set
operator|->
name|__bits
index|[
name|_NCPUWORDS
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Build a valid cpuset_t object from a string representation.  * It expects an incoming buffer at least sized as CPUSETBUFSIZ.  */
end_comment

begin_function
name|int
name|cpusetobj_strscan
parameter_list|(
name|cpuset_t
modifier|*
name|set
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|u_int
name|nwords
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|>
name|CPUSETBUFSIZ
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Allow to pass a shorter version of the mask when necessary. */
name|nwords
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|buf
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|','
condition|)
name|nwords
operator|++
expr_stmt|;
if|if
condition|(
name|nwords
operator|>
name|_NCPUWORDS
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|CPU_ZERO
argument_list|(
name|set
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|nwords
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%lx,"
argument_list|,
operator|&
name|set
operator|->
name|__bits
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|||
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|buf
operator|=
name|strstr
argument_list|(
name|buf
argument_list|,
literal|","
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|buf
operator|++
expr_stmt|;
block|}
name|ret
operator|=
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%lx"
argument_list|,
operator|&
name|set
operator|->
name|__bits
index|[
name|nwords
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|||
name|ret
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Apply an anonymous mask to a single thread.  */
end_comment

begin_function
name|int
name|cpuset_setthread
parameter_list|(
name|lwpid_t
name|id
parameter_list|,
name|cpuset_t
modifier|*
name|mask
parameter_list|)
block|{
name|struct
name|cpuset
modifier|*
name|nset
decl_stmt|;
name|struct
name|cpuset
modifier|*
name|set
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nset
operator|=
name|uma_zalloc
argument_list|(
name|cpuset_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|cpuset_which
argument_list|(
name|CPU_WHICH_TID
argument_list|,
name|id
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|td
argument_list|,
operator|&
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|set
operator|=
name|NULL
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|cpuset_shadow
argument_list|(
name|td
operator|->
name|td_cpuset
argument_list|,
name|nset
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|set
operator|=
name|td
operator|->
name|td_cpuset
expr_stmt|;
name|td
operator|->
name|td_cpuset
operator|=
name|nset
expr_stmt|;
name|sched_affinity
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|nset
operator|=
name|NULL
expr_stmt|;
block|}
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
name|cpuset_rel
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|nset
condition|)
name|uma_zfree
argument_list|(
name|cpuset_zone
argument_list|,
name|nset
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Apply new cpumask to the ithread.  */
end_comment

begin_function
name|int
name|cpuset_setithread
parameter_list|(
name|lwpid_t
name|id
parameter_list|,
name|int
name|cpu
parameter_list|)
block|{
name|struct
name|cpuset
modifier|*
name|nset
decl_stmt|,
modifier|*
name|rset
decl_stmt|;
name|struct
name|cpuset
modifier|*
name|parent
decl_stmt|,
modifier|*
name|old_set
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|cpusetid_t
name|cs_id
decl_stmt|;
name|cpuset_t
name|mask
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nset
operator|=
name|uma_zalloc
argument_list|(
name|cpuset_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|rset
operator|=
name|uma_zalloc
argument_list|(
name|cpuset_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|cs_id
operator|=
name|CPUSET_INVALID
expr_stmt|;
name|CPU_ZERO
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpu
operator|==
name|NOCPU
condition|)
name|CPU_COPY
argument_list|(
name|cpuset_root
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
else|else
name|CPU_SET
argument_list|(
name|cpu
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|error
operator|=
name|cpuset_which
argument_list|(
name|CPU_WHICH_TID
argument_list|,
name|id
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|td
argument_list|,
operator|&
name|old_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
operator|(
operator|(
name|cs_id
operator|=
name|alloc_unr
argument_list|(
name|cpuset_unr
argument_list|)
operator|)
operator|==
name|CPUSET_INVALID
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* cpuset_which() returns with PROC_LOCK held. */
name|old_set
operator|=
name|td
operator|->
name|td_cpuset
expr_stmt|;
if|if
condition|(
name|cpu
operator|==
name|NOCPU
condition|)
block|{
comment|/* 		 * roll back to default set. We're not using cpuset_shadow() 		 * here because we can fail CPU_SUBSET() check. This can happen 		 * if default set does not contain all CPUs. 		 */
name|error
operator|=
name|_cpuset_create
argument_list|(
name|nset
argument_list|,
name|cpuset_default
argument_list|,
operator|&
name|mask
argument_list|,
name|CPUSET_INVALID
argument_list|)
expr_stmt|;
goto|goto
name|applyset
goto|;
block|}
if|if
condition|(
name|old_set
operator|->
name|cs_id
operator|==
literal|1
operator|||
operator|(
name|old_set
operator|->
name|cs_id
operator|==
name|CPUSET_INVALID
operator|&&
name|old_set
operator|->
name|cs_parent
operator|->
name|cs_id
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* 		 * Current set is either default (1) or 		 * shadowed version of default set. 		 * 		 * Allocate new root set to be able to shadow it 		 * with any mask. 		 */
name|error
operator|=
name|_cpuset_create
argument_list|(
name|rset
argument_list|,
name|cpuset_zero
argument_list|,
operator|&
name|cpuset_zero
operator|->
name|cs_mask
argument_list|,
name|cs_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|rset
operator|->
name|cs_flags
operator||=
name|CPU_SET_ROOT
expr_stmt|;
name|parent
operator|=
name|rset
expr_stmt|;
name|rset
operator|=
name|NULL
expr_stmt|;
name|cs_id
operator|=
name|CPUSET_INVALID
expr_stmt|;
block|}
else|else
block|{
comment|/* Assume existing set was already allocated by previous call */
name|parent
operator|=
name|old_set
expr_stmt|;
name|old_set
operator|=
name|NULL
expr_stmt|;
block|}
name|error
operator|=
name|cpuset_shadow
argument_list|(
name|parent
argument_list|,
name|nset
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|applyset
label|:
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_cpuset
operator|=
name|nset
expr_stmt|;
name|sched_affinity
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|nset
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|old_set
operator|=
name|NULL
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_set
operator|!=
name|NULL
condition|)
name|cpuset_rel
argument_list|(
name|old_set
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|nset
operator|!=
name|NULL
condition|)
name|uma_zfree
argument_list|(
name|cpuset_zone
argument_list|,
name|nset
argument_list|)
expr_stmt|;
if|if
condition|(
name|rset
operator|!=
name|NULL
condition|)
name|uma_zfree
argument_list|(
name|cpuset_zone
argument_list|,
name|rset
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs_id
operator|!=
name|CPUSET_INVALID
condition|)
name|free_unr
argument_list|(
name|cpuset_unr
argument_list|,
name|cs_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Creates system-wide cpusets and the cpuset for thread0 including two  * sets:  *   * 0 - The root set which should represent all valid processors in the  *     system.  It is initially created with a mask of all processors  *     because we don't know what processors are valid until cpuset_init()  *     runs.  This set is immutable.  * 1 - The default set which all processes are a member of until changed.  *     This allows an administrator to move all threads off of given cpus to  *     dedicate them to high priority tasks or save power etc.  */
end_comment

begin_function
name|struct
name|cpuset
modifier|*
name|cpuset_thread0
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cpuset
modifier|*
name|set
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|cpuset_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"cpuset"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cpuset
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|cpuset_lock
argument_list|,
literal|"cpuset"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
comment|/* 	 * Create the root system set for the whole machine.  Doesn't use 	 * cpuset_create() due to NULL parent. 	 */
name|set
operator|=
name|uma_zalloc
argument_list|(
name|cpuset_zone
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|CPU_FILL
argument_list|(
operator|&
name|set
operator|->
name|cs_mask
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|set
operator|->
name|cs_children
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|cpuset_ids
argument_list|,
name|set
argument_list|,
name|cs_link
argument_list|)
expr_stmt|;
name|set
operator|->
name|cs_ref
operator|=
literal|1
expr_stmt|;
name|set
operator|->
name|cs_flags
operator|=
name|CPU_SET_ROOT
expr_stmt|;
name|cpuset_zero
operator|=
name|set
expr_stmt|;
name|cpuset_root
operator|=
operator|&
name|set
operator|->
name|cs_mask
expr_stmt|;
comment|/* 	 * Now derive a default, modifiable set from that to give out. 	 */
name|set
operator|=
name|uma_zalloc
argument_list|(
name|cpuset_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|_cpuset_create
argument_list|(
name|set
argument_list|,
name|cpuset_zero
argument_list|,
operator|&
name|cpuset_zero
operator|->
name|cs_mask
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"Error creating default set: %d\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|cpuset_default
operator|=
name|set
expr_stmt|;
comment|/* 	 * Initialize the unit allocator. 0 and 1 are allocated above. 	 */
name|cpuset_unr
operator|=
name|new_unrhdr
argument_list|(
literal|2
argument_list|,
name|INT_MAX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * If MD code has not initialized per-domain cpusets, place all 	 * CPUs in domain 0. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXMEMDOM
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|CPU_EMPTY
argument_list|(
operator|&
name|cpuset_domain
index|[
name|i
index|]
argument_list|)
condition|)
goto|goto
name|domains_set
goto|;
name|CPU_COPY
argument_list|(
operator|&
name|all_cpus
argument_list|,
operator|&
name|cpuset_domain
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|domains_set
label|:
return|return
operator|(
name|set
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a cpuset, which would be cpuset_create() but  * mark the new 'set' as root.  *  * We are not going to reparent the td to it.  Use cpuset_setproc_update_set()  * for that.  *  * In case of no error, returns the set in *setp locked with a reference.  */
end_comment

begin_function
name|int
name|cpuset_create_root
parameter_list|(
name|struct
name|prison
modifier|*
name|pr
parameter_list|,
name|struct
name|cpuset
modifier|*
modifier|*
name|setp
parameter_list|)
block|{
name|struct
name|cpuset
modifier|*
name|set
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|pr
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[%s:%d] invalid pr"
operator|,
name|__func__
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|setp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[%s:%d] invalid setp"
operator|,
name|__func__
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|cpuset_create
argument_list|(
name|setp
argument_list|,
name|pr
operator|->
name|pr_cpuset
argument_list|,
operator|&
name|pr
operator|->
name|pr_cpuset
operator|->
name|cs_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|KASSERT
argument_list|(
operator|*
name|setp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[%s:%d] cpuset_create returned invalid data"
operator|,
name|__func__
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
comment|/* Mark the set as root. */
name|set
operator|=
operator|*
name|setp
expr_stmt|;
name|set
operator|->
name|cs_flags
operator||=
name|CPU_SET_ROOT
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cpuset_setproc_update_set
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|cpuset
modifier|*
name|set
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|p
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[%s:%d] invalid proc"
operator|,
name|__func__
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|set
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[%s:%d] invalid set"
operator|,
name|__func__
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|cpuset_ref
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|error
operator|=
name|cpuset_setproc
argument_list|(
name|p
operator|->
name|p_pid
argument_list|,
name|set
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|cpuset_rel
argument_list|(
name|set
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is called once the final set of system cpus is known.  Modifies  * the root set and all children and mark the root read-only.    */
end_comment

begin_function
specifier|static
name|void
name|cpuset_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|cpuset_t
name|mask
decl_stmt|;
name|mask
operator|=
name|all_cpus
expr_stmt|;
if|if
condition|(
name|cpuset_modify
argument_list|(
name|cpuset_zero
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Can't set initial cpuset mask.\n"
argument_list|)
expr_stmt|;
name|cpuset_zero
operator|->
name|cs_flags
operator||=
name|CPU_SET_RDONLY
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|cpuset
argument_list|,
name|SI_SUB_SMP
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|cpuset_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|cpuset_args
block|{
name|cpusetid_t
modifier|*
name|setid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sys_cpuset
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|cpuset_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|cpuset
modifier|*
name|root
decl_stmt|;
name|struct
name|cpuset
modifier|*
name|set
decl_stmt|;
name|int
name|error
decl_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|root
operator|=
name|cpuset_refroot
argument_list|(
name|td
operator|->
name|td_cpuset
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|cpuset_create
argument_list|(
operator|&
name|set
argument_list|,
name|root
argument_list|,
operator|&
name|root
operator|->
name|cs_mask
argument_list|)
expr_stmt|;
name|cpuset_rel
argument_list|(
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|set
operator|->
name|cs_id
argument_list|,
name|uap
operator|->
name|setid
argument_list|,
sizeof|sizeof
argument_list|(
name|set
operator|->
name|cs_id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|cpuset_setproc
argument_list|(
operator|-
literal|1
argument_list|,
name|set
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cpuset_rel
argument_list|(
name|set
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|cpuset_setid_args
block|{
name|cpuwhich_t
name|which
decl_stmt|;
name|id_t
name|id
decl_stmt|;
name|cpusetid_t
name|setid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sys_cpuset_setid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|cpuset_setid_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|kern_cpuset_setid
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|which
argument_list|,
name|uap
operator|->
name|id
argument_list|,
name|uap
operator|->
name|setid
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kern_cpuset_setid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|cpuwhich_t
name|which
parameter_list|,
name|id_t
name|id
parameter_list|,
name|cpusetid_t
name|setid
parameter_list|)
block|{
name|struct
name|cpuset
modifier|*
name|set
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Presently we only support per-process sets. 	 */
if|if
condition|(
name|which
operator|!=
name|CPU_WHICH_PID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|set
operator|=
name|cpuset_lookup
argument_list|(
name|setid
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
name|error
operator|=
name|cpuset_setproc
argument_list|(
name|id
argument_list|,
name|set
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cpuset_rel
argument_list|(
name|set
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|cpuset_getid_args
block|{
name|cpulevel_t
name|level
decl_stmt|;
name|cpuwhich_t
name|which
decl_stmt|;
name|id_t
name|id
decl_stmt|;
name|cpusetid_t
modifier|*
name|setid
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sys_cpuset_getid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|cpuset_getid_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|kern_cpuset_getid
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|level
argument_list|,
name|uap
operator|->
name|which
argument_list|,
name|uap
operator|->
name|id
argument_list|,
name|uap
operator|->
name|setid
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kern_cpuset_getid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|cpulevel_t
name|level
parameter_list|,
name|cpuwhich_t
name|which
parameter_list|,
name|id_t
name|id
parameter_list|,
name|cpusetid_t
modifier|*
name|setid
parameter_list|)
block|{
name|struct
name|cpuset
modifier|*
name|nset
decl_stmt|;
name|struct
name|cpuset
modifier|*
name|set
decl_stmt|;
name|struct
name|thread
modifier|*
name|ttd
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|cpusetid_t
name|tmpid
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|level
operator|==
name|CPU_LEVEL_WHICH
operator|&&
name|which
operator|!=
name|CPU_WHICH_CPUSET
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|cpuset_which
argument_list|(
name|which
argument_list|,
name|id
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|ttd
argument_list|,
operator|&
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|CPU_WHICH_TID
case|:
case|case
name|CPU_WHICH_PID
case|:
name|thread_lock
argument_list|(
name|ttd
argument_list|)
expr_stmt|;
name|set
operator|=
name|cpuset_refbase
argument_list|(
name|ttd
operator|->
name|td_cpuset
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|ttd
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPU_WHICH_CPUSET
case|:
case|case
name|CPU_WHICH_JAIL
case|:
break|break;
case|case
name|CPU_WHICH_IRQ
case|:
case|case
name|CPU_WHICH_DOMAIN
case|:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
switch|switch
condition|(
name|level
condition|)
block|{
case|case
name|CPU_LEVEL_ROOT
case|:
name|nset
operator|=
name|cpuset_refroot
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|cpuset_rel
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|set
operator|=
name|nset
expr_stmt|;
break|break;
case|case
name|CPU_LEVEL_CPUSET
case|:
break|break;
case|case
name|CPU_LEVEL_WHICH
case|:
break|break;
block|}
name|tmpid
operator|=
name|set
operator|->
name|cs_id
expr_stmt|;
name|cpuset_rel
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|tmpid
argument_list|,
name|setid
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|cpuset_getaffinity_args
block|{
name|cpulevel_t
name|level
decl_stmt|;
name|cpuwhich_t
name|which
decl_stmt|;
name|id_t
name|id
decl_stmt|;
name|size_t
name|cpusetsize
decl_stmt|;
name|cpuset_t
modifier|*
name|mask
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sys_cpuset_getaffinity
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|cpuset_getaffinity_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|kern_cpuset_getaffinity
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|level
argument_list|,
name|uap
operator|->
name|which
argument_list|,
name|uap
operator|->
name|id
argument_list|,
name|uap
operator|->
name|cpusetsize
argument_list|,
name|uap
operator|->
name|mask
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kern_cpuset_getaffinity
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|cpulevel_t
name|level
parameter_list|,
name|cpuwhich_t
name|which
parameter_list|,
name|id_t
name|id
parameter_list|,
name|size_t
name|cpusetsize
parameter_list|,
name|cpuset_t
modifier|*
name|maskp
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|ttd
decl_stmt|;
name|struct
name|cpuset
modifier|*
name|nset
decl_stmt|;
name|struct
name|cpuset
modifier|*
name|set
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|cpuset_t
modifier|*
name|mask
decl_stmt|;
name|int
name|error
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|cpusetsize
operator|<
sizeof|sizeof
argument_list|(
name|cpuset_t
argument_list|)
operator|||
name|cpusetsize
operator|>
name|CPU_MAXSIZE
operator|/
name|NBBY
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
name|size
operator|=
name|cpusetsize
expr_stmt|;
name|mask
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|error
operator|=
name|cpuset_which
argument_list|(
name|which
argument_list|,
name|id
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|ttd
argument_list|,
operator|&
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
switch|switch
condition|(
name|level
condition|)
block|{
case|case
name|CPU_LEVEL_ROOT
case|:
case|case
name|CPU_LEVEL_CPUSET
case|:
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|CPU_WHICH_TID
case|:
case|case
name|CPU_WHICH_PID
case|:
name|thread_lock
argument_list|(
name|ttd
argument_list|)
expr_stmt|;
name|set
operator|=
name|cpuset_ref
argument_list|(
name|ttd
operator|->
name|td_cpuset
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|ttd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPU_WHICH_CPUSET
case|:
case|case
name|CPU_WHICH_JAIL
case|:
break|break;
case|case
name|CPU_WHICH_IRQ
case|:
case|case
name|CPU_WHICH_DOMAIN
case|:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|level
operator|==
name|CPU_LEVEL_ROOT
condition|)
name|nset
operator|=
name|cpuset_refroot
argument_list|(
name|set
argument_list|)
expr_stmt|;
else|else
name|nset
operator|=
name|cpuset_refbase
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|CPU_COPY
argument_list|(
operator|&
name|nset
operator|->
name|cs_mask
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|cpuset_rel
argument_list|(
name|nset
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPU_LEVEL_WHICH
case|:
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|CPU_WHICH_TID
case|:
name|thread_lock
argument_list|(
name|ttd
argument_list|)
expr_stmt|;
name|CPU_COPY
argument_list|(
operator|&
name|ttd
operator|->
name|td_cpuset
operator|->
name|cs_mask
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|ttd
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPU_WHICH_PID
case|:
name|FOREACH_THREAD_IN_PROC
argument_list|(
argument|p
argument_list|,
argument|ttd
argument_list|)
block|{
name|thread_lock
argument_list|(
name|ttd
argument_list|)
expr_stmt|;
name|CPU_OR
argument_list|(
name|mask
argument_list|,
operator|&
name|ttd
operator|->
name|td_cpuset
operator|->
name|cs_mask
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|ttd
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CPU_WHICH_CPUSET
case|:
case|case
name|CPU_WHICH_JAIL
case|:
name|CPU_COPY
argument_list|(
operator|&
name|set
operator|->
name|cs_mask
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPU_WHICH_IRQ
case|:
name|error
operator|=
name|intr_getaffinity
argument_list|(
name|id
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPU_WHICH_DOMAIN
case|:
if|if
condition|(
name|id
operator|<
literal|0
operator|||
name|id
operator|>=
name|MAXMEMDOM
condition|)
name|error
operator|=
name|ESRCH
expr_stmt|;
else|else
name|CPU_COPY
argument_list|(
operator|&
name|cpuset_domain
index|[
name|id
index|]
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|set
condition|)
name|cpuset_rel
argument_list|(
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|mask
argument_list|,
name|maskp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|mask
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|cpuset_setaffinity_args
block|{
name|cpulevel_t
name|level
decl_stmt|;
name|cpuwhich_t
name|which
decl_stmt|;
name|id_t
name|id
decl_stmt|;
name|size_t
name|cpusetsize
decl_stmt|;
specifier|const
name|cpuset_t
modifier|*
name|mask
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sys_cpuset_setaffinity
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|cpuset_setaffinity_args
modifier|*
name|uap
parameter_list|)
block|{
return|return
operator|(
name|kern_cpuset_setaffinity
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|level
argument_list|,
name|uap
operator|->
name|which
argument_list|,
name|uap
operator|->
name|id
argument_list|,
name|uap
operator|->
name|cpusetsize
argument_list|,
name|uap
operator|->
name|mask
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kern_cpuset_setaffinity
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|cpulevel_t
name|level
parameter_list|,
name|cpuwhich_t
name|which
parameter_list|,
name|id_t
name|id
parameter_list|,
name|size_t
name|cpusetsize
parameter_list|,
specifier|const
name|cpuset_t
modifier|*
name|maskp
parameter_list|)
block|{
name|struct
name|cpuset
modifier|*
name|nset
decl_stmt|;
name|struct
name|cpuset
modifier|*
name|set
decl_stmt|;
name|struct
name|thread
modifier|*
name|ttd
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|cpuset_t
modifier|*
name|mask
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|cpusetsize
operator|<
sizeof|sizeof
argument_list|(
name|cpuset_t
argument_list|)
operator|||
name|cpusetsize
operator|>
name|CPU_MAXSIZE
operator|/
name|NBBY
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
name|mask
operator|=
name|malloc
argument_list|(
name|cpusetsize
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|maskp
argument_list|,
name|mask
argument_list|,
name|cpusetsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Verify that no high bits are set. 	 */
if|if
condition|(
name|cpusetsize
operator|>
sizeof|sizeof
argument_list|(
name|cpuset_t
argument_list|)
condition|)
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|end
operator|=
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|mask
operator|->
name|__bits
expr_stmt|;
name|end
operator|+=
name|cpusetsize
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|cpuset_t
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|!=
name|end
condition|)
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
switch|switch
condition|(
name|level
condition|)
block|{
case|case
name|CPU_LEVEL_ROOT
case|:
case|case
name|CPU_LEVEL_CPUSET
case|:
name|error
operator|=
name|cpuset_which
argument_list|(
name|which
argument_list|,
name|id
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|ttd
argument_list|,
operator|&
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|CPU_WHICH_TID
case|:
case|case
name|CPU_WHICH_PID
case|:
name|thread_lock
argument_list|(
name|ttd
argument_list|)
expr_stmt|;
name|set
operator|=
name|cpuset_ref
argument_list|(
name|ttd
operator|->
name|td_cpuset
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|ttd
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPU_WHICH_CPUSET
case|:
case|case
name|CPU_WHICH_JAIL
case|:
break|break;
case|case
name|CPU_WHICH_IRQ
case|:
case|case
name|CPU_WHICH_DOMAIN
case|:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|level
operator|==
name|CPU_LEVEL_ROOT
condition|)
name|nset
operator|=
name|cpuset_refroot
argument_list|(
name|set
argument_list|)
expr_stmt|;
else|else
name|nset
operator|=
name|cpuset_refbase
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|error
operator|=
name|cpuset_modify
argument_list|(
name|nset
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|cpuset_rel
argument_list|(
name|nset
argument_list|)
expr_stmt|;
name|cpuset_rel
argument_list|(
name|set
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPU_LEVEL_WHICH
case|:
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|CPU_WHICH_TID
case|:
name|error
operator|=
name|cpuset_setthread
argument_list|(
name|id
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPU_WHICH_PID
case|:
name|error
operator|=
name|cpuset_setproc
argument_list|(
name|id
argument_list|,
name|NULL
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPU_WHICH_CPUSET
case|:
case|case
name|CPU_WHICH_JAIL
case|:
name|error
operator|=
name|cpuset_which
argument_list|(
name|which
argument_list|,
name|id
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|ttd
argument_list|,
operator|&
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|cpuset_modify
argument_list|(
name|set
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|cpuset_rel
argument_list|(
name|set
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CPU_WHICH_IRQ
case|:
name|error
operator|=
name|intr_setaffinity
argument_list|(
name|id
argument_list|,
name|mask
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|out
label|:
name|free
argument_list|(
name|mask
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_function
name|void
name|ddb_display_cpuset
parameter_list|(
specifier|const
name|cpuset_t
modifier|*
name|set
parameter_list|)
block|{
name|int
name|cpu
decl_stmt|,
name|once
decl_stmt|;
for|for
control|(
name|once
operator|=
literal|0
operator|,
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<
name|CPU_SETSIZE
condition|;
name|cpu
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ISSET
argument_list|(
name|cpu
argument_list|,
name|set
argument_list|)
condition|)
block|{
if|if
condition|(
name|once
operator|==
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"%d"
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|once
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|db_printf
argument_list|(
literal|",%d"
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|once
operator|==
literal|0
condition|)
name|db_printf
argument_list|(
literal|"<none>"
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|cpusets
argument_list|,
argument|db_show_cpusets
argument_list|)
end_macro

begin_block
block|{
name|struct
name|cpuset
modifier|*
name|set
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|set
argument_list|,
argument|&cpuset_ids
argument_list|,
argument|cs_link
argument_list|)
block|{
name|db_printf
argument_list|(
literal|"set=%p id=%-6u ref=%-6d flags=0x%04x parent id=%d\n"
argument_list|,
name|set
argument_list|,
name|set
operator|->
name|cs_id
argument_list|,
name|set
operator|->
name|cs_ref
argument_list|,
name|set
operator|->
name|cs_flags
argument_list|,
operator|(
name|set
operator|->
name|cs_parent
operator|!=
name|NULL
operator|)
condition|?
name|set
operator|->
name|cs_parent
operator|->
name|cs_id
else|:
literal|0
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"  mask="
argument_list|)
expr_stmt|;
name|ddb_display_cpuset
argument_list|(
operator|&
name|set
operator|->
name|cs_mask
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_pager_quit
condition|)
break|break;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

end_unit

