begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001, 2002, 2003  * 	Bosko Milekic<bmilekic@FreeBSD.org>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.   *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|"opt_param.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mac.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_comment
comment|/*  * mb_alloc: network buffer allocator  */
end_comment

begin_comment
comment|/*  * Maximum number of PCPU containers. If you know what you're doing you could  * explicitly define MBALLOC_NCPU to be exactly the number of CPUs on your  * system during compilation, and thus prevent kernel structure bloat.  *  * SMP and non-SMP kernels clearly have a different number of possible CPUs,  * but because we cannot assume a dense array of CPUs, we always allocate  * and traverse PCPU containers up to NCPU amount and merely check for  * CPU availability.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MBALLOC_NCPU
end_ifdef

begin_define
define|#
directive|define
name|NCPU
value|MBALLOC_NCPU
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NCPU
value|MAXCPU
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  * The mbuf allocator is based on Alfred Perlstein's<alfred@FreeBSD.org>  * "memcache" proof-of-concept allocator which was itself based on  * several well-known SMP-friendly allocators.  *  * The mb_alloc mbuf allocator is a special when compared to other  * general-purpose allocators.  Some things to take note of:  *  *   Mbufs and mbuf clusters are two different objects.  Sometimes we  *   will allocate a single mbuf, other times a single cluster,  *   other times both.  Further, we may sometimes wish to allocate a  *   whole chain of mbufs with clusters.  This allocator will perform  *   the common case of each scenario in one function call (this  *   includes constructing or destructing the object) while only  *   locking/unlocking the cache once, if it can get away with it.  *   The caches consist of pure mbufs and pure clusters; that is  *   there are no 'zones' containing mbufs with already pre-hooked  *   clusters.  Since we can allocate both objects atomically anyway,  *   we don't bother fragmenting our caches for any particular 'scenarios.'  *  *   We allocate from seperate sub-maps of kmem_map, thus imposing  *   an ultimate upper-limit on the number of allocatable clusters  *   and mbufs and also, since the clusters all come from a  *   virtually contiguous region, we can keep reference counters  *   for them and "allocate" them purely by indexing into a  *   dense refcount vector.  *  *   We call out to protocol drain routines (which can be hooked  *   into us) when we're low on space.  *  * The mbuf allocator keeps all objects that it allocates in mb_buckets.  * The buckets keep a number of objects (an object can be an mbuf or an  * mbuf cluster) and facilitate moving larger sets of contiguous objects  * from the per-CPU caches to the global cache. The buckets also have  * the added advantage that objects, when migrated from cache to cache,  * are migrated in chunks that keep contiguous objects together,  * minimizing TLB pollution.  *  * The buckets are kept on singly-linked lists called "containers." A container  * is protected by a mutex in order to ensure consistency.  The mutex  * itself is allocated separately and attached to the container at boot time,  * thus allowing for certain containers to share the same lock.  Per-CPU  * containers for mbufs and mbuf clusters all share the same per-CPU   * lock whereas the global cache containers for these objects share one  * global lock.  */
end_comment

begin_struct
struct|struct
name|mb_bucket
block|{
name|SLIST_ENTRY
argument_list|(
argument|mb_bucket
argument_list|)
name|mb_blist
expr_stmt|;
name|int
name|mb_owner
decl_stmt|;
name|int
name|mb_numfree
decl_stmt|;
name|void
modifier|*
name|mb_free
index|[
literal|0
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mb_container
block|{
name|SLIST_HEAD
argument_list|(
argument|mc_buckethd
argument_list|,
argument|mb_bucket
argument_list|)
name|mc_bhead
expr_stmt|;
name|struct
name|mtx
modifier|*
name|mc_lock
decl_stmt|;
name|int
name|mc_numowner
decl_stmt|;
name|u_int
name|mc_starved
decl_stmt|;
name|long
modifier|*
name|mc_types
decl_stmt|;
name|u_long
modifier|*
name|mc_objcount
decl_stmt|;
name|u_long
modifier|*
name|mc_numbucks
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mb_gen_list
block|{
name|struct
name|mb_container
name|mb_cont
decl_stmt|;
name|struct
name|cv
name|mgl_mstarved
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mb_pcpu_list
block|{
name|struct
name|mb_container
name|mb_cont
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Boot-time configurable object counts that will determine the maximum  * number of permitted objects in the mbuf and mcluster cases.  In the  * ext counter (nmbcnt) case, it's just an indicator serving to scale  * kmem_map size properly - in other words, we may be allowed to allocate  * more than nmbcnt counters, whereas we will never be allowed to allocate  * more than nmbufs mbufs or nmbclusters mclusters.  * As for nsfbufs, it is used to indicate how many sendfile(2) buffers will be  * allocatable by the sfbuf allocator (found in uipc_syscalls.c)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NMBCLUSTERS
end_ifndef

begin_define
define|#
directive|define
name|NMBCLUSTERS
value|(1024 + maxusers * 64)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NMBUFS
end_ifndef

begin_define
define|#
directive|define
name|NMBUFS
value|(nmbclusters * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NSFBUFS
end_ifndef

begin_define
define|#
directive|define
name|NSFBUFS
value|(512 + maxusers * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NMBCNTS
end_ifndef

begin_define
define|#
directive|define
name|NMBCNTS
value|(nmbclusters + nsfbufs)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|nmbufs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nmbclusters
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nmbcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nsfbufs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Sizes of objects per bucket.  There are this size's worth of mbufs  * or clusters in each bucket.  Please keep these a power-of-2.  */
end_comment

begin_define
define|#
directive|define
name|MBUF_BUCK_SZ
value|(PAGE_SIZE * 2)
end_define

begin_define
define|#
directive|define
name|CLUST_BUCK_SZ
value|(PAGE_SIZE * 4)
end_define

begin_comment
comment|/*  * Perform sanity checks of tunables declared above.  */
end_comment

begin_function
specifier|static
name|void
name|tunable_mbinit
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
comment|/* 	 * This has to be done before VM init. 	 */
name|nmbclusters
operator|=
name|NMBCLUSTERS
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.nmbclusters"
argument_list|,
operator|&
name|nmbclusters
argument_list|)
expr_stmt|;
name|nmbufs
operator|=
name|NMBUFS
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.nmbufs"
argument_list|,
operator|&
name|nmbufs
argument_list|)
expr_stmt|;
name|nsfbufs
operator|=
name|NSFBUFS
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.nsfbufs"
argument_list|,
operator|&
name|nsfbufs
argument_list|)
expr_stmt|;
name|nmbcnt
operator|=
name|NMBCNTS
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.nmbcnt"
argument_list|,
operator|&
name|nmbcnt
argument_list|)
expr_stmt|;
comment|/* Sanity checks */
if|if
condition|(
name|nmbufs
operator|<
name|nmbclusters
operator|*
literal|2
condition|)
name|nmbufs
operator|=
name|nmbclusters
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|nmbcnt
operator|<
name|nmbclusters
operator|+
name|nsfbufs
condition|)
name|nmbcnt
operator|=
name|nmbclusters
operator|+
name|nsfbufs
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|tunable_mbinit
argument_list|,
name|SI_SUB_TUNABLES
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|tunable_mbinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The freelist structures and mutex locks.  The number statically declared  * here depends on the number of CPUs.  *  * We set up in such a way that all the objects (mbufs, clusters)  * share the same mutex lock.  It has been established that we do not benefit  * from different locks for different objects, so we use the same lock,  * regardless of object type.  This also allows us to do optimised  * multi-object allocations without dropping the lock in between.  */
end_comment

begin_struct
struct|struct
name|mb_lstmngr
block|{
name|struct
name|mb_gen_list
modifier|*
name|ml_genlist
decl_stmt|;
name|struct
name|mb_pcpu_list
modifier|*
name|ml_cntlst
index|[
name|NCPU
index|]
decl_stmt|;
name|struct
name|mb_bucket
modifier|*
modifier|*
name|ml_btable
decl_stmt|;
name|vm_map_t
name|ml_map
decl_stmt|;
name|vm_offset_t
name|ml_mapbase
decl_stmt|;
name|vm_offset_t
name|ml_maptop
decl_stmt|;
name|int
name|ml_mapfull
decl_stmt|;
name|u_int
name|ml_objsize
decl_stmt|;
name|u_int
name|ml_objbucks
decl_stmt|;
name|u_int
modifier|*
name|ml_wmhigh
decl_stmt|;
name|u_int
modifier|*
name|ml_wmlow
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|mb_lstmngr
name|mb_list_mbuf
decl_stmt|,
name|mb_list_clust
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|mbuf_gen
decl_stmt|,
name|mbuf_pcpu
index|[
name|NCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
modifier|*
name|cl_refcntmap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local macros for internal allocator structure manipulations.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_define
define|#
directive|define
name|MB_GET_PCPU_LIST
parameter_list|(
name|mb_lst
parameter_list|)
value|(mb_lst)->ml_cntlst[PCPU_GET(cpuid)]
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MB_GET_PCPU_LIST
parameter_list|(
name|mb_lst
parameter_list|)
value|(mb_lst)->ml_cntlst[0]
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MB_GET_GEN_LIST
parameter_list|(
name|mb_lst
parameter_list|)
value|(mb_lst)->ml_genlist
end_define

begin_define
define|#
directive|define
name|MB_LOCK_CONT
parameter_list|(
name|mb_cnt
parameter_list|)
value|mtx_lock((mb_cnt)->mb_cont.mc_lock)
end_define

begin_define
define|#
directive|define
name|MB_UNLOCK_CONT
parameter_list|(
name|mb_cnt
parameter_list|)
value|mtx_unlock((mb_cnt)->mb_cont.mc_lock)
end_define

begin_define
define|#
directive|define
name|MB_GET_PCPU_LIST_NUM
parameter_list|(
name|mb_lst
parameter_list|,
name|num
parameter_list|)
define|\
value|(mb_lst)->ml_cntlst[(num)]
end_define

begin_define
define|#
directive|define
name|MB_BUCKET_INDX
parameter_list|(
name|mb_obj
parameter_list|,
name|mb_lst
parameter_list|)
define|\
value|(int)(((caddr_t)(mb_obj) - (caddr_t)(mb_lst)->ml_mapbase) /		\     ((mb_lst)->ml_objbucks * (mb_lst)->ml_objsize))
end_define

begin_define
define|#
directive|define
name|MB_GET_OBJECT
parameter_list|(
name|mb_objp
parameter_list|,
name|mb_bckt
parameter_list|,
name|mb_lst
parameter_list|)
define|\
value|{									\ 	struct mc_buckethd *_mchd =&((mb_lst)->mb_cont.mc_bhead);	\ 									\ 	(mb_bckt)->mb_numfree--;					\ 	(mb_objp) = (mb_bckt)->mb_free[((mb_bckt)->mb_numfree)];	\ 	(*((mb_lst)->mb_cont.mc_objcount))--;				\ 	if ((mb_bckt)->mb_numfree == 0) {				\ 		SLIST_REMOVE_HEAD(_mchd, mb_blist);			\ 		SLIST_NEXT((mb_bckt), mb_blist) = NULL;			\ 		(mb_bckt)->mb_owner |= MB_BUCKET_FREE;			\ 	}								\ }
end_define

begin_define
define|#
directive|define
name|MB_PUT_OBJECT
parameter_list|(
name|mb_objp
parameter_list|,
name|mb_bckt
parameter_list|,
name|mb_lst
parameter_list|)
define|\
value|(mb_bckt)->mb_free[((mb_bckt)->mb_numfree)] = (mb_objp);	\ 	(mb_bckt)->mb_numfree++;					\ 	(*((mb_lst)->mb_cont.mc_objcount))++;
end_define

begin_define
define|#
directive|define
name|MB_MBTYPES_INC
parameter_list|(
name|mb_cnt
parameter_list|,
name|mb_type
parameter_list|,
name|mb_num
parameter_list|)
define|\
value|if ((mb_type) != MT_NOTMBUF)					\ 	    (*((mb_cnt)->mb_cont.mc_types + (mb_type))) += (mb_num)
end_define

begin_define
define|#
directive|define
name|MB_MBTYPES_DEC
parameter_list|(
name|mb_cnt
parameter_list|,
name|mb_type
parameter_list|,
name|mb_num
parameter_list|)
define|\
value|if ((mb_type) != MT_NOTMBUF)					\ 	    (*((mb_cnt)->mb_cont.mc_types + (mb_type))) -= (mb_num)
end_define

begin_comment
comment|/*  * Ownership of buckets/containers is represented by integers.  The PCPU  * lists range from 0 to NCPU-1.  We need a free numerical id for the general  * list (we use NCPU).  We also need a non-conflicting free bit to indicate  * that the bucket is free and removed from a container, while not losing  * the bucket's originating container id.  We use the highest bit  * for the free marker.  */
end_comment

begin_define
define|#
directive|define
name|MB_GENLIST_OWNER
value|(NCPU)
end_define

begin_define
define|#
directive|define
name|MB_BUCKET_FREE
value|(1<< (sizeof(int) * 8 - 1))
end_define

begin_comment
comment|/* Statistics structures for allocator (per-CPU and general). */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mbpstat
name|mb_statpcpu
index|[
name|NCPU
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbstat
name|mbstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sleep time for wait code (in ticks). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mbuf_wait
init|=
literal|64
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|mbuf_hiwm
init|=
literal|512
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* High wm on  # of mbufs per cache */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|mbuf_lowm
init|=
literal|128
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Low wm on # of mbufs per cache */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|clust_hiwm
init|=
literal|128
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* High wm on # of clusters per cache */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|clust_lowm
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Low wm on # of clusters per cache */
end_comment

begin_comment
comment|/*  * Objects exported by sysctl(8).  */
end_comment

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_kern_ipc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|nmbclusters
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|nmbclusters
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of mbuf clusters available"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|nmbufs
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|nmbufs
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of mbufs available"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|nmbcnt
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|nmbcnt
argument_list|,
literal|0
argument_list|,
literal|"Number used to scale kmem_map to ensure sufficient space for counters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|nsfbufs
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|nsfbufs
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of sendfile(2) sf_bufs available"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|mbuf_wait
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mbuf_wait
argument_list|,
literal|0
argument_list|,
literal|"Sleep time of mbuf subsystem wait allocations during exhaustion"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|mbuf_hiwm
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mbuf_hiwm
argument_list|,
literal|0
argument_list|,
literal|"Upper limit of number of mbufs allowed in each cache"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|mbuf_lowm
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mbuf_lowm
argument_list|,
literal|0
argument_list|,
literal|"Lower limit of number of mbufs allowed in each cache"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|clust_hiwm
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|clust_hiwm
argument_list|,
literal|0
argument_list|,
literal|"Upper limit of number of mbuf clusters allowed in each cache"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|clust_lowm
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|clust_lowm
argument_list|,
literal|0
argument_list|,
literal|"Lower limit of number of mbuf clusters allowed in each cache"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_STRUCT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|mbstat
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|mbstat
argument_list|,
name|mbstat
argument_list|,
literal|"Mbuf general information and statistics"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_OPAQUE
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|mb_statpcpu
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|mb_statpcpu
argument_list|,
sizeof|sizeof
argument_list|(
name|mb_statpcpu
argument_list|)
argument_list|,
literal|"S,"
argument_list|,
literal|"Mbuf allocator per CPU statistics"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Prototypes of local allocator routines.  */
end_comment

begin_function_decl
specifier|static
name|void
modifier|*
name|mb_alloc_wait
parameter_list|(
name|struct
name|mb_lstmngr
modifier|*
parameter_list|,
name|short
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mb_bucket
modifier|*
name|mb_pop_cont
parameter_list|(
name|struct
name|mb_lstmngr
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|mb_pcpu_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mb_reclaim
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mbuf_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Initial allocation numbers.  Each parameter represents the number of buckets  * of each object that will be placed initially in each PCPU container for  * said object.  */
end_comment

begin_define
define|#
directive|define
name|NMB_MBUF_INIT
value|2
end_define

begin_define
define|#
directive|define
name|NMB_CLUST_INIT
value|8
end_define

begin_comment
comment|/*  * Internal flags that allow for cache locks to remain "persistent" across  * allocation and free calls.  They may be used in combination.  */
end_comment

begin_define
define|#
directive|define
name|MBP_PERSIST
value|0x1
end_define

begin_comment
comment|/* Return with lock still held. */
end_comment

begin_define
define|#
directive|define
name|MBP_PERSISTENT
value|0x2
end_define

begin_comment
comment|/* Cache lock is already held coming in. */
end_comment

begin_comment
comment|/*  * Initialize the mbuf subsystem.  *  * We sub-divide the kmem_map into several submaps; this way, we don't have  * to worry about artificially limiting the number of mbuf or mbuf cluster  * allocations, due to fear of one type of allocation "stealing" address  * space initially reserved for another.  *  * Set up both the general containers and all the PCPU containers.  Populate  * the PCPU containers with initial numbers.  */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_MBUF
argument_list|,
literal|"mbufmgr"
argument_list|,
literal|"mbuf subsystem management structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|SYSINIT
argument_list|(
argument|mbuf
argument_list|,
argument|SI_SUB_MBUF
argument_list|,
argument|SI_ORDER_FIRST
argument_list|,
argument|mbuf_init
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_function
specifier|static
name|void
name|mbuf_init
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|struct
name|mb_pcpu_list
modifier|*
name|pcpu_cnt
decl_stmt|;
name|vm_size_t
name|mb_map_size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 	 * Set up all the submaps, for each type of object that we deal 	 * with in this allocator. 	 */
name|mb_map_size
operator|=
call|(
name|vm_size_t
call|)
argument_list|(
name|nmbufs
operator|*
name|MSIZE
argument_list|)
expr_stmt|;
name|mb_map_size
operator|=
name|rounddown
argument_list|(
name|mb_map_size
argument_list|,
name|MBUF_BUCK_SZ
argument_list|)
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_btable
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|mb_map_size
operator|/
name|MBUF_BUCK_SZ
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mb_bucket
operator|*
argument_list|)
argument_list|,
name|M_MBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_list_mbuf
operator|.
name|ml_btable
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|mb_list_mbuf
operator|.
name|ml_map
operator|=
name|kmem_suballoc
argument_list|(
name|kmem_map
argument_list|,
operator|&
operator|(
name|mb_list_mbuf
operator|.
name|ml_mapbase
operator|)
argument_list|,
operator|&
operator|(
name|mb_list_mbuf
operator|.
name|ml_maptop
operator|)
argument_list|,
name|mb_map_size
argument_list|)
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_map
operator|->
name|system_map
operator|=
literal|1
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_mapfull
operator|=
literal|0
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_objsize
operator|=
name|MSIZE
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_objbucks
operator|=
name|MBUF_BUCK_SZ
operator|/
name|MSIZE
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_wmhigh
operator|=
operator|&
name|mbuf_hiwm
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_wmlow
operator|=
operator|&
name|mbuf_lowm
expr_stmt|;
name|mb_map_size
operator|=
call|(
name|vm_size_t
call|)
argument_list|(
name|nmbclusters
operator|*
name|MCLBYTES
argument_list|)
expr_stmt|;
name|mb_map_size
operator|=
name|rounddown
argument_list|(
name|mb_map_size
argument_list|,
name|CLUST_BUCK_SZ
argument_list|)
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_btable
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|mb_map_size
operator|/
name|CLUST_BUCK_SZ
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mb_bucket
operator|*
argument_list|)
argument_list|,
name|M_MBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_list_clust
operator|.
name|ml_btable
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|mb_list_clust
operator|.
name|ml_map
operator|=
name|kmem_suballoc
argument_list|(
name|kmem_map
argument_list|,
operator|&
operator|(
name|mb_list_clust
operator|.
name|ml_mapbase
operator|)
argument_list|,
operator|&
operator|(
name|mb_list_clust
operator|.
name|ml_maptop
operator|)
argument_list|,
name|mb_map_size
argument_list|)
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_map
operator|->
name|system_map
operator|=
literal|1
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_mapfull
operator|=
literal|0
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_objsize
operator|=
name|MCLBYTES
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_objbucks
operator|=
name|CLUST_BUCK_SZ
operator|/
name|MCLBYTES
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_wmhigh
operator|=
operator|&
name|clust_hiwm
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_wmlow
operator|=
operator|&
name|clust_lowm
expr_stmt|;
comment|/* 	 * Allocate required general (global) containers for each object type. 	 */
name|mb_list_mbuf
operator|.
name|ml_genlist
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mb_gen_list
argument_list|)
argument_list|,
name|M_MBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_genlist
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mb_gen_list
argument_list|)
argument_list|,
name|M_MBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mb_list_mbuf
operator|.
name|ml_genlist
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mb_list_clust
operator|.
name|ml_genlist
operator|==
name|NULL
operator|)
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * Initialize condition variables and general container mutex locks. 	 */
name|mtx_init
argument_list|(
operator|&
name|mbuf_gen
argument_list|,
literal|"mbuf subsystem general lists lock"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
operator|(
name|mb_list_mbuf
operator|.
name|ml_genlist
operator|->
name|mgl_mstarved
operator|)
argument_list|,
literal|"mbuf pool starved"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
operator|(
name|mb_list_clust
operator|.
name|ml_genlist
operator|->
name|mgl_mstarved
operator|)
argument_list|,
literal|"mcluster pool starved"
argument_list|)
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_lock
operator|=
name|mb_list_clust
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_lock
operator|=
operator|&
name|mbuf_gen
expr_stmt|;
comment|/* 	 * Set up the general containers for each object. 	 */
name|mb_list_mbuf
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_numowner
operator|=
name|mb_list_clust
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_numowner
operator|=
name|MB_GENLIST_OWNER
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|=
name|mb_list_clust
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|=
literal|0
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|=
operator|&
operator|(
name|mb_statpcpu
index|[
name|MB_GENLIST_OWNER
index|]
operator|.
name|mb_mbfree
operator|)
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|=
operator|&
operator|(
name|mb_statpcpu
index|[
name|MB_GENLIST_OWNER
index|]
operator|.
name|mb_clfree
operator|)
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_numbucks
operator|=
operator|&
operator|(
name|mb_statpcpu
index|[
name|MB_GENLIST_OWNER
index|]
operator|.
name|mb_mbbucks
operator|)
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_numbucks
operator|=
operator|&
operator|(
name|mb_statpcpu
index|[
name|MB_GENLIST_OWNER
index|]
operator|.
name|mb_clbucks
operator|)
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_types
operator|=
operator|&
operator|(
name|mb_statpcpu
index|[
name|MB_GENLIST_OWNER
index|]
operator|.
name|mb_mbtypes
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_types
operator|=
name|NULL
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
operator|(
name|mb_list_mbuf
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
operator|(
name|mb_list_clust
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate all the required counters for clusters.  This makes 	 * cluster allocations/deallocations much faster. 	 */
name|cl_refcntmap
operator|=
name|malloc
argument_list|(
name|nmbclusters
operator|*
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|,
name|M_MBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl_refcntmap
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * Initialize general mbuf statistics. 	 */
name|mbstat
operator|.
name|m_msize
operator|=
name|MSIZE
expr_stmt|;
name|mbstat
operator|.
name|m_mclbytes
operator|=
name|MCLBYTES
expr_stmt|;
name|mbstat
operator|.
name|m_minclsize
operator|=
name|MINCLSIZE
expr_stmt|;
name|mbstat
operator|.
name|m_mlen
operator|=
name|MLEN
expr_stmt|;
name|mbstat
operator|.
name|m_mhlen
operator|=
name|MHLEN
expr_stmt|;
name|mbstat
operator|.
name|m_numtypes
operator|=
name|MT_NTYPES
expr_stmt|;
name|mbstat
operator|.
name|m_mbperbuck
operator|=
name|MBUF_BUCK_SZ
operator|/
name|MSIZE
expr_stmt|;
name|mbstat
operator|.
name|m_clperbuck
operator|=
name|CLUST_BUCK_SZ
operator|/
name|MCLBYTES
expr_stmt|;
comment|/* 	 * Allocate and initialize PCPU containers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCPU
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|mb_statpcpu
index|[
name|i
index|]
operator|.
name|mb_active
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|mb_list_mbuf
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mb_pcpu_list
argument_list|)
argument_list|,
name|M_MBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mb_pcpu_list
argument_list|)
argument_list|,
name|M_MBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mb_list_mbuf
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mb_list_clust
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|==
name|NULL
operator|)
condition|)
goto|goto
name|bad
goto|;
name|mtx_init
argument_list|(
operator|&
name|mbuf_pcpu
index|[
name|i
index|]
argument_list|,
literal|"mbuf PCPU list lock"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_lock
operator|=
name|mb_list_clust
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_lock
operator|=
operator|&
name|mbuf_pcpu
index|[
name|i
index|]
expr_stmt|;
name|mb_statpcpu
index|[
name|i
index|]
operator|.
name|mb_active
operator|=
literal|1
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_numowner
operator|=
name|mb_list_clust
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_numowner
operator|=
name|i
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|=
name|mb_list_clust
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|=
literal|0
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|=
operator|&
operator|(
name|mb_statpcpu
index|[
name|i
index|]
operator|.
name|mb_mbfree
operator|)
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|=
operator|&
operator|(
name|mb_statpcpu
index|[
name|i
index|]
operator|.
name|mb_clfree
operator|)
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_numbucks
operator|=
operator|&
operator|(
name|mb_statpcpu
index|[
name|i
index|]
operator|.
name|mb_mbbucks
operator|)
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_numbucks
operator|=
operator|&
operator|(
name|mb_statpcpu
index|[
name|i
index|]
operator|.
name|mb_clbucks
operator|)
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_types
operator|=
operator|&
operator|(
name|mb_statpcpu
index|[
name|i
index|]
operator|.
name|mb_mbtypes
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_types
operator|=
name|NULL
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
operator|(
name|mb_list_mbuf
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
operator|(
name|mb_list_clust
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Perform initial allocations. 		 */
name|pcpu_cnt
operator|=
name|MB_GET_PCPU_LIST_NUM
argument_list|(
operator|&
name|mb_list_mbuf
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|MB_LOCK_CONT
argument_list|(
name|pcpu_cnt
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NMB_MBUF_INIT
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|mb_pop_cont
argument_list|(
operator|&
name|mb_list_mbuf
argument_list|,
name|M_DONTWAIT
argument_list|,
name|pcpu_cnt
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
block|}
name|MB_UNLOCK_CONT
argument_list|(
name|pcpu_cnt
argument_list|)
expr_stmt|;
name|pcpu_cnt
operator|=
name|MB_GET_PCPU_LIST_NUM
argument_list|(
operator|&
name|mb_list_clust
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|MB_LOCK_CONT
argument_list|(
name|pcpu_cnt
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NMB_CLUST_INIT
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|mb_pop_cont
argument_list|(
operator|&
name|mb_list_clust
argument_list|,
name|M_DONTWAIT
argument_list|,
name|pcpu_cnt
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
block|}
name|MB_UNLOCK_CONT
argument_list|(
name|pcpu_cnt
argument_list|)
expr_stmt|;
block|}
return|return;
name|bad
label|:
name|panic
argument_list|(
literal|"mbuf_init(): failed to initialize mbuf subsystem!"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Populate a given mbuf PCPU container with a bucket full of fresh new  * buffers.  Return a pointer to the new bucket (already in the container if  * successful), or return NULL on failure.  *  * LOCKING NOTES:  * PCPU container lock must be held when this is called.  * The lock is dropped here so that we can cleanly call the underlying VM  * code.  If we fail, we return with no locks held. If we succeed (i.e., return  * non-NULL), we return with the PCPU lock held, ready for allocation from  * the returned bucket.  */
end_comment

begin_function
specifier|static
name|struct
name|mb_bucket
modifier|*
name|mb_pop_cont
parameter_list|(
name|struct
name|mb_lstmngr
modifier|*
name|mb_list
parameter_list|,
name|int
name|how
parameter_list|,
name|struct
name|mb_pcpu_list
modifier|*
name|cnt_lst
parameter_list|)
block|{
name|struct
name|mb_bucket
modifier|*
name|bucket
decl_stmt|;
name|caddr_t
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|MB_UNLOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
comment|/* 	 * If our object's (finite) map is starved now (i.e., no more address 	 * space), bail out now. 	 */
if|if
condition|(
name|mb_list
operator|->
name|ml_mapfull
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bucket
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mb_bucket
argument_list|)
operator|+
name|mb_list
operator|->
name|ml_objbucks
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|M_MBUF
argument_list|,
name|how
operator|==
name|M_TRYWAIT
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
name|kmem_malloc
argument_list|(
name|mb_list
operator|->
name|ml_map
argument_list|,
name|mb_list
operator|->
name|ml_objsize
operator|*
name|mb_list
operator|->
name|ml_objbucks
argument_list|,
name|how
operator|==
name|M_TRYWAIT
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|bucket
argument_list|,
name|M_MBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|how
operator|==
name|M_TRYWAIT
condition|)
name|mb_list
operator|->
name|ml_mapfull
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bucket
operator|->
name|mb_numfree
operator|=
literal|0
expr_stmt|;
name|mb_list
operator|->
name|ml_btable
index|[
name|MB_BUCKET_INDX
argument_list|(
name|p
argument_list|,
name|mb_list
argument_list|)
index|]
operator|=
name|bucket
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mb_list
operator|->
name|ml_objbucks
condition|;
name|i
operator|++
control|)
block|{
name|bucket
operator|->
name|mb_free
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
name|bucket
operator|->
name|mb_numfree
operator|++
expr_stmt|;
name|p
operator|+=
name|mb_list
operator|->
name|ml_objsize
expr_stmt|;
block|}
name|MB_LOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
name|bucket
operator|->
name|mb_owner
operator|=
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_numowner
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|,
name|bucket
argument_list|,
name|mb_blist
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_numbucks
operator|)
operator|)
operator|++
expr_stmt|;
operator|*
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|)
operator|+=
name|bucket
operator|->
name|mb_numfree
expr_stmt|;
return|return
operator|(
name|bucket
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a network buffer.  * The general case is very easy.  Complications only arise if our PCPU  * container is empty.  Things get worse if the PCPU container is empty,  * the general container is empty, and we've run out of address space  * in our map; then we try to block if we're willing to (M_TRYWAIT).  */
end_comment

begin_function
specifier|static
name|__inline
name|void
modifier|*
name|mb_alloc
parameter_list|(
name|struct
name|mb_lstmngr
modifier|*
name|mb_list
parameter_list|,
name|int
name|how
parameter_list|,
name|short
name|type
parameter_list|,
name|short
name|persist
parameter_list|,
name|int
modifier|*
name|pers_list
parameter_list|)
block|{
specifier|static
name|int
name|last_report
decl_stmt|;
name|struct
name|mb_pcpu_list
modifier|*
name|cnt_lst
decl_stmt|;
name|struct
name|mb_bucket
modifier|*
name|bucket
decl_stmt|;
name|void
modifier|*
name|m
decl_stmt|;
comment|/* #ifdef INVARIANTS */
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|how
operator|&
operator|(
name|M_WAITOK
operator||
name|M_NOWAIT
operator||
name|M_DONTWAIT
operator||
name|M_TRYWAIT
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|!=
name|M_DONTWAIT
operator|&&
name|flags
operator|!=
name|M_TRYWAIT
condition|)
block|{
specifier|static
name|struct
name|timeval
name|lasterr
decl_stmt|;
specifier|static
name|int
name|curerr
decl_stmt|;
if|if
condition|(
name|ppsratecheck
argument_list|(
operator|&
name|lasterr
argument_list|,
operator|&
name|curerr
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Bad mbuf alloc flags: %x\n"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|backtrace
argument_list|()
expr_stmt|;
name|how
operator|=
name|M_TRYWAIT
expr_stmt|;
block|}
block|}
comment|/* #endif */
name|m
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|persist
operator|&
name|MBP_PERSISTENT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * If we're a "persistent" call, then the per-CPU #(pers_list) 		 * cache lock is already held, and we just need to refer to 		 * the correct cache descriptor. 		 */
name|cnt_lst
operator|=
name|MB_GET_PCPU_LIST_NUM
argument_list|(
name|mb_list
argument_list|,
operator|*
name|pers_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cnt_lst
operator|=
name|MB_GET_PCPU_LIST
argument_list|(
name|mb_list
argument_list|)
expr_stmt|;
name|MB_LOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bucket
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * This is the easy allocation case. We just grab an object 		 * from a bucket in the PCPU container. At worst, we 		 * have just emptied the bucket and so we remove it 		 * from the container. 		 */
name|MB_GET_OBJECT
argument_list|(
name|m
argument_list|,
name|bucket
argument_list|,
name|cnt_lst
argument_list|)
expr_stmt|;
name|MB_MBTYPES_INC
argument_list|(
name|cnt_lst
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If asked to persist, do not drop the lock. */
if|if
condition|(
operator|(
name|persist
operator|&
name|MBP_PERSIST
operator|)
operator|==
literal|0
condition|)
name|MB_UNLOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
else|else
operator|*
name|pers_list
operator|=
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_numowner
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mb_gen_list
modifier|*
name|gen_list
decl_stmt|;
comment|/* 		 * This is the less-common more difficult case. We must 		 * first verify if the general list has anything for us 		 * and if that also fails, we must allocate a page from 		 * the map and create a new bucket to place in our PCPU 		 * container (already locked). If the map is starved then 		 * we're really in for trouble, as we have to wait on 		 * the general container's condition variable. 		 */
name|gen_list
operator|=
name|MB_GET_GEN_LIST
argument_list|(
name|mb_list
argument_list|)
expr_stmt|;
name|MB_LOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bucket
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Give ownership of the bucket to our CPU's 			 * container, but only actually put the bucket 			 * in the container if it doesn't become free 			 * upon removing an mbuf from it. 			 */
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|,
name|mb_blist
argument_list|)
expr_stmt|;
name|bucket
operator|->
name|mb_owner
operator|=
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_numowner
expr_stmt|;
operator|(
operator|*
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_numbucks
operator|)
operator|)
operator|--
expr_stmt|;
operator|(
operator|*
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_numbucks
operator|)
operator|)
operator|++
expr_stmt|;
operator|*
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|)
operator|-=
name|bucket
operator|->
name|mb_numfree
expr_stmt|;
name|bucket
operator|->
name|mb_numfree
operator|--
expr_stmt|;
name|m
operator|=
name|bucket
operator|->
name|mb_free
index|[
operator|(
name|bucket
operator|->
name|mb_numfree
operator|)
index|]
expr_stmt|;
if|if
condition|(
name|bucket
operator|->
name|mb_numfree
operator|==
literal|0
condition|)
block|{
name|SLIST_NEXT
argument_list|(
name|bucket
argument_list|,
name|mb_blist
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|bucket
operator|->
name|mb_owner
operator||=
name|MB_BUCKET_FREE
expr_stmt|;
block|}
else|else
block|{
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|,
name|bucket
argument_list|,
name|mb_blist
argument_list|)
expr_stmt|;
operator|*
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|)
operator|+=
name|bucket
operator|->
name|mb_numfree
expr_stmt|;
block|}
name|MB_UNLOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
name|MB_MBTYPES_INC
argument_list|(
name|cnt_lst
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If asked to persist, do not drop the lock. */
if|if
condition|(
operator|(
name|persist
operator|&
name|MBP_PERSIST
operator|)
operator|==
literal|0
condition|)
name|MB_UNLOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
else|else
operator|*
name|pers_list
operator|=
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_numowner
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We'll have to allocate a new page. 			 */
name|MB_UNLOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|mb_pop_cont
argument_list|(
name|mb_list
argument_list|,
name|how
argument_list|,
name|cnt_lst
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket
operator|!=
name|NULL
condition|)
block|{
name|MB_GET_OBJECT
argument_list|(
name|m
argument_list|,
name|bucket
argument_list|,
name|cnt_lst
argument_list|)
expr_stmt|;
name|MB_MBTYPES_INC
argument_list|(
name|cnt_lst
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If asked to persist, do not drop the lock. */
if|if
condition|(
operator|(
name|persist
operator|&
name|MBP_PERSIST
operator|)
operator|==
literal|0
condition|)
name|MB_UNLOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
else|else
operator|*
name|pers_list
operator|=
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_numowner
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|how
operator|==
name|M_TRYWAIT
condition|)
block|{
comment|/* 				 	 * Absolute worst-case scenario. 					 * We block if we're willing to, but 					 * only after trying to steal from 					 * other lists. 					 */
name|m
operator|=
name|mb_alloc_wait
argument_list|(
name|mb_list
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX: No consistency. */
name|mbstat
operator|.
name|m_drops
operator|++
expr_stmt|;
if|if
condition|(
name|ticks
operator|<
name|last_report
operator|||
operator|(
name|ticks
operator|-
name|last_report
operator|)
operator|>=
name|hz
condition|)
block|{
name|last_report
operator|=
name|ticks
expr_stmt|;
name|printf
argument_list|(
literal|"All mbufs or mbuf clusters exhausted, please see tuning(7).\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
operator|(
name|persist
operator|&
name|MBP_PERSIST
operator|)
operator|!=
literal|0
condition|)
block|{
name|cnt_lst
operator|=
name|MB_GET_PCPU_LIST
argument_list|(
name|mb_list
argument_list|)
expr_stmt|;
name|MB_LOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
operator|*
name|pers_list
operator|=
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_numowner
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is the worst-case scenario called only if we're allocating with  * M_TRYWAIT.  We first drain all the protocols, then try to find an mbuf  * by looking in every PCPU container.  If we're still unsuccesful, we  * try the general container one last time and possibly block on our  * starved cv.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|mb_alloc_wait
parameter_list|(
name|struct
name|mb_lstmngr
modifier|*
name|mb_list
parameter_list|,
name|short
name|type
parameter_list|)
block|{
name|struct
name|mb_pcpu_list
modifier|*
name|cnt_lst
decl_stmt|;
name|struct
name|mb_gen_list
modifier|*
name|gen_list
decl_stmt|;
name|struct
name|mb_bucket
modifier|*
name|bucket
decl_stmt|;
name|void
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cv_ret
decl_stmt|;
comment|/* 	 * Try to reclaim mbuf-related objects (mbufs, clusters). 	 */
name|mb_reclaim
argument_list|()
expr_stmt|;
comment|/* 	 * Cycle all the PCPU containers. Increment starved counts if found 	 * empty. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCPU
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
name|cnt_lst
operator|=
name|MB_GET_PCPU_LIST_NUM
argument_list|(
name|mb_list
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|MB_LOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
comment|/* 		 * If container is non-empty, get a single object from it. 		 * If empty, increment starved count. 		 */
if|if
condition|(
operator|(
name|bucket
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|MB_GET_OBJECT
argument_list|(
name|m
argument_list|,
name|bucket
argument_list|,
name|cnt_lst
argument_list|)
expr_stmt|;
name|MB_MBTYPES_INC
argument_list|(
name|cnt_lst
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MB_UNLOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
name|mbstat
operator|.
name|m_wait
operator|++
expr_stmt|;
comment|/* XXX: No consistency. */
return|return
operator|(
name|m
operator|)
return|;
block|}
else|else
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|++
expr_stmt|;
name|MB_UNLOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We're still here, so that means it's time to get the general 	 * container lock, check it one more time (now that mb_reclaim() 	 * has been called) and if we still get nothing, block on the cv. 	 */
name|gen_list
operator|=
name|MB_GET_GEN_LIST
argument_list|(
name|mb_list
argument_list|)
expr_stmt|;
name|MB_LOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bucket
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|MB_GET_OBJECT
argument_list|(
name|m
argument_list|,
name|bucket
argument_list|,
name|gen_list
argument_list|)
expr_stmt|;
name|MB_MBTYPES_INC
argument_list|(
name|gen_list
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MB_UNLOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
name|mbstat
operator|.
name|m_wait
operator|++
expr_stmt|;
comment|/* XXX: No consistency. */
return|return
operator|(
name|m
operator|)
return|;
block|}
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|++
expr_stmt|;
name|cv_ret
operator|=
name|cv_timedwait
argument_list|(
operator|&
operator|(
name|gen_list
operator|->
name|mgl_mstarved
operator|)
argument_list|,
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_lock
argument_list|,
name|mbuf_wait
argument_list|)
expr_stmt|;
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|cv_ret
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|bucket
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|MB_GET_OBJECT
argument_list|(
name|m
argument_list|,
name|bucket
argument_list|,
name|gen_list
argument_list|)
expr_stmt|;
name|MB_MBTYPES_INC
argument_list|(
name|gen_list
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mbstat
operator|.
name|m_wait
operator|++
expr_stmt|;
comment|/* XXX: No consistency. */
block|}
else|else
block|{
name|mbstat
operator|.
name|m_drops
operator|++
expr_stmt|;
comment|/* XXX: No consistency. */
name|m
operator|=
name|NULL
expr_stmt|;
block|}
name|MB_UNLOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * Free an object to its rightful container.  * In the very general case, this operation is really very easy.  * Complications arise primarily if:  *	(a) We've hit the high limit on number of free objects allowed in  *	    our PCPU container.  *	(b) We're in a critical situation where our container has been  *	    marked 'starved' and we need to issue wakeups on the starved  *	    condition variable.  *	(c) Minor (odd) cases: our bucket has migrated while we were  *	    waiting for the lock; our bucket is in the general container;  *	    our bucket is empty.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|mb_free
parameter_list|(
name|struct
name|mb_lstmngr
modifier|*
name|mb_list
parameter_list|,
name|void
modifier|*
name|m
parameter_list|,
name|short
name|type
parameter_list|,
name|short
name|persist
parameter_list|,
name|int
modifier|*
name|pers_list
parameter_list|)
block|{
name|struct
name|mb_pcpu_list
modifier|*
name|cnt_lst
decl_stmt|;
name|struct
name|mb_gen_list
modifier|*
name|gen_list
decl_stmt|;
name|struct
name|mb_bucket
modifier|*
name|bucket
decl_stmt|;
name|u_int
name|owner
decl_stmt|;
name|bucket
operator|=
name|mb_list
operator|->
name|ml_btable
index|[
name|MB_BUCKET_INDX
argument_list|(
name|m
argument_list|,
name|mb_list
argument_list|)
index|]
expr_stmt|;
comment|/* 	 * Make sure that if after we lock the bucket's present container the 	 * bucket has migrated, that we drop the lock and get the new one. 	 */
name|retry_lock
label|:
name|owner
operator|=
name|bucket
operator|->
name|mb_owner
operator|&
operator|~
name|MB_BUCKET_FREE
expr_stmt|;
switch|switch
condition|(
name|owner
condition|)
block|{
case|case
name|MB_GENLIST_OWNER
case|:
name|gen_list
operator|=
name|MB_GET_GEN_LIST
argument_list|(
name|mb_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|persist
operator|&
name|MBP_PERSISTENT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|*
name|pers_list
operator|>=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|pers_list
operator|!=
name|MB_GENLIST_OWNER
condition|)
block|{
name|cnt_lst
operator|=
name|MB_GET_PCPU_LIST_NUM
argument_list|(
name|mb_list
argument_list|,
operator|*
name|pers_list
argument_list|)
expr_stmt|;
name|MB_UNLOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
name|MB_LOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|MB_LOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|owner
operator|!=
operator|(
name|bucket
operator|->
name|mb_owner
operator|&
operator|~
name|MB_BUCKET_FREE
operator|)
condition|)
block|{
name|MB_UNLOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
operator|*
name|pers_list
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|retry_lock
goto|;
block|}
comment|/* 		 * If we're intended for the general container, this is 		 * real easy: no migrating required. The only `bogon' 		 * is that we're now contending with all the threads 		 * dealing with the general list, but this is expected. 		 */
name|MB_PUT_OBJECT
argument_list|(
name|m
argument_list|,
name|bucket
argument_list|,
name|gen_list
argument_list|)
expr_stmt|;
name|MB_MBTYPES_DEC
argument_list|(
name|gen_list
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|>
literal|0
condition|)
name|cv_signal
argument_list|(
operator|&
operator|(
name|gen_list
operator|->
name|mgl_mstarved
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|persist
operator|&
name|MBP_PERSIST
operator|)
operator|==
literal|0
condition|)
name|MB_UNLOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
else|else
operator|*
name|pers_list
operator|=
name|MB_GENLIST_OWNER
expr_stmt|;
break|break;
default|default:
name|cnt_lst
operator|=
name|MB_GET_PCPU_LIST_NUM
argument_list|(
name|mb_list
argument_list|,
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|persist
operator|&
name|MBP_PERSISTENT
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|*
name|pers_list
operator|>=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|pers_list
operator|==
name|MB_GENLIST_OWNER
condition|)
block|{
name|gen_list
operator|=
name|MB_GET_GEN_LIST
argument_list|(
name|mb_list
argument_list|)
expr_stmt|;
name|MB_UNLOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
name|MB_LOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cnt_lst
operator|=
name|MB_GET_PCPU_LIST_NUM
argument_list|(
name|mb_list
argument_list|,
operator|*
name|pers_list
argument_list|)
expr_stmt|;
name|owner
operator|=
operator|*
name|pers_list
expr_stmt|;
block|}
block|}
else|else
block|{
name|MB_LOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|owner
operator|!=
operator|(
name|bucket
operator|->
name|mb_owner
operator|&
operator|~
name|MB_BUCKET_FREE
operator|)
condition|)
block|{
name|MB_UNLOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
operator|*
name|pers_list
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|retry_lock
goto|;
block|}
name|MB_PUT_OBJECT
argument_list|(
name|m
argument_list|,
name|bucket
argument_list|,
name|cnt_lst
argument_list|)
expr_stmt|;
name|MB_MBTYPES_DEC
argument_list|(
name|cnt_lst
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|>
literal|0
condition|)
block|{
comment|/* 			 * This is a tough case. It means that we've 			 * been flagged at least once to indicate that 			 * we're empty, and that the system is in a critical 			 * situation, so we ought to migrate at least one 			 * bucket over to the general container. 			 * There may or may not be a thread blocking on 			 * the starved condition variable, but chances 			 * are that one will eventually come up soon so 			 * it's better to migrate now than never. 			 */
name|gen_list
operator|=
name|MB_GET_GEN_LIST
argument_list|(
name|mb_list
argument_list|)
expr_stmt|;
name|MB_LOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|bucket
operator|->
name|mb_owner
operator|&
name|MB_BUCKET_FREE
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"mb_free: corrupt bucket %p\n"
operator|,
name|bucket
operator|)
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|,
name|bucket
argument_list|,
name|mb_blist
argument_list|)
expr_stmt|;
name|bucket
operator|->
name|mb_owner
operator|=
name|MB_GENLIST_OWNER
expr_stmt|;
operator|(
operator|*
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|)
operator|)
operator|--
expr_stmt|;
operator|(
operator|*
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|)
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_numbucks
operator|)
operator|)
operator|--
expr_stmt|;
operator|(
operator|*
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_numbucks
operator|)
operator|)
operator|++
expr_stmt|;
comment|/* 			 * Determine whether or not to keep transferring 			 * buckets to the general list or whether we've 			 * transferred enough already. 			 * We realize that although we may flag another 			 * bucket to be migrated to the general container 			 * that in the meantime, the thread that was 			 * blocked on the cv is already woken up and 			 * long gone. But in that case, the worst 			 * consequence is that we will end up migrating 			 * one bucket too many, which is really not a big 			 * deal, especially if we're close to a critical 			 * situation. 			 */
if|if
condition|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|>
literal|0
condition|)
block|{
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|--
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
operator|(
name|gen_list
operator|->
name|mgl_mstarved
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|=
literal|0
expr_stmt|;
name|MB_UNLOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|persist
operator|&
name|MBP_PERSIST
operator|)
operator|==
literal|0
condition|)
name|MB_UNLOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
else|else
operator|*
name|pers_list
operator|=
name|owner
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|)
operator|>
operator|*
operator|(
name|mb_list
operator|->
name|ml_wmhigh
operator|)
condition|)
block|{
comment|/* 			 * We've hit the high limit of allowed numbers of mbufs 			 * on this PCPU list. We must now migrate a bucket 			 * over to the general container. 			 */
name|gen_list
operator|=
name|MB_GET_GEN_LIST
argument_list|(
name|mb_list
argument_list|)
expr_stmt|;
name|MB_LOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bucket
operator|->
name|mb_owner
operator|&
name|MB_BUCKET_FREE
operator|)
operator|==
literal|0
condition|)
block|{
name|bucket
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|,
name|mb_blist
argument_list|)
expr_stmt|;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|,
name|bucket
argument_list|,
name|mb_blist
argument_list|)
expr_stmt|;
name|bucket
operator|->
name|mb_owner
operator|=
name|MB_GENLIST_OWNER
expr_stmt|;
operator|*
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|)
operator|-=
name|bucket
operator|->
name|mb_numfree
expr_stmt|;
operator|*
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|)
operator|+=
name|bucket
operator|->
name|mb_numfree
expr_stmt|;
operator|(
operator|*
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_numbucks
operator|)
operator|)
operator|--
expr_stmt|;
operator|(
operator|*
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_numbucks
operator|)
operator|)
operator|++
expr_stmt|;
comment|/* 			 * While we're at it, transfer some of the mbtypes 			 * "count load" onto the general list's mbtypes 			 * array, seeing as how we're moving the bucket 			 * there now, meaning that the freeing of objects 			 * there will now decrement the _general list's_ 			 * mbtypes counters, and no longer our PCPU list's 			 * mbtypes counters. We do this for the type presently 			 * being freed in an effort to keep the mbtypes 			 * counters approximately balanced across all lists. 			 */
name|MB_MBTYPES_DEC
argument_list|(
name|cnt_lst
argument_list|,
name|type
argument_list|,
name|mb_list
operator|->
name|ml_objbucks
operator|-
name|bucket
operator|->
name|mb_numfree
argument_list|)
expr_stmt|;
name|MB_MBTYPES_INC
argument_list|(
name|gen_list
argument_list|,
name|type
argument_list|,
name|mb_list
operator|->
name|ml_objbucks
operator|-
name|bucket
operator|->
name|mb_numfree
argument_list|)
expr_stmt|;
name|MB_UNLOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|persist
operator|&
name|MBP_PERSIST
operator|)
operator|==
literal|0
condition|)
name|MB_UNLOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
else|else
operator|*
name|pers_list
operator|=
name|owner
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bucket
operator|->
name|mb_owner
operator|&
name|MB_BUCKET_FREE
condition|)
block|{
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|,
name|bucket
argument_list|,
name|mb_blist
argument_list|)
expr_stmt|;
name|bucket
operator|->
name|mb_owner
operator|=
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_numowner
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|persist
operator|&
name|MBP_PERSIST
operator|)
operator|==
literal|0
condition|)
name|MB_UNLOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
else|else
operator|*
name|pers_list
operator|=
name|owner
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Drain protocols in hopes to free up some resources.  *  * LOCKING NOTES:  * No locks should be held when this is called.  The drain routines have to  * presently acquire some locks which raises the possibility of lock order  * violation if we're holding any mutex if that mutex is acquired in reverse  * order relative to one of the locks in the drain routines.  */
end_comment

begin_function
specifier|static
name|void
name|mb_reclaim
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|domain
modifier|*
name|dp
decl_stmt|;
name|struct
name|protosw
modifier|*
name|pr
decl_stmt|;
name|WITNESS_WARN
argument_list|(
name|WARN_GIANTOK
operator||
name|WARN_SLEEPOK
operator||
name|WARN_PANIC
argument_list|,
name|NULL
argument_list|,
literal|"mb_reclaim()"
argument_list|)
expr_stmt|;
name|mbstat
operator|.
name|m_drain
operator|++
expr_stmt|;
comment|/* XXX: No consistency. */
for|for
control|(
name|dp
operator|=
name|domains
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|dom_next
control|)
for|for
control|(
name|pr
operator|=
name|dp
operator|->
name|dom_protosw
init|;
name|pr
operator|<
name|dp
operator|->
name|dom_protoswNPROTOSW
condition|;
name|pr
operator|++
control|)
if|if
condition|(
name|pr
operator|->
name|pr_drain
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|pr
operator|->
name|pr_drain
call|)
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Internal setup macros.  */
end_comment

begin_define
define|#
directive|define
name|_mb_setup
parameter_list|(
name|m
parameter_list|,
name|type
parameter_list|)
value|do {						\ 	(m)->m_type = (type);						\ 	(m)->m_next = NULL;						\ 	(m)->m_nextpkt = NULL;						\ 	(m)->m_data = (m)->m_dat;					\ 	(m)->m_flags = 0;						\ } while (0)
end_define

begin_define
define|#
directive|define
name|_mbhdr_setup
parameter_list|(
name|m
parameter_list|,
name|type
parameter_list|)
value|do {					\ 	(m)->m_type = (type);						\ 	(m)->m_next = NULL;						\ 	(m)->m_nextpkt = NULL;						\ 	(m)->m_data = (m)->m_pktdat;					\ 	(m)->m_flags = M_PKTHDR;					\ 	(m)->m_pkthdr.rcvif = NULL;					\ 	(m)->m_pkthdr.csum_flags = 0;					\ 	SLIST_INIT(&(m)->m_pkthdr.tags);				\ } while (0)
end_define

begin_define
define|#
directive|define
name|_mcl_setup
parameter_list|(
name|m
parameter_list|)
value|do {						\ 	(m)->m_data = (m)->m_ext.ext_buf;				\ 	(m)->m_flags |= M_EXT;						\ 	(m)->m_ext.ext_free = NULL;					\ 	(m)->m_ext.ext_args = NULL;					\ 	(m)->m_ext.ext_size = MCLBYTES;					\ 	(m)->m_ext.ext_type = EXT_CLUSTER;				\ } while (0)
end_define

begin_define
define|#
directive|define
name|_mext_init_ref
parameter_list|(
name|m
parameter_list|,
name|ref
parameter_list|)
value|do {					\ 	(m)->m_ext.ref_cnt = ((ref) == NULL) ?				\ 	    malloc(sizeof(u_int), M_MBUF, M_NOWAIT) : (u_int *)(ref);	\ 	if ((m)->m_ext.ref_cnt != NULL) {				\ 		*((m)->m_ext.ref_cnt) = 0;				\ 		MEXT_ADD_REF((m));					\ 	}								\ } while (0)
end_define

begin_define
define|#
directive|define
name|cl2ref
parameter_list|(
name|cl
parameter_list|)
define|\
value|(((uintptr_t)(cl) - (uintptr_t)mb_list_clust.ml_mapbase)>> MCLSHIFT)
end_define

begin_define
define|#
directive|define
name|_mext_dealloc_ref
parameter_list|(
name|m
parameter_list|)
define|\
value|if ((m)->m_ext.ext_type != EXT_EXTREF)				\ 		free((m)->m_ext.ref_cnt, M_MBUF)
end_define

begin_comment
comment|/******************************************************************************  * Internal routines.  *   * Because mb_alloc() and mb_free() are inlines (to keep the common  * cases down to a maximum of one function call), below are a few  * routines used only internally for the sole purpose of making certain  * functions smaller.  *  * - _mext_free(): frees associated storage when the ref. count is  *   exactly one and we're freeing.  *  * - _mgetm_internal(): common "persistent-lock" routine that allocates  *   an mbuf and a cluster in one shot, but where the lock is already  *   held coming in (which is what makes it different from the exported  *   m_getcl()).  The lock is dropped when done.  This is used by m_getm()  *   and, therefore, is very m_getm()-specific.  */
end_comment

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|_mgetm_internal
parameter_list|(
name|int
parameter_list|,
name|short
parameter_list|,
name|short
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|_mext_free
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mb
parameter_list|)
block|{
if|if
condition|(
name|mb
operator|->
name|m_ext
operator|.
name|ext_type
operator|==
name|EXT_CLUSTER
condition|)
block|{
name|mb_free
argument_list|(
operator|&
name|mb_list_clust
argument_list|,
operator|(
name|caddr_t
operator|)
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|,
name|MT_NOTMBUF
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
operator|(
name|mb
operator|->
name|m_ext
operator|.
name|ext_free
operator|)
operator|)
operator|(
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
operator|,
name|mb
operator|->
name|m_ext
operator|.
name|ext_args
operator|)
expr_stmt|;
name|_mext_dealloc_ref
argument_list|(
name|mb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|_mgetm_internal
parameter_list|(
name|int
name|how
parameter_list|,
name|short
name|type
parameter_list|,
name|short
name|persist
parameter_list|,
name|int
name|cchnum
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|mb
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|mb_alloc
argument_list|(
operator|&
name|mb_list_mbuf
argument_list|,
name|how
argument_list|,
name|type
argument_list|,
name|persist
argument_list|,
operator|&
name|cchnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|_mb_setup
argument_list|(
name|mb
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|persist
operator|&
name|MBP_PERSIST
operator|)
operator|!=
literal|0
condition|)
block|{
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
operator|=
operator|(
name|caddr_t
operator|)
name|mb_alloc
argument_list|(
operator|&
name|mb_list_clust
argument_list|,
name|how
argument_list|,
name|MT_NOTMBUF
argument_list|,
name|MBP_PERSISTENT
argument_list|,
operator|&
name|cchnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|mb
argument_list|)
expr_stmt|;
name|mb
operator|=
name|NULL
expr_stmt|;
block|}
name|_mcl_setup
argument_list|(
name|mb
argument_list|)
expr_stmt|;
name|_mext_init_ref
argument_list|(
name|mb
argument_list|,
operator|&
name|cl_refcntmap
index|[
name|cl2ref
argument_list|(
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mb
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************  * Exported buffer allocation and de-allocation routines.  */
end_comment

begin_comment
comment|/*  * Allocate and return a single (normal) mbuf.  NULL is returned on failure.  *  * Arguments:  *  - how: M_TRYWAIT to try to block for kern.ipc.mbuf_wait number of ticks  *    if really starved for memory.  M_DONTWAIT to never block.  *  - type: the type of the mbuf being allocated.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|m_get
parameter_list|(
name|int
name|how
parameter_list|,
name|short
name|type
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|mb
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|mb_alloc
argument_list|(
operator|&
name|mb_list_mbuf
argument_list|,
name|how
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|!=
name|NULL
condition|)
name|_mb_setup
argument_list|(
name|mb
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|mb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a given length worth of mbufs and/or clusters (whatever fits  * best) and return a pointer to the top of the allocated chain.  If an  * existing mbuf chain is provided, then we will append the new chain  * to the existing one but still return the top of the newly allocated  * chain.  NULL is returned on failure, in which case the [optional]  * provided chain is left untouched, and any memory already allocated  * is freed.  *  * Arguments:  *  - m: existing chain to which to append new chain (optional).  *  - len: total length of data to append, either in mbufs or clusters  *    (we allocate whatever combination yields the best fit).  *  - how: M_TRYWAIT to try to block for kern.ipc.mbuf_wait number of ticks  *    if really starved for memory.  M_DONTWAIT to never block.  *  - type: the type of the mbuf being allocated.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|m_getm
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|how
parameter_list|,
name|short
name|type
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|,
modifier|*
name|top
decl_stmt|,
modifier|*
name|cur
decl_stmt|,
modifier|*
name|mtail
decl_stmt|;
name|int
name|num
decl_stmt|,
name|rem
decl_stmt|,
name|cchnum
decl_stmt|;
name|short
name|persist
decl_stmt|;
name|int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|len
operator|>=
literal|0
argument_list|,
operator|(
literal|"m_getm(): len is< 0"
operator|)
argument_list|)
expr_stmt|;
comment|/* If m != NULL, we will append to the end of that chain. */
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
for|for
control|(
name|mtail
operator|=
name|m
init|;
name|mtail
operator|->
name|m_next
operator|!=
name|NULL
condition|;
name|mtail
operator|=
name|mtail
operator|->
name|m_next
control|)
empty_stmt|;
else|else
name|mtail
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * In the best-case scenario (which should be the common case 	 * unless we're in a starvation situation), we will be able to 	 * go through the allocation of all the desired mbufs and clusters 	 * here without dropping our per-CPU cache lock in between. 	 */
name|num
operator|=
name|len
operator|/
name|MCLBYTES
expr_stmt|;
name|rem
operator|=
name|len
operator|%
name|MCLBYTES
expr_stmt|;
name|persist
operator|=
literal|0
expr_stmt|;
name|cchnum
operator|=
operator|-
literal|1
expr_stmt|;
name|top
operator|=
name|cur
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|mb
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|mb_alloc
argument_list|(
operator|&
name|mb_list_mbuf
argument_list|,
name|how
argument_list|,
name|type
argument_list|,
name|MBP_PERSIST
operator||
name|persist
argument_list|,
operator|&
name|cchnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
name|_mb_setup
argument_list|(
name|mb
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|mb
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|persist
operator|=
operator|(
name|i
operator|!=
operator|(
name|num
operator|-
literal|1
operator|)
operator|||
name|rem
operator|>
literal|0
operator|)
condition|?
name|MBP_PERSIST
else|:
literal|0
expr_stmt|;
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
operator|=
operator|(
name|caddr_t
operator|)
name|mb_alloc
argument_list|(
operator|&
name|mb_list_clust
argument_list|,
name|how
argument_list|,
name|MT_NOTMBUF
argument_list|,
name|persist
operator||
name|MBP_PERSISTENT
argument_list|,
operator|&
name|cchnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|mb
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|_mcl_setup
argument_list|(
name|mb
argument_list|)
expr_stmt|;
name|_mext_init_ref
argument_list|(
name|mb
argument_list|,
operator|&
name|cl_refcntmap
index|[
name|cl2ref
argument_list|(
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|persist
operator|=
name|MBP_PERSISTENT
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
name|top
operator|=
name|cur
operator|=
name|mb
expr_stmt|;
else|else
name|cur
operator|=
operator|(
name|cur
operator|->
name|m_next
operator|=
name|mb
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|rem
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cchnum
operator|>=
literal|0
condition|)
block|{
name|persist
operator|=
name|MBP_PERSISTENT
expr_stmt|;
name|persist
operator||=
operator|(
name|rem
operator|>
name|MINCLSIZE
operator|)
condition|?
name|MBP_PERSIST
else|:
literal|0
expr_stmt|;
name|mb
operator|=
name|_mgetm_internal
argument_list|(
name|how
argument_list|,
name|type
argument_list|,
name|persist
argument_list|,
name|cchnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
block|}
elseif|else
if|if
condition|(
name|rem
operator|>
name|MINCLSIZE
condition|)
block|{
name|mb
operator|=
name|m_getcl
argument_list|(
name|how
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mb
operator|=
name|m_get
argument_list|(
name|how
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mb
operator|!=
name|NULL
condition|)
block|{
name|mb
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
name|top
operator|=
name|mb
expr_stmt|;
else|else
name|cur
operator|->
name|m_next
operator|=
name|mb
expr_stmt|;
block|}
else|else
goto|goto
name|failed
goto|;
block|}
if|if
condition|(
name|mtail
operator|!=
name|NULL
condition|)
name|mtail
operator|->
name|m_next
operator|=
name|top
expr_stmt|;
return|return
name|top
return|;
name|failed
label|:
if|if
condition|(
name|top
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate and return a single M_PKTHDR mbuf.  NULL is returned on failure.  *  * Arguments:  *  - how: M_TRYWAIT to try to block for kern.ipc.mbuf_wait number of ticks  *    if really starved for memory.  M_DONTWAIT to never block.  *  - type: the type of the mbuf being allocated.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|m_gethdr
parameter_list|(
name|int
name|how
parameter_list|,
name|short
name|type
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|mb
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|mb_alloc
argument_list|(
operator|&
name|mb_list_mbuf
argument_list|,
name|how
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|!=
name|NULL
condition|)
block|{
name|_mbhdr_setup
argument_list|(
name|mb
argument_list|,
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
name|mac_init_mbuf
argument_list|(
name|mb
argument_list|,
name|how
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_free
argument_list|(
name|mb
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
block|}
return|return
operator|(
name|mb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate and return a single (normal) pre-zero'd mbuf.  NULL is  * returned on failure.  *  * Arguments:  *  - how: M_TRYWAIT to try to block for kern.ipc.mbuf_wait number of ticks  *    if really starved for memory.  M_DONTWAIT to never block.  *  - type: the type of the mbuf being allocated.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|m_get_clrd
parameter_list|(
name|int
name|how
parameter_list|,
name|short
name|type
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|mb
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|mb_alloc
argument_list|(
operator|&
name|mb_list_mbuf
argument_list|,
name|how
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|!=
name|NULL
condition|)
block|{
name|_mb_setup
argument_list|(
name|mb
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mtod
argument_list|(
name|mb
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|MLEN
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate and return a single M_PKTHDR pre-zero'd mbuf.  NULL is  * returned on failure.  *  * Arguments:  *  - how: M_TRYWAIT to try to block for kern.ipc.mbuf_wait number of ticks  *    if really starved for memory.  M_DONTWAIT to never block.  *  - type: the type of the mbuf being allocated.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|m_gethdr_clrd
parameter_list|(
name|int
name|how
parameter_list|,
name|short
name|type
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|mb
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|mb_alloc
argument_list|(
operator|&
name|mb_list_mbuf
argument_list|,
name|how
argument_list|,
name|type
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|!=
name|NULL
condition|)
block|{
name|_mbhdr_setup
argument_list|(
name|mb
argument_list|,
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
name|mac_init_mbuf
argument_list|(
name|mb
argument_list|,
name|how
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_free
argument_list|(
name|mb
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
name|bzero
argument_list|(
name|mtod
argument_list|(
name|mb
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|MHLEN
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a single mbuf and any associated storage that it may have attached  * to it.  The associated storage may not be immediately freed if its  * reference count is above 1.  Returns the next mbuf in the chain following  * the mbuf being freed.  *  * Arguments:  *  - mb: the mbuf to free.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|m_free
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mb
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|nb
decl_stmt|;
name|int
name|cchnum
decl_stmt|;
name|short
name|persist
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|mb
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|!=
literal|0
condition|)
name|m_tag_delete_chain
argument_list|(
name|mb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
operator|(
name|mb
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|&&
operator|(
name|mb
operator|->
name|m_pkthdr
operator|.
name|label
operator|.
name|l_flags
operator|&
name|MAC_FLAG_INITIALIZED
operator|)
condition|)
name|mac_destroy_mbuf
argument_list|(
name|mb
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nb
operator|=
name|mb
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
operator|(
name|mb
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|!=
literal|0
condition|)
block|{
name|MEXT_REM_REF
argument_list|(
name|mb
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_cmpset_int
argument_list|(
name|mb
operator|->
name|m_ext
operator|.
name|ref_cnt
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|mb
operator|->
name|m_ext
operator|.
name|ext_type
operator|==
name|EXT_CLUSTER
condition|)
block|{
name|mb_free
argument_list|(
operator|&
name|mb_list_clust
argument_list|,
operator|(
name|caddr_t
operator|)
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|,
name|MT_NOTMBUF
argument_list|,
name|MBP_PERSIST
argument_list|,
operator|&
name|cchnum
argument_list|)
expr_stmt|;
name|persist
operator|=
name|MBP_PERSISTENT
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
operator|(
name|mb
operator|->
name|m_ext
operator|.
name|ext_free
operator|)
operator|)
operator|(
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
operator|,
name|mb
operator|->
name|m_ext
operator|.
name|ext_args
operator|)
expr_stmt|;
name|_mext_dealloc_ref
argument_list|(
name|mb
argument_list|)
expr_stmt|;
name|persist
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|mb_free
argument_list|(
operator|&
name|mb_list_mbuf
argument_list|,
name|mb
argument_list|,
name|mb
operator|->
name|m_type
argument_list|,
name|persist
argument_list|,
operator|&
name|cchnum
argument_list|)
expr_stmt|;
return|return
operator|(
name|nb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free an entire chain of mbufs and associated external buffers, if  * applicable.  Right now, we only optimize a little so that the cache  * lock may be held across a single mbuf+cluster free.  Hopefully,  * we'll eventually be holding the lock across more than merely two  * consecutive frees but right now this is hard to implement because of  * things like _mext_dealloc_ref (may do a free()) and atomic ops in the  * loop.  *  *  - mb: the mbuf chain to free.  */
end_comment

begin_function
name|void
name|m_freem
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mb
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|cchnum
decl_stmt|;
name|short
name|persist
decl_stmt|;
while|while
condition|(
name|mb
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|mb
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|!=
literal|0
condition|)
name|m_tag_delete_chain
argument_list|(
name|mb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
operator|(
name|mb
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|&&
operator|(
name|mb
operator|->
name|m_pkthdr
operator|.
name|label
operator|.
name|l_flags
operator|&
name|MAC_FLAG_INITIALIZED
operator|)
condition|)
name|mac_destroy_mbuf
argument_list|(
name|mb
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|persist
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|mb
expr_stmt|;
name|mb
operator|=
name|mb
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|!=
literal|0
condition|)
block|{
name|MEXT_REM_REF
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_cmpset_int
argument_list|(
name|m
operator|->
name|m_ext
operator|.
name|ref_cnt
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_ext
operator|.
name|ext_type
operator|==
name|EXT_CLUSTER
condition|)
block|{
name|mb_free
argument_list|(
operator|&
name|mb_list_clust
argument_list|,
operator|(
name|caddr_t
operator|)
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|,
name|MT_NOTMBUF
argument_list|,
name|MBP_PERSIST
argument_list|,
operator|&
name|cchnum
argument_list|)
expr_stmt|;
name|persist
operator|=
name|MBP_PERSISTENT
expr_stmt|;
block|}
else|else
block|{
operator|(
operator|*
operator|(
name|m
operator|->
name|m_ext
operator|.
name|ext_free
operator|)
operator|)
operator|(
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
operator|,
name|m
operator|->
name|m_ext
operator|.
name|ext_args
operator|)
expr_stmt|;
name|_mext_dealloc_ref
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|persist
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|mb_free
argument_list|(
operator|&
name|mb_list_mbuf
argument_list|,
name|m
argument_list|,
name|m
operator|->
name|m_type
argument_list|,
name|persist
argument_list|,
operator|&
name|cchnum
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Fetch an mbuf with a cluster attached to it.  If one of the  * allocations fails, the entire allocation fails.  This routine is  * the preferred way of fetching both the mbuf and cluster together,  * as it avoids having to unlock/relock between allocations.  Returns  * NULL on failure.   *  * Arguments:  *  - how: M_TRYWAIT to try to block for kern.ipc.mbuf_wait number of ticks  *    if really starved for memory.  M_DONTWAIT to never block.  *  - type: the type of the mbuf being allocated.  *  - flags: any flags to pass to the mbuf being allocated; if this includes  *    the M_PKTHDR bit, then the mbuf is configured as a M_PKTHDR mbuf.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|m_getcl
parameter_list|(
name|int
name|how
parameter_list|,
name|short
name|type
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|int
name|cchnum
decl_stmt|;
name|mb
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|mb_alloc
argument_list|(
operator|&
name|mb_list_mbuf
argument_list|,
name|how
argument_list|,
name|type
argument_list|,
name|MBP_PERSIST
argument_list|,
operator|&
name|cchnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|mb
operator|->
name|m_type
operator|=
name|type
expr_stmt|;
name|mb
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|mb
operator|->
name|m_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|M_PKTHDR
operator|)
operator|!=
literal|0
condition|)
block|{
name|mb
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|mb
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|mb
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|mb
operator|->
name|m_pkthdr
operator|.
name|tags
argument_list|)
expr_stmt|;
block|}
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
operator|=
operator|(
name|caddr_t
operator|)
name|mb_alloc
argument_list|(
operator|&
name|mb_list_clust
argument_list|,
name|how
argument_list|,
name|MT_NOTMBUF
argument_list|,
name|MBP_PERSISTENT
argument_list|,
operator|&
name|cchnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|mb
argument_list|)
expr_stmt|;
name|mb
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|_mcl_setup
argument_list|(
name|mb
argument_list|)
expr_stmt|;
name|_mext_init_ref
argument_list|(
name|mb
argument_list|,
operator|&
name|cl_refcntmap
index|[
name|cl2ref
argument_list|(
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
operator|(
name|flags
operator|&
name|M_PKTHDR
operator|)
operator|&&
operator|(
name|mac_init_mbuf
argument_list|(
name|mb
argument_list|,
name|how
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|m_free
argument_list|(
name|mb
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|mb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fetch a single mbuf cluster and attach it to an existing mbuf.  If  * successfull, configures the provided mbuf to have mbuf->m_ext.ext_buf  * pointing to the cluster, and sets the M_EXT bit in the mbuf's flags.  * The M_EXT bit is not set on failure.  *  * Arguments:  *  - mb: the existing mbuf to which to attach the allocated cluster.  *  - how: M_TRYWAIT to try to block for kern.ipc.mbuf_wait number of ticks  *    if really starved for memory.  M_DONTWAIT to never block.  */
end_comment

begin_function
name|void
name|m_clget
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mb
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
operator|=
operator|(
name|caddr_t
operator|)
name|mb_alloc
argument_list|(
operator|&
name|mb_list_clust
argument_list|,
name|how
argument_list|,
name|MT_NOTMBUF
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
operator|!=
name|NULL
condition|)
block|{
name|_mcl_setup
argument_list|(
name|mb
argument_list|)
expr_stmt|;
name|_mext_init_ref
argument_list|(
name|mb
argument_list|,
operator|&
name|cl_refcntmap
index|[
name|cl2ref
argument_list|(
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Configure a provided mbuf to refer to the provided external storage  * buffer and setup a reference count for said buffer.  If the setting  * up of the reference count fails, the M_EXT bit will not be set.  If  * successfull, the M_EXT bit is set in the mbuf's flags.  *  * Arguments:  *  - mb: the existing mbuf to which to attach the provided buffer.  *  - buf: the address of the provided external storage buffer.  *  - size: the size of the provided buffer.  *  - freef: a pointer to a routine that is responsible for freeing the  *    provided external storage buffer.  *  - args: a pointer to an argument structure (of any type) to be passed  *    to the provided freef routine (may be NULL).  *  - flags: any other flags to be passed to the provided mbuf.  *  - type: the type that the external storage buffer should be labeled with.  */
end_comment

begin_function
name|void
name|m_extadd
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mb
parameter_list|,
name|caddr_t
name|buf
parameter_list|,
name|u_int
name|size
parameter_list|,
name|void
function_decl|(
modifier|*
name|freef
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|u_int
modifier|*
name|ref_cnt
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|EXT_CLUSTER
condition|)
name|ref_cnt
operator|=
operator|&
name|cl_refcntmap
index|[
name|cl2ref
argument_list|(
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|)
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|type
operator|==
name|EXT_EXTREF
condition|)
name|ref_cnt
operator|=
name|mb
operator|->
name|m_ext
operator|.
name|ref_cnt
expr_stmt|;
name|_mext_init_ref
argument_list|(
name|mb
argument_list|,
name|ref_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|->
name|m_ext
operator|.
name|ref_cnt
operator|!=
name|NULL
condition|)
block|{
name|mb
operator|->
name|m_flags
operator||=
operator|(
name|M_EXT
operator||
name|flags
operator|)
expr_stmt|;
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
operator|=
name|buf
expr_stmt|;
name|mb
operator|->
name|m_data
operator|=
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
name|mb
operator|->
name|m_ext
operator|.
name|ext_size
operator|=
name|size
expr_stmt|;
name|mb
operator|->
name|m_ext
operator|.
name|ext_free
operator|=
name|freef
expr_stmt|;
name|mb
operator|->
name|m_ext
operator|.
name|ext_args
operator|=
name|args
expr_stmt|;
name|mb
operator|->
name|m_ext
operator|.
name|ext_type
operator|=
name|type
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Change type of provided mbuf.  This is a relatively expensive operation  * (due to the cost of statistics manipulations) and should be avoided, where  * possible.  *  * Arguments:  *  - mb: the provided mbuf for which the type needs to be changed.  *  - new_type: the new type to change the mbuf to.  */
end_comment

begin_function
name|void
name|m_chtype
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mb
parameter_list|,
name|short
name|new_type
parameter_list|)
block|{
name|struct
name|mb_gen_list
modifier|*
name|gen_list
decl_stmt|;
name|gen_list
operator|=
name|MB_GET_GEN_LIST
argument_list|(
operator|&
name|mb_list_mbuf
argument_list|)
expr_stmt|;
name|MB_LOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
name|MB_MBTYPES_DEC
argument_list|(
name|gen_list
argument_list|,
name|mb
operator|->
name|m_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MB_MBTYPES_INC
argument_list|(
name|gen_list
argument_list|,
name|new_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MB_UNLOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
name|mb
operator|->
name|m_type
operator|=
name|new_type
expr_stmt|;
block|}
end_function

end_unit

