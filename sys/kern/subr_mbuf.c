begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001  * 	Bosko Milekic<bmilekic@FreeBSD.org>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.   *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_param.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_comment
comment|/*  * Maximum number of PCPU containers. If you know what you're doing you could  * explicitly define MBALLOC_NCPU to be exactly the number of CPUs on your  * system during compilation, and thus prevent kernel structure bloat.  *  * SMP and non-SMP kernels clearly have a different number of possible CPUs,  * but because we cannot assume a dense array of CPUs, we always allocate  * and traverse PCPU containers up to NCPU amount and merely check for  * CPU availability.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MBALLOC_NCPU
end_ifdef

begin_define
define|#
directive|define
name|NCPU
value|MBALLOC_NCPU
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NCPU
value|MAXCPU
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-  * The mbuf allocator is heavily based on Alfred Perlstein's  * (alfred@FreeBSD.org) "memcache" allocator which is itself based  * on concepts from several per-CPU memory allocators. The difference  * between this allocator and memcache is that, among other things:  *  * (i) We don't free back to the map from the free() routine - we leave the  *     option of implementing lazy freeing (from a kproc) in the future.   *  * (ii) We allocate from separate sub-maps of kmem_map, thus limiting the  *	maximum number of allocatable objects of a given type. Further,  *	we handle blocking on a cv in the case that the map is starved and  *	we have to rely solely on cached (circulating) objects.  *  * The mbuf allocator keeps all objects that it allocates in mb_buckets.  * The buckets keep a page worth of objects (an object can be an mbuf or an  * mbuf cluster) and facilitate moving larger sets of contiguous objects  * from the per-CPU lists to the main list for the given object. The buckets  * also have an added advantage in that after several moves from a per-CPU  * list to the main list and back to the per-CPU list, contiguous objects  * are kept together, thus trying to put the TLB cache to good use.  *  * The buckets are kept on singly-linked lists called "containers." A container  * is protected by a mutex lock in order to ensure consistency.  The mutex lock  * itself is allocated seperately and attached to the container at boot time,  * thus allowing for certain containers to share the same mutex lock.  Per-CPU  * containers for mbufs and mbuf clusters all share the same per-CPU  * lock whereas the "general system" containers (i.e., the "main lists") for  * these objects share one global lock.  */
end_comment

begin_struct
struct|struct
name|mb_bucket
block|{
name|SLIST_ENTRY
argument_list|(
argument|mb_bucket
argument_list|)
name|mb_blist
expr_stmt|;
name|int
name|mb_owner
decl_stmt|;
name|int
name|mb_numfree
decl_stmt|;
name|void
modifier|*
name|mb_free
index|[
literal|0
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mb_container
block|{
name|SLIST_HEAD
argument_list|(
argument|mc_buckethd
argument_list|,
argument|mb_bucket
argument_list|)
name|mc_bhead
expr_stmt|;
name|struct
name|mtx
modifier|*
name|mc_lock
decl_stmt|;
name|int
name|mc_numowner
decl_stmt|;
name|u_int
name|mc_starved
decl_stmt|;
name|long
modifier|*
name|mc_types
decl_stmt|;
name|u_long
modifier|*
name|mc_objcount
decl_stmt|;
name|u_long
modifier|*
name|mc_numpgs
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mb_gen_list
block|{
name|struct
name|mb_container
name|mb_cont
decl_stmt|;
name|struct
name|cv
name|mgl_mstarved
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mb_pcpu_list
block|{
name|struct
name|mb_container
name|mb_cont
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Boot-time configurable object counts that will determine the maximum  * number of permitted objects in the mbuf and mcluster cases.  In the  * ext counter (nmbcnt) case, it's just an indicator serving to scale  * kmem_map size properly - in other words, we may be allowed to allocate  * more than nmbcnt counters, whereas we will never be allowed to allocate  * more than nmbufs mbufs or nmbclusters mclusters.  * As for nsfbufs, it is used to indicate how many sendfile(2) buffers will be  * allocatable by the sfbuf allocator (found in uipc_syscalls.c)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NMBCLUSTERS
end_ifndef

begin_define
define|#
directive|define
name|NMBCLUSTERS
value|(1024 + maxusers * 64)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NMBUFS
end_ifndef

begin_define
define|#
directive|define
name|NMBUFS
value|(nmbclusters * 2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NSFBUFS
end_ifndef

begin_define
define|#
directive|define
name|NSFBUFS
value|(512 + maxusers * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NMBCNTS
end_ifndef

begin_define
define|#
directive|define
name|NMBCNTS
value|(nmbclusters + nsfbufs)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|nmbufs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nmbclusters
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nmbcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nsfbufs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Perform sanity checks of tunables declared above.  */
end_comment

begin_function
specifier|static
name|void
name|tunable_mbinit
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
comment|/* 	 * This has to be done before VM init. 	 */
name|nmbclusters
operator|=
name|NMBCLUSTERS
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.nmbclusters"
argument_list|,
operator|&
name|nmbclusters
argument_list|)
expr_stmt|;
name|nmbufs
operator|=
name|NMBUFS
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.nmbufs"
argument_list|,
operator|&
name|nmbufs
argument_list|)
expr_stmt|;
name|nsfbufs
operator|=
name|NSFBUFS
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.nsfbufs"
argument_list|,
operator|&
name|nsfbufs
argument_list|)
expr_stmt|;
name|nmbcnt
operator|=
name|NMBCNTS
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.nmbcnt"
argument_list|,
operator|&
name|nmbcnt
argument_list|)
expr_stmt|;
comment|/* Sanity checks */
if|if
condition|(
name|nmbufs
operator|<
name|nmbclusters
operator|*
literal|2
condition|)
name|nmbufs
operator|=
name|nmbclusters
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|nmbcnt
operator|<
name|nmbclusters
operator|+
name|nsfbufs
condition|)
name|nmbcnt
operator|=
name|nmbclusters
operator|+
name|nsfbufs
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|tunable_mbinit
argument_list|,
name|SI_SUB_TUNABLES
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|tunable_mbinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The freelist structures and mutex locks.  The number statically declared  * here depends on the number of CPUs.  *  * We set up in such a way that all the objects (mbufs, clusters)  * share the same mutex lock.  It has been established that we do not benefit  * from different locks for different objects, so we use the same lock,  * regardless of object type.  */
end_comment

begin_struct
struct|struct
name|mb_lstmngr
block|{
name|struct
name|mb_gen_list
modifier|*
name|ml_genlist
decl_stmt|;
name|struct
name|mb_pcpu_list
modifier|*
name|ml_cntlst
index|[
name|NCPU
index|]
decl_stmt|;
name|struct
name|mb_bucket
modifier|*
modifier|*
name|ml_btable
decl_stmt|;
name|vm_map_t
name|ml_map
decl_stmt|;
name|vm_offset_t
name|ml_mapbase
decl_stmt|;
name|vm_offset_t
name|ml_maptop
decl_stmt|;
name|int
name|ml_mapfull
decl_stmt|;
name|u_int
name|ml_objsize
decl_stmt|;
name|u_int
modifier|*
name|ml_wmhigh
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|mb_lstmngr
name|mb_list_mbuf
decl_stmt|,
name|mb_list_clust
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|mbuf_gen
decl_stmt|,
name|mbuf_pcpu
index|[
name|NCPU
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local macros for internal allocator structure manipulations.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_define
define|#
directive|define
name|MB_GET_PCPU_LIST
parameter_list|(
name|mb_lst
parameter_list|)
value|(mb_lst)->ml_cntlst[PCPU_GET(cpuid)]
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MB_GET_PCPU_LIST
parameter_list|(
name|mb_lst
parameter_list|)
value|(mb_lst)->ml_cntlst[0]
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MB_GET_GEN_LIST
parameter_list|(
name|mb_lst
parameter_list|)
value|(mb_lst)->ml_genlist
end_define

begin_define
define|#
directive|define
name|MB_LOCK_CONT
parameter_list|(
name|mb_cnt
parameter_list|)
value|mtx_lock((mb_cnt)->mb_cont.mc_lock)
end_define

begin_define
define|#
directive|define
name|MB_UNLOCK_CONT
parameter_list|(
name|mb_cnt
parameter_list|)
value|mtx_unlock((mb_cnt)->mb_cont.mc_lock)
end_define

begin_define
define|#
directive|define
name|MB_GET_PCPU_LIST_NUM
parameter_list|(
name|mb_lst
parameter_list|,
name|num
parameter_list|)
define|\
value|(mb_lst)->ml_cntlst[(num)]
end_define

begin_define
define|#
directive|define
name|MB_BUCKET_INDX
parameter_list|(
name|mb_obj
parameter_list|,
name|mb_lst
parameter_list|)
define|\
value|(int)(((caddr_t)(mb_obj) - (caddr_t)(mb_lst)->ml_mapbase) / PAGE_SIZE)
end_define

begin_define
define|#
directive|define
name|MB_GET_OBJECT
parameter_list|(
name|mb_objp
parameter_list|,
name|mb_bckt
parameter_list|,
name|mb_lst
parameter_list|)
define|\
value|{									\ 	struct mc_buckethd *_mchd =&((mb_lst)->mb_cont.mc_bhead);	\ 									\ 	(mb_bckt)->mb_numfree--;					\ 	(mb_objp) = (mb_bckt)->mb_free[((mb_bckt)->mb_numfree)];	\ 	(*((mb_lst)->mb_cont.mc_objcount))--;				\ 	if ((mb_bckt)->mb_numfree == 0) {				\ 		SLIST_REMOVE_HEAD(_mchd, mb_blist);			\ 		SLIST_NEXT((mb_bckt), mb_blist) = NULL;			\ 		(mb_bckt)->mb_owner |= MB_BUCKET_FREE;			\ 	}								\ }
end_define

begin_define
define|#
directive|define
name|MB_PUT_OBJECT
parameter_list|(
name|mb_objp
parameter_list|,
name|mb_bckt
parameter_list|,
name|mb_lst
parameter_list|)
define|\
value|(mb_bckt)->mb_free[((mb_bckt)->mb_numfree)] = (mb_objp);	\ 	(mb_bckt)->mb_numfree++;					\ 	(*((mb_lst)->mb_cont.mc_objcount))++;
end_define

begin_define
define|#
directive|define
name|MB_MBTYPES_INC
parameter_list|(
name|mb_cnt
parameter_list|,
name|mb_type
parameter_list|,
name|mb_num
parameter_list|)
define|\
value|if ((mb_type) != MT_NOTMBUF)					\ 	    (*((mb_cnt)->mb_cont.mc_types + (mb_type))) += (mb_num)
end_define

begin_define
define|#
directive|define
name|MB_MBTYPES_DEC
parameter_list|(
name|mb_cnt
parameter_list|,
name|mb_type
parameter_list|,
name|mb_num
parameter_list|)
define|\
value|if ((mb_type) != MT_NOTMBUF)					\ 	    (*((mb_cnt)->mb_cont.mc_types + (mb_type))) -= (mb_num)
end_define

begin_comment
comment|/*  * Ownership of buckets/containers is represented by integers.  The PCPU  * lists range from 0 to NCPU-1.  We need a free numerical id for the general  * list (we use NCPU).  We also need a non-conflicting free bit to indicate  * that the bucket is free and removed from a container, while not losing  * the bucket's originating container id.  We use the highest bit  * for the free marker.  */
end_comment

begin_define
define|#
directive|define
name|MB_GENLIST_OWNER
value|(NCPU)
end_define

begin_define
define|#
directive|define
name|MB_BUCKET_FREE
value|(1<< (sizeof(int) * 8 - 1))
end_define

begin_comment
comment|/* Statistics structures for allocator (per-CPU and general). */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mbpstat
name|mb_statpcpu
index|[
name|NCPU
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mbstat
name|mbstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sleep time for wait code (in ticks). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mbuf_wait
init|=
literal|64
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|mbuf_limit
init|=
literal|512
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Upper limit on # of mbufs per CPU. */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|clust_limit
init|=
literal|128
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Upper limit on # of clusters per CPU. */
end_comment

begin_comment
comment|/*  * Objects exported by sysctl(8).  */
end_comment

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_kern_ipc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|nmbclusters
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|nmbclusters
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of mbuf clusters available"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|nmbufs
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|nmbufs
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of mbufs available"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|nmbcnt
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|nmbcnt
argument_list|,
literal|0
argument_list|,
literal|"Number used to scale kmem_map to ensure sufficient space for counters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|nsfbufs
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|nsfbufs
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of sendfile(2) sf_bufs available"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|mbuf_wait
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mbuf_wait
argument_list|,
literal|0
argument_list|,
literal|"Sleep time of mbuf subsystem wait allocations during exhaustion"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|mbuf_limit
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mbuf_limit
argument_list|,
literal|0
argument_list|,
literal|"Upper limit of number of mbufs allowed on each PCPU list"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|clust_limit
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|clust_limit
argument_list|,
literal|0
argument_list|,
literal|"Upper limit of number of mbuf clusters allowed on each PCPU list"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_STRUCT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|mbstat
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|mbstat
argument_list|,
name|mbstat
argument_list|,
literal|"Mbuf general information and statistics"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_OPAQUE
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|mb_statpcpu
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|mb_statpcpu
argument_list|,
sizeof|sizeof
argument_list|(
name|mb_statpcpu
argument_list|)
argument_list|,
literal|"S,"
argument_list|,
literal|"Mbuf allocator per CPU statistics"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Prototypes of local allocator routines.  */
end_comment

begin_function_decl
specifier|static
name|void
modifier|*
name|mb_alloc_wait
parameter_list|(
name|struct
name|mb_lstmngr
modifier|*
parameter_list|,
name|short
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mb_bucket
modifier|*
name|mb_pop_cont
parameter_list|(
name|struct
name|mb_lstmngr
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|mb_pcpu_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mb_reclaim
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mbuf_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Initial allocation numbers.  Each parameter represents the number of buckets  * of each object that will be placed initially in each PCPU container for  * said object.  */
end_comment

begin_define
define|#
directive|define
name|NMB_MBUF_INIT
value|4
end_define

begin_define
define|#
directive|define
name|NMB_CLUST_INIT
value|16
end_define

begin_comment
comment|/*  * Initialize the mbuf subsystem.  *  * We sub-divide the kmem_map into several submaps; this way, we don't have  * to worry about artificially limiting the number of mbuf or mbuf cluster  * allocations, due to fear of one type of allocation "stealing" address  * space initially reserved for another.  *  * Set up both the general containers and all the PCPU containers.  Populate  * the PCPU containers with initial numbers.  */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_MBUF
argument_list|,
literal|"mbufmgr"
argument_list|,
literal|"mbuf subsystem management structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|SYSINIT
argument_list|(
argument|mbuf
argument_list|,
argument|SI_SUB_MBUF
argument_list|,
argument|SI_ORDER_FIRST
argument_list|,
argument|mbuf_init
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_function
name|void
name|mbuf_init
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|struct
name|mb_pcpu_list
modifier|*
name|pcpu_cnt
decl_stmt|;
name|vm_size_t
name|mb_map_size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 	 * Set up all the submaps, for each type of object that we deal 	 * with in this allocator. 	 */
name|mb_map_size
operator|=
call|(
name|vm_size_t
call|)
argument_list|(
name|nmbufs
operator|*
name|MSIZE
argument_list|)
expr_stmt|;
name|mb_map_size
operator|=
name|rounddown
argument_list|(
name|mb_map_size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_btable
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|mb_map_size
operator|/
name|PAGE_SIZE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mb_bucket
operator|*
argument_list|)
argument_list|,
name|M_MBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_list_mbuf
operator|.
name|ml_btable
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|mb_list_mbuf
operator|.
name|ml_map
operator|=
name|kmem_suballoc
argument_list|(
name|kmem_map
argument_list|,
operator|&
operator|(
name|mb_list_mbuf
operator|.
name|ml_mapbase
operator|)
argument_list|,
operator|&
operator|(
name|mb_list_mbuf
operator|.
name|ml_maptop
operator|)
argument_list|,
name|mb_map_size
argument_list|)
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_mapfull
operator|=
literal|0
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_objsize
operator|=
name|MSIZE
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_wmhigh
operator|=
operator|&
name|mbuf_limit
expr_stmt|;
name|mb_map_size
operator|=
call|(
name|vm_size_t
call|)
argument_list|(
name|nmbclusters
operator|*
name|MCLBYTES
argument_list|)
expr_stmt|;
name|mb_map_size
operator|=
name|rounddown
argument_list|(
name|mb_map_size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_btable
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|mb_map_size
operator|/
name|PAGE_SIZE
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mb_bucket
operator|*
argument_list|)
argument_list|,
name|M_MBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_list_clust
operator|.
name|ml_btable
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|mb_list_clust
operator|.
name|ml_map
operator|=
name|kmem_suballoc
argument_list|(
name|kmem_map
argument_list|,
operator|&
operator|(
name|mb_list_clust
operator|.
name|ml_mapbase
operator|)
argument_list|,
operator|&
operator|(
name|mb_list_clust
operator|.
name|ml_maptop
operator|)
argument_list|,
name|mb_map_size
argument_list|)
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_mapfull
operator|=
literal|0
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_objsize
operator|=
name|MCLBYTES
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_wmhigh
operator|=
operator|&
name|clust_limit
expr_stmt|;
comment|/* XXX XXX XXX: mbuf_map->system_map = clust_map->system_map = 1. */
comment|/* 	 * Allocate required general (global) containers for each object type. 	 */
name|mb_list_mbuf
operator|.
name|ml_genlist
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mb_gen_list
argument_list|)
argument_list|,
name|M_MBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_genlist
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mb_gen_list
argument_list|)
argument_list|,
name|M_MBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mb_list_mbuf
operator|.
name|ml_genlist
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mb_list_clust
operator|.
name|ml_genlist
operator|==
name|NULL
operator|)
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * Initialize condition variables and general container mutex locks. 	 */
name|mtx_init
argument_list|(
operator|&
name|mbuf_gen
argument_list|,
literal|"mbuf subsystem general lists lock"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
operator|(
name|mb_list_mbuf
operator|.
name|ml_genlist
operator|->
name|mgl_mstarved
operator|)
argument_list|,
literal|"mbuf pool starved"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
operator|(
name|mb_list_clust
operator|.
name|ml_genlist
operator|->
name|mgl_mstarved
operator|)
argument_list|,
literal|"mcluster pool starved"
argument_list|)
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_lock
operator|=
name|mb_list_clust
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_lock
operator|=
operator|&
name|mbuf_gen
expr_stmt|;
comment|/* 	 * Set up the general containers for each object. 	 */
name|mb_list_mbuf
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_numowner
operator|=
name|mb_list_clust
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_numowner
operator|=
name|MB_GENLIST_OWNER
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|=
name|mb_list_clust
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|=
literal|0
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|=
operator|&
operator|(
name|mb_statpcpu
index|[
name|MB_GENLIST_OWNER
index|]
operator|.
name|mb_mbfree
operator|)
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|=
operator|&
operator|(
name|mb_statpcpu
index|[
name|MB_GENLIST_OWNER
index|]
operator|.
name|mb_clfree
operator|)
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_numpgs
operator|=
operator|&
operator|(
name|mb_statpcpu
index|[
name|MB_GENLIST_OWNER
index|]
operator|.
name|mb_mbpgs
operator|)
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_numpgs
operator|=
operator|&
operator|(
name|mb_statpcpu
index|[
name|MB_GENLIST_OWNER
index|]
operator|.
name|mb_clpgs
operator|)
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_types
operator|=
operator|&
operator|(
name|mb_statpcpu
index|[
name|MB_GENLIST_OWNER
index|]
operator|.
name|mb_mbtypes
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_types
operator|=
name|NULL
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
operator|(
name|mb_list_mbuf
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
operator|(
name|mb_list_clust
operator|.
name|ml_genlist
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize general mbuf statistics. 	 */
name|mbstat
operator|.
name|m_msize
operator|=
name|MSIZE
expr_stmt|;
name|mbstat
operator|.
name|m_mclbytes
operator|=
name|MCLBYTES
expr_stmt|;
name|mbstat
operator|.
name|m_minclsize
operator|=
name|MINCLSIZE
expr_stmt|;
name|mbstat
operator|.
name|m_mlen
operator|=
name|MLEN
expr_stmt|;
name|mbstat
operator|.
name|m_mhlen
operator|=
name|MHLEN
expr_stmt|;
name|mbstat
operator|.
name|m_numtypes
operator|=
name|MT_NTYPES
expr_stmt|;
comment|/* 	 * Allocate and initialize PCPU containers. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCPU
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
name|mb_list_mbuf
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mb_pcpu_list
argument_list|)
argument_list|,
name|M_MBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mb_pcpu_list
argument_list|)
argument_list|,
name|M_MBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mb_list_mbuf
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
name|mb_list_clust
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|==
name|NULL
operator|)
condition|)
goto|goto
name|bad
goto|;
name|mtx_init
argument_list|(
operator|&
name|mbuf_pcpu
index|[
name|i
index|]
argument_list|,
literal|"mbuf PCPU list lock"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_lock
operator|=
name|mb_list_clust
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_lock
operator|=
operator|&
name|mbuf_pcpu
index|[
name|i
index|]
expr_stmt|;
name|mb_statpcpu
index|[
name|i
index|]
operator|.
name|mb_active
operator|=
literal|1
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_numowner
operator|=
name|mb_list_clust
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_numowner
operator|=
name|i
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|=
name|mb_list_clust
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|=
literal|0
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|=
operator|&
operator|(
name|mb_statpcpu
index|[
name|i
index|]
operator|.
name|mb_mbfree
operator|)
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|=
operator|&
operator|(
name|mb_statpcpu
index|[
name|i
index|]
operator|.
name|mb_clfree
operator|)
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_numpgs
operator|=
operator|&
operator|(
name|mb_statpcpu
index|[
name|i
index|]
operator|.
name|mb_mbpgs
operator|)
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_numpgs
operator|=
operator|&
operator|(
name|mb_statpcpu
index|[
name|i
index|]
operator|.
name|mb_clpgs
operator|)
expr_stmt|;
name|mb_list_mbuf
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_types
operator|=
operator|&
operator|(
name|mb_statpcpu
index|[
name|i
index|]
operator|.
name|mb_mbtypes
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|mb_list_clust
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_types
operator|=
name|NULL
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
operator|(
name|mb_list_mbuf
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
operator|(
name|mb_list_clust
operator|.
name|ml_cntlst
index|[
name|i
index|]
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Perform initial allocations. 		 */
name|pcpu_cnt
operator|=
name|MB_GET_PCPU_LIST_NUM
argument_list|(
operator|&
name|mb_list_mbuf
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|MB_LOCK_CONT
argument_list|(
name|pcpu_cnt
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NMB_MBUF_INIT
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|mb_pop_cont
argument_list|(
operator|&
name|mb_list_mbuf
argument_list|,
name|M_DONTWAIT
argument_list|,
name|pcpu_cnt
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
block|}
name|MB_UNLOCK_CONT
argument_list|(
name|pcpu_cnt
argument_list|)
expr_stmt|;
name|pcpu_cnt
operator|=
name|MB_GET_PCPU_LIST_NUM
argument_list|(
operator|&
name|mb_list_clust
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|MB_LOCK_CONT
argument_list|(
name|pcpu_cnt
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NMB_CLUST_INIT
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|mb_pop_cont
argument_list|(
operator|&
name|mb_list_clust
argument_list|,
name|M_DONTWAIT
argument_list|,
name|pcpu_cnt
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
block|}
name|MB_UNLOCK_CONT
argument_list|(
name|pcpu_cnt
argument_list|)
expr_stmt|;
block|}
return|return;
name|bad
label|:
name|panic
argument_list|(
literal|"mbuf_init(): failed to initialize mbuf subsystem!"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Populate a given mbuf PCPU container with a bucket full of fresh new  * buffers.  Return a pointer to the new bucket (already in the container if  * successful), or return NULL on failure.  *  * LOCKING NOTES:  * PCPU container lock must be held when this is called.  * The lock is dropped here so that we can cleanly call the underlying VM  * code.  If we fail, we return with no locks held. If we succeed (i.e., return  * non-NULL), we return with the PCPU lock held, ready for allocation from  * the returned bucket.  */
end_comment

begin_function
specifier|static
name|struct
name|mb_bucket
modifier|*
name|mb_pop_cont
parameter_list|(
name|struct
name|mb_lstmngr
modifier|*
name|mb_list
parameter_list|,
name|int
name|how
parameter_list|,
name|struct
name|mb_pcpu_list
modifier|*
name|cnt_lst
parameter_list|)
block|{
name|struct
name|mb_bucket
modifier|*
name|bucket
decl_stmt|;
name|caddr_t
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|MB_UNLOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
comment|/* 	 * If our object's (finite) map is starved now (i.e., no more address 	 * space), bail out now. 	 */
if|if
condition|(
name|mb_list
operator|->
name|ml_mapfull
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bucket
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mb_bucket
argument_list|)
operator|+
name|PAGE_SIZE
operator|/
name|mb_list
operator|->
name|ml_objsize
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|M_MBUF
argument_list|,
name|how
operator|==
name|M_TRYWAIT
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|=
operator|(
name|caddr_t
operator|)
name|kmem_malloc
argument_list|(
name|mb_list
operator|->
name|ml_map
argument_list|,
name|PAGE_SIZE
argument_list|,
name|how
operator|==
name|M_TRYWAIT
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|bucket
argument_list|,
name|M_MBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|how
operator|==
name|M_TRYWAIT
condition|)
name|mb_list
operator|->
name|ml_mapfull
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bucket
operator|->
name|mb_numfree
operator|=
literal|0
expr_stmt|;
name|mb_list
operator|->
name|ml_btable
index|[
name|MB_BUCKET_INDX
argument_list|(
name|p
argument_list|,
name|mb_list
argument_list|)
index|]
operator|=
name|bucket
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|PAGE_SIZE
operator|/
name|mb_list
operator|->
name|ml_objsize
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|bucket
operator|->
name|mb_free
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
name|bucket
operator|->
name|mb_numfree
operator|++
expr_stmt|;
name|p
operator|+=
name|mb_list
operator|->
name|ml_objsize
expr_stmt|;
block|}
name|MB_LOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
name|bucket
operator|->
name|mb_owner
operator|=
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_numowner
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|,
name|bucket
argument_list|,
name|mb_blist
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_numpgs
operator|)
operator|)
operator|++
expr_stmt|;
operator|*
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|)
operator|+=
name|bucket
operator|->
name|mb_numfree
expr_stmt|;
return|return
operator|(
name|bucket
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate an mbuf-subsystem type object.  * The general case is very easy.  Complications only arise if our PCPU  * container is empty.  Things get worse if the PCPU container is empty,  * the general container is empty, and we've run out of address space  * in our map; then we try to block if we're willing to (M_TRYWAIT).  */
end_comment

begin_function
specifier|static
name|__inline
name|void
modifier|*
name|mb_alloc
parameter_list|(
name|struct
name|mb_lstmngr
modifier|*
name|mb_list
parameter_list|,
name|int
name|how
parameter_list|,
name|short
name|type
parameter_list|)
block|{
specifier|static
name|int
name|last_report
decl_stmt|;
name|struct
name|mb_pcpu_list
modifier|*
name|cnt_lst
decl_stmt|;
name|struct
name|mb_bucket
modifier|*
name|bucket
decl_stmt|;
name|void
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|cnt_lst
operator|=
name|MB_GET_PCPU_LIST
argument_list|(
name|mb_list
argument_list|)
expr_stmt|;
name|MB_LOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bucket
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * This is the easy allocation case. We just grab an object 		 * from a bucket in the PCPU container. At worst, we 		 * have just emptied the bucket and so we remove it 		 * from the container. 		 */
name|MB_GET_OBJECT
argument_list|(
name|m
argument_list|,
name|bucket
argument_list|,
name|cnt_lst
argument_list|)
expr_stmt|;
name|MB_MBTYPES_INC
argument_list|(
name|cnt_lst
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MB_UNLOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mb_gen_list
modifier|*
name|gen_list
decl_stmt|;
comment|/* 		 * This is the less-common more difficult case. We must 		 * first verify if the general list has anything for us 		 * and if that also fails, we must allocate a page from 		 * the map and create a new bucket to place in our PCPU 		 * container (already locked). If the map is starved then 		 * we're really in for trouble, as we have to wait on 		 * the general container's condition variable. 		 */
name|gen_list
operator|=
name|MB_GET_GEN_LIST
argument_list|(
name|mb_list
argument_list|)
expr_stmt|;
name|MB_LOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bucket
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Give ownership of the bucket to our CPU's 			 * container, but only actually put the bucket 			 * in the container if it doesn't become free 			 * upon removing an mbuf from it. 			 */
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|,
name|mb_blist
argument_list|)
expr_stmt|;
name|bucket
operator|->
name|mb_owner
operator|=
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_numowner
expr_stmt|;
operator|(
operator|*
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_numpgs
operator|)
operator|)
operator|--
expr_stmt|;
operator|(
operator|*
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_numpgs
operator|)
operator|)
operator|++
expr_stmt|;
operator|*
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|)
operator|-=
name|bucket
operator|->
name|mb_numfree
expr_stmt|;
name|bucket
operator|->
name|mb_numfree
operator|--
expr_stmt|;
name|m
operator|=
name|bucket
operator|->
name|mb_free
index|[
operator|(
name|bucket
operator|->
name|mb_numfree
operator|)
index|]
expr_stmt|;
if|if
condition|(
name|bucket
operator|->
name|mb_numfree
operator|==
literal|0
condition|)
block|{
name|SLIST_NEXT
argument_list|(
name|bucket
argument_list|,
name|mb_blist
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|bucket
operator|->
name|mb_owner
operator||=
name|MB_BUCKET_FREE
expr_stmt|;
block|}
else|else
block|{
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|,
name|bucket
argument_list|,
name|mb_blist
argument_list|)
expr_stmt|;
operator|*
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|)
operator|+=
name|bucket
operator|->
name|mb_numfree
expr_stmt|;
block|}
name|MB_UNLOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
name|MB_MBTYPES_INC
argument_list|(
name|cnt_lst
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MB_UNLOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We'll have to allocate a new page. 			 */
name|MB_UNLOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|mb_pop_cont
argument_list|(
name|mb_list
argument_list|,
name|how
argument_list|,
name|cnt_lst
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket
operator|!=
name|NULL
condition|)
block|{
name|MB_GET_OBJECT
argument_list|(
name|m
argument_list|,
name|bucket
argument_list|,
name|cnt_lst
argument_list|)
expr_stmt|;
name|MB_MBTYPES_INC
argument_list|(
name|cnt_lst
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MB_UNLOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|how
operator|==
name|M_TRYWAIT
condition|)
block|{
comment|/* 				 	 * Absolute worst-case scenario. 					 * We block if we're willing to, but 					 * only after trying to steal from 					 * other lists. 					 */
name|m
operator|=
name|mb_alloc_wait
argument_list|(
name|mb_list
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX: No consistency. */
name|mbstat
operator|.
name|m_drops
operator|++
expr_stmt|;
if|if
condition|(
name|ticks
operator|<
name|last_report
operator|||
operator|(
name|ticks
operator|-
name|last_report
operator|)
operator|>=
name|hz
condition|)
block|{
name|last_report
operator|=
name|ticks
expr_stmt|;
name|printf
argument_list|(
literal|"mb_alloc for mbuf type %d failed.\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is the worst-case scenario called only if we're allocating with  * M_TRYWAIT.  We first drain all the protocols, then try to find an mbuf  * by looking in every PCPU container.  If we're still unsuccesful, we  * try the general container one last time and possibly block on our  * starved cv.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|mb_alloc_wait
parameter_list|(
name|struct
name|mb_lstmngr
modifier|*
name|mb_list
parameter_list|,
name|short
name|type
parameter_list|)
block|{
name|struct
name|mb_pcpu_list
modifier|*
name|cnt_lst
decl_stmt|;
name|struct
name|mb_gen_list
modifier|*
name|gen_list
decl_stmt|;
name|struct
name|mb_bucket
modifier|*
name|bucket
decl_stmt|;
name|void
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cv_ret
decl_stmt|;
comment|/* 	 * Try to reclaim mbuf-related objects (mbufs, clusters). 	 */
name|mb_reclaim
argument_list|()
expr_stmt|;
comment|/* 	 * Cycle all the PCPU containers. Increment starved counts if found 	 * empty. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCPU
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
name|cnt_lst
operator|=
name|MB_GET_PCPU_LIST_NUM
argument_list|(
name|mb_list
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|MB_LOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
comment|/* 		 * If container is non-empty, get a single object from it. 		 * If empty, increment starved count. 		 */
if|if
condition|(
operator|(
name|bucket
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|MB_GET_OBJECT
argument_list|(
name|m
argument_list|,
name|bucket
argument_list|,
name|cnt_lst
argument_list|)
expr_stmt|;
name|MB_MBTYPES_INC
argument_list|(
name|cnt_lst
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MB_UNLOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
name|mbstat
operator|.
name|m_wait
operator|++
expr_stmt|;
comment|/* XXX: No consistency. */
return|return
operator|(
name|m
operator|)
return|;
block|}
else|else
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|++
expr_stmt|;
name|MB_UNLOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We're still here, so that means it's time to get the general 	 * container lock, check it one more time (now that mb_reclaim() 	 * has been called) and if we still get nothing, block on the cv. 	 */
name|gen_list
operator|=
name|MB_GET_GEN_LIST
argument_list|(
name|mb_list
argument_list|)
expr_stmt|;
name|MB_LOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bucket
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|MB_GET_OBJECT
argument_list|(
name|m
argument_list|,
name|bucket
argument_list|,
name|gen_list
argument_list|)
expr_stmt|;
name|MB_MBTYPES_INC
argument_list|(
name|gen_list
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MB_UNLOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
name|mbstat
operator|.
name|m_wait
operator|++
expr_stmt|;
comment|/* XXX: No consistency. */
return|return
operator|(
name|m
operator|)
return|;
block|}
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|++
expr_stmt|;
name|cv_ret
operator|=
name|cv_timedwait
argument_list|(
operator|&
operator|(
name|gen_list
operator|->
name|mgl_mstarved
operator|)
argument_list|,
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_lock
argument_list|,
name|mbuf_wait
argument_list|)
expr_stmt|;
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|cv_ret
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|bucket
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|MB_GET_OBJECT
argument_list|(
name|m
argument_list|,
name|bucket
argument_list|,
name|gen_list
argument_list|)
expr_stmt|;
name|MB_MBTYPES_INC
argument_list|(
name|gen_list
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mbstat
operator|.
name|m_wait
operator|++
expr_stmt|;
comment|/* XXX: No consistency. */
block|}
else|else
block|{
name|mbstat
operator|.
name|m_drops
operator|++
expr_stmt|;
comment|/* XXX: No consistency. */
name|m
operator|=
name|NULL
expr_stmt|;
block|}
name|MB_UNLOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * Free an object to its rightful container.  * In the very general case, this operation is really very easy.  * Complications arise primarily if:  *	(a) We've hit the high limit on number of free objects allowed in  *	    our PCPU container.  *	(b) We're in a critical situation where our container has been  *	    marked 'starved' and we need to issue wakeups on the starved  *	    condition variable.  *	(c) Minor (odd) cases: our bucket has migrated while we were  *	    waiting for the lock; our bucket is in the general container;  *	    our bucket is empty.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|mb_free
parameter_list|(
name|struct
name|mb_lstmngr
modifier|*
name|mb_list
parameter_list|,
name|void
modifier|*
name|m
parameter_list|,
name|short
name|type
parameter_list|)
block|{
name|struct
name|mb_pcpu_list
modifier|*
name|cnt_lst
decl_stmt|;
name|struct
name|mb_gen_list
modifier|*
name|gen_list
decl_stmt|;
name|struct
name|mb_bucket
modifier|*
name|bucket
decl_stmt|;
name|u_int
name|owner
decl_stmt|;
name|bucket
operator|=
name|mb_list
operator|->
name|ml_btable
index|[
name|MB_BUCKET_INDX
argument_list|(
name|m
argument_list|,
name|mb_list
argument_list|)
index|]
expr_stmt|;
comment|/* 	 * Make sure that if after we lock the bucket's present container the 	 * bucket has migrated, that we drop the lock and get the new one. 	 */
name|retry_lock
label|:
name|owner
operator|=
name|bucket
operator|->
name|mb_owner
operator|&
operator|~
name|MB_BUCKET_FREE
expr_stmt|;
switch|switch
condition|(
name|owner
condition|)
block|{
case|case
name|MB_GENLIST_OWNER
case|:
name|gen_list
operator|=
name|MB_GET_GEN_LIST
argument_list|(
name|mb_list
argument_list|)
expr_stmt|;
name|MB_LOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|!=
operator|(
name|bucket
operator|->
name|mb_owner
operator|&
operator|~
name|MB_BUCKET_FREE
operator|)
condition|)
block|{
name|MB_UNLOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
goto|goto
name|retry_lock
goto|;
block|}
comment|/* 		 * If we're intended for the general container, this is 		 * real easy: no migrating required. The only `bogon' 		 * is that we're now contending with all the threads 		 * dealing with the general list, but this is expected. 		 */
name|MB_PUT_OBJECT
argument_list|(
name|m
argument_list|,
name|bucket
argument_list|,
name|gen_list
argument_list|)
expr_stmt|;
name|MB_MBTYPES_DEC
argument_list|(
name|gen_list
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|>
literal|0
condition|)
name|cv_signal
argument_list|(
operator|&
operator|(
name|gen_list
operator|->
name|mgl_mstarved
operator|)
argument_list|)
expr_stmt|;
name|MB_UNLOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cnt_lst
operator|=
name|MB_GET_PCPU_LIST_NUM
argument_list|(
name|mb_list
argument_list|,
name|owner
argument_list|)
expr_stmt|;
name|MB_LOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|!=
operator|(
name|bucket
operator|->
name|mb_owner
operator|&
operator|~
name|MB_BUCKET_FREE
operator|)
condition|)
block|{
name|MB_UNLOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
goto|goto
name|retry_lock
goto|;
block|}
name|MB_PUT_OBJECT
argument_list|(
name|m
argument_list|,
name|bucket
argument_list|,
name|cnt_lst
argument_list|)
expr_stmt|;
name|MB_MBTYPES_DEC
argument_list|(
name|cnt_lst
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|>
literal|0
condition|)
block|{
comment|/* 			 * This is a tough case. It means that we've 			 * been flagged at least once to indicate that 			 * we're empty, and that the system is in a critical 			 * situation, so we ought to migrate at least one 			 * bucket over to the general container. 			 * There may or may not be a thread blocking on 			 * the starved condition variable, but chances 			 * are that one will eventually come up soon so 			 * it's better to migrate now than never. 			 */
name|gen_list
operator|=
name|MB_GET_GEN_LIST
argument_list|(
name|mb_list
argument_list|)
expr_stmt|;
name|MB_LOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|bucket
operator|->
name|mb_owner
operator|&
name|MB_BUCKET_FREE
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"mb_free: corrupt bucket %p\n"
operator|,
name|bucket
operator|)
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|,
name|bucket
argument_list|,
name|mb_blist
argument_list|)
expr_stmt|;
name|bucket
operator|->
name|mb_owner
operator|=
name|MB_GENLIST_OWNER
expr_stmt|;
operator|(
operator|*
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|)
operator|)
operator|--
expr_stmt|;
operator|(
operator|*
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|)
operator|)
operator|++
expr_stmt|;
operator|(
operator|*
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_numpgs
operator|)
operator|)
operator|--
expr_stmt|;
operator|(
operator|*
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_numpgs
operator|)
operator|)
operator|++
expr_stmt|;
comment|/* 			 * Determine whether or not to keep transferring 			 * buckets to the general list or whether we've 			 * transferred enough already. 			 * We realize that although we may flag another 			 * bucket to be migrated to the general container 			 * that in the meantime, the thread that was 			 * blocked on the cv is already woken up and 			 * long gone. But in that case, the worst 			 * consequence is that we will end up migrating 			 * one bucket too many, which is really not a big 			 * deal, especially if we're close to a critical 			 * situation. 			 */
if|if
condition|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|>
literal|0
condition|)
block|{
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|--
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
operator|(
name|gen_list
operator|->
name|mgl_mstarved
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_starved
operator|=
literal|0
expr_stmt|;
name|MB_UNLOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
name|MB_UNLOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|)
operator|>
operator|*
operator|(
name|mb_list
operator|->
name|ml_wmhigh
operator|)
condition|)
block|{
comment|/* 			 * We've hit the high limit of allowed numbers of mbufs 			 * on this PCPU list. We must now migrate a bucket 			 * over to the general container. 			 */
name|gen_list
operator|=
name|MB_GET_GEN_LIST
argument_list|(
name|mb_list
argument_list|)
expr_stmt|;
name|MB_LOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bucket
operator|->
name|mb_owner
operator|&
name|MB_BUCKET_FREE
operator|)
operator|==
literal|0
condition|)
block|{
name|bucket
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|,
name|mb_blist
argument_list|)
expr_stmt|;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|,
name|bucket
argument_list|,
name|mb_blist
argument_list|)
expr_stmt|;
name|bucket
operator|->
name|mb_owner
operator|=
name|MB_GENLIST_OWNER
expr_stmt|;
operator|*
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|)
operator|-=
name|bucket
operator|->
name|mb_numfree
expr_stmt|;
operator|*
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_objcount
operator|)
operator|+=
name|bucket
operator|->
name|mb_numfree
expr_stmt|;
operator|(
operator|*
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_numpgs
operator|)
operator|)
operator|--
expr_stmt|;
operator|(
operator|*
operator|(
name|gen_list
operator|->
name|mb_cont
operator|.
name|mc_numpgs
operator|)
operator|)
operator|++
expr_stmt|;
comment|/* 			 * While we're at it, transfer some of the mbtypes 			 * "count load" onto the general list's mbtypes 			 * array, seeing as how we're moving the bucket 			 * there now, meaning that the freeing of objects 			 * there will now decrement the _general list's_ 			 * mbtypes counters, and no longer our PCPU list's 			 * mbtypes counters. We do this for the type presently 			 * being freed in an effort to keep the mbtypes 			 * counters approximately balanced across all lists. 			 */
name|MB_MBTYPES_DEC
argument_list|(
name|cnt_lst
argument_list|,
name|type
argument_list|,
operator|(
name|PAGE_SIZE
operator|/
name|mb_list
operator|->
name|ml_objsize
operator|)
operator|-
name|bucket
operator|->
name|mb_numfree
argument_list|)
expr_stmt|;
name|MB_MBTYPES_INC
argument_list|(
name|gen_list
argument_list|,
name|type
argument_list|,
operator|(
name|PAGE_SIZE
operator|/
name|mb_list
operator|->
name|ml_objsize
operator|)
operator|-
name|bucket
operator|->
name|mb_numfree
argument_list|)
expr_stmt|;
name|MB_UNLOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
name|MB_UNLOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bucket
operator|->
name|mb_owner
operator|&
name|MB_BUCKET_FREE
condition|)
block|{
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
operator|(
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_bhead
operator|)
argument_list|,
name|bucket
argument_list|,
name|mb_blist
argument_list|)
expr_stmt|;
name|bucket
operator|->
name|mb_owner
operator|=
name|cnt_lst
operator|->
name|mb_cont
operator|.
name|mc_numowner
expr_stmt|;
block|}
name|MB_UNLOCK_CONT
argument_list|(
name|cnt_lst
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Drain protocols in hopes to free up some resources.  *  * LOCKING NOTES:  * No locks should be held when this is called.  The drain routines have to  * presently acquire some locks which raises the possibility of lock order  * violation if we're holding any mutex if that mutex is acquired in reverse  * order relative to one of the locks in the drain routines.  */
end_comment

begin_function
specifier|static
name|void
name|mb_reclaim
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|domain
modifier|*
name|dp
decl_stmt|;
name|struct
name|protosw
modifier|*
name|pr
decl_stmt|;
comment|/*  * XXX: Argh, we almost always trip here with witness turned on now-a-days  * XXX: because we often come in with Giant held. For now, there's no way  * XXX: to avoid this.  */
ifdef|#
directive|ifdef
name|WITNESS
name|KASSERT
argument_list|(
name|witness_list
argument_list|(
name|curthread
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"mb_reclaim() called with locks held"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mbstat
operator|.
name|m_drain
operator|++
expr_stmt|;
comment|/* XXX: No consistency. */
for|for
control|(
name|dp
operator|=
name|domains
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|dom_next
control|)
for|for
control|(
name|pr
operator|=
name|dp
operator|->
name|dom_protosw
init|;
name|pr
operator|<
name|dp
operator|->
name|dom_protoswNPROTOSW
condition|;
name|pr
operator|++
control|)
if|if
condition|(
name|pr
operator|->
name|pr_drain
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|pr
operator|->
name|pr_drain
call|)
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Local mbuf& cluster alloc macros and routines.  * Local macro and function names begin with an underscore ("_").  */
end_comment

begin_function_decl
specifier|static
name|void
name|_mclfree
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|_m_get
parameter_list|(
name|m
parameter_list|,
name|how
parameter_list|,
name|type
parameter_list|)
value|do {					\ 	(m) = (struct mbuf *)mb_alloc(&mb_list_mbuf, (how), (type));	\ 	if ((m) != NULL) {						\ 		(m)->m_type = (type);					\ 		(m)->m_next = NULL;					\ 		(m)->m_nextpkt = NULL;					\ 		(m)->m_data = (m)->m_dat;				\ 		(m)->m_flags = 0;					\ 	}								\ } while (0)
end_define

begin_define
define|#
directive|define
name|_m_gethdr
parameter_list|(
name|m
parameter_list|,
name|how
parameter_list|,
name|type
parameter_list|)
value|do {					\ 	(m) = (struct mbuf *)mb_alloc(&mb_list_mbuf, (how), (type));	\ 	if ((m) != NULL) {						\ 		(m)->m_type = (type);					\ 		(m)->m_next = NULL;					\ 		(m)->m_nextpkt = NULL;					\ 		(m)->m_data = (m)->m_pktdat;				\ 		(m)->m_flags = M_PKTHDR;				\ 		(m)->m_pkthdr.rcvif = NULL;				\ 		(m)->m_pkthdr.csum_flags = 0;				\ 		(m)->m_pkthdr.aux = NULL;				\ 	}								\ } while (0)
end_define

begin_comment
comment|/* XXX: Check for M_PKTHDR&& m_pkthdr.aux is bogus... please fix (see KAME). */
end_comment

begin_define
define|#
directive|define
name|_m_free
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
value|do {						\ 	(n) = (m)->m_next;						\ 	if ((m)->m_flags& M_EXT)					\ 		MEXTFREE((m));						\ 	if (((m)->m_flags& M_PKTHDR) != 0&& (m)->m_pkthdr.aux) {	\ 		m_freem((m)->m_pkthdr.aux);				\ 		(m)->m_pkthdr.aux = NULL;				\ 	}								\ 	mb_free(&mb_list_mbuf, (m), (m)->m_type);			\ } while (0)
end_define

begin_define
define|#
directive|define
name|_mext_init_ref
parameter_list|(
name|m
parameter_list|)
value|do {						\ 	(m)->m_ext.ref_cnt = malloc(sizeof(u_int), M_MBUF, M_NOWAIT);	\ 	if ((m)->m_ext.ref_cnt != NULL) {				\ 		*((m)->m_ext.ref_cnt) = 0;				\ 		MEXT_ADD_REF((m));					\ 	}								\ } while (0)
end_define

begin_define
define|#
directive|define
name|_mext_dealloc_ref
parameter_list|(
name|m
parameter_list|)
define|\
value|free((m)->m_ext.ref_cnt, M_MBUF)
end_define

begin_function
name|void
name|_mext_free
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mb
parameter_list|)
block|{
if|if
condition|(
name|mb
operator|->
name|m_ext
operator|.
name|ext_type
operator|==
name|EXT_CLUSTER
condition|)
name|mb_free
argument_list|(
operator|&
name|mb_list_clust
argument_list|,
operator|(
name|caddr_t
operator|)
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|,
name|MT_NOTMBUF
argument_list|)
expr_stmt|;
else|else
operator|(
operator|*
operator|(
name|mb
operator|->
name|m_ext
operator|.
name|ext_free
operator|)
operator|)
operator|(
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
operator|,
name|mb
operator|->
name|m_ext
operator|.
name|ext_args
operator|)
expr_stmt|;
name|_mext_dealloc_ref
argument_list|(
name|mb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We only include this here to avoid making m_clget() excessively large  * due to too much inlined code.  */
end_comment

begin_function
specifier|static
name|void
name|_mclfree
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mb
parameter_list|)
block|{
name|mb_free
argument_list|(
operator|&
name|mb_list_clust
argument_list|,
operator|(
name|caddr_t
operator|)
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
argument_list|,
name|MT_NOTMBUF
argument_list|)
expr_stmt|;
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Exported space allocation and de-allocation routines.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|m_get
parameter_list|(
name|int
name|how
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|_m_get
argument_list|(
name|mb
argument_list|,
name|how
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|mb
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|m_gethdr
parameter_list|(
name|int
name|how
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|_m_gethdr
argument_list|(
name|mb
argument_list|,
name|how
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|mb
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|m_get_clrd
parameter_list|(
name|int
name|how
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|_m_get
argument_list|(
name|mb
argument_list|,
name|how
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|!=
name|NULL
condition|)
name|bzero
argument_list|(
name|mtod
argument_list|(
name|mb
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|MLEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|mb
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|m_gethdr_clrd
parameter_list|(
name|int
name|how
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|_m_gethdr
argument_list|(
name|mb
argument_list|,
name|how
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|!=
name|NULL
condition|)
name|bzero
argument_list|(
name|mtod
argument_list|(
name|mb
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|MHLEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|mb
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|m_free
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mb
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|nb
decl_stmt|;
name|_m_free
argument_list|(
name|mb
argument_list|,
name|nb
argument_list|)
expr_stmt|;
return|return
operator|(
name|nb
operator|)
return|;
block|}
end_function

begin_function
name|void
name|m_clget
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mb
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
operator|=
operator|(
name|caddr_t
operator|)
name|mb_alloc
argument_list|(
operator|&
name|mb_list_clust
argument_list|,
name|how
argument_list|,
name|MT_NOTMBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
operator|!=
name|NULL
condition|)
block|{
name|_mext_init_ref
argument_list|(
name|mb
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|->
name|m_ext
operator|.
name|ref_cnt
operator|==
name|NULL
condition|)
name|_mclfree
argument_list|(
name|mb
argument_list|)
expr_stmt|;
else|else
block|{
name|mb
operator|->
name|m_data
operator|=
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
name|mb
operator|->
name|m_flags
operator||=
name|M_EXT
expr_stmt|;
name|mb
operator|->
name|m_ext
operator|.
name|ext_free
operator|=
name|NULL
expr_stmt|;
name|mb
operator|->
name|m_ext
operator|.
name|ext_args
operator|=
name|NULL
expr_stmt|;
name|mb
operator|->
name|m_ext
operator|.
name|ext_size
operator|=
name|MCLBYTES
expr_stmt|;
name|mb
operator|->
name|m_ext
operator|.
name|ext_type
operator|=
name|EXT_CLUSTER
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|m_extadd
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mb
parameter_list|,
name|caddr_t
name|buf
parameter_list|,
name|u_int
name|size
parameter_list|,
name|void
function_decl|(
modifier|*
name|freef
function_decl|)
parameter_list|(
name|caddr_t
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|args
parameter_list|,
name|short
name|flags
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|_mext_init_ref
argument_list|(
name|mb
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|->
name|m_ext
operator|.
name|ref_cnt
operator|!=
name|NULL
condition|)
block|{
name|mb
operator|->
name|m_flags
operator||=
operator|(
name|M_EXT
operator||
name|flags
operator|)
expr_stmt|;
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
operator|=
name|buf
expr_stmt|;
name|mb
operator|->
name|m_data
operator|=
name|mb
operator|->
name|m_ext
operator|.
name|ext_buf
expr_stmt|;
name|mb
operator|->
name|m_ext
operator|.
name|ext_size
operator|=
name|size
expr_stmt|;
name|mb
operator|->
name|m_ext
operator|.
name|ext_free
operator|=
name|freef
expr_stmt|;
name|mb
operator|->
name|m_ext
operator|.
name|ext_args
operator|=
name|args
expr_stmt|;
name|mb
operator|->
name|m_ext
operator|.
name|ext_type
operator|=
name|type
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Change type for mbuf `mb'; this is a relatively expensive operation and  * should be avoided.  */
end_comment

begin_function
name|void
name|m_chtype
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mb
parameter_list|,
name|short
name|new_type
parameter_list|)
block|{
name|struct
name|mb_gen_list
modifier|*
name|gen_list
decl_stmt|;
name|gen_list
operator|=
name|MB_GET_GEN_LIST
argument_list|(
operator|&
name|mb_list_mbuf
argument_list|)
expr_stmt|;
name|MB_LOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
name|MB_MBTYPES_DEC
argument_list|(
name|gen_list
argument_list|,
name|mb
operator|->
name|m_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MB_MBTYPES_INC
argument_list|(
name|gen_list
argument_list|,
name|new_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|MB_UNLOCK_CONT
argument_list|(
name|gen_list
argument_list|)
expr_stmt|;
name|mb
operator|->
name|m_type
operator|=
name|new_type
expr_stmt|;
block|}
end_function

end_unit

