begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997, Stefan Esser<se@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_kstack_usage_prof.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_include
include|#
directive|include
file|<sys/rtprio.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_sym.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Describe an interrupt thread.  There is one of these per interrupt event.  */
end_comment

begin_struct
struct|struct
name|intr_thread
block|{
name|struct
name|intr_event
modifier|*
name|it_event
decl_stmt|;
name|struct
name|thread
modifier|*
name|it_thread
decl_stmt|;
comment|/* Kernel thread. */
name|int
name|it_flags
decl_stmt|;
comment|/* (j) IT_* flags. */
name|int
name|it_need
decl_stmt|;
comment|/* Needs service. */
block|}
struct|;
end_struct

begin_comment
comment|/* Interrupt thread flags kept in it_flags */
end_comment

begin_define
define|#
directive|define
name|IT_DEAD
value|0x000001
end_define

begin_comment
comment|/* Thread is waiting to exit. */
end_comment

begin_define
define|#
directive|define
name|IT_WAIT
value|0x000002
end_define

begin_comment
comment|/* Thread is waiting for completion. */
end_comment

begin_struct
struct|struct
name|intr_entropy
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|uintptr_t
name|event
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|intr_event
modifier|*
name|clk_intr_event
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|intr_event
modifier|*
name|tty_intr_event
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|vm_ih
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|intrproc
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_ITHREAD
argument_list|,
literal|"ithread"
argument_list|,
literal|"Interrupt Threads"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|intr_storm_threshold
init|=
literal|1000
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|intr_storm_threshold
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|intr_storm_threshold
argument_list|,
literal|0
argument_list|,
literal|"Number of consecutive interrupts before storm protection is enabled"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|intr_event
argument_list|)
name|event_list
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|event_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|event_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|intr_event_list
argument_list|,
operator|&
name|event_lock
argument_list|,
literal|"intr event list"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|intr_event_update
parameter_list|(
name|struct
name|intr_event
modifier|*
name|ie
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INTR_FILTER
end_ifdef

begin_function_decl
specifier|static
name|int
name|intr_event_schedule_thread
parameter_list|(
name|struct
name|intr_event
modifier|*
name|ie
parameter_list|,
name|struct
name|intr_thread
modifier|*
name|ithd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|intr_filter_loop
parameter_list|(
name|struct
name|intr_event
modifier|*
name|ie
parameter_list|,
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|,
name|struct
name|intr_thread
modifier|*
modifier|*
name|ithd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|intr_thread
modifier|*
name|ithread_create
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|intr_handler
modifier|*
name|ih
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|int
name|intr_event_schedule_thread
parameter_list|(
name|struct
name|intr_event
modifier|*
name|ie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|intr_thread
modifier|*
name|ithread_create
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ithread_destroy
parameter_list|(
name|struct
name|intr_thread
modifier|*
name|ithread
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ithread_execute_handlers
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|intr_event
modifier|*
name|ie
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INTR_FILTER
end_ifdef

begin_function_decl
specifier|static
name|void
name|priv_ithread_execute_handler
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|intr_handler
modifier|*
name|ih
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ithread_loop
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ithread_update
parameter_list|(
name|struct
name|intr_thread
modifier|*
name|ithd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|start_softintr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Map an interrupt type to an ithread priority. */
end_comment

begin_function
name|u_char
name|intr_priority
parameter_list|(
name|enum
name|intr_type
name|flags
parameter_list|)
block|{
name|u_char
name|pri
decl_stmt|;
name|flags
operator|&=
operator|(
name|INTR_TYPE_TTY
operator||
name|INTR_TYPE_BIO
operator||
name|INTR_TYPE_NET
operator||
name|INTR_TYPE_CAM
operator||
name|INTR_TYPE_MISC
operator||
name|INTR_TYPE_CLK
operator||
name|INTR_TYPE_AV
operator|)
expr_stmt|;
switch|switch
condition|(
name|flags
condition|)
block|{
case|case
name|INTR_TYPE_TTY
case|:
name|pri
operator|=
name|PI_TTY
expr_stmt|;
break|break;
case|case
name|INTR_TYPE_BIO
case|:
name|pri
operator|=
name|PI_DISK
expr_stmt|;
break|break;
case|case
name|INTR_TYPE_NET
case|:
name|pri
operator|=
name|PI_NET
expr_stmt|;
break|break;
case|case
name|INTR_TYPE_CAM
case|:
name|pri
operator|=
name|PI_DISK
expr_stmt|;
break|break;
case|case
name|INTR_TYPE_AV
case|:
name|pri
operator|=
name|PI_AV
expr_stmt|;
break|break;
case|case
name|INTR_TYPE_CLK
case|:
name|pri
operator|=
name|PI_REALTIME
expr_stmt|;
break|break;
case|case
name|INTR_TYPE_MISC
case|:
name|pri
operator|=
name|PI_DULL
expr_stmt|;
comment|/* don't care */
break|break;
default|default:
comment|/* We didn't specify an interrupt level. */
name|panic
argument_list|(
literal|"intr_priority: no interrupt type in flags"
argument_list|)
expr_stmt|;
block|}
return|return
name|pri
return|;
block|}
end_function

begin_comment
comment|/*  * Update an ithread based on the associated intr_event.  */
end_comment

begin_function
specifier|static
name|void
name|ithread_update
parameter_list|(
name|struct
name|intr_thread
modifier|*
name|ithd
parameter_list|)
block|{
name|struct
name|intr_event
modifier|*
name|ie
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|u_char
name|pri
decl_stmt|;
name|ie
operator|=
name|ithd
operator|->
name|it_event
expr_stmt|;
name|td
operator|=
name|ithd
operator|->
name|it_thread
expr_stmt|;
comment|/* Determine the overall priority of this event. */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ie
operator|->
name|ie_handlers
argument_list|)
condition|)
name|pri
operator|=
name|PRI_MAX_ITHD
expr_stmt|;
else|else
name|pri
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ie
operator|->
name|ie_handlers
argument_list|)
operator|->
name|ih_pri
expr_stmt|;
comment|/* Update name and priority. */
name|strlcpy
argument_list|(
name|td
operator|->
name|td_name
argument_list|,
name|ie
operator|->
name|ie_fullname
argument_list|,
sizeof|sizeof
argument_list|(
name|td
operator|->
name|td_name
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTR
name|sched_clear_tdname
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|sched_prio
argument_list|(
name|td
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Regenerate the full name of an interrupt event and update its priority.  */
end_comment

begin_function
specifier|static
name|void
name|intr_event_update
parameter_list|(
name|struct
name|intr_event
modifier|*
name|ie
parameter_list|)
block|{
name|struct
name|intr_handler
modifier|*
name|ih
decl_stmt|;
name|char
modifier|*
name|last
decl_stmt|;
name|int
name|missed
decl_stmt|,
name|space
decl_stmt|;
comment|/* Start off with no entropy and just the name of the event. */
name|mtx_assert
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ie
operator|->
name|ie_fullname
argument_list|,
name|ie
operator|->
name|ie_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ie
operator|->
name|ie_fullname
argument_list|)
argument_list|)
expr_stmt|;
name|ie
operator|->
name|ie_flags
operator|&=
operator|~
name|IE_ENTROPY
expr_stmt|;
name|missed
operator|=
literal|0
expr_stmt|;
name|space
operator|=
literal|1
expr_stmt|;
comment|/* Run through all the handlers updating values. */
name|TAILQ_FOREACH
argument_list|(
argument|ih
argument_list|,
argument|&ie->ie_handlers
argument_list|,
argument|ih_next
argument_list|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|ie
operator|->
name|ie_fullname
argument_list|)
operator|+
name|strlen
argument_list|(
name|ih
operator|->
name|ih_name
argument_list|)
operator|+
literal|1
operator|<
sizeof|sizeof
argument_list|(
name|ie
operator|->
name|ie_fullname
argument_list|)
condition|)
block|{
name|strcat
argument_list|(
name|ie
operator|->
name|ie_fullname
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ie
operator|->
name|ie_fullname
argument_list|,
name|ih
operator|->
name|ih_name
argument_list|)
expr_stmt|;
name|space
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|missed
operator|++
expr_stmt|;
if|if
condition|(
name|ih
operator|->
name|ih_flags
operator|&
name|IH_ENTROPY
condition|)
name|ie
operator|->
name|ie_flags
operator||=
name|IE_ENTROPY
expr_stmt|;
block|}
comment|/* 	 * If the handler names were too long, add +'s to indicate missing 	 * names. If we run out of room and still have +'s to add, change 	 * the last character from a + to a *. 	 */
name|last
operator|=
operator|&
name|ie
operator|->
name|ie_fullname
index|[
sizeof|sizeof
argument_list|(
name|ie
operator|->
name|ie_fullname
argument_list|)
operator|-
literal|2
index|]
expr_stmt|;
while|while
condition|(
name|missed
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|ie
operator|->
name|ie_fullname
argument_list|)
operator|+
literal|1
operator|==
sizeof|sizeof
argument_list|(
name|ie
operator|->
name|ie_fullname
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|last
operator|==
literal|'+'
condition|)
block|{
operator|*
name|last
operator|=
literal|'*'
expr_stmt|;
break|break;
block|}
else|else
operator|*
name|last
operator|=
literal|'+'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|space
condition|)
block|{
name|strcat
argument_list|(
name|ie
operator|->
name|ie_fullname
argument_list|,
literal|" +"
argument_list|)
expr_stmt|;
name|space
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|strcat
argument_list|(
name|ie
operator|->
name|ie_fullname
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If this event has an ithread, update it's priority and 	 * name. 	 */
if|if
condition|(
name|ie
operator|->
name|ie_thread
operator|!=
name|NULL
condition|)
name|ithread_update
argument_list|(
name|ie
operator|->
name|ie_thread
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: updated %s"
argument_list|,
name|__func__
argument_list|,
name|ie
operator|->
name|ie_fullname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|intr_event_create
parameter_list|(
name|struct
name|intr_event
modifier|*
modifier|*
name|event
parameter_list|,
name|void
modifier|*
name|source
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|irq
parameter_list|,
name|void
function_decl|(
modifier|*
name|pre_ithread
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|post_ithread
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|post_filter
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|assign_cpu
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|struct
name|intr_event
modifier|*
name|ie
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
comment|/* The only valid flag during creation is IE_SOFT. */
if|if
condition|(
operator|(
name|flags
operator|&
operator|~
name|IE_SOFT
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ie
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|intr_event
argument_list|)
argument_list|,
name|M_ITHREAD
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ie
operator|->
name|ie_source
operator|=
name|source
expr_stmt|;
name|ie
operator|->
name|ie_pre_ithread
operator|=
name|pre_ithread
expr_stmt|;
name|ie
operator|->
name|ie_post_ithread
operator|=
name|post_ithread
expr_stmt|;
name|ie
operator|->
name|ie_post_filter
operator|=
name|post_filter
expr_stmt|;
name|ie
operator|->
name|ie_assign_cpu
operator|=
name|assign_cpu
expr_stmt|;
name|ie
operator|->
name|ie_flags
operator|=
name|flags
expr_stmt|;
name|ie
operator|->
name|ie_irq
operator|=
name|irq
expr_stmt|;
name|ie
operator|->
name|ie_cpu
operator|=
name|NOCPU
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ie
operator|->
name|ie_handlers
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|,
literal|"intr event"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|ie
operator|->
name|ie_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ie
operator|->
name|ie_name
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|ie
operator|->
name|ie_fullname
argument_list|,
name|ie
operator|->
name|ie_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ie
operator|->
name|ie_fullname
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|event_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|event_list
argument_list|,
name|ie
argument_list|,
name|ie_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|event_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|!=
name|NULL
condition|)
operator|*
name|event
operator|=
name|ie
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: created %s"
argument_list|,
name|__func__
argument_list|,
name|ie
operator|->
name|ie_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Bind an interrupt event to the specified CPU.  Note that not all  * platforms support binding an interrupt to a CPU.  For those  * platforms this request will fail.  Using a cpu id of NOCPU unbinds  * the interrupt event.  */
end_comment

begin_function
specifier|static
name|int
name|_intr_event_bind
parameter_list|(
name|struct
name|intr_event
modifier|*
name|ie
parameter_list|,
name|int
name|cpu
parameter_list|,
name|bool
name|bindirq
parameter_list|,
name|bool
name|bindithread
parameter_list|)
block|{
name|lwpid_t
name|id
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Need a CPU to bind to. */
if|if
condition|(
name|cpu
operator|!=
name|NOCPU
operator|&&
name|CPU_ABSENT
argument_list|(
name|cpu
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ie
operator|->
name|ie_assign_cpu
operator|==
name|NULL
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|error
operator|=
name|priv_check
argument_list|(
name|curthread
argument_list|,
name|PRIV_SCHED_CPUSET_INTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * If we have any ithreads try to set their mask first to verify 	 * permissions, etc. 	 */
if|if
condition|(
name|bindithread
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ie
operator|->
name|ie_thread
operator|!=
name|NULL
condition|)
block|{
name|id
operator|=
name|ie
operator|->
name|ie_thread
operator|->
name|it_thread
operator|->
name|td_tid
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|cpuset_setithread
argument_list|(
name|id
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bindirq
condition|)
name|error
operator|=
name|ie
operator|->
name|ie_assign_cpu
argument_list|(
name|ie
operator|->
name|ie_source
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|bindithread
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ie
operator|->
name|ie_thread
operator|!=
name|NULL
condition|)
block|{
name|cpu
operator|=
name|ie
operator|->
name|ie_cpu
expr_stmt|;
name|id
operator|=
name|ie
operator|->
name|ie_thread
operator|->
name|it_thread
operator|->
name|td_tid
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cpuset_setithread
argument_list|(
name|id
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|bindirq
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|ie
operator|->
name|ie_cpu
operator|=
name|cpu
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Bind an interrupt event to the specified CPU.  For supported platforms, any  * associated ithreads as well as the primary interrupt context will be bound  * to the specificed CPU.  */
end_comment

begin_function
name|int
name|intr_event_bind
parameter_list|(
name|struct
name|intr_event
modifier|*
name|ie
parameter_list|,
name|int
name|cpu
parameter_list|)
block|{
return|return
operator|(
name|_intr_event_bind
argument_list|(
name|ie
argument_list|,
name|cpu
argument_list|,
name|true
argument_list|,
name|true
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Bind an interrupt event to the specified CPU, but do not bind associated  * ithreads.  */
end_comment

begin_function
name|int
name|intr_event_bind_irqonly
parameter_list|(
name|struct
name|intr_event
modifier|*
name|ie
parameter_list|,
name|int
name|cpu
parameter_list|)
block|{
return|return
operator|(
name|_intr_event_bind
argument_list|(
name|ie
argument_list|,
name|cpu
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Bind an interrupt event's ithread to the specified CPU.  */
end_comment

begin_function
name|int
name|intr_event_bind_ithread
parameter_list|(
name|struct
name|intr_event
modifier|*
name|ie
parameter_list|,
name|int
name|cpu
parameter_list|)
block|{
return|return
operator|(
name|_intr_event_bind
argument_list|(
name|ie
argument_list|,
name|cpu
argument_list|,
name|false
argument_list|,
name|true
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|intr_event
modifier|*
name|intr_lookup
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
name|struct
name|intr_event
modifier|*
name|ie
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|event_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ie
argument_list|,
argument|&event_list
argument_list|,
argument|ie_list
argument_list|)
if|if
condition|(
name|ie
operator|->
name|ie_irq
operator|==
name|irq
operator|&&
operator|(
name|ie
operator|->
name|ie_flags
operator|&
name|IE_SOFT
operator|)
operator|==
literal|0
operator|&&
name|TAILQ_FIRST
argument_list|(
operator|&
name|ie
operator|->
name|ie_handlers
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
name|mtx_unlock
argument_list|(
operator|&
name|event_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ie
operator|)
return|;
block|}
end_function

begin_function
name|int
name|intr_setaffinity
parameter_list|(
name|int
name|irq
parameter_list|,
name|int
name|mode
parameter_list|,
name|void
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|intr_event
modifier|*
name|ie
decl_stmt|;
name|cpuset_t
modifier|*
name|mask
decl_stmt|;
name|int
name|cpu
decl_stmt|,
name|n
decl_stmt|;
name|mask
operator|=
name|m
expr_stmt|;
name|cpu
operator|=
name|NOCPU
expr_stmt|;
comment|/* 	 * If we're setting all cpus we can unbind.  Otherwise make sure 	 * only one cpu is in the set. 	 */
if|if
condition|(
name|CPU_CMP
argument_list|(
name|cpuset_root
argument_list|,
name|mask
argument_list|)
condition|)
block|{
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|CPU_SETSIZE
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|CPU_ISSET
argument_list|(
name|n
argument_list|,
name|mask
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|cpu
operator|!=
name|NOCPU
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|cpu
operator|=
name|n
expr_stmt|;
block|}
block|}
name|ie
operator|=
name|intr_lookup
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ie
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|CPU_WHICH_IRQ
case|:
return|return
operator|(
name|intr_event_bind
argument_list|(
name|ie
argument_list|,
name|cpu
argument_list|)
operator|)
return|;
case|case
name|CPU_WHICH_INTRHANDLER
case|:
return|return
operator|(
name|intr_event_bind_irqonly
argument_list|(
name|ie
argument_list|,
name|cpu
argument_list|)
operator|)
return|;
case|case
name|CPU_WHICH_ITHREAD
case|:
return|return
operator|(
name|intr_event_bind_ithread
argument_list|(
name|ie
argument_list|,
name|cpu
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|intr_getaffinity
parameter_list|(
name|int
name|irq
parameter_list|,
name|int
name|mode
parameter_list|,
name|void
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|intr_event
modifier|*
name|ie
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|cpuset_t
modifier|*
name|mask
decl_stmt|;
name|lwpid_t
name|id
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mask
operator|=
name|m
expr_stmt|;
name|ie
operator|=
name|intr_lookup
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ie
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
name|CPU_ZERO
argument_list|(
name|mask
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|CPU_WHICH_IRQ
case|:
case|case
name|CPU_WHICH_INTRHANDLER
case|:
name|mtx_lock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ie
operator|->
name|ie_cpu
operator|==
name|NOCPU
condition|)
name|CPU_COPY
argument_list|(
name|cpuset_root
argument_list|,
name|mask
argument_list|)
expr_stmt|;
else|else
name|CPU_SET
argument_list|(
name|ie
operator|->
name|ie_cpu
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|CPU_WHICH_ITHREAD
case|:
name|mtx_lock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ie
operator|->
name|ie_thread
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|CPU_COPY
argument_list|(
name|cpuset_root
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|id
operator|=
name|ie
operator|->
name|ie_thread
operator|->
name|it_thread
operator|->
name|td_tid
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|cpuset_which
argument_list|(
name|CPU_WHICH_TID
argument_list|,
name|id
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|td
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|CPU_COPY
argument_list|(
operator|&
name|td
operator|->
name|td_cpuset
operator|->
name|cs_mask
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|intr_event_destroy
parameter_list|(
name|struct
name|intr_event
modifier|*
name|ie
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|event_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ie
operator|->
name|ie_handlers
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|event_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|event_list
argument_list|,
name|ie
argument_list|,
name|ie_list
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|notyet
if|if
condition|(
name|ie
operator|->
name|ie_thread
operator|!=
name|NULL
condition|)
block|{
name|ithread_destroy
argument_list|(
name|ie
operator|->
name|ie_thread
argument_list|)
expr_stmt|;
name|ie
operator|->
name|ie_thread
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|event_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ie
argument_list|,
name|M_ITHREAD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|INTR_FILTER
end_ifndef

begin_function
specifier|static
name|struct
name|intr_thread
modifier|*
name|ithread_create
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|intr_thread
modifier|*
name|ithd
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ithd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|intr_thread
argument_list|)
argument_list|,
name|M_ITHREAD
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|error
operator|=
name|kproc_kthread_add
argument_list|(
name|ithread_loop
argument_list|,
name|ithd
argument_list|,
operator|&
name|intrproc
argument_list|,
operator|&
name|td
argument_list|,
name|RFSTOPPED
operator||
name|RFHIGHPID
argument_list|,
literal|0
argument_list|,
literal|"intr"
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"kproc_create() failed with %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|sched_class
argument_list|(
name|td
argument_list|,
name|PRI_ITHD
argument_list|)
expr_stmt|;
name|TD_SET_IWAIT
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_pflags
operator||=
name|TDP_ITHREAD
expr_stmt|;
name|ithd
operator|->
name|it_thread
operator|=
name|td
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: created %s"
argument_list|,
name|__func__
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ithd
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|struct
name|intr_thread
modifier|*
name|ithread_create
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|intr_handler
modifier|*
name|ih
parameter_list|)
block|{
name|struct
name|intr_thread
modifier|*
name|ithd
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ithd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|intr_thread
argument_list|)
argument_list|,
name|M_ITHREAD
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|error
operator|=
name|kproc_kthread_add
argument_list|(
name|ithread_loop
argument_list|,
name|ih
argument_list|,
operator|&
name|intrproc
argument_list|,
operator|&
name|td
argument_list|,
name|RFSTOPPED
operator||
name|RFHIGHPID
argument_list|,
literal|0
argument_list|,
literal|"intr"
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"kproc_create() failed with %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|sched_class
argument_list|(
name|td
argument_list|,
name|PRI_ITHD
argument_list|)
expr_stmt|;
name|TD_SET_IWAIT
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_pflags
operator||=
name|TDP_ITHREAD
expr_stmt|;
name|ithd
operator|->
name|it_thread
operator|=
name|td
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: created %s"
argument_list|,
name|__func__
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ithd
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|ithread_destroy
parameter_list|(
name|struct
name|intr_thread
modifier|*
name|ithread
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: killing %s"
argument_list|,
name|__func__
argument_list|,
name|ithread
operator|->
name|it_event
operator|->
name|ie_name
argument_list|)
expr_stmt|;
name|td
operator|=
name|ithread
operator|->
name|it_thread
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|ithread
operator|->
name|it_flags
operator||=
name|IT_DEAD
expr_stmt|;
if|if
condition|(
name|TD_AWAITING_INTR
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|TD_CLR_IWAIT
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|sched_add
argument_list|(
name|td
argument_list|,
name|SRQ_INTR
argument_list|)
expr_stmt|;
block|}
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|INTR_FILTER
end_ifndef

begin_function
name|int
name|intr_event_add_handler
parameter_list|(
name|struct
name|intr_event
modifier|*
name|ie
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|driver_filter_t
name|filter
parameter_list|,
name|driver_intr_t
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|u_char
name|pri
parameter_list|,
name|enum
name|intr_type
name|flags
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|intr_handler
modifier|*
name|ih
decl_stmt|,
modifier|*
name|temp_ih
decl_stmt|;
name|struct
name|intr_thread
modifier|*
name|it
decl_stmt|;
if|if
condition|(
name|ie
operator|==
name|NULL
operator|||
name|name
operator|==
name|NULL
operator|||
operator|(
name|handler
operator|==
name|NULL
operator|&&
name|filter
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Allocate and populate an interrupt handler structure. */
name|ih
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|intr_handler
argument_list|)
argument_list|,
name|M_ITHREAD
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ih
operator|->
name|ih_filter
operator|=
name|filter
expr_stmt|;
name|ih
operator|->
name|ih_handler
operator|=
name|handler
expr_stmt|;
name|ih
operator|->
name|ih_argument
operator|=
name|arg
expr_stmt|;
name|strlcpy
argument_list|(
name|ih
operator|->
name|ih_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ih
operator|->
name|ih_name
argument_list|)
argument_list|)
expr_stmt|;
name|ih
operator|->
name|ih_event
operator|=
name|ie
expr_stmt|;
name|ih
operator|->
name|ih_pri
operator|=
name|pri
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|INTR_EXCL
condition|)
name|ih
operator|->
name|ih_flags
operator|=
name|IH_EXCLUSIVE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|INTR_MPSAFE
condition|)
name|ih
operator|->
name|ih_flags
operator||=
name|IH_MPSAFE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|INTR_ENTROPY
condition|)
name|ih
operator|->
name|ih_flags
operator||=
name|IH_ENTROPY
expr_stmt|;
comment|/* We can only have one exclusive handler in a event. */
name|mtx_lock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ie
operator|->
name|ie_handlers
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|INTR_EXCL
operator|)
operator|||
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|ie
operator|->
name|ie_handlers
argument_list|)
operator|->
name|ih_flags
operator|&
name|IH_EXCLUSIVE
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ih
argument_list|,
name|M_ITHREAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
comment|/* Create a thread if we need one. */
while|while
condition|(
name|ie
operator|->
name|ie_thread
operator|==
name|NULL
operator|&&
name|handler
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ie
operator|->
name|ie_flags
operator|&
name|IE_ADDING_THREAD
condition|)
name|msleep
argument_list|(
name|ie
argument_list|,
operator|&
name|ie
operator|->
name|ie_lock
argument_list|,
literal|0
argument_list|,
literal|"ithread"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|ie
operator|->
name|ie_flags
operator||=
name|IE_ADDING_THREAD
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|it
operator|=
name|ithread_create
argument_list|(
literal|"intr: newborn"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|ie
operator|->
name|ie_flags
operator|&=
operator|~
name|IE_ADDING_THREAD
expr_stmt|;
name|ie
operator|->
name|ie_thread
operator|=
name|it
expr_stmt|;
name|it
operator|->
name|it_event
operator|=
name|ie
expr_stmt|;
name|ithread_update
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Add the new handler to the event in priority order. */
name|TAILQ_FOREACH
argument_list|(
argument|temp_ih
argument_list|,
argument|&ie->ie_handlers
argument_list|,
argument|ih_next
argument_list|)
block|{
if|if
condition|(
name|temp_ih
operator|->
name|ih_pri
operator|>
name|ih
operator|->
name|ih_pri
condition|)
break|break;
block|}
if|if
condition|(
name|temp_ih
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ie
operator|->
name|ie_handlers
argument_list|,
name|ih
argument_list|,
name|ih_next
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_BEFORE
argument_list|(
name|temp_ih
argument_list|,
name|ih
argument_list|,
name|ih_next
argument_list|)
expr_stmt|;
name|intr_event_update
argument_list|(
name|ie
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: added %s to %s"
argument_list|,
name|__func__
argument_list|,
name|ih
operator|->
name|ih_name
argument_list|,
name|ie
operator|->
name|ie_name
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookiep
operator|!=
name|NULL
condition|)
operator|*
name|cookiep
operator|=
name|ih
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|intr_event_add_handler
parameter_list|(
name|struct
name|intr_event
modifier|*
name|ie
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|driver_filter_t
name|filter
parameter_list|,
name|driver_intr_t
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|u_char
name|pri
parameter_list|,
name|enum
name|intr_type
name|flags
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|intr_handler
modifier|*
name|ih
decl_stmt|,
modifier|*
name|temp_ih
decl_stmt|;
name|struct
name|intr_thread
modifier|*
name|it
decl_stmt|;
if|if
condition|(
name|ie
operator|==
name|NULL
operator|||
name|name
operator|==
name|NULL
operator|||
operator|(
name|handler
operator|==
name|NULL
operator|&&
name|filter
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Allocate and populate an interrupt handler structure. */
name|ih
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|intr_handler
argument_list|)
argument_list|,
name|M_ITHREAD
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ih
operator|->
name|ih_filter
operator|=
name|filter
expr_stmt|;
name|ih
operator|->
name|ih_handler
operator|=
name|handler
expr_stmt|;
name|ih
operator|->
name|ih_argument
operator|=
name|arg
expr_stmt|;
name|strlcpy
argument_list|(
name|ih
operator|->
name|ih_name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|ih
operator|->
name|ih_name
argument_list|)
argument_list|)
expr_stmt|;
name|ih
operator|->
name|ih_event
operator|=
name|ie
expr_stmt|;
name|ih
operator|->
name|ih_pri
operator|=
name|pri
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|INTR_EXCL
condition|)
name|ih
operator|->
name|ih_flags
operator|=
name|IH_EXCLUSIVE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|INTR_MPSAFE
condition|)
name|ih
operator|->
name|ih_flags
operator||=
name|IH_MPSAFE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|INTR_ENTROPY
condition|)
name|ih
operator|->
name|ih_flags
operator||=
name|IH_ENTROPY
expr_stmt|;
comment|/* We can only have one exclusive handler in a event. */
name|mtx_lock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ie
operator|->
name|ie_handlers
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|INTR_EXCL
operator|)
operator|||
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|ie
operator|->
name|ie_handlers
argument_list|)
operator|->
name|ih_flags
operator|&
name|IH_EXCLUSIVE
operator|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ih
argument_list|,
name|M_ITHREAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
comment|/* For filtered handlers, create a private ithread to run on. */
if|if
condition|(
name|filter
operator|!=
name|NULL
operator|&&
name|handler
operator|!=
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|it
operator|=
name|ithread_create
argument_list|(
literal|"intr: newborn"
argument_list|,
name|ih
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|it
operator|->
name|it_event
operator|=
name|ie
expr_stmt|;
name|ih
operator|->
name|ih_thread
operator|=
name|it
expr_stmt|;
name|ithread_update
argument_list|(
name|it
argument_list|)
expr_stmt|;
comment|/* XXX - do we really need this?!?!? */
block|}
else|else
block|{
comment|/* Create the global per-event thread if we need one. */
while|while
condition|(
name|ie
operator|->
name|ie_thread
operator|==
name|NULL
operator|&&
name|handler
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ie
operator|->
name|ie_flags
operator|&
name|IE_ADDING_THREAD
condition|)
name|msleep
argument_list|(
name|ie
argument_list|,
operator|&
name|ie
operator|->
name|ie_lock
argument_list|,
literal|0
argument_list|,
literal|"ithread"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|ie
operator|->
name|ie_flags
operator||=
name|IE_ADDING_THREAD
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|it
operator|=
name|ithread_create
argument_list|(
literal|"intr: newborn"
argument_list|,
name|ih
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|ie
operator|->
name|ie_flags
operator|&=
operator|~
name|IE_ADDING_THREAD
expr_stmt|;
name|ie
operator|->
name|ie_thread
operator|=
name|it
expr_stmt|;
name|it
operator|->
name|it_event
operator|=
name|ie
expr_stmt|;
name|ithread_update
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|ie
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Add the new handler to the event in priority order. */
name|TAILQ_FOREACH
argument_list|(
argument|temp_ih
argument_list|,
argument|&ie->ie_handlers
argument_list|,
argument|ih_next
argument_list|)
block|{
if|if
condition|(
name|temp_ih
operator|->
name|ih_pri
operator|>
name|ih
operator|->
name|ih_pri
condition|)
break|break;
block|}
if|if
condition|(
name|temp_ih
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ie
operator|->
name|ie_handlers
argument_list|,
name|ih
argument_list|,
name|ih_next
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_BEFORE
argument_list|(
name|temp_ih
argument_list|,
name|ih
argument_list|,
name|ih_next
argument_list|)
expr_stmt|;
name|intr_event_update
argument_list|(
name|ie
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: added %s to %s"
argument_list|,
name|__func__
argument_list|,
name|ih
operator|->
name|ih_name
argument_list|,
name|ie
operator|->
name|ie_name
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookiep
operator|!=
name|NULL
condition|)
operator|*
name|cookiep
operator|=
name|ih
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Append a description preceded by a ':' to the name of the specified  * interrupt handler.  */
end_comment

begin_function
name|int
name|intr_event_describe_handler
parameter_list|(
name|struct
name|intr_event
modifier|*
name|ie
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|,
specifier|const
name|char
modifier|*
name|descr
parameter_list|)
block|{
name|struct
name|intr_handler
modifier|*
name|ih
decl_stmt|;
name|size_t
name|space
decl_stmt|;
name|char
modifier|*
name|start
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|TAILQ_FOREACH
argument_list|(
argument|ih
argument_list|,
argument|&ie->ie_handlers
argument_list|,
argument|ih_next
argument_list|)
block|{
if|if
condition|(
name|ih
operator|==
name|cookie
condition|)
break|break;
block|}
if|if
condition|(
name|ih
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"handler %p not found in interrupt event %p"
argument_list|,
name|cookie
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ih
operator|=
name|cookie
expr_stmt|;
comment|/* 	 * Look for an existing description by checking for an 	 * existing ":".  This assumes device names do not include 	 * colons.  If one is found, prepare to insert the new 	 * description at that point.  If one is not found, find the 	 * end of the name to use as the insertion point. 	 */
name|start
operator|=
name|strchr
argument_list|(
name|ih
operator|->
name|ih_name
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|NULL
condition|)
name|start
operator|=
name|strchr
argument_list|(
name|ih
operator|->
name|ih_name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * See if there is enough remaining room in the string for the 	 * description + ":".  The "- 1" leaves room for the trailing 	 * '\0'.  The "+ 1" accounts for the colon. 	 */
name|space
operator|=
sizeof|sizeof
argument_list|(
name|ih
operator|->
name|ih_name
argument_list|)
operator|-
operator|(
name|start
operator|-
name|ih
operator|->
name|ih_name
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|descr
argument_list|)
operator|+
literal|1
operator|>
name|space
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
comment|/* Append a colon followed by the description. */
operator|*
name|start
operator|=
literal|':'
expr_stmt|;
name|strcpy
argument_list|(
name|start
operator|+
literal|1
argument_list|,
name|descr
argument_list|)
expr_stmt|;
name|intr_event_update
argument_list|(
name|ie
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the ie_source field from the intr_event an intr_handler is  * associated with.  */
end_comment

begin_function
name|void
modifier|*
name|intr_handler_source
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|intr_handler
modifier|*
name|ih
decl_stmt|;
name|struct
name|intr_event
modifier|*
name|ie
decl_stmt|;
name|ih
operator|=
operator|(
expr|struct
name|intr_handler
operator|*
operator|)
name|cookie
expr_stmt|;
if|if
condition|(
name|ih
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ie
operator|=
name|ih
operator|->
name|ih_event
expr_stmt|;
name|KASSERT
argument_list|(
name|ie
operator|!=
name|NULL
argument_list|,
operator|(
literal|"interrupt handler \"%s\" has a NULL interrupt event"
operator|,
name|ih
operator|->
name|ih_name
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ie
operator|->
name|ie_source
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sleep until an ithread finishes executing an interrupt handler.  *  * XXX Doesn't currently handle interrupt filters or fast interrupt  * handlers.  This is intended for compatibility with linux drivers  * only.  Do not use in BSD code.  */
end_comment

begin_function
name|void
name|_intr_drain
parameter_list|(
name|int
name|irq
parameter_list|)
block|{
name|struct
name|intr_event
modifier|*
name|ie
decl_stmt|;
name|struct
name|intr_thread
modifier|*
name|ithd
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|ie
operator|=
name|intr_lookup
argument_list|(
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ie
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|ie
operator|->
name|ie_thread
operator|==
name|NULL
condition|)
return|return;
name|ithd
operator|=
name|ie
operator|->
name|ie_thread
expr_stmt|;
name|td
operator|=
name|ithd
operator|->
name|it_thread
expr_stmt|;
comment|/* 	 * We set the flag and wait for it to be cleared to avoid 	 * long delays with potentially busy interrupt handlers 	 * were we to only sample TD_AWAITING_INTR() every tick. 	 */
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TD_AWAITING_INTR
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|ithd
operator|->
name|it_flags
operator||=
name|IT_WAIT
expr_stmt|;
while|while
condition|(
name|ithd
operator|->
name|it_flags
operator|&
name|IT_WAIT
condition|)
block|{
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|pause
argument_list|(
literal|"idrain"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
block|}
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|INTR_FILTER
end_ifndef

begin_function
name|int
name|intr_event_remove_handler
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|intr_handler
modifier|*
name|handler
init|=
operator|(
expr|struct
name|intr_handler
operator|*
operator|)
name|cookie
decl_stmt|;
name|struct
name|intr_event
modifier|*
name|ie
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|intr_handler
modifier|*
name|ih
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|notyet
name|int
name|dead
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|handler
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ie
operator|=
name|handler
operator|->
name|ih_event
expr_stmt|;
name|KASSERT
argument_list|(
name|ie
operator|!=
name|NULL
argument_list|,
operator|(
literal|"interrupt handler \"%s\" has a NULL interrupt event"
operator|,
name|handler
operator|->
name|ih_name
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: removing %s from %s"
argument_list|,
name|__func__
argument_list|,
name|handler
operator|->
name|ih_name
argument_list|,
name|ie
operator|->
name|ie_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|TAILQ_FOREACH
argument_list|(
argument|ih
argument_list|,
argument|&ie->ie_handlers
argument_list|,
argument|ih_next
argument_list|)
if|if
condition|(
name|ih
operator|==
name|handler
condition|)
goto|goto
name|ok
goto|;
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"interrupt handler \"%s\" not found in interrupt event \"%s\""
argument_list|,
name|ih
operator|->
name|ih_name
argument_list|,
name|ie
operator|->
name|ie_name
argument_list|)
expr_stmt|;
name|ok
label|:
endif|#
directive|endif
comment|/* 	 * If there is no ithread, then just remove the handler and return. 	 * XXX: Note that an INTR_FAST handler might be running on another 	 * CPU! 	 */
if|if
condition|(
name|ie
operator|->
name|ie_thread
operator|==
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ie
operator|->
name|ie_handlers
argument_list|,
name|handler
argument_list|,
name|ih_next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|handler
argument_list|,
name|M_ITHREAD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If the interrupt thread is already running, then just mark this 	 * handler as being dead and let the ithread do the actual removal. 	 * 	 * During a cold boot while cold is set, msleep() does not sleep, 	 * so we have to remove the handler here rather than letting the 	 * thread do it. 	 */
name|thread_lock
argument_list|(
name|ie
operator|->
name|ie_thread
operator|->
name|it_thread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TD_AWAITING_INTR
argument_list|(
name|ie
operator|->
name|ie_thread
operator|->
name|it_thread
argument_list|)
operator|&&
operator|!
name|cold
condition|)
block|{
name|handler
operator|->
name|ih_flags
operator||=
name|IH_DEAD
expr_stmt|;
comment|/* 		 * Ensure that the thread will process the handler list 		 * again and remove this handler if it has already passed 		 * it on the list. 		 * 		 * The release part of the following store ensures 		 * that the update of ih_flags is ordered before the 		 * it_need setting.  See the comment before 		 * atomic_cmpset_acq(&ithd->it_need, ...) operation in 		 * the ithread_execute_handlers(). 		 */
name|atomic_store_rel_int
argument_list|(
operator|&
name|ie
operator|->
name|ie_thread
operator|->
name|it_need
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ie
operator|->
name|ie_handlers
argument_list|,
name|handler
argument_list|,
name|ih_next
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|ie
operator|->
name|ie_thread
operator|->
name|it_thread
argument_list|)
expr_stmt|;
while|while
condition|(
name|handler
operator|->
name|ih_flags
operator|&
name|IH_DEAD
condition|)
name|msleep
argument_list|(
name|handler
argument_list|,
operator|&
name|ie
operator|->
name|ie_lock
argument_list|,
literal|0
argument_list|,
literal|"iev_rmh"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|intr_event_update
argument_list|(
name|ie
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* 	 * XXX: This could be bad in the case of ppbus(8).  Also, I think 	 * this could lead to races of stale data when servicing an 	 * interrupt. 	 */
name|dead
operator|=
literal|1
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ih
argument_list|,
argument|&ie->ie_handlers
argument_list|,
argument|ih_next
argument_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|ih
operator|->
name|ih_flags
operator|&
name|IH_FAST
operator|)
condition|)
block|{
name|dead
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|dead
condition|)
block|{
name|ithread_destroy
argument_list|(
name|ie
operator|->
name|ie_thread
argument_list|)
expr_stmt|;
name|ie
operator|->
name|ie_thread
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|handler
argument_list|,
name|M_ITHREAD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intr_event_schedule_thread
parameter_list|(
name|struct
name|intr_event
modifier|*
name|ie
parameter_list|)
block|{
name|struct
name|intr_entropy
name|entropy
decl_stmt|;
name|struct
name|intr_thread
modifier|*
name|it
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|thread
modifier|*
name|ctd
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
comment|/* 	 * If no ithread or no handlers, then we have a stray interrupt. 	 */
if|if
condition|(
name|ie
operator|==
name|NULL
operator|||
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ie
operator|->
name|ie_handlers
argument_list|)
operator|||
name|ie
operator|->
name|ie_thread
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ctd
operator|=
name|curthread
expr_stmt|;
name|it
operator|=
name|ie
operator|->
name|ie_thread
expr_stmt|;
name|td
operator|=
name|it
operator|->
name|it_thread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
comment|/* 	 * If any of the handlers for this ithread claim to be good 	 * sources of entropy, then gather some. 	 */
if|if
condition|(
name|ie
operator|->
name|ie_flags
operator|&
name|IE_ENTROPY
condition|)
block|{
name|entropy
operator|.
name|event
operator|=
operator|(
name|uintptr_t
operator|)
name|ie
expr_stmt|;
name|entropy
operator|.
name|td
operator|=
name|ctd
expr_stmt|;
name|random_harvest_queue
argument_list|(
operator|&
name|entropy
argument_list|,
sizeof|sizeof
argument_list|(
name|entropy
argument_list|)
argument_list|,
literal|2
argument_list|,
name|RANDOM_INTERRUPT
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|p
operator|!=
name|NULL
argument_list|,
operator|(
literal|"ithread %s has no process"
operator|,
name|ie
operator|->
name|ie_name
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set it_need to tell the thread to keep running if it is already 	 * running.  Then, lock the thread and see if we actually need to 	 * put it on the runqueue. 	 * 	 * Use store_rel to arrange that the store to ih_need in 	 * swi_sched() is before the store to it_need and prepare for 	 * transfer of this order to loads in the ithread. 	 */
name|atomic_store_rel_int
argument_list|(
operator|&
name|it
operator|->
name|it_need
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|TD_AWAITING_INTR
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: schedule pid %d (%s)"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_name
argument_list|)
expr_stmt|;
name|TD_CLR_IWAIT
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|sched_add
argument_list|(
name|td
argument_list|,
name|SRQ_INTR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CTR5
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: pid %d (%s): it_need %d, state %d"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_name
argument_list|,
name|it
operator|->
name|it_need
argument_list|,
name|td
operator|->
name|td_state
argument_list|)
expr_stmt|;
block|}
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|intr_event_remove_handler
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|intr_handler
modifier|*
name|handler
init|=
operator|(
expr|struct
name|intr_handler
operator|*
operator|)
name|cookie
decl_stmt|;
name|struct
name|intr_event
modifier|*
name|ie
decl_stmt|;
name|struct
name|intr_thread
modifier|*
name|it
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|intr_handler
modifier|*
name|ih
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|notyet
name|int
name|dead
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|handler
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ie
operator|=
name|handler
operator|->
name|ih_event
expr_stmt|;
name|KASSERT
argument_list|(
name|ie
operator|!=
name|NULL
argument_list|,
operator|(
literal|"interrupt handler \"%s\" has a NULL interrupt event"
operator|,
name|handler
operator|->
name|ih_name
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: removing %s from %s"
argument_list|,
name|__func__
argument_list|,
name|handler
operator|->
name|ih_name
argument_list|,
name|ie
operator|->
name|ie_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|TAILQ_FOREACH
argument_list|(
argument|ih
argument_list|,
argument|&ie->ie_handlers
argument_list|,
argument|ih_next
argument_list|)
if|if
condition|(
name|ih
operator|==
name|handler
condition|)
goto|goto
name|ok
goto|;
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"interrupt handler \"%s\" not found in interrupt event \"%s\""
argument_list|,
name|ih
operator|->
name|ih_name
argument_list|,
name|ie
operator|->
name|ie_name
argument_list|)
expr_stmt|;
name|ok
label|:
endif|#
directive|endif
comment|/* 	 * If there are no ithreads (per event and per handler), then 	 * just remove the handler and return.   	 * XXX: Note that an INTR_FAST handler might be running on another CPU! 	 */
if|if
condition|(
name|ie
operator|->
name|ie_thread
operator|==
name|NULL
operator|&&
name|handler
operator|->
name|ih_thread
operator|==
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ie
operator|->
name|ie_handlers
argument_list|,
name|handler
argument_list|,
name|ih_next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|handler
argument_list|,
name|M_ITHREAD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Private or global ithread? */
name|it
operator|=
operator|(
name|handler
operator|->
name|ih_thread
operator|)
condition|?
name|handler
operator|->
name|ih_thread
else|:
name|ie
operator|->
name|ie_thread
expr_stmt|;
comment|/* 	 * If the interrupt thread is already running, then just mark this 	 * handler as being dead and let the ithread do the actual removal. 	 * 	 * During a cold boot while cold is set, msleep() does not sleep, 	 * so we have to remove the handler here rather than letting the 	 * thread do it. 	 */
name|thread_lock
argument_list|(
name|it
operator|->
name|it_thread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TD_AWAITING_INTR
argument_list|(
name|it
operator|->
name|it_thread
argument_list|)
operator|&&
operator|!
name|cold
condition|)
block|{
name|handler
operator|->
name|ih_flags
operator||=
name|IH_DEAD
expr_stmt|;
comment|/* 		 * Ensure that the thread will process the handler list 		 * again and remove this handler if it has already passed 		 * it on the list. 		 * 		 * The release part of the following store ensures 		 * that the update of ih_flags is ordered before the 		 * it_need setting.  See the comment before 		 * atomic_cmpset_acq(&ithd->it_need, ...) operation in 		 * the ithread_execute_handlers(). 		 */
name|atomic_store_rel_int
argument_list|(
operator|&
name|it
operator|->
name|it_need
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ie
operator|->
name|ie_handlers
argument_list|,
name|handler
argument_list|,
name|ih_next
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|it
operator|->
name|it_thread
argument_list|)
expr_stmt|;
while|while
condition|(
name|handler
operator|->
name|ih_flags
operator|&
name|IH_DEAD
condition|)
name|msleep
argument_list|(
name|handler
argument_list|,
operator|&
name|ie
operator|->
name|ie_lock
argument_list|,
literal|0
argument_list|,
literal|"iev_rmh"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*  	 * At this point, the handler has been disconnected from the event, 	 * so we can kill the private ithread if any. 	 */
if|if
condition|(
name|handler
operator|->
name|ih_thread
condition|)
block|{
name|ithread_destroy
argument_list|(
name|handler
operator|->
name|ih_thread
argument_list|)
expr_stmt|;
name|handler
operator|->
name|ih_thread
operator|=
name|NULL
expr_stmt|;
block|}
name|intr_event_update
argument_list|(
name|ie
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* 	 * XXX: This could be bad in the case of ppbus(8).  Also, I think 	 * this could lead to races of stale data when servicing an 	 * interrupt. 	 */
name|dead
operator|=
literal|1
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ih
argument_list|,
argument|&ie->ie_handlers
argument_list|,
argument|ih_next
argument_list|)
block|{
if|if
condition|(
name|handler
operator|!=
name|NULL
condition|)
block|{
name|dead
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|dead
condition|)
block|{
name|ithread_destroy
argument_list|(
name|ie
operator|->
name|ie_thread
argument_list|)
expr_stmt|;
name|ie
operator|->
name|ie_thread
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|handler
argument_list|,
name|M_ITHREAD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|intr_event_schedule_thread
parameter_list|(
name|struct
name|intr_event
modifier|*
name|ie
parameter_list|,
name|struct
name|intr_thread
modifier|*
name|it
parameter_list|)
block|{
name|struct
name|intr_entropy
name|entropy
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|thread
modifier|*
name|ctd
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
comment|/* 	 * If no ithread or no handlers, then we have a stray interrupt. 	 */
if|if
condition|(
name|ie
operator|==
name|NULL
operator|||
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ie
operator|->
name|ie_handlers
argument_list|)
operator|||
name|it
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ctd
operator|=
name|curthread
expr_stmt|;
name|td
operator|=
name|it
operator|->
name|it_thread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
comment|/* 	 * If any of the handlers for this ithread claim to be good 	 * sources of entropy, then gather some. 	 */
if|if
condition|(
name|ie
operator|->
name|ie_flags
operator|&
name|IE_ENTROPY
condition|)
block|{
name|entropy
operator|.
name|event
operator|=
operator|(
name|uintptr_t
operator|)
name|ie
expr_stmt|;
name|entropy
operator|.
name|td
operator|=
name|ctd
expr_stmt|;
name|random_harvest_queue
argument_list|(
operator|&
name|entropy
argument_list|,
sizeof|sizeof
argument_list|(
name|entropy
argument_list|)
argument_list|,
literal|2
argument_list|,
name|RANDOM_INTERRUPT
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|p
operator|!=
name|NULL
argument_list|,
operator|(
literal|"ithread %s has no process"
operator|,
name|ie
operator|->
name|ie_name
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set it_need to tell the thread to keep running if it is already 	 * running.  Then, lock the thread and see if we actually need to 	 * put it on the runqueue. 	 * 	 * Use store_rel to arrange that the store to ih_need in 	 * swi_sched() is before the store to it_need and prepare for 	 * transfer of this order to loads in the ithread. 	 */
name|atomic_store_rel_int
argument_list|(
operator|&
name|it
operator|->
name|it_need
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|TD_AWAITING_INTR
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: schedule pid %d (%s)"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_name
argument_list|)
expr_stmt|;
name|TD_CLR_IWAIT
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|sched_add
argument_list|(
name|td
argument_list|,
name|SRQ_INTR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CTR5
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: pid %d (%s): it_need %d, state %d"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_name
argument_list|,
name|it
operator|->
name|it_need
argument_list|,
name|td
operator|->
name|td_state
argument_list|)
expr_stmt|;
block|}
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Allow interrupt event binding for software interrupt handlers -- a no-op,  * since interrupts are generated in software rather than being directed by  * a PIC.  */
end_comment

begin_function
specifier|static
name|int
name|swi_assign_cpu
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|cpu
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a software interrupt handler to a specified event.  If a given event  * is not specified, then a new event is created.  */
end_comment

begin_function
name|int
name|swi_add
parameter_list|(
name|struct
name|intr_event
modifier|*
modifier|*
name|eventp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|driver_intr_t
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pri
parameter_list|,
name|enum
name|intr_type
name|flags
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|intr_event
modifier|*
name|ie
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|INTR_ENTROPY
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ie
operator|=
operator|(
name|eventp
operator|!=
name|NULL
operator|)
condition|?
operator|*
name|eventp
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|ie
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ie
operator|->
name|ie_flags
operator|&
name|IE_SOFT
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
else|else
block|{
name|error
operator|=
name|intr_event_create
argument_list|(
operator|&
name|ie
argument_list|,
name|NULL
argument_list|,
name|IE_SOFT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|swi_assign_cpu
argument_list|,
literal|"swi%d:"
argument_list|,
name|pri
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|eventp
operator|!=
name|NULL
condition|)
operator|*
name|eventp
operator|=
name|ie
expr_stmt|;
block|}
name|error
operator|=
name|intr_event_add_handler
argument_list|(
name|ie
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|handler
argument_list|,
name|arg
argument_list|,
name|PI_SWI
argument_list|(
name|pri
argument_list|)
argument_list|,
name|flags
argument_list|,
name|cookiep
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Schedule a software interrupt thread.  */
end_comment

begin_function
name|void
name|swi_sched
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|intr_handler
modifier|*
name|ih
init|=
operator|(
expr|struct
name|intr_handler
operator|*
operator|)
name|cookie
decl_stmt|;
name|struct
name|intr_event
modifier|*
name|ie
init|=
name|ih
operator|->
name|ih_event
decl_stmt|;
name|struct
name|intr_entropy
name|entropy
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_INTR
argument_list|,
literal|"swi_sched: %s %s need=%d"
argument_list|,
name|ie
operator|->
name|ie_name
argument_list|,
name|ih
operator|->
name|ih_name
argument_list|,
name|ih
operator|->
name|ih_need
argument_list|)
expr_stmt|;
name|entropy
operator|.
name|event
operator|=
operator|(
name|uintptr_t
operator|)
name|ih
expr_stmt|;
name|entropy
operator|.
name|td
operator|=
name|curthread
expr_stmt|;
name|random_harvest_queue
argument_list|(
operator|&
name|entropy
argument_list|,
sizeof|sizeof
argument_list|(
name|entropy
argument_list|)
argument_list|,
literal|1
argument_list|,
name|RANDOM_SWI
argument_list|)
expr_stmt|;
comment|/* 	 * Set ih_need for this handler so that if the ithread is already 	 * running it will execute this handler on the next pass.  Otherwise, 	 * it will execute it the next time it runs. 	 */
name|ih
operator|->
name|ih_need
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SWI_DELAY
operator|)
condition|)
block|{
name|VM_CNT_INC
argument_list|(
name|v_soft
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INTR_FILTER
name|error
operator|=
name|intr_event_schedule_thread
argument_list|(
name|ie
argument_list|,
name|ie
operator|->
name|ie_thread
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|intr_event_schedule_thread
argument_list|(
name|ie
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"stray software interrupt"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Remove a software interrupt handler.  Currently this code does not  * remove the associated interrupt event if it becomes empty.  Calling code  * may do so manually via intr_event_destroy(), but that's not really  * an optimal interface.  */
end_comment

begin_function
name|int
name|swi_remove
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|)
block|{
return|return
operator|(
name|intr_event_remove_handler
argument_list|(
name|cookie
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INTR_FILTER
end_ifdef

begin_function
specifier|static
name|void
name|priv_ithread_execute_handler
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|intr_handler
modifier|*
name|ih
parameter_list|)
block|{
name|struct
name|intr_event
modifier|*
name|ie
decl_stmt|;
name|ie
operator|=
name|ih
operator|->
name|ih_event
expr_stmt|;
comment|/* 	 * If this handler is marked for death, remove it from 	 * the list of handlers and wake up the sleeper. 	 */
if|if
condition|(
name|ih
operator|->
name|ih_flags
operator|&
name|IH_DEAD
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ie
operator|->
name|ie_handlers
argument_list|,
name|ih
argument_list|,
name|ih_next
argument_list|)
expr_stmt|;
name|ih
operator|->
name|ih_flags
operator|&=
operator|~
name|IH_DEAD
expr_stmt|;
name|wakeup
argument_list|(
name|ih
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Execute this handler. */
name|CTR6
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: pid %d exec %p(%p) for %s flg=%x"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ih
operator|->
name|ih_handler
argument_list|,
name|ih
operator|->
name|ih_argument
argument_list|,
name|ih
operator|->
name|ih_name
argument_list|,
name|ih
operator|->
name|ih_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ih
operator|->
name|ih_flags
operator|&
name|IH_MPSAFE
operator|)
condition|)
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|ih
operator|->
name|ih_handler
argument_list|(
name|ih
operator|->
name|ih_argument
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ih
operator|->
name|ih_flags
operator|&
name|IH_MPSAFE
operator|)
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This is a public function for use by drivers that mux interrupt  * handlers for child devices from their interrupt handler.  */
end_comment

begin_function
name|void
name|intr_event_execute_handlers
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|intr_event
modifier|*
name|ie
parameter_list|)
block|{
name|struct
name|intr_handler
modifier|*
name|ih
decl_stmt|,
modifier|*
name|ihn
decl_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ih
argument_list|,
argument|&ie->ie_handlers
argument_list|,
argument|ih_next
argument_list|,
argument|ihn
argument_list|)
block|{
comment|/* 		 * If this handler is marked for death, remove it from 		 * the list of handlers and wake up the sleeper. 		 */
if|if
condition|(
name|ih
operator|->
name|ih_flags
operator|&
name|IH_DEAD
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ie
operator|->
name|ie_handlers
argument_list|,
name|ih
argument_list|,
name|ih_next
argument_list|)
expr_stmt|;
name|ih
operator|->
name|ih_flags
operator|&=
operator|~
name|IH_DEAD
expr_stmt|;
name|wakeup
argument_list|(
name|ih
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ie
operator|->
name|ie_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Skip filter only handlers */
if|if
condition|(
name|ih
operator|->
name|ih_handler
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 		 * For software interrupt threads, we only execute 		 * handlers that have their need flag set.  Hardware 		 * interrupt threads always invoke all of their handlers. 		 * 		 * ih_need can only be 0 or 1.  Failed cmpset below 		 * means that there is no request to execute handlers, 		 * so a retry of the cmpset is not needed. 		 */
if|if
condition|(
operator|(
name|ie
operator|->
name|ie_flags
operator|&
name|IE_SOFT
operator|)
operator|!=
literal|0
operator|&&
name|atomic_cmpset_int
argument_list|(
operator|&
name|ih
operator|->
name|ih_need
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Execute this handler. */
name|CTR6
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: pid %d exec %p(%p) for %s flg=%x"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ih
operator|->
name|ih_handler
argument_list|,
name|ih
operator|->
name|ih_argument
argument_list|,
name|ih
operator|->
name|ih_name
argument_list|,
name|ih
operator|->
name|ih_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ih
operator|->
name|ih_flags
operator|&
name|IH_MPSAFE
operator|)
condition|)
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|ih
operator|->
name|ih_handler
argument_list|(
name|ih
operator|->
name|ih_argument
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ih
operator|->
name|ih_flags
operator|&
name|IH_MPSAFE
operator|)
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ithread_execute_handlers
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|intr_event
modifier|*
name|ie
parameter_list|)
block|{
comment|/* Interrupt handlers should not sleep. */
if|if
condition|(
operator|!
operator|(
name|ie
operator|->
name|ie_flags
operator|&
name|IE_SOFT
operator|)
condition|)
name|THREAD_NO_SLEEPING
argument_list|()
expr_stmt|;
name|intr_event_execute_handlers
argument_list|(
name|p
argument_list|,
name|ie
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ie
operator|->
name|ie_flags
operator|&
name|IE_SOFT
operator|)
condition|)
name|THREAD_SLEEPING_OK
argument_list|()
expr_stmt|;
comment|/* 	 * Interrupt storm handling: 	 * 	 * If this interrupt source is currently storming, then throttle 	 * it to only fire the handler once  per clock tick. 	 * 	 * If this interrupt source is not currently storming, but the 	 * number of back to back interrupts exceeds the storm threshold, 	 * then enter storming mode. 	 */
if|if
condition|(
name|intr_storm_threshold
operator|!=
literal|0
operator|&&
name|ie
operator|->
name|ie_count
operator|>=
name|intr_storm_threshold
operator|&&
operator|!
operator|(
name|ie
operator|->
name|ie_flags
operator|&
name|IE_SOFT
operator|)
condition|)
block|{
comment|/* Report the message only once every second. */
if|if
condition|(
name|ppsratecheck
argument_list|(
operator|&
name|ie
operator|->
name|ie_warntm
argument_list|,
operator|&
name|ie
operator|->
name|ie_warncnt
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"interrupt storm detected on \"%s\"; throttling interrupt source\n"
argument_list|,
name|ie
operator|->
name|ie_name
argument_list|)
expr_stmt|;
block|}
name|pause
argument_list|(
literal|"istorm"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|ie
operator|->
name|ie_count
operator|++
expr_stmt|;
comment|/* 	 * Now that all the handlers have had a chance to run, reenable 	 * the interrupt source. 	 */
if|if
condition|(
name|ie
operator|->
name|ie_post_ithread
operator|!=
name|NULL
condition|)
name|ie
operator|->
name|ie_post_ithread
argument_list|(
name|ie
operator|->
name|ie_source
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|INTR_FILTER
end_ifndef

begin_comment
comment|/*  * This is the main code for interrupt threads.  */
end_comment

begin_function
specifier|static
name|void
name|ithread_loop
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|intr_thread
modifier|*
name|ithd
decl_stmt|;
name|struct
name|intr_event
modifier|*
name|ie
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|wake
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|ithd
operator|=
operator|(
expr|struct
name|intr_thread
operator|*
operator|)
name|arg
expr_stmt|;
name|KASSERT
argument_list|(
name|ithd
operator|->
name|it_thread
operator|==
name|td
argument_list|,
operator|(
literal|"%s: ithread and proc linkage out of sync"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ie
operator|=
name|ithd
operator|->
name|it_event
expr_stmt|;
name|ie
operator|->
name|ie_count
operator|=
literal|0
expr_stmt|;
name|wake
operator|=
literal|0
expr_stmt|;
comment|/* 	 * As long as we have interrupts outstanding, go through the 	 * list of handlers, giving each one a go at it. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * If we are an orphaned thread, then just die. 		 */
if|if
condition|(
name|ithd
operator|->
name|it_flags
operator|&
name|IT_DEAD
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: pid %d (%s) exiting"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ithd
argument_list|,
name|M_ITHREAD
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|()
expr_stmt|;
block|}
comment|/* 		 * Service interrupts.  If another interrupt arrives while 		 * we are running, it will set it_need to note that we 		 * should make another pass. 		 * 		 * The load_acq part of the following cmpset ensures 		 * that the load of ih_need in ithread_execute_handlers() 		 * is ordered after the load of it_need here. 		 */
while|while
condition|(
name|atomic_cmpset_acq_int
argument_list|(
operator|&
name|ithd
operator|->
name|it_need
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
name|ithread_execute_handlers
argument_list|(
name|p
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|WITNESS_WARN
argument_list|(
name|WARN_PANIC
argument_list|,
name|NULL
argument_list|,
literal|"suspending ithread"
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
comment|/* 		 * Processed all our interrupts.  Now get the sched 		 * lock.  This may take a while and it_need may get 		 * set again, so we have to check it again. 		 */
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|ithd
operator|->
name|it_need
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|ithd
operator|->
name|it_flags
operator|&
operator|(
name|IT_DEAD
operator||
name|IT_WAIT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|TD_SET_IWAIT
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|ie
operator|->
name|ie_count
operator|=
literal|0
expr_stmt|;
name|mi_switch
argument_list|(
name|SW_VOL
operator||
name|SWT_IWAIT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ithd
operator|->
name|it_flags
operator|&
name|IT_WAIT
condition|)
block|{
name|wake
operator|=
literal|1
expr_stmt|;
name|ithd
operator|->
name|it_flags
operator|&=
operator|~
name|IT_WAIT
expr_stmt|;
block|}
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|wake
condition|)
block|{
name|wakeup
argument_list|(
name|ithd
argument_list|)
expr_stmt|;
name|wake
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Main interrupt handling body.  *  * Input:  * o ie:                        the event connected to this interrupt.  * o frame:                     some archs (i.e. i386) pass a frame to some.  *                              handlers as their main argument.  * Return value:  * o 0:                         everything ok.  * o EINVAL:                    stray interrupt.  */
end_comment

begin_function
name|int
name|intr_event_handle
parameter_list|(
name|struct
name|intr_event
modifier|*
name|ie
parameter_list|,
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
name|struct
name|intr_handler
modifier|*
name|ih
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|oldframe
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|error
decl_stmt|,
name|ret
decl_stmt|,
name|thread
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
ifdef|#
directive|ifdef
name|KSTACK_USAGE_PROF
name|intr_prof_stack_use
argument_list|(
name|td
argument_list|,
name|frame
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* An interrupt with no event or handlers is a stray interrupt. */
if|if
condition|(
name|ie
operator|==
name|NULL
operator|||
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ie
operator|->
name|ie_handlers
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Execute fast interrupt handlers directly. 	 * To support clock handlers, if a handler registers 	 * with a NULL argument, then we pass it a pointer to 	 * a trapframe as its argument. 	 */
name|td
operator|->
name|td_intr_nesting_level
operator|++
expr_stmt|;
name|thread
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|oldframe
operator|=
name|td
operator|->
name|td_intr_frame
expr_stmt|;
name|td
operator|->
name|td_intr_frame
operator|=
name|frame
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ih
argument_list|,
argument|&ie->ie_handlers
argument_list|,
argument|ih_next
argument_list|)
block|{
if|if
condition|(
name|ih
operator|->
name|ih_filter
operator|==
name|NULL
condition|)
block|{
name|thread
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|CTR4
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: exec %p(%p) for %s"
argument_list|,
name|__func__
argument_list|,
name|ih
operator|->
name|ih_filter
argument_list|,
name|ih
operator|->
name|ih_argument
operator|==
name|NULL
condition|?
name|frame
else|:
name|ih
operator|->
name|ih_argument
argument_list|,
name|ih
operator|->
name|ih_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ih
operator|->
name|ih_argument
operator|==
name|NULL
condition|)
name|ret
operator|=
name|ih
operator|->
name|ih_filter
argument_list|(
name|frame
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|ih
operator|->
name|ih_filter
argument_list|(
name|ih
operator|->
name|ih_argument
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ret
operator|==
name|FILTER_STRAY
operator|||
operator|(
operator|(
name|ret
operator|&
operator|(
name|FILTER_SCHEDULE_THREAD
operator||
name|FILTER_HANDLED
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ret
operator|&
operator|~
operator|(
name|FILTER_SCHEDULE_THREAD
operator||
name|FILTER_HANDLED
operator|)
operator|)
operator|==
literal|0
operator|)
argument_list|,
operator|(
literal|"%s: incorrect return value %#x from %s"
operator|,
name|__func__
operator|,
name|ret
operator|,
name|ih
operator|->
name|ih_name
operator|)
argument_list|)
expr_stmt|;
comment|/*  		 * Wrapper handler special handling: 		 * 		 * in some particular cases (like pccard and pccbb),  		 * the _real_ device handler is wrapped in a couple of 		 * functions - a filter wrapper and an ithread wrapper. 		 * In this case (and just in this case), the filter wrapper  		 * could ask the system to schedule the ithread and mask 		 * the interrupt source if the wrapped handler is composed 		 * of just an ithread handler. 		 * 		 * TODO: write a generic wrapper to avoid people rolling  		 * their own 		 */
if|if
condition|(
operator|!
name|thread
condition|)
block|{
if|if
condition|(
name|ret
operator|==
name|FILTER_SCHEDULE_THREAD
condition|)
name|thread
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|td
operator|->
name|td_intr_frame
operator|=
name|oldframe
expr_stmt|;
if|if
condition|(
name|thread
condition|)
block|{
if|if
condition|(
name|ie
operator|->
name|ie_pre_ithread
operator|!=
name|NULL
condition|)
name|ie
operator|->
name|ie_pre_ithread
argument_list|(
name|ie
operator|->
name|ie_source
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ie
operator|->
name|ie_post_filter
operator|!=
name|NULL
condition|)
name|ie
operator|->
name|ie_post_filter
argument_list|(
name|ie
operator|->
name|ie_source
argument_list|)
expr_stmt|;
block|}
comment|/* Schedule the ithread if needed. */
if|if
condition|(
name|thread
condition|)
block|{
name|error
operator|=
name|intr_event_schedule_thread
argument_list|(
name|ie
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"bad stray interrupt"
operator|)
argument_list|)
expr_stmt|;
block|}
name|critical_exit
argument_list|()
expr_stmt|;
name|td
operator|->
name|td_intr_nesting_level
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * This is the main code for interrupt threads.  */
end_comment

begin_function
specifier|static
name|void
name|ithread_loop
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|intr_thread
modifier|*
name|ithd
decl_stmt|;
name|struct
name|intr_handler
modifier|*
name|ih
decl_stmt|;
name|struct
name|intr_event
modifier|*
name|ie
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|priv
decl_stmt|;
name|int
name|wake
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|ih
operator|=
operator|(
expr|struct
name|intr_handler
operator|*
operator|)
name|arg
expr_stmt|;
name|priv
operator|=
operator|(
name|ih
operator|->
name|ih_thread
operator|!=
name|NULL
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|ithd
operator|=
operator|(
name|priv
operator|)
condition|?
name|ih
operator|->
name|ih_thread
else|:
name|ih
operator|->
name|ih_event
operator|->
name|ie_thread
expr_stmt|;
name|KASSERT
argument_list|(
name|ithd
operator|->
name|it_thread
operator|==
name|td
argument_list|,
operator|(
literal|"%s: ithread and proc linkage out of sync"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ie
operator|=
name|ithd
operator|->
name|it_event
expr_stmt|;
name|ie
operator|->
name|ie_count
operator|=
literal|0
expr_stmt|;
name|wake
operator|=
literal|0
expr_stmt|;
comment|/* 	 * As long as we have interrupts outstanding, go through the 	 * list of handlers, giving each one a go at it. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * If we are an orphaned thread, then just die. 		 */
if|if
condition|(
name|ithd
operator|->
name|it_flags
operator|&
name|IT_DEAD
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: pid %d (%s) exiting"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ithd
argument_list|,
name|M_ITHREAD
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|()
expr_stmt|;
block|}
comment|/* 		 * Service interrupts.  If another interrupt arrives while 		 * we are running, it will set it_need to note that we 		 * should make another pass. 		 * 		 * The load_acq part of the following cmpset ensures 		 * that the load of ih_need in ithread_execute_handlers() 		 * is ordered after the load of it_need here. 		 */
while|while
condition|(
name|atomic_cmpset_acq_int
argument_list|(
operator|&
name|ithd
operator|->
name|it_need
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|priv
condition|)
name|priv_ithread_execute_handler
argument_list|(
name|p
argument_list|,
name|ih
argument_list|)
expr_stmt|;
else|else
name|ithread_execute_handlers
argument_list|(
name|p
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
name|WITNESS_WARN
argument_list|(
name|WARN_PANIC
argument_list|,
name|NULL
argument_list|,
literal|"suspending ithread"
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
comment|/* 		 * Processed all our interrupts.  Now get the sched 		 * lock.  This may take a while and it_need may get 		 * set again, so we have to check it again. 		 */
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|ithd
operator|->
name|it_need
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|ithd
operator|->
name|it_flags
operator|&
operator|(
name|IT_DEAD
operator||
name|IT_WAIT
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|TD_SET_IWAIT
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|ie
operator|->
name|ie_count
operator|=
literal|0
expr_stmt|;
name|mi_switch
argument_list|(
name|SW_VOL
operator||
name|SWT_IWAIT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ithd
operator|->
name|it_flags
operator|&
name|IT_WAIT
condition|)
block|{
name|wake
operator|=
literal|1
expr_stmt|;
name|ithd
operator|->
name|it_flags
operator|&=
operator|~
name|IT_WAIT
expr_stmt|;
block|}
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|wake
condition|)
block|{
name|wakeup
argument_list|(
name|ithd
argument_list|)
expr_stmt|;
name|wake
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*   * Main loop for interrupt filter.  *  * Some architectures (i386, amd64 and arm) require the optional frame   * parameter, and use it as the main argument for fast handler execution  * when ih_argument == NULL.  *  * Return value:  * o FILTER_STRAY:              No filter recognized the event, and no  *                              filter-less handler is registered on this   *                              line.  * o FILTER_HANDLED:            A filter claimed the event and served it.  * o FILTER_SCHEDULE_THREAD:    No filter claimed the event, but there's at  *                              least one filter-less handler on this line.  * o FILTER_HANDLED |   *   FILTER_SCHEDULE_THREAD:    A filter claimed the event, and asked for  *                              scheduling the per-handler ithread.  *  * In case an ithread has to be scheduled, in *ithd there will be a   * pointer to a struct intr_thread containing the thread to be  * scheduled.  */
end_comment

begin_function
specifier|static
name|int
name|intr_filter_loop
parameter_list|(
name|struct
name|intr_event
modifier|*
name|ie
parameter_list|,
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|,
name|struct
name|intr_thread
modifier|*
modifier|*
name|ithd
parameter_list|)
block|{
name|struct
name|intr_handler
modifier|*
name|ih
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|thread_only
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|thread_only
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ih
argument_list|,
argument|&ie->ie_handlers
argument_list|,
argument|ih_next
argument_list|)
block|{
comment|/* 		 * Execute fast interrupt handlers directly. 		 * To support clock handlers, if a handler registers 		 * with a NULL argument, then we pass it a pointer to 		 * a trapframe as its argument. 		 */
name|arg
operator|=
operator|(
operator|(
name|ih
operator|->
name|ih_argument
operator|==
name|NULL
operator|)
condition|?
name|frame
else|:
name|ih
operator|->
name|ih_argument
operator|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: exec %p/%p(%p) for %s"
argument_list|,
name|__func__
argument_list|,
name|ih
operator|->
name|ih_filter
argument_list|,
name|ih
operator|->
name|ih_handler
argument_list|,
name|arg
argument_list|,
name|ih
operator|->
name|ih_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ih
operator|->
name|ih_filter
operator|!=
name|NULL
condition|)
name|ret
operator|=
name|ih
operator|->
name|ih_filter
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|thread_only
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|KASSERT
argument_list|(
name|ret
operator|==
name|FILTER_STRAY
operator|||
operator|(
operator|(
name|ret
operator|&
operator|(
name|FILTER_SCHEDULE_THREAD
operator||
name|FILTER_HANDLED
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ret
operator|&
operator|~
operator|(
name|FILTER_SCHEDULE_THREAD
operator||
name|FILTER_HANDLED
operator|)
operator|)
operator|==
literal|0
operator|)
argument_list|,
operator|(
literal|"%s: incorrect return value %#x from %s"
operator|,
name|__func__
operator|,
name|ret
operator|,
name|ih
operator|->
name|ih_name
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&
name|FILTER_STRAY
condition|)
continue|continue;
else|else
block|{
operator|*
name|ithd
operator|=
name|ih
operator|->
name|ih_thread
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
comment|/* 	 * No filters handled the interrupt and we have at least 	 * one handler without a filter.  In this case, we schedule 	 * all of the filter-less handlers to run in the ithread. 	 */
if|if
condition|(
name|thread_only
condition|)
block|{
operator|*
name|ithd
operator|=
name|ie
operator|->
name|ie_thread
expr_stmt|;
return|return
operator|(
name|FILTER_SCHEDULE_THREAD
operator|)
return|;
block|}
return|return
operator|(
name|FILTER_STRAY
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Main interrupt handling body.  *  * Input:  * o ie:                        the event connected to this interrupt.  * o frame:                     some archs (i.e. i386) pass a frame to some.  *                              handlers as their main argument.  * Return value:  * o 0:                         everything ok.  * o EINVAL:                    stray interrupt.  */
end_comment

begin_function
name|int
name|intr_event_handle
parameter_list|(
name|struct
name|intr_event
modifier|*
name|ie
parameter_list|,
name|struct
name|trapframe
modifier|*
name|frame
parameter_list|)
block|{
name|struct
name|intr_thread
modifier|*
name|ithd
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|oldframe
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|thread
decl_stmt|;
name|ithd
operator|=
name|NULL
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
if|if
condition|(
name|ie
operator|==
name|NULL
operator|||
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ie
operator|->
name|ie_handlers
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|td
operator|->
name|td_intr_nesting_level
operator|++
expr_stmt|;
name|thread
operator|=
literal|0
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|oldframe
operator|=
name|td
operator|->
name|td_intr_frame
expr_stmt|;
name|td
operator|->
name|td_intr_frame
operator|=
name|frame
expr_stmt|;
name|thread
operator|=
name|intr_filter_loop
argument_list|(
name|ie
argument_list|,
name|frame
argument_list|,
operator|&
name|ithd
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|&
name|FILTER_HANDLED
condition|)
block|{
if|if
condition|(
name|ie
operator|->
name|ie_post_filter
operator|!=
name|NULL
condition|)
name|ie
operator|->
name|ie_post_filter
argument_list|(
name|ie
operator|->
name|ie_source
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ie
operator|->
name|ie_pre_ithread
operator|!=
name|NULL
condition|)
name|ie
operator|->
name|ie_pre_ithread
argument_list|(
name|ie
operator|->
name|ie_source
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_intr_frame
operator|=
name|oldframe
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
comment|/* Interrupt storm logic */
if|if
condition|(
name|thread
operator|&
name|FILTER_STRAY
condition|)
block|{
name|ie
operator|->
name|ie_count
operator|++
expr_stmt|;
if|if
condition|(
name|ie
operator|->
name|ie_count
operator|<
name|intr_storm_threshold
condition|)
name|printf
argument_list|(
literal|"Interrupt stray detection not present\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Schedule an ithread if needed. */
if|if
condition|(
name|thread
operator|&
name|FILTER_SCHEDULE_THREAD
condition|)
block|{
if|if
condition|(
name|intr_event_schedule_thread
argument_list|(
name|ie
argument_list|,
name|ithd
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: impossible stray interrupt"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_intr_nesting_level
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_comment
comment|/*  * Dump details about an interrupt handler  */
end_comment

begin_function
specifier|static
name|void
name|db_dump_intrhand
parameter_list|(
name|struct
name|intr_handler
modifier|*
name|ih
parameter_list|)
block|{
name|int
name|comma
decl_stmt|;
name|db_printf
argument_list|(
literal|"\t%-10s "
argument_list|,
name|ih
operator|->
name|ih_name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ih
operator|->
name|ih_pri
condition|)
block|{
case|case
name|PI_REALTIME
case|:
name|db_printf
argument_list|(
literal|"CLK "
argument_list|)
expr_stmt|;
break|break;
case|case
name|PI_AV
case|:
name|db_printf
argument_list|(
literal|"AV  "
argument_list|)
expr_stmt|;
break|break;
case|case
name|PI_TTY
case|:
name|db_printf
argument_list|(
literal|"TTY "
argument_list|)
expr_stmt|;
break|break;
case|case
name|PI_NET
case|:
name|db_printf
argument_list|(
literal|"NET "
argument_list|)
expr_stmt|;
break|break;
case|case
name|PI_DISK
case|:
name|db_printf
argument_list|(
literal|"DISK"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PI_DULL
case|:
name|db_printf
argument_list|(
literal|"DULL"
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ih
operator|->
name|ih_pri
operator|>=
name|PI_SOFT
condition|)
name|db_printf
argument_list|(
literal|"SWI "
argument_list|)
expr_stmt|;
else|else
name|db_printf
argument_list|(
literal|"%4u"
argument_list|,
name|ih
operator|->
name|ih_pri
argument_list|)
expr_stmt|;
break|break;
block|}
name|db_printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ih
operator|->
name|ih_filter
operator|!=
name|NULL
condition|)
block|{
name|db_printf
argument_list|(
literal|"[F]"
argument_list|)
expr_stmt|;
name|db_printsym
argument_list|(
operator|(
name|uintptr_t
operator|)
name|ih
operator|->
name|ih_filter
argument_list|,
name|DB_STGY_PROC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ih
operator|->
name|ih_handler
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ih
operator|->
name|ih_filter
operator|!=
name|NULL
condition|)
name|db_printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"[H]"
argument_list|)
expr_stmt|;
name|db_printsym
argument_list|(
operator|(
name|uintptr_t
operator|)
name|ih
operator|->
name|ih_handler
argument_list|,
name|DB_STGY_PROC
argument_list|)
expr_stmt|;
block|}
name|db_printf
argument_list|(
literal|"(%p)"
argument_list|,
name|ih
operator|->
name|ih_argument
argument_list|)
expr_stmt|;
if|if
condition|(
name|ih
operator|->
name|ih_need
operator|||
operator|(
name|ih
operator|->
name|ih_flags
operator|&
operator|(
name|IH_EXCLUSIVE
operator||
name|IH_ENTROPY
operator||
name|IH_DEAD
operator||
name|IH_MPSAFE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|" {"
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ih
operator|->
name|ih_flags
operator|&
name|IH_EXCLUSIVE
condition|)
block|{
if|if
condition|(
name|comma
condition|)
name|db_printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"EXCL"
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ih
operator|->
name|ih_flags
operator|&
name|IH_ENTROPY
condition|)
block|{
if|if
condition|(
name|comma
condition|)
name|db_printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"ENTROPY"
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ih
operator|->
name|ih_flags
operator|&
name|IH_DEAD
condition|)
block|{
if|if
condition|(
name|comma
condition|)
name|db_printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"DEAD"
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ih
operator|->
name|ih_flags
operator|&
name|IH_MPSAFE
condition|)
block|{
if|if
condition|(
name|comma
condition|)
name|db_printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"MPSAFE"
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ih
operator|->
name|ih_need
condition|)
block|{
if|if
condition|(
name|comma
condition|)
name|db_printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"NEED"
argument_list|)
expr_stmt|;
block|}
name|db_printf
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump details about a event.  */
end_comment

begin_function
name|void
name|db_dump_intr_event
parameter_list|(
name|struct
name|intr_event
modifier|*
name|ie
parameter_list|,
name|int
name|handlers
parameter_list|)
block|{
name|struct
name|intr_handler
modifier|*
name|ih
decl_stmt|;
name|struct
name|intr_thread
modifier|*
name|it
decl_stmt|;
name|int
name|comma
decl_stmt|;
name|db_printf
argument_list|(
literal|"%s "
argument_list|,
name|ie
operator|->
name|ie_fullname
argument_list|)
expr_stmt|;
name|it
operator|=
name|ie
operator|->
name|ie_thread
expr_stmt|;
if|if
condition|(
name|it
operator|!=
name|NULL
condition|)
name|db_printf
argument_list|(
literal|"(pid %d)"
argument_list|,
name|it
operator|->
name|it_thread
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
else|else
name|db_printf
argument_list|(
literal|"(no thread)"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ie
operator|->
name|ie_flags
operator|&
operator|(
name|IE_SOFT
operator||
name|IE_ENTROPY
operator||
name|IE_ADDING_THREAD
operator|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|it
operator|!=
name|NULL
operator|&&
name|it
operator|->
name|it_need
operator|)
condition|)
block|{
name|db_printf
argument_list|(
literal|" {"
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ie
operator|->
name|ie_flags
operator|&
name|IE_SOFT
condition|)
block|{
name|db_printf
argument_list|(
literal|"SOFT"
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ie
operator|->
name|ie_flags
operator|&
name|IE_ENTROPY
condition|)
block|{
if|if
condition|(
name|comma
condition|)
name|db_printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"ENTROPY"
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ie
operator|->
name|ie_flags
operator|&
name|IE_ADDING_THREAD
condition|)
block|{
if|if
condition|(
name|comma
condition|)
name|db_printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"ADDING_THREAD"
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|it
operator|!=
name|NULL
operator|&&
name|it
operator|->
name|it_need
condition|)
block|{
if|if
condition|(
name|comma
condition|)
name|db_printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"NEED"
argument_list|)
expr_stmt|;
block|}
name|db_printf
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|handlers
condition|)
name|TAILQ_FOREACH
argument_list|(
argument|ih
argument_list|,
argument|&ie->ie_handlers
argument_list|,
argument|ih_next
argument_list|)
name|db_dump_intrhand
argument_list|(
name|ih
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump data about interrupt handlers  */
end_comment

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|intr
argument_list|,
argument|db_show_intr
argument_list|)
end_macro

begin_block
block|{
name|struct
name|intr_event
modifier|*
name|ie
decl_stmt|;
name|int
name|all
decl_stmt|,
name|verbose
decl_stmt|;
name|verbose
operator|=
name|strchr
argument_list|(
name|modif
argument_list|,
literal|'v'
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|all
operator|=
name|strchr
argument_list|(
name|modif
argument_list|,
literal|'a'
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ie
argument_list|,
argument|&event_list
argument_list|,
argument|ie_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|all
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ie
operator|->
name|ie_handlers
argument_list|)
condition|)
continue|continue;
name|db_dump_intr_event
argument_list|(
name|ie
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_pager_quit
condition|)
break|break;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

begin_comment
comment|/*  * Start standard software interrupt threads  */
end_comment

begin_function
specifier|static
name|void
name|start_softintr
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
if|if
condition|(
name|swi_add
argument_list|(
name|NULL
argument_list|,
literal|"vm"
argument_list|,
name|swi_vm
argument_list|,
name|NULL
argument_list|,
name|SWI_VM
argument_list|,
name|INTR_MPSAFE
argument_list|,
operator|&
name|vm_ih
argument_list|)
condition|)
name|panic
argument_list|(
literal|"died while creating vm swi ithread"
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|start_softintr
argument_list|,
name|SI_SUB_SOFTINTR
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|start_softintr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Sysctls used by systat and others: hw.intrnames and hw.intrcnt.  * The data for this machine dependent, and the declarations are in machine  * dependent code.  The layout of intrnames and intrcnt however is machine  * independent.  *  * We do not know the length of intrcnt and intrnames at compile time, so  * calculate things at run time.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_intrnames
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
return|return
operator|(
name|sysctl_handle_opaque
argument_list|(
name|oidp
argument_list|,
name|intrnames
argument_list|,
name|sintrnames
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|intrnames
argument_list|,
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_intrnames
argument_list|,
literal|""
argument_list|,
literal|"Interrupt Names"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_intrcnt
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SCTL_MASK32
name|uint32_t
modifier|*
name|intrcnt32
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|flags
operator|&
name|SCTL_MASK32
condition|)
block|{
if|if
condition|(
operator|!
name|req
operator|->
name|oldptr
condition|)
return|return
operator|(
name|sysctl_handle_opaque
argument_list|(
name|oidp
argument_list|,
name|NULL
argument_list|,
name|sintrcnt
operator|/
literal|2
argument_list|,
name|req
argument_list|)
operator|)
return|;
name|intrcnt32
operator|=
name|malloc
argument_list|(
name|sintrcnt
operator|/
literal|2
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|intrcnt32
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sintrcnt
operator|/
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
condition|;
name|i
operator|++
control|)
name|intrcnt32
index|[
name|i
index|]
operator|=
name|intrcnt
index|[
name|i
index|]
expr_stmt|;
name|error
operator|=
name|sysctl_handle_opaque
argument_list|(
name|oidp
argument_list|,
name|intrcnt32
argument_list|,
name|sintrcnt
operator|/
literal|2
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|intrcnt32
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|sysctl_handle_opaque
argument_list|(
name|oidp
argument_list|,
name|intrcnt
argument_list|,
name|sintrcnt
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|intrcnt
argument_list|,
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_intrcnt
argument_list|,
literal|""
argument_list|,
literal|"Interrupt Counts"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_comment
comment|/*  * DDB command to dump the interrupt statistics.  */
end_comment

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|intrcnt
argument_list|,
argument|db_show_intrcnt
argument_list|)
end_macro

begin_block
block|{
name|u_long
modifier|*
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|u_int
name|j
decl_stmt|;
name|cp
operator|=
name|intrnames
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|intrcnt
init|;
name|j
operator|<
operator|(
name|sintrcnt
operator|/
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|)
operator|&&
operator|!
name|db_pager_quit
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
operator|*
name|i
operator|!=
literal|0
condition|)
name|db_printf
argument_list|(
literal|"%s\t%lu\n"
argument_list|,
name|cp
argument_list|,
operator|*
name|i
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

