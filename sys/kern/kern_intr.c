begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, Stefan Esser<se@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rtprio.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ipl.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/mutex.h>
end_include

begin_struct
struct|struct
name|swilist
block|{
name|swihand_t
modifier|*
name|sl_handler
decl_stmt|;
name|struct
name|swilist
modifier|*
name|sl_next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|swilist
name|swilists
index|[
name|NSWI
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|softintr_count
index|[
name|NSWI
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|softithd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|u_int
name|sdelayed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|volatile
name|u_int
name|spending
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|start_softintr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|intr_soft
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|register_swi
parameter_list|(
name|intr
parameter_list|,
name|handler
parameter_list|)
name|int
name|intr
decl_stmt|;
name|swihand_t
modifier|*
name|handler
decl_stmt|;
block|{
name|struct
name|swilist
modifier|*
name|slp
decl_stmt|,
modifier|*
name|slq
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|intr
operator|<
literal|0
operator|||
name|intr
operator|>=
name|NSWI
condition|)
name|panic
argument_list|(
literal|"register_swi: bad intr %d"
argument_list|,
name|intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|handler
operator|==
name|swi_generic
operator|||
name|handler
operator|==
name|swi_null
condition|)
name|panic
argument_list|(
literal|"register_swi: bad handler %p"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|handler
argument_list|)
expr_stmt|;
name|slp
operator|=
operator|&
name|swilists
index|[
name|intr
index|]
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|shandlers
index|[
name|intr
index|]
operator|==
name|swi_null
condition|)
name|shandlers
index|[
name|intr
index|]
operator|=
name|handler
expr_stmt|;
else|else
block|{
if|if
condition|(
name|slp
operator|->
name|sl_next
operator|==
name|NULL
condition|)
block|{
name|slp
operator|->
name|sl_handler
operator|=
name|shandlers
index|[
name|intr
index|]
expr_stmt|;
name|shandlers
index|[
name|intr
index|]
operator|=
name|swi_generic
expr_stmt|;
block|}
name|slq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|slq
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|slq
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"register_swi: malloc failed"
argument_list|)
expr_stmt|;
name|slq
operator|->
name|sl_handler
operator|=
name|handler
expr_stmt|;
name|slq
operator|->
name|sl_next
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|slp
operator|->
name|sl_next
operator|!=
name|NULL
condition|)
name|slp
operator|=
name|slp
operator|->
name|sl_next
expr_stmt|;
name|slp
operator|->
name|sl_next
operator|=
name|slq
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|swi_dispatcher
parameter_list|(
name|intr
parameter_list|)
name|int
name|intr
decl_stmt|;
block|{
name|struct
name|swilist
modifier|*
name|slp
decl_stmt|;
name|slp
operator|=
operator|&
name|swilists
index|[
name|intr
index|]
expr_stmt|;
do|do
block|{
call|(
modifier|*
name|slp
operator|->
name|sl_handler
call|)
argument_list|()
expr_stmt|;
name|slp
operator|=
name|slp
operator|->
name|sl_next
expr_stmt|;
block|}
do|while
condition|(
name|slp
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_function
name|void
name|unregister_swi
parameter_list|(
name|intr
parameter_list|,
name|handler
parameter_list|)
name|int
name|intr
decl_stmt|;
name|swihand_t
modifier|*
name|handler
decl_stmt|;
block|{
name|struct
name|swilist
modifier|*
name|slfoundpred
decl_stmt|,
modifier|*
name|slp
decl_stmt|,
modifier|*
name|slq
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|intr
operator|<
literal|0
operator|||
name|intr
operator|>=
name|NSWI
condition|)
name|panic
argument_list|(
literal|"unregister_swi: bad intr %d"
argument_list|,
name|intr
argument_list|)
expr_stmt|;
if|if
condition|(
name|handler
operator|==
name|swi_generic
operator|||
name|handler
operator|==
name|swi_null
condition|)
name|panic
argument_list|(
literal|"unregister_swi: bad handler %p"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|handler
argument_list|)
expr_stmt|;
name|slp
operator|=
operator|&
name|swilists
index|[
name|intr
index|]
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|shandlers
index|[
name|intr
index|]
operator|==
name|handler
condition|)
name|shandlers
index|[
name|intr
index|]
operator|=
name|swi_null
expr_stmt|;
elseif|else
if|if
condition|(
name|slp
operator|->
name|sl_next
operator|!=
name|NULL
condition|)
block|{
name|slfoundpred
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|slq
operator|=
name|slp
operator|->
name|sl_next
init|;
name|slq
operator|!=
name|NULL
condition|;
name|slp
operator|=
name|slq
operator|,
name|slq
operator|=
name|slp
operator|->
name|sl_next
control|)
if|if
condition|(
name|slq
operator|->
name|sl_handler
operator|==
name|handler
condition|)
name|slfoundpred
operator|=
name|slp
expr_stmt|;
name|slp
operator|=
operator|&
name|swilists
index|[
name|intr
index|]
expr_stmt|;
if|if
condition|(
name|slfoundpred
operator|!=
name|NULL
condition|)
block|{
name|slq
operator|=
name|slfoundpred
operator|->
name|sl_next
expr_stmt|;
name|slfoundpred
operator|->
name|sl_next
operator|=
name|slq
operator|->
name|sl_next
expr_stmt|;
name|free
argument_list|(
name|slq
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|slp
operator|->
name|sl_handler
operator|==
name|handler
condition|)
block|{
name|slq
operator|=
name|slp
operator|->
name|sl_next
expr_stmt|;
name|slp
operator|->
name|sl_next
operator|=
name|slq
operator|->
name|sl_next
expr_stmt|;
name|slp
operator|->
name|sl_handler
operator|=
name|slq
operator|->
name|sl_handler
expr_stmt|;
name|free
argument_list|(
name|slq
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|slp
operator|->
name|sl_next
operator|==
name|NULL
condition|)
name|shandlers
index|[
name|intr
index|]
operator|=
name|slp
operator|->
name|sl_handler
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ithread_priority
parameter_list|(
name|flags
parameter_list|)
name|int
name|flags
decl_stmt|;
block|{
name|int
name|pri
decl_stmt|;
switch|switch
condition|(
name|flags
condition|)
block|{
case|case
name|INTR_TYPE_TTY
case|:
comment|/* keyboard or parallel port */
name|pri
operator|=
name|PI_TTYLOW
expr_stmt|;
break|break;
case|case
operator|(
name|INTR_TYPE_TTY
operator||
name|INTR_FAST
operator|)
case|:
comment|/* sio */
name|pri
operator|=
name|PI_TTYHIGH
expr_stmt|;
break|break;
case|case
name|INTR_TYPE_BIO
case|:
comment|/* 		 * XXX We need to refine this.  BSD/OS distinguishes 		 * between tape and disk priorities. 		 */
name|pri
operator|=
name|PI_DISK
expr_stmt|;
break|break;
case|case
name|INTR_TYPE_NET
case|:
name|pri
operator|=
name|PI_NET
expr_stmt|;
break|break;
case|case
name|INTR_TYPE_CAM
case|:
name|pri
operator|=
name|PI_DISK
expr_stmt|;
comment|/* XXX or PI_CAM? */
break|break;
case|case
name|INTR_TYPE_MISC
case|:
name|pri
operator|=
name|PI_DULL
expr_stmt|;
comment|/* don't care */
break|break;
comment|/* We didn't specify an interrupt level. */
default|default:
name|panic
argument_list|(
literal|"ithread_priority: no interrupt type in flags"
argument_list|)
expr_stmt|;
block|}
return|return
name|pri
return|;
block|}
end_function

begin_comment
comment|/*  * Schedule the soft interrupt handler thread.  */
end_comment

begin_function
name|void
name|sched_softintr
parameter_list|(
name|void
parameter_list|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|cnt
operator|.
name|v_intr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* one more global interrupt */
comment|/* 	 * If we don't have an interrupt resource or an interrupt thread for 	 * this IRQ, log it as a stray interrupt. 	 */
if|if
condition|(
name|softithd
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"soft interrupt scheduled too early"
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_INTR
argument_list|,
literal|"sched_softintr pid %d(%s) spending=0x%x"
argument_list|,
name|softithd
operator|->
name|p_pid
argument_list|,
name|softithd
operator|->
name|p_comm
argument_list|,
name|spending
argument_list|)
expr_stmt|;
comment|/* 	 * Get the sched lock and see if the thread is on whichkqs yet. 	 * If not, put it on there.  In any case, kick everyone so that if 	 * the new thread is higher priority than their current thread, it 	 * gets run now. 	 */
name|mtx_enter
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|softithd
operator|->
name|p_stat
operator|==
name|SWAIT
condition|)
block|{
comment|/* not on run queue */
name|CTR1
argument_list|(
name|KTR_INTR
argument_list|,
literal|"sched_softintr: setrunqueue %d"
argument_list|,
name|softithd
operator|->
name|p_pid
argument_list|)
expr_stmt|;
comment|/*		membar_lock(); */
name|softithd
operator|->
name|p_stat
operator|=
name|SRUN
expr_stmt|;
name|setrunqueue
argument_list|(
name|softithd
argument_list|)
expr_stmt|;
name|aston
argument_list|()
expr_stmt|;
block|}
name|mtx_exit
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|aston();
comment|/* ??? check priorities first? */
else|#
directive|else
name|need_resched
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|start_softintr
argument_list|,
argument|SI_SUB_SOFTINTR
argument_list|,
argument|SI_ORDER_FIRST
argument_list|,
argument|start_softintr
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_comment
comment|/*  * Start soft interrupt thread.  */
end_comment

begin_function
specifier|static
name|void
name|start_softintr
parameter_list|(
name|dummy
parameter_list|)
name|void
modifier|*
name|dummy
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|softithd
operator|!=
name|NULL
condition|)
block|{
comment|/* we already have a thread */
name|printf
argument_list|(
literal|"start_softintr: already running"
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
operator|=
name|kthread_create
argument_list|(
name|intr_soft
argument_list|,
name|NULL
argument_list|,
operator|&
name|softithd
argument_list|,
name|RFSTOPPED
operator||
name|RFHIGHPID
argument_list|,
literal|"softinterrupt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"start_softintr: kthread_create error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|softithd
operator|->
name|p_rtprio
operator|.
name|type
operator|=
name|RTP_PRIO_ITHREAD
expr_stmt|;
name|softithd
operator|->
name|p_rtprio
operator|.
name|prio
operator|=
name|PI_SOFT
expr_stmt|;
comment|/* soft interrupt */
name|softithd
operator|->
name|p_stat
operator|=
name|SWAIT
expr_stmt|;
comment|/* we're idle */
name|softithd
operator|->
name|p_flag
operator||=
name|P_NOLOAD
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Software interrupt process code.  */
end_comment

begin_function
specifier|static
name|void
name|intr_soft
parameter_list|(
name|dummy
parameter_list|)
name|void
modifier|*
name|dummy
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|u_int
name|pend
decl_stmt|;
comment|/* Main loop */
for|for
control|(
init|;
condition|;
control|)
block|{
name|CTR3
argument_list|(
name|KTR_INTR
argument_list|,
literal|"intr_soft pid %d(%s) spending=0x%x"
argument_list|,
name|curproc
operator|->
name|p_pid
argument_list|,
name|curproc
operator|->
name|p_comm
argument_list|,
name|spending
argument_list|)
expr_stmt|;
comment|/* 		 * Service interrupts.  If another interrupt arrives 		 * while we are running, they will set spending to 		 * denote that we should make another pass. 		 */
name|pend
operator|=
name|atomic_readandclear_int
argument_list|(
operator|&
name|spending
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|ffs
argument_list|(
name|pend
argument_list|)
operator|)
condition|)
block|{
name|i
operator|--
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|softintr_count
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pend
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
name|mtx_enter
argument_list|(
operator|&
name|Giant
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
if|if
condition|(
name|shandlers
index|[
name|i
index|]
operator|==
name|swi_generic
condition|)
name|swi_dispatcher
argument_list|(
name|i
argument_list|)
expr_stmt|;
else|else
operator|(
name|shandlers
index|[
name|i
index|]
operator|)
operator|(
operator|)
expr_stmt|;
name|mtx_exit
argument_list|(
operator|&
name|Giant
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Processed all our interrupts.  Now get the sched 		 * lock.  This may take a while and spending may get 		 * set again, so we have to check it again. 		 */
name|mtx_enter
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|spending
operator|==
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_INTR
argument_list|,
literal|"intr_soft pid %d: done"
argument_list|,
name|curproc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|curproc
operator|->
name|p_stat
operator|=
name|SWAIT
expr_stmt|;
comment|/* we're idle */
name|mi_switch
argument_list|()
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_INTR
argument_list|,
literal|"intr_soft pid %d: resumed"
argument_list|,
name|curproc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
block|}
name|mtx_exit
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Bits in the spending bitmap variable must be set atomically because  * spending may be manipulated by interrupts or other cpu's without holding   * any locks.  *  * Note: setbits uses a locked or, making simple cases MP safe.  */
end_comment

begin_define
define|#
directive|define
name|DO_SETBITS
parameter_list|(
name|name
parameter_list|,
name|var
parameter_list|,
name|bits
parameter_list|)
define|\
value|void name(void)					\ {						\ 	atomic_set_int(var, bits);		\ 	sched_softintr();			\ }
end_define

begin_define
define|#
directive|define
name|DO_SETBITS_AND_NO_MORE
parameter_list|(
name|name
parameter_list|,
name|var
parameter_list|,
name|bits
parameter_list|)
define|\
value|void name(void)					\ {						\ 	atomic_set_int(var, bits);		\ }
end_define

begin_macro
name|DO_SETBITS
argument_list|(
argument|setsoftcamnet
argument_list|,
argument|&spending
argument_list|,
argument|SWI_CAMNET_PENDING
argument_list|)
end_macro

begin_macro
name|DO_SETBITS
argument_list|(
argument|setsoftcambio
argument_list|,
argument|&spending
argument_list|,
argument|SWI_CAMBIO_PENDING
argument_list|)
end_macro

begin_macro
name|DO_SETBITS
argument_list|(
argument|setsoftclock
argument_list|,
argument|&spending
argument_list|,
argument|SWI_CLOCK_PENDING
argument_list|)
end_macro

begin_macro
name|DO_SETBITS
argument_list|(
argument|setsoftnet
argument_list|,
argument|&spending
argument_list|,
argument|SWI_NET_PENDING
argument_list|)
end_macro

begin_macro
name|DO_SETBITS
argument_list|(
argument|setsofttty
argument_list|,
argument|&spending
argument_list|,
argument|SWI_TTY_PENDING
argument_list|)
end_macro

begin_macro
name|DO_SETBITS
argument_list|(
argument|setsoftvm
argument_list|,
argument|&spending
argument_list|,
argument|SWI_VM_PENDING
argument_list|)
end_macro

begin_macro
name|DO_SETBITS
argument_list|(
argument|setsofttq
argument_list|,
argument|&spending
argument_list|,
argument|SWI_TQ_PENDING
argument_list|)
end_macro

begin_macro
name|DO_SETBITS_AND_NO_MORE
argument_list|(
argument|schedsoftcamnet
argument_list|,
argument|&sdelayed
argument_list|,
argument|SWI_CAMNET_PENDING
argument_list|)
end_macro

begin_macro
name|DO_SETBITS_AND_NO_MORE
argument_list|(
argument|schedsoftcambio
argument_list|,
argument|&sdelayed
argument_list|,
argument|SWI_CAMBIO_PENDING
argument_list|)
end_macro

begin_macro
name|DO_SETBITS_AND_NO_MORE
argument_list|(
argument|schedsoftnet
argument_list|,
argument|&sdelayed
argument_list|,
argument|SWI_NET_PENDING
argument_list|)
end_macro

begin_macro
name|DO_SETBITS_AND_NO_MORE
argument_list|(
argument|schedsofttty
argument_list|,
argument|&sdelayed
argument_list|,
argument|SWI_TTY_PENDING
argument_list|)
end_macro

begin_macro
name|DO_SETBITS_AND_NO_MORE
argument_list|(
argument|schedsoftvm
argument_list|,
argument|&sdelayed
argument_list|,
argument|SWI_VM_PENDING
argument_list|)
end_macro

begin_macro
name|DO_SETBITS_AND_NO_MORE
argument_list|(
argument|schedsofttq
argument_list|,
argument|&sdelayed
argument_list|,
argument|SWI_TQ_PENDING
argument_list|)
end_macro

begin_function
name|void
name|setdelayed
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|pend
decl_stmt|;
name|pend
operator|=
name|atomic_readandclear_int
argument_list|(
operator|&
name|sdelayed
argument_list|)
expr_stmt|;
if|if
condition|(
name|pend
operator|!=
literal|0
condition|)
block|{
name|atomic_set_int
argument_list|(
operator|&
name|spending
argument_list|,
name|pend
argument_list|)
expr_stmt|;
name|sched_softintr
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|intrmask_t
name|softclockpending
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|spending
operator|&
name|SWI_CLOCK_PENDING
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dummy spl calls.  The only reason for these is to not break  * all the code which expects to call them.  */
end_comment

begin_function
name|void
name|spl0
parameter_list|(
name|void
parameter_list|)
block|{}
end_function

begin_function
name|void
name|splx
parameter_list|(
name|intrmask_t
name|x
parameter_list|)
block|{}
end_function

begin_function
name|intrmask_t
name|splq
parameter_list|(
name|intrmask_t
name|mask
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|intrmask_t
name|splbio
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|intrmask_t
name|splcam
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|intrmask_t
name|splclock
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|intrmask_t
name|splhigh
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|intrmask_t
name|splimp
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|intrmask_t
name|splnet
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|intrmask_t
name|splsoftcam
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|intrmask_t
name|splsoftcambio
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|intrmask_t
name|splsoftcamnet
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|intrmask_t
name|splsoftclock
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|intrmask_t
name|splsofttty
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|intrmask_t
name|splsoftvm
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|intrmask_t
name|splsofttq
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|intrmask_t
name|splstatclock
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|intrmask_t
name|spltty
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|intrmask_t
name|splvm
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

end_unit

