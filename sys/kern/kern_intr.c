begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, Stefan Esser<se@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rtprio.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_comment
comment|/* prototype for legacy_setsoftnet */
end_comment

begin_struct
struct|struct
name|int_entropy
block|{
name|struct
name|proc
modifier|*
name|proc
decl_stmt|;
name|int
name|vector
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|void
modifier|*
name|net_ih
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|vm_ih
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|softclock_ih
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ithd
modifier|*
name|clk_ithd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ithd
modifier|*
name|tty_ithd
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_ITHREAD
argument_list|,
literal|"ithread"
argument_list|,
literal|"Interrupt Threads"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|ithread_update
parameter_list|(
name|struct
name|ithd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ithread_loop
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|start_softintr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swi_net
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|u_char
name|ithread_priority
parameter_list|(
name|enum
name|intr_type
name|flags
parameter_list|)
block|{
name|u_char
name|pri
decl_stmt|;
name|flags
operator|&=
operator|(
name|INTR_TYPE_TTY
operator||
name|INTR_TYPE_BIO
operator||
name|INTR_TYPE_NET
operator||
name|INTR_TYPE_CAM
operator||
name|INTR_TYPE_MISC
operator||
name|INTR_TYPE_CLK
operator||
name|INTR_TYPE_AV
operator|)
expr_stmt|;
switch|switch
condition|(
name|flags
condition|)
block|{
case|case
name|INTR_TYPE_TTY
case|:
name|pri
operator|=
name|PI_TTYLOW
expr_stmt|;
break|break;
case|case
name|INTR_TYPE_BIO
case|:
comment|/* 		 * XXX We need to refine this.  BSD/OS distinguishes 		 * between tape and disk priorities. 		 */
name|pri
operator|=
name|PI_DISK
expr_stmt|;
break|break;
case|case
name|INTR_TYPE_NET
case|:
name|pri
operator|=
name|PI_NET
expr_stmt|;
break|break;
case|case
name|INTR_TYPE_CAM
case|:
name|pri
operator|=
name|PI_DISK
expr_stmt|;
comment|/* XXX or PI_CAM? */
break|break;
case|case
name|INTR_TYPE_AV
case|:
comment|/* Audio/video */
name|pri
operator|=
name|PI_AV
expr_stmt|;
break|break;
case|case
name|INTR_TYPE_CLK
case|:
name|pri
operator|=
name|PI_REALTIME
expr_stmt|;
break|break;
case|case
name|INTR_TYPE_MISC
case|:
name|pri
operator|=
name|PI_DULL
expr_stmt|;
comment|/* don't care */
break|break;
default|default:
comment|/* We didn't specify an interrupt level. */
name|panic
argument_list|(
literal|"ithread_priority: no interrupt type in flags"
argument_list|)
expr_stmt|;
block|}
return|return
name|pri
return|;
block|}
end_function

begin_comment
comment|/*  * Regenerate the name (p_comm) and priority for a threaded interrupt thread.  */
end_comment

begin_function
specifier|static
name|void
name|ithread_update
parameter_list|(
name|struct
name|ithd
modifier|*
name|ithd
parameter_list|)
block|{
name|struct
name|intrhand
modifier|*
name|ih
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|entropy
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|ithd
operator|->
name|it_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|td
operator|=
name|ithd
operator|->
name|it_td
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
return|return;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|strncpy
argument_list|(
name|p
operator|->
name|p_comm
argument_list|,
name|ithd
operator|->
name|it_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ithd
operator|->
name|it_name
argument_list|)
argument_list|)
expr_stmt|;
name|ih
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ithd
operator|->
name|it_handlers
argument_list|)
expr_stmt|;
if|if
condition|(
name|ih
operator|==
name|NULL
condition|)
block|{
name|td
operator|->
name|td_priority
operator|=
name|PRI_MAX_ITHD
expr_stmt|;
name|ithd
operator|->
name|it_flags
operator|&=
operator|~
name|IT_ENTROPY
expr_stmt|;
return|return;
block|}
name|entropy
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_priority
operator|=
name|ih
operator|->
name|ih_pri
expr_stmt|;
name|td
operator|->
name|td_base_pri
operator|=
name|ih
operator|->
name|ih_pri
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ih
argument_list|,
argument|&ithd->it_handlers
argument_list|,
argument|ih_next
argument_list|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|p
operator|->
name|p_comm
argument_list|)
operator|+
name|strlen
argument_list|(
name|ih
operator|->
name|ih_name
argument_list|)
operator|+
literal|1
operator|<
sizeof|sizeof
argument_list|(
name|p
operator|->
name|p_comm
argument_list|)
condition|)
block|{
name|strcat
argument_list|(
name|p
operator|->
name|p_comm
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
operator|->
name|p_comm
argument_list|,
name|ih
operator|->
name|ih_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strlen
argument_list|(
name|p
operator|->
name|p_comm
argument_list|)
operator|+
literal|1
operator|==
sizeof|sizeof
argument_list|(
name|p
operator|->
name|p_comm
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|p_comm
index|[
sizeof|sizeof
argument_list|(
name|p
operator|->
name|p_comm
argument_list|)
operator|-
literal|2
index|]
operator|==
literal|'+'
condition|)
name|p
operator|->
name|p_comm
index|[
sizeof|sizeof
argument_list|(
name|p
operator|->
name|p_comm
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|'*'
expr_stmt|;
else|else
name|p
operator|->
name|p_comm
index|[
sizeof|sizeof
argument_list|(
name|p
operator|->
name|p_comm
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|'+'
expr_stmt|;
block|}
else|else
name|strcat
argument_list|(
name|p
operator|->
name|p_comm
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ih
operator|->
name|ih_flags
operator|&
name|IH_ENTROPY
condition|)
name|entropy
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|entropy
condition|)
name|ithd
operator|->
name|it_flags
operator||=
name|IT_ENTROPY
expr_stmt|;
else|else
name|ithd
operator|->
name|it_flags
operator|&=
operator|~
name|IT_ENTROPY
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: updated %s\n"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ithread_create
parameter_list|(
name|struct
name|ithd
modifier|*
modifier|*
name|ithread
parameter_list|,
name|int
name|vector
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
function_decl|(
modifier|*
name|disable
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|enable
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|struct
name|ithd
modifier|*
name|ithd
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
comment|/* The only valid flag during creation is IT_SOFT. */
if|if
condition|(
operator|(
name|flags
operator|&
operator|~
name|IT_SOFT
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ithd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ithd
argument_list|)
argument_list|,
name|M_ITHREAD
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ithd
operator|->
name|it_vector
operator|=
name|vector
expr_stmt|;
name|ithd
operator|->
name|it_disable
operator|=
name|disable
expr_stmt|;
name|ithd
operator|->
name|it_enable
operator|=
name|enable
expr_stmt|;
name|ithd
operator|->
name|it_flags
operator|=
name|flags
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ithd
operator|->
name|it_handlers
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ithd
operator|->
name|it_lock
argument_list|,
literal|"ithread"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ithd
operator|->
name|it_lock
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|ithd
operator|->
name|it_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ithd
operator|->
name|it_name
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|error
operator|=
name|kthread_create
argument_list|(
name|ithread_loop
argument_list|,
name|ithd
argument_list|,
operator|&
name|p
argument_list|,
name|RFSTOPPED
operator||
name|RFHIGHPID
argument_list|,
literal|"%s"
argument_list|,
name|ithd
operator|->
name|it_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mtx_destroy
argument_list|(
operator|&
name|ithd
operator|->
name|it_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ithd
argument_list|,
name|M_ITHREAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|td
operator|=
name|FIRST_THREAD_IN_PROC
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* XXXKSE */
name|td
operator|->
name|td_ksegrp
operator|->
name|kg_pri_class
operator|=
name|PRI_ITHD
expr_stmt|;
name|td
operator|->
name|td_priority
operator|=
name|PRI_MAX_ITHD
expr_stmt|;
name|p
operator|->
name|p_stat
operator|=
name|SWAIT
expr_stmt|;
name|ithd
operator|->
name|it_td
operator|=
name|td
expr_stmt|;
name|td
operator|->
name|td_ithd
operator|=
name|ithd
expr_stmt|;
if|if
condition|(
name|ithread
operator|!=
name|NULL
condition|)
operator|*
name|ithread
operator|=
name|ithd
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ithd
operator|->
name|it_lock
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: created %s"
argument_list|,
name|__func__
argument_list|,
name|ithd
operator|->
name|it_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ithread_destroy
parameter_list|(
name|struct
name|ithd
modifier|*
name|ithread
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|ithread
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|td
operator|=
name|ithread
operator|->
name|it_td
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ithread
operator|->
name|it_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ithread
operator|->
name|it_handlers
argument_list|)
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ithread
operator|->
name|it_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ithread
operator|->
name|it_flags
operator||=
name|IT_DEAD
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_stat
operator|==
name|SWAIT
condition|)
block|{
name|p
operator|->
name|p_stat
operator|=
name|SRUN
expr_stmt|;
comment|/* XXXKSE */
name|setrunqueue
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ithread
operator|->
name|it_lock
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: killing %s"
argument_list|,
name|__func__
argument_list|,
name|ithread
operator|->
name|it_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ithread_add_handler
parameter_list|(
name|struct
name|ithd
modifier|*
name|ithread
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|driver_intr_t
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|u_char
name|pri
parameter_list|,
name|enum
name|intr_type
name|flags
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|intrhand
modifier|*
name|ih
decl_stmt|,
modifier|*
name|temp_ih
decl_stmt|;
if|if
condition|(
name|ithread
operator|==
name|NULL
operator|||
name|name
operator|==
name|NULL
operator|||
name|handler
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|INTR_FAST
operator|)
operator|!=
literal|0
condition|)
name|flags
operator||=
name|INTR_EXCL
expr_stmt|;
name|ih
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|intrhand
argument_list|)
argument_list|,
name|M_ITHREAD
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ih
operator|->
name|ih_handler
operator|=
name|handler
expr_stmt|;
name|ih
operator|->
name|ih_argument
operator|=
name|arg
expr_stmt|;
name|ih
operator|->
name|ih_name
operator|=
name|name
expr_stmt|;
name|ih
operator|->
name|ih_ithread
operator|=
name|ithread
expr_stmt|;
name|ih
operator|->
name|ih_pri
operator|=
name|pri
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|INTR_FAST
condition|)
name|ih
operator|->
name|ih_flags
operator|=
name|IH_FAST
operator||
name|IH_EXCLUSIVE
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|INTR_EXCL
condition|)
name|ih
operator|->
name|ih_flags
operator|=
name|IH_EXCLUSIVE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|INTR_MPSAFE
condition|)
name|ih
operator|->
name|ih_flags
operator||=
name|IH_MPSAFE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|INTR_ENTROPY
condition|)
name|ih
operator|->
name|ih_flags
operator||=
name|IH_ENTROPY
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ithread
operator|->
name|it_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|INTR_EXCL
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ithread
operator|->
name|it_handlers
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ithread
operator|->
name|it_handlers
argument_list|)
operator|&&
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|ithread
operator|->
name|it_handlers
argument_list|)
operator|->
name|ih_flags
operator|&
name|IH_EXCLUSIVE
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|TAILQ_FOREACH
argument_list|(
argument|temp_ih
argument_list|,
argument|&ithread->it_handlers
argument_list|,
argument|ih_next
argument_list|)
if|if
condition|(
name|temp_ih
operator|->
name|ih_pri
operator|>
name|ih
operator|->
name|ih_pri
condition|)
break|break;
if|if
condition|(
name|temp_ih
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ithread
operator|->
name|it_handlers
argument_list|,
name|ih
argument_list|,
name|ih_next
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_BEFORE
argument_list|(
name|temp_ih
argument_list|,
name|ih
argument_list|,
name|ih_next
argument_list|)
expr_stmt|;
name|ithread_update
argument_list|(
name|ithread
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ithread
operator|->
name|it_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookiep
operator|!=
name|NULL
condition|)
operator|*
name|cookiep
operator|=
name|ih
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: added %s to %s"
argument_list|,
name|__func__
argument_list|,
name|ih
operator|->
name|ih_name
argument_list|,
name|ithread
operator|->
name|it_name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|mtx_unlock
argument_list|(
operator|&
name|ithread
operator|->
name|it_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ih
argument_list|,
name|M_ITHREAD
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ithread_remove_handler
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|intrhand
modifier|*
name|handler
init|=
operator|(
expr|struct
name|intrhand
operator|*
operator|)
name|cookie
decl_stmt|;
name|struct
name|ithd
modifier|*
name|ithread
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|intrhand
modifier|*
name|ih
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|handler
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ithread
operator|=
name|handler
operator|->
name|ih_ithread
expr_stmt|;
name|KASSERT
argument_list|(
name|ithread
operator|!=
name|NULL
argument_list|,
operator|(
literal|"interrupt handler \"%s\" has a NULL interrupt thread"
operator|,
name|handler
operator|->
name|ih_name
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: removing %s from %s"
argument_list|,
name|__func__
argument_list|,
name|handler
operator|->
name|ih_name
argument_list|,
name|ithread
operator|->
name|it_name
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ithread
operator|->
name|it_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|TAILQ_FOREACH
argument_list|(
argument|ih
argument_list|,
argument|&ithread->it_handlers
argument_list|,
argument|ih_next
argument_list|)
if|if
condition|(
name|ih
operator|==
name|handler
condition|)
goto|goto
name|ok
goto|;
name|mtx_unlock
argument_list|(
operator|&
name|ithread
operator|->
name|it_lock
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"interrupt handler \"%s\" not found in interrupt thread \"%s\""
argument_list|,
name|ih
operator|->
name|ih_name
argument_list|,
name|ithread
operator|->
name|it_name
argument_list|)
expr_stmt|;
name|ok
label|:
endif|#
directive|endif
comment|/* 	 * If the interrupt thread is already running, then just mark this 	 * handler as being dead and let the ithread do the actual removal. 	 */
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ithread
operator|->
name|it_td
operator|->
name|td_proc
operator|->
name|p_stat
operator|!=
name|SWAIT
condition|)
block|{
name|handler
operator|->
name|ih_flags
operator||=
name|IH_DEAD
expr_stmt|;
comment|/* 		 * Ensure that the thread will process the handler list 		 * again and remove this handler if it has already passed 		 * it on the list. 		 */
name|ithread
operator|->
name|it_need
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ithread
operator|->
name|it_handlers
argument_list|,
name|handler
argument_list|,
name|ih_next
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|handler
operator|->
name|ih_flags
operator|&
name|IH_DEAD
operator|)
operator|!=
literal|0
condition|)
name|msleep
argument_list|(
name|handler
argument_list|,
operator|&
name|ithread
operator|->
name|it_lock
argument_list|,
name|PUSER
argument_list|,
literal|"itrmh"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ithread_update
argument_list|(
name|ithread
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ithread
operator|->
name|it_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|handler
argument_list|,
name|M_ITHREAD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ithread_schedule
parameter_list|(
name|struct
name|ithd
modifier|*
name|ithread
parameter_list|,
name|int
name|do_switch
parameter_list|)
block|{
name|struct
name|int_entropy
name|entropy
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
comment|/* 	 * If no ithread or no handlers, then we have a stray interrupt. 	 */
if|if
condition|(
operator|(
name|ithread
operator|==
name|NULL
operator|)
operator|||
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ithread
operator|->
name|it_handlers
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * If any of the handlers for this ithread claim to be good 	 * sources of entropy, then gather some. 	 */
if|if
condition|(
name|harvest
operator|.
name|interrupt
operator|&&
name|ithread
operator|->
name|it_flags
operator|&
name|IT_ENTROPY
condition|)
block|{
name|entropy
operator|.
name|vector
operator|=
name|ithread
operator|->
name|it_vector
expr_stmt|;
name|entropy
operator|.
name|proc
operator|=
name|curthread
operator|->
name|td_proc
expr_stmt|;
empty_stmt|;
name|random_harvest
argument_list|(
operator|&
name|entropy
argument_list|,
sizeof|sizeof
argument_list|(
name|entropy
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
name|RANDOM_INTERRUPT
argument_list|)
expr_stmt|;
block|}
name|td
operator|=
name|ithread
operator|->
name|it_td
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|KASSERT
argument_list|(
name|p
operator|!=
name|NULL
argument_list|,
operator|(
literal|"ithread %s has no process"
operator|,
name|ithread
operator|->
name|it_name
operator|)
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: pid %d: (%s) need = %d"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|ithread
operator|->
name|it_need
argument_list|)
expr_stmt|;
comment|/* 	 * Set it_need to tell the thread to keep running if it is already 	 * running.  Then, grab sched_lock and see if we actually need to 	 * put this thread on the runqueue.  If so and the do_switch flag is 	 * true and it is safe to switch, then switch to the ithread 	 * immediately.  Otherwise, set the needresched flag to guarantee 	 * that this ithread will run before any userland processes. 	 */
name|ithread
operator|->
name|it_need
operator|=
literal|1
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_stat
operator|==
name|SWAIT
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: setrunqueue %d"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_stat
operator|=
name|SRUN
expr_stmt|;
name|setrunqueue
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* XXXKSE */
if|if
condition|(
name|do_switch
operator|&&
name|curthread
operator|->
name|td_critnest
operator|==
literal|1
operator|&&
name|curthread
operator|->
name|td_proc
operator|->
name|p_stat
operator|==
name|SRUN
condition|)
block|{
if|if
condition|(
name|curthread
operator|!=
name|PCPU_GET
argument_list|(
name|idlethread
argument_list|)
condition|)
name|setrunqueue
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|curthread
operator|->
name|td_proc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_nivcsw
operator|++
expr_stmt|;
name|mi_switch
argument_list|()
expr_stmt|;
block|}
else|else
name|curthread
operator|->
name|td_kse
operator|->
name|ke_flags
operator||=
name|KEF_NEEDRESCHED
expr_stmt|;
block|}
else|else
block|{
name|CTR4
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: pid %d: it_need %d, state %d"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|ithread
operator|->
name|it_need
argument_list|,
name|p
operator|->
name|p_stat
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|swi_add
parameter_list|(
name|struct
name|ithd
modifier|*
modifier|*
name|ithdp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|driver_intr_t
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pri
parameter_list|,
name|enum
name|intr_type
name|flags
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|ithd
modifier|*
name|ithd
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|INTR_FAST
operator||
name|INTR_ENTROPY
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ithd
operator|=
operator|(
name|ithdp
operator|!=
name|NULL
operator|)
condition|?
operator|*
name|ithdp
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|ithd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|ithd
operator|->
name|it_flags
operator|&
name|IT_SOFT
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
else|else
block|{
name|error
operator|=
name|ithread_create
argument_list|(
operator|&
name|ithd
argument_list|,
name|pri
argument_list|,
name|IT_SOFT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|"swi%d:"
argument_list|,
name|pri
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|ithdp
operator|!=
name|NULL
condition|)
operator|*
name|ithdp
operator|=
name|ithd
expr_stmt|;
block|}
return|return
operator|(
name|ithread_add_handler
argument_list|(
name|ithd
argument_list|,
name|name
argument_list|,
name|handler
argument_list|,
name|arg
argument_list|,
operator|(
name|pri
operator|*
name|RQ_PPQ
operator|)
operator|+
name|PI_SOFT
argument_list|,
name|flags
argument_list|,
name|cookiep
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Schedule a heavyweight software interrupt process.   */
end_comment

begin_function
name|void
name|swi_sched
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|intrhand
modifier|*
name|ih
init|=
operator|(
expr|struct
name|intrhand
operator|*
operator|)
name|cookie
decl_stmt|;
name|struct
name|ithd
modifier|*
name|it
init|=
name|ih
operator|->
name|ih_ithread
decl_stmt|;
name|int
name|error
decl_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|cnt
operator|.
name|v_intr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* one more global interrupt */
name|CTR3
argument_list|(
name|KTR_INTR
argument_list|,
literal|"swi_sched pid %d(%s) need=%d"
argument_list|,
name|it
operator|->
name|it_td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|it
operator|->
name|it_td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|,
name|it
operator|->
name|it_need
argument_list|)
expr_stmt|;
comment|/* 	 * Set ih_need for this handler so that if the ithread is already 	 * running it will execute this handler on the next pass.  Otherwise, 	 * it will execute it the next time it runs. 	 */
name|atomic_store_rel_int
argument_list|(
operator|&
name|ih
operator|->
name|ih_need
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SWI_DELAY
operator|)
condition|)
block|{
name|error
operator|=
name|ithread_schedule
argument_list|(
name|it
argument_list|,
operator|!
name|cold
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"stray software interrupt"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is the main code for interrupt threads.  */
end_comment

begin_function
name|void
name|ithread_loop
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ithd
modifier|*
name|ithd
decl_stmt|;
comment|/* our thread context */
name|struct
name|intrhand
modifier|*
name|ih
decl_stmt|;
comment|/* and our interrupt handler chain */
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|ithd
operator|=
operator|(
expr|struct
name|ithd
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* point to myself */
name|KASSERT
argument_list|(
name|ithd
operator|->
name|it_td
operator|==
name|td
operator|&&
name|td
operator|->
name|td_ithd
operator|==
name|ithd
argument_list|,
operator|(
literal|"%s: ithread and proc linkage out of sync"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * As long as we have interrupts outstanding, go through the 	 * list of handlers, giving each one a go at it. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * If we are an orphaned thread, then just die. 		 */
if|if
condition|(
name|ithd
operator|->
name|it_flags
operator|&
name|IT_DEAD
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: pid %d: (%s) exiting"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_ithd
operator|=
name|NULL
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ithd
operator|->
name|it_lock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ithd
argument_list|,
name|M_ITHREAD
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|CTR4
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: pid %d: (%s) need=%d"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|ithd
operator|->
name|it_need
argument_list|)
expr_stmt|;
while|while
condition|(
name|ithd
operator|->
name|it_need
condition|)
block|{
comment|/* 			 * Service interrupts.  If another interrupt 			 * arrives while we are running, they will set 			 * it_need to denote that we should make 			 * another pass. 			 */
name|atomic_store_rel_int
argument_list|(
operator|&
name|ithd
operator|->
name|it_need
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|restart
label|:
name|TAILQ_FOREACH
argument_list|(
argument|ih
argument_list|,
argument|&ithd->it_handlers
argument_list|,
argument|ih_next
argument_list|)
block|{
if|if
condition|(
name|ithd
operator|->
name|it_flags
operator|&
name|IT_SOFT
operator|&&
operator|!
name|ih
operator|->
name|ih_need
condition|)
continue|continue;
name|atomic_store_rel_int
argument_list|(
operator|&
name|ih
operator|->
name|ih_need
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CTR6
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: pid %d ih=%p: %p(%p) flg=%x"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ih
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ih
operator|->
name|ih_handler
argument_list|,
name|ih
operator|->
name|ih_argument
argument_list|,
name|ih
operator|->
name|ih_flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ih
operator|->
name|ih_flags
operator|&
name|IH_DEAD
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|ithd
operator|->
name|it_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ithd
operator|->
name|it_handlers
argument_list|,
name|ih
argument_list|,
name|ih_next
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|ih
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ithd
operator|->
name|it_lock
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
operator|(
name|ih
operator|->
name|ih_flags
operator|&
name|IH_MPSAFE
operator|)
operator|==
literal|0
condition|)
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|ih
operator|->
name|ih_handler
argument_list|(
name|ih
operator|->
name|ih_argument
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ih
operator|->
name|ih_flags
operator|&
name|IH_MPSAFE
operator|)
operator|==
literal|0
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Processed all our interrupts.  Now get the sched 		 * lock.  This may take a while and it_need may get 		 * set again, so we have to check it again. 		 */
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ithd
operator|->
name|it_need
condition|)
block|{
comment|/* 			 * Should we call this earlier in the loop above? 			 */
if|if
condition|(
name|ithd
operator|->
name|it_enable
operator|!=
name|NULL
condition|)
name|ithd
operator|->
name|it_enable
argument_list|(
name|ithd
operator|->
name|it_vector
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_stat
operator|=
name|SWAIT
expr_stmt|;
comment|/* we're idle */
name|p
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_nvcsw
operator|++
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: pid %d: done"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|mi_switch
argument_list|()
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_INTR
argument_list|,
literal|"%s: pid %d: resumed"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Start standard software interrupt threads  */
end_comment

begin_function
specifier|static
name|void
name|start_softintr
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
if|if
condition|(
name|swi_add
argument_list|(
name|NULL
argument_list|,
literal|"net"
argument_list|,
name|swi_net
argument_list|,
name|NULL
argument_list|,
name|SWI_NET
argument_list|,
literal|0
argument_list|,
operator|&
name|net_ih
argument_list|)
operator|||
name|swi_add
argument_list|(
operator|&
name|clk_ithd
argument_list|,
literal|"clock"
argument_list|,
name|softclock
argument_list|,
name|NULL
argument_list|,
name|SWI_CLOCK
argument_list|,
name|INTR_MPSAFE
argument_list|,
operator|&
name|softclock_ih
argument_list|)
operator|||
name|swi_add
argument_list|(
name|NULL
argument_list|,
literal|"vm"
argument_list|,
name|swi_vm
argument_list|,
name|NULL
argument_list|,
name|SWI_VM
argument_list|,
literal|0
argument_list|,
operator|&
name|vm_ih
argument_list|)
condition|)
name|panic
argument_list|(
literal|"died while creating standard software ithreads"
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|clk_ithd
operator|->
name|it_td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|clk_ithd
operator|->
name|it_td
operator|->
name|td_proc
operator|->
name|p_flag
operator||=
name|P_NOLOAD
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|clk_ithd
operator|->
name|it_td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|start_softintr
argument_list|,
argument|SI_SUB_SOFTINTR
argument_list|,
argument|SI_ORDER_FIRST
argument_list|,
argument|start_softintr
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_function
name|void
name|legacy_setsoftnet
parameter_list|(
name|void
parameter_list|)
block|{
name|swi_sched
argument_list|(
name|net_ih
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX: This should really be in the network code somewhere and installed  * via a SI_SUB_SOFINTR, SI_ORDER_MIDDLE sysinit.  */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|netisrs
index|[
literal|32
index|]
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|volatile
name|unsigned
name|int
name|netisr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scheduling bits for network */
end_comment

begin_function
name|int
name|register_netisr
parameter_list|(
name|num
parameter_list|,
name|handler
parameter_list|)
name|int
name|num
decl_stmt|;
name|netisr_t
modifier|*
name|handler
decl_stmt|;
block|{
if|if
condition|(
name|num
operator|<
literal|0
operator|||
name|num
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|netisrs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|netisrs
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"register_netisr: bad isr number: %d\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|netisrs
index|[
name|num
index|]
operator|=
name|handler
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|unregister_netisr
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
if|if
condition|(
name|num
operator|<
literal|0
operator|||
name|num
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|netisrs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|netisrs
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"unregister_netisr: bad isr number: %d\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|netisrs
index|[
name|num
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_function_decl
name|void
name|netisr_pollmore
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|swi_net
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|u_int
name|bits
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|pollmore
decl_stmt|;
endif|#
directive|endif
name|bits
operator|=
name|atomic_readandclear_int
argument_list|(
operator|&
name|netisr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|bits
operator|==
literal|0
condition|)
return|return;
name|pollmore
operator|=
name|bits
operator|&
operator|(
literal|1
operator|<<
name|NETISR_POLL
operator|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|i
operator|=
name|ffs
argument_list|(
name|bits
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|netisrs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|netisrs
index|[
name|i
index|]
operator|(
operator|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"swi_net: unregistered isr number: %d.\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|bits
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEVICE_POLLING
if|if
condition|(
name|pollmore
condition|)
name|netisr_pollmore
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*   * Sysctls used by systat and others: hw.intrnames and hw.intrcnt.  * The data for this machine dependent, and the declarations are in machine  * dependent code.  The layout of intrnames and intrcnt however is machine  * independent.  *  * We do not know the length of intrcnt and intrnames at compile time, so  * calculate things at run time.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_intrnames
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
return|return
operator|(
name|sysctl_handle_opaque
argument_list|(
name|oidp
argument_list|,
name|intrnames
argument_list|,
name|eintrnames
operator|-
name|intrnames
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|intrnames
argument_list|,
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_intrnames
argument_list|,
literal|""
argument_list|,
literal|"Interrupt Names"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_intrcnt
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
return|return
operator|(
name|sysctl_handle_opaque
argument_list|(
name|oidp
argument_list|,
name|intrcnt
argument_list|,
operator|(
name|char
operator|*
operator|)
name|eintrcnt
operator|-
operator|(
name|char
operator|*
operator|)
name|intrcnt
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|intrcnt
argument_list|,
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_intrcnt
argument_list|,
literal|""
argument_list|,
literal|"Interrupt Counts"
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

