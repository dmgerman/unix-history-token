begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Ed Schouten under sponsorship from the  * FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_include
include|#
directive|include
file|<sys/consio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/terminal.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_TERMINAL
argument_list|,
literal|"terminal"
argument_list|,
literal|"terminal device"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Locking.  *  * Normally we don't need to lock down the terminal emulator, because  * the TTY lock is already held when calling teken_input().  * Unfortunately this is not the case when the terminal acts as a  * console device, because cnputc() can be called at the same time.  * This means terminals may need to be locked down using a spin lock.  */
end_comment

begin_define
define|#
directive|define
name|TERMINAL_LOCK
parameter_list|(
name|tm
parameter_list|)
value|do {					\ 	if ((tm)->tm_flags& TF_CONS)					\ 		mtx_lock_spin(&(tm)->tm_mtx);				\ 	else if ((tm)->tm_tty != NULL)					\ 		tty_lock((tm)->tm_tty);					\ } while (0)
end_define

begin_define
define|#
directive|define
name|TERMINAL_UNLOCK
parameter_list|(
name|tm
parameter_list|)
value|do {					\ 	if ((tm)->tm_flags& TF_CONS)					\ 		mtx_unlock_spin(&(tm)->tm_mtx);				\ 	else if ((tm)->tm_tty != NULL)					\ 		tty_unlock((tm)->tm_tty);				\ } while (0)
end_define

begin_define
define|#
directive|define
name|TERMINAL_LOCK_TTY
parameter_list|(
name|tm
parameter_list|)
value|do {					\ 	if ((tm)->tm_flags& TF_CONS)					\ 		mtx_lock_spin(&(tm)->tm_mtx);				\ } while (0)
end_define

begin_define
define|#
directive|define
name|TERMINAL_UNLOCK_TTY
parameter_list|(
name|tm
parameter_list|)
value|do {					\ 	if ((tm)->tm_flags& TF_CONS)					\ 		mtx_unlock_spin(&(tm)->tm_mtx);				\ } while (0)
end_define

begin_define
define|#
directive|define
name|TERMINAL_LOCK_CONS
parameter_list|(
name|tm
parameter_list|)
value|mtx_lock_spin(&(tm)->tm_mtx)
end_define

begin_define
define|#
directive|define
name|TERMINAL_UNLOCK_CONS
parameter_list|(
name|tm
parameter_list|)
value|mtx_unlock_spin(&(tm)->tm_mtx)
end_define

begin_comment
comment|/*  * TTY routines.  */
end_comment

begin_decl_stmt
specifier|static
name|tsw_open_t
name|termtty_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tsw_close_t
name|termtty_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tsw_outwakeup_t
name|termtty_outwakeup
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tsw_ioctl_t
name|termtty_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tsw_mmap_t
name|termtty_mmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ttydevsw
name|terminal_tty_class
init|=
block|{
operator|.
name|tsw_open
operator|=
name|termtty_open
block|,
operator|.
name|tsw_close
operator|=
name|termtty_close
block|,
operator|.
name|tsw_outwakeup
operator|=
name|termtty_outwakeup
block|,
operator|.
name|tsw_ioctl
operator|=
name|termtty_ioctl
block|,
operator|.
name|tsw_mmap
operator|=
name|termtty_mmap
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Terminal emulator routines.  */
end_comment

begin_decl_stmt
specifier|static
name|tf_bell_t
name|termteken_bell
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tf_cursor_t
name|termteken_cursor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tf_putchar_t
name|termteken_putchar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tf_fill_t
name|termteken_fill
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tf_copy_t
name|termteken_copy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tf_param_t
name|termteken_param
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tf_respond_t
name|termteken_respond
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|teken_funcs_t
name|terminal_drawmethods
init|=
block|{
operator|.
name|tf_bell
operator|=
name|termteken_bell
block|,
operator|.
name|tf_cursor
operator|=
name|termteken_cursor
block|,
operator|.
name|tf_putchar
operator|=
name|termteken_putchar
block|,
operator|.
name|tf_fill
operator|=
name|termteken_fill
block|,
operator|.
name|tf_copy
operator|=
name|termteken_copy
block|,
operator|.
name|tf_param
operator|=
name|termteken_param
block|,
operator|.
name|tf_respond
operator|=
name|termteken_respond
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Kernel message formatting. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|teken_attr_t
name|kernel_message
init|=
block|{
operator|.
name|ta_fgcolor
operator|=
name|TC_WHITE
block|,
operator|.
name|ta_bgcolor
operator|=
name|TC_BLACK
block|,
operator|.
name|ta_format
operator|=
name|TF_BOLD
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|teken_attr_t
name|default_message
init|=
block|{
operator|.
name|ta_fgcolor
operator|=
name|TC_WHITE
block|,
operator|.
name|ta_bgcolor
operator|=
name|TC_BLACK
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TCHAR_CREATE
parameter_list|(
name|c
parameter_list|,
name|a
parameter_list|)
value|((c) | \ 	(a)->ta_format<< 21 | \ 	teken_256to8((a)->ta_fgcolor)<< 26 | \ 	teken_256to8((a)->ta_bgcolor)<< 29)
end_define

begin_function
specifier|static
name|void
name|terminal_init
parameter_list|(
name|struct
name|terminal
modifier|*
name|tm
parameter_list|)
block|{
if|if
condition|(
name|tm
operator|->
name|tm_flags
operator|&
name|TF_CONS
condition|)
name|mtx_init
argument_list|(
operator|&
name|tm
operator|->
name|tm_mtx
argument_list|,
literal|"trmlck"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|teken_init
argument_list|(
operator|&
name|tm
operator|->
name|tm_emulator
argument_list|,
operator|&
name|terminal_drawmethods
argument_list|,
name|tm
argument_list|)
expr_stmt|;
name|teken_set_defattr
argument_list|(
operator|&
name|tm
operator|->
name|tm_emulator
argument_list|,
operator|&
name|default_message
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|terminal
modifier|*
name|terminal_alloc
parameter_list|(
specifier|const
name|struct
name|terminal_class
modifier|*
name|tc
parameter_list|,
name|void
modifier|*
name|softc
parameter_list|)
block|{
name|struct
name|terminal
modifier|*
name|tm
decl_stmt|;
name|tm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|terminal
argument_list|)
argument_list|,
name|M_TERMINAL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|terminal_init
argument_list|(
name|tm
argument_list|)
expr_stmt|;
name|tm
operator|->
name|tm_class
operator|=
name|tc
expr_stmt|;
name|tm
operator|->
name|tm_softc
operator|=
name|softc
expr_stmt|;
return|return
operator|(
name|tm
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|terminal_sync_ttysize
parameter_list|(
name|struct
name|terminal
modifier|*
name|tm
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|tm
operator|->
name|tm_tty
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tty_set_winsize
argument_list|(
name|tp
argument_list|,
operator|&
name|tm
operator|->
name|tm_winsize
argument_list|)
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|terminal_maketty
parameter_list|(
name|struct
name|terminal
modifier|*
name|tm
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|char
name|name
index|[
literal|8
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnrprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
literal|32
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|tp
operator|=
name|tty_alloc
argument_list|(
operator|&
name|terminal_tty_class
argument_list|,
name|tm
argument_list|)
expr_stmt|;
name|tty_makedev
argument_list|(
name|tp
argument_list|,
name|NULL
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|tm
operator|->
name|tm_tty
operator|=
name|tp
expr_stmt|;
name|terminal_sync_ttysize
argument_list|(
name|tm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|terminal_set_winsize_blank
parameter_list|(
name|struct
name|terminal
modifier|*
name|tm
parameter_list|,
specifier|const
name|struct
name|winsize
modifier|*
name|size
parameter_list|,
name|int
name|blank
parameter_list|)
block|{
name|term_rect_t
name|r
decl_stmt|;
name|tm
operator|->
name|tm_winsize
operator|=
operator|*
name|size
expr_stmt|;
name|r
operator|.
name|tr_begin
operator|.
name|tp_row
operator|=
name|r
operator|.
name|tr_begin
operator|.
name|tp_col
operator|=
literal|0
expr_stmt|;
name|r
operator|.
name|tr_end
operator|.
name|tp_row
operator|=
name|size
operator|->
name|ws_row
expr_stmt|;
name|r
operator|.
name|tr_end
operator|.
name|tp_col
operator|=
name|size
operator|->
name|ws_col
expr_stmt|;
name|TERMINAL_LOCK
argument_list|(
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|blank
operator|==
literal|0
condition|)
name|teken_set_winsize_noreset
argument_list|(
operator|&
name|tm
operator|->
name|tm_emulator
argument_list|,
operator|&
name|r
operator|.
name|tr_end
argument_list|)
expr_stmt|;
else|else
name|teken_set_winsize
argument_list|(
operator|&
name|tm
operator|->
name|tm_emulator
argument_list|,
operator|&
name|r
operator|.
name|tr_end
argument_list|)
expr_stmt|;
name|TERMINAL_UNLOCK
argument_list|(
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|blank
operator|!=
literal|0
condition|)
name|tm
operator|->
name|tm_class
operator|->
name|tc_fill
argument_list|(
name|tm
argument_list|,
operator|&
name|r
argument_list|,
name|TCHAR_CREATE
argument_list|(
operator|(
name|teken_char_t
operator|)
literal|' '
argument_list|,
operator|&
name|default_message
argument_list|)
argument_list|)
expr_stmt|;
name|terminal_sync_ttysize
argument_list|(
name|tm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|terminal_set_winsize
parameter_list|(
name|struct
name|terminal
modifier|*
name|tm
parameter_list|,
specifier|const
name|struct
name|winsize
modifier|*
name|size
parameter_list|)
block|{
name|terminal_set_winsize_blank
argument_list|(
name|tm
argument_list|,
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX: This function is a kludge.  Drivers like vt(4) need to  * temporarily stop input when resizing, etc.  This should ideally be  * handled within the driver.  */
end_comment

begin_function
name|void
name|terminal_mute
parameter_list|(
name|struct
name|terminal
modifier|*
name|tm
parameter_list|,
name|int
name|yes
parameter_list|)
block|{
name|TERMINAL_LOCK
argument_list|(
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|yes
condition|)
name|tm
operator|->
name|tm_flags
operator||=
name|TF_MUTE
expr_stmt|;
else|else
name|tm
operator|->
name|tm_flags
operator|&=
operator|~
name|TF_MUTE
expr_stmt|;
name|TERMINAL_UNLOCK
argument_list|(
name|tm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|terminal_input_char
parameter_list|(
name|struct
name|terminal
modifier|*
name|tm
parameter_list|,
name|term_char_t
name|c
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|tm
operator|->
name|tm_tty
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Strip off any attributes. Also ignore input of second part of 	 * CJK fullwidth characters, as we don't want to return these 	 * characters twice. 	 */
if|if
condition|(
name|TCHAR_FORMAT
argument_list|(
name|c
argument_list|)
operator|&
name|TF_CJK_RIGHT
condition|)
return|return;
name|c
operator|=
name|TCHAR_CHARACTER
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* 	 * Conversion to UTF-8. 	 */
if|if
condition|(
name|c
operator|<
literal|0x80
condition|)
block|{
name|ttydisc_rint
argument_list|(
name|tp
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0x800
condition|)
block|{
name|char
name|str
index|[
literal|2
index|]
init|=
block|{
literal|0xc0
operator||
operator|(
name|c
operator|>>
literal|6
operator|)
block|,
literal|0x80
operator||
operator|(
name|c
operator|&
literal|0x3f
operator|)
block|}
decl_stmt|;
name|ttydisc_rint_simple
argument_list|(
name|tp
argument_list|,
name|str
argument_list|,
sizeof|sizeof
name|str
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|0x10000
condition|)
block|{
name|char
name|str
index|[
literal|3
index|]
init|=
block|{
literal|0xe0
operator||
operator|(
name|c
operator|>>
literal|12
operator|)
block|,
literal|0x80
operator||
operator|(
operator|(
name|c
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
block|,
literal|0x80
operator||
operator|(
name|c
operator|&
literal|0x3f
operator|)
block|}
decl_stmt|;
name|ttydisc_rint_simple
argument_list|(
name|tp
argument_list|,
name|str
argument_list|,
sizeof|sizeof
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|str
index|[
literal|4
index|]
init|=
block|{
literal|0xf0
operator||
operator|(
name|c
operator|>>
literal|18
operator|)
block|,
literal|0x80
operator||
operator|(
operator|(
name|c
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
operator|)
block|,
literal|0x80
operator||
operator|(
operator|(
name|c
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
block|,
literal|0x80
operator||
operator|(
name|c
operator|&
literal|0x3f
operator|)
block|}
decl_stmt|;
name|ttydisc_rint_simple
argument_list|(
name|tp
argument_list|,
name|str
argument_list|,
sizeof|sizeof
name|str
argument_list|)
expr_stmt|;
block|}
name|ttydisc_rint_done
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|terminal_input_raw
parameter_list|(
name|struct
name|terminal
modifier|*
name|tm
parameter_list|,
name|char
name|c
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|tm
operator|->
name|tm_tty
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|ttydisc_rint
argument_list|(
name|tp
argument_list|,
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ttydisc_rint_done
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|terminal_input_special
parameter_list|(
name|struct
name|terminal
modifier|*
name|tm
parameter_list|,
name|unsigned
name|int
name|k
parameter_list|)
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|tp
operator|=
name|tm
operator|->
name|tm_tty
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return;
name|str
operator|=
name|teken_get_sequence
argument_list|(
operator|&
name|tm
operator|->
name|tm_emulator
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|ttydisc_rint_simple
argument_list|(
name|tp
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|ttydisc_rint_done
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Binding with the TTY layer.  */
end_comment

begin_function
specifier|static
name|int
name|termtty_open
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|terminal
modifier|*
name|tm
init|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
decl_stmt|;
name|tm
operator|->
name|tm_class
operator|->
name|tc_opened
argument_list|(
name|tm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termtty_close
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|terminal
modifier|*
name|tm
init|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
decl_stmt|;
name|tm
operator|->
name|tm_class
operator|->
name|tc_opened
argument_list|(
name|tm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|termtty_outwakeup
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|terminal
modifier|*
name|tm
init|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
decl_stmt|;
name|char
name|obuf
index|[
literal|128
index|]
decl_stmt|;
name|size_t
name|olen
decl_stmt|;
name|unsigned
name|int
name|flags
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|olen
operator|=
name|ttydisc_getc
argument_list|(
name|tp
argument_list|,
name|obuf
argument_list|,
sizeof|sizeof
name|obuf
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|TERMINAL_LOCK_TTY
argument_list|(
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tm
operator|->
name|tm_flags
operator|&
name|TF_MUTE
operator|)
condition|)
block|{
name|tm
operator|->
name|tm_flags
operator|&=
operator|~
name|TF_BELL
expr_stmt|;
name|teken_input
argument_list|(
operator|&
name|tm
operator|->
name|tm_emulator
argument_list|,
name|obuf
argument_list|,
name|olen
argument_list|)
expr_stmt|;
name|flags
operator||=
name|tm
operator|->
name|tm_flags
expr_stmt|;
block|}
name|TERMINAL_UNLOCK_TTY
argument_list|(
name|tm
argument_list|)
expr_stmt|;
block|}
name|tm
operator|->
name|tm_class
operator|->
name|tc_done
argument_list|(
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TF_BELL
condition|)
name|tm
operator|->
name|tm_class
operator|->
name|tc_bell
argument_list|(
name|tm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|termtty_ioctl
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|terminal
modifier|*
name|tm
init|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|CONS_GETINFO
case|:
block|{
name|vid_info_t
modifier|*
name|vi
init|=
operator|(
name|vid_info_t
operator|*
operator|)
name|data
decl_stmt|;
specifier|const
name|teken_pos_t
modifier|*
name|p
decl_stmt|;
name|int
name|fg
decl_stmt|,
name|bg
decl_stmt|;
if|if
condition|(
name|vi
operator|->
name|size
operator|!=
sizeof|sizeof
argument_list|(
name|vid_info_t
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Already help the console driver by filling in some data. */
name|p
operator|=
name|teken_get_cursor
argument_list|(
operator|&
name|tm
operator|->
name|tm_emulator
argument_list|)
expr_stmt|;
name|vi
operator|->
name|mv_row
operator|=
name|p
operator|->
name|tp_row
expr_stmt|;
name|vi
operator|->
name|mv_col
operator|=
name|p
operator|->
name|tp_col
expr_stmt|;
name|p
operator|=
name|teken_get_winsize
argument_list|(
operator|&
name|tm
operator|->
name|tm_emulator
argument_list|)
expr_stmt|;
name|vi
operator|->
name|mv_rsz
operator|=
name|p
operator|->
name|tp_row
expr_stmt|;
name|vi
operator|->
name|mv_csz
operator|=
name|p
operator|->
name|tp_col
expr_stmt|;
name|teken_get_defattr_cons25
argument_list|(
operator|&
name|tm
operator|->
name|tm_emulator
argument_list|,
operator|&
name|fg
argument_list|,
operator|&
name|bg
argument_list|)
expr_stmt|;
name|vi
operator|->
name|mv_norm
operator|.
name|fore
operator|=
name|fg
expr_stmt|;
name|vi
operator|->
name|mv_norm
operator|.
name|back
operator|=
name|bg
expr_stmt|;
comment|/* XXX: keep vidcontrol happy; bold backgrounds. */
name|vi
operator|->
name|mv_rev
operator|.
name|fore
operator|=
name|bg
expr_stmt|;
name|vi
operator|->
name|mv_rev
operator|.
name|back
operator|=
name|fg
operator|&
literal|0x7
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * Unlike various other drivers, this driver will never 	 * deallocate TTYs.  This means it's safe to temporarily unlock 	 * the TTY when handling ioctls. 	 */
name|tty_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|error
operator|=
name|tm
operator|->
name|tm_class
operator|->
name|tc_ioctl
argument_list|(
name|tm
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|tty_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|termtty_mmap
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_paddr_t
modifier|*
name|paddr
parameter_list|,
name|int
name|nprot
parameter_list|,
name|vm_memattr_t
modifier|*
name|memattr
parameter_list|)
block|{
name|struct
name|terminal
modifier|*
name|tm
init|=
name|tty_softc
argument_list|(
name|tp
argument_list|)
decl_stmt|;
return|return
operator|(
name|tm
operator|->
name|tm_class
operator|->
name|tc_mmap
argument_list|(
name|tm
argument_list|,
name|offset
argument_list|,
name|paddr
argument_list|,
name|nprot
argument_list|,
name|memattr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Binding with the kernel and debug console.  */
end_comment

begin_decl_stmt
specifier|static
name|cn_probe_t
name|termcn_cnprobe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cn_init_t
name|termcn_cninit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cn_term_t
name|termcn_cnterm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cn_getc_t
name|termcn_cngetc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cn_putc_t
name|termcn_cnputc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cn_grab_t
name|termcn_cngrab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cn_ungrab_t
name|termcn_cnungrab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|consdev_ops
name|termcn_cnops
init|=
block|{
operator|.
name|cn_probe
operator|=
name|termcn_cnprobe
block|,
operator|.
name|cn_init
operator|=
name|termcn_cninit
block|,
operator|.
name|cn_term
operator|=
name|termcn_cnterm
block|,
operator|.
name|cn_getc
operator|=
name|termcn_cngetc
block|,
operator|.
name|cn_putc
operator|=
name|termcn_cnputc
block|,
operator|.
name|cn_grab
operator|=
name|termcn_cngrab
block|,
operator|.
name|cn_ungrab
operator|=
name|termcn_cnungrab
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|termcn_cnregister
parameter_list|(
name|struct
name|terminal
modifier|*
name|tm
parameter_list|)
block|{
name|struct
name|consdev
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
name|tm
operator|->
name|consdev
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|cp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|consdev
argument_list|)
argument_list|,
name|M_TERMINAL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|cp
operator|->
name|cn_ops
operator|=
operator|&
name|termcn_cnops
expr_stmt|;
name|cp
operator|->
name|cn_arg
operator|=
name|tm
expr_stmt|;
name|cp
operator|->
name|cn_pri
operator|=
name|CN_INTERNAL
expr_stmt|;
name|sprintf
argument_list|(
name|cp
operator|->
name|cn_name
argument_list|,
literal|"ttyv0"
argument_list|)
expr_stmt|;
name|tm
operator|->
name|tm_flags
operator|=
name|TF_CONS
expr_stmt|;
name|tm
operator|->
name|consdev
operator|=
name|cp
expr_stmt|;
name|terminal_init
argument_list|(
name|tm
argument_list|)
expr_stmt|;
block|}
comment|/* Attach terminal as console. */
name|cnadd
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|termcn_cngrab
parameter_list|(
name|struct
name|consdev
modifier|*
name|cp
parameter_list|)
block|{  }
end_function

begin_function
specifier|static
name|void
name|termcn_cnungrab
parameter_list|(
name|struct
name|consdev
modifier|*
name|cp
parameter_list|)
block|{  }
end_function

begin_function
specifier|static
name|void
name|termcn_cnprobe
parameter_list|(
name|struct
name|consdev
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|terminal
modifier|*
name|tm
init|=
name|cp
operator|->
name|cn_arg
decl_stmt|;
if|if
condition|(
name|tm
operator|==
name|NULL
condition|)
block|{
name|cp
operator|->
name|cn_pri
operator|=
name|CN_DEAD
expr_stmt|;
return|return;
block|}
name|tm
operator|->
name|consdev
operator|=
name|cp
expr_stmt|;
name|terminal_init
argument_list|(
name|tm
argument_list|)
expr_stmt|;
name|tm
operator|->
name|tm_class
operator|->
name|tc_cnprobe
argument_list|(
name|tm
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|termcn_cninit
parameter_list|(
name|struct
name|consdev
modifier|*
name|cp
parameter_list|)
block|{  }
end_function

begin_function
specifier|static
name|void
name|termcn_cnterm
parameter_list|(
name|struct
name|consdev
modifier|*
name|cp
parameter_list|)
block|{  }
end_function

begin_function
specifier|static
name|int
name|termcn_cngetc
parameter_list|(
name|struct
name|consdev
modifier|*
name|cp
parameter_list|)
block|{
name|struct
name|terminal
modifier|*
name|tm
init|=
name|cp
operator|->
name|cn_arg
decl_stmt|;
return|return
operator|(
name|tm
operator|->
name|tm_class
operator|->
name|tc_cngetc
argument_list|(
name|tm
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|termcn_cnputc
parameter_list|(
name|struct
name|consdev
modifier|*
name|cp
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|struct
name|terminal
modifier|*
name|tm
init|=
name|cp
operator|->
name|cn_arg
decl_stmt|;
name|teken_attr_t
name|backup
decl_stmt|;
name|char
name|cv
init|=
name|c
decl_stmt|;
name|TERMINAL_LOCK_CONS
argument_list|(
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|tm
operator|->
name|tm_flags
operator|&
name|TF_MUTE
operator|)
condition|)
block|{
name|backup
operator|=
operator|*
name|teken_get_curattr
argument_list|(
operator|&
name|tm
operator|->
name|tm_emulator
argument_list|)
expr_stmt|;
name|teken_set_curattr
argument_list|(
operator|&
name|tm
operator|->
name|tm_emulator
argument_list|,
operator|&
name|kernel_message
argument_list|)
expr_stmt|;
name|teken_input
argument_list|(
operator|&
name|tm
operator|->
name|tm_emulator
argument_list|,
operator|&
name|cv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|teken_set_curattr
argument_list|(
operator|&
name|tm
operator|->
name|tm_emulator
argument_list|,
operator|&
name|backup
argument_list|)
expr_stmt|;
block|}
name|TERMINAL_UNLOCK_CONS
argument_list|(
name|tm
argument_list|)
expr_stmt|;
name|tm
operator|->
name|tm_class
operator|->
name|tc_done
argument_list|(
name|tm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Binding with the terminal emulator.  */
end_comment

begin_function
specifier|static
name|void
name|termteken_bell
parameter_list|(
name|void
modifier|*
name|softc
parameter_list|)
block|{
name|struct
name|terminal
modifier|*
name|tm
init|=
name|softc
decl_stmt|;
name|tm
operator|->
name|tm_flags
operator||=
name|TF_BELL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|termteken_cursor
parameter_list|(
name|void
modifier|*
name|softc
parameter_list|,
specifier|const
name|teken_pos_t
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|terminal
modifier|*
name|tm
init|=
name|softc
decl_stmt|;
name|tm
operator|->
name|tm_class
operator|->
name|tc_cursor
argument_list|(
name|tm
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|termteken_putchar
parameter_list|(
name|void
modifier|*
name|softc
parameter_list|,
specifier|const
name|teken_pos_t
modifier|*
name|p
parameter_list|,
name|teken_char_t
name|c
parameter_list|,
specifier|const
name|teken_attr_t
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|terminal
modifier|*
name|tm
init|=
name|softc
decl_stmt|;
name|tm
operator|->
name|tm_class
operator|->
name|tc_putchar
argument_list|(
name|tm
argument_list|,
name|p
argument_list|,
name|TCHAR_CREATE
argument_list|(
name|c
argument_list|,
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|termteken_fill
parameter_list|(
name|void
modifier|*
name|softc
parameter_list|,
specifier|const
name|teken_rect_t
modifier|*
name|r
parameter_list|,
name|teken_char_t
name|c
parameter_list|,
specifier|const
name|teken_attr_t
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|terminal
modifier|*
name|tm
init|=
name|softc
decl_stmt|;
name|tm
operator|->
name|tm_class
operator|->
name|tc_fill
argument_list|(
name|tm
argument_list|,
name|r
argument_list|,
name|TCHAR_CREATE
argument_list|(
name|c
argument_list|,
name|a
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|termteken_copy
parameter_list|(
name|void
modifier|*
name|softc
parameter_list|,
specifier|const
name|teken_rect_t
modifier|*
name|r
parameter_list|,
specifier|const
name|teken_pos_t
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|terminal
modifier|*
name|tm
init|=
name|softc
decl_stmt|;
name|tm
operator|->
name|tm_class
operator|->
name|tc_copy
argument_list|(
name|tm
argument_list|,
name|r
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|termteken_param
parameter_list|(
name|void
modifier|*
name|softc
parameter_list|,
name|int
name|cmd
parameter_list|,
name|unsigned
name|int
name|arg
parameter_list|)
block|{
name|struct
name|terminal
modifier|*
name|tm
init|=
name|softc
decl_stmt|;
name|tm
operator|->
name|tm_class
operator|->
name|tc_param
argument_list|(
name|tm
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|termteken_respond
parameter_list|(
name|void
modifier|*
name|softc
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|#
directive|if
literal|0
block|struct terminal *tm = softc; 	struct tty *tp;
comment|/* 	 * Only inject a response into the TTY if the data actually 	 * originated from the TTY. 	 * 	 * XXX: This cannot be done right now.  The TTY could pick up 	 * other locks.  It could also in theory cause loops, when the 	 * TTY performs echoing of a command that generates even more 	 * input. 	 */
block|tp = tm->tm_tty; 	if (tp == NULL) 		return;  	ttydisc_rint_simple(tp, buf, len); 	ttydisc_rint_done(tp);
endif|#
directive|endif
block|}
end_function

end_unit

