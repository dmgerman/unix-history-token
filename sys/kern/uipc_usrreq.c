begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1989, 1991, 1993  *	The Regents of the University of California.  * Copyright (c) 2004-2009 Robert N. M. Watson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	From: @(#)uipc_usrreq.c	8.3 (Berkeley) 1/4/94  */
end_comment

begin_comment
comment|/*  * UNIX Domain (Local) Sockets  *  * This is an implementation of UNIX (local) domain sockets.  Each socket has  * an associated struct unpcb (UNIX protocol control block).  Stream sockets  * may be connected to 0 or 1 other socket.  Datagram sockets may be  * connected to 0, 1, or many other sockets.  Sockets may be created and  * connected in pairs (socketpair(2)), or bound/connected to using the file  * system name space.  For most purposes, only the receive socket buffer is  * used, as sending on one socket delivers directly to the receive socket  * buffer of a second socket.  *  * The implementation is substantially complicated by the fact that  * "ancillary data", such as file descriptors or credentials, may be passed  * across UNIX domain sockets.  The potential for passing UNIX domain sockets  * over other UNIX domain sockets requires the implementation of a simple  * garbage collector to find and tear down cycles of disconnected sockets.  *  * TODO:  *	SEQPACKET, RDM  *	rethink name space problems  *	need a proper out-of-band  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_comment
comment|/* XXX must be before<sys/file.h> */
end_comment

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<sys/unpcb.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_comment
comment|/*  * Locking key:  * (l)	Locked using list lock  * (g)	Locked using linkage lock  */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|unp_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unp_gen_t
name|unp_gencnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (l) */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|unp_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (l) Count of local sockets. */
end_comment

begin_decl_stmt
specifier|static
name|ino_t
name|unp_ino
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototype for fake inode numbers. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unp_rights
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (g) File descriptors in flight. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|unp_head
name|unp_shead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (l) List of stream sockets. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|unp_head
name|unp_dhead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (l) List of datagram sockets. */
end_comment

begin_struct
struct|struct
name|unp_defer
block|{
name|SLIST_ENTRY
argument_list|(
argument|unp_defer
argument_list|)
name|ud_link
expr_stmt|;
name|struct
name|file
modifier|*
name|ud_fp
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|unp_defer
argument_list|)
name|unp_defers
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|unp_defers_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sockaddr
name|sun_noname
init|=
block|{
sizeof|sizeof
argument_list|(
name|sun_noname
argument_list|)
block|,
name|AF_LOCAL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Garbage collection of cyclic file descriptor/socket references occurs  * asynchronously in a taskqueue context in order to avoid recursion and  * reentrance in the UNIX domain socket, file descriptor, and socket layer  * code.  See unp_gc() for a full description.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|task
name|unp_gc_task
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The close of unix domain sockets attached as SCM_RIGHTS is  * postponed to the taskqueue, to avoid arbitrary recursion depth.  * The attached sockets might have another sockets attached.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|task
name|unp_defer_task
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Both send and receive buffers are allocated PIPSIZ bytes of buffering for  * stream sockets, although the total for sender and receiver is actually  * only PIPSIZ.  *  * Datagram sockets really use the sendspace as the maximum datagram size,  * and don't really want to reserve the sendspace.  Their recvspace should be  * large enough for at least one max-size datagram plus address.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PIPSIZ
end_ifndef

begin_define
define|#
directive|define
name|PIPSIZ
value|8192
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|u_long
name|unpst_sendspace
init|=
name|PIPSIZ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|unpst_recvspace
init|=
name|PIPSIZ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|unpdg_sendspace
init|=
literal|2
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* really max datagram size */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|unpdg_recvspace
init|=
literal|4
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net
argument_list|,
name|PF_LOCAL
argument_list|,
name|local
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Local domain"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_local
argument_list|,
name|SOCK_STREAM
argument_list|,
name|stream
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"SOCK_STREAM"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_local
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|dgram
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"SOCK_DGRAM"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_local_stream
argument_list|,
name|OID_AUTO
argument_list|,
name|sendspace
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unpst_sendspace
argument_list|,
literal|0
argument_list|,
literal|"Default stream send space."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_local_stream
argument_list|,
name|OID_AUTO
argument_list|,
name|recvspace
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unpst_recvspace
argument_list|,
literal|0
argument_list|,
literal|"Default stream receive space."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_local_dgram
argument_list|,
name|OID_AUTO
argument_list|,
name|maxdgram
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unpdg_sendspace
argument_list|,
literal|0
argument_list|,
literal|"Default datagram send space."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_local_dgram
argument_list|,
name|OID_AUTO
argument_list|,
name|recvspace
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unpdg_recvspace
argument_list|,
literal|0
argument_list|,
literal|"Default datagram receive space."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_local
argument_list|,
name|OID_AUTO
argument_list|,
name|inflight
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|unp_rights
argument_list|,
literal|0
argument_list|,
literal|"File descriptors in flight."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_local
argument_list|,
name|OID_AUTO
argument_list|,
name|deferred
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|unp_defers_count
argument_list|,
literal|0
argument_list|,
literal|"File descriptors deferred to taskqueue for close."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-  * Locking and synchronization:  *  * Three types of locks exit in the local domain socket implementation: a  * global list mutex, a global linkage rwlock, and per-unpcb mutexes.  Of the  * global locks, the list lock protects the socket count, global generation  * number, and stream/datagram global lists.  The linkage lock protects the  * interconnection of unpcbs, the v_socket and unp_vnode pointers, and can be  * held exclusively over the acquisition of multiple unpcb locks to prevent  * deadlock.  *  * UNIX domain sockets each have an unpcb hung off of their so_pcb pointer,  * allocated in pru_attach() and freed in pru_detach().  The validity of that  * pointer is an invariant, so no lock is required to dereference the so_pcb  * pointer if a valid socket reference is held by the caller.  In practice,  * this is always true during operations performed on a socket.  Each unpcb  * has a back-pointer to its socket, unp_socket, which will be stable under  * the same circumstances.  *  * This pointer may only be safely dereferenced as long as a valid reference  * to the unpcb is held.  Typically, this reference will be from the socket,  * or from another unpcb when the referring unpcb's lock is held (in order  * that the reference not be invalidated during use).  For example, to follow  * unp->unp_conn->unp_socket, you need unlock the lock on unp, not unp_conn,  * as unp_socket remains valid as long as the reference to unp_conn is valid.  *  * Fields of unpcbss are locked using a per-unpcb lock, unp_mtx.  Individual  * atomic reads without the lock may be performed "lockless", but more  * complex reads and read-modify-writes require the mutex to be held.  No  * lock order is defined between unpcb locks -- multiple unpcb locks may be  * acquired at the same time only when holding the linkage rwlock  * exclusively, which prevents deadlocks.  *  * Blocking with UNIX domain sockets is a tricky issue: unlike most network  * protocols, bind() is a non-atomic operation, and connect() requires  * potential sleeping in the protocol, due to potentially waiting on local or  * distributed file systems.  We try to separate "lookup" operations, which  * may sleep, and the IPC operations themselves, which typically can occur  * with relative atomicity as locks can be held over the entire operation.  *  * Another tricky issue is simultaneous multi-threaded or multi-process  * access to a single UNIX domain socket.  These are handled by the flags  * UNP_CONNECTING and UNP_BINDING, which prevent concurrent connecting or  * binding, both of which involve dropping UNIX domain socket locks in order  * to perform namei() and other file system operations.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|rwlock
name|unp_link_rwlock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|unp_list_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|unp_defers_lock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UNP_LINK_LOCK_INIT
parameter_list|()
value|rw_init(&unp_link_rwlock,	\ 					    "unp_link_rwlock")
end_define

begin_define
define|#
directive|define
name|UNP_LINK_LOCK_ASSERT
parameter_list|()
value|rw_assert(&unp_link_rwlock,	\ 					    RA_LOCKED)
end_define

begin_define
define|#
directive|define
name|UNP_LINK_UNLOCK_ASSERT
parameter_list|()
value|rw_assert(&unp_link_rwlock,	\ 					    RA_UNLOCKED)
end_define

begin_define
define|#
directive|define
name|UNP_LINK_RLOCK
parameter_list|()
value|rw_rlock(&unp_link_rwlock)
end_define

begin_define
define|#
directive|define
name|UNP_LINK_RUNLOCK
parameter_list|()
value|rw_runlock(&unp_link_rwlock)
end_define

begin_define
define|#
directive|define
name|UNP_LINK_WLOCK
parameter_list|()
value|rw_wlock(&unp_link_rwlock)
end_define

begin_define
define|#
directive|define
name|UNP_LINK_WUNLOCK
parameter_list|()
value|rw_wunlock(&unp_link_rwlock)
end_define

begin_define
define|#
directive|define
name|UNP_LINK_WLOCK_ASSERT
parameter_list|()
value|rw_assert(&unp_link_rwlock,	\ 					    RA_WLOCKED)
end_define

begin_define
define|#
directive|define
name|UNP_LIST_LOCK_INIT
parameter_list|()
value|mtx_init(&unp_list_lock,	\ 					    "unp_list_lock", NULL, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|UNP_LIST_LOCK
parameter_list|()
value|mtx_lock(&unp_list_lock)
end_define

begin_define
define|#
directive|define
name|UNP_LIST_UNLOCK
parameter_list|()
value|mtx_unlock(&unp_list_lock)
end_define

begin_define
define|#
directive|define
name|UNP_DEFERRED_LOCK_INIT
parameter_list|()
value|mtx_init(&unp_defers_lock, \ 					    "unp_defer", NULL, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|UNP_DEFERRED_LOCK
parameter_list|()
value|mtx_lock(&unp_defers_lock)
end_define

begin_define
define|#
directive|define
name|UNP_DEFERRED_UNLOCK
parameter_list|()
value|mtx_unlock(&unp_defers_lock)
end_define

begin_define
define|#
directive|define
name|UNP_PCB_LOCK_INIT
parameter_list|(
name|unp
parameter_list|)
value|mtx_init(&(unp)->unp_mtx,	\ 					    "unp_mtx", "unp_mtx",	\ 					    MTX_DUPOK|MTX_DEF|MTX_RECURSE)
end_define

begin_define
define|#
directive|define
name|UNP_PCB_LOCK_DESTROY
parameter_list|(
name|unp
parameter_list|)
value|mtx_destroy(&(unp)->unp_mtx)
end_define

begin_define
define|#
directive|define
name|UNP_PCB_LOCK
parameter_list|(
name|unp
parameter_list|)
value|mtx_lock(&(unp)->unp_mtx)
end_define

begin_define
define|#
directive|define
name|UNP_PCB_UNLOCK
parameter_list|(
name|unp
parameter_list|)
value|mtx_unlock(&(unp)->unp_mtx)
end_define

begin_define
define|#
directive|define
name|UNP_PCB_LOCK_ASSERT
parameter_list|(
name|unp
parameter_list|)
value|mtx_assert(&(unp)->unp_mtx, MA_OWNED)
end_define

begin_function_decl
specifier|static
name|int
name|uipc_connect2
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|socket
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|uipc_ctloutput
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unp_connect
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unp_connect2
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|socket
modifier|*
name|so2
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_disconnect
parameter_list|(
name|struct
name|unpcb
modifier|*
name|unp
parameter_list|,
name|struct
name|unpcb
modifier|*
name|unp2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_dispose
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_shutdown
parameter_list|(
name|struct
name|unpcb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_drop
parameter_list|(
name|struct
name|unpcb
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_gc
parameter_list|(
name|__unused
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_scan
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|struct
name|file
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_discard
parameter_list|(
name|struct
name|file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_freerights
parameter_list|(
name|struct
name|file
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unp_internalize
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_internalize_fp
parameter_list|(
name|struct
name|file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unp_externalize
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unp_externalize_fp
parameter_list|(
name|struct
name|file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|unp_addsockcred
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_process_defers
parameter_list|(
name|void
modifier|*
name|__unused
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Definitions of protocols supported in the LOCAL domain.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|domain
name|localdomain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pr_usrreqs
name|uipc_usrreqs_dgram
decl_stmt|,
name|uipc_usrreqs_stream
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|protosw
name|localsw
index|[]
init|=
block|{
block|{
operator|.
name|pr_type
operator|=
name|SOCK_STREAM
block|,
operator|.
name|pr_domain
operator|=
operator|&
name|localdomain
block|,
operator|.
name|pr_flags
operator|=
name|PR_CONNREQUIRED
operator||
name|PR_WANTRCVD
operator||
name|PR_RIGHTS
block|,
operator|.
name|pr_ctloutput
operator|=
operator|&
name|uipc_ctloutput
block|,
operator|.
name|pr_usrreqs
operator|=
operator|&
name|uipc_usrreqs_stream
block|}
block|,
block|{
operator|.
name|pr_type
operator|=
name|SOCK_DGRAM
block|,
operator|.
name|pr_domain
operator|=
operator|&
name|localdomain
block|,
operator|.
name|pr_flags
operator|=
name|PR_ATOMIC
operator||
name|PR_ADDR
operator||
name|PR_RIGHTS
block|,
operator|.
name|pr_usrreqs
operator|=
operator|&
name|uipc_usrreqs_dgram
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|domain
name|localdomain
init|=
block|{
operator|.
name|dom_family
operator|=
name|AF_LOCAL
block|,
operator|.
name|dom_name
operator|=
literal|"local"
block|,
operator|.
name|dom_init
operator|=
name|unp_init
block|,
operator|.
name|dom_externalize
operator|=
name|unp_externalize
block|,
operator|.
name|dom_dispose
operator|=
name|unp_dispose
block|,
operator|.
name|dom_protosw
operator|=
name|localsw
block|,
operator|.
name|dom_protoswNPROTOSW
operator|=
operator|&
name|localsw
index|[
sizeof|sizeof
argument_list|(
name|localsw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|localsw
index|[
literal|0
index|]
argument_list|)
index|]
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DOMAIN_SET
argument_list|(
name|local
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|uipc_abort
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_abort: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|UNP_LINK_WLOCK
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|unp2
operator|!=
name|NULL
condition|)
block|{
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|unp_drop
argument_list|(
name|unp2
argument_list|,
name|ECONNABORTED
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
block|}
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_LINK_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_accept
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|;
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
comment|/* 	 * Pass back name of connected socket, if it was bound and we are 	 * still connected (our peer may have closed already!). 	 */
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_accept: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|nam
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
argument_list|,
name|M_SONAME
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|UNP_LINK_RLOCK
argument_list|()
expr_stmt|;
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|unp2
operator|!=
name|NULL
operator|&&
name|unp2
operator|->
name|unp_addr
operator|!=
name|NULL
condition|)
block|{
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|unp2
operator|->
name|unp_addr
expr_stmt|;
name|bcopy
argument_list|(
name|sa
argument_list|,
operator|*
name|nam
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sa
operator|=
operator|&
name|sun_noname
expr_stmt|;
name|bcopy
argument_list|(
name|sa
argument_list|,
operator|*
name|nam
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
block|}
name|UNP_LINK_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|u_long
name|sendspace
decl_stmt|,
name|recvspace
decl_stmt|;
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|so
operator|->
name|so_pcb
operator|==
name|NULL
argument_list|,
operator|(
literal|"uipc_attach: so_pcb != NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|==
literal|0
operator|||
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|so
operator|->
name|so_type
condition|)
block|{
case|case
name|SOCK_STREAM
case|:
name|sendspace
operator|=
name|unpst_sendspace
expr_stmt|;
name|recvspace
operator|=
name|unpst_recvspace
expr_stmt|;
break|break;
case|case
name|SOCK_DGRAM
case|:
name|sendspace
operator|=
name|unpdg_sendspace
expr_stmt|;
name|recvspace
operator|=
name|unpdg_recvspace
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"uipc_attach"
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|sendspace
argument_list|,
name|recvspace
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|unp
operator|=
name|uma_zalloc
argument_list|(
name|unp_zone
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|LIST_INIT
argument_list|(
operator|&
name|unp
operator|->
name|unp_refs
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK_INIT
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_socket
operator|=
name|so
expr_stmt|;
name|so
operator|->
name|so_pcb
operator|=
name|unp
expr_stmt|;
name|unp
operator|->
name|unp_refcount
operator|=
literal|1
expr_stmt|;
name|UNP_LIST_LOCK
argument_list|()
expr_stmt|;
name|unp
operator|->
name|unp_gencnt
operator|=
operator|++
name|unp_gencnt
expr_stmt|;
name|unp_count
operator|++
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_DGRAM
condition|?
operator|&
name|unp_dhead
else|:
operator|&
name|unp_shead
argument_list|,
name|unp
argument_list|,
name|unp_link
argument_list|)
expr_stmt|;
name|UNP_LIST_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_bind
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|sockaddr_un
modifier|*
name|soun
init|=
operator|(
expr|struct
name|sockaddr_un
operator|*
operator|)
name|nam
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|namelen
decl_stmt|,
name|vfslocked
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_bind: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|soun
operator|->
name|sun_len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|namelen
operator|=
name|soun
operator|->
name|sun_len
operator|-
name|offsetof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|,
name|sun_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|namelen
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * We don't allow simultaneous bind() calls on a single UNIX domain 	 * socket, so flag in-progress operations, and return an error if an 	 * operation is already in progress. 	 * 	 * Historically, we have not allowed a socket to be rebound, so this 	 * also returns an error.  Not allowing re-binding simplifies the 	 * implementation and avoids a great many possible failure modes. 	 */
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_vnode
operator|!=
name|NULL
condition|)
block|{
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|unp
operator|->
name|unp_flags
operator|&
name|UNP_BINDING
condition|)
block|{
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EALREADY
operator|)
return|;
block|}
name|unp
operator|->
name|unp_flags
operator||=
name|UNP_BINDING
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|namelen
operator|+
literal|1
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|soun
operator|->
name|sun_path
argument_list|,
name|buf
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|buf
index|[
name|namelen
index|]
operator|=
literal|0
expr_stmt|;
name|restart
label|:
name|vfslocked
operator|=
literal|0
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|CREATE
argument_list|,
name|MPSAFE
operator||
name|NOFOLLOW
operator||
name|LOCKPARENT
operator||
name|SAVENAME
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|buf
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* SHOULD BE ABLE TO ADOPT EXISTING AND wakeup() ALA FIFO's */
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error
goto|;
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|vfslocked
operator|=
name|NDHASGIANT
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|NULL
operator|||
name|vn_start_write
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|,
operator|&
name|mp
argument_list|,
name|V_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|.
name|ni_dvp
operator|==
name|vp
condition|)
name|vrele
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
block|{
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EADDRINUSE
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|error
operator|=
name|vn_start_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|mp
argument_list|,
name|V_XSLEEP
operator||
name|PCATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error
goto|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|VATTR_NULL
argument_list|(
operator|&
name|vattr
argument_list|)
expr_stmt|;
name|vattr
operator|.
name|va_type
operator|=
name|VSOCK
expr_stmt|;
name|vattr
operator|.
name|va_mode
operator|=
operator|(
name|ACCESSPERMS
operator|&
operator|~
name|td
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_cmask
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_vnode_check_create
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|nd
operator|.
name|ni_dvp
argument_list|,
operator|&
name|nd
operator|.
name|ni_cnd
argument_list|,
operator|&
name|vattr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|VOP_CREATE
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|,
operator|&
name|nd
operator|.
name|ni_vp
argument_list|,
operator|&
name|nd
operator|.
name|ni_cnd
argument_list|,
operator|&
name|vattr
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|ASSERT_VOP_ELOCKED
argument_list|(
name|vp
argument_list|,
literal|"uipc_bind"
argument_list|)
expr_stmt|;
name|soun
operator|=
operator|(
expr|struct
name|sockaddr_un
operator|*
operator|)
name|sodupsockaddr
argument_list|(
name|nam
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|UNP_LINK_WLOCK
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_socket
operator|=
name|unp
operator|->
name|unp_socket
expr_stmt|;
name|unp
operator|->
name|unp_vnode
operator|=
name|vp
expr_stmt|;
name|unp
operator|->
name|unp_addr
operator|=
name|soun
expr_stmt|;
name|unp
operator|->
name|unp_flags
operator|&=
operator|~
name|UNP_BINDING
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_LINK_WUNLOCK
argument_list|()
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_flags
operator|&=
operator|~
name|UNP_BINDING
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_connect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|td
operator|==
name|curthread
argument_list|,
operator|(
literal|"uipc_connect: td != curthread"
operator|)
argument_list|)
expr_stmt|;
name|UNP_LINK_WLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|unp_connect
argument_list|(
name|so
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|UNP_LINK_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uipc_close
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_close: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|UNP_LINK_WLOCK
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|unp2
operator|!=
name|NULL
condition|)
block|{
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|unp_disconnect
argument_list|(
name|unp
argument_list|,
name|unp2
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
block|}
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_LINK_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_connect2
parameter_list|(
name|struct
name|socket
modifier|*
name|so1
parameter_list|,
name|struct
name|socket
modifier|*
name|so2
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|;
name|int
name|error
decl_stmt|;
name|UNP_LINK_WLOCK
argument_list|()
expr_stmt|;
name|unp
operator|=
name|so1
operator|->
name|so_pcb
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_connect2: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|unp2
operator|=
name|so2
operator|->
name|so_pcb
expr_stmt|;
name|KASSERT
argument_list|(
name|unp2
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_connect2: unp2 == NULL"
operator|)
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|error
operator|=
name|unp_connect2
argument_list|(
name|so1
argument_list|,
name|so2
argument_list|,
name|PRU_CONNECT2
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_LINK_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uipc_detach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|;
name|struct
name|sockaddr_un
modifier|*
name|saved_unp_addr
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|freeunp
decl_stmt|,
name|local_unp_rights
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_detach: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|UNP_LINK_WLOCK
argument_list|()
expr_stmt|;
name|UNP_LIST_LOCK
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|unp
argument_list|,
name|unp_link
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_gencnt
operator|=
operator|++
name|unp_gencnt
expr_stmt|;
operator|--
name|unp_count
expr_stmt|;
name|UNP_LIST_UNLOCK
argument_list|()
expr_stmt|;
comment|/* 	 * XXXRW: Should assert vp->v_socket == so. 	 */
if|if
condition|(
operator|(
name|vp
operator|=
name|unp
operator|->
name|unp_vnode
operator|)
operator|!=
name|NULL
condition|)
block|{
name|unp
operator|->
name|unp_vnode
operator|->
name|v_socket
operator|=
name|NULL
expr_stmt|;
name|unp
operator|->
name|unp_vnode
operator|=
name|NULL
expr_stmt|;
block|}
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|unp2
operator|!=
name|NULL
condition|)
block|{
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|unp_disconnect
argument_list|(
name|unp
argument_list|,
name|unp2
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We hold the linkage lock exclusively, so it's OK to acquire 	 * multiple pcb locks at a time. 	 */
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|unp
operator|->
name|unp_refs
argument_list|)
condition|)
block|{
name|struct
name|unpcb
modifier|*
name|ref
init|=
name|LIST_FIRST
argument_list|(
operator|&
name|unp
operator|->
name|unp_refs
argument_list|)
decl_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|unp_drop
argument_list|(
name|ref
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
name|local_unp_rights
operator|=
name|unp_rights
expr_stmt|;
name|UNP_LINK_WUNLOCK
argument_list|()
expr_stmt|;
name|unp
operator|->
name|unp_socket
operator|->
name|so_pcb
operator|=
name|NULL
expr_stmt|;
name|saved_unp_addr
operator|=
name|unp
operator|->
name|unp_addr
expr_stmt|;
name|unp
operator|->
name|unp_addr
operator|=
name|NULL
expr_stmt|;
name|unp
operator|->
name|unp_refcount
operator|--
expr_stmt|;
name|freeunp
operator|=
operator|(
name|unp
operator|->
name|unp_refcount
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|saved_unp_addr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|saved_unp_addr
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeunp
condition|)
block|{
name|UNP_PCB_LOCK_DESTROY
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|unp_zone
argument_list|,
name|unp
argument_list|)
expr_stmt|;
block|}
else|else
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
condition|)
block|{
name|int
name|vfslocked
decl_stmt|;
name|vfslocked
operator|=
name|VFS_LOCK_GIANT
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|local_unp_rights
condition|)
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|unp_gc_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_disconnect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_disconnect: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|UNP_LINK_WLOCK
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|unp2
operator|!=
name|NULL
condition|)
block|{
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|unp_disconnect
argument_list|(
name|unp
argument_list|,
name|unp2
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
block|}
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_LINK_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_listen
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|backlog
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_listen: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_vnode
operator|==
name|NULL
condition|)
block|{
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|error
operator|=
name|solisten_proto_check
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|cru2x
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
operator|&
name|unp
operator|->
name|unp_peercred
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_flags
operator||=
name|UNP_HAVEPCCACHED
expr_stmt|;
name|solisten_proto
argument_list|(
name|so
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
block|}
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_peeraddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|;
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_peeraddr: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|nam
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
argument_list|,
name|M_SONAME
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|UNP_LINK_RLOCK
argument_list|()
expr_stmt|;
comment|/* 	 * XXX: It seems that this test always fails even when connection is 	 * established.  So, this else clause is added as workaround to 	 * return PF_LOCAL sockaddr. 	 */
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|unp2
operator|!=
name|NULL
condition|)
block|{
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp2
operator|->
name|unp_addr
operator|!=
name|NULL
condition|)
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|unp2
operator|->
name|unp_addr
expr_stmt|;
else|else
name|sa
operator|=
operator|&
name|sun_noname
expr_stmt|;
name|bcopy
argument_list|(
name|sa
argument_list|,
operator|*
name|nam
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sa
operator|=
operator|&
name|sun_noname
expr_stmt|;
name|bcopy
argument_list|(
name|sa
argument_list|,
operator|*
name|nam
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
block|}
name|UNP_LINK_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_rcvd
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|;
name|struct
name|socket
modifier|*
name|so2
decl_stmt|;
name|u_int
name|mbcnt
decl_stmt|,
name|sbcc
decl_stmt|;
name|u_long
name|newhiwat
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_rcvd: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_DGRAM
condition|)
name|panic
argument_list|(
literal|"uipc_rcvd DGRAM?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_type
operator|!=
name|SOCK_STREAM
condition|)
name|panic
argument_list|(
literal|"uipc_rcvd unknown socktype"
argument_list|)
expr_stmt|;
comment|/* 	 * Adjust backpressure on sender and wakeup any waiting to write. 	 * 	 * The unp lock is acquired to maintain the validity of the unp_conn 	 * pointer; no lock on unp2 is required as unp2->unp_socket will be 	 * static as long as we don't permit unp2 to disconnect from unp, 	 * which is prevented by the lock on unp.  We cache values from 	 * so_rcv to avoid holding the so_rcv lock over the entire 	 * transaction on the remote so_snd. 	 */
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|mbcnt
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mbcnt
expr_stmt|;
name|sbcc
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|unp2
operator|==
name|NULL
condition|)
block|{
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|so2
operator|=
name|unp2
operator|->
name|unp_socket
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so2
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|so2
operator|->
name|so_snd
operator|.
name|sb_mbmax
operator|+=
name|unp
operator|->
name|unp_mbcnt
operator|-
name|mbcnt
expr_stmt|;
name|newhiwat
operator|=
name|so2
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|+
name|unp
operator|->
name|unp_cc
operator|-
name|sbcc
expr_stmt|;
operator|(
name|void
operator|)
name|chgsbsize
argument_list|(
name|so2
operator|->
name|so_cred
operator|->
name|cr_uidinfo
argument_list|,
operator|&
name|so2
operator|->
name|so_snd
operator|.
name|sb_hiwat
argument_list|,
name|newhiwat
argument_list|,
name|RLIM_INFINITY
argument_list|)
expr_stmt|;
name|sowwakeup_locked
argument_list|(
name|so2
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_mbcnt
operator|=
name|mbcnt
expr_stmt|;
name|unp
operator|->
name|unp_cc
operator|=
name|sbcc
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_send
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|;
name|struct
name|socket
modifier|*
name|so2
decl_stmt|;
name|u_int
name|mbcnt_delta
decl_stmt|,
name|sbcc
decl_stmt|;
name|u_int
name|newhiwat
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_send: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PRUS_OOB
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|control
operator|!=
name|NULL
operator|&&
operator|(
name|error
operator|=
name|unp_internalize
argument_list|(
operator|&
name|control
argument_list|,
name|td
argument_list|)
operator|)
condition|)
goto|goto
name|release
goto|;
if|if
condition|(
operator|(
name|nam
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|flags
operator|&
name|PRUS_EOF
operator|)
condition|)
name|UNP_LINK_WLOCK
argument_list|()
expr_stmt|;
else|else
name|UNP_LINK_RLOCK
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|so
operator|->
name|so_type
condition|)
block|{
case|case
name|SOCK_DGRAM
case|:
block|{
specifier|const
name|struct
name|sockaddr
modifier|*
name|from
decl_stmt|;
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|nam
operator|!=
name|NULL
condition|)
block|{
name|UNP_LINK_WLOCK_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|unp2
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|EISCONN
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|unp_connect
argument_list|(
name|so
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
block|}
comment|/* 		 * Because connect() and send() are non-atomic in a sendto() 		 * with a target address, it's possible that the socket will 		 * have disconnected before the send() can run.  In that case 		 * return the slightly counter-intuitive but otherwise 		 * correct error that the socket is not connected. 		 */
if|if
condition|(
name|unp2
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
break|break;
block|}
comment|/* Lockless read. */
if|if
condition|(
name|unp2
operator|->
name|unp_flags
operator|&
name|UNP_WANTCRED
condition|)
name|control
operator|=
name|unp_addsockcred
argument_list|(
name|td
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_addr
operator|!=
name|NULL
condition|)
name|from
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|unp
operator|->
name|unp_addr
expr_stmt|;
else|else
name|from
operator|=
operator|&
name|sun_noname
expr_stmt|;
name|so2
operator|=
name|unp2
operator|->
name|unp_socket
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so2
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbappendaddr_locked
argument_list|(
operator|&
name|so2
operator|->
name|so_rcv
argument_list|,
name|from
argument_list|,
name|m
argument_list|,
name|control
argument_list|)
condition|)
block|{
name|sorwakeup_locked
argument_list|(
name|so2
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so2
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
block|}
if|if
condition|(
name|nam
operator|!=
name|NULL
condition|)
block|{
name|UNP_LINK_WLOCK_ASSERT
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|unp_disconnect
argument_list|(
name|unp
argument_list|,
name|unp2
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
block|}
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SOCK_STREAM
case|:
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nam
operator|!=
name|NULL
condition|)
block|{
name|UNP_LINK_WLOCK_ASSERT
argument_list|()
expr_stmt|;
name|error
operator|=
name|unp_connect
argument_list|(
name|so
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* XXX */
block|}
else|else
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
break|break;
block|}
block|}
comment|/* Lockless read. */
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_state
operator|&
name|SBS_CANTSENDMORE
condition|)
block|{
name|error
operator|=
name|EPIPE
expr_stmt|;
break|break;
block|}
comment|/* 		 * Because connect() and send() are non-atomic in a sendto() 		 * with a target address, it's possible that the socket will 		 * have disconnected before the send() can run.  In that case 		 * return the slightly counter-intuitive but otherwise 		 * correct error that the socket is not connected. 		 * 		 * Locking here must be done carefully: the linkage lock 		 * prevents interconnections between unpcbs from changing, so 		 * we can traverse from unp to unp2 without acquiring unp's 		 * lock.  Socket buffer locks follow unpcb locks, so we can 		 * acquire both remote and lock socket buffer locks. 		 */
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|unp2
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
break|break;
block|}
name|so2
operator|=
name|unp2
operator|->
name|unp_socket
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so2
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp2
operator|->
name|unp_flags
operator|&
name|UNP_WANTCRED
condition|)
block|{
comment|/* 			 * Credentials are passed only once on SOCK_STREAM. 			 */
name|unp2
operator|->
name|unp_flags
operator|&=
operator|~
name|UNP_WANTCRED
expr_stmt|;
name|control
operator|=
name|unp_addsockcred
argument_list|(
name|td
argument_list|,
name|control
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Send to paired receive port, and then reduce send buffer 		 * hiwater marks to maintain backpressure.  Wake up readers. 		 */
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sbappendcontrol_locked
argument_list|(
operator|&
name|so2
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|,
name|control
argument_list|)
condition|)
name|control
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|sbappend_locked
argument_list|(
operator|&
name|so2
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|mbcnt_delta
operator|=
name|so2
operator|->
name|so_rcv
operator|.
name|sb_mbcnt
operator|-
name|unp2
operator|->
name|unp_mbcnt
expr_stmt|;
name|unp2
operator|->
name|unp_mbcnt
operator|=
name|so2
operator|->
name|so_rcv
operator|.
name|sb_mbcnt
expr_stmt|;
name|sbcc
operator|=
name|so2
operator|->
name|so_rcv
operator|.
name|sb_cc
expr_stmt|;
name|sorwakeup_locked
argument_list|(
name|so2
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|>=
call|(
name|int
call|)
argument_list|(
name|sbcc
operator|-
name|unp2
operator|->
name|unp_cc
argument_list|)
condition|)
name|newhiwat
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|-
operator|(
name|sbcc
operator|-
name|unp2
operator|->
name|unp_cc
operator|)
expr_stmt|;
else|else
name|newhiwat
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|chgsbsize
argument_list|(
name|so
operator|->
name|so_cred
operator|->
name|cr_uidinfo
argument_list|,
operator|&
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
argument_list|,
name|newhiwat
argument_list|,
name|RLIM_INFINITY
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_mbmax
operator|-=
name|mbcnt_delta
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|unp2
operator|->
name|unp_cc
operator|=
name|sbcc
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"uipc_send unknown socktype"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * PRUS_EOF is equivalent to pru_send followed by pru_shutdown. 	 */
if|if
condition|(
name|flags
operator|&
name|PRUS_EOF
condition|)
block|{
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|socantsendmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|unp_shutdown
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|nam
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|flags
operator|&
name|PRUS_EOF
operator|)
condition|)
name|UNP_LINK_WUNLOCK
argument_list|()
expr_stmt|;
else|else
name|UNP_LINK_RUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|control
operator|!=
name|NULL
operator|&&
name|error
operator|!=
literal|0
condition|)
name|unp_dispose
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|release
label|:
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_sense
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|stat
modifier|*
name|sb
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|;
name|struct
name|socket
modifier|*
name|so2
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_sense: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|sb
operator|->
name|st_blksize
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
expr_stmt|;
name|UNP_LINK_RLOCK
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_STREAM
operator|&&
name|unp2
operator|!=
name|NULL
condition|)
block|{
name|so2
operator|=
name|unp2
operator|->
name|unp_socket
expr_stmt|;
name|sb
operator|->
name|st_blksize
operator|+=
name|so2
operator|->
name|so_rcv
operator|.
name|sb_cc
expr_stmt|;
block|}
name|sb
operator|->
name|st_dev
operator|=
name|NODEV
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_ino
operator|==
literal|0
condition|)
name|unp
operator|->
name|unp_ino
operator|=
operator|(
operator|++
name|unp_ino
operator|==
literal|0
operator|)
condition|?
operator|++
name|unp_ino
else|:
name|unp_ino
expr_stmt|;
name|sb
operator|->
name|st_ino
operator|=
name|unp
operator|->
name|unp_ino
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_LINK_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_shutdown
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_shutdown: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|UNP_LINK_WLOCK
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|socantsendmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|unp_shutdown
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_LINK_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_sockaddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_sockaddr: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|nam
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
argument_list|,
name|M_SONAME
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_addr
operator|!=
name|NULL
condition|)
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|unp
operator|->
name|unp_addr
expr_stmt|;
else|else
name|sa
operator|=
operator|&
name|sun_noname
expr_stmt|;
name|bcopy
argument_list|(
name|sa
argument_list|,
operator|*
name|nam
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|pr_usrreqs
name|uipc_usrreqs_dgram
init|=
block|{
operator|.
name|pru_abort
operator|=
name|uipc_abort
block|,
operator|.
name|pru_accept
operator|=
name|uipc_accept
block|,
operator|.
name|pru_attach
operator|=
name|uipc_attach
block|,
operator|.
name|pru_bind
operator|=
name|uipc_bind
block|,
operator|.
name|pru_connect
operator|=
name|uipc_connect
block|,
operator|.
name|pru_connect2
operator|=
name|uipc_connect2
block|,
operator|.
name|pru_detach
operator|=
name|uipc_detach
block|,
operator|.
name|pru_disconnect
operator|=
name|uipc_disconnect
block|,
operator|.
name|pru_listen
operator|=
name|uipc_listen
block|,
operator|.
name|pru_peeraddr
operator|=
name|uipc_peeraddr
block|,
operator|.
name|pru_rcvd
operator|=
name|uipc_rcvd
block|,
operator|.
name|pru_send
operator|=
name|uipc_send
block|,
operator|.
name|pru_sense
operator|=
name|uipc_sense
block|,
operator|.
name|pru_shutdown
operator|=
name|uipc_shutdown
block|,
operator|.
name|pru_sockaddr
operator|=
name|uipc_sockaddr
block|,
operator|.
name|pru_soreceive
operator|=
name|soreceive_dgram
block|,
operator|.
name|pru_close
operator|=
name|uipc_close
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pr_usrreqs
name|uipc_usrreqs_stream
init|=
block|{
operator|.
name|pru_abort
operator|=
name|uipc_abort
block|,
operator|.
name|pru_accept
operator|=
name|uipc_accept
block|,
operator|.
name|pru_attach
operator|=
name|uipc_attach
block|,
operator|.
name|pru_bind
operator|=
name|uipc_bind
block|,
operator|.
name|pru_connect
operator|=
name|uipc_connect
block|,
operator|.
name|pru_connect2
operator|=
name|uipc_connect2
block|,
operator|.
name|pru_detach
operator|=
name|uipc_detach
block|,
operator|.
name|pru_disconnect
operator|=
name|uipc_disconnect
block|,
operator|.
name|pru_listen
operator|=
name|uipc_listen
block|,
operator|.
name|pru_peeraddr
operator|=
name|uipc_peeraddr
block|,
operator|.
name|pru_rcvd
operator|=
name|uipc_rcvd
block|,
operator|.
name|pru_send
operator|=
name|uipc_send
block|,
operator|.
name|pru_sense
operator|=
name|uipc_sense
block|,
operator|.
name|pru_shutdown
operator|=
name|uipc_shutdown
block|,
operator|.
name|pru_sockaddr
operator|=
name|uipc_sockaddr
block|,
operator|.
name|pru_soreceive
operator|=
name|soreceive_generic
block|,
operator|.
name|pru_close
operator|=
name|uipc_close
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|uipc_ctloutput
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|struct
name|xucred
name|xu
decl_stmt|;
name|int
name|error
decl_stmt|,
name|optval
decl_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_level
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_ctloutput: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_dir
condition|)
block|{
case|case
name|SOPT_GET
case|:
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|LOCAL_PEERCRED
case|:
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_flags
operator|&
name|UNP_HAVEPC
condition|)
name|xu
operator|=
name|unp
operator|->
name|unp_peercred
expr_stmt|;
else|else
block|{
if|if
condition|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_STREAM
condition|)
name|error
operator|=
name|ENOTCONN
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|xu
argument_list|,
sizeof|sizeof
argument_list|(
name|xu
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCAL_CREDS
case|:
comment|/* Unlocked read. */
name|optval
operator|=
name|unp
operator|->
name|unp_flags
operator|&
name|UNP_WANTCRED
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCAL_CONNWAIT
case|:
comment|/* Unlocked read. */
name|optval
operator|=
name|unp
operator|->
name|unp_flags
operator|&
name|UNP_CONNWAIT
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SOPT_SET
case|:
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|LOCAL_CREDS
case|:
case|case
name|LOCAL_CONNWAIT
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
define|#
directive|define
name|OPTSET
parameter_list|(
name|bit
parameter_list|)
value|do {						\ 	UNP_PCB_LOCK(unp);						\ 	if (optval)							\ 		unp->unp_flags |= bit;					\ 	else								\ 		unp->unp_flags&= ~bit;					\ 	UNP_PCB_UNLOCK(unp);						\ } while (0)
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|LOCAL_CREDS
case|:
name|OPTSET
argument_list|(
name|UNP_WANTCRED
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCAL_CONNWAIT
case|:
name|OPTSET
argument_list|(
name|UNP_CONNWAIT
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
undef|#
directive|undef
name|OPTSET
default|default:
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unp_connect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|sockaddr_un
modifier|*
name|soun
init|=
operator|(
expr|struct
name|sockaddr_un
operator|*
operator|)
name|nam
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so2
decl_stmt|,
modifier|*
name|so3
decl_stmt|;
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|,
modifier|*
name|unp3
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|,
name|vfslocked
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|char
name|buf
index|[
name|SOCK_MAXADDRLEN
index|]
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|UNP_LINK_WLOCK_ASSERT
argument_list|()
expr_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"unp_connect: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nam
operator|->
name|sa_len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|len
operator|=
name|nam
operator|->
name|sa_len
operator|-
name|offsetof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|,
name|sun_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bcopy
argument_list|(
name|soun
operator|->
name|sun_path
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_flags
operator|&
name|UNP_CONNECTING
condition|)
block|{
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EALREADY
operator|)
return|;
block|}
name|UNP_LINK_WUNLOCK
argument_list|()
expr_stmt|;
name|unp
operator|->
name|unp_flags
operator||=
name|UNP_CONNECTING
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|sa
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
argument_list|,
name|M_SONAME
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|MPSAFE
operator||
name|FOLLOW
operator||
name|LOCKSHARED
operator||
name|LOCKLEAF
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|buf
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|vp
operator|=
name|NULL
expr_stmt|;
else|else
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|vp
argument_list|,
literal|"unp_connect"
argument_list|)
expr_stmt|;
name|vfslocked
operator|=
name|NDHASGIANT
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VSOCK
condition|)
block|{
name|error
operator|=
name|ENOTSOCK
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_vnode_check_open
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|vp
argument_list|,
name|VWRITE
operator||
name|VREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
endif|#
directive|endif
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VWRITE
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"unp_connect: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Lock linkage lock for two reasons: make sure v_socket is stable, 	 * and to protect simultaneous locking of multiple pcbs. 	 */
name|UNP_LINK_WLOCK
argument_list|()
expr_stmt|;
name|so2
operator|=
name|vp
operator|->
name|v_socket
expr_stmt|;
if|if
condition|(
name|so2
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ECONNREFUSED
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
if|if
condition|(
name|so
operator|->
name|so_type
operator|!=
name|so2
operator|->
name|so_type
condition|)
block|{
name|error
operator|=
name|EPROTOTYPE
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
condition|)
block|{
if|if
condition|(
name|so2
operator|->
name|so_options
operator|&
name|SO_ACCEPTCONN
condition|)
block|{
name|CURVNET_SET
argument_list|(
name|so2
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
name|so3
operator|=
name|sonewconn
argument_list|(
name|so2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
else|else
name|so3
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|so3
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ECONNREFUSED
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|unp2
operator|=
name|sotounpcb
argument_list|(
name|so2
argument_list|)
expr_stmt|;
name|unp3
operator|=
name|sotounpcb
argument_list|(
name|so3
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp3
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp2
operator|->
name|unp_addr
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|unp2
operator|->
name|unp_addr
argument_list|,
name|sa
argument_list|,
name|unp2
operator|->
name|unp_addr
operator|->
name|sun_len
argument_list|)
expr_stmt|;
name|unp3
operator|->
name|unp_addr
operator|=
operator|(
expr|struct
name|sockaddr_un
operator|*
operator|)
name|sa
expr_stmt|;
name|sa
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * The connecter's (client's) credentials are copied from its 		 * process structure at the time of connect() (which is now). 		 */
name|cru2x
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
operator|&
name|unp3
operator|->
name|unp_peercred
argument_list|)
expr_stmt|;
name|unp3
operator|->
name|unp_flags
operator||=
name|UNP_HAVEPC
expr_stmt|;
comment|/* 		 * The receiver's (server's) credentials are copied from the 		 * unp_peercred member of socket on which the former called 		 * listen(); uipc_listen() cached that process's credentials 		 * at that time so we can use them now. 		 */
name|KASSERT
argument_list|(
name|unp2
operator|->
name|unp_flags
operator|&
name|UNP_HAVEPCCACHED
argument_list|,
operator|(
literal|"unp_connect: listener without cached peercred"
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|unp
operator|->
name|unp_peercred
argument_list|,
operator|&
name|unp2
operator|->
name|unp_peercred
argument_list|,
sizeof|sizeof
argument_list|(
name|unp
operator|->
name|unp_peercred
argument_list|)
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_flags
operator||=
name|UNP_HAVEPC
expr_stmt|;
if|if
condition|(
name|unp2
operator|->
name|unp_flags
operator|&
name|UNP_WANTCRED
condition|)
name|unp3
operator|->
name|unp_flags
operator||=
name|UNP_WANTCRED
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp3
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_socketpeer_set_from_socket
argument_list|(
name|so
argument_list|,
name|so3
argument_list|)
expr_stmt|;
name|mac_socketpeer_set_from_socket
argument_list|(
name|so3
argument_list|,
name|so
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|so2
operator|=
name|so3
expr_stmt|;
block|}
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"unp_connect: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|unp2
operator|=
name|sotounpcb
argument_list|(
name|so2
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp2
operator|!=
name|NULL
argument_list|,
operator|(
literal|"unp_connect: unp2 == NULL"
operator|)
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|error
operator|=
name|unp_connect2
argument_list|(
name|so
argument_list|,
name|so2
argument_list|,
name|PRU_CONNECT
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|bad2
label|:
name|UNP_LINK_WUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|vfslocked
condition|)
comment|/*  		 * Giant has been previously acquired. This means filesystem 		 * isn't MPSAFE.  Do it once again. 		 */
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|bad
label|:
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sa
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|UNP_LINK_WLOCK
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_flags
operator|&=
operator|~
name|UNP_CONNECTING
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unp_connect2
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|socket
modifier|*
name|so2
parameter_list|,
name|int
name|req
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|struct
name|unpcb
modifier|*
name|unp2
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"unp_connect2: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|unp2
operator|=
name|sotounpcb
argument_list|(
name|so2
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp2
operator|!=
name|NULL
argument_list|,
operator|(
literal|"unp_connect2: unp2 == NULL"
operator|)
argument_list|)
expr_stmt|;
name|UNP_LINK_WLOCK_ASSERT
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK_ASSERT
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK_ASSERT
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|so2
operator|->
name|so_type
operator|!=
name|so
operator|->
name|so_type
condition|)
return|return
operator|(
name|EPROTOTYPE
operator|)
return|;
name|unp
operator|->
name|unp_conn
operator|=
name|unp2
expr_stmt|;
switch|switch
condition|(
name|so
operator|->
name|so_type
condition|)
block|{
case|case
name|SOCK_DGRAM
case|:
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|unp2
operator|->
name|unp_refs
argument_list|,
name|unp
argument_list|,
name|unp_reflink
argument_list|)
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
break|break;
case|case
name|SOCK_STREAM
case|:
name|unp2
operator|->
name|unp_conn
operator|=
name|unp
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|PRU_CONNECT
operator|&&
operator|(
operator|(
name|unp
operator|->
name|unp_flags
operator||
name|unp2
operator|->
name|unp_flags
operator|)
operator|&
name|UNP_CONNWAIT
operator|)
condition|)
name|soisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
else|else
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|soisconnected
argument_list|(
name|so2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"unp_connect2"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unp_disconnect
parameter_list|(
name|struct
name|unpcb
modifier|*
name|unp
parameter_list|,
name|struct
name|unpcb
modifier|*
name|unp2
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|KASSERT
argument_list|(
name|unp2
operator|!=
name|NULL
argument_list|,
operator|(
literal|"unp_disconnect: unp2 == NULL"
operator|)
argument_list|)
expr_stmt|;
name|UNP_LINK_WLOCK_ASSERT
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK_ASSERT
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK_ASSERT
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_conn
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|unp
operator|->
name|unp_socket
operator|->
name|so_type
condition|)
block|{
case|case
name|SOCK_DGRAM
case|:
name|LIST_REMOVE
argument_list|(
name|unp
argument_list|,
name|unp_reflink
argument_list|)
expr_stmt|;
name|so
operator|=
name|unp
operator|->
name|unp_socket
expr_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_state
operator|&=
operator|~
name|SS_ISCONNECTED
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
break|break;
case|case
name|SOCK_STREAM
case|:
name|soisdisconnected
argument_list|(
name|unp
operator|->
name|unp_socket
argument_list|)
expr_stmt|;
name|unp2
operator|->
name|unp_conn
operator|=
name|NULL
expr_stmt|;
name|soisdisconnected
argument_list|(
name|unp2
operator|->
name|unp_socket
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * unp_pcblist() walks the global list of struct unpcb's to generate a  * pointer list, bumping the refcount on each unpcb.  It then copies them out  * sequentially, validating the generation number on each to see if it has  * been detached.  All of this is necessary because copyout() may sleep on  * disk I/O.  */
end_comment

begin_function
specifier|static
name|int
name|unp_pcblist
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
name|int
name|freeunp
decl_stmt|;
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
modifier|*
name|unp_list
decl_stmt|;
name|unp_gen_t
name|gencnt
decl_stmt|;
name|struct
name|xunpgen
modifier|*
name|xug
decl_stmt|;
name|struct
name|unp_head
modifier|*
name|head
decl_stmt|;
name|struct
name|xunpcb
modifier|*
name|xu
decl_stmt|;
name|head
operator|=
operator|(
operator|(
name|intptr_t
operator|)
name|arg1
operator|==
name|SOCK_DGRAM
condition|?
operator|&
name|unp_dhead
else|:
operator|&
name|unp_shead
operator|)
expr_stmt|;
comment|/* 	 * The process of preparing the PCB list is too time-consuming and 	 * resource-intensive to repeat twice on every request. 	 */
if|if
condition|(
name|req
operator|->
name|oldptr
operator|==
name|NULL
condition|)
block|{
name|n
operator|=
name|unp_count
expr_stmt|;
name|req
operator|->
name|oldidx
operator|=
literal|2
operator|*
operator|(
sizeof|sizeof
expr|*
name|xug
operator|)
operator|+
operator|(
name|n
operator|+
name|n
operator|/
literal|8
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|xunpcb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* 	 * OK, now we're committed to doing something. 	 */
name|xug
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|xug
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|UNP_LIST_LOCK
argument_list|()
expr_stmt|;
name|gencnt
operator|=
name|unp_gencnt
expr_stmt|;
name|n
operator|=
name|unp_count
expr_stmt|;
name|UNP_LIST_UNLOCK
argument_list|()
expr_stmt|;
name|xug
operator|->
name|xug_len
operator|=
sizeof|sizeof
expr|*
name|xug
expr_stmt|;
name|xug
operator|->
name|xug_count
operator|=
name|n
expr_stmt|;
name|xug
operator|->
name|xug_gen
operator|=
name|gencnt
expr_stmt|;
name|xug
operator|->
name|xug_sogen
operator|=
name|so_gencnt
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|xug
argument_list|,
sizeof|sizeof
expr|*
name|xug
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|xug
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|unp_list
operator|=
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
expr|*
name|unp_list
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|UNP_LIST_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|unp
operator|=
name|LIST_FIRST
argument_list|(
name|head
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|unp
operator|&&
name|i
operator|<
name|n
condition|;
name|unp
operator|=
name|LIST_NEXT
argument_list|(
name|unp
argument_list|,
name|unp_link
argument_list|)
control|)
block|{
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_gencnt
operator|<=
name|gencnt
condition|)
block|{
if|if
condition|(
name|cr_cansee
argument_list|(
name|req
operator|->
name|td
operator|->
name|td_ucred
argument_list|,
name|unp
operator|->
name|unp_socket
operator|->
name|so_cred
argument_list|)
condition|)
block|{
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|unp_list
index|[
name|i
operator|++
index|]
operator|=
name|unp
expr_stmt|;
name|unp
operator|->
name|unp_refcount
operator|++
expr_stmt|;
block|}
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
block|}
name|UNP_LIST_UNLOCK
argument_list|()
expr_stmt|;
name|n
operator|=
name|i
expr_stmt|;
comment|/* In case we lost some during malloc. */
name|error
operator|=
literal|0
expr_stmt|;
name|xu
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|xu
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|unp
operator|=
name|unp_list
index|[
name|i
index|]
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_refcount
operator|--
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_refcount
operator|!=
literal|0
operator|&&
name|unp
operator|->
name|unp_gencnt
operator|<=
name|gencnt
condition|)
block|{
name|xu
operator|->
name|xu_len
operator|=
sizeof|sizeof
expr|*
name|xu
expr_stmt|;
name|xu
operator|->
name|xu_unpp
operator|=
name|unp
expr_stmt|;
comment|/* 			 * XXX - need more locking here to protect against 			 * connect/disconnect races for SMP. 			 */
if|if
condition|(
name|unp
operator|->
name|unp_addr
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|unp
operator|->
name|unp_addr
argument_list|,
operator|&
name|xu
operator|->
name|xu_addr
argument_list|,
name|unp
operator|->
name|unp_addr
operator|->
name|sun_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_conn
operator|!=
name|NULL
operator|&&
name|unp
operator|->
name|unp_conn
operator|->
name|unp_addr
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|unp
operator|->
name|unp_conn
operator|->
name|unp_addr
argument_list|,
operator|&
name|xu
operator|->
name|xu_caddr
argument_list|,
name|unp
operator|->
name|unp_conn
operator|->
name|unp_addr
operator|->
name|sun_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|unp
argument_list|,
operator|&
name|xu
operator|->
name|xu_unp
argument_list|,
sizeof|sizeof
expr|*
name|unp
argument_list|)
expr_stmt|;
name|sotoxsocket
argument_list|(
name|unp
operator|->
name|unp_socket
argument_list|,
operator|&
name|xu
operator|->
name|xu_socket
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|xu
argument_list|,
sizeof|sizeof
expr|*
name|xu
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|freeunp
operator|=
operator|(
name|unp
operator|->
name|unp_refcount
operator|==
literal|0
operator|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeunp
condition|)
block|{
name|UNP_PCB_LOCK_DESTROY
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|unp_zone
argument_list|,
name|unp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|xu
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* 		 * Give the user an updated idea of our state.  If the 		 * generation differs from what we told her before, she knows 		 * that something happened while we were processing this 		 * request, and it might be necessary to retry. 		 */
name|xug
operator|->
name|xug_gen
operator|=
name|unp_gencnt
expr_stmt|;
name|xug
operator|->
name|xug_sogen
operator|=
name|so_gencnt
expr_stmt|;
name|xug
operator|->
name|xug_count
operator|=
name|unp_count
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|xug
argument_list|,
sizeof|sizeof
expr|*
name|xug
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|unp_list
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xug
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_local_dgram
argument_list|,
name|OID_AUTO
argument_list|,
name|pcblist
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|long
operator|)
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|,
name|unp_pcblist
argument_list|,
literal|"S,xunpcb"
argument_list|,
literal|"List of active local datagram sockets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_local_stream
argument_list|,
name|OID_AUTO
argument_list|,
name|pcblist
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|long
operator|)
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
name|unp_pcblist
argument_list|,
literal|"S,xunpcb"
argument_list|,
literal|"List of active local stream sockets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|unp_shutdown
parameter_list|(
name|struct
name|unpcb
modifier|*
name|unp
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp2
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|UNP_LINK_WLOCK_ASSERT
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK_ASSERT
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_socket
operator|->
name|so_type
operator|==
name|SOCK_STREAM
operator|&&
name|unp2
operator|!=
name|NULL
condition|)
block|{
name|so
operator|=
name|unp2
operator|->
name|unp_socket
expr_stmt|;
if|if
condition|(
name|so
operator|!=
name|NULL
condition|)
name|socantrcvmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|unp_drop
parameter_list|(
name|struct
name|unpcb
modifier|*
name|unp
parameter_list|,
name|int
name|errno
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|unp
operator|->
name|unp_socket
decl_stmt|;
name|struct
name|unpcb
modifier|*
name|unp2
decl_stmt|;
name|UNP_LINK_WLOCK_ASSERT
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK_ASSERT
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
name|errno
expr_stmt|;
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|unp2
operator|==
name|NULL
condition|)
return|return;
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|unp_disconnect
argument_list|(
name|unp
argument_list|,
name|unp2
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unp_freerights
parameter_list|(
name|struct
name|file
modifier|*
modifier|*
name|rp
parameter_list|,
name|int
name|fdcount
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fdcount
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|*
name|rp
expr_stmt|;
operator|*
name|rp
operator|++
operator|=
name|NULL
expr_stmt|;
name|unp_discard
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|unp_externalize
parameter_list|(
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|controlp
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
comment|/* XXX */
name|struct
name|cmsghdr
modifier|*
name|cm
init|=
name|mtod
argument_list|(
name|control
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|fdp
decl_stmt|;
name|struct
name|file
modifier|*
modifier|*
name|rp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|socklen_t
name|clen
init|=
name|control
operator|->
name|m_len
decl_stmt|,
name|datalen
decl_stmt|;
name|int
name|error
decl_stmt|,
name|newfds
decl_stmt|;
name|int
name|f
decl_stmt|;
name|u_int
name|newlen
decl_stmt|;
name|UNP_LINK_UNLOCK_ASSERT
argument_list|()
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
comment|/* controlp == NULL => free control messages */
operator|*
name|controlp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|cm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
operator|*
name|cm
argument_list|)
operator|>
name|clen
operator|||
name|cm
operator|->
name|cmsg_len
operator|>
name|clen
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|data
operator|=
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|datalen
operator|=
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|cm
operator|->
name|cmsg_len
operator|-
operator|(
name|caddr_t
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cmsg_level
operator|==
name|SOL_SOCKET
operator|&&
name|cm
operator|->
name|cmsg_type
operator|==
name|SCM_RIGHTS
condition|)
block|{
name|newfds
operator|=
name|datalen
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|file
operator|*
argument_list|)
expr_stmt|;
name|rp
operator|=
name|data
expr_stmt|;
comment|/* If we're not outputting the descriptors free them. */
if|if
condition|(
name|error
operator|||
name|controlp
operator|==
name|NULL
condition|)
block|{
name|unp_freerights
argument_list|(
name|rp
argument_list|,
name|newfds
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|FILEDESC_XLOCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
comment|/* if the new FD's will not fit free them.  */
if|if
condition|(
operator|!
name|fdavail
argument_list|(
name|td
argument_list|,
name|newfds
argument_list|)
condition|)
block|{
name|FILEDESC_XUNLOCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
name|unp_freerights
argument_list|(
name|rp
argument_list|,
name|newfds
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* 			 * Now change each pointer to an fd in the global 			 * table to an integer that is the index to the local 			 * fd table entry that we set up to point to the 			 * global one we are transferring. 			 */
name|newlen
operator|=
name|newfds
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|*
name|controlp
operator|=
name|sbcreatecontrol
argument_list|(
name|NULL
argument_list|,
name|newlen
argument_list|,
name|SCM_RIGHTS
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|controlp
operator|==
name|NULL
condition|)
block|{
name|FILEDESC_XUNLOCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
name|error
operator|=
name|E2BIG
expr_stmt|;
name|unp_freerights
argument_list|(
name|rp
argument_list|,
name|newfds
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|fdp
operator|=
operator|(
name|int
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|mtod
argument_list|(
operator|*
name|controlp
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|newfds
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fdalloc
argument_list|(
name|td
argument_list|,
literal|0
argument_list|,
operator|&
name|f
argument_list|)
condition|)
name|panic
argument_list|(
literal|"unp_externalize fdalloc failed"
argument_list|)
expr_stmt|;
name|fp
operator|=
operator|*
name|rp
operator|++
expr_stmt|;
name|td
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_ofiles
index|[
name|f
index|]
operator|=
name|fp
expr_stmt|;
name|unp_externalize_fp
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|*
name|fdp
operator|++
operator|=
name|f
expr_stmt|;
block|}
name|FILEDESC_XUNLOCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We can just copy anything else across. */
if|if
condition|(
name|error
operator|||
name|controlp
operator|==
name|NULL
condition|)
goto|goto
name|next
goto|;
operator|*
name|controlp
operator|=
name|sbcreatecontrol
argument_list|(
name|NULL
argument_list|,
name|datalen
argument_list|,
name|cm
operator|->
name|cmsg_type
argument_list|,
name|cm
operator|->
name|cmsg_level
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|controlp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|bcopy
argument_list|(
name|data
argument_list|,
name|CMSG_DATA
argument_list|(
name|mtod
argument_list|(
operator|*
name|controlp
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
name|controlp
operator|=
operator|&
operator|(
operator|*
name|controlp
operator|)
operator|->
name|m_next
expr_stmt|;
name|next
label|:
if|if
condition|(
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|<
name|clen
condition|)
block|{
name|clen
operator|-=
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
expr_stmt|;
name|cm
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|clen
operator|=
literal|0
expr_stmt|;
name|cm
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unp_zone_change
parameter_list|(
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|uma_zone_set_max
argument_list|(
name|unp_zone
argument_list|,
name|maxsockets
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unp_init
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|VIMAGE
if|if
condition|(
operator|!
name|IS_DEFAULT_VNET
argument_list|(
name|curvnet
argument_list|)
condition|)
return|return;
endif|#
directive|endif
name|unp_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"unpcb"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unpcb
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp_zone
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"unp_init"
argument_list|)
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|unp_zone
argument_list|,
name|maxsockets
argument_list|)
expr_stmt|;
name|EVENTHANDLER_REGISTER
argument_list|(
name|maxsockets_change
argument_list|,
name|unp_zone_change
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|unp_dhead
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|unp_shead
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|unp_defers
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|unp_gc_task
argument_list|,
literal|0
argument_list|,
name|unp_gc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|unp_defer_task
argument_list|,
literal|0
argument_list|,
name|unp_process_defers
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|UNP_LINK_LOCK_INIT
argument_list|()
expr_stmt|;
name|UNP_LIST_LOCK_INIT
argument_list|()
expr_stmt|;
name|UNP_DEFERRED_LOCK_INIT
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|unp_internalize
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|controlp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|control
init|=
operator|*
name|controlp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|filedesc
modifier|*
name|fdescp
init|=
name|p
operator|->
name|p_fd
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cm
init|=
name|mtod
argument_list|(
name|control
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
decl_stmt|;
name|struct
name|cmsgcred
modifier|*
name|cmcred
decl_stmt|;
name|struct
name|file
modifier|*
modifier|*
name|rp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tv
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|,
modifier|*
name|fdp
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|socklen_t
name|clen
init|=
name|control
operator|->
name|m_len
decl_stmt|,
name|datalen
decl_stmt|;
name|int
name|error
decl_stmt|,
name|oldfds
decl_stmt|;
name|u_int
name|newlen
decl_stmt|;
name|UNP_LINK_UNLOCK_ASSERT
argument_list|()
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
operator|*
name|controlp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|cm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
operator|*
name|cm
argument_list|)
operator|>
name|clen
operator|||
name|cm
operator|->
name|cmsg_level
operator|!=
name|SOL_SOCKET
operator|||
name|cm
operator|->
name|cmsg_len
operator|>
name|clen
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|data
operator|=
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|datalen
operator|=
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|cm
operator|->
name|cmsg_len
operator|-
operator|(
name|caddr_t
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|cm
operator|->
name|cmsg_type
condition|)
block|{
comment|/* 		 * Fill in credential information. 		 */
case|case
name|SCM_CREDS
case|:
operator|*
name|controlp
operator|=
name|sbcreatecontrol
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cmcred
argument_list|)
argument_list|,
name|SCM_CREDS
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|controlp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cmcred
operator|=
operator|(
expr|struct
name|cmsgcred
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|mtod
argument_list|(
operator|*
name|controlp
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|cmcred
operator|->
name|cmcred_pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|cmcred
operator|->
name|cmcred_uid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_ruid
expr_stmt|;
name|cmcred
operator|->
name|cmcred_gid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_rgid
expr_stmt|;
name|cmcred
operator|->
name|cmcred_euid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_uid
expr_stmt|;
name|cmcred
operator|->
name|cmcred_ngroups
operator|=
name|MIN
argument_list|(
name|td
operator|->
name|td_ucred
operator|->
name|cr_ngroups
argument_list|,
name|CMGROUP_MAX
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmcred
operator|->
name|cmcred_ngroups
condition|;
name|i
operator|++
control|)
name|cmcred
operator|->
name|cmcred_groups
index|[
name|i
index|]
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_groups
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|SCM_RIGHTS
case|:
name|oldfds
operator|=
name|datalen
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/* 			 * Check that all the FDs passed in refer to legal 			 * files.  If not, reject the entire operation. 			 */
name|fdp
operator|=
name|data
expr_stmt|;
name|FILEDESC_SLOCK
argument_list|(
name|fdescp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldfds
condition|;
name|i
operator|++
control|)
block|{
name|fd
operator|=
operator|*
name|fdp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|fd
operator|>=
name|fdescp
operator|->
name|fd_nfiles
operator|||
name|fdescp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
operator|==
name|NULL
condition|)
block|{
name|FILEDESC_SUNLOCK
argument_list|(
name|fdescp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBADF
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fp
operator|=
name|fdescp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|f_ops
operator|->
name|fo_flags
operator|&
name|DFLAG_PASSABLE
operator|)
condition|)
block|{
name|FILEDESC_SUNLOCK
argument_list|(
name|fdescp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 			 * Now replace the integer FDs with pointers to the 			 * associated global file table entry.. 			 */
name|newlen
operator|=
name|oldfds
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|file
operator|*
argument_list|)
expr_stmt|;
operator|*
name|controlp
operator|=
name|sbcreatecontrol
argument_list|(
name|NULL
argument_list|,
name|newlen
argument_list|,
name|SCM_RIGHTS
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|controlp
operator|==
name|NULL
condition|)
block|{
name|FILEDESC_SUNLOCK
argument_list|(
name|fdescp
argument_list|)
expr_stmt|;
name|error
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fdp
operator|=
name|data
expr_stmt|;
name|rp
operator|=
operator|(
expr|struct
name|file
operator|*
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|mtod
argument_list|(
operator|*
name|controlp
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldfds
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
name|fdescp
operator|->
name|fd_ofiles
index|[
operator|*
name|fdp
operator|++
index|]
expr_stmt|;
operator|*
name|rp
operator|++
operator|=
name|fp
expr_stmt|;
name|unp_internalize_fp
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|FILEDESC_SUNLOCK
argument_list|(
name|fdescp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCM_TIMESTAMP
case|:
operator|*
name|controlp
operator|=
name|sbcreatecontrol
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tv
argument_list|)
argument_list|,
name|SCM_TIMESTAMP
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|controlp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|tv
operator|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|mtod
argument_list|(
operator|*
name|controlp
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
name|tv
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|controlp
operator|=
operator|&
operator|(
operator|*
name|controlp
operator|)
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|<
name|clen
condition|)
block|{
name|clen
operator|-=
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
expr_stmt|;
name|cm
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|clen
operator|=
literal|0
expr_stmt|;
name|cm
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|out
label|:
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|unp_addsockcred
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|,
modifier|*
name|n_prev
decl_stmt|;
name|struct
name|sockcred
modifier|*
name|sc
decl_stmt|;
specifier|const
name|struct
name|cmsghdr
modifier|*
name|cm
decl_stmt|;
name|int
name|ngroups
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ngroups
operator|=
name|MIN
argument_list|(
name|td
operator|->
name|td_ucred
operator|->
name|cr_ngroups
argument_list|,
name|CMGROUP_MAX
argument_list|)
expr_stmt|;
name|m
operator|=
name|sbcreatecontrol
argument_list|(
name|NULL
argument_list|,
name|SOCKCREDSIZE
argument_list|(
name|ngroups
argument_list|)
argument_list|,
name|SCM_CREDS
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|control
operator|)
return|;
name|sc
operator|=
operator|(
expr|struct
name|sockcred
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_uid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_ruid
expr_stmt|;
name|sc
operator|->
name|sc_euid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_uid
expr_stmt|;
name|sc
operator|->
name|sc_gid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_rgid
expr_stmt|;
name|sc
operator|->
name|sc_egid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_gid
expr_stmt|;
name|sc
operator|->
name|sc_ngroups
operator|=
name|ngroups
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_ngroups
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|sc_groups
index|[
name|i
index|]
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_groups
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * Unlink SCM_CREDS control messages (struct cmsgcred), since just 	 * created SCM_CREDS control message (struct sockcred) has another 	 * format. 	 */
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
for|for
control|(
name|n
operator|=
name|control
operator|,
name|n_prev
operator|=
name|NULL
init|;
name|n
operator|!=
name|NULL
condition|;
control|)
block|{
name|cm
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cmsg_level
operator|==
name|SOL_SOCKET
operator|&&
name|cm
operator|->
name|cmsg_type
operator|==
name|SCM_CREDS
condition|)
block|{
if|if
condition|(
name|n_prev
operator|==
name|NULL
condition|)
name|control
operator|=
name|n
operator|->
name|m_next
expr_stmt|;
else|else
name|n_prev
operator|->
name|m_next
operator|=
name|n
operator|->
name|m_next
expr_stmt|;
name|n
operator|=
name|m_free
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n_prev
operator|=
name|n
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|m_next
expr_stmt|;
block|}
block|}
comment|/* Prepend it to the head. */
name|m
operator|->
name|m_next
operator|=
name|control
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|unpcb
modifier|*
name|fptounp
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_type
operator|!=
name|DTYPE_SOCKET
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|so
operator|=
name|fp
operator|->
name|f_data
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|!=
operator|&
name|localdomain
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
name|sotounpcb
argument_list|(
name|so
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unp_discard
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|unp_defer
modifier|*
name|dr
decl_stmt|;
if|if
condition|(
name|unp_externalize_fp
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|dr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dr
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|dr
operator|->
name|ud_fp
operator|=
name|fp
expr_stmt|;
name|UNP_DEFERRED_LOCK
argument_list|()
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|unp_defers
argument_list|,
name|dr
argument_list|,
name|ud_link
argument_list|)
expr_stmt|;
name|UNP_DEFERRED_UNLOCK
argument_list|()
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|unp_defers_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|unp_defer_task
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|closef
argument_list|(
name|fp
argument_list|,
operator|(
expr|struct
name|thread
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unp_process_defers
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|unp_defer
modifier|*
name|dr
decl_stmt|;
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|unp_defer
argument_list|)
name|drl
expr_stmt|;
name|int
name|count
decl_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|drl
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|UNP_DEFERRED_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|SLIST_FIRST
argument_list|(
operator|&
name|unp_defers
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|UNP_DEFERRED_UNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
name|SLIST_SWAP
argument_list|(
operator|&
name|unp_defers
argument_list|,
operator|&
name|drl
argument_list|,
name|unp_defer
argument_list|)
expr_stmt|;
name|UNP_DEFERRED_UNLOCK
argument_list|()
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|dr
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|drl
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|drl
argument_list|,
name|ud_link
argument_list|)
expr_stmt|;
name|closef
argument_list|(
name|dr
operator|->
name|ud_fp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|unp_defers_count
argument_list|,
operator|-
name|count
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|unp_internalize_fp
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|UNP_LINK_WLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|unp
operator|=
name|fptounp
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|unp
operator|->
name|unp_file
operator|=
name|fp
expr_stmt|;
name|unp
operator|->
name|unp_msgcount
operator|++
expr_stmt|;
block|}
name|fhold
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|unp_rights
operator|++
expr_stmt|;
name|UNP_LINK_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|unp_externalize_fp
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|UNP_LINK_WLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|unp
operator|=
name|fptounp
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|unp
operator|->
name|unp_msgcount
operator|--
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|ret
operator|=
literal|0
expr_stmt|;
name|unp_rights
operator|--
expr_stmt|;
name|UNP_LINK_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * unp_defer indicates whether additional work has been defered for a future  * pass through unp_gc().  It is thread local and does not require explicit  * synchronization.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unp_marked
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unp_unreachable
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|unp_accessable
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
if|if
condition|(
operator|(
name|unp
operator|=
name|fptounp
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|unp
operator|->
name|unp_gcflag
operator|&
name|UNPGC_REF
condition|)
return|return;
name|unp
operator|->
name|unp_gcflag
operator|&=
operator|~
name|UNPGC_DEAD
expr_stmt|;
name|unp
operator|->
name|unp_gcflag
operator||=
name|UNPGC_REF
expr_stmt|;
name|unp_marked
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unp_gc_process
parameter_list|(
name|struct
name|unpcb
modifier|*
name|unp
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|soa
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
comment|/* Already processed. */
if|if
condition|(
name|unp
operator|->
name|unp_gcflag
operator|&
name|UNPGC_SCANNED
condition|)
return|return;
name|fp
operator|=
name|unp
operator|->
name|unp_file
expr_stmt|;
comment|/* 	 * Check for a socket potentially in a cycle.  It must be in a 	 * queue as indicated by msgcount, and this must equal the file 	 * reference count.  Note that when msgcount is 0 the file is NULL. 	 */
if|if
condition|(
operator|(
name|unp
operator|->
name|unp_gcflag
operator|&
name|UNPGC_REF
operator|)
operator|==
literal|0
operator|&&
name|fp
operator|&&
name|unp
operator|->
name|unp_msgcount
operator|!=
literal|0
operator|&&
name|fp
operator|->
name|f_count
operator|==
name|unp
operator|->
name|unp_msgcount
condition|)
block|{
name|unp
operator|->
name|unp_gcflag
operator||=
name|UNPGC_DEAD
expr_stmt|;
name|unp_unreachable
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 	 * Mark all sockets we reference with RIGHTS. 	 */
name|so
operator|=
name|unp
operator|->
name|unp_socket
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|unp_scan
argument_list|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|,
name|unp_accessable
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* 	 * Mark all sockets in our accept queue. 	 */
name|ACCEPT_LOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|soa
argument_list|,
argument|&so->so_comp
argument_list|,
argument|so_list
argument_list|)
block|{
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|soa
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|unp_scan
argument_list|(
name|soa
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|,
name|unp_accessable
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|soa
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
name|ACCEPT_UNLOCK
argument_list|()
expr_stmt|;
name|unp
operator|->
name|unp_gcflag
operator||=
name|UNPGC_SCANNED
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|unp_recycled
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_local
argument_list|,
name|OID_AUTO
argument_list|,
name|recycled
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|unp_recycled
argument_list|,
literal|0
argument_list|,
literal|"Number of unreachable sockets claimed by the garbage collector."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|unp_taskcount
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_local
argument_list|,
name|OID_AUTO
argument_list|,
name|taskcount
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|unp_taskcount
argument_list|,
literal|0
argument_list|,
literal|"Number of times the garbage collector has run."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|unp_gc
parameter_list|(
name|__unused
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|unp_head
modifier|*
name|heads
index|[]
init|=
block|{
operator|&
name|unp_dhead
block|,
operator|&
name|unp_shead
block|,
name|NULL
block|}
decl_stmt|;
name|struct
name|unp_head
modifier|*
modifier|*
name|head
decl_stmt|;
name|struct
name|file
modifier|*
name|f
decl_stmt|,
modifier|*
modifier|*
name|unref
decl_stmt|;
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|total
decl_stmt|;
name|unp_taskcount
operator|++
expr_stmt|;
name|UNP_LIST_LOCK
argument_list|()
expr_stmt|;
comment|/* 	 * First clear all gc flags from previous runs. 	 */
for|for
control|(
name|head
operator|=
name|heads
init|;
operator|*
name|head
operator|!=
name|NULL
condition|;
name|head
operator|++
control|)
name|LIST_FOREACH
argument_list|(
argument|unp
argument_list|,
argument|*head
argument_list|,
argument|unp_link
argument_list|)
name|unp
operator|->
name|unp_gcflag
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Scan marking all reachable sockets with UNPGC_REF.  Once a socket 	 * is reachable all of the sockets it references are reachable. 	 * Stop the scan once we do a complete loop without discovering 	 * a new reachable socket. 	 */
do|do
block|{
name|unp_unreachable
operator|=
literal|0
expr_stmt|;
name|unp_marked
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|head
operator|=
name|heads
init|;
operator|*
name|head
operator|!=
name|NULL
condition|;
name|head
operator|++
control|)
name|LIST_FOREACH
argument_list|(
argument|unp
argument_list|,
argument|*head
argument_list|,
argument|unp_link
argument_list|)
name|unp_gc_process
argument_list|(
name|unp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|unp_marked
condition|)
do|;
name|UNP_LIST_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|unp_unreachable
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Allocate space for a local list of dead unpcbs. 	 */
name|unref
operator|=
name|malloc
argument_list|(
name|unp_unreachable
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|file
operator|*
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * Iterate looking for sockets which have been specifically marked 	 * as as unreachable and store them locally. 	 */
name|UNP_LINK_RLOCK
argument_list|()
expr_stmt|;
name|UNP_LIST_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|total
operator|=
literal|0
operator|,
name|head
operator|=
name|heads
init|;
operator|*
name|head
operator|!=
name|NULL
condition|;
name|head
operator|++
control|)
name|LIST_FOREACH
argument_list|(
argument|unp
argument_list|,
argument|*head
argument_list|,
argument|unp_link
argument_list|)
if|if
condition|(
operator|(
name|unp
operator|->
name|unp_gcflag
operator|&
name|UNPGC_DEAD
operator|)
operator|!=
literal|0
condition|)
block|{
name|f
operator|=
name|unp
operator|->
name|unp_file
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_msgcount
operator|==
literal|0
operator|||
name|f
operator|==
name|NULL
operator|||
name|f
operator|->
name|f_count
operator|!=
name|unp
operator|->
name|unp_msgcount
condition|)
continue|continue;
name|unref
index|[
name|total
operator|++
index|]
operator|=
name|f
expr_stmt|;
name|fhold
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|total
operator|<=
name|unp_unreachable
argument_list|,
operator|(
literal|"unp_gc: incorrect unreachable count."
operator|)
argument_list|)
expr_stmt|;
block|}
name|UNP_LIST_UNLOCK
argument_list|()
expr_stmt|;
name|UNP_LINK_RUNLOCK
argument_list|()
expr_stmt|;
comment|/* 	 * Now flush all sockets, free'ing rights.  This will free the 	 * struct files associated with these sockets but leave each socket 	 * with one remaining ref. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|unref
index|[
name|i
index|]
operator|->
name|f_data
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|so
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
name|sorflush
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * And finally release the sockets so they can be reclaimed. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total
condition|;
name|i
operator|++
control|)
name|fdrop
argument_list|(
name|unref
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|unp_recycled
operator|+=
name|total
expr_stmt|;
name|free
argument_list|(
name|unref
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unp_dispose
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
condition|)
name|unp_scan
argument_list|(
name|m
argument_list|,
name|unp_discard
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unp_scan
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|void
function_decl|(
modifier|*
name|op
function_decl|)
parameter_list|(
name|struct
name|file
modifier|*
parameter_list|)
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|file
modifier|*
modifier|*
name|rp
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cm
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|socklen_t
name|clen
decl_stmt|,
name|datalen
decl_stmt|;
name|int
name|qfds
decl_stmt|;
while|while
condition|(
name|m0
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_type
operator|!=
name|MT_CONTROL
condition|)
continue|continue;
name|cm
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
expr_stmt|;
name|clen
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
while|while
condition|(
name|cm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
operator|*
name|cm
argument_list|)
operator|>
name|clen
operator|||
name|cm
operator|->
name|cmsg_len
operator|>
name|clen
condition|)
break|break;
name|data
operator|=
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|datalen
operator|=
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|cm
operator|->
name|cmsg_len
operator|-
operator|(
name|caddr_t
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cmsg_level
operator|==
name|SOL_SOCKET
operator|&&
name|cm
operator|->
name|cmsg_type
operator|==
name|SCM_RIGHTS
condition|)
block|{
name|qfds
operator|=
name|datalen
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|file
operator|*
argument_list|)
expr_stmt|;
name|rp
operator|=
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qfds
condition|;
name|i
operator|++
control|)
call|(
modifier|*
name|op
call|)
argument_list|(
operator|*
name|rp
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|<
name|clen
condition|)
block|{
name|clen
operator|-=
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
expr_stmt|;
name|cm
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|clen
operator|=
literal|0
expr_stmt|;
name|cm
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|m0
operator|=
name|m0
operator|->
name|m_act
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_function
specifier|static
name|void
name|db_print_indent
parameter_list|(
name|int
name|indent
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indent
condition|;
name|i
operator|++
control|)
name|db_printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_print_unpflags
parameter_list|(
name|int
name|unp_flags
parameter_list|)
block|{
name|int
name|comma
decl_stmt|;
name|comma
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|unp_flags
operator|&
name|UNP_HAVEPC
condition|)
block|{
name|db_printf
argument_list|(
literal|"%sUNP_HAVEPC"
argument_list|,
name|comma
condition|?
literal|", "
else|:
literal|""
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|unp_flags
operator|&
name|UNP_HAVEPCCACHED
condition|)
block|{
name|db_printf
argument_list|(
literal|"%sUNP_HAVEPCCACHED"
argument_list|,
name|comma
condition|?
literal|", "
else|:
literal|""
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|unp_flags
operator|&
name|UNP_WANTCRED
condition|)
block|{
name|db_printf
argument_list|(
literal|"%sUNP_WANTCRED"
argument_list|,
name|comma
condition|?
literal|", "
else|:
literal|""
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|unp_flags
operator|&
name|UNP_CONNWAIT
condition|)
block|{
name|db_printf
argument_list|(
literal|"%sUNP_CONNWAIT"
argument_list|,
name|comma
condition|?
literal|", "
else|:
literal|""
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|unp_flags
operator|&
name|UNP_CONNECTING
condition|)
block|{
name|db_printf
argument_list|(
literal|"%sUNP_CONNECTING"
argument_list|,
name|comma
condition|?
literal|", "
else|:
literal|""
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|unp_flags
operator|&
name|UNP_BINDING
condition|)
block|{
name|db_printf
argument_list|(
literal|"%sUNP_BINDING"
argument_list|,
name|comma
condition|?
literal|", "
else|:
literal|""
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|db_print_xucred
parameter_list|(
name|int
name|indent
parameter_list|,
name|struct
name|xucred
modifier|*
name|xu
parameter_list|)
block|{
name|int
name|comma
decl_stmt|,
name|i
decl_stmt|;
name|db_print_indent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"cr_version: %u   cr_uid: %u   cr_ngroups: %d\n"
argument_list|,
name|xu
operator|->
name|cr_version
argument_list|,
name|xu
operator|->
name|cr_uid
argument_list|,
name|xu
operator|->
name|cr_ngroups
argument_list|)
expr_stmt|;
name|db_print_indent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"cr_groups: "
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xu
operator|->
name|cr_ngroups
condition|;
name|i
operator|++
control|)
block|{
name|db_printf
argument_list|(
literal|"%s%u"
argument_list|,
name|comma
condition|?
literal|", "
else|:
literal|""
argument_list|,
name|xu
operator|->
name|cr_groups
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|comma
operator|=
literal|1
expr_stmt|;
block|}
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_print_unprefs
parameter_list|(
name|int
name|indent
parameter_list|,
name|struct
name|unp_head
modifier|*
name|uh
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|int
name|counter
decl_stmt|;
name|counter
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|unp
argument_list|,
argument|uh
argument_list|,
argument|unp_reflink
argument_list|)
block|{
if|if
condition|(
name|counter
operator|%
literal|4
operator|==
literal|0
condition|)
name|db_print_indent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"%p  "
argument_list|,
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
name|counter
operator|%
literal|4
operator|==
literal|3
condition|)
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|counter
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|counter
operator|!=
literal|0
operator|&&
name|counter
operator|%
literal|4
operator|!=
literal|0
condition|)
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|unpcb
argument_list|,
argument|db_show_unpcb
argument_list|)
end_macro

begin_block
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
if|if
condition|(
operator|!
name|have_addr
condition|)
block|{
name|db_printf
argument_list|(
literal|"usage: show unpcb<addr>\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|unp
operator|=
operator|(
expr|struct
name|unpcb
operator|*
operator|)
name|addr
expr_stmt|;
name|db_printf
argument_list|(
literal|"unp_socket: %p   unp_vnode: %p\n"
argument_list|,
name|unp
operator|->
name|unp_socket
argument_list|,
name|unp
operator|->
name|unp_vnode
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"unp_ino: %d   unp_conn: %p\n"
argument_list|,
name|unp
operator|->
name|unp_ino
argument_list|,
name|unp
operator|->
name|unp_conn
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"unp_refs:\n"
argument_list|)
expr_stmt|;
name|db_print_unprefs
argument_list|(
literal|2
argument_list|,
operator|&
name|unp
operator|->
name|unp_refs
argument_list|)
expr_stmt|;
comment|/* XXXRW: Would be nice to print the full address, if any. */
name|db_printf
argument_list|(
literal|"unp_addr: %p\n"
argument_list|,
name|unp
operator|->
name|unp_addr
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"unp_cc: %d   unp_mbcnt: %d   unp_gencnt: %llu\n"
argument_list|,
name|unp
operator|->
name|unp_cc
argument_list|,
name|unp
operator|->
name|unp_mbcnt
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|unp
operator|->
name|unp_gencnt
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"unp_flags: %x ("
argument_list|,
name|unp
operator|->
name|unp_flags
argument_list|)
expr_stmt|;
name|db_print_unpflags
argument_list|(
name|unp
operator|->
name|unp_flags
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"unp_peercred:\n"
argument_list|)
expr_stmt|;
name|db_print_xucred
argument_list|(
literal|2
argument_list|,
operator|&
name|unp
operator|->
name|unp_peercred
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"unp_refcount: %u\n"
argument_list|,
name|unp
operator|->
name|unp_refcount
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

