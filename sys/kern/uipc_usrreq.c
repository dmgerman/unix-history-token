begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1989, 1991, 1993  *	The Regents of the University of California.  * Copyright 2004-2005 Robert N. M. Watson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	From: @(#)uipc_usrreq.c	8.3 (Berkeley) 1/4/94  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_comment
comment|/* XXX must be before<sys/file.h> */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mac.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<sys/unpcb.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_decl_stmt
specifier|static
name|uma_zone_t
name|unp_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unp_gen_t
name|unp_gencnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|unp_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|unp_head
name|unp_shead
decl_stmt|,
name|unp_dhead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Unix communications domain.  *  * TODO:  *	SEQPACKET, RDM  *	rethink name space problems  *	need a proper out-of-band  *	lock pushdown  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sockaddr
name|sun_noname
init|=
block|{
sizeof|sizeof
argument_list|(
name|sun_noname
argument_list|)
block|,
name|AF_LOCAL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ino_t
name|unp_ino
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prototype for fake inode numbers */
end_comment

begin_function_decl
name|struct
name|mbuf
modifier|*
name|unp_addsockcred
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Currently, UNIX domain sockets are protected by a single subsystem lock,  * which covers global data structures and variables, the contents of each  * per-socket unpcb structure, and the so_pcb field in sockets attached to  * the UNIX domain.  This provides for a moderate degree of paralellism, as  * receive operations on UNIX domain sockets do not need to acquire the  * subsystem lock.  Finer grained locking to permit send() without acquiring  * a global lock would be a logical next step.  *  * The UNIX domain socket lock preceds all socket layer locks, including the  * socket lock and socket buffer lock, permitting UNIX domain socket code to  * call into socket support routines without releasing its locks.  *  * Some caution is required in areas where the UNIX domain socket code enters  * VFS in order to create or find rendezvous points.  This results in  * dropping of the UNIX domain socket subsystem lock, acquisition of the  * Giant lock, and potential sleeping.  This increases the chances of races,  * and exposes weaknesses in the socket->protocol API by offering poor  * failure modes.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|unp_mtx
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UNP_LOCK_INIT
parameter_list|()
define|\
value|mtx_init(&unp_mtx, "unp", NULL, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|UNP_LOCK
parameter_list|()
value|mtx_lock(&unp_mtx)
end_define

begin_define
define|#
directive|define
name|UNP_UNLOCK
parameter_list|()
value|mtx_unlock(&unp_mtx)
end_define

begin_define
define|#
directive|define
name|UNP_LOCK_ASSERT
parameter_list|()
value|mtx_assert(&unp_mtx, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|UNP_UNLOCK_ASSERT
parameter_list|()
value|mtx_assert(&unp_mtx, MA_NOTOWNED)
end_define

begin_comment
comment|/*  * Garbage collection of cyclic file descriptor/socket references occurs  * asynchronously in a taskqueue context in order to avoid recursion and  * reentrance in the UNIX domain socket, file descriptor, and socket layer  * code.  See unp_gc() for a full description.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|task
name|unp_gc_task
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|unp_attach
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_detach
parameter_list|(
name|struct
name|unpcb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unp_bind
parameter_list|(
name|struct
name|unpcb
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unp_connect
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unp_connect2
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|socket
modifier|*
name|so2
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_disconnect
parameter_list|(
name|struct
name|unpcb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_shutdown
parameter_list|(
name|struct
name|unpcb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_drop
parameter_list|(
name|struct
name|unpcb
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_gc
parameter_list|(
name|__unused
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_scan
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|struct
name|file
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_mark
parameter_list|(
name|struct
name|file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_discard
parameter_list|(
name|struct
name|file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_freerights
parameter_list|(
name|struct
name|file
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unp_internalize
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unp_listen
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|unpcb
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|uipc_abort
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|UNP_LOCK
argument_list|()
expr_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
block|{
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|unp_drop
argument_list|(
name|unp
argument_list|,
name|ECONNABORTED
argument_list|)
expr_stmt|;
name|unp_detach
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_UNLOCK_ASSERT
argument_list|()
expr_stmt|;
name|ACCEPT_LOCK
argument_list|()
expr_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sotryfree
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_accept
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
comment|/* 	 * Pass back name of connected socket, 	 * if it was bound and we are still connected 	 * (our peer may have closed already!). 	 */
operator|*
name|nam
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
argument_list|,
name|M_SONAME
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|UNP_LOCK
argument_list|()
expr_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
block|{
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
operator|*
name|nam
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
operator|*
name|nam
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|unp
operator|->
name|unp_conn
operator|!=
name|NULL
operator|&&
name|unp
operator|->
name|unp_conn
operator|->
name|unp_addr
operator|!=
name|NULL
condition|)
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|unp
operator|->
name|unp_conn
operator|->
name|unp_addr
expr_stmt|;
else|else
name|sa
operator|=
operator|&
name|sun_noname
expr_stmt|;
name|bcopy
argument_list|(
name|sa
argument_list|,
operator|*
name|nam
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
init|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|unp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
return|return
operator|(
name|unp_attach
argument_list|(
name|so
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_bind
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|UNP_LOCK
argument_list|()
expr_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
block|{
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|unp_bind
argument_list|(
name|unp
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_connect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|td
operator|==
name|curthread
argument_list|,
operator|(
literal|"uipc_connect: td != curthread"
operator|)
argument_list|)
expr_stmt|;
name|UNP_LOCK
argument_list|()
expr_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
block|{
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|unp_connect
argument_list|(
name|so
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|uipc_connect2
parameter_list|(
name|struct
name|socket
modifier|*
name|so1
parameter_list|,
name|struct
name|socket
modifier|*
name|so2
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|UNP_LOCK
argument_list|()
expr_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so1
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
block|{
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|unp_connect2
argument_list|(
name|so1
argument_list|,
name|so2
argument_list|,
name|PRU_CONNECT2
argument_list|)
expr_stmt|;
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* control is EOPNOTSUPP */
end_comment

begin_function
specifier|static
name|int
name|uipc_detach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|UNP_LOCK
argument_list|()
expr_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
block|{
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|unp_detach
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_UNLOCK_ASSERT
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_disconnect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|UNP_LOCK
argument_list|()
expr_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
block|{
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|unp_disconnect
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_listen
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|backlog
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|UNP_LOCK
argument_list|()
expr_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
operator|||
name|unp
operator|->
name|unp_vnode
operator|==
name|NULL
condition|)
block|{
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|unp_listen
argument_list|(
name|so
argument_list|,
name|unp
argument_list|,
name|backlog
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_peeraddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
operator|*
name|nam
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
argument_list|,
name|M_SONAME
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|UNP_LOCK
argument_list|()
expr_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
block|{
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
operator|*
name|nam
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
operator|*
name|nam
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|unp
operator|->
name|unp_conn
operator|!=
name|NULL
operator|&&
name|unp
operator|->
name|unp_conn
operator|->
name|unp_addr
operator|!=
name|NULL
condition|)
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|unp
operator|->
name|unp_conn
operator|->
name|unp_addr
expr_stmt|;
else|else
block|{
comment|/* 		 * XXX: It seems that this test always fails even when 		 * connection is established.  So, this else clause is 		 * added as workaround to return PF_LOCAL sockaddr. 		 */
name|sa
operator|=
operator|&
name|sun_noname
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|sa
argument_list|,
operator|*
name|nam
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_rcvd
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so2
decl_stmt|;
name|u_long
name|newhiwat
decl_stmt|;
name|UNP_LOCK
argument_list|()
expr_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
block|{
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
switch|switch
condition|(
name|so
operator|->
name|so_type
condition|)
block|{
case|case
name|SOCK_DGRAM
case|:
name|panic
argument_list|(
literal|"uipc_rcvd DGRAM?"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
name|SOCK_STREAM
case|:
if|if
condition|(
name|unp
operator|->
name|unp_conn
operator|==
name|NULL
condition|)
break|break;
name|so2
operator|=
name|unp
operator|->
name|unp_conn
operator|->
name|unp_socket
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so2
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* 		 * Adjust backpressure on sender 		 * and wakeup any waiting to write. 		 */
name|so2
operator|->
name|so_snd
operator|.
name|sb_mbmax
operator|+=
name|unp
operator|->
name|unp_mbcnt
operator|-
name|so
operator|->
name|so_rcv
operator|.
name|sb_mbcnt
expr_stmt|;
name|unp
operator|->
name|unp_mbcnt
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mbcnt
expr_stmt|;
name|newhiwat
operator|=
name|so2
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|+
name|unp
operator|->
name|unp_cc
operator|-
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
expr_stmt|;
operator|(
name|void
operator|)
name|chgsbsize
argument_list|(
name|so2
operator|->
name|so_cred
operator|->
name|cr_uidinfo
argument_list|,
operator|&
name|so2
operator|->
name|so_snd
operator|.
name|sb_hiwat
argument_list|,
name|newhiwat
argument_list|,
name|RLIM_INFINITY
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_cc
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|sowwakeup_locked
argument_list|(
name|so2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"uipc_rcvd unknown socktype"
argument_list|)
expr_stmt|;
block|}
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* pru_rcvoob is EOPNOTSUPP */
end_comment

begin_function
specifier|static
name|int
name|uipc_send
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so2
decl_stmt|;
name|u_long
name|newhiwat
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|flags
operator|&
name|PRUS_OOB
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|control
operator|!=
name|NULL
operator|&&
operator|(
name|error
operator|=
name|unp_internalize
argument_list|(
operator|&
name|control
argument_list|,
name|td
argument_list|)
operator|)
condition|)
goto|goto
name|release
goto|;
name|UNP_LOCK
argument_list|()
expr_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
block|{
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|dispose_release
goto|;
block|}
switch|switch
condition|(
name|so
operator|->
name|so_type
condition|)
block|{
case|case
name|SOCK_DGRAM
case|:
block|{
specifier|const
name|struct
name|sockaddr
modifier|*
name|from
decl_stmt|;
if|if
condition|(
name|nam
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|unp
operator|->
name|unp_conn
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|EISCONN
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|unp_connect
argument_list|(
name|so
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|unp
operator|->
name|unp_conn
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
break|break;
block|}
block|}
name|so2
operator|=
name|unp
operator|->
name|unp_conn
operator|->
name|unp_socket
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_addr
operator|!=
name|NULL
condition|)
name|from
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|unp
operator|->
name|unp_addr
expr_stmt|;
else|else
name|from
operator|=
operator|&
name|sun_noname
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_conn
operator|->
name|unp_flags
operator|&
name|UNP_WANTCRED
condition|)
name|control
operator|=
name|unp_addsockcred
argument_list|(
name|td
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so2
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbappendaddr_locked
argument_list|(
operator|&
name|so2
operator|->
name|so_rcv
argument_list|,
name|from
argument_list|,
name|m
argument_list|,
name|control
argument_list|)
condition|)
block|{
name|sorwakeup_locked
argument_list|(
name|so2
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so2
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
block|}
if|if
condition|(
name|nam
operator|!=
name|NULL
condition|)
name|unp_disconnect
argument_list|(
name|unp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SOCK_STREAM
case|:
comment|/* Connect if not connected yet. */
comment|/* 		 * Note: A better implementation would complain 		 * if not equal to the peer's address. 		 */
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nam
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|unp_connect
argument_list|(
name|so
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* XXX */
block|}
else|else
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
break|break;
block|}
block|}
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_state
operator|&
name|SBS_CANTSENDMORE
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPIPE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|unp
operator|->
name|unp_conn
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"uipc_send connected but no connection?"
argument_list|)
expr_stmt|;
name|so2
operator|=
name|unp
operator|->
name|unp_conn
operator|->
name|unp_socket
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so2
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_conn
operator|->
name|unp_flags
operator|&
name|UNP_WANTCRED
condition|)
block|{
comment|/* 			 * Credentials are passed only once on 			 * SOCK_STREAM. 			 */
name|unp
operator|->
name|unp_conn
operator|->
name|unp_flags
operator|&=
operator|~
name|UNP_WANTCRED
expr_stmt|;
name|control
operator|=
name|unp_addsockcred
argument_list|(
name|td
argument_list|,
name|control
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Send to paired receive port, and then reduce 		 * send buffer hiwater marks to maintain backpressure. 		 * Wake up readers. 		 */
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sbappendcontrol_locked
argument_list|(
operator|&
name|so2
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|,
name|control
argument_list|)
condition|)
name|control
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|sbappend_locked
argument_list|(
operator|&
name|so2
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|so
operator|->
name|so_snd
operator|.
name|sb_mbmax
operator|-=
name|so2
operator|->
name|so_rcv
operator|.
name|sb_mbcnt
operator|-
name|unp
operator|->
name|unp_conn
operator|->
name|unp_mbcnt
expr_stmt|;
name|unp
operator|->
name|unp_conn
operator|->
name|unp_mbcnt
operator|=
name|so2
operator|->
name|so_rcv
operator|.
name|sb_mbcnt
expr_stmt|;
name|newhiwat
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|-
operator|(
name|so2
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|-
name|unp
operator|->
name|unp_conn
operator|->
name|unp_cc
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|chgsbsize
argument_list|(
name|so
operator|->
name|so_cred
operator|->
name|cr_uidinfo
argument_list|,
operator|&
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
argument_list|,
name|newhiwat
argument_list|,
name|RLIM_INFINITY
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_conn
operator|->
name|unp_cc
operator|=
name|so2
operator|->
name|so_rcv
operator|.
name|sb_cc
expr_stmt|;
name|sorwakeup_locked
argument_list|(
name|so2
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"uipc_send unknown socktype"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * SEND_EOF is equivalent to a SEND followed by 	 * a SHUTDOWN. 	 */
if|if
condition|(
name|flags
operator|&
name|PRUS_EOF
condition|)
block|{
name|socantsendmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|unp_shutdown
argument_list|(
name|unp
argument_list|)
expr_stmt|;
block|}
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
name|dispose_release
label|:
if|if
condition|(
name|control
operator|!=
name|NULL
operator|&&
name|error
operator|!=
literal|0
condition|)
name|unp_dispose
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|release
label|:
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_sense
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|stat
modifier|*
name|sb
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so2
decl_stmt|;
name|UNP_LOCK
argument_list|()
expr_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
block|{
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sb
operator|->
name|st_blksize
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_STREAM
operator|&&
name|unp
operator|->
name|unp_conn
operator|!=
name|NULL
condition|)
block|{
name|so2
operator|=
name|unp
operator|->
name|unp_conn
operator|->
name|unp_socket
expr_stmt|;
name|sb
operator|->
name|st_blksize
operator|+=
name|so2
operator|->
name|so_rcv
operator|.
name|sb_cc
expr_stmt|;
block|}
name|sb
operator|->
name|st_dev
operator|=
name|NODEV
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_ino
operator|==
literal|0
condition|)
name|unp
operator|->
name|unp_ino
operator|=
operator|(
operator|++
name|unp_ino
operator|==
literal|0
operator|)
condition|?
operator|++
name|unp_ino
else|:
name|unp_ino
expr_stmt|;
name|sb
operator|->
name|st_ino
operator|=
name|unp
operator|->
name|unp_ino
expr_stmt|;
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_shutdown
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|UNP_LOCK
argument_list|()
expr_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
block|{
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|socantsendmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|unp_shutdown
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_sockaddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
operator|*
name|nam
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
argument_list|,
name|M_SONAME
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|UNP_LOCK
argument_list|()
expr_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
block|{
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
operator|*
name|nam
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
operator|*
name|nam
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|unp
operator|->
name|unp_addr
operator|!=
name|NULL
condition|)
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|unp
operator|->
name|unp_addr
expr_stmt|;
else|else
name|sa
operator|=
operator|&
name|sun_noname
expr_stmt|;
name|bcopy
argument_list|(
name|sa
argument_list|,
operator|*
name|nam
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|pr_usrreqs
name|uipc_usrreqs
init|=
block|{
operator|.
name|pru_abort
operator|=
name|uipc_abort
block|,
operator|.
name|pru_accept
operator|=
name|uipc_accept
block|,
operator|.
name|pru_attach
operator|=
name|uipc_attach
block|,
operator|.
name|pru_bind
operator|=
name|uipc_bind
block|,
operator|.
name|pru_connect
operator|=
name|uipc_connect
block|,
operator|.
name|pru_connect2
operator|=
name|uipc_connect2
block|,
operator|.
name|pru_detach
operator|=
name|uipc_detach
block|,
operator|.
name|pru_disconnect
operator|=
name|uipc_disconnect
block|,
operator|.
name|pru_listen
operator|=
name|uipc_listen
block|,
operator|.
name|pru_peeraddr
operator|=
name|uipc_peeraddr
block|,
operator|.
name|pru_rcvd
operator|=
name|uipc_rcvd
block|,
operator|.
name|pru_send
operator|=
name|uipc_send
block|,
operator|.
name|pru_sense
operator|=
name|uipc_sense
block|,
operator|.
name|pru_shutdown
operator|=
name|uipc_shutdown
block|,
operator|.
name|pru_sockaddr
operator|=
name|uipc_sockaddr
block|,
operator|.
name|pru_sosend
operator|=
name|sosend
block|,
operator|.
name|pru_soreceive
operator|=
name|soreceive
block|,
operator|.
name|pru_sopoll
operator|=
name|sopoll
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|uipc_ctloutput
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|struct
name|xucred
name|xu
decl_stmt|;
name|int
name|error
decl_stmt|,
name|optval
decl_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_level
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|UNP_LOCK
argument_list|()
expr_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
block|{
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_dir
condition|)
block|{
case|case
name|SOPT_GET
case|:
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|LOCAL_PEERCRED
case|:
if|if
condition|(
name|unp
operator|->
name|unp_flags
operator|&
name|UNP_HAVEPC
condition|)
name|xu
operator|=
name|unp
operator|->
name|unp_peercred
expr_stmt|;
else|else
block|{
if|if
condition|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_STREAM
condition|)
name|error
operator|=
name|ENOTCONN
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|xu
argument_list|,
sizeof|sizeof
argument_list|(
name|xu
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCAL_CREDS
case|:
name|optval
operator|=
name|unp
operator|->
name|unp_flags
operator|&
name|UNP_WANTCRED
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCAL_CONNWAIT
case|:
name|optval
operator|=
name|unp
operator|->
name|unp_flags
operator|&
name|UNP_CONNWAIT
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SOPT_SET
case|:
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|LOCAL_CREDS
case|:
case|case
name|LOCAL_CONNWAIT
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
define|#
directive|define
name|OPTSET
parameter_list|(
name|bit
parameter_list|)
define|\
value|if (optval) \ 		unp->unp_flags |= bit; \ 	else \ 		unp->unp_flags&= ~bit;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|LOCAL_CREDS
case|:
name|OPTSET
argument_list|(
name|UNP_WANTCRED
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCAL_CONNWAIT
case|:
name|OPTSET
argument_list|(
name|UNP_CONNWAIT
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
undef|#
directive|undef
name|OPTSET
default|default:
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Both send and receive buffers are allocated PIPSIZ bytes of buffering  * for stream sockets, although the total for sender and receiver is  * actually only PIPSIZ.  * Datagram sockets really use the sendspace as the maximum datagram size,  * and don't really want to reserve the sendspace.  Their recvspace should  * be large enough for at least one max-size datagram plus address.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PIPSIZ
end_ifndef

begin_define
define|#
directive|define
name|PIPSIZ
value|8192
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|u_long
name|unpst_sendspace
init|=
name|PIPSIZ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|unpst_recvspace
init|=
name|PIPSIZ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|unpdg_sendspace
init|=
literal|2
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* really max datagram size */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|unpdg_recvspace
init|=
literal|4
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unp_rights
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file descriptors in flight */
end_comment

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_local_stream
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_local_stream
argument_list|,
name|OID_AUTO
argument_list|,
name|sendspace
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unpst_sendspace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_local_stream
argument_list|,
name|OID_AUTO
argument_list|,
name|recvspace
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unpst_recvspace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_local_dgram
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_local_dgram
argument_list|,
name|OID_AUTO
argument_list|,
name|maxdgram
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unpdg_sendspace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_local_dgram
argument_list|,
name|OID_AUTO
argument_list|,
name|recvspace
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unpdg_recvspace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_local
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_local
argument_list|,
name|OID_AUTO
argument_list|,
name|inflight
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|unp_rights
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|unp_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|==
literal|0
operator|||
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|so
operator|->
name|so_type
condition|)
block|{
case|case
name|SOCK_STREAM
case|:
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|unpst_sendspace
argument_list|,
name|unpst_recvspace
argument_list|)
expr_stmt|;
break|break;
case|case
name|SOCK_DGRAM
case|:
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|unpdg_sendspace
argument_list|,
name|unpdg_recvspace
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"unp_attach"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|unp
operator|=
name|uma_zalloc
argument_list|(
name|unp_zone
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|LIST_INIT
argument_list|(
operator|&
name|unp
operator|->
name|unp_refs
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_socket
operator|=
name|so
expr_stmt|;
name|so
operator|->
name|so_pcb
operator|=
name|unp
expr_stmt|;
name|UNP_LOCK
argument_list|()
expr_stmt|;
name|unp
operator|->
name|unp_gencnt
operator|=
operator|++
name|unp_gencnt
expr_stmt|;
name|unp_count
operator|++
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_DGRAM
condition|?
operator|&
name|unp_dhead
else|:
operator|&
name|unp_shead
argument_list|,
name|unp
argument_list|,
name|unp_link
argument_list|)
expr_stmt|;
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unp_detach
parameter_list|(
name|struct
name|unpcb
modifier|*
name|unp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|local_unp_rights
decl_stmt|;
name|UNP_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|unp
argument_list|,
name|unp_link
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_gencnt
operator|=
operator|++
name|unp_gencnt
expr_stmt|;
operator|--
name|unp_count
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|=
name|unp
operator|->
name|unp_vnode
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * XXXRW: should v_socket be frobbed only while holding 		 * Giant? 		 */
name|unp
operator|->
name|unp_vnode
operator|->
name|v_socket
operator|=
name|NULL
expr_stmt|;
name|unp
operator|->
name|unp_vnode
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|unp
operator|->
name|unp_conn
operator|!=
name|NULL
condition|)
name|unp_disconnect
argument_list|(
name|unp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|unp
operator|->
name|unp_refs
argument_list|)
condition|)
block|{
name|struct
name|unpcb
modifier|*
name|ref
init|=
name|LIST_FIRST
argument_list|(
operator|&
name|unp
operator|->
name|unp_refs
argument_list|)
decl_stmt|;
name|unp_drop
argument_list|(
name|ref
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
block|}
name|soisdisconnected
argument_list|(
name|unp
operator|->
name|unp_socket
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_socket
operator|->
name|so_pcb
operator|=
name|NULL
expr_stmt|;
name|local_unp_rights
operator|=
name|unp_rights
expr_stmt|;
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_addr
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|unp
operator|->
name|unp_addr
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|unp_zone
argument_list|,
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|local_unp_rights
condition|)
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|unp_gc_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|unp_bind
parameter_list|(
name|struct
name|unpcb
modifier|*
name|unp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|sockaddr_un
modifier|*
name|soun
init|=
operator|(
expr|struct
name|sockaddr_un
operator|*
operator|)
name|nam
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|namelen
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|UNP_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/* 	 * XXXRW: This test-and-set of unp_vnode is non-atomic; the 	 * unlocked read here is fine, but the value of unp_vnode needs 	 * to be tested again after we do all the lookups to see if the 	 * pcb is still unbound? 	 */
if|if
condition|(
name|unp
operator|->
name|unp_vnode
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|namelen
operator|=
name|soun
operator|->
name|sun_len
operator|-
name|offsetof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|,
name|sun_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|namelen
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|namelen
operator|+
literal|1
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|soun
operator|->
name|sun_path
argument_list|,
name|namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|restart
label|:
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|CREATE
argument_list|,
name|NOFOLLOW
operator||
name|LOCKPARENT
operator||
name|SAVENAME
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|buf
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* SHOULD BE ABLE TO ADOPT EXISTING AND wakeup() ALA FIFO's */
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|NULL
operator|||
name|vn_start_write
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|,
operator|&
name|mp
argument_list|,
name|V_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|.
name|ni_dvp
operator|==
name|vp
condition|)
name|vrele
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
block|{
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EADDRINUSE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|error
operator|=
name|vn_start_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|mp
argument_list|,
name|V_XSLEEP
operator||
name|PCATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
goto|goto
name|restart
goto|;
block|}
name|VATTR_NULL
argument_list|(
operator|&
name|vattr
argument_list|)
expr_stmt|;
name|vattr
operator|.
name|va_type
operator|=
name|VSOCK
expr_stmt|;
name|vattr
operator|.
name|va_mode
operator|=
operator|(
name|ACCESSPERMS
operator|&
operator|~
name|td
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_cmask
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_vnode_create
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|nd
operator|.
name|ni_dvp
argument_list|,
operator|&
name|nd
operator|.
name|ni_cnd
argument_list|,
operator|&
name|vattr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|VOP_LEASE
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|LEASE_WRITE
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_CREATE
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|,
operator|&
name|nd
operator|.
name|ni_vp
argument_list|,
operator|&
name|nd
operator|.
name|ni_cnd
argument_list|,
operator|&
name|vattr
argument_list|)
expr_stmt|;
block|}
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|vp
argument_list|,
literal|"unp_bind"
argument_list|)
expr_stmt|;
name|soun
operator|=
operator|(
expr|struct
name|sockaddr_un
operator|*
operator|)
name|sodupsockaddr
argument_list|(
name|nam
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|UNP_LOCK
argument_list|()
expr_stmt|;
name|vp
operator|->
name|v_socket
operator|=
name|unp
operator|->
name|unp_socket
expr_stmt|;
name|unp
operator|->
name|unp_vnode
operator|=
name|vp
expr_stmt|;
name|unp
operator|->
name|unp_addr
operator|=
name|soun
expr_stmt|;
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|done
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|UNP_LOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unp_connect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|sockaddr_un
modifier|*
name|soun
init|=
operator|(
expr|struct
name|sockaddr_un
operator|*
operator|)
name|nam
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so2
decl_stmt|,
modifier|*
name|so3
decl_stmt|;
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|,
modifier|*
name|unp3
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|char
name|buf
index|[
name|SOCK_MAXADDRLEN
index|]
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|UNP_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|len
operator|=
name|nam
operator|->
name|sa_len
operator|-
name|offsetof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|,
name|sun_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|soun
operator|->
name|sun_path
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
name|sa
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
argument_list|,
name|M_SONAME
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|buf
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|vp
operator|=
name|NULL
expr_stmt|;
else|else
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|vp
argument_list|,
literal|"unp_connect"
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VSOCK
condition|)
block|{
name|error
operator|=
name|ENOTSOCK
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VWRITE
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|UNP_LOCK
argument_list|()
expr_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|so2
operator|=
name|vp
operator|->
name|v_socket
expr_stmt|;
if|if
condition|(
name|so2
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ECONNREFUSED
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
if|if
condition|(
name|so
operator|->
name|so_type
operator|!=
name|so2
operator|->
name|so_type
condition|)
block|{
name|error
operator|=
name|EPROTOTYPE
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
condition|)
block|{
if|if
condition|(
name|so2
operator|->
name|so_options
operator|&
name|SO_ACCEPTCONN
condition|)
block|{
comment|/* 			 * NB: drop locks here so unp_attach is entered 			 *     w/o locks; this avoids a recursive lock 			 *     of the head and holding sleep locks across 			 *     a (potentially) blocking malloc. 			 */
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
name|so3
operator|=
name|sonewconn
argument_list|(
name|so2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UNP_LOCK
argument_list|()
expr_stmt|;
block|}
else|else
name|so3
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|so3
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ECONNREFUSED
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|unp2
operator|=
name|sotounpcb
argument_list|(
name|so2
argument_list|)
expr_stmt|;
name|unp3
operator|=
name|sotounpcb
argument_list|(
name|so3
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp2
operator|->
name|unp_addr
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|unp2
operator|->
name|unp_addr
argument_list|,
name|sa
argument_list|,
name|unp2
operator|->
name|unp_addr
operator|->
name|sun_len
argument_list|)
expr_stmt|;
name|unp3
operator|->
name|unp_addr
operator|=
operator|(
expr|struct
name|sockaddr_un
operator|*
operator|)
name|sa
expr_stmt|;
name|sa
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * unp_peercred management: 		 * 		 * The connecter's (client's) credentials are copied 		 * from its process structure at the time of connect() 		 * (which is now). 		 */
name|cru2x
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
operator|&
name|unp3
operator|->
name|unp_peercred
argument_list|)
expr_stmt|;
name|unp3
operator|->
name|unp_flags
operator||=
name|UNP_HAVEPC
expr_stmt|;
comment|/* 		 * The receiver's (server's) credentials are copied 		 * from the unp_peercred member of socket on which the 		 * former called listen(); unp_listen() cached that 		 * process's credentials at that time so we can use 		 * them now. 		 */
name|KASSERT
argument_list|(
name|unp2
operator|->
name|unp_flags
operator|&
name|UNP_HAVEPCCACHED
argument_list|,
operator|(
literal|"unp_connect: listener without cached peercred"
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|unp
operator|->
name|unp_peercred
argument_list|,
operator|&
name|unp2
operator|->
name|unp_peercred
argument_list|,
sizeof|sizeof
argument_list|(
name|unp
operator|->
name|unp_peercred
argument_list|)
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_flags
operator||=
name|UNP_HAVEPC
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|mac_set_socket_peer_from_socket
argument_list|(
name|so
argument_list|,
name|so3
argument_list|)
expr_stmt|;
name|mac_set_socket_peer_from_socket
argument_list|(
name|so3
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|so2
operator|=
name|so3
expr_stmt|;
block|}
name|error
operator|=
name|unp_connect2
argument_list|(
name|so
argument_list|,
name|so2
argument_list|,
name|PRU_CONNECT
argument_list|)
expr_stmt|;
name|bad2
label|:
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|bad
label|:
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sa
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|UNP_LOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unp_connect2
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|socket
modifier|*
name|so2
parameter_list|,
name|int
name|req
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
init|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|unpcb
modifier|*
name|unp2
decl_stmt|;
name|UNP_LOCK_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|so2
operator|->
name|so_type
operator|!=
name|so
operator|->
name|so_type
condition|)
return|return
operator|(
name|EPROTOTYPE
operator|)
return|;
name|unp2
operator|=
name|sotounpcb
argument_list|(
name|so2
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_conn
operator|=
name|unp2
expr_stmt|;
switch|switch
condition|(
name|so
operator|->
name|so_type
condition|)
block|{
case|case
name|SOCK_DGRAM
case|:
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|unp2
operator|->
name|unp_refs
argument_list|,
name|unp
argument_list|,
name|unp_reflink
argument_list|)
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
break|break;
case|case
name|SOCK_STREAM
case|:
name|unp2
operator|->
name|unp_conn
operator|=
name|unp
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|PRU_CONNECT
operator|&&
operator|(
operator|(
name|unp
operator|->
name|unp_flags
operator||
name|unp2
operator|->
name|unp_flags
operator|)
operator|&
name|UNP_CONNWAIT
operator|)
condition|)
name|soisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
else|else
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|soisconnected
argument_list|(
name|so2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"unp_connect2"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unp_disconnect
parameter_list|(
name|struct
name|unpcb
modifier|*
name|unp
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp2
init|=
name|unp
operator|->
name|unp_conn
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|UNP_LOCK_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|unp2
operator|==
name|NULL
condition|)
return|return;
name|unp
operator|->
name|unp_conn
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|unp
operator|->
name|unp_socket
operator|->
name|so_type
condition|)
block|{
case|case
name|SOCK_DGRAM
case|:
name|LIST_REMOVE
argument_list|(
name|unp
argument_list|,
name|unp_reflink
argument_list|)
expr_stmt|;
name|so
operator|=
name|unp
operator|->
name|unp_socket
expr_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_state
operator|&=
operator|~
name|SS_ISCONNECTED
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
break|break;
case|case
name|SOCK_STREAM
case|:
name|soisdisconnected
argument_list|(
name|unp
operator|->
name|unp_socket
argument_list|)
expr_stmt|;
name|unp2
operator|->
name|unp_conn
operator|=
name|NULL
expr_stmt|;
name|soisdisconnected
argument_list|(
name|unp2
operator|->
name|unp_socket
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_function
name|void
name|unp_abort
parameter_list|(
name|struct
name|unpcb
modifier|*
name|unp
parameter_list|)
block|{
name|unp_detach
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_UNLOCK_ASSERT
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * unp_pcblist() assumes that UNIX domain socket memory is never reclaimed  * by the zone (UMA_ZONE_NOFREE), and as such potentially stale pointers  * are safe to reference.  It first scans the list of struct unpcb's to  * generate a pointer list, then it rescans its list one entry at a time to  * externalize and copyout.  It checks the generation number to see if a  * struct unpcb has been reused, and will skip it if so.  */
end_comment

begin_function
specifier|static
name|int
name|unp_pcblist
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
modifier|*
name|unp_list
decl_stmt|;
name|unp_gen_t
name|gencnt
decl_stmt|;
name|struct
name|xunpgen
modifier|*
name|xug
decl_stmt|;
name|struct
name|unp_head
modifier|*
name|head
decl_stmt|;
name|struct
name|xunpcb
modifier|*
name|xu
decl_stmt|;
name|head
operator|=
operator|(
operator|(
name|intptr_t
operator|)
name|arg1
operator|==
name|SOCK_DGRAM
condition|?
operator|&
name|unp_dhead
else|:
operator|&
name|unp_shead
operator|)
expr_stmt|;
comment|/* 	 * The process of preparing the PCB list is too time-consuming and 	 * resource-intensive to repeat twice on every request. 	 */
if|if
condition|(
name|req
operator|->
name|oldptr
operator|==
name|NULL
condition|)
block|{
name|n
operator|=
name|unp_count
expr_stmt|;
name|req
operator|->
name|oldidx
operator|=
literal|2
operator|*
operator|(
sizeof|sizeof
expr|*
name|xug
operator|)
operator|+
operator|(
name|n
operator|+
name|n
operator|/
literal|8
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|xunpcb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* 	 * OK, now we're committed to doing something. 	 */
name|xug
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|xug
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|UNP_LOCK
argument_list|()
expr_stmt|;
name|gencnt
operator|=
name|unp_gencnt
expr_stmt|;
name|n
operator|=
name|unp_count
expr_stmt|;
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
name|xug
operator|->
name|xug_len
operator|=
sizeof|sizeof
expr|*
name|xug
expr_stmt|;
name|xug
operator|->
name|xug_count
operator|=
name|n
expr_stmt|;
name|xug
operator|->
name|xug_gen
operator|=
name|gencnt
expr_stmt|;
name|xug
operator|->
name|xug_sogen
operator|=
name|so_gencnt
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|xug
argument_list|,
sizeof|sizeof
expr|*
name|xug
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|xug
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|unp_list
operator|=
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
expr|*
name|unp_list
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|UNP_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|unp
operator|=
name|LIST_FIRST
argument_list|(
name|head
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|unp
operator|&&
name|i
operator|<
name|n
condition|;
name|unp
operator|=
name|LIST_NEXT
argument_list|(
name|unp
argument_list|,
name|unp_link
argument_list|)
control|)
block|{
if|if
condition|(
name|unp
operator|->
name|unp_gencnt
operator|<=
name|gencnt
condition|)
block|{
if|if
condition|(
name|cr_cansee
argument_list|(
name|req
operator|->
name|td
operator|->
name|td_ucred
argument_list|,
name|unp
operator|->
name|unp_socket
operator|->
name|so_cred
argument_list|)
condition|)
continue|continue;
name|unp_list
index|[
name|i
operator|++
index|]
operator|=
name|unp
expr_stmt|;
block|}
block|}
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
name|n
operator|=
name|i
expr_stmt|;
comment|/* in case we lost some during malloc */
name|error
operator|=
literal|0
expr_stmt|;
name|xu
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|xu
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|unp
operator|=
name|unp_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_gencnt
operator|<=
name|gencnt
condition|)
block|{
name|xu
operator|->
name|xu_len
operator|=
sizeof|sizeof
expr|*
name|xu
expr_stmt|;
name|xu
operator|->
name|xu_unpp
operator|=
name|unp
expr_stmt|;
comment|/* 			 * XXX - need more locking here to protect against 			 * connect/disconnect races for SMP. 			 */
if|if
condition|(
name|unp
operator|->
name|unp_addr
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|unp
operator|->
name|unp_addr
argument_list|,
operator|&
name|xu
operator|->
name|xu_addr
argument_list|,
name|unp
operator|->
name|unp_addr
operator|->
name|sun_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_conn
operator|!=
name|NULL
operator|&&
name|unp
operator|->
name|unp_conn
operator|->
name|unp_addr
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|unp
operator|->
name|unp_conn
operator|->
name|unp_addr
argument_list|,
operator|&
name|xu
operator|->
name|xu_caddr
argument_list|,
name|unp
operator|->
name|unp_conn
operator|->
name|unp_addr
operator|->
name|sun_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|unp
argument_list|,
operator|&
name|xu
operator|->
name|xu_unp
argument_list|,
sizeof|sizeof
expr|*
name|unp
argument_list|)
expr_stmt|;
name|sotoxsocket
argument_list|(
name|unp
operator|->
name|unp_socket
argument_list|,
operator|&
name|xu
operator|->
name|xu_socket
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|xu
argument_list|,
sizeof|sizeof
expr|*
name|xu
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|xu
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* 		 * Give the user an updated idea of our state. 		 * If the generation differs from what we told 		 * her before, she knows that something happened 		 * while we were processing this request, and it 		 * might be necessary to retry. 		 */
name|xug
operator|->
name|xug_gen
operator|=
name|unp_gencnt
expr_stmt|;
name|xug
operator|->
name|xug_sogen
operator|=
name|so_gencnt
expr_stmt|;
name|xug
operator|->
name|xug_count
operator|=
name|unp_count
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|xug
argument_list|,
sizeof|sizeof
expr|*
name|xug
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|unp_list
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xug
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_local_dgram
argument_list|,
name|OID_AUTO
argument_list|,
name|pcblist
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|long
operator|)
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|,
name|unp_pcblist
argument_list|,
literal|"S,xunpcb"
argument_list|,
literal|"List of active local datagram sockets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_local_stream
argument_list|,
name|OID_AUTO
argument_list|,
name|pcblist
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|long
operator|)
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
name|unp_pcblist
argument_list|,
literal|"S,xunpcb"
argument_list|,
literal|"List of active local stream sockets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|unp_shutdown
parameter_list|(
name|struct
name|unpcb
modifier|*
name|unp
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|UNP_LOCK_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_socket
operator|->
name|so_type
operator|==
name|SOCK_STREAM
operator|&&
name|unp
operator|->
name|unp_conn
operator|&&
operator|(
name|so
operator|=
name|unp
operator|->
name|unp_conn
operator|->
name|unp_socket
operator|)
condition|)
name|socantrcvmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unp_drop
parameter_list|(
name|struct
name|unpcb
modifier|*
name|unp
parameter_list|,
name|int
name|errno
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|unp
operator|->
name|unp_socket
decl_stmt|;
name|UNP_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
name|errno
expr_stmt|;
name|unp_disconnect
argument_list|(
name|unp
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_function
name|void
name|unp_drain
parameter_list|(
name|void
parameter_list|)
block|{  }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|unp_freerights
parameter_list|(
name|struct
name|file
modifier|*
modifier|*
name|rp
parameter_list|,
name|int
name|fdcount
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fdcount
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|*
name|rp
expr_stmt|;
comment|/* 		 * zero the pointer before calling 		 * unp_discard since it may end up 		 * in unp_gc().. 		 */
operator|*
name|rp
operator|++
operator|=
literal|0
expr_stmt|;
name|unp_discard
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|unp_externalize
parameter_list|(
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|controlp
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
comment|/* XXX */
name|struct
name|cmsghdr
modifier|*
name|cm
init|=
name|mtod
argument_list|(
name|control
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|fdp
decl_stmt|;
name|struct
name|file
modifier|*
modifier|*
name|rp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|socklen_t
name|clen
init|=
name|control
operator|->
name|m_len
decl_stmt|,
name|datalen
decl_stmt|;
name|int
name|error
decl_stmt|,
name|newfds
decl_stmt|;
name|int
name|f
decl_stmt|;
name|u_int
name|newlen
decl_stmt|;
name|UNP_UNLOCK_ASSERT
argument_list|()
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
comment|/* controlp == NULL => free control messages */
operator|*
name|controlp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|cm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
operator|*
name|cm
argument_list|)
operator|>
name|clen
operator|||
name|cm
operator|->
name|cmsg_len
operator|>
name|clen
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|data
operator|=
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|datalen
operator|=
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|cm
operator|->
name|cmsg_len
operator|-
operator|(
name|caddr_t
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cmsg_level
operator|==
name|SOL_SOCKET
operator|&&
name|cm
operator|->
name|cmsg_type
operator|==
name|SCM_RIGHTS
condition|)
block|{
name|newfds
operator|=
name|datalen
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|file
operator|*
argument_list|)
expr_stmt|;
name|rp
operator|=
name|data
expr_stmt|;
comment|/* If we're not outputting the descriptors free them. */
if|if
condition|(
name|error
operator|||
name|controlp
operator|==
name|NULL
condition|)
block|{
name|unp_freerights
argument_list|(
name|rp
argument_list|,
name|newfds
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|FILEDESC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
comment|/* if the new FD's will not fit free them.  */
if|if
condition|(
operator|!
name|fdavail
argument_list|(
name|td
argument_list|,
name|newfds
argument_list|)
condition|)
block|{
name|FILEDESC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
name|unp_freerights
argument_list|(
name|rp
argument_list|,
name|newfds
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* 			 * now change each pointer to an fd in the global 			 * table to an integer that is the index to the 			 * local fd table entry that we set up to point 			 * to the global one we are transferring. 			 */
name|newlen
operator|=
name|newfds
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|*
name|controlp
operator|=
name|sbcreatecontrol
argument_list|(
name|NULL
argument_list|,
name|newlen
argument_list|,
name|SCM_RIGHTS
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|controlp
operator|==
name|NULL
condition|)
block|{
name|FILEDESC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
name|error
operator|=
name|E2BIG
expr_stmt|;
name|unp_freerights
argument_list|(
name|rp
argument_list|,
name|newfds
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|fdp
operator|=
operator|(
name|int
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|mtod
argument_list|(
operator|*
name|controlp
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|newfds
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fdalloc
argument_list|(
name|td
argument_list|,
literal|0
argument_list|,
operator|&
name|f
argument_list|)
condition|)
name|panic
argument_list|(
literal|"unp_externalize fdalloc failed"
argument_list|)
expr_stmt|;
name|fp
operator|=
operator|*
name|rp
operator|++
expr_stmt|;
name|td
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_ofiles
index|[
name|f
index|]
operator|=
name|fp
expr_stmt|;
name|FILE_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_msgcount
operator|--
expr_stmt|;
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|unp_rights
operator|--
expr_stmt|;
operator|*
name|fdp
operator|++
operator|=
name|f
expr_stmt|;
block|}
name|FILEDESC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We can just copy anything else across */
if|if
condition|(
name|error
operator|||
name|controlp
operator|==
name|NULL
condition|)
goto|goto
name|next
goto|;
operator|*
name|controlp
operator|=
name|sbcreatecontrol
argument_list|(
name|NULL
argument_list|,
name|datalen
argument_list|,
name|cm
operator|->
name|cmsg_type
argument_list|,
name|cm
operator|->
name|cmsg_level
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|controlp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|bcopy
argument_list|(
name|data
argument_list|,
name|CMSG_DATA
argument_list|(
name|mtod
argument_list|(
operator|*
name|controlp
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
name|controlp
operator|=
operator|&
operator|(
operator|*
name|controlp
operator|)
operator|->
name|m_next
expr_stmt|;
name|next
label|:
if|if
condition|(
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|<
name|clen
condition|)
block|{
name|clen
operator|-=
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
expr_stmt|;
name|cm
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|clen
operator|=
literal|0
expr_stmt|;
name|cm
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|unp_init
parameter_list|(
name|void
parameter_list|)
block|{
name|unp_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"unpcb"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unpcb
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp_zone
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"unp_init"
argument_list|)
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|unp_zone
argument_list|,
name|nmbclusters
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|unp_dhead
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|unp_shead
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|unp_gc_task
argument_list|,
literal|0
argument_list|,
name|unp_gc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|UNP_LOCK_INIT
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|unp_internalize
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|controlp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|control
init|=
operator|*
name|controlp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|filedesc
modifier|*
name|fdescp
init|=
name|p
operator|->
name|p_fd
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cm
init|=
name|mtod
argument_list|(
name|control
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
decl_stmt|;
name|struct
name|cmsgcred
modifier|*
name|cmcred
decl_stmt|;
name|struct
name|file
modifier|*
modifier|*
name|rp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tv
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|,
modifier|*
name|fdp
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|socklen_t
name|clen
init|=
name|control
operator|->
name|m_len
decl_stmt|,
name|datalen
decl_stmt|;
name|int
name|error
decl_stmt|,
name|oldfds
decl_stmt|;
name|u_int
name|newlen
decl_stmt|;
name|UNP_UNLOCK_ASSERT
argument_list|()
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
operator|*
name|controlp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|cm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
operator|*
name|cm
argument_list|)
operator|>
name|clen
operator|||
name|cm
operator|->
name|cmsg_level
operator|!=
name|SOL_SOCKET
operator|||
name|cm
operator|->
name|cmsg_len
operator|>
name|clen
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|data
operator|=
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|datalen
operator|=
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|cm
operator|->
name|cmsg_len
operator|-
operator|(
name|caddr_t
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|cm
operator|->
name|cmsg_type
condition|)
block|{
comment|/* 		 * Fill in credential information. 		 */
case|case
name|SCM_CREDS
case|:
operator|*
name|controlp
operator|=
name|sbcreatecontrol
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cmcred
argument_list|)
argument_list|,
name|SCM_CREDS
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|controlp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cmcred
operator|=
operator|(
expr|struct
name|cmsgcred
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|mtod
argument_list|(
operator|*
name|controlp
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|cmcred
operator|->
name|cmcred_pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|cmcred
operator|->
name|cmcred_uid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_ruid
expr_stmt|;
name|cmcred
operator|->
name|cmcred_gid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_rgid
expr_stmt|;
name|cmcred
operator|->
name|cmcred_euid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_uid
expr_stmt|;
name|cmcred
operator|->
name|cmcred_ngroups
operator|=
name|MIN
argument_list|(
name|td
operator|->
name|td_ucred
operator|->
name|cr_ngroups
argument_list|,
name|CMGROUP_MAX
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmcred
operator|->
name|cmcred_ngroups
condition|;
name|i
operator|++
control|)
name|cmcred
operator|->
name|cmcred_groups
index|[
name|i
index|]
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_groups
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|SCM_RIGHTS
case|:
name|oldfds
operator|=
name|datalen
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/* 			 * check that all the FDs passed in refer to legal files 			 * If not, reject the entire operation. 			 */
name|fdp
operator|=
name|data
expr_stmt|;
name|FILEDESC_LOCK
argument_list|(
name|fdescp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldfds
condition|;
name|i
operator|++
control|)
block|{
name|fd
operator|=
operator|*
name|fdp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|fd
operator|>=
name|fdescp
operator|->
name|fd_nfiles
operator|||
name|fdescp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
operator|==
name|NULL
condition|)
block|{
name|FILEDESC_UNLOCK
argument_list|(
name|fdescp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBADF
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fp
operator|=
name|fdescp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|f_ops
operator|->
name|fo_flags
operator|&
name|DFLAG_PASSABLE
operator|)
condition|)
block|{
name|FILEDESC_UNLOCK
argument_list|(
name|fdescp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 			 * Now replace the integer FDs with pointers to 			 * the associated global file table entry.. 			 */
name|newlen
operator|=
name|oldfds
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|file
operator|*
argument_list|)
expr_stmt|;
operator|*
name|controlp
operator|=
name|sbcreatecontrol
argument_list|(
name|NULL
argument_list|,
name|newlen
argument_list|,
name|SCM_RIGHTS
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|controlp
operator|==
name|NULL
condition|)
block|{
name|FILEDESC_UNLOCK
argument_list|(
name|fdescp
argument_list|)
expr_stmt|;
name|error
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fdp
operator|=
name|data
expr_stmt|;
name|rp
operator|=
operator|(
expr|struct
name|file
operator|*
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|mtod
argument_list|(
operator|*
name|controlp
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldfds
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
name|fdescp
operator|->
name|fd_ofiles
index|[
operator|*
name|fdp
operator|++
index|]
expr_stmt|;
operator|*
name|rp
operator|++
operator|=
name|fp
expr_stmt|;
name|FILE_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_count
operator|++
expr_stmt|;
name|fp
operator|->
name|f_msgcount
operator|++
expr_stmt|;
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|unp_rights
operator|++
expr_stmt|;
block|}
name|FILEDESC_UNLOCK
argument_list|(
name|fdescp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCM_TIMESTAMP
case|:
operator|*
name|controlp
operator|=
name|sbcreatecontrol
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tv
argument_list|)
argument_list|,
name|SCM_TIMESTAMP
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|controlp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|tv
operator|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|mtod
argument_list|(
operator|*
name|controlp
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
name|tv
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|controlp
operator|=
operator|&
operator|(
operator|*
name|controlp
operator|)
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|<
name|clen
condition|)
block|{
name|clen
operator|-=
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
expr_stmt|;
name|cm
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|clen
operator|=
literal|0
expr_stmt|;
name|cm
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|out
label|:
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|unp_addsockcred
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|struct
name|sockcred
modifier|*
name|sc
decl_stmt|;
name|int
name|ngroups
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ngroups
operator|=
name|MIN
argument_list|(
name|td
operator|->
name|td_ucred
operator|->
name|cr_ngroups
argument_list|,
name|CMGROUP_MAX
argument_list|)
expr_stmt|;
name|m
operator|=
name|sbcreatecontrol
argument_list|(
name|NULL
argument_list|,
name|SOCKCREDSIZE
argument_list|(
name|ngroups
argument_list|)
argument_list|,
name|SCM_CREDS
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|control
operator|)
return|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|sockcred
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_uid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_ruid
expr_stmt|;
name|sc
operator|->
name|sc_euid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_uid
expr_stmt|;
name|sc
operator|->
name|sc_gid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_rgid
expr_stmt|;
name|sc
operator|->
name|sc_egid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_gid
expr_stmt|;
name|sc
operator|->
name|sc_ngroups
operator|=
name|ngroups
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_ngroups
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|sc_groups
index|[
name|i
index|]
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_groups
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * If a control message already exists, append us to the end. 	 */
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|n
operator|=
name|control
init|;
name|n
operator|->
name|m_next
operator|!=
name|NULL
condition|;
name|n
operator|=
name|n
operator|->
name|m_next
control|)
empty_stmt|;
name|n
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
block|}
else|else
name|control
operator|=
name|m
expr_stmt|;
return|return
operator|(
name|control
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * unp_defer indicates whether additional work has been defered for a future  * pass through unp_gc().  It is thread local and does not require explicit  * synchronization.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unp_defer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unp_taskcount
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_local
argument_list|,
name|OID_AUTO
argument_list|,
name|taskcount
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|unp_taskcount
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|unp_recycled
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_local
argument_list|,
name|OID_AUTO
argument_list|,
name|recycled
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|unp_recycled
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|unp_gc
parameter_list|(
name|__unused
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|file
modifier|*
name|fp
decl_stmt|,
modifier|*
name|nextfp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|file
modifier|*
modifier|*
name|extra_ref
decl_stmt|,
modifier|*
modifier|*
name|fpp
decl_stmt|;
name|int
name|nunref
decl_stmt|,
name|i
decl_stmt|;
name|int
name|nfiles_snap
decl_stmt|;
name|int
name|nfiles_slack
init|=
literal|20
decl_stmt|;
name|unp_taskcount
operator|++
expr_stmt|;
name|unp_defer
operator|=
literal|0
expr_stmt|;
comment|/* 	 * before going through all this, set all FDs to 	 * be NOT defered and NOT externally accessible 	 */
name|sx_slock
argument_list|(
operator|&
name|filelist_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|fp
argument_list|,
argument|&filehead
argument_list|,
argument|f_list
argument_list|)
name|fp
operator|->
name|f_gcflag
operator|&=
operator|~
operator|(
name|FMARK
operator||
name|FDEFER
operator|)
expr_stmt|;
do|do
block|{
name|KASSERT
argument_list|(
name|unp_defer
operator|>=
literal|0
argument_list|,
operator|(
literal|"unp_gc: unp_defer %d"
operator|,
name|unp_defer
operator|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|fp
argument_list|,
argument|&filehead
argument_list|,
argument|f_list
argument_list|)
block|{
name|FILE_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* 			 * If the file is not open, skip it -- could be a 			 * file in the process of being opened, or in the 			 * process of being closed.  If the file is 			 * "closing", it may have been marked for deferred 			 * consideration.  Clear the flag now if so. 			 */
if|if
condition|(
name|fp
operator|->
name|f_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|f_gcflag
operator|&
name|FDEFER
condition|)
name|unp_defer
operator|--
expr_stmt|;
name|fp
operator|->
name|f_gcflag
operator|&=
operator|~
operator|(
name|FMARK
operator||
name|FDEFER
operator|)
expr_stmt|;
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * If we already marked it as 'defer'  in a 			 * previous pass, then try process it this time 			 * and un-mark it 			 */
if|if
condition|(
name|fp
operator|->
name|f_gcflag
operator|&
name|FDEFER
condition|)
block|{
name|fp
operator|->
name|f_gcflag
operator|&=
operator|~
name|FDEFER
expr_stmt|;
name|unp_defer
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * if it's not defered, then check if it's 				 * already marked.. if so skip it 				 */
if|if
condition|(
name|fp
operator|->
name|f_gcflag
operator|&
name|FMARK
condition|)
block|{
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 				 * If all references are from messages 				 * in transit, then skip it. it's not 				 * externally accessible. 				 */
if|if
condition|(
name|fp
operator|->
name|f_count
operator|==
name|fp
operator|->
name|f_msgcount
condition|)
block|{
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 				 * If it got this far then it must be 				 * externally accessible. 				 */
name|fp
operator|->
name|f_gcflag
operator||=
name|FMARK
expr_stmt|;
block|}
comment|/* 			 * either it was defered, or it is externally 			 * accessible and not already marked so. 			 * Now check if it is possibly one of OUR sockets. 			 */
if|if
condition|(
name|fp
operator|->
name|f_type
operator|!=
name|DTYPE_SOCKET
operator|||
operator|(
name|so
operator|=
name|fp
operator|->
name|f_data
operator|)
operator|==
name|NULL
condition|)
block|{
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|!=
operator|&
name|localdomain
operator|||
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_RIGHTS
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 			 * So, Ok, it's one of our sockets and it IS externally 			 * accessible (or was defered). Now we look 			 * to see if we hold any file descriptors in its 			 * message buffers. Follow those links and mark them 			 * as accessible too. 			 */
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|unp_scan
argument_list|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|,
name|unp_mark
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|unp_defer
condition|)
do|;
name|sx_sunlock
argument_list|(
operator|&
name|filelist_lock
argument_list|)
expr_stmt|;
comment|/* 	 * XXXRW: The following comments need updating for a post-SMPng and 	 * deferred unp_gc() world, but are still generally accurate. 	 * 	 * We grab an extra reference to each of the file table entries 	 * that are not otherwise accessible and then free the rights 	 * that are stored in messages on them. 	 * 	 * The bug in the orginal code is a little tricky, so I'll describe 	 * what's wrong with it here. 	 * 	 * It is incorrect to simply unp_discard each entry for f_msgcount 	 * times -- consider the case of sockets A and B that contain 	 * references to each other.  On a last close of some other socket, 	 * we trigger a gc since the number of outstanding rights (unp_rights) 	 * is non-zero.  If during the sweep phase the gc code unp_discards, 	 * we end up doing a (full) closef on the descriptor.  A closef on A 	 * results in the following chain.  Closef calls soo_close, which 	 * calls soclose.   Soclose calls first (through the switch 	 * uipc_usrreq) unp_detach, which re-invokes unp_gc.  Unp_gc simply 	 * returns because the previous instance had set unp_gcing, and 	 * we return all the way back to soclose, which marks the socket 	 * with SS_NOFDREF, and then calls sofree.  Sofree calls sorflush 	 * to free up the rights that are queued in messages on the socket A, 	 * i.e., the reference on B.  The sorflush calls via the dom_dispose 	 * switch unp_dispose, which unp_scans with unp_discard.  This second 	 * instance of unp_discard just calls closef on B. 	 * 	 * Well, a similar chain occurs on B, resulting in a sorflush on B, 	 * which results in another closef on A.  Unfortunately, A is already 	 * being closed, and the descriptor has already been marked with 	 * SS_NOFDREF, and soclose panics at this point. 	 * 	 * Here, we first take an extra reference to each inaccessible 	 * descriptor.  Then, we call sorflush ourself, since we know 	 * it is a Unix domain socket anyhow.  After we destroy all the 	 * rights carried in messages, we do a last closef to get rid 	 * of our extra reference.  This is the last close, and the 	 * unp_detach etc will shut down the socket. 	 * 	 * 91/09/19, bsy@cs.cmu.edu 	 */
name|again
label|:
name|nfiles_snap
operator|=
name|openfiles
operator|+
name|nfiles_slack
expr_stmt|;
comment|/* some slack */
name|extra_ref
operator|=
name|malloc
argument_list|(
name|nfiles_snap
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|file
operator|*
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|filelist_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfiles_snap
operator|<
name|openfiles
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|filelist_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|extra_ref
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|nfiles_slack
operator|+=
literal|20
expr_stmt|;
goto|goto
name|again
goto|;
block|}
for|for
control|(
name|nunref
operator|=
literal|0
operator|,
name|fp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|filehead
argument_list|)
operator|,
name|fpp
operator|=
name|extra_ref
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|nextfp
control|)
block|{
name|nextfp
operator|=
name|LIST_NEXT
argument_list|(
name|fp
argument_list|,
name|f_list
argument_list|)
expr_stmt|;
name|FILE_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* 		 * If it's not open, skip it 		 */
if|if
condition|(
name|fp
operator|->
name|f_count
operator|==
literal|0
condition|)
block|{
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If all refs are from msgs, and it's not marked accessible 		 * then it must be referenced from some unreachable cycle 		 * of (shut-down) FDs, so include it in our 		 * list of FDs to remove 		 */
if|if
condition|(
name|fp
operator|->
name|f_count
operator|==
name|fp
operator|->
name|f_msgcount
operator|&&
operator|!
operator|(
name|fp
operator|->
name|f_gcflag
operator|&
name|FMARK
operator|)
condition|)
block|{
operator|*
name|fpp
operator|++
operator|=
name|fp
expr_stmt|;
name|nunref
operator|++
expr_stmt|;
name|fp
operator|->
name|f_count
operator|++
expr_stmt|;
block|}
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|sx_sunlock
argument_list|(
operator|&
name|filelist_lock
argument_list|)
expr_stmt|;
comment|/* 	 * for each FD on our hit list, do the following two things 	 */
for|for
control|(
name|i
operator|=
name|nunref
operator|,
name|fpp
operator|=
name|extra_ref
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
operator|++
name|fpp
control|)
block|{
name|struct
name|file
modifier|*
name|tfp
init|=
operator|*
name|fpp
decl_stmt|;
name|FILE_LOCK
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfp
operator|->
name|f_type
operator|==
name|DTYPE_SOCKET
operator|&&
name|tfp
operator|->
name|f_data
operator|!=
name|NULL
condition|)
block|{
name|FILE_UNLOCK
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
name|sorflush
argument_list|(
name|tfp
operator|->
name|f_data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FILE_UNLOCK
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|nunref
operator|,
name|fpp
operator|=
name|extra_ref
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
operator|++
name|fpp
control|)
block|{
name|closef
argument_list|(
operator|*
name|fpp
argument_list|,
operator|(
expr|struct
name|thread
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|unp_recycled
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|extra_ref
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|unp_dispose
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
condition|)
name|unp_scan
argument_list|(
name|m
argument_list|,
name|unp_discard
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|unp_listen
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|unpcb
modifier|*
name|unp
parameter_list|,
name|int
name|backlog
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|UNP_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|error
operator|=
name|solisten_proto_check
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|cru2x
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
operator|&
name|unp
operator|->
name|unp_peercred
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_flags
operator||=
name|UNP_HAVEPCCACHED
expr_stmt|;
name|solisten_proto
argument_list|(
name|so
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
block|}
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unp_scan
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|void
function_decl|(
modifier|*
name|op
function_decl|)
parameter_list|(
name|struct
name|file
modifier|*
parameter_list|)
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|file
modifier|*
modifier|*
name|rp
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cm
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|socklen_t
name|clen
decl_stmt|,
name|datalen
decl_stmt|;
name|int
name|qfds
decl_stmt|;
while|while
condition|(
name|m0
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_type
operator|!=
name|MT_CONTROL
condition|)
continue|continue;
name|cm
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
expr_stmt|;
name|clen
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
while|while
condition|(
name|cm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
operator|*
name|cm
argument_list|)
operator|>
name|clen
operator|||
name|cm
operator|->
name|cmsg_len
operator|>
name|clen
condition|)
break|break;
name|data
operator|=
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|datalen
operator|=
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|cm
operator|->
name|cmsg_len
operator|-
operator|(
name|caddr_t
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cmsg_level
operator|==
name|SOL_SOCKET
operator|&&
name|cm
operator|->
name|cmsg_type
operator|==
name|SCM_RIGHTS
condition|)
block|{
name|qfds
operator|=
name|datalen
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|file
operator|*
argument_list|)
expr_stmt|;
name|rp
operator|=
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qfds
condition|;
name|i
operator|++
control|)
call|(
modifier|*
name|op
call|)
argument_list|(
operator|*
name|rp
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|<
name|clen
condition|)
block|{
name|clen
operator|-=
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
expr_stmt|;
name|cm
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|clen
operator|=
literal|0
expr_stmt|;
name|cm
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|m0
operator|=
name|m0
operator|->
name|m_act
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|unp_mark
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|fp
operator|->
name|f_gcflag
operator|&
name|FMARK
condition|)
return|return;
name|unp_defer
operator|++
expr_stmt|;
name|fp
operator|->
name|f_gcflag
operator||=
operator|(
name|FMARK
operator||
name|FDEFER
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unp_discard
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|)
block|{
name|UNP_LOCK
argument_list|()
expr_stmt|;
name|FILE_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_msgcount
operator|--
expr_stmt|;
name|unp_rights
operator|--
expr_stmt|;
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|UNP_UNLOCK
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|closef
argument_list|(
name|fp
argument_list|,
operator|(
expr|struct
name|thread
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

