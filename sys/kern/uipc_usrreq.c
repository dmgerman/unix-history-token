begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1989, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	From: @(#)uipc_usrreq.c	8.3 (Berkeley) 1/4/94  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_comment
comment|/* XXX must be before<sys/file.h> */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<sys/unpcb.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_zone.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|vm_zone
modifier|*
name|unp_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unp_gen_t
name|unp_gencnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|unp_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|unp_head
name|unp_shead
decl_stmt|,
name|unp_dhead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Unix communications domain.  *  * TODO:  *	SEQPACKET, RDM  *	rethink name space problems  *	need a proper out-of-band  *	lock pushdown  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sockaddr
name|sun_noname
init|=
block|{
sizeof|sizeof
argument_list|(
name|sun_noname
argument_list|)
block|,
name|AF_LOCAL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ino_t
name|unp_ino
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prototype for fake inode numbers */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unp_attach
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unp_detach
name|__P
argument_list|(
operator|(
expr|struct
name|unpcb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unp_bind
name|__P
argument_list|(
operator|(
expr|struct
name|unpcb
operator|*
operator|,
expr|struct
name|sockaddr
operator|*
operator|,
expr|struct
name|thread
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unp_connect
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|,
expr|struct
name|sockaddr
operator|*
operator|,
expr|struct
name|thread
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unp_disconnect
name|__P
argument_list|(
operator|(
expr|struct
name|unpcb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unp_shutdown
name|__P
argument_list|(
operator|(
expr|struct
name|unpcb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unp_drop
name|__P
argument_list|(
operator|(
expr|struct
name|unpcb
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unp_gc
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unp_scan
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
expr|struct
name|file
operator|*
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unp_mark
name|__P
argument_list|(
operator|(
expr|struct
name|file
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unp_discard
name|__P
argument_list|(
operator|(
expr|struct
name|file
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unp_freerights
name|__P
argument_list|(
operator|(
expr|struct
name|file
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unp_internalize
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|,
expr|struct
name|thread
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unp_listen
name|__P
argument_list|(
operator|(
expr|struct
name|unpcb
operator|*
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|uipc_abort
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
init|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|unp
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|unp_drop
argument_list|(
name|unp
argument_list|,
name|ECONNABORTED
argument_list|)
expr_stmt|;
name|unp_detach
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|sotryfree
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_accept
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
init|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|unp
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
comment|/* 	 * Pass back name of connected socket, 	 * if it was bound and we are still connected 	 * (our peer may have closed already!). 	 */
if|if
condition|(
name|unp
operator|->
name|unp_conn
operator|&&
name|unp
operator|->
name|unp_conn
operator|->
name|unp_addr
condition|)
block|{
operator|*
name|nam
operator|=
name|dup_sockaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|unp
operator|->
name|unp_conn
operator|->
name|unp_addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|nam
operator|=
name|dup_sockaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sun_noname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
init|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|unp
operator|!=
literal|0
condition|)
return|return
name|EISCONN
return|;
return|return
name|unp_attach
argument_list|(
name|so
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_bind
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
init|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|unp
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
return|return
name|unp_bind
argument_list|(
name|unp
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_connect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
init|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|unp
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
return|return
name|unp_connect
argument_list|(
name|so
argument_list|,
name|nam
argument_list|,
name|curthread
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_connect2
parameter_list|(
name|struct
name|socket
modifier|*
name|so1
parameter_list|,
name|struct
name|socket
modifier|*
name|so2
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
init|=
name|sotounpcb
argument_list|(
name|so1
argument_list|)
decl_stmt|;
if|if
condition|(
name|unp
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
return|return
name|unp_connect2
argument_list|(
name|so1
argument_list|,
name|so2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* control is EOPNOTSUPP */
end_comment

begin_function
specifier|static
name|int
name|uipc_detach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
init|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|unp
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|unp_detach
argument_list|(
name|unp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_disconnect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
init|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|unp
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|unp_disconnect
argument_list|(
name|unp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_listen
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
init|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|unp
operator|==
literal|0
operator|||
name|unp
operator|->
name|unp_vnode
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
return|return
name|unp_listen
argument_list|(
name|unp
argument_list|,
name|td
operator|->
name|td_proc
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_peeraddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
init|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|unp
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|unp
operator|->
name|unp_conn
operator|&&
name|unp
operator|->
name|unp_conn
operator|->
name|unp_addr
condition|)
operator|*
name|nam
operator|=
name|dup_sockaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|unp
operator|->
name|unp_conn
operator|->
name|unp_addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_rcvd
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
init|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|socket
modifier|*
name|so2
decl_stmt|;
name|u_long
name|newhiwat
decl_stmt|;
if|if
condition|(
name|unp
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
switch|switch
condition|(
name|so
operator|->
name|so_type
condition|)
block|{
case|case
name|SOCK_DGRAM
case|:
name|panic
argument_list|(
literal|"uipc_rcvd DGRAM?"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
name|SOCK_STREAM
case|:
if|if
condition|(
name|unp
operator|->
name|unp_conn
operator|==
literal|0
condition|)
break|break;
name|so2
operator|=
name|unp
operator|->
name|unp_conn
operator|->
name|unp_socket
expr_stmt|;
comment|/* 		 * Adjust backpressure on sender 		 * and wakeup any waiting to write. 		 */
name|so2
operator|->
name|so_snd
operator|.
name|sb_mbmax
operator|+=
name|unp
operator|->
name|unp_mbcnt
operator|-
name|so
operator|->
name|so_rcv
operator|.
name|sb_mbcnt
expr_stmt|;
name|unp
operator|->
name|unp_mbcnt
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mbcnt
expr_stmt|;
name|newhiwat
operator|=
name|so2
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|+
name|unp
operator|->
name|unp_cc
operator|-
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
expr_stmt|;
operator|(
name|void
operator|)
name|chgsbsize
argument_list|(
name|so2
operator|->
name|so_cred
operator|->
name|cr_uidinfo
argument_list|,
operator|&
name|so2
operator|->
name|so_snd
operator|.
name|sb_hiwat
argument_list|,
name|newhiwat
argument_list|,
name|RLIM_INFINITY
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_cc
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
expr_stmt|;
name|sowwakeup
argument_list|(
name|so2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"uipc_rcvd unknown socktype"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* pru_rcvoob is EOPNOTSUPP */
end_comment

begin_function
specifier|static
name|int
name|uipc_send
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|unpcb
modifier|*
name|unp
init|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|socket
modifier|*
name|so2
decl_stmt|;
name|u_long
name|newhiwat
decl_stmt|;
if|if
condition|(
name|unp
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|flags
operator|&
name|PRUS_OOB
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|control
operator|&&
operator|(
name|error
operator|=
name|unp_internalize
argument_list|(
operator|&
name|control
argument_list|,
name|td
argument_list|)
operator|)
condition|)
goto|goto
name|release
goto|;
switch|switch
condition|(
name|so
operator|->
name|so_type
condition|)
block|{
case|case
name|SOCK_DGRAM
case|:
block|{
name|struct
name|sockaddr
modifier|*
name|from
decl_stmt|;
if|if
condition|(
name|nam
condition|)
block|{
if|if
condition|(
name|unp
operator|->
name|unp_conn
condition|)
block|{
name|error
operator|=
name|EISCONN
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|unp_connect
argument_list|(
name|so
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|unp
operator|->
name|unp_conn
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
break|break;
block|}
block|}
name|so2
operator|=
name|unp
operator|->
name|unp_conn
operator|->
name|unp_socket
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_addr
condition|)
name|from
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|unp
operator|->
name|unp_addr
expr_stmt|;
else|else
name|from
operator|=
operator|&
name|sun_noname
expr_stmt|;
if|if
condition|(
name|sbappendaddr
argument_list|(
operator|&
name|so2
operator|->
name|so_rcv
argument_list|,
name|from
argument_list|,
name|m
argument_list|,
name|control
argument_list|)
condition|)
block|{
name|sorwakeup
argument_list|(
name|so2
argument_list|)
expr_stmt|;
name|m
operator|=
literal|0
expr_stmt|;
name|control
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ENOBUFS
expr_stmt|;
if|if
condition|(
name|nam
condition|)
name|unp_disconnect
argument_list|(
name|unp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SOCK_STREAM
case|:
comment|/* Connect if not connected yet. */
comment|/* 		 * Note: A better implementation would complain 		 * if not equal to the peer's address. 		 */
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nam
condition|)
block|{
name|error
operator|=
name|unp_connect
argument_list|(
name|so
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* XXX */
block|}
else|else
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_CANTSENDMORE
condition|)
block|{
name|error
operator|=
name|EPIPE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|unp
operator|->
name|unp_conn
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"uipc_send connected but no connection?"
argument_list|)
expr_stmt|;
name|so2
operator|=
name|unp
operator|->
name|unp_conn
operator|->
name|unp_socket
expr_stmt|;
comment|/* 		 * Send to paired receive port, and then reduce 		 * send buffer hiwater marks to maintain backpressure. 		 * Wake up readers. 		 */
if|if
condition|(
name|control
condition|)
block|{
if|if
condition|(
name|sbappendcontrol
argument_list|(
operator|&
name|so2
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|,
name|control
argument_list|)
condition|)
name|control
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|sbappend
argument_list|(
operator|&
name|so2
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_mbmax
operator|-=
name|so2
operator|->
name|so_rcv
operator|.
name|sb_mbcnt
operator|-
name|unp
operator|->
name|unp_conn
operator|->
name|unp_mbcnt
expr_stmt|;
name|unp
operator|->
name|unp_conn
operator|->
name|unp_mbcnt
operator|=
name|so2
operator|->
name|so_rcv
operator|.
name|sb_mbcnt
expr_stmt|;
name|newhiwat
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|-
operator|(
name|so2
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|-
name|unp
operator|->
name|unp_conn
operator|->
name|unp_cc
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|chgsbsize
argument_list|(
name|so
operator|->
name|so_cred
operator|->
name|cr_uidinfo
argument_list|,
operator|&
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
argument_list|,
name|newhiwat
argument_list|,
name|RLIM_INFINITY
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_conn
operator|->
name|unp_cc
operator|=
name|so2
operator|->
name|so_rcv
operator|.
name|sb_cc
expr_stmt|;
name|sorwakeup
argument_list|(
name|so2
argument_list|)
expr_stmt|;
name|m
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"uipc_send unknown socktype"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * SEND_EOF is equivalent to a SEND followed by 	 * a SHUTDOWN. 	 */
if|if
condition|(
name|flags
operator|&
name|PRUS_EOF
condition|)
block|{
name|socantsendmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|unp_shutdown
argument_list|(
name|unp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|control
operator|&&
name|error
operator|!=
literal|0
condition|)
name|unp_dispose
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|release
label|:
if|if
condition|(
name|control
condition|)
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_sense
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|stat
modifier|*
name|sb
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
init|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|struct
name|socket
modifier|*
name|so2
decl_stmt|;
if|if
condition|(
name|unp
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|sb
operator|->
name|st_blksize
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_STREAM
operator|&&
name|unp
operator|->
name|unp_conn
operator|!=
literal|0
condition|)
block|{
name|so2
operator|=
name|unp
operator|->
name|unp_conn
operator|->
name|unp_socket
expr_stmt|;
name|sb
operator|->
name|st_blksize
operator|+=
name|so2
operator|->
name|so_rcv
operator|.
name|sb_cc
expr_stmt|;
block|}
name|sb
operator|->
name|st_dev
operator|=
name|NOUDEV
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_ino
operator|==
literal|0
condition|)
name|unp
operator|->
name|unp_ino
operator|=
name|unp_ino
operator|++
expr_stmt|;
name|sb
operator|->
name|st_ino
operator|=
name|unp
operator|->
name|unp_ino
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_shutdown
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
init|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|unp
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|socantsendmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|unp_shutdown
argument_list|(
name|unp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_sockaddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
init|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
if|if
condition|(
name|unp
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|unp
operator|->
name|unp_addr
condition|)
operator|*
name|nam
operator|=
name|dup_sockaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|unp
operator|->
name|unp_addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
operator|*
name|nam
operator|=
name|dup_sockaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sun_noname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|pr_usrreqs
name|uipc_usrreqs
init|=
block|{
name|uipc_abort
block|,
name|uipc_accept
block|,
name|uipc_attach
block|,
name|uipc_bind
block|,
name|uipc_connect
block|,
name|uipc_connect2
block|,
name|pru_control_notsupp
block|,
name|uipc_detach
block|,
name|uipc_disconnect
block|,
name|uipc_listen
block|,
name|uipc_peeraddr
block|,
name|uipc_rcvd
block|,
name|pru_rcvoob_notsupp
block|,
name|uipc_send
block|,
name|uipc_sense
block|,
name|uipc_shutdown
block|,
name|uipc_sockaddr
block|,
name|sosend
block|,
name|soreceive
block|,
name|sopoll
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|uipc_ctloutput
parameter_list|(
name|so
parameter_list|,
name|sopt
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockopt
modifier|*
name|sopt
decl_stmt|;
block|{
name|struct
name|unpcb
modifier|*
name|unp
init|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_dir
condition|)
block|{
case|case
name|SOPT_GET
case|:
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|LOCAL_PEERCRED
case|:
if|if
condition|(
name|unp
operator|->
name|unp_flags
operator|&
name|UNP_HAVEPC
condition|)
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|unp
operator|->
name|unp_peercred
argument_list|,
sizeof|sizeof
argument_list|(
name|unp
operator|->
name|unp_peercred
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_STREAM
condition|)
name|error
operator|=
name|ENOTCONN
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SOPT_SET
case|:
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Both send and receive buffers are allocated PIPSIZ bytes of buffering  * for stream sockets, although the total for sender and receiver is  * actually only PIPSIZ.  * Datagram sockets really use the sendspace as the maximum datagram size,  * and don't really want to reserve the sendspace.  Their recvspace should  * be large enough for at least one max-size datagram plus address.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PIPSIZ
end_ifndef

begin_define
define|#
directive|define
name|PIPSIZ
value|8192
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|u_long
name|unpst_sendspace
init|=
name|PIPSIZ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|unpst_recvspace
init|=
name|PIPSIZ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|unpdg_sendspace
init|=
literal|2
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* really max datagram size */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|unpdg_recvspace
init|=
literal|4
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unp_rights
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file descriptors in flight */
end_comment

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_local_stream
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_local_stream
argument_list|,
name|OID_AUTO
argument_list|,
name|sendspace
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unpst_sendspace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_local_stream
argument_list|,
name|OID_AUTO
argument_list|,
name|recvspace
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unpst_recvspace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_local_dgram
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_local_dgram
argument_list|,
name|OID_AUTO
argument_list|,
name|maxdgram
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unpdg_sendspace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_local_dgram
argument_list|,
name|OID_AUTO
argument_list|,
name|recvspace
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unpdg_recvspace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_local
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_local
argument_list|,
name|OID_AUTO
argument_list|,
name|inflight
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|unp_rights
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|unp_attach
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
specifier|register
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|==
literal|0
operator|||
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|so
operator|->
name|so_type
condition|)
block|{
case|case
name|SOCK_STREAM
case|:
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|unpst_sendspace
argument_list|,
name|unpst_recvspace
argument_list|)
expr_stmt|;
break|break;
case|case
name|SOCK_DGRAM
case|:
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|unpdg_sendspace
argument_list|,
name|unpdg_recvspace
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"unp_attach"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|unp
operator|=
name|zalloc
argument_list|(
name|unp_zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|bzero
argument_list|(
name|unp
argument_list|,
sizeof|sizeof
expr|*
name|unp
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_gencnt
operator|=
operator|++
name|unp_gencnt
expr_stmt|;
name|unp_count
operator|++
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|unp
operator|->
name|unp_refs
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_socket
operator|=
name|so
expr_stmt|;
name|FILEDESC_LOCK
argument_list|(
name|curproc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_rvnode
operator|=
name|curthread
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_rdir
expr_stmt|;
name|FILEDESC_UNLOCK
argument_list|(
name|curproc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_DGRAM
condition|?
operator|&
name|unp_dhead
else|:
operator|&
name|unp_shead
argument_list|,
name|unp
argument_list|,
name|unp_link
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_pcb
operator|=
operator|(
name|caddr_t
operator|)
name|unp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unp_detach
parameter_list|(
name|unp
parameter_list|)
specifier|register
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
block|{
name|LIST_REMOVE
argument_list|(
name|unp
argument_list|,
name|unp_link
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_gencnt
operator|=
operator|++
name|unp_gencnt
expr_stmt|;
operator|--
name|unp_count
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_vnode
condition|)
block|{
name|unp
operator|->
name|unp_vnode
operator|->
name|v_socket
operator|=
literal|0
expr_stmt|;
name|vrele
argument_list|(
name|unp
operator|->
name|unp_vnode
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_vnode
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|unp
operator|->
name|unp_conn
condition|)
name|unp_disconnect
argument_list|(
name|unp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|unp
operator|->
name|unp_refs
argument_list|)
condition|)
name|unp_drop
argument_list|(
name|LIST_FIRST
argument_list|(
operator|&
name|unp
operator|->
name|unp_refs
argument_list|)
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
name|soisdisconnected
argument_list|(
name|unp
operator|->
name|unp_socket
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_socket
operator|->
name|so_pcb
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|unp_rights
condition|)
block|{
comment|/* 		 * Normally the receive buffer is flushed later, 		 * in sofree, but if our receive buffer holds references 		 * to descriptors that are now garbage, we will dispose 		 * of those descriptor references after the garbage collector 		 * gets them (resulting in a "panic: closef: count< 0"). 		 */
name|sorflush
argument_list|(
name|unp
operator|->
name|unp_socket
argument_list|)
expr_stmt|;
name|unp_gc
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|unp
operator|->
name|unp_addr
condition|)
name|FREE
argument_list|(
name|unp
operator|->
name|unp_addr
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|zfree
argument_list|(
name|unp_zone
argument_list|,
name|unp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|unp_bind
parameter_list|(
name|unp
parameter_list|,
name|nam
parameter_list|,
name|td
parameter_list|)
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|nam
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|sockaddr_un
modifier|*
name|soun
init|=
operator|(
expr|struct
name|sockaddr_un
operator|*
operator|)
name|nam
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|namelen
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_vnode
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|namelen
operator|=
name|soun
operator|->
name|sun_len
operator|-
name|offsetof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|,
name|sun_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|namelen
operator|<=
literal|0
condition|)
return|return
name|EINVAL
return|;
name|buf
operator|=
name|malloc
argument_list|(
name|SOCK_MAXADDRLEN
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|soun
operator|->
name|sun_path
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|buf
index|[
name|namelen
index|]
operator|=
literal|0
expr_stmt|;
comment|/* null-terminate the string */
name|restart
label|:
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|CREATE
argument_list|,
name|NOFOLLOW
operator||
name|LOCKPARENT
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|buf
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* SHOULD BE ABLE TO ADOPT EXISTING AND wakeup() ALA FIFO's */
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|NULL
operator|||
name|vn_start_write
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|,
operator|&
name|mp
argument_list|,
name|V_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|.
name|ni_dvp
operator|==
name|vp
condition|)
name|vrele
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
block|{
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
block|}
name|error
operator|=
name|vn_start_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|mp
argument_list|,
name|V_XSLEEP
operator||
name|PCATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
goto|goto
name|restart
goto|;
block|}
name|VATTR_NULL
argument_list|(
operator|&
name|vattr
argument_list|)
expr_stmt|;
name|vattr
operator|.
name|va_type
operator|=
name|VSOCK
expr_stmt|;
name|FILEDESC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
name|vattr
operator|.
name|va_mode
operator|=
operator|(
name|ACCESSPERMS
operator|&
operator|~
name|td
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_cmask
operator|)
expr_stmt|;
name|FILEDESC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
name|VOP_LEASE
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|LEASE_WRITE
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_CREATE
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|,
operator|&
name|nd
operator|.
name|ni_vp
argument_list|,
operator|&
name|nd
operator|.
name|ni_cnd
argument_list|,
operator|&
name|vattr
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|vp
operator|->
name|v_socket
operator|=
name|unp
operator|->
name|unp_socket
expr_stmt|;
name|unp
operator|->
name|unp_vnode
operator|=
name|vp
expr_stmt|;
name|unp
operator|->
name|unp_addr
operator|=
operator|(
expr|struct
name|sockaddr_un
operator|*
operator|)
name|dup_sockaddr
argument_list|(
name|nam
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unp_connect
parameter_list|(
name|so
parameter_list|,
name|nam
parameter_list|,
name|td
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|nam
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
specifier|register
name|struct
name|sockaddr_un
modifier|*
name|soun
init|=
operator|(
expr|struct
name|sockaddr_un
operator|*
operator|)
name|nam
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so2
decl_stmt|,
modifier|*
name|so3
decl_stmt|;
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|,
modifier|*
name|unp3
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|char
name|buf
index|[
name|SOCK_MAXADDRLEN
index|]
decl_stmt|;
name|len
operator|=
name|nam
operator|->
name|sa_len
operator|-
name|offsetof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|,
name|sun_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
name|EINVAL
return|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|soun
operator|->
name|sun_path
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|buf
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VSOCK
condition|)
block|{
name|error
operator|=
name|ENOTSOCK
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VWRITE
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|so2
operator|=
name|vp
operator|->
name|v_socket
expr_stmt|;
if|if
condition|(
name|so2
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ECONNREFUSED
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|so
operator|->
name|so_type
operator|!=
name|so2
operator|->
name|so_type
condition|)
block|{
name|error
operator|=
name|EPROTOTYPE
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
condition|)
block|{
if|if
condition|(
operator|(
name|so2
operator|->
name|so_options
operator|&
name|SO_ACCEPTCONN
operator|)
operator|==
literal|0
operator|||
operator|(
name|so3
operator|=
name|sonewconn
argument_list|(
name|so2
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ECONNREFUSED
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|unp2
operator|=
name|sotounpcb
argument_list|(
name|so2
argument_list|)
expr_stmt|;
name|unp3
operator|=
name|sotounpcb
argument_list|(
name|so3
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp2
operator|->
name|unp_addr
condition|)
name|unp3
operator|->
name|unp_addr
operator|=
operator|(
expr|struct
name|sockaddr_un
operator|*
operator|)
name|dup_sockaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|unp2
operator|->
name|unp_addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * unp_peercred management: 		 * 		 * The connecter's (client's) credentials are copied 		 * from its process structure at the time of connect() 		 * (which is now). 		 */
name|cru2x
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
operator|&
name|unp3
operator|->
name|unp_peercred
argument_list|)
expr_stmt|;
name|unp3
operator|->
name|unp_flags
operator||=
name|UNP_HAVEPC
expr_stmt|;
comment|/* 		 * The receiver's (server's) credentials are copied 		 * from the unp_peercred member of socket on which the 		 * former called listen(); unp_listen() cached that 		 * process's credentials at that time so we can use 		 * them now. 		 */
name|KASSERT
argument_list|(
name|unp2
operator|->
name|unp_flags
operator|&
name|UNP_HAVEPCCACHED
argument_list|,
operator|(
literal|"unp_connect: listener without cached peercred"
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|unp
operator|->
name|unp_peercred
argument_list|,
operator|&
name|unp2
operator|->
name|unp_peercred
argument_list|,
sizeof|sizeof
argument_list|(
name|unp
operator|->
name|unp_peercred
argument_list|)
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_flags
operator||=
name|UNP_HAVEPC
expr_stmt|;
name|so2
operator|=
name|so3
expr_stmt|;
block|}
name|error
operator|=
name|unp_connect2
argument_list|(
name|so
argument_list|,
name|so2
argument_list|)
expr_stmt|;
name|bad
label|:
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|unp_connect2
parameter_list|(
name|so
parameter_list|,
name|so2
parameter_list|)
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so2
decl_stmt|;
block|{
specifier|register
name|struct
name|unpcb
modifier|*
name|unp
init|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|unpcb
modifier|*
name|unp2
decl_stmt|;
if|if
condition|(
name|so2
operator|->
name|so_type
operator|!=
name|so
operator|->
name|so_type
condition|)
return|return
operator|(
name|EPROTOTYPE
operator|)
return|;
name|unp2
operator|=
name|sotounpcb
argument_list|(
name|so2
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_conn
operator|=
name|unp2
expr_stmt|;
switch|switch
condition|(
name|so
operator|->
name|so_type
condition|)
block|{
case|case
name|SOCK_DGRAM
case|:
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|unp2
operator|->
name|unp_refs
argument_list|,
name|unp
argument_list|,
name|unp_reflink
argument_list|)
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
break|break;
case|case
name|SOCK_STREAM
case|:
name|unp2
operator|->
name|unp_conn
operator|=
name|unp
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|soisconnected
argument_list|(
name|so2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"unp_connect2"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unp_disconnect
parameter_list|(
name|unp
parameter_list|)
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
block|{
specifier|register
name|struct
name|unpcb
modifier|*
name|unp2
init|=
name|unp
operator|->
name|unp_conn
decl_stmt|;
if|if
condition|(
name|unp2
operator|==
literal|0
condition|)
return|return;
name|unp
operator|->
name|unp_conn
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|unp
operator|->
name|unp_socket
operator|->
name|so_type
condition|)
block|{
case|case
name|SOCK_DGRAM
case|:
name|LIST_REMOVE
argument_list|(
name|unp
argument_list|,
name|unp_reflink
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_socket
operator|->
name|so_state
operator|&=
operator|~
name|SS_ISCONNECTED
expr_stmt|;
break|break;
case|case
name|SOCK_STREAM
case|:
name|soisdisconnected
argument_list|(
name|unp
operator|->
name|unp_socket
argument_list|)
expr_stmt|;
name|unp2
operator|->
name|unp_conn
operator|=
literal|0
expr_stmt|;
name|soisdisconnected
argument_list|(
name|unp2
operator|->
name|unp_socket
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_function
name|void
name|unp_abort
parameter_list|(
name|unp
parameter_list|)
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
block|{
name|unp_detach
argument_list|(
name|unp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|unp_pcblist
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
modifier|*
name|unp_list
decl_stmt|;
name|unp_gen_t
name|gencnt
decl_stmt|;
name|struct
name|xunpgen
modifier|*
name|xug
decl_stmt|;
name|struct
name|unp_head
modifier|*
name|head
decl_stmt|;
name|struct
name|xunpcb
modifier|*
name|xu
decl_stmt|;
name|head
operator|=
operator|(
operator|(
name|intptr_t
operator|)
name|arg1
operator|==
name|SOCK_DGRAM
condition|?
operator|&
name|unp_dhead
else|:
operator|&
name|unp_shead
operator|)
expr_stmt|;
comment|/* 	 * The process of preparing the PCB list is too time-consuming and 	 * resource-intensive to repeat twice on every request. 	 */
if|if
condition|(
name|req
operator|->
name|oldptr
operator|==
literal|0
condition|)
block|{
name|n
operator|=
name|unp_count
expr_stmt|;
name|req
operator|->
name|oldidx
operator|=
literal|2
operator|*
operator|(
sizeof|sizeof
expr|*
name|xug
operator|)
operator|+
operator|(
name|n
operator|+
name|n
operator|/
literal|8
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|xunpcb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|req
operator|->
name|newptr
operator|!=
literal|0
condition|)
return|return
name|EPERM
return|;
comment|/* 	 * OK, now we're committed to doing something. 	 */
name|xug
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|xug
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|gencnt
operator|=
name|unp_gencnt
expr_stmt|;
name|n
operator|=
name|unp_count
expr_stmt|;
name|xug
operator|->
name|xug_len
operator|=
sizeof|sizeof
expr|*
name|xug
expr_stmt|;
name|xug
operator|->
name|xug_count
operator|=
name|n
expr_stmt|;
name|xug
operator|->
name|xug_gen
operator|=
name|gencnt
expr_stmt|;
name|xug
operator|->
name|xug_sogen
operator|=
name|so_gencnt
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|xug
argument_list|,
sizeof|sizeof
expr|*
name|xug
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|xug
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|unp_list
operator|=
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
expr|*
name|unp_list
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|unp
operator|=
name|LIST_FIRST
argument_list|(
name|head
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|unp
operator|&&
name|i
operator|<
name|n
condition|;
name|unp
operator|=
name|LIST_NEXT
argument_list|(
name|unp
argument_list|,
name|unp_link
argument_list|)
control|)
block|{
if|if
condition|(
name|unp
operator|->
name|unp_gencnt
operator|<=
name|gencnt
condition|)
block|{
if|if
condition|(
name|cr_cansee
argument_list|(
name|req
operator|->
name|td
operator|->
name|td_ucred
argument_list|,
name|unp
operator|->
name|unp_socket
operator|->
name|so_cred
argument_list|)
condition|)
continue|continue;
name|unp_list
index|[
name|i
operator|++
index|]
operator|=
name|unp
expr_stmt|;
block|}
block|}
name|n
operator|=
name|i
expr_stmt|;
comment|/* in case we lost some during malloc */
name|error
operator|=
literal|0
expr_stmt|;
name|xu
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|xu
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|unp
operator|=
name|unp_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_gencnt
operator|<=
name|gencnt
condition|)
block|{
name|xu
operator|->
name|xu_len
operator|=
sizeof|sizeof
expr|*
name|xu
expr_stmt|;
name|xu
operator|->
name|xu_unpp
operator|=
name|unp
expr_stmt|;
comment|/* 			 * XXX - need more locking here to protect against 			 * connect/disconnect races for SMP. 			 */
if|if
condition|(
name|unp
operator|->
name|unp_addr
condition|)
name|bcopy
argument_list|(
name|unp
operator|->
name|unp_addr
argument_list|,
operator|&
name|xu
operator|->
name|xu_addr
argument_list|,
name|unp
operator|->
name|unp_addr
operator|->
name|sun_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_conn
operator|&&
name|unp
operator|->
name|unp_conn
operator|->
name|unp_addr
condition|)
name|bcopy
argument_list|(
name|unp
operator|->
name|unp_conn
operator|->
name|unp_addr
argument_list|,
operator|&
name|xu
operator|->
name|xu_caddr
argument_list|,
name|unp
operator|->
name|unp_conn
operator|->
name|unp_addr
operator|->
name|sun_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|unp
argument_list|,
operator|&
name|xu
operator|->
name|xu_unp
argument_list|,
sizeof|sizeof
expr|*
name|unp
argument_list|)
expr_stmt|;
name|sotoxsocket
argument_list|(
name|unp
operator|->
name|unp_socket
argument_list|,
operator|&
name|xu
operator|->
name|xu_socket
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|xu
argument_list|,
sizeof|sizeof
expr|*
name|xu
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|xu
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* 		 * Give the user an updated idea of our state. 		 * If the generation differs from what we told 		 * her before, she knows that something happened 		 * while we were processing this request, and it 		 * might be necessary to retry. 		 */
name|xug
operator|->
name|xug_gen
operator|=
name|unp_gencnt
expr_stmt|;
name|xug
operator|->
name|xug_sogen
operator|=
name|so_gencnt
expr_stmt|;
name|xug
operator|->
name|xug_count
operator|=
name|unp_count
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|xug
argument_list|,
sizeof|sizeof
expr|*
name|xug
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|unp_list
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xug
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_local_dgram
argument_list|,
name|OID_AUTO
argument_list|,
name|pcblist
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|long
operator|)
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|,
name|unp_pcblist
argument_list|,
literal|"S,xunpcb"
argument_list|,
literal|"List of active local datagram sockets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_local_stream
argument_list|,
name|OID_AUTO
argument_list|,
name|pcblist
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|long
operator|)
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
name|unp_pcblist
argument_list|,
literal|"S,xunpcb"
argument_list|,
literal|"List of active local stream sockets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|unp_shutdown
parameter_list|(
name|unp
parameter_list|)
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_socket
operator|->
name|so_type
operator|==
name|SOCK_STREAM
operator|&&
name|unp
operator|->
name|unp_conn
operator|&&
operator|(
name|so
operator|=
name|unp
operator|->
name|unp_conn
operator|->
name|unp_socket
operator|)
condition|)
name|socantrcvmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unp_drop
parameter_list|(
name|unp
parameter_list|,
name|errno
parameter_list|)
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|int
name|errno
decl_stmt|;
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|unp
operator|->
name|unp_socket
decl_stmt|;
name|so
operator|->
name|so_error
operator|=
name|errno
expr_stmt|;
name|unp_disconnect
argument_list|(
name|unp
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_function
name|void
name|unp_drain
parameter_list|()
block|{  }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|unp_freerights
parameter_list|(
name|rp
parameter_list|,
name|fdcount
parameter_list|)
name|struct
name|file
modifier|*
modifier|*
name|rp
decl_stmt|;
name|int
name|fdcount
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fdcount
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
operator|*
name|rp
expr_stmt|;
comment|/* 		 * zero the pointer before calling 		 * unp_discard since it may end up 		 * in unp_gc().. 		 */
operator|*
name|rp
operator|++
operator|=
literal|0
expr_stmt|;
name|unp_discard
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|unp_externalize
parameter_list|(
name|control
parameter_list|,
name|controlp
parameter_list|)
name|struct
name|mbuf
modifier|*
name|control
decl_stmt|,
decl|*
modifier|*
name|controlp
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
comment|/* XXX */
name|struct
name|cmsghdr
modifier|*
name|cm
init|=
name|mtod
argument_list|(
name|control
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|fdp
decl_stmt|;
name|struct
name|file
modifier|*
modifier|*
name|rp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|socklen_t
name|clen
init|=
name|control
operator|->
name|m_len
decl_stmt|,
name|datalen
decl_stmt|;
name|int
name|error
decl_stmt|,
name|newfds
decl_stmt|;
name|int
name|f
decl_stmt|;
name|u_int
name|newlen
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
comment|/* controlp == NULL => free control messages */
operator|*
name|controlp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|cm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
operator|*
name|cm
argument_list|)
operator|>
name|clen
operator|||
name|cm
operator|->
name|cmsg_len
operator|>
name|clen
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|data
operator|=
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|datalen
operator|=
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|cm
operator|->
name|cmsg_len
operator|-
operator|(
name|caddr_t
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cmsg_level
operator|==
name|SOL_SOCKET
operator|&&
name|cm
operator|->
name|cmsg_type
operator|==
name|SCM_RIGHTS
condition|)
block|{
name|newfds
operator|=
name|datalen
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|file
operator|*
argument_list|)
expr_stmt|;
name|rp
operator|=
name|data
expr_stmt|;
comment|/* If we're not outputting the discriptors free them. */
if|if
condition|(
name|error
operator|||
name|controlp
operator|==
name|NULL
condition|)
block|{
name|unp_freerights
argument_list|(
name|rp
argument_list|,
name|newfds
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|FILEDESC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
comment|/* if the new FD's will not fit free them.  */
if|if
condition|(
operator|!
name|fdavail
argument_list|(
name|td
argument_list|,
name|newfds
argument_list|)
condition|)
block|{
name|FILEDESC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
name|unp_freerights
argument_list|(
name|rp
argument_list|,
name|newfds
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* 			 * now change each pointer to an fd in the global 			 * table to an integer that is the index to the 			 * local fd table entry that we set up to point 			 * to the global one we are transferring. 			 */
name|newlen
operator|=
name|newfds
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|*
name|controlp
operator|=
name|sbcreatecontrol
argument_list|(
name|NULL
argument_list|,
name|newlen
argument_list|,
name|SCM_RIGHTS
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|controlp
operator|==
name|NULL
condition|)
block|{
name|FILEDESC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
name|error
operator|=
name|E2BIG
expr_stmt|;
name|unp_freerights
argument_list|(
name|rp
argument_list|,
name|newfds
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|fdp
operator|=
operator|(
name|int
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|mtod
argument_list|(
operator|*
name|controlp
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|newfds
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fdalloc
argument_list|(
name|td
argument_list|,
literal|0
argument_list|,
operator|&
name|f
argument_list|)
condition|)
name|panic
argument_list|(
literal|"unp_externalize fdalloc failed"
argument_list|)
expr_stmt|;
name|fp
operator|=
operator|*
name|rp
operator|++
expr_stmt|;
name|td
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_ofiles
index|[
name|f
index|]
operator|=
name|fp
expr_stmt|;
name|FILE_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_msgcount
operator|--
expr_stmt|;
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|unp_rights
operator|--
expr_stmt|;
operator|*
name|fdp
operator|++
operator|=
name|f
expr_stmt|;
block|}
name|FILEDESC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We can just copy anything else across */
if|if
condition|(
name|error
operator|||
name|controlp
operator|==
name|NULL
condition|)
goto|goto
name|next
goto|;
operator|*
name|controlp
operator|=
name|sbcreatecontrol
argument_list|(
name|NULL
argument_list|,
name|datalen
argument_list|,
name|cm
operator|->
name|cmsg_type
argument_list|,
name|cm
operator|->
name|cmsg_level
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|controlp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|bcopy
argument_list|(
name|data
argument_list|,
name|CMSG_DATA
argument_list|(
name|mtod
argument_list|(
operator|*
name|controlp
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
name|controlp
operator|=
operator|&
operator|(
operator|*
name|controlp
operator|)
operator|->
name|m_next
expr_stmt|;
name|next
label|:
if|if
condition|(
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|<
name|clen
condition|)
block|{
name|clen
operator|-=
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
expr_stmt|;
name|cm
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|clen
operator|=
literal|0
expr_stmt|;
name|cm
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_function
name|void
name|unp_init
parameter_list|(
name|void
parameter_list|)
block|{
name|unp_zone
operator|=
name|zinit
argument_list|(
literal|"unpcb"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unpcb
argument_list|)
argument_list|,
name|nmbclusters
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp_zone
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"unp_init"
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|unp_dhead
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|unp_shead
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MIN
end_ifndef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<(b))?(a):(b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|unp_internalize
parameter_list|(
name|controlp
parameter_list|,
name|td
parameter_list|)
name|struct
name|mbuf
modifier|*
modifier|*
name|controlp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|control
init|=
operator|*
name|controlp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|filedesc
modifier|*
name|fdescp
init|=
name|p
operator|->
name|p_fd
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cm
init|=
name|mtod
argument_list|(
name|control
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
decl_stmt|;
name|struct
name|cmsgcred
modifier|*
name|cmcred
decl_stmt|;
name|struct
name|file
modifier|*
modifier|*
name|rp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tv
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|,
modifier|*
name|fdp
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|socklen_t
name|clen
init|=
name|control
operator|->
name|m_len
decl_stmt|,
name|datalen
decl_stmt|;
name|int
name|error
decl_stmt|,
name|oldfds
decl_stmt|;
name|u_int
name|newlen
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
operator|*
name|controlp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|cm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
operator|*
name|cm
argument_list|)
operator|>
name|clen
operator|||
name|cm
operator|->
name|cmsg_level
operator|!=
name|SOL_SOCKET
operator|||
name|cm
operator|->
name|cmsg_len
operator|>
name|clen
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|data
operator|=
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|datalen
operator|=
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|cm
operator|->
name|cmsg_len
operator|-
operator|(
name|caddr_t
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|cm
operator|->
name|cmsg_type
condition|)
block|{
comment|/* 		 * Fill in credential information. 		 */
case|case
name|SCM_CREDS
case|:
operator|*
name|controlp
operator|=
name|sbcreatecontrol
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cmcred
argument_list|)
argument_list|,
name|SCM_CREDS
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|controlp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cmcred
operator|=
operator|(
expr|struct
name|cmsgcred
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|mtod
argument_list|(
operator|*
name|controlp
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|cmcred
operator|->
name|cmcred_pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|cmcred
operator|->
name|cmcred_uid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_ruid
expr_stmt|;
name|cmcred
operator|->
name|cmcred_gid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_rgid
expr_stmt|;
name|cmcred
operator|->
name|cmcred_euid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_uid
expr_stmt|;
name|cmcred
operator|->
name|cmcred_ngroups
operator|=
name|MIN
argument_list|(
name|td
operator|->
name|td_ucred
operator|->
name|cr_ngroups
argument_list|,
name|CMGROUP_MAX
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmcred
operator|->
name|cmcred_ngroups
condition|;
name|i
operator|++
control|)
name|cmcred
operator|->
name|cmcred_groups
index|[
name|i
index|]
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_groups
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|SCM_RIGHTS
case|:
name|oldfds
operator|=
name|datalen
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/* 			 * check that all the FDs passed in refer to legal files 			 * If not, reject the entire operation. 			 */
name|fdp
operator|=
name|data
expr_stmt|;
name|FILEDESC_LOCK
argument_list|(
name|fdescp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldfds
condition|;
name|i
operator|++
control|)
block|{
name|fd
operator|=
operator|*
name|fdp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|fd
operator|>=
name|fdescp
operator|->
name|fd_nfiles
operator|||
name|fdescp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
operator|==
name|NULL
condition|)
block|{
name|FILEDESC_UNLOCK
argument_list|(
name|fdescp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBADF
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 			 * Now replace the integer FDs with pointers to 			 * the associated global file table entry.. 			 */
name|newlen
operator|=
name|oldfds
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|file
operator|*
argument_list|)
expr_stmt|;
operator|*
name|controlp
operator|=
name|sbcreatecontrol
argument_list|(
name|NULL
argument_list|,
name|newlen
argument_list|,
name|SCM_RIGHTS
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|controlp
operator|==
name|NULL
condition|)
block|{
name|FILEDESC_UNLOCK
argument_list|(
name|fdescp
argument_list|)
expr_stmt|;
name|error
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fdp
operator|=
name|data
expr_stmt|;
name|rp
operator|=
operator|(
expr|struct
name|file
operator|*
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|mtod
argument_list|(
operator|*
name|controlp
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldfds
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
name|fdescp
operator|->
name|fd_ofiles
index|[
operator|*
name|fdp
operator|++
index|]
expr_stmt|;
operator|*
name|rp
operator|++
operator|=
name|fp
expr_stmt|;
name|FILE_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_count
operator|++
expr_stmt|;
name|fp
operator|->
name|f_msgcount
operator|++
expr_stmt|;
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|unp_rights
operator|++
expr_stmt|;
block|}
name|FILEDESC_UNLOCK
argument_list|(
name|fdescp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCM_TIMESTAMP
case|:
operator|*
name|controlp
operator|=
name|sbcreatecontrol
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tv
argument_list|)
argument_list|,
name|SCM_TIMESTAMP
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|controlp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|tv
operator|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|mtod
argument_list|(
operator|*
name|controlp
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
name|tv
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|controlp
operator|=
operator|&
operator|(
operator|*
name|controlp
operator|)
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|<
name|clen
condition|)
block|{
name|clen
operator|-=
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
expr_stmt|;
name|cm
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|clen
operator|=
literal|0
expr_stmt|;
name|cm
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|out
label|:
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|unp_defer
decl_stmt|,
name|unp_gcing
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|unp_gc
parameter_list|()
block|{
specifier|register
name|struct
name|file
modifier|*
name|fp
decl_stmt|,
modifier|*
name|nextfp
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|file
modifier|*
modifier|*
name|extra_ref
decl_stmt|,
modifier|*
modifier|*
name|fpp
decl_stmt|;
name|int
name|nunref
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|unp_gcing
condition|)
return|return;
name|unp_gcing
operator|=
literal|1
expr_stmt|;
name|unp_defer
operator|=
literal|0
expr_stmt|;
comment|/*  	 * before going through all this, set all FDs to  	 * be NOT defered and NOT externally accessible 	 */
name|sx_slock
argument_list|(
operator|&
name|filelist_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|fp
argument_list|,
argument|&filehead
argument_list|,
argument|f_list
argument_list|)
name|fp
operator|->
name|f_gcflag
operator|&=
operator|~
operator|(
name|FMARK
operator||
name|FDEFER
operator|)
expr_stmt|;
do|do
block|{
name|LIST_FOREACH
argument_list|(
argument|fp
argument_list|,
argument|&filehead
argument_list|,
argument|f_list
argument_list|)
block|{
name|FILE_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* 			 * If the file is not open, skip it 			 */
if|if
condition|(
name|fp
operator|->
name|f_count
operator|==
literal|0
condition|)
block|{
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * If we already marked it as 'defer'  in a 			 * previous pass, then try process it this time 			 * and un-mark it 			 */
if|if
condition|(
name|fp
operator|->
name|f_gcflag
operator|&
name|FDEFER
condition|)
block|{
name|fp
operator|->
name|f_gcflag
operator|&=
operator|~
name|FDEFER
expr_stmt|;
name|unp_defer
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * if it's not defered, then check if it's 				 * already marked.. if so skip it 				 */
if|if
condition|(
name|fp
operator|->
name|f_gcflag
operator|&
name|FMARK
condition|)
block|{
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*  				 * If all references are from messages 				 * in transit, then skip it. it's not  				 * externally accessible. 				 */
if|if
condition|(
name|fp
operator|->
name|f_count
operator|==
name|fp
operator|->
name|f_msgcount
condition|)
block|{
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*  				 * If it got this far then it must be 				 * externally accessible. 				 */
name|fp
operator|->
name|f_gcflag
operator||=
name|FMARK
expr_stmt|;
block|}
comment|/* 			 * either it was defered, or it is externally  			 * accessible and not already marked so. 			 * Now check if it is possibly one of OUR sockets. 			 */
if|if
condition|(
name|fp
operator|->
name|f_type
operator|!=
name|DTYPE_SOCKET
operator|||
operator|(
name|so
operator|=
operator|(
expr|struct
name|socket
operator|*
operator|)
name|fp
operator|->
name|f_data
operator|)
operator|==
literal|0
condition|)
block|{
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|!=
operator|&
name|localdomain
operator|||
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_RIGHTS
operator|)
operator|==
literal|0
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator|&
name|SB_LOCK
condition|)
block|{
comment|/* 				 * This is problematical; it's not clear 				 * we need to wait for the sockbuf to be 				 * unlocked (on a uniprocessor, at least), 				 * and it's also not clear what to do 				 * if sbwait returns an error due to receipt 				 * of a signal.  If sbwait does return 				 * an error, we'll go into an infinite 				 * loop.  Delete all of this for now. 				 */
operator|(
name|void
operator|)
name|sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
endif|#
directive|endif
comment|/* 			 * So, Ok, it's one of our sockets and it IS externally 			 * accessible (or was defered). Now we look 			 * to see if we hold any file descriptors in its 			 * message buffers. Follow those links and mark them  			 * as accessible too. 			 */
name|unp_scan
argument_list|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|,
name|unp_mark
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|unp_defer
condition|)
do|;
name|sx_sunlock
argument_list|(
operator|&
name|filelist_lock
argument_list|)
expr_stmt|;
comment|/* 	 * We grab an extra reference to each of the file table entries 	 * that are not otherwise accessible and then free the rights 	 * that are stored in messages on them. 	 * 	 * The bug in the orginal code is a little tricky, so I'll describe 	 * what's wrong with it here. 	 * 	 * It is incorrect to simply unp_discard each entry for f_msgcount 	 * times -- consider the case of sockets A and B that contain 	 * references to each other.  On a last close of some other socket, 	 * we trigger a gc since the number of outstanding rights (unp_rights) 	 * is non-zero.  If during the sweep phase the gc code un_discards, 	 * we end up doing a (full) closef on the descriptor.  A closef on A 	 * results in the following chain.  Closef calls soo_close, which 	 * calls soclose.   Soclose calls first (through the switch 	 * uipc_usrreq) unp_detach, which re-invokes unp_gc.  Unp_gc simply 	 * returns because the previous instance had set unp_gcing, and 	 * we return all the way back to soclose, which marks the socket 	 * with SS_NOFDREF, and then calls sofree.  Sofree calls sorflush 	 * to free up the rights that are queued in messages on the socket A, 	 * i.e., the reference on B.  The sorflush calls via the dom_dispose 	 * switch unp_dispose, which unp_scans with unp_discard.  This second 	 * instance of unp_discard just calls closef on B. 	 * 	 * Well, a similar chain occurs on B, resulting in a sorflush on B, 	 * which results in another closef on A.  Unfortunately, A is already 	 * being closed, and the descriptor has already been marked with 	 * SS_NOFDREF, and soclose panics at this point. 	 * 	 * Here, we first take an extra reference to each inaccessible 	 * descriptor.  Then, we call sorflush ourself, since we know 	 * it is a Unix domain socket anyhow.  After we destroy all the 	 * rights carried in messages, we do a last closef to get rid 	 * of our extra reference.  This is the last close, and the 	 * unp_detach etc will shut down the socket. 	 * 	 * 91/09/19, bsy@cs.cmu.edu 	 */
name|extra_ref
operator|=
name|malloc
argument_list|(
name|nfiles
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|file
operator|*
argument_list|)
argument_list|,
name|M_FILE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|filelist_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|nunref
operator|=
literal|0
operator|,
name|fp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|filehead
argument_list|)
operator|,
name|fpp
operator|=
name|extra_ref
init|;
name|fp
operator|!=
literal|0
condition|;
name|fp
operator|=
name|nextfp
control|)
block|{
name|nextfp
operator|=
name|LIST_NEXT
argument_list|(
name|fp
argument_list|,
name|f_list
argument_list|)
expr_stmt|;
name|FILE_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/*  		 * If it's not open, skip it 		 */
if|if
condition|(
name|fp
operator|->
name|f_count
operator|==
literal|0
condition|)
block|{
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/*  		 * If all refs are from msgs, and it's not marked accessible 		 * then it must be referenced from some unreachable cycle 		 * of (shut-down) FDs, so include it in our 		 * list of FDs to remove 		 */
if|if
condition|(
name|fp
operator|->
name|f_count
operator|==
name|fp
operator|->
name|f_msgcount
operator|&&
operator|!
operator|(
name|fp
operator|->
name|f_gcflag
operator|&
name|FMARK
operator|)
condition|)
block|{
operator|*
name|fpp
operator|++
operator|=
name|fp
expr_stmt|;
name|nunref
operator|++
expr_stmt|;
name|fp
operator|->
name|f_count
operator|++
expr_stmt|;
block|}
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|sx_sunlock
argument_list|(
operator|&
name|filelist_lock
argument_list|)
expr_stmt|;
comment|/*  	 * for each FD on our hit list, do the following two things 	 */
for|for
control|(
name|i
operator|=
name|nunref
operator|,
name|fpp
operator|=
name|extra_ref
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
operator|++
name|fpp
control|)
block|{
name|struct
name|file
modifier|*
name|tfp
init|=
operator|*
name|fpp
decl_stmt|;
name|FILE_LOCK
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfp
operator|->
name|f_type
operator|==
name|DTYPE_SOCKET
operator|&&
name|tfp
operator|->
name|f_data
operator|!=
name|NULL
condition|)
block|{
name|FILE_UNLOCK
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
name|sorflush
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|)
operator|(
name|tfp
operator|->
name|f_data
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|FILE_UNLOCK
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|nunref
operator|,
name|fpp
operator|=
name|extra_ref
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
operator|++
name|fpp
control|)
name|closef
argument_list|(
operator|*
name|fpp
argument_list|,
operator|(
expr|struct
name|thread
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|extra_ref
argument_list|,
name|M_FILE
argument_list|)
expr_stmt|;
name|unp_gcing
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|unp_dispose
parameter_list|(
name|m
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
if|if
condition|(
name|m
condition|)
name|unp_scan
argument_list|(
name|m
argument_list|,
name|unp_discard
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|unp_listen
parameter_list|(
name|unp
parameter_list|,
name|p
parameter_list|)
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|cru2x
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|unp
operator|->
name|unp_peercred
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_flags
operator||=
name|UNP_HAVEPCCACHED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|unp_scan
parameter_list|(
name|m0
parameter_list|,
name|op
parameter_list|)
specifier|register
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*op
end_function_decl

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
expr|struct
name|file
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|file
modifier|*
modifier|*
name|rp
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cm
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|socklen_t
name|clen
decl_stmt|,
name|datalen
decl_stmt|;
name|int
name|qfds
decl_stmt|;
while|while
condition|(
name|m0
condition|)
block|{
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_type
operator|!=
name|MT_CONTROL
condition|)
continue|continue;
name|cm
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
expr_stmt|;
name|clen
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
while|while
condition|(
name|cm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
operator|*
name|cm
argument_list|)
operator|>
name|clen
operator|||
name|cm
operator|->
name|cmsg_len
operator|>
name|clen
condition|)
break|break;
name|data
operator|=
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|datalen
operator|=
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|cm
operator|->
name|cmsg_len
operator|-
operator|(
name|caddr_t
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cmsg_level
operator|==
name|SOL_SOCKET
operator|&&
name|cm
operator|->
name|cmsg_type
operator|==
name|SCM_RIGHTS
condition|)
block|{
name|qfds
operator|=
name|datalen
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|file
operator|*
argument_list|)
expr_stmt|;
name|rp
operator|=
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qfds
condition|;
name|i
operator|++
control|)
call|(
modifier|*
name|op
call|)
argument_list|(
operator|*
name|rp
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|<
name|clen
condition|)
block|{
name|clen
operator|-=
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
expr_stmt|;
name|cm
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|clen
operator|=
literal|0
expr_stmt|;
name|cm
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|m0
operator|=
name|m0
operator|->
name|m_act
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|void
name|unp_mark
parameter_list|(
name|fp
parameter_list|)
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|fp
operator|->
name|f_gcflag
operator|&
name|FMARK
condition|)
return|return;
name|unp_defer
operator|++
expr_stmt|;
name|fp
operator|->
name|f_gcflag
operator||=
operator|(
name|FMARK
operator||
name|FDEFER
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unp_discard
parameter_list|(
name|fp
parameter_list|)
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
block|{
name|FILE_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_msgcount
operator|--
expr_stmt|;
name|unp_rights
operator|--
expr_stmt|;
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closef
argument_list|(
name|fp
argument_list|,
operator|(
expr|struct
name|thread
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

