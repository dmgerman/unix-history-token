begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1989, 1991, 1993  *	The Regents of the University of California.  * Copyright (c) 2004-2007 Robert N. M. Watson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	From: @(#)uipc_usrreq.c	8.3 (Berkeley) 1/4/94  */
end_comment

begin_comment
comment|/*  * UNIX Domain (Local) Sockets  *  * This is an implementation of UNIX (local) domain sockets.  Each socket has  * an associated struct unpcb (UNIX protocol control block).  Stream sockets  * may be connected to 0 or 1 other socket.  Datagram sockets may be  * connected to 0, 1, or many other sockets.  Sockets may be created and  * connected in pairs (socketpair(2)), or bound/connected to using the file  * system name space.  For most purposes, only the receive socket buffer is  * used, as sending on one socket delivers directly to the receive socket  * buffer of a second socket.  *  * The implementation is substantially complicated by the fact that  * "ancillary data", such as file descriptors or credentials, may be passed  * across UNIX domain sockets.  The potential for passing UNIX domain sockets  * over other UNIX domain sockets requires the implementation of a simple  * garbage collector to find and tear down cycles of disconnected sockets.  *  * TODO:  *	SEQPACKET, RDM  *	rethink name space problems  *	need a proper out-of-band  *	lock pushdown  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_comment
comment|/* XXX must be before<sys/file.h> */
end_comment

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<sys/unpcb.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_decl_stmt
specifier|static
name|uma_zone_t
name|unp_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unp_gen_t
name|unp_gencnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|unp_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Count of local sockets. */
end_comment

begin_decl_stmt
specifier|static
name|ino_t
name|unp_ino
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototype for fake inode numbers. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unp_rights
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File descriptors in flight. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|unp_head
name|unp_shead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of local stream sockets. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|unp_head
name|unp_dhead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of local datagram sockets. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|sockaddr
name|sun_noname
init|=
block|{
sizeof|sizeof
argument_list|(
name|sun_noname
argument_list|)
block|,
name|AF_LOCAL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Garbage collection of cyclic file descriptor/socket references occurs  * asynchronously in a taskqueue context in order to avoid recursion and  * reentrance in the UNIX domain socket, file descriptor, and socket layer  * code.  See unp_gc() for a full description.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|task
name|unp_gc_task
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Both send and receive buffers are allocated PIPSIZ bytes of buffering for  * stream sockets, although the total for sender and receiver is actually  * only PIPSIZ.  *  * Datagram sockets really use the sendspace as the maximum datagram size,  * and don't really want to reserve the sendspace.  Their recvspace should be  * large enough for at least one max-size datagram plus address.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PIPSIZ
end_ifndef

begin_define
define|#
directive|define
name|PIPSIZ
value|8192
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|u_long
name|unpst_sendspace
init|=
name|PIPSIZ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|unpst_recvspace
init|=
name|PIPSIZ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|unpdg_sendspace
init|=
literal|2
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* really max datagram size */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|unpdg_recvspace
init|=
literal|4
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net
argument_list|,
name|PF_LOCAL
argument_list|,
name|local
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Local domain"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_local
argument_list|,
name|SOCK_STREAM
argument_list|,
name|stream
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"SOCK_STREAM"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_local
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|dgram
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"SOCK_DGRAM"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_local_stream
argument_list|,
name|OID_AUTO
argument_list|,
name|sendspace
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unpst_sendspace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_local_stream
argument_list|,
name|OID_AUTO
argument_list|,
name|recvspace
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unpst_recvspace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_local_dgram
argument_list|,
name|OID_AUTO
argument_list|,
name|maxdgram
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unpdg_sendspace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_local_dgram
argument_list|,
name|OID_AUTO
argument_list|,
name|recvspace
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unpdg_recvspace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_local
argument_list|,
name|OID_AUTO
argument_list|,
name|inflight
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|unp_rights
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-  * Locking and synchronization:  *  * The global UNIX domain socket rwlock (unp_global_rwlock) protects all  * global variables, including the linked lists tracking the set of allocated  * UNIX domain sockets.  The global rwlock also serves to prevent deadlock  * when more than one PCB lock is acquired at a time (i.e., during  * connect()).  Finally, the global rwlock protects uncounted references from  * vnodes to sockets bound to those vnodes: to safely dereference the  * v_socket pointer, the global rwlock must be held while a full reference is  * acquired.  *  * UNIX domain sockets each have an unpcb hung off of their so_pcb pointer,  * allocated in pru_attach() and freed in pru_detach().  The validity of that  * pointer is an invariant, so no lock is required to dereference the so_pcb  * pointer if a valid socket reference is held by the caller.  In practice,  * this is always true during operations performed on a socket.  Each unpcb  * has a back-pointer to its socket, unp_socket, which will be stable under  * the same circumstances.  *  * This pointer may only be safely dereferenced as long as a valid reference  * to the unpcb is held.  Typically, this reference will be from the socket,  * or from another unpcb when the referring unpcb's lock is held (in order  * that the reference not be invalidated during use).  For example, to follow  * unp->unp_conn->unp_socket, you need unlock the lock on unp, not unp_conn,  * as unp_socket remains valid as long as the reference to unp_conn is valid.  *  * Fields of unpcbss are locked using a per-unpcb lock, unp_mtx.  Individual  * atomic reads without the lock may be performed "lockless", but more  * complex reads and read-modify-writes require the mutex to be held.  No  * lock order is defined between unpcb locks -- multiple unpcb locks may be  * acquired at the same time only when holding the global UNIX domain socket  * rwlock exclusively, which prevents deadlocks.  *  * Blocking with UNIX domain sockets is a tricky issue: unlike most network  * protocols, bind() is a non-atomic operation, and connect() requires  * potential sleeping in the protocol, due to potentially waiting on local or  * distributed file systems.  We try to separate "lookup" operations, which  * may sleep, and the IPC operations themselves, which typically can occur  * with relative atomicity as locks can be held over the entire operation.  *  * Another tricky issue is simultaneous multi-threaded or multi-process  * access to a single UNIX domain socket.  These are handled by the flags  * UNP_CONNECTING and UNP_BINDING, which prevent concurrent connecting or  * binding, both of which involve dropping UNIX domain socket locks in order  * to perform namei() and other file system operations.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|rwlock
name|unp_global_rwlock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UNP_GLOBAL_LOCK_INIT
parameter_list|()
value|rw_init(&unp_global_rwlock,	\ 					    "unp_global_rwlock")
end_define

begin_define
define|#
directive|define
name|UNP_GLOBAL_LOCK_ASSERT
parameter_list|()
value|rw_assert(&unp_global_rwlock,	\ 					    RA_LOCKED)
end_define

begin_define
define|#
directive|define
name|UNP_GLOBAL_UNLOCK_ASSERT
parameter_list|()
value|rw_assert(&unp_global_rwlock,	\ 					    RA_UNLOCKED)
end_define

begin_define
define|#
directive|define
name|UNP_GLOBAL_WLOCK
parameter_list|()
value|rw_wlock(&unp_global_rwlock)
end_define

begin_define
define|#
directive|define
name|UNP_GLOBAL_WUNLOCK
parameter_list|()
value|rw_wunlock(&unp_global_rwlock)
end_define

begin_define
define|#
directive|define
name|UNP_GLOBAL_WLOCK_ASSERT
parameter_list|()
value|rw_assert(&unp_global_rwlock,	\ 					    RA_WLOCKED)
end_define

begin_define
define|#
directive|define
name|UNP_GLOBAL_WOWNED
parameter_list|()
value|rw_wowned(&unp_global_rwlock)
end_define

begin_define
define|#
directive|define
name|UNP_GLOBAL_RLOCK
parameter_list|()
value|rw_rlock(&unp_global_rwlock)
end_define

begin_define
define|#
directive|define
name|UNP_GLOBAL_RUNLOCK
parameter_list|()
value|rw_runlock(&unp_global_rwlock)
end_define

begin_define
define|#
directive|define
name|UNP_GLOBAL_RLOCK_ASSERT
parameter_list|()
value|rw_assert(&unp_global_rwlock,	\ 					    RA_RLOCKED)
end_define

begin_define
define|#
directive|define
name|UNP_PCB_LOCK_INIT
parameter_list|(
name|unp
parameter_list|)
value|mtx_init(&(unp)->unp_mtx,	\ 					    "unp_mtx", "unp_mtx",	\ 					    MTX_DUPOK|MTX_DEF|MTX_RECURSE)
end_define

begin_define
define|#
directive|define
name|UNP_PCB_LOCK_DESTROY
parameter_list|(
name|unp
parameter_list|)
value|mtx_destroy(&(unp)->unp_mtx)
end_define

begin_define
define|#
directive|define
name|UNP_PCB_LOCK
parameter_list|(
name|unp
parameter_list|)
value|mtx_lock(&(unp)->unp_mtx)
end_define

begin_define
define|#
directive|define
name|UNP_PCB_UNLOCK
parameter_list|(
name|unp
parameter_list|)
value|mtx_unlock(&(unp)->unp_mtx)
end_define

begin_define
define|#
directive|define
name|UNP_PCB_LOCK_ASSERT
parameter_list|(
name|unp
parameter_list|)
value|mtx_assert(&(unp)->unp_mtx, MA_OWNED)
end_define

begin_function_decl
specifier|static
name|int
name|unp_connect
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unp_connect2
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|socket
modifier|*
name|so2
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_disconnect
parameter_list|(
name|struct
name|unpcb
modifier|*
name|unp
parameter_list|,
name|struct
name|unpcb
modifier|*
name|unp2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_shutdown
parameter_list|(
name|struct
name|unpcb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_drop
parameter_list|(
name|struct
name|unpcb
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_gc
parameter_list|(
name|__unused
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_scan
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|struct
name|file
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_mark
parameter_list|(
name|struct
name|file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_discard
parameter_list|(
name|struct
name|file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unp_freerights
parameter_list|(
name|struct
name|file
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|unp_internalize
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|unp_addsockcred
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Definitions of protocols supported in the LOCAL domain.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|domain
name|localdomain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|protosw
name|localsw
index|[]
init|=
block|{
block|{
operator|.
name|pr_type
operator|=
name|SOCK_STREAM
block|,
operator|.
name|pr_domain
operator|=
operator|&
name|localdomain
block|,
operator|.
name|pr_flags
operator|=
name|PR_CONNREQUIRED
operator||
name|PR_WANTRCVD
operator||
name|PR_RIGHTS
block|,
operator|.
name|pr_ctloutput
operator|=
operator|&
name|uipc_ctloutput
block|,
operator|.
name|pr_usrreqs
operator|=
operator|&
name|uipc_usrreqs
block|}
block|,
block|{
operator|.
name|pr_type
operator|=
name|SOCK_DGRAM
block|,
operator|.
name|pr_domain
operator|=
operator|&
name|localdomain
block|,
operator|.
name|pr_flags
operator|=
name|PR_ATOMIC
operator||
name|PR_ADDR
operator||
name|PR_RIGHTS
block|,
operator|.
name|pr_usrreqs
operator|=
operator|&
name|uipc_usrreqs
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|domain
name|localdomain
init|=
block|{
operator|.
name|dom_family
operator|=
name|AF_LOCAL
block|,
operator|.
name|dom_name
operator|=
literal|"local"
block|,
operator|.
name|dom_init
operator|=
name|unp_init
block|,
operator|.
name|dom_externalize
operator|=
name|unp_externalize
block|,
operator|.
name|dom_dispose
operator|=
name|unp_dispose
block|,
operator|.
name|dom_protosw
operator|=
name|localsw
block|,
operator|.
name|dom_protoswNPROTOSW
operator|=
operator|&
name|localsw
index|[
sizeof|sizeof
argument_list|(
name|localsw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|localsw
index|[
literal|0
index|]
argument_list|)
index|]
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DOMAIN_SET
argument_list|(
name|local
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|uipc_abort
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_abort: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|UNP_GLOBAL_WLOCK
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|unp2
operator|!=
name|NULL
condition|)
block|{
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|unp_drop
argument_list|(
name|unp2
argument_list|,
name|ECONNABORTED
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
block|}
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_GLOBAL_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_accept
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|;
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
comment|/* 	 * Pass back name of connected socket, if it was bound and we are 	 * still connected (our peer may have closed already!). 	 */
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_accept: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|nam
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
argument_list|,
name|M_SONAME
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|UNP_GLOBAL_RLOCK
argument_list|()
expr_stmt|;
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|unp2
operator|!=
name|NULL
operator|&&
name|unp2
operator|->
name|unp_addr
operator|!=
name|NULL
condition|)
block|{
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|unp2
operator|->
name|unp_addr
expr_stmt|;
name|bcopy
argument_list|(
name|sa
argument_list|,
operator|*
name|nam
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sa
operator|=
operator|&
name|sun_noname
expr_stmt|;
name|bcopy
argument_list|(
name|sa
argument_list|,
operator|*
name|nam
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
block|}
name|UNP_GLOBAL_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|u_long
name|sendspace
decl_stmt|,
name|recvspace
decl_stmt|;
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|locked
decl_stmt|;
name|KASSERT
argument_list|(
name|so
operator|->
name|so_pcb
operator|==
name|NULL
argument_list|,
operator|(
literal|"uipc_attach: so_pcb != NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|==
literal|0
operator|||
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|so
operator|->
name|so_type
condition|)
block|{
case|case
name|SOCK_STREAM
case|:
name|sendspace
operator|=
name|unpst_sendspace
expr_stmt|;
name|recvspace
operator|=
name|unpst_recvspace
expr_stmt|;
break|break;
case|case
name|SOCK_DGRAM
case|:
name|sendspace
operator|=
name|unpdg_sendspace
expr_stmt|;
name|recvspace
operator|=
name|unpdg_recvspace
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"uipc_attach"
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|sendspace
argument_list|,
name|recvspace
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|unp
operator|=
name|uma_zalloc
argument_list|(
name|unp_zone
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|LIST_INIT
argument_list|(
operator|&
name|unp
operator|->
name|unp_refs
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK_INIT
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_socket
operator|=
name|so
expr_stmt|;
name|so
operator|->
name|so_pcb
operator|=
name|unp
expr_stmt|;
name|unp
operator|->
name|unp_refcount
operator|=
literal|1
expr_stmt|;
name|locked
operator|=
literal|0
expr_stmt|;
comment|/* 	 * uipc_attach() may be called indirectly from within the UNIX domain 	 * socket code via sonewconn() in unp_connect().  Since rwlocks can 	 * not be recursed, we do the closest thing. 	 */
if|if
condition|(
operator|!
name|UNP_GLOBAL_WOWNED
argument_list|()
condition|)
block|{
name|UNP_GLOBAL_WLOCK
argument_list|()
expr_stmt|;
name|locked
operator|=
literal|1
expr_stmt|;
block|}
name|unp
operator|->
name|unp_gencnt
operator|=
operator|++
name|unp_gencnt
expr_stmt|;
name|unp_count
operator|++
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_DGRAM
condition|?
operator|&
name|unp_dhead
else|:
operator|&
name|unp_shead
argument_list|,
name|unp
argument_list|,
name|unp_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
condition|)
name|UNP_GLOBAL_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_bind
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|sockaddr_un
modifier|*
name|soun
init|=
operator|(
expr|struct
name|sockaddr_un
operator|*
operator|)
name|nam
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|namelen
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_bind: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|namelen
operator|=
name|soun
operator|->
name|sun_len
operator|-
name|offsetof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|,
name|sun_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|namelen
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * We don't allow simultaneous bind() calls on a single UNIX domain 	 * socket, so flag in-progress operations, and return an error if an 	 * operation is already in progress. 	 * 	 * Historically, we have not allowed a socket to be rebound, so this 	 * also returns an error.  Not allowing re-binding certainly 	 * simplifies the implementation and avoids a great many possible 	 * failure modes. 	 */
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_vnode
operator|!=
name|NULL
condition|)
block|{
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|unp
operator|->
name|unp_flags
operator|&
name|UNP_BINDING
condition|)
block|{
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EALREADY
operator|)
return|;
block|}
name|unp
operator|->
name|unp_flags
operator||=
name|UNP_BINDING
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|namelen
operator|+
literal|1
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|soun
operator|->
name|sun_path
argument_list|,
name|namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|restart
label|:
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|CREATE
argument_list|,
name|NOFOLLOW
operator||
name|LOCKPARENT
operator||
name|SAVENAME
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|buf
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* SHOULD BE ABLE TO ADOPT EXISTING AND wakeup() ALA FIFO's */
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error
goto|;
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|NULL
operator|||
name|vn_start_write
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|,
operator|&
name|mp
argument_list|,
name|V_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|.
name|ni_dvp
operator|==
name|vp
condition|)
name|vrele
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
block|{
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EADDRINUSE
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|error
operator|=
name|vn_start_write
argument_list|(
name|NULL
argument_list|,
operator|&
name|mp
argument_list|,
name|V_XSLEEP
operator||
name|PCATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|error
goto|;
goto|goto
name|restart
goto|;
block|}
name|VATTR_NULL
argument_list|(
operator|&
name|vattr
argument_list|)
expr_stmt|;
name|vattr
operator|.
name|va_type
operator|=
name|VSOCK
expr_stmt|;
name|vattr
operator|.
name|va_mode
operator|=
operator|(
name|ACCESSPERMS
operator|&
operator|~
name|td
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_cmask
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_vnode_create
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|nd
operator|.
name|ni_dvp
argument_list|,
operator|&
name|nd
operator|.
name|ni_cnd
argument_list|,
operator|&
name|vattr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|VOP_LEASE
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|LEASE_WRITE
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_CREATE
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|,
operator|&
name|nd
operator|.
name|ni_vp
argument_list|,
operator|&
name|nd
operator|.
name|ni_cnd
argument_list|,
operator|&
name|vattr
argument_list|)
expr_stmt|;
block|}
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|vp
argument_list|,
literal|"uipc_bind"
argument_list|)
expr_stmt|;
name|soun
operator|=
operator|(
expr|struct
name|sockaddr_un
operator|*
operator|)
name|sodupsockaddr
argument_list|(
name|nam
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|UNP_GLOBAL_WLOCK
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_socket
operator|=
name|unp
operator|->
name|unp_socket
expr_stmt|;
name|unp
operator|->
name|unp_vnode
operator|=
name|vp
expr_stmt|;
name|unp
operator|->
name|unp_addr
operator|=
name|soun
expr_stmt|;
name|unp
operator|->
name|unp_flags
operator|&=
operator|~
name|UNP_BINDING
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_GLOBAL_WUNLOCK
argument_list|()
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_flags
operator|&=
operator|~
name|UNP_BINDING
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_connect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|td
operator|==
name|curthread
argument_list|,
operator|(
literal|"uipc_connect: td != curthread"
operator|)
argument_list|)
expr_stmt|;
name|UNP_GLOBAL_WLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|unp_connect
argument_list|(
name|so
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|UNP_GLOBAL_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|uipc_close
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_close: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|UNP_GLOBAL_WLOCK
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|unp2
operator|!=
name|NULL
condition|)
block|{
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|unp_disconnect
argument_list|(
name|unp
argument_list|,
name|unp2
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
block|}
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_GLOBAL_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|uipc_connect2
parameter_list|(
name|struct
name|socket
modifier|*
name|so1
parameter_list|,
name|struct
name|socket
modifier|*
name|so2
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|;
name|int
name|error
decl_stmt|;
name|UNP_GLOBAL_WLOCK
argument_list|()
expr_stmt|;
name|unp
operator|=
name|so1
operator|->
name|so_pcb
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_connect2: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|unp2
operator|=
name|so2
operator|->
name|so_pcb
expr_stmt|;
name|KASSERT
argument_list|(
name|unp2
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_connect2: unp2 == NULL"
operator|)
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|error
operator|=
name|unp_connect2
argument_list|(
name|so1
argument_list|,
name|so2
argument_list|,
name|PRU_CONNECT2
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_GLOBAL_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* control is EOPNOTSUPP */
end_comment

begin_function
specifier|static
name|void
name|uipc_detach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|;
name|struct
name|sockaddr_un
modifier|*
name|saved_unp_addr
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|freeunp
decl_stmt|,
name|local_unp_rights
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_detach: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|UNP_GLOBAL_WLOCK
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|unp
argument_list|,
name|unp_link
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_gencnt
operator|=
operator|++
name|unp_gencnt
expr_stmt|;
operator|--
name|unp_count
expr_stmt|;
comment|/* 	 * XXXRW: Should assert vp->v_socket == so. 	 */
if|if
condition|(
operator|(
name|vp
operator|=
name|unp
operator|->
name|unp_vnode
operator|)
operator|!=
name|NULL
condition|)
block|{
name|unp
operator|->
name|unp_vnode
operator|->
name|v_socket
operator|=
name|NULL
expr_stmt|;
name|unp
operator|->
name|unp_vnode
operator|=
name|NULL
expr_stmt|;
block|}
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|unp2
operator|!=
name|NULL
condition|)
block|{
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|unp_disconnect
argument_list|(
name|unp
argument_list|,
name|unp2
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We hold the global lock, so it's OK to acquire multiple pcb locks 	 * at a time. 	 */
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|unp
operator|->
name|unp_refs
argument_list|)
condition|)
block|{
name|struct
name|unpcb
modifier|*
name|ref
init|=
name|LIST_FIRST
argument_list|(
operator|&
name|unp
operator|->
name|unp_refs
argument_list|)
decl_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|ref
argument_list|)
expr_stmt|;
name|unp_drop
argument_list|(
name|ref
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
name|UNP_GLOBAL_WUNLOCK
argument_list|()
expr_stmt|;
name|unp
operator|->
name|unp_socket
operator|->
name|so_pcb
operator|=
name|NULL
expr_stmt|;
name|local_unp_rights
operator|=
name|unp_rights
expr_stmt|;
name|saved_unp_addr
operator|=
name|unp
operator|->
name|unp_addr
expr_stmt|;
name|unp
operator|->
name|unp_addr
operator|=
name|NULL
expr_stmt|;
name|unp
operator|->
name|unp_refcount
operator|--
expr_stmt|;
name|freeunp
operator|=
operator|(
name|unp
operator|->
name|unp_refcount
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|saved_unp_addr
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|saved_unp_addr
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeunp
condition|)
block|{
name|UNP_PCB_LOCK_DESTROY
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|unp_zone
argument_list|,
name|unp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vp
condition|)
block|{
name|int
name|vfslocked
decl_stmt|;
name|vfslocked
operator|=
name|VFS_LOCK_GIANT
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|local_unp_rights
condition|)
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|unp_gc_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_disconnect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_disconnect: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|UNP_GLOBAL_WLOCK
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|unp2
operator|!=
name|NULL
condition|)
block|{
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|unp_disconnect
argument_list|(
name|unp
argument_list|,
name|unp2
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
block|}
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_GLOBAL_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_listen
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|backlog
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_listen: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_vnode
operator|==
name|NULL
condition|)
block|{
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|error
operator|=
name|solisten_proto_check
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|cru2x
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
operator|&
name|unp
operator|->
name|unp_peercred
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_flags
operator||=
name|UNP_HAVEPCCACHED
expr_stmt|;
name|solisten_proto
argument_list|(
name|so
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
block|}
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_peeraddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|;
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_peeraddr: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|nam
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
argument_list|,
name|M_SONAME
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: It seems that this test always fails even when connection is 	 * established.  So, this else clause is added as workaround to 	 * return PF_LOCAL sockaddr. 	 */
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|unp2
operator|!=
name|NULL
condition|)
block|{
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp2
operator|->
name|unp_addr
operator|!=
name|NULL
condition|)
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|unp
operator|->
name|unp_conn
operator|->
name|unp_addr
expr_stmt|;
else|else
name|sa
operator|=
operator|&
name|sun_noname
expr_stmt|;
name|bcopy
argument_list|(
name|sa
argument_list|,
operator|*
name|nam
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sa
operator|=
operator|&
name|sun_noname
expr_stmt|;
name|bcopy
argument_list|(
name|sa
argument_list|,
operator|*
name|nam
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
block|}
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_rcvd
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|;
name|struct
name|socket
modifier|*
name|so2
decl_stmt|;
name|u_int
name|mbcnt
decl_stmt|,
name|sbcc
decl_stmt|;
name|u_long
name|newhiwat
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_rcvd: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_DGRAM
condition|)
name|panic
argument_list|(
literal|"uipc_rcvd DGRAM?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_type
operator|!=
name|SOCK_STREAM
condition|)
name|panic
argument_list|(
literal|"uipc_rcvd unknown socktype"
argument_list|)
expr_stmt|;
comment|/* 	 * Adjust backpressure on sender and wakeup any waiting to write. 	 * 	 * The consistency requirements here are a bit complex: we must 	 * acquire the lock for our own unpcb in order to prevent it from 	 * disconnecting while in use, changing the unp_conn peer.  We do not 	 * need unp2's lock, since the unp2->unp_socket pointer will remain 	 * static as long as the unp2 pcb is valid, which it will be until we 	 * release unp's lock to allow a disconnect.  We do need socket 	 * mutexes for both socket endpoints since we manipulate fields in 	 * both; we hold both locks at once since we access both 	 * simultaneously. 	 */
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|mbcnt
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mbcnt
expr_stmt|;
name|sbcc
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|unp2
operator|==
name|NULL
condition|)
block|{
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|so2
operator|=
name|unp2
operator|->
name|unp_socket
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so2
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|so2
operator|->
name|so_snd
operator|.
name|sb_mbmax
operator|+=
name|unp
operator|->
name|unp_mbcnt
operator|-
name|mbcnt
expr_stmt|;
name|newhiwat
operator|=
name|so2
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|+
name|unp
operator|->
name|unp_cc
operator|-
name|sbcc
expr_stmt|;
operator|(
name|void
operator|)
name|chgsbsize
argument_list|(
name|so2
operator|->
name|so_cred
operator|->
name|cr_uidinfo
argument_list|,
operator|&
name|so2
operator|->
name|so_snd
operator|.
name|sb_hiwat
argument_list|,
name|newhiwat
argument_list|,
name|RLIM_INFINITY
argument_list|)
expr_stmt|;
name|sowwakeup_locked
argument_list|(
name|so2
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_mbcnt
operator|=
name|mbcnt
expr_stmt|;
name|unp
operator|->
name|unp_cc
operator|=
name|sbcc
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* pru_rcvoob is EOPNOTSUPP */
end_comment

begin_function
specifier|static
name|int
name|uipc_send
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|;
name|struct
name|socket
modifier|*
name|so2
decl_stmt|;
name|u_int
name|mbcnt
decl_stmt|,
name|sbcc
decl_stmt|;
name|u_long
name|newhiwat
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_send: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PRUS_OOB
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|control
operator|!=
name|NULL
operator|&&
operator|(
name|error
operator|=
name|unp_internalize
argument_list|(
operator|&
name|control
argument_list|,
name|td
argument_list|)
operator|)
condition|)
goto|goto
name|release
goto|;
if|if
condition|(
operator|(
name|nam
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|flags
operator|&
name|PRUS_EOF
operator|)
condition|)
name|UNP_GLOBAL_WLOCK
argument_list|()
expr_stmt|;
else|else
name|UNP_GLOBAL_RLOCK
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|so
operator|->
name|so_type
condition|)
block|{
case|case
name|SOCK_DGRAM
case|:
block|{
specifier|const
name|struct
name|sockaddr
modifier|*
name|from
decl_stmt|;
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|nam
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|unp2
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|EISCONN
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|unp_connect
argument_list|(
name|so
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
block|}
else|else
block|{
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp2
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * Because connect() and send() are non-atomic in a sendto() 		 * with a target address, it's possible that the socket will 		 * have disconnected before the send() can run.  In that case 		 * return the slightly counter-intuitive but otherwise 		 * correct error that the socket is not connected. 		 */
name|UNP_PCB_LOCK_ASSERT
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp2
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
break|break;
block|}
name|so2
operator|=
name|unp2
operator|->
name|unp_socket
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_addr
operator|!=
name|NULL
condition|)
name|from
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|unp
operator|->
name|unp_addr
expr_stmt|;
else|else
name|from
operator|=
operator|&
name|sun_noname
expr_stmt|;
if|if
condition|(
name|unp2
operator|->
name|unp_flags
operator|&
name|UNP_WANTCRED
condition|)
name|control
operator|=
name|unp_addsockcred
argument_list|(
name|td
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so2
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbappendaddr_locked
argument_list|(
operator|&
name|so2
operator|->
name|so_rcv
argument_list|,
name|from
argument_list|,
name|m
argument_list|,
name|control
argument_list|)
condition|)
block|{
name|sorwakeup_locked
argument_list|(
name|so2
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so2
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
block|}
if|if
condition|(
name|nam
operator|!=
name|NULL
condition|)
name|unp_disconnect
argument_list|(
name|unp
argument_list|,
name|unp2
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SOCK_STREAM
case|:
comment|/* 		 * Connect if not connected yet. 		 * 		 * Note: A better implementation would complain if not equal 		 * to the peer's address. 		 */
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|nam
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|unp_connect
argument_list|(
name|so
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* XXX */
block|}
else|else
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK_ASSERT
argument_list|(
name|unp
argument_list|)
expr_stmt|;
comment|/* Lockless read. */
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_state
operator|&
name|SBS_CANTSENDMORE
condition|)
block|{
name|error
operator|=
name|EPIPE
expr_stmt|;
break|break;
block|}
comment|/* 		 * Because connect() and send() are non-atomic in a sendto() 		 * with a target address, it's possible that the socket will 		 * have disconnected before the send() can run.  In that case 		 * return the slightly counter-intuitive but otherwise 		 * correct error that the socket is not connected. 		 * 		 * Lock order here has to be handled carefully: we hold the 		 * global lock, so acquiring two unpcb locks is OK.  We must 		 * acquire both before acquiring any socket mutexes.  We must 		 * also acquire the local socket send mutex before the remote 		 * socket receive mutex.  The only tricky thing is making 		 * sure to acquire the unp2 lock before the local socket send 		 * lock, or we will experience deadlocks. 		 */
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|unp2
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
break|break;
block|}
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|so2
operator|=
name|unp2
operator|->
name|unp_socket
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so2
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp2
operator|->
name|unp_flags
operator|&
name|UNP_WANTCRED
condition|)
block|{
comment|/* 			 * Credentials are passed only once on 			 * SOCK_STREAM. 			 */
name|unp2
operator|->
name|unp_flags
operator|&=
operator|~
name|UNP_WANTCRED
expr_stmt|;
name|control
operator|=
name|unp_addsockcred
argument_list|(
name|td
argument_list|,
name|control
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Send to paired receive port, and then reduce send buffer 		 * hiwater marks to maintain backpressure.  Wake up readers. 		 */
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sbappendcontrol_locked
argument_list|(
operator|&
name|so2
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|,
name|control
argument_list|)
condition|)
name|control
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|sbappend_locked
argument_list|(
operator|&
name|so2
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|mbcnt
operator|=
name|so2
operator|->
name|so_rcv
operator|.
name|sb_mbcnt
operator|-
name|unp2
operator|->
name|unp_mbcnt
expr_stmt|;
name|unp2
operator|->
name|unp_mbcnt
operator|=
name|so2
operator|->
name|so_rcv
operator|.
name|sb_mbcnt
expr_stmt|;
name|sbcc
operator|=
name|so2
operator|->
name|so_rcv
operator|.
name|sb_cc
expr_stmt|;
name|sorwakeup_locked
argument_list|(
name|so2
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|newhiwat
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|-
operator|(
name|sbcc
operator|-
name|unp2
operator|->
name|unp_cc
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|chgsbsize
argument_list|(
name|so
operator|->
name|so_cred
operator|->
name|cr_uidinfo
argument_list|,
operator|&
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
argument_list|,
name|newhiwat
argument_list|,
name|RLIM_INFINITY
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_mbmax
operator|-=
name|mbcnt
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|unp2
operator|->
name|unp_cc
operator|=
name|sbcc
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"uipc_send unknown socktype"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * SEND_EOF is equivalent to a SEND followed by 	 * a SHUTDOWN. 	 */
if|if
condition|(
name|flags
operator|&
name|PRUS_EOF
condition|)
block|{
name|socantsendmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|unp_shutdown
argument_list|(
name|unp
argument_list|)
expr_stmt|;
block|}
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nam
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|flags
operator|&
name|PRUS_EOF
operator|)
condition|)
name|UNP_GLOBAL_WUNLOCK
argument_list|()
expr_stmt|;
else|else
name|UNP_GLOBAL_RUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|control
operator|!=
name|NULL
operator|&&
name|error
operator|!=
literal|0
condition|)
name|unp_dispose
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|release
label|:
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_sense
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|stat
modifier|*
name|sb
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|;
name|struct
name|socket
modifier|*
name|so2
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_sense: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|sb
operator|->
name|st_blksize
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
expr_stmt|;
name|UNP_GLOBAL_RLOCK
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_STREAM
operator|&&
name|unp2
operator|!=
name|NULL
condition|)
block|{
name|so2
operator|=
name|unp2
operator|->
name|unp_socket
expr_stmt|;
name|sb
operator|->
name|st_blksize
operator|+=
name|so2
operator|->
name|so_rcv
operator|.
name|sb_cc
expr_stmt|;
block|}
name|sb
operator|->
name|st_dev
operator|=
name|NODEV
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_ino
operator|==
literal|0
condition|)
name|unp
operator|->
name|unp_ino
operator|=
operator|(
operator|++
name|unp_ino
operator|==
literal|0
operator|)
condition|?
operator|++
name|unp_ino
else|:
name|unp_ino
expr_stmt|;
name|sb
operator|->
name|st_ino
operator|=
name|unp
operator|->
name|unp_ino
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_GLOBAL_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_shutdown
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_shutdown: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|UNP_GLOBAL_WLOCK
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|socantsendmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|unp_shutdown
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_GLOBAL_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uipc_sockaddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_sockaddr: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|nam
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
argument_list|,
name|M_SONAME
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_addr
operator|!=
name|NULL
condition|)
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|unp
operator|->
name|unp_addr
expr_stmt|;
else|else
name|sa
operator|=
operator|&
name|sun_noname
expr_stmt|;
name|bcopy
argument_list|(
name|sa
argument_list|,
operator|*
name|nam
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|pr_usrreqs
name|uipc_usrreqs
init|=
block|{
operator|.
name|pru_abort
operator|=
name|uipc_abort
block|,
operator|.
name|pru_accept
operator|=
name|uipc_accept
block|,
operator|.
name|pru_attach
operator|=
name|uipc_attach
block|,
operator|.
name|pru_bind
operator|=
name|uipc_bind
block|,
operator|.
name|pru_connect
operator|=
name|uipc_connect
block|,
operator|.
name|pru_connect2
operator|=
name|uipc_connect2
block|,
operator|.
name|pru_detach
operator|=
name|uipc_detach
block|,
operator|.
name|pru_disconnect
operator|=
name|uipc_disconnect
block|,
operator|.
name|pru_listen
operator|=
name|uipc_listen
block|,
operator|.
name|pru_peeraddr
operator|=
name|uipc_peeraddr
block|,
operator|.
name|pru_rcvd
operator|=
name|uipc_rcvd
block|,
operator|.
name|pru_send
operator|=
name|uipc_send
block|,
operator|.
name|pru_sense
operator|=
name|uipc_sense
block|,
operator|.
name|pru_shutdown
operator|=
name|uipc_shutdown
block|,
operator|.
name|pru_sockaddr
operator|=
name|uipc_sockaddr
block|,
operator|.
name|pru_close
operator|=
name|uipc_close
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|uipc_ctloutput
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|struct
name|xucred
name|xu
decl_stmt|;
name|int
name|error
decl_stmt|,
name|optval
decl_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_level
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"uipc_ctloutput: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_dir
condition|)
block|{
case|case
name|SOPT_GET
case|:
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|LOCAL_PEERCRED
case|:
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_flags
operator|&
name|UNP_HAVEPC
condition|)
name|xu
operator|=
name|unp
operator|->
name|unp_peercred
expr_stmt|;
else|else
block|{
if|if
condition|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_STREAM
condition|)
name|error
operator|=
name|ENOTCONN
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|xu
argument_list|,
sizeof|sizeof
argument_list|(
name|xu
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCAL_CREDS
case|:
comment|/* Unocked read. */
name|optval
operator|=
name|unp
operator|->
name|unp_flags
operator|&
name|UNP_WANTCRED
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCAL_CONNWAIT
case|:
comment|/* Unocked read. */
name|optval
operator|=
name|unp
operator|->
name|unp_flags
operator|&
name|UNP_CONNWAIT
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SOPT_SET
case|:
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|LOCAL_CREDS
case|:
case|case
name|LOCAL_CONNWAIT
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
define|#
directive|define
name|OPTSET
parameter_list|(
name|bit
parameter_list|)
value|do {						\ 	UNP_PCB_LOCK(unp);						\ 	if (optval)							\ 		unp->unp_flags |= bit;					\ 	else								\ 		unp->unp_flags&= ~bit;					\ 	UNP_PCB_UNLOCK(unp);						\ } while (0)
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|LOCAL_CREDS
case|:
name|OPTSET
argument_list|(
name|UNP_WANTCRED
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOCAL_CONNWAIT
case|:
name|OPTSET
argument_list|(
name|UNP_CONNWAIT
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
undef|#
directive|undef
name|OPTSET
default|default:
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unp_connect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|sockaddr_un
modifier|*
name|soun
init|=
operator|(
expr|struct
name|sockaddr_un
operator|*
operator|)
name|nam
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so2
decl_stmt|,
modifier|*
name|so3
decl_stmt|;
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
name|unp2
decl_stmt|,
modifier|*
name|unp3
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|char
name|buf
index|[
name|SOCK_MAXADDRLEN
index|]
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|UNP_GLOBAL_WLOCK_ASSERT
argument_list|()
expr_stmt|;
name|UNP_GLOBAL_WUNLOCK
argument_list|()
expr_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"unp_connect: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|nam
operator|->
name|sa_len
operator|-
name|offsetof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|,
name|sun_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|soun
operator|->
name|sun_path
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_flags
operator|&
name|UNP_CONNECTING
condition|)
block|{
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EALREADY
operator|)
return|;
block|}
name|unp
operator|->
name|unp_flags
operator||=
name|UNP_CONNECTING
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|sa
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_un
argument_list|)
argument_list|,
name|M_SONAME
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|buf
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|vp
operator|=
name|NULL
expr_stmt|;
else|else
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|vp
argument_list|,
literal|"unp_connect"
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VSOCK
condition|)
block|{
name|error
operator|=
name|ENOTSOCK
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_vnode_open
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|vp
argument_list|,
name|VWRITE
operator||
name|VREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
endif|#
directive|endif
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VWRITE
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"unp_connect: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Lock global lock for two reasons: make sure v_socket is stable, 	 * and to protect simultaneous locking of multiple pcbs. 	 */
name|UNP_GLOBAL_WLOCK
argument_list|()
expr_stmt|;
name|so2
operator|=
name|vp
operator|->
name|v_socket
expr_stmt|;
if|if
condition|(
name|so2
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ECONNREFUSED
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
if|if
condition|(
name|so
operator|->
name|so_type
operator|!=
name|so2
operator|->
name|so_type
condition|)
block|{
name|error
operator|=
name|EPROTOTYPE
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
condition|)
block|{
if|if
condition|(
name|so2
operator|->
name|so_options
operator|&
name|SO_ACCEPTCONN
condition|)
block|{
comment|/* 			 * We can't drop the global lock here or 'so2' may 			 * become invalid, meaning that we will later recurse 			 * back into the UNIX domain socket code while 			 * holding the global lock. 			 */
name|so3
operator|=
name|sonewconn
argument_list|(
name|so2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|so3
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|so3
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ECONNREFUSED
expr_stmt|;
goto|goto
name|bad2
goto|;
block|}
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|unp2
operator|=
name|sotounpcb
argument_list|(
name|so2
argument_list|)
expr_stmt|;
name|unp3
operator|=
name|sotounpcb
argument_list|(
name|so3
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp3
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp2
operator|->
name|unp_addr
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|unp2
operator|->
name|unp_addr
argument_list|,
name|sa
argument_list|,
name|unp2
operator|->
name|unp_addr
operator|->
name|sun_len
argument_list|)
expr_stmt|;
name|unp3
operator|->
name|unp_addr
operator|=
operator|(
expr|struct
name|sockaddr_un
operator|*
operator|)
name|sa
expr_stmt|;
name|sa
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * unp_peercred management: 		 * 		 * The connecter's (client's) credentials are copied from its 		 * process structure at the time of connect() (which is now). 		 */
name|cru2x
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
operator|&
name|unp3
operator|->
name|unp_peercred
argument_list|)
expr_stmt|;
name|unp3
operator|->
name|unp_flags
operator||=
name|UNP_HAVEPC
expr_stmt|;
comment|/* 		 * The receiver's (server's) credentials are copied from the 		 * unp_peercred member of socket on which the former called 		 * listen(); uipc_listen() cached that process's credentials 		 * at that time so we can use them now. 		 */
name|KASSERT
argument_list|(
name|unp2
operator|->
name|unp_flags
operator|&
name|UNP_HAVEPCCACHED
argument_list|,
operator|(
literal|"unp_connect: listener without cached peercred"
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|unp
operator|->
name|unp_peercred
argument_list|,
operator|&
name|unp2
operator|->
name|unp_peercred
argument_list|,
sizeof|sizeof
argument_list|(
name|unp
operator|->
name|unp_peercred
argument_list|)
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_flags
operator||=
name|UNP_HAVEPC
expr_stmt|;
if|if
condition|(
name|unp2
operator|->
name|unp_flags
operator|&
name|UNP_WANTCRED
condition|)
name|unp3
operator|->
name|unp_flags
operator||=
name|UNP_WANTCRED
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp3
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|mac_set_socket_peer_from_socket
argument_list|(
name|so
argument_list|,
name|so3
argument_list|)
expr_stmt|;
name|mac_set_socket_peer_from_socket
argument_list|(
name|so3
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|so2
operator|=
name|so3
expr_stmt|;
block|}
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"unp_connect: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|unp2
operator|=
name|sotounpcb
argument_list|(
name|so2
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp2
operator|!=
name|NULL
argument_list|,
operator|(
literal|"unp_connect: unp2 == NULL"
operator|)
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|error
operator|=
name|unp_connect2
argument_list|(
name|so
argument_list|,
name|so2
argument_list|,
name|PRU_CONNECT
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|bad2
label|:
name|UNP_GLOBAL_WUNLOCK
argument_list|()
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|bad
label|:
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sa
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|UNP_GLOBAL_WLOCK
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_flags
operator|&=
operator|~
name|UNP_CONNECTING
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|unp_connect2
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|socket
modifier|*
name|so2
parameter_list|,
name|int
name|req
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|;
name|struct
name|unpcb
modifier|*
name|unp2
decl_stmt|;
name|unp
operator|=
name|sotounpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"unp_connect2: unp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|unp2
operator|=
name|sotounpcb
argument_list|(
name|so2
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|unp2
operator|!=
name|NULL
argument_list|,
operator|(
literal|"unp_connect2: unp2 == NULL"
operator|)
argument_list|)
expr_stmt|;
name|UNP_GLOBAL_WLOCK_ASSERT
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK_ASSERT
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK_ASSERT
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|so2
operator|->
name|so_type
operator|!=
name|so
operator|->
name|so_type
condition|)
return|return
operator|(
name|EPROTOTYPE
operator|)
return|;
name|unp
operator|->
name|unp_conn
operator|=
name|unp2
expr_stmt|;
switch|switch
condition|(
name|so
operator|->
name|so_type
condition|)
block|{
case|case
name|SOCK_DGRAM
case|:
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|unp2
operator|->
name|unp_refs
argument_list|,
name|unp
argument_list|,
name|unp_reflink
argument_list|)
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
break|break;
case|case
name|SOCK_STREAM
case|:
name|unp2
operator|->
name|unp_conn
operator|=
name|unp
expr_stmt|;
if|if
condition|(
name|req
operator|==
name|PRU_CONNECT
operator|&&
operator|(
operator|(
name|unp
operator|->
name|unp_flags
operator||
name|unp2
operator|->
name|unp_flags
operator|)
operator|&
name|UNP_CONNWAIT
operator|)
condition|)
name|soisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
else|else
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|soisconnected
argument_list|(
name|so2
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"unp_connect2"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unp_disconnect
parameter_list|(
name|struct
name|unpcb
modifier|*
name|unp
parameter_list|,
name|struct
name|unpcb
modifier|*
name|unp2
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|KASSERT
argument_list|(
name|unp2
operator|!=
name|NULL
argument_list|,
operator|(
literal|"unp_disconnect: unp2 == NULL"
operator|)
argument_list|)
expr_stmt|;
name|UNP_GLOBAL_WLOCK_ASSERT
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK_ASSERT
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|UNP_PCB_LOCK_ASSERT
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_conn
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|unp
operator|->
name|unp_socket
operator|->
name|so_type
condition|)
block|{
case|case
name|SOCK_DGRAM
case|:
name|LIST_REMOVE
argument_list|(
name|unp
argument_list|,
name|unp_reflink
argument_list|)
expr_stmt|;
name|so
operator|=
name|unp
operator|->
name|unp_socket
expr_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_state
operator|&=
operator|~
name|SS_ISCONNECTED
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
break|break;
case|case
name|SOCK_STREAM
case|:
name|soisdisconnected
argument_list|(
name|unp
operator|->
name|unp_socket
argument_list|)
expr_stmt|;
name|unp2
operator|->
name|unp_conn
operator|=
name|NULL
expr_stmt|;
name|soisdisconnected
argument_list|(
name|unp2
operator|->
name|unp_socket
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * unp_pcblist() assumes that UNIX domain socket memory is never reclaimed by  * the zone (UMA_ZONE_NOFREE), and as such potentially stale pointers are  * safe to reference.  It first scans the list of struct unpcb's to generate  * a pointer list, then it rescans its list one entry at a time to  * externalize and copyout.  It checks the generation number to see if a  * struct unpcb has been reused, and will skip it if so.  */
end_comment

begin_function
specifier|static
name|int
name|unp_pcblist
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
name|int
name|freeunp
decl_stmt|;
name|struct
name|unpcb
modifier|*
name|unp
decl_stmt|,
modifier|*
modifier|*
name|unp_list
decl_stmt|;
name|unp_gen_t
name|gencnt
decl_stmt|;
name|struct
name|xunpgen
modifier|*
name|xug
decl_stmt|;
name|struct
name|unp_head
modifier|*
name|head
decl_stmt|;
name|struct
name|xunpcb
modifier|*
name|xu
decl_stmt|;
name|head
operator|=
operator|(
operator|(
name|intptr_t
operator|)
name|arg1
operator|==
name|SOCK_DGRAM
condition|?
operator|&
name|unp_dhead
else|:
operator|&
name|unp_shead
operator|)
expr_stmt|;
comment|/* 	 * The process of preparing the PCB list is too time-consuming and 	 * resource-intensive to repeat twice on every request. 	 */
if|if
condition|(
name|req
operator|->
name|oldptr
operator|==
name|NULL
condition|)
block|{
name|n
operator|=
name|unp_count
expr_stmt|;
name|req
operator|->
name|oldidx
operator|=
literal|2
operator|*
operator|(
sizeof|sizeof
expr|*
name|xug
operator|)
operator|+
operator|(
name|n
operator|+
name|n
operator|/
literal|8
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|xunpcb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* 	 * OK, now we're committed to doing something. 	 */
name|xug
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|xug
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|UNP_GLOBAL_RLOCK
argument_list|()
expr_stmt|;
name|gencnt
operator|=
name|unp_gencnt
expr_stmt|;
name|n
operator|=
name|unp_count
expr_stmt|;
name|UNP_GLOBAL_RUNLOCK
argument_list|()
expr_stmt|;
name|xug
operator|->
name|xug_len
operator|=
sizeof|sizeof
expr|*
name|xug
expr_stmt|;
name|xug
operator|->
name|xug_count
operator|=
name|n
expr_stmt|;
name|xug
operator|->
name|xug_gen
operator|=
name|gencnt
expr_stmt|;
name|xug
operator|->
name|xug_sogen
operator|=
name|so_gencnt
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|xug
argument_list|,
sizeof|sizeof
expr|*
name|xug
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|xug
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|unp_list
operator|=
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
expr|*
name|unp_list
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * XXXRW: Note, this code relies very explicitly in pcb's being type 	 * stable. 	 */
name|UNP_GLOBAL_RLOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|unp
operator|=
name|LIST_FIRST
argument_list|(
name|head
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|unp
operator|&&
name|i
operator|<
name|n
condition|;
name|unp
operator|=
name|LIST_NEXT
argument_list|(
name|unp
argument_list|,
name|unp_link
argument_list|)
control|)
block|{
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_gencnt
operator|<=
name|gencnt
condition|)
block|{
if|if
condition|(
name|cr_cansee
argument_list|(
name|req
operator|->
name|td
operator|->
name|td_ucred
argument_list|,
name|unp
operator|->
name|unp_socket
operator|->
name|so_cred
argument_list|)
condition|)
block|{
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|unp_list
index|[
name|i
operator|++
index|]
operator|=
name|unp
expr_stmt|;
name|unp
operator|->
name|unp_refcount
operator|++
expr_stmt|;
block|}
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
block|}
name|UNP_GLOBAL_RUNLOCK
argument_list|()
expr_stmt|;
name|n
operator|=
name|i
expr_stmt|;
comment|/* In case we lost some during malloc. */
comment|/* 	 * XXXRW: The logic below asumes that it is OK to lock a mutex in 	 * an unpcb that may have been freed. 	 */
name|error
operator|=
literal|0
expr_stmt|;
name|xu
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|xu
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|unp
operator|=
name|unp_list
index|[
name|i
index|]
expr_stmt|;
name|UNP_PCB_LOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|unp
operator|->
name|unp_refcount
operator|--
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_refcount
operator|!=
literal|0
operator|&&
name|unp
operator|->
name|unp_gencnt
operator|<=
name|gencnt
condition|)
block|{
name|xu
operator|->
name|xu_len
operator|=
sizeof|sizeof
expr|*
name|xu
expr_stmt|;
name|xu
operator|->
name|xu_unpp
operator|=
name|unp
expr_stmt|;
comment|/* 			 * XXX - need more locking here to protect against 			 * connect/disconnect races for SMP. 			 */
if|if
condition|(
name|unp
operator|->
name|unp_addr
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|unp
operator|->
name|unp_addr
argument_list|,
operator|&
name|xu
operator|->
name|xu_addr
argument_list|,
name|unp
operator|->
name|unp_addr
operator|->
name|sun_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_conn
operator|!=
name|NULL
operator|&&
name|unp
operator|->
name|unp_conn
operator|->
name|unp_addr
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|unp
operator|->
name|unp_conn
operator|->
name|unp_addr
argument_list|,
operator|&
name|xu
operator|->
name|xu_caddr
argument_list|,
name|unp
operator|->
name|unp_conn
operator|->
name|unp_addr
operator|->
name|sun_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|unp
argument_list|,
operator|&
name|xu
operator|->
name|xu_unp
argument_list|,
sizeof|sizeof
expr|*
name|unp
argument_list|)
expr_stmt|;
name|sotoxsocket
argument_list|(
name|unp
operator|->
name|unp_socket
argument_list|,
operator|&
name|xu
operator|->
name|xu_socket
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|xu
argument_list|,
sizeof|sizeof
expr|*
name|xu
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|freeunp
operator|=
operator|(
name|unp
operator|->
name|unp_refcount
operator|==
literal|0
operator|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp
argument_list|)
expr_stmt|;
if|if
condition|(
name|freeunp
condition|)
block|{
name|UNP_PCB_LOCK_DESTROY
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|unp_zone
argument_list|,
name|unp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|xu
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* 		 * Give the user an updated idea of our state.  If the 		 * generation differs from what we told her before, she knows 		 * that something happened while we were processing this 		 * request, and it might be necessary to retry. 		 */
name|xug
operator|->
name|xug_gen
operator|=
name|unp_gencnt
expr_stmt|;
name|xug
operator|->
name|xug_sogen
operator|=
name|so_gencnt
expr_stmt|;
name|xug
operator|->
name|xug_count
operator|=
name|unp_count
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|xug
argument_list|,
sizeof|sizeof
expr|*
name|xug
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|unp_list
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xug
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_local_dgram
argument_list|,
name|OID_AUTO
argument_list|,
name|pcblist
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|long
operator|)
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|,
name|unp_pcblist
argument_list|,
literal|"S,xunpcb"
argument_list|,
literal|"List of active local datagram sockets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_local_stream
argument_list|,
name|OID_AUTO
argument_list|,
name|pcblist
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|long
operator|)
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
name|unp_pcblist
argument_list|,
literal|"S,xunpcb"
argument_list|,
literal|"List of active local stream sockets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|unp_shutdown
parameter_list|(
name|struct
name|unpcb
modifier|*
name|unp
parameter_list|)
block|{
name|struct
name|unpcb
modifier|*
name|unp2
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|UNP_GLOBAL_WLOCK_ASSERT
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK_ASSERT
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|unp
operator|->
name|unp_socket
operator|->
name|so_type
operator|==
name|SOCK_STREAM
operator|&&
name|unp2
operator|!=
name|NULL
condition|)
block|{
name|so
operator|=
name|unp2
operator|->
name|unp_socket
expr_stmt|;
if|if
condition|(
name|so
operator|!=
name|NULL
condition|)
name|socantrcvmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|unp_drop
parameter_list|(
name|struct
name|unpcb
modifier|*
name|unp
parameter_list|,
name|int
name|errno
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|unp
operator|->
name|unp_socket
decl_stmt|;
name|struct
name|unpcb
modifier|*
name|unp2
decl_stmt|;
name|UNP_GLOBAL_WLOCK_ASSERT
argument_list|()
expr_stmt|;
name|UNP_PCB_LOCK_ASSERT
argument_list|(
name|unp
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
name|errno
expr_stmt|;
name|unp2
operator|=
name|unp
operator|->
name|unp_conn
expr_stmt|;
if|if
condition|(
name|unp2
operator|==
name|NULL
condition|)
return|return;
name|UNP_PCB_LOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
name|unp_disconnect
argument_list|(
name|unp
argument_list|,
name|unp2
argument_list|)
expr_stmt|;
name|UNP_PCB_UNLOCK
argument_list|(
name|unp2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unp_freerights
parameter_list|(
name|struct
name|file
modifier|*
modifier|*
name|rp
parameter_list|,
name|int
name|fdcount
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fdcount
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Zero the pointer before calling unp_discard since it may 		 * end up in unp_gc().. 		 * 		 * XXXRW: This is less true than it used to be. 		 */
name|fp
operator|=
operator|*
name|rp
expr_stmt|;
operator|*
name|rp
operator|++
operator|=
name|NULL
expr_stmt|;
name|unp_discard
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|unp_externalize
parameter_list|(
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|controlp
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
comment|/* XXX */
name|struct
name|cmsghdr
modifier|*
name|cm
init|=
name|mtod
argument_list|(
name|control
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
modifier|*
name|fdp
decl_stmt|;
name|struct
name|file
modifier|*
modifier|*
name|rp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|socklen_t
name|clen
init|=
name|control
operator|->
name|m_len
decl_stmt|,
name|datalen
decl_stmt|;
name|int
name|error
decl_stmt|,
name|newfds
decl_stmt|;
name|int
name|f
decl_stmt|;
name|u_int
name|newlen
decl_stmt|;
name|UNP_GLOBAL_UNLOCK_ASSERT
argument_list|()
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
comment|/* controlp == NULL => free control messages */
operator|*
name|controlp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|cm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
operator|*
name|cm
argument_list|)
operator|>
name|clen
operator|||
name|cm
operator|->
name|cmsg_len
operator|>
name|clen
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|data
operator|=
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|datalen
operator|=
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|cm
operator|->
name|cmsg_len
operator|-
operator|(
name|caddr_t
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cmsg_level
operator|==
name|SOL_SOCKET
operator|&&
name|cm
operator|->
name|cmsg_type
operator|==
name|SCM_RIGHTS
condition|)
block|{
name|newfds
operator|=
name|datalen
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|file
operator|*
argument_list|)
expr_stmt|;
name|rp
operator|=
name|data
expr_stmt|;
comment|/* If we're not outputting the descriptors free them. */
if|if
condition|(
name|error
operator|||
name|controlp
operator|==
name|NULL
condition|)
block|{
name|unp_freerights
argument_list|(
name|rp
argument_list|,
name|newfds
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|FILEDESC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
comment|/* if the new FD's will not fit free them.  */
if|if
condition|(
operator|!
name|fdavail
argument_list|(
name|td
argument_list|,
name|newfds
argument_list|)
condition|)
block|{
name|FILEDESC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
name|unp_freerights
argument_list|(
name|rp
argument_list|,
name|newfds
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* 			 * Now change each pointer to an fd in the global 			 * table to an integer that is the index to the local 			 * fd table entry that we set up to point to the 			 * global one we are transferring. 			 */
name|newlen
operator|=
name|newfds
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|*
name|controlp
operator|=
name|sbcreatecontrol
argument_list|(
name|NULL
argument_list|,
name|newlen
argument_list|,
name|SCM_RIGHTS
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|controlp
operator|==
name|NULL
condition|)
block|{
name|FILEDESC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
name|error
operator|=
name|E2BIG
expr_stmt|;
name|unp_freerights
argument_list|(
name|rp
argument_list|,
name|newfds
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|fdp
operator|=
operator|(
name|int
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|mtod
argument_list|(
operator|*
name|controlp
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|newfds
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fdalloc
argument_list|(
name|td
argument_list|,
literal|0
argument_list|,
operator|&
name|f
argument_list|)
condition|)
name|panic
argument_list|(
literal|"unp_externalize fdalloc failed"
argument_list|)
expr_stmt|;
name|fp
operator|=
operator|*
name|rp
operator|++
expr_stmt|;
name|td
operator|->
name|td_proc
operator|->
name|p_fd
operator|->
name|fd_ofiles
index|[
name|f
index|]
operator|=
name|fp
expr_stmt|;
name|FILE_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_msgcount
operator|--
expr_stmt|;
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|unp_rights
operator|--
expr_stmt|;
operator|*
name|fdp
operator|++
operator|=
name|f
expr_stmt|;
block|}
name|FILEDESC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We can just copy anything else across. */
if|if
condition|(
name|error
operator|||
name|controlp
operator|==
name|NULL
condition|)
goto|goto
name|next
goto|;
operator|*
name|controlp
operator|=
name|sbcreatecontrol
argument_list|(
name|NULL
argument_list|,
name|datalen
argument_list|,
name|cm
operator|->
name|cmsg_type
argument_list|,
name|cm
operator|->
name|cmsg_level
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|controlp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|bcopy
argument_list|(
name|data
argument_list|,
name|CMSG_DATA
argument_list|(
name|mtod
argument_list|(
operator|*
name|controlp
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
argument_list|)
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
name|controlp
operator|=
operator|&
operator|(
operator|*
name|controlp
operator|)
operator|->
name|m_next
expr_stmt|;
name|next
label|:
if|if
condition|(
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|<
name|clen
condition|)
block|{
name|clen
operator|-=
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
expr_stmt|;
name|cm
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|clen
operator|=
literal|0
expr_stmt|;
name|cm
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unp_zone_change
parameter_list|(
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|uma_zone_set_max
argument_list|(
name|unp_zone
argument_list|,
name|maxsockets
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|unp_init
parameter_list|(
name|void
parameter_list|)
block|{
name|unp_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"unpcb"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unpcb
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|unp_zone
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"unp_init"
argument_list|)
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|unp_zone
argument_list|,
name|maxsockets
argument_list|)
expr_stmt|;
name|EVENTHANDLER_REGISTER
argument_list|(
name|maxsockets_change
argument_list|,
name|unp_zone_change
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|unp_dhead
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|unp_shead
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|unp_gc_task
argument_list|,
literal|0
argument_list|,
name|unp_gc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|UNP_GLOBAL_LOCK_INIT
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|unp_internalize
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|controlp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|control
init|=
operator|*
name|controlp
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|filedesc
modifier|*
name|fdescp
init|=
name|p
operator|->
name|p_fd
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cm
init|=
name|mtod
argument_list|(
name|control
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
decl_stmt|;
name|struct
name|cmsgcred
modifier|*
name|cmcred
decl_stmt|;
name|struct
name|file
modifier|*
modifier|*
name|rp
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|timeval
modifier|*
name|tv
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fd
decl_stmt|,
modifier|*
name|fdp
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|socklen_t
name|clen
init|=
name|control
operator|->
name|m_len
decl_stmt|,
name|datalen
decl_stmt|;
name|int
name|error
decl_stmt|,
name|oldfds
decl_stmt|;
name|u_int
name|newlen
decl_stmt|;
name|UNP_GLOBAL_UNLOCK_ASSERT
argument_list|()
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
operator|*
name|controlp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|cm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
operator|*
name|cm
argument_list|)
operator|>
name|clen
operator|||
name|cm
operator|->
name|cmsg_level
operator|!=
name|SOL_SOCKET
operator|||
name|cm
operator|->
name|cmsg_len
operator|>
name|clen
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|data
operator|=
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|datalen
operator|=
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|cm
operator|->
name|cmsg_len
operator|-
operator|(
name|caddr_t
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|cm
operator|->
name|cmsg_type
condition|)
block|{
comment|/* 		 * Fill in credential information. 		 */
case|case
name|SCM_CREDS
case|:
operator|*
name|controlp
operator|=
name|sbcreatecontrol
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cmcred
argument_list|)
argument_list|,
name|SCM_CREDS
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|controlp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cmcred
operator|=
operator|(
expr|struct
name|cmsgcred
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|mtod
argument_list|(
operator|*
name|controlp
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|cmcred
operator|->
name|cmcred_pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|cmcred
operator|->
name|cmcred_uid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_ruid
expr_stmt|;
name|cmcred
operator|->
name|cmcred_gid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_rgid
expr_stmt|;
name|cmcred
operator|->
name|cmcred_euid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_uid
expr_stmt|;
name|cmcred
operator|->
name|cmcred_ngroups
operator|=
name|MIN
argument_list|(
name|td
operator|->
name|td_ucred
operator|->
name|cr_ngroups
argument_list|,
name|CMGROUP_MAX
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cmcred
operator|->
name|cmcred_ngroups
condition|;
name|i
operator|++
control|)
name|cmcred
operator|->
name|cmcred_groups
index|[
name|i
index|]
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_groups
index|[
name|i
index|]
expr_stmt|;
break|break;
case|case
name|SCM_RIGHTS
case|:
name|oldfds
operator|=
name|datalen
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/* 			 * Check that all the FDs passed in refer to legal 			 * files.  If not, reject the entire operation. 			 */
name|fdp
operator|=
name|data
expr_stmt|;
name|FILEDESC_LOCK
argument_list|(
name|fdescp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldfds
condition|;
name|i
operator|++
control|)
block|{
name|fd
operator|=
operator|*
name|fdp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|fd
operator|>=
name|fdescp
operator|->
name|fd_nfiles
operator|||
name|fdescp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
operator|==
name|NULL
condition|)
block|{
name|FILEDESC_UNLOCK
argument_list|(
name|fdescp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBADF
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fp
operator|=
name|fdescp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|->
name|f_ops
operator|->
name|fo_flags
operator|&
name|DFLAG_PASSABLE
operator|)
condition|)
block|{
name|FILEDESC_UNLOCK
argument_list|(
name|fdescp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 			 * Now replace the integer FDs with pointers to 			 * the associated global file table entry.. 			 */
name|newlen
operator|=
name|oldfds
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|file
operator|*
argument_list|)
expr_stmt|;
operator|*
name|controlp
operator|=
name|sbcreatecontrol
argument_list|(
name|NULL
argument_list|,
name|newlen
argument_list|,
name|SCM_RIGHTS
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|controlp
operator|==
name|NULL
condition|)
block|{
name|FILEDESC_UNLOCK
argument_list|(
name|fdescp
argument_list|)
expr_stmt|;
name|error
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fdp
operator|=
name|data
expr_stmt|;
name|rp
operator|=
operator|(
expr|struct
name|file
operator|*
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|mtod
argument_list|(
operator|*
name|controlp
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldfds
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
name|fdescp
operator|->
name|fd_ofiles
index|[
operator|*
name|fdp
operator|++
index|]
expr_stmt|;
operator|*
name|rp
operator|++
operator|=
name|fp
expr_stmt|;
name|FILE_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_count
operator|++
expr_stmt|;
name|fp
operator|->
name|f_msgcount
operator|++
expr_stmt|;
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|unp_rights
operator|++
expr_stmt|;
block|}
name|FILEDESC_UNLOCK
argument_list|(
name|fdescp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCM_TIMESTAMP
case|:
operator|*
name|controlp
operator|=
name|sbcreatecontrol
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tv
argument_list|)
argument_list|,
name|SCM_TIMESTAMP
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|controlp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|tv
operator|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|mtod
argument_list|(
operator|*
name|controlp
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
name|tv
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|controlp
operator|=
operator|&
operator|(
operator|*
name|controlp
operator|)
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|<
name|clen
condition|)
block|{
name|clen
operator|-=
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
expr_stmt|;
name|cm
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|clen
operator|=
literal|0
expr_stmt|;
name|cm
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|out
label|:
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|unp_addsockcred
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|,
modifier|*
name|n_prev
decl_stmt|;
name|struct
name|sockcred
modifier|*
name|sc
decl_stmt|;
specifier|const
name|struct
name|cmsghdr
modifier|*
name|cm
decl_stmt|;
name|int
name|ngroups
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ngroups
operator|=
name|MIN
argument_list|(
name|td
operator|->
name|td_ucred
operator|->
name|cr_ngroups
argument_list|,
name|CMGROUP_MAX
argument_list|)
expr_stmt|;
name|m
operator|=
name|sbcreatecontrol
argument_list|(
name|NULL
argument_list|,
name|SOCKCREDSIZE
argument_list|(
name|ngroups
argument_list|)
argument_list|,
name|SCM_CREDS
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|control
operator|)
return|;
name|sc
operator|=
operator|(
expr|struct
name|sockcred
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_uid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_ruid
expr_stmt|;
name|sc
operator|->
name|sc_euid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_uid
expr_stmt|;
name|sc
operator|->
name|sc_gid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_rgid
expr_stmt|;
name|sc
operator|->
name|sc_egid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_gid
expr_stmt|;
name|sc
operator|->
name|sc_ngroups
operator|=
name|ngroups
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_ngroups
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|sc_groups
index|[
name|i
index|]
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_groups
index|[
name|i
index|]
expr_stmt|;
comment|/* 	 * Unlink SCM_CREDS control messages (struct cmsgcred), since just 	 * created SCM_CREDS control message (struct sockcred) has another 	 * format. 	 */
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
for|for
control|(
name|n
operator|=
name|control
operator|,
name|n_prev
operator|=
name|NULL
init|;
name|n
operator|!=
name|NULL
condition|;
control|)
block|{
name|cm
operator|=
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cmsg_level
operator|==
name|SOL_SOCKET
operator|&&
name|cm
operator|->
name|cmsg_type
operator|==
name|SCM_CREDS
condition|)
block|{
if|if
condition|(
name|n_prev
operator|==
name|NULL
condition|)
name|control
operator|=
name|n
operator|->
name|m_next
expr_stmt|;
else|else
name|n_prev
operator|->
name|m_next
operator|=
name|n
operator|->
name|m_next
expr_stmt|;
name|n
operator|=
name|m_free
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n_prev
operator|=
name|n
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|m_next
expr_stmt|;
block|}
block|}
comment|/* Prepend it to the head. */
name|m
operator|->
name|m_next
operator|=
name|control
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * unp_defer indicates whether additional work has been defered for a future  * pass through unp_gc().  It is thread local and does not require explicit  * synchronization.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unp_defer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|unp_taskcount
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_local
argument_list|,
name|OID_AUTO
argument_list|,
name|taskcount
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|unp_taskcount
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|unp_recycled
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_local
argument_list|,
name|OID_AUTO
argument_list|,
name|recycled
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|unp_recycled
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|unp_gc
parameter_list|(
name|__unused
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|file
modifier|*
name|fp
decl_stmt|,
modifier|*
name|nextfp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|file
modifier|*
modifier|*
name|extra_ref
decl_stmt|,
modifier|*
modifier|*
name|fpp
decl_stmt|;
name|int
name|nunref
decl_stmt|,
name|i
decl_stmt|;
name|int
name|nfiles_snap
decl_stmt|;
name|int
name|nfiles_slack
init|=
literal|20
decl_stmt|;
name|unp_taskcount
operator|++
expr_stmt|;
name|unp_defer
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Before going through all this, set all FDs to be NOT deferred and 	 * NOT externally accessible. 	 */
name|sx_slock
argument_list|(
operator|&
name|filelist_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|fp
argument_list|,
argument|&filehead
argument_list|,
argument|f_list
argument_list|)
name|fp
operator|->
name|f_gcflag
operator|&=
operator|~
operator|(
name|FMARK
operator||
name|FDEFER
operator|)
expr_stmt|;
do|do
block|{
name|KASSERT
argument_list|(
name|unp_defer
operator|>=
literal|0
argument_list|,
operator|(
literal|"unp_gc: unp_defer %d"
operator|,
name|unp_defer
operator|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|fp
argument_list|,
argument|&filehead
argument_list|,
argument|f_list
argument_list|)
block|{
name|FILE_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* 			 * If the file is not open, skip it -- could be a 			 * file in the process of being opened, or in the 			 * process of being closed.  If the file is 			 * "closing", it may have been marked for deferred 			 * consideration.  Clear the flag now if so. 			 */
if|if
condition|(
name|fp
operator|->
name|f_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|f_gcflag
operator|&
name|FDEFER
condition|)
name|unp_defer
operator|--
expr_stmt|;
name|fp
operator|->
name|f_gcflag
operator|&=
operator|~
operator|(
name|FMARK
operator||
name|FDEFER
operator|)
expr_stmt|;
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * If we already marked it as 'defer' in a 			 * previous pass, then try to process it this 			 * time and un-mark it. 			 */
if|if
condition|(
name|fp
operator|->
name|f_gcflag
operator|&
name|FDEFER
condition|)
block|{
name|fp
operator|->
name|f_gcflag
operator|&=
operator|~
name|FDEFER
expr_stmt|;
name|unp_defer
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * If it's not deferred, then check if it's 				 * already marked.. if so skip it 				 */
if|if
condition|(
name|fp
operator|->
name|f_gcflag
operator|&
name|FMARK
condition|)
block|{
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 				 * If all references are from messages in 				 * transit, then skip it. it's not externally 				 * accessible. 				 */
if|if
condition|(
name|fp
operator|->
name|f_count
operator|==
name|fp
operator|->
name|f_msgcount
condition|)
block|{
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 				 * If it got this far then it must be 				 * externally accessible. 				 */
name|fp
operator|->
name|f_gcflag
operator||=
name|FMARK
expr_stmt|;
block|}
comment|/* 			 * Either it was deferred, or it is externally 			 * accessible and not already marked so.  Now check 			 * if it is possibly one of OUR sockets. 			 */
if|if
condition|(
name|fp
operator|->
name|f_type
operator|!=
name|DTYPE_SOCKET
operator|||
operator|(
name|so
operator|=
name|fp
operator|->
name|f_data
operator|)
operator|==
name|NULL
condition|)
block|{
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|!=
operator|&
name|localdomain
operator|||
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_RIGHTS
operator|)
operator|==
literal|0
condition|)
block|{
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * Tell any other threads that do a subsequent 			 * fdrop() that we are scanning the message 			 * buffers. 			 */
name|fp
operator|->
name|f_gcflag
operator||=
name|FWAIT
expr_stmt|;
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* 			 * So, Ok, it's one of our sockets and it IS 			 * externally accessible (or was deferred).  Now we 			 * look to see if we hold any file descriptors in its 			 * message buffers. Follow those links and mark them 			 * as accessible too. 			 */
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|unp_scan
argument_list|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|,
name|unp_mark
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* 			 * Wake up any threads waiting in fdrop(). 			 */
name|FILE_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_gcflag
operator|&=
operator|~
name|FWAIT
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|fp
operator|->
name|f_gcflag
argument_list|)
expr_stmt|;
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|unp_defer
condition|)
do|;
name|sx_sunlock
argument_list|(
operator|&
name|filelist_lock
argument_list|)
expr_stmt|;
comment|/* 	 * XXXRW: The following comments need updating for a post-SMPng and 	 * deferred unp_gc() world, but are still generally accurate. 	 * 	 * We grab an extra reference to each of the file table entries that 	 * are not otherwise accessible and then free the rights that are 	 * stored in messages on them. 	 * 	 * The bug in the orginal code is a little tricky, so I'll describe 	 * what's wrong with it here. 	 * 	 * It is incorrect to simply unp_discard each entry for f_msgcount 	 * times -- consider the case of sockets A and B that contain 	 * references to each other.  On a last close of some other socket, 	 * we trigger a gc since the number of outstanding rights (unp_rights) 	 * is non-zero.  If during the sweep phase the gc code unp_discards, 	 * we end up doing a (full) closef on the descriptor.  A closef on A 	 * results in the following chain.  Closef calls soo_close, which 	 * calls soclose.   Soclose calls first (through the switch 	 * uipc_usrreq) unp_detach, which re-invokes unp_gc.  Unp_gc simply 	 * returns because the previous instance had set unp_gcing, and we 	 * return all the way back to soclose, which marks the socket with 	 * SS_NOFDREF, and then calls sofree.  Sofree calls sorflush to free 	 * up the rights that are queued in messages on the socket A, i.e., 	 * the reference on B.  The sorflush calls via the dom_dispose switch 	 * unp_dispose, which unp_scans with unp_discard.  This second 	 * instance of unp_discard just calls closef on B. 	 * 	 * Well, a similar chain occurs on B, resulting in a sorflush on B, 	 * which results in another closef on A.  Unfortunately, A is already 	 * being closed, and the descriptor has already been marked with 	 * SS_NOFDREF, and soclose panics at this point. 	 * 	 * Here, we first take an extra reference to each inaccessible 	 * descriptor.  Then, we call sorflush ourself, since we know it is a 	 * Unix domain socket anyhow.  After we destroy all the rights 	 * carried in messages, we do a last closef to get rid of our extra 	 * reference.  This is the last close, and the unp_detach etc will 	 * shut down the socket. 	 * 	 * 91/09/19, bsy@cs.cmu.edu 	 */
name|again
label|:
name|nfiles_snap
operator|=
name|openfiles
operator|+
name|nfiles_slack
expr_stmt|;
comment|/* some slack */
name|extra_ref
operator|=
name|malloc
argument_list|(
name|nfiles_snap
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|file
operator|*
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|filelist_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfiles_snap
operator|<
name|openfiles
condition|)
block|{
name|sx_sunlock
argument_list|(
operator|&
name|filelist_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|extra_ref
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|nfiles_slack
operator|+=
literal|20
expr_stmt|;
goto|goto
name|again
goto|;
block|}
for|for
control|(
name|nunref
operator|=
literal|0
operator|,
name|fp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|filehead
argument_list|)
operator|,
name|fpp
operator|=
name|extra_ref
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|nextfp
control|)
block|{
name|nextfp
operator|=
name|LIST_NEXT
argument_list|(
name|fp
argument_list|,
name|f_list
argument_list|)
expr_stmt|;
name|FILE_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* 		 * If it's not open, skip it 		 */
if|if
condition|(
name|fp
operator|->
name|f_count
operator|==
literal|0
condition|)
block|{
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If all refs are from msgs, and it's not marked accessible 		 * then it must be referenced from some unreachable cycle of 		 * (shut-down) FDs, so include it in our list of FDs to 		 * remove. 		 */
if|if
condition|(
name|fp
operator|->
name|f_count
operator|==
name|fp
operator|->
name|f_msgcount
operator|&&
operator|!
operator|(
name|fp
operator|->
name|f_gcflag
operator|&
name|FMARK
operator|)
condition|)
block|{
operator|*
name|fpp
operator|++
operator|=
name|fp
expr_stmt|;
name|nunref
operator|++
expr_stmt|;
name|fp
operator|->
name|f_count
operator|++
expr_stmt|;
block|}
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|sx_sunlock
argument_list|(
operator|&
name|filelist_lock
argument_list|)
expr_stmt|;
comment|/* 	 * For each FD on our hit list, do the following two things: 	 */
for|for
control|(
name|i
operator|=
name|nunref
operator|,
name|fpp
operator|=
name|extra_ref
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
operator|++
name|fpp
control|)
block|{
name|struct
name|file
modifier|*
name|tfp
init|=
operator|*
name|fpp
decl_stmt|;
name|FILE_LOCK
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tfp
operator|->
name|f_type
operator|==
name|DTYPE_SOCKET
operator|&&
name|tfp
operator|->
name|f_data
operator|!=
name|NULL
condition|)
block|{
name|FILE_UNLOCK
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
name|sorflush
argument_list|(
name|tfp
operator|->
name|f_data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FILE_UNLOCK
argument_list|(
name|tfp
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
name|nunref
operator|,
name|fpp
operator|=
name|extra_ref
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
operator|++
name|fpp
control|)
block|{
name|closef
argument_list|(
operator|*
name|fpp
argument_list|,
operator|(
expr|struct
name|thread
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|unp_recycled
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|extra_ref
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|unp_dispose
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
condition|)
name|unp_scan
argument_list|(
name|m
argument_list|,
name|unp_discard
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unp_scan
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|void
function_decl|(
modifier|*
name|op
function_decl|)
parameter_list|(
name|struct
name|file
modifier|*
parameter_list|)
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|file
modifier|*
modifier|*
name|rp
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cm
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|socklen_t
name|clen
decl_stmt|,
name|datalen
decl_stmt|;
name|int
name|qfds
decl_stmt|;
while|while
condition|(
name|m0
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_type
operator|!=
name|MT_CONTROL
condition|)
continue|continue;
name|cm
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
expr_stmt|;
name|clen
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
while|while
condition|(
name|cm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
sizeof|sizeof
argument_list|(
operator|*
name|cm
argument_list|)
operator|>
name|clen
operator|||
name|cm
operator|->
name|cmsg_len
operator|>
name|clen
condition|)
break|break;
name|data
operator|=
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
name|datalen
operator|=
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|cm
operator|->
name|cmsg_len
operator|-
operator|(
name|caddr_t
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|cm
operator|->
name|cmsg_level
operator|==
name|SOL_SOCKET
operator|&&
name|cm
operator|->
name|cmsg_type
operator|==
name|SCM_RIGHTS
condition|)
block|{
name|qfds
operator|=
name|datalen
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|file
operator|*
argument_list|)
expr_stmt|;
name|rp
operator|=
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qfds
condition|;
name|i
operator|++
control|)
call|(
modifier|*
name|op
call|)
argument_list|(
operator|*
name|rp
operator|++
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|<
name|clen
condition|)
block|{
name|clen
operator|-=
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
expr_stmt|;
name|cm
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|cm
operator|+
name|CMSG_SPACE
argument_list|(
name|datalen
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|clen
operator|=
literal|0
expr_stmt|;
name|cm
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|m0
operator|=
name|m0
operator|->
name|m_act
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|unp_mark
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|)
block|{
comment|/* XXXRW: Should probably assert file list lock here. */
if|if
condition|(
name|fp
operator|->
name|f_gcflag
operator|&
name|FMARK
condition|)
return|return;
name|unp_defer
operator|++
expr_stmt|;
name|fp
operator|->
name|f_gcflag
operator||=
operator|(
name|FMARK
operator||
name|FDEFER
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unp_discard
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|)
block|{
name|UNP_GLOBAL_WLOCK
argument_list|()
expr_stmt|;
name|FILE_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_msgcount
operator|--
expr_stmt|;
name|unp_rights
operator|--
expr_stmt|;
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|UNP_GLOBAL_WUNLOCK
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|closef
argument_list|(
name|fp
argument_list|,
operator|(
expr|struct
name|thread
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

