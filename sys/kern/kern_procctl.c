begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2014 John Baldwin  * Copyright (c) 2014 The FreeBSD Foundation  *  * Portions of this software were developed by Konstantin Belousov  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/capsicum.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/procctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_function
specifier|static
name|int
name|protect_setchild
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_SYSTEM
operator|||
name|p_cansched
argument_list|(
name|td
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|flags
operator|&
name|PPROT_SET
condition|)
block|{
name|p
operator|->
name|p_flag
operator||=
name|P_PROTECTED
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PPROT_INHERIT
condition|)
name|p
operator|->
name|p_flag2
operator||=
name|P2_INHERIT_PROTECTED
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_PROTECTED
expr_stmt|;
name|p
operator|->
name|p_flag2
operator|&=
operator|~
name|P2_INHERIT_PROTECTED
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|protect_setchildren
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|proc
modifier|*
name|top
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|p
operator|=
name|top
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|sx_assert
argument_list|(
operator|&
name|proctree_lock
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ret
operator||=
name|protect_setchild
argument_list|(
name|td
argument_list|,
name|p
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 		 * If this process has children, descend to them next, 		 * otherwise do any siblings, and if done with this level, 		 * follow back up the tree (but not past top). 		 */
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|p
operator|->
name|p_children
argument_list|)
condition|)
name|p
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|p
operator|->
name|p_children
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|==
name|top
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|p
argument_list|,
name|p_sibling
argument_list|)
condition|)
block|{
name|p
operator|=
name|LIST_NEXT
argument_list|(
name|p
argument_list|,
name|p_sibling
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|p
operator|->
name|p_pptr
expr_stmt|;
block|}
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|protect_set
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|ret
decl_stmt|;
switch|switch
condition|(
name|PPROT_OP
argument_list|(
name|flags
argument_list|)
condition|)
block|{
case|case
name|PPROT_SET
case|:
case|case
name|PPROT_CLEAR
case|:
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|PPROT_FLAGS
argument_list|(
name|flags
argument_list|)
operator|&
operator|~
operator|(
name|PPROT_DESCEND
operator||
name|PPROT_INHERIT
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_VM_MADV_PROTECT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|flags
operator|&
name|PPROT_DESCEND
condition|)
name|ret
operator|=
name|protect_setchildren
argument_list|(
name|td
argument_list|,
name|p
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|protect_setchild
argument_list|(
name|td
argument_list|,
name|p
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|reap_acquire
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|sx_assert
argument_list|(
operator|&
name|proctree_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|curproc
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|->
name|p_treeflag
operator|&
name|P_TREE_REAPER
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|p
operator|->
name|p_treeflag
operator||=
name|P_TREE_REAPER
expr_stmt|;
comment|/* 	 * We do not reattach existing children and the whole tree 	 * under them to us, since p->p_reaper already seen them. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|reap_release
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|sx_assert
argument_list|(
operator|&
name|proctree_lock
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|curproc
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|p
operator|==
name|initproc
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|->
name|p_treeflag
operator|&
name|P_TREE_REAPER
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|reaper_abandon_children
argument_list|(
name|p
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|reap_status
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|procctl_reaper_status
modifier|*
name|rs
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|reap
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
modifier|*
name|first_p
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|proctree_lock
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|rs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|p_treeflag
operator|&
name|P_TREE_REAPER
operator|)
operator|==
literal|0
condition|)
block|{
name|reap
operator|=
name|p
operator|->
name|p_reaper
expr_stmt|;
block|}
else|else
block|{
name|reap
operator|=
name|p
expr_stmt|;
name|rs
operator|->
name|rs_flags
operator||=
name|REAPER_STATUS_OWNED
expr_stmt|;
block|}
if|if
condition|(
name|reap
operator|==
name|initproc
condition|)
name|rs
operator|->
name|rs_flags
operator||=
name|REAPER_STATUS_REALINIT
expr_stmt|;
name|rs
operator|->
name|rs_reaper
operator|=
name|reap
operator|->
name|p_pid
expr_stmt|;
name|rs
operator|->
name|rs_descendants
operator|=
literal|0
expr_stmt|;
name|rs
operator|->
name|rs_children
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|reap
operator|->
name|p_reaplist
argument_list|)
condition|)
block|{
name|first_p
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|reap
operator|->
name|p_children
argument_list|)
expr_stmt|;
if|if
condition|(
name|first_p
operator|==
name|NULL
condition|)
name|first_p
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|reap
operator|->
name|p_reaplist
argument_list|)
expr_stmt|;
name|rs
operator|->
name|rs_pid
operator|=
name|first_p
operator|->
name|p_pid
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|p2
argument_list|,
argument|&reap->p_reaplist
argument_list|,
argument|p_reapsibling
argument_list|)
block|{
if|if
condition|(
name|proc_realparent
argument_list|(
name|p2
argument_list|)
operator|==
name|reap
condition|)
name|rs
operator|->
name|rs_children
operator|++
expr_stmt|;
name|rs
operator|->
name|rs_descendants
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|rs
operator|->
name|rs_pid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|reap_getpids
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|procctl_reaper_pids
modifier|*
name|rp
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|reap
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|struct
name|procctl_reaper_pidinfo
modifier|*
name|pi
decl_stmt|,
modifier|*
name|pip
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|proctree_lock
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|reap
operator|=
operator|(
name|p
operator|->
name|p_treeflag
operator|&
name|P_TREE_REAPER
operator|)
operator|==
literal|0
condition|?
name|p
operator|->
name|p_reaper
else|:
name|p
expr_stmt|;
name|n
operator|=
name|i
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|p2
argument_list|,
argument|&reap->p_reaplist
argument_list|,
argument|p_reapsibling
argument_list|)
name|n
operator|++
expr_stmt|;
name|sx_unlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rp_count
operator|<
name|n
condition|)
name|n
operator|=
name|rp
operator|->
name|rp_count
expr_stmt|;
name|pi
operator|=
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|pi
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|p2
argument_list|,
argument|&reap->p_reaplist
argument_list|,
argument|p_reapsibling
argument_list|)
block|{
if|if
condition|(
name|i
operator|==
name|n
condition|)
break|break;
name|pip
operator|=
operator|&
name|pi
index|[
name|i
index|]
expr_stmt|;
name|bzero
argument_list|(
name|pip
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pip
argument_list|)
argument_list|)
expr_stmt|;
name|pip
operator|->
name|pi_pid
operator|=
name|p2
operator|->
name|p_pid
expr_stmt|;
name|pip
operator|->
name|pi_subtree
operator|=
name|p2
operator|->
name|p_reapsubtree
expr_stmt|;
name|pip
operator|->
name|pi_flags
operator|=
name|REAPER_PIDINFO_VALID
expr_stmt|;
if|if
condition|(
name|proc_realparent
argument_list|(
name|p2
argument_list|)
operator|==
name|reap
condition|)
name|pip
operator|->
name|pi_flags
operator||=
name|REAPER_PIDINFO_CHILD
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|sx_sunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|pi
argument_list|,
name|rp
operator|->
name|rp_pids
argument_list|,
name|i
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|pi
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pi
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|reap_kill
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|procctl_reaper_kill
modifier|*
name|rk
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|reap
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
name|ksiginfo_t
name|ksi
decl_stmt|;
name|int
name|error
decl_stmt|,
name|error1
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|proctree_lock
argument_list|,
name|SX_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_CAPABILITY_MODE
argument_list|(
name|td
argument_list|)
condition|)
return|return
operator|(
name|ECAPMODE
operator|)
return|;
if|if
condition|(
name|rk
operator|->
name|rk_sig
operator|<=
literal|0
operator|||
name|rk
operator|->
name|rk_sig
operator|>
name|_SIG_MAXSIG
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|rk
operator|->
name|rk_flags
operator|&
operator|~
name|REAPER_KILL_CHILDREN
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|reap
operator|=
operator|(
name|p
operator|->
name|p_treeflag
operator|&
name|P_TREE_REAPER
operator|)
operator|==
literal|0
condition|?
name|p
operator|->
name|p_reaper
else|:
name|p
expr_stmt|;
name|ksiginfo_init
argument_list|(
operator|&
name|ksi
argument_list|)
expr_stmt|;
name|ksi
operator|.
name|ksi_signo
operator|=
name|rk
operator|->
name|rk_sig
expr_stmt|;
name|ksi
operator|.
name|ksi_code
operator|=
name|SI_USER
expr_stmt|;
name|ksi
operator|.
name|ksi_pid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
name|ksi
operator|.
name|ksi_uid
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_ruid
expr_stmt|;
name|error
operator|=
name|ESRCH
expr_stmt|;
name|rk
operator|->
name|rk_killed
operator|=
literal|0
expr_stmt|;
name|rk
operator|->
name|rk_fpid
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|p2
operator|=
operator|(
name|rk
operator|->
name|rk_flags
operator|&
name|REAPER_KILL_CHILDREN
operator|)
operator|!=
literal|0
condition|?
name|LIST_FIRST
argument_list|(
operator|&
name|reap
operator|->
name|p_children
argument_list|)
else|:
name|LIST_FIRST
argument_list|(
operator|&
name|reap
operator|->
name|p_reaplist
argument_list|)
init|;
name|p2
operator|!=
name|NULL
condition|;
name|p2
operator|=
operator|(
name|rk
operator|->
name|rk_flags
operator|&
name|REAPER_KILL_CHILDREN
operator|)
operator|!=
literal|0
condition|?
name|LIST_NEXT
argument_list|(
name|p2
argument_list|,
name|p_sibling
argument_list|)
else|:
name|LIST_NEXT
argument_list|(
name|p2
argument_list|,
name|p_reapsibling
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|rk
operator|->
name|rk_flags
operator|&
name|REAPER_KILL_SUBTREE
operator|)
operator|!=
literal|0
operator|&&
name|p2
operator|->
name|p_reapsubtree
operator|!=
name|rk
operator|->
name|rk_subtree
condition|)
continue|continue;
name|PROC_LOCK
argument_list|(
name|p2
argument_list|)
expr_stmt|;
name|error1
operator|=
name|p_cansignal
argument_list|(
name|td
argument_list|,
name|p2
argument_list|,
name|rk
operator|->
name|rk_sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|error1
operator|==
literal|0
condition|)
block|{
name|pksignal
argument_list|(
name|p2
argument_list|,
name|rk
operator|->
name|rk_sig
argument_list|,
operator|&
name|ksi
argument_list|)
expr_stmt|;
name|rk
operator|->
name|rk_killed
operator|++
expr_stmt|;
name|error
operator|=
name|error1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|ESRCH
condition|)
block|{
name|error
operator|=
name|error1
expr_stmt|;
name|rk
operator|->
name|rk_fpid
operator|=
name|p2
operator|->
name|p_pid
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p2
argument_list|)
expr_stmt|;
comment|/* Do not end the loop on error, signal everything we can. */
block|}
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|trace_ctl
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Ktrace changes p_traceflag from or to zero under the 	 * process lock, so the test does not need to acquire ktrace 	 * mutex. 	 */
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_TRACED
operator|)
operator|!=
literal|0
operator|||
name|p
operator|->
name|p_traceflag
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|PROC_TRACE_CTL_ENABLE
case|:
if|if
condition|(
name|td
operator|->
name|td_proc
operator|!=
name|p
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|p
operator|->
name|p_flag2
operator|&=
operator|~
operator|(
name|P2_NOTRACE
operator||
name|P2_NOTRACE_EXEC
operator|)
expr_stmt|;
break|break;
case|case
name|PROC_TRACE_CTL_DISABLE_EXEC
case|:
name|p
operator|->
name|p_flag2
operator||=
name|P2_NOTRACE_EXEC
operator||
name|P2_NOTRACE
expr_stmt|;
break|break;
case|case
name|PROC_TRACE_CTL_DISABLE
case|:
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag2
operator|&
name|P2_NOTRACE_EXEC
operator|)
operator|!=
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|p
operator|->
name|p_flag2
operator|&
name|P2_NOTRACE
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"dandling P2_NOTRACE_EXEC"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_proc
operator|!=
name|p
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|p
operator|->
name|p_flag2
operator|&=
operator|~
name|P2_NOTRACE_EXEC
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|p_flag2
operator||=
name|P2_NOTRACE
expr_stmt|;
block|}
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|trace_status
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|int
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag2
operator|&
name|P2_NOTRACE
operator|)
operator|!=
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_TRACED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%d traced but tracing disabled"
operator|,
name|p
operator|->
name|p_pid
operator|)
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_TRACED
operator|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|data
operator|=
name|p
operator|->
name|p_pptr
operator|->
name|p_pid
expr_stmt|;
block|}
else|else
block|{
operator|*
name|data
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|procctl_args
block|{
name|idtype_t
name|idtype
decl_stmt|;
name|id_t
name|id
decl_stmt|;
name|int
name|com
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|sys_procctl
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|procctl_args
modifier|*
name|uap
parameter_list|)
block|{
name|void
modifier|*
name|data
decl_stmt|;
union|union
block|{
name|struct
name|procctl_reaper_status
name|rs
decl_stmt|;
name|struct
name|procctl_reaper_pids
name|rp
decl_stmt|;
name|struct
name|procctl_reaper_kill
name|rk
decl_stmt|;
block|}
name|x
union|;
name|int
name|error
decl_stmt|,
name|error1
decl_stmt|,
name|flags
decl_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|com
condition|)
block|{
case|case
name|PROC_SPROTECT
case|:
case|case
name|PROC_TRACE_CTL
case|:
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|data
argument_list|,
operator|&
name|flags
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|data
operator|=
operator|&
name|flags
expr_stmt|;
break|break;
case|case
name|PROC_REAP_ACQUIRE
case|:
case|case
name|PROC_REAP_RELEASE
case|:
if|if
condition|(
name|uap
operator|->
name|data
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|data
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|PROC_REAP_STATUS
case|:
name|data
operator|=
operator|&
name|x
operator|.
name|rs
expr_stmt|;
break|break;
case|case
name|PROC_REAP_GETPIDS
case|:
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|data
argument_list|,
operator|&
name|x
operator|.
name|rp
argument_list|,
sizeof|sizeof
argument_list|(
name|x
operator|.
name|rp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|data
operator|=
operator|&
name|x
operator|.
name|rp
expr_stmt|;
break|break;
case|case
name|PROC_REAP_KILL
case|:
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|data
argument_list|,
operator|&
name|x
operator|.
name|rk
argument_list|,
sizeof|sizeof
argument_list|(
name|x
operator|.
name|rk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|data
operator|=
operator|&
name|x
operator|.
name|rk
expr_stmt|;
break|break;
case|case
name|PROC_TRACE_STATUS
case|:
name|data
operator|=
operator|&
name|flags
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|kern_procctl
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|idtype
argument_list|,
name|uap
operator|->
name|id
argument_list|,
name|uap
operator|->
name|com
argument_list|,
name|data
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|com
condition|)
block|{
case|case
name|PROC_REAP_STATUS
case|:
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|x
operator|.
name|rs
argument_list|,
name|uap
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|x
operator|.
name|rs
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PROC_REAP_KILL
case|:
name|error1
operator|=
name|copyout
argument_list|(
operator|&
name|x
operator|.
name|rk
argument_list|,
name|uap
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|x
operator|.
name|rk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|error1
expr_stmt|;
break|break;
case|case
name|PROC_TRACE_STATUS
case|:
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|flags
argument_list|,
name|uap
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kern_procctl_single
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|int
name|com
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|PROC_LOCK_ASSERT
argument_list|(
name|p
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|com
condition|)
block|{
case|case
name|PROC_SPROTECT
case|:
return|return
operator|(
name|protect_set
argument_list|(
name|td
argument_list|,
name|p
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
operator|)
return|;
case|case
name|PROC_REAP_ACQUIRE
case|:
return|return
operator|(
name|reap_acquire
argument_list|(
name|td
argument_list|,
name|p
argument_list|)
operator|)
return|;
case|case
name|PROC_REAP_RELEASE
case|:
return|return
operator|(
name|reap_release
argument_list|(
name|td
argument_list|,
name|p
argument_list|)
operator|)
return|;
case|case
name|PROC_REAP_STATUS
case|:
return|return
operator|(
name|reap_status
argument_list|(
name|td
argument_list|,
name|p
argument_list|,
name|data
argument_list|)
operator|)
return|;
case|case
name|PROC_REAP_GETPIDS
case|:
return|return
operator|(
name|reap_getpids
argument_list|(
name|td
argument_list|,
name|p
argument_list|,
name|data
argument_list|)
operator|)
return|;
case|case
name|PROC_REAP_KILL
case|:
return|return
operator|(
name|reap_kill
argument_list|(
name|td
argument_list|,
name|p
argument_list|,
name|data
argument_list|)
operator|)
return|;
case|case
name|PROC_TRACE_CTL
case|:
return|return
operator|(
name|trace_ctl
argument_list|(
name|td
argument_list|,
name|p
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
operator|)
return|;
case|case
name|PROC_TRACE_STATUS
case|:
return|return
operator|(
name|trace_status
argument_list|(
name|td
argument_list|,
name|p
argument_list|,
name|data
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|kern_procctl
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|idtype_t
name|idtype
parameter_list|,
name|id_t
name|id
parameter_list|,
name|int
name|com
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|pgrp
modifier|*
name|pg
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|,
name|first_error
decl_stmt|,
name|ok
decl_stmt|;
name|bool
name|tree_locked
decl_stmt|;
switch|switch
condition|(
name|com
condition|)
block|{
case|case
name|PROC_REAP_ACQUIRE
case|:
case|case
name|PROC_REAP_RELEASE
case|:
case|case
name|PROC_REAP_STATUS
case|:
case|case
name|PROC_REAP_GETPIDS
case|:
case|case
name|PROC_REAP_KILL
case|:
case|case
name|PROC_TRACE_STATUS
case|:
if|if
condition|(
name|idtype
operator|!=
name|P_PID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
switch|switch
condition|(
name|com
condition|)
block|{
case|case
name|PROC_SPROTECT
case|:
case|case
name|PROC_REAP_STATUS
case|:
case|case
name|PROC_REAP_GETPIDS
case|:
case|case
name|PROC_REAP_KILL
case|:
case|case
name|PROC_TRACE_CTL
case|:
name|sx_slock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|tree_locked
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|PROC_REAP_ACQUIRE
case|:
case|case
name|PROC_REAP_RELEASE
case|:
name|sx_xlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|tree_locked
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|PROC_TRACE_STATUS
case|:
name|tree_locked
operator|=
name|false
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
switch|switch
condition|(
name|idtype
condition|)
block|{
case|case
name|P_PID
case|:
name|p
operator|=
name|pfind
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ESRCH
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|p_cansee
argument_list|(
name|td
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|kern_procctl_single
argument_list|(
name|td
argument_list|,
name|p
argument_list|,
name|com
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_PGID
case|:
comment|/* 		 * Attempt to apply the operation to all members of the 		 * group.  Ignore processes in the group that can't be 		 * seen.  Ignore errors so long as at least one process is 		 * able to complete the request successfully. 		 */
name|pg
operator|=
name|pgfind
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|pg
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ESRCH
expr_stmt|;
break|break;
block|}
name|PGRP_UNLOCK
argument_list|(
name|pg
argument_list|)
expr_stmt|;
name|ok
operator|=
literal|0
expr_stmt|;
name|first_error
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&pg->pg_members
argument_list|,
argument|p_pglist
argument_list|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_state
operator|==
name|PRS_NEW
operator|||
name|p_cansee
argument_list|(
name|td
argument_list|,
name|p
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|error
operator|=
name|kern_procctl_single
argument_list|(
name|td
argument_list|,
name|p
argument_list|,
name|com
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|first_error
operator|==
literal|0
condition|)
name|first_error
operator|=
name|error
expr_stmt|;
block|}
if|if
condition|(
name|ok
condition|)
name|error
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|first_error
operator|!=
literal|0
condition|)
name|error
operator|=
name|first_error
expr_stmt|;
else|else
comment|/* 			 * Was not able to see any processes in the 			 * process group. 			 */
name|error
operator|=
name|ESRCH
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tree_locked
condition|)
name|sx_unlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

