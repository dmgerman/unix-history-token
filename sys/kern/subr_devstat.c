begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997, 1998, 1999 Kenneth D. Merry.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|devstat_num_devs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|devstat_generation
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|devstat_version
init|=
name|DEVSTAT_VERSION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|devstat_current_devnumber
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|devstat_mutex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|devstatlist
name|device_statq
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|devstat
modifier|*
name|devstat_alloc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|devstat_free
parameter_list|(
name|struct
name|devstat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|devstat_add_entry
parameter_list|(
name|struct
name|devstat
modifier|*
name|ds
parameter_list|,
specifier|const
name|void
modifier|*
name|dev_name
parameter_list|,
name|int
name|unit_number
parameter_list|,
name|u_int32_t
name|block_size
parameter_list|,
name|devstat_support_flags
name|flags
parameter_list|,
name|devstat_type_flags
name|device_type
parameter_list|,
name|devstat_priority
name|priority
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Allocate a devstat and initialize it  */
end_comment

begin_function
name|struct
name|devstat
modifier|*
name|devstat_new_entry
parameter_list|(
specifier|const
name|void
modifier|*
name|dev_name
parameter_list|,
name|int
name|unit_number
parameter_list|,
name|u_int32_t
name|block_size
parameter_list|,
name|devstat_support_flags
name|flags
parameter_list|,
name|devstat_type_flags
name|device_type
parameter_list|,
name|devstat_priority
name|priority
parameter_list|)
block|{
name|struct
name|devstat
modifier|*
name|ds
decl_stmt|;
specifier|static
name|int
name|once
decl_stmt|;
if|if
condition|(
operator|!
name|once
condition|)
block|{
name|STAILQ_INIT
argument_list|(
operator|&
name|device_statq
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|devstat_mutex
argument_list|,
literal|"devstat"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|once
operator|=
literal|1
expr_stmt|;
block|}
name|mtx_assert
argument_list|(
operator|&
name|devstat_mutex
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|ds
operator|=
name|devstat_alloc
argument_list|()
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|devstat_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|unit_number
operator|==
operator|-
literal|1
condition|)
block|{
name|ds
operator|->
name|id
operator|=
name|dev_name
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|ds
operator|->
name|creation_time
argument_list|)
expr_stmt|;
name|devstat_generation
operator|++
expr_stmt|;
block|}
else|else
block|{
name|devstat_add_entry
argument_list|(
name|ds
argument_list|,
name|dev_name
argument_list|,
name|unit_number
argument_list|,
name|block_size
argument_list|,
name|flags
argument_list|,
name|device_type
argument_list|,
name|priority
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|devstat_mutex
argument_list|)
expr_stmt|;
return|return
operator|(
name|ds
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Take a malloced and zeroed devstat structure given to us, fill it in   * and add it to the queue of devices.    */
end_comment

begin_function
specifier|static
name|void
name|devstat_add_entry
parameter_list|(
name|struct
name|devstat
modifier|*
name|ds
parameter_list|,
specifier|const
name|void
modifier|*
name|dev_name
parameter_list|,
name|int
name|unit_number
parameter_list|,
name|u_int32_t
name|block_size
parameter_list|,
name|devstat_support_flags
name|flags
parameter_list|,
name|devstat_type_flags
name|device_type
parameter_list|,
name|devstat_priority
name|priority
parameter_list|)
block|{
name|struct
name|devstatlist
modifier|*
name|devstat_head
decl_stmt|;
name|struct
name|devstat
modifier|*
name|ds_tmp
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|devstat_mutex
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|devstat_num_devs
operator|++
expr_stmt|;
name|devstat_head
operator|=
operator|&
name|device_statq
expr_stmt|;
comment|/* 	 * Priority sort.  Each driver passes in its priority when it adds 	 * its devstat entry.  Drivers are sorted first by priority, and 	 * then by probe order. 	 *  	 * For the first device, we just insert it, since the priority 	 * doesn't really matter yet.  Subsequent devices are inserted into 	 * the list using the order outlined above. 	 */
if|if
condition|(
name|devstat_num_devs
operator|==
literal|1
condition|)
name|STAILQ_INSERT_TAIL
argument_list|(
name|devstat_head
argument_list|,
name|ds
argument_list|,
name|dev_links
argument_list|)
expr_stmt|;
else|else
block|{
name|STAILQ_FOREACH
argument_list|(
argument|ds_tmp
argument_list|,
argument|devstat_head
argument_list|,
argument|dev_links
argument_list|)
block|{
name|struct
name|devstat
modifier|*
name|ds_next
decl_stmt|;
name|ds_next
operator|=
name|STAILQ_NEXT
argument_list|(
name|ds_tmp
argument_list|,
name|dev_links
argument_list|)
expr_stmt|;
comment|/* 			 * If we find a break between higher and lower 			 * priority items, and if this item fits in the 			 * break, insert it.  This also applies if the 			 * "lower priority item" is the end of the list. 			 */
if|if
condition|(
operator|(
name|priority
operator|<=
name|ds_tmp
operator|->
name|priority
operator|)
operator|&&
operator|(
operator|(
name|ds_next
operator|==
name|NULL
operator|)
operator|||
operator|(
name|priority
operator|>
name|ds_next
operator|->
name|priority
operator|)
operator|)
condition|)
block|{
name|STAILQ_INSERT_AFTER
argument_list|(
name|devstat_head
argument_list|,
name|ds_tmp
argument_list|,
name|ds
argument_list|,
name|dev_links
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|priority
operator|>
name|ds_tmp
operator|->
name|priority
condition|)
block|{
comment|/* 				 * If this is the case, we should be able 				 * to insert ourselves at the head of the 				 * list.  If we can't, something is wrong. 				 */
if|if
condition|(
name|ds_tmp
operator|==
name|STAILQ_FIRST
argument_list|(
name|devstat_head
argument_list|)
condition|)
block|{
name|STAILQ_INSERT_HEAD
argument_list|(
name|devstat_head
argument_list|,
name|ds
argument_list|,
name|dev_links
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|STAILQ_INSERT_TAIL
argument_list|(
name|devstat_head
argument_list|,
name|ds
argument_list|,
name|dev_links
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"devstat_add_entry: HELP! "
literal|"sorting problem detected "
literal|"for name %p unit %d\n"
argument_list|,
name|dev_name
argument_list|,
name|unit_number
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|ds
operator|->
name|device_number
operator|=
name|devstat_current_devnumber
operator|++
expr_stmt|;
name|ds
operator|->
name|unit_number
operator|=
name|unit_number
expr_stmt|;
name|strlcpy
argument_list|(
name|ds
operator|->
name|device_name
argument_list|,
name|dev_name
argument_list|,
name|DEVSTAT_NAME_LEN
argument_list|)
expr_stmt|;
name|ds
operator|->
name|block_size
operator|=
name|block_size
expr_stmt|;
name|ds
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|ds
operator|->
name|device_type
operator|=
name|device_type
expr_stmt|;
name|ds
operator|->
name|priority
operator|=
name|priority
expr_stmt|;
name|binuptime
argument_list|(
operator|&
name|ds
operator|->
name|creation_time
argument_list|)
expr_stmt|;
name|devstat_generation
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a devstat structure from the list of devices.  */
end_comment

begin_function
name|void
name|devstat_remove_entry
parameter_list|(
name|struct
name|devstat
modifier|*
name|ds
parameter_list|)
block|{
name|struct
name|devstatlist
modifier|*
name|devstat_head
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|devstat_mutex
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|devstat_mutex
argument_list|)
expr_stmt|;
name|devstat_head
operator|=
operator|&
name|device_statq
expr_stmt|;
comment|/* Remove this entry from the devstat queue */
name|atomic_add_acq_int
argument_list|(
operator|&
name|ds
operator|->
name|sequence1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|id
operator|==
name|NULL
condition|)
block|{
name|devstat_num_devs
operator|--
expr_stmt|;
name|STAILQ_REMOVE
argument_list|(
name|devstat_head
argument_list|,
name|ds
argument_list|,
name|devstat
argument_list|,
name|dev_links
argument_list|)
expr_stmt|;
block|}
name|devstat_free
argument_list|(
name|ds
argument_list|)
expr_stmt|;
name|devstat_generation
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|devstat_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Record a transaction start.  *  * See comments for devstat_end_transaction().  Ordering is very important  * here.  */
end_comment

begin_function
name|void
name|devstat_start_transaction
parameter_list|(
name|struct
name|devstat
modifier|*
name|ds
parameter_list|,
name|struct
name|bintime
modifier|*
name|now
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|devstat_mutex
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
comment|/* sanity check */
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
return|return;
name|atomic_add_acq_int
argument_list|(
operator|&
name|ds
operator|->
name|sequence1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * We only want to set the start time when we are going from idle 	 * to busy.  The start time is really the start of the latest busy 	 * period. 	 */
if|if
condition|(
name|ds
operator|->
name|start_count
operator|==
name|ds
operator|->
name|end_count
condition|)
block|{
if|if
condition|(
name|now
operator|!=
name|NULL
condition|)
name|ds
operator|->
name|busy_from
operator|=
operator|*
name|now
expr_stmt|;
else|else
name|binuptime
argument_list|(
operator|&
name|ds
operator|->
name|busy_from
argument_list|)
expr_stmt|;
block|}
name|ds
operator|->
name|start_count
operator|++
expr_stmt|;
name|atomic_add_rel_int
argument_list|(
operator|&
name|ds
operator|->
name|sequence0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|devstat_start_transaction_bio
parameter_list|(
name|struct
name|devstat
modifier|*
name|ds
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|devstat_mutex
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
comment|/* sanity check */
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
return|return;
name|binuptime
argument_list|(
operator|&
name|bp
operator|->
name|bio_t0
argument_list|)
expr_stmt|;
name|devstat_start_transaction
argument_list|(
name|ds
argument_list|,
operator|&
name|bp
operator|->
name|bio_t0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Record the ending of a transaction, and incrment the various counters.  *  * Ordering in this function, and in devstat_start_transaction() is VERY  * important.  The idea here is to run without locks, so we are very  * careful to only modify some fields on the way "down" (i.e. at  * transaction start) and some fields on the way "up" (i.e. at transaction  * completion).  One exception is busy_from, which we only modify in  * devstat_start_transaction() when there are no outstanding transactions,  * and thus it can't be modified in devstat_end_transaction()  * simultaneously.  *  * The sequence0 and sequence1 fields are provided to enable an application  * spying on the structures with mmap(2) to tell when a structure is in a  * consistent state or not.  *  * For this to work 100% reliably, it is important that the two fields  * are at opposite ends of the structure and that they are incremented  * in the opposite order of how a memcpy(3) in userland would copy them.  * We assume that the copying happens front to back, but there is actually  * no way short of writing your own memcpy(3) replacement to guarantee  * this will be the case.  *  * In addition to this, being a kind of locks, they must be updated with  * atomic instructions using appropriate memory barriers.  */
end_comment

begin_function
name|void
name|devstat_end_transaction
parameter_list|(
name|struct
name|devstat
modifier|*
name|ds
parameter_list|,
name|u_int32_t
name|bytes
parameter_list|,
name|devstat_tag_type
name|tag_type
parameter_list|,
name|devstat_trans_flags
name|flags
parameter_list|,
name|struct
name|bintime
modifier|*
name|now
parameter_list|,
name|struct
name|bintime
modifier|*
name|then
parameter_list|)
block|{
name|struct
name|bintime
name|dt
decl_stmt|,
name|lnow
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|now
operator|==
name|NULL
condition|)
block|{
name|now
operator|=
operator|&
name|lnow
expr_stmt|;
name|binuptime
argument_list|(
name|now
argument_list|)
expr_stmt|;
block|}
name|atomic_add_acq_int
argument_list|(
operator|&
name|ds
operator|->
name|sequence1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Update byte and operations counts */
name|ds
operator|->
name|bytes
index|[
name|flags
index|]
operator|+=
name|bytes
expr_stmt|;
name|ds
operator|->
name|operations
index|[
name|flags
index|]
operator|++
expr_stmt|;
comment|/* 	 * Keep a count of the various tag types sent. 	 */
if|if
condition|(
operator|(
name|ds
operator|->
name|flags
operator|&
name|DEVSTAT_NO_ORDERED_TAGS
operator|)
operator|==
literal|0
operator|&&
name|tag_type
operator|!=
name|DEVSTAT_TAG_NONE
condition|)
name|ds
operator|->
name|tag_types
index|[
name|tag_type
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|then
operator|!=
name|NULL
condition|)
block|{
comment|/* Update duration of operations */
name|dt
operator|=
operator|*
name|now
expr_stmt|;
name|bintime_sub
argument_list|(
operator|&
name|dt
argument_list|,
name|then
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|ds
operator|->
name|duration
index|[
name|flags
index|]
argument_list|,
operator|&
name|dt
argument_list|)
expr_stmt|;
block|}
comment|/* Accumulate busy time */
name|dt
operator|=
operator|*
name|now
expr_stmt|;
name|bintime_sub
argument_list|(
operator|&
name|dt
argument_list|,
operator|&
name|ds
operator|->
name|busy_from
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|ds
operator|->
name|busy_time
argument_list|,
operator|&
name|dt
argument_list|)
expr_stmt|;
name|ds
operator|->
name|busy_from
operator|=
operator|*
name|now
expr_stmt|;
name|ds
operator|->
name|end_count
operator|++
expr_stmt|;
name|atomic_add_rel_int
argument_list|(
operator|&
name|ds
operator|->
name|sequence0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|devstat_end_transaction_bio
parameter_list|(
name|struct
name|devstat
modifier|*
name|ds
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|devstat_trans_flags
name|flg
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_DELETE
condition|)
name|flg
operator|=
name|DEVSTAT_FREE
expr_stmt|;
elseif|else
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
name|flg
operator|=
name|DEVSTAT_READ
expr_stmt|;
elseif|else
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_WRITE
condition|)
name|flg
operator|=
name|DEVSTAT_WRITE
expr_stmt|;
else|else
name|flg
operator|=
name|DEVSTAT_NO_DATA
expr_stmt|;
name|devstat_end_transaction
argument_list|(
name|ds
argument_list|,
name|bp
operator|->
name|bio_bcount
operator|-
name|bp
operator|->
name|bio_resid
argument_list|,
name|DEVSTAT_TAG_SIMPLE
argument_list|,
name|flg
argument_list|,
name|NULL
argument_list|,
operator|&
name|bp
operator|->
name|bio_t0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the sysctl handler for the devstat package.  The data pushed out  * on the kern.devstat.all sysctl variable consists of the current devstat  * generation number, and then an array of devstat structures, one for each  * device in the system.  *  * This is more cryptic that obvious, but basically we neither can nor  * want to hold the devstat_mutex for any amount of time, so we grab it  * only when we need to and keep an eye on devstat_generation all the time.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_devstat
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|long
name|mygen
decl_stmt|;
name|struct
name|devstat
modifier|*
name|nds
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|devstat_mutex
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
comment|/* 	 * XXX devstat_generation should really be "volatile" but that 	 * XXX freaks out the sysctl macro below.  The places where we 	 * XXX change it and inspect it are bracketed in the mutex which 	 * XXX guarantees us proper write barriers.  I don't belive the 	 * XXX compiler is allowed to optimize mygen away across calls 	 * XXX to other functions, so the following is belived to be safe. 	 */
name|mygen
operator|=
name|devstat_generation
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|mygen
argument_list|,
sizeof|sizeof
argument_list|(
name|mygen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|devstat_num_devs
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|devstat_mutex
argument_list|)
expr_stmt|;
name|nds
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|device_statq
argument_list|)
expr_stmt|;
if|if
condition|(
name|mygen
operator|!=
name|devstat_generation
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|devstat_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
init|;
name|nds
operator|!=
name|NULL
condition|;
control|)
block|{
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|nds
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|devstat
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|devstat_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|mygen
operator|!=
name|devstat_generation
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
else|else
name|nds
operator|=
name|STAILQ_NEXT
argument_list|(
name|nds
argument_list|,
name|dev_links
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|devstat_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sysctl entries for devstat.  The first one is a node that all the rest  * hang off of.   */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|devstat
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Device Statistics"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_devstat
argument_list|,
name|OID_AUTO
argument_list|,
name|all
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_devstat
argument_list|,
literal|"S,devstat"
argument_list|,
literal|"All devices in the devstat list"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Export the number of devices in the system so that userland utilities  * can determine how much memory to allocate to hold all the devices.  */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_devstat
argument_list|,
name|OID_AUTO
argument_list|,
name|numdevs
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|devstat_num_devs
argument_list|,
literal|0
argument_list|,
literal|"Number of devices in the devstat list"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_kern_devstat
argument_list|,
name|OID_AUTO
argument_list|,
name|generation
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|devstat_generation
argument_list|,
literal|0
argument_list|,
literal|"Devstat list generation"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_devstat
argument_list|,
name|OID_AUTO
argument_list|,
name|version
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|devstat_version
argument_list|,
literal|0
argument_list|,
literal|"Devstat list version number"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Allocator for struct devstat structures.  We sub-allocate these from pages  * which we get from malloc.  These pages are exported for mmap(2)'ing through  * a miniature device driver  */
end_comment

begin_define
define|#
directive|define
name|statsperpage
value|(PAGE_SIZE / sizeof(struct devstat))
end_define

begin_decl_stmt
specifier|static
name|d_mmap_t
name|devstat_mmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|devstat_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_flags
operator|=
name|D_NEEDGIANT
block|,
operator|.
name|d_mmap
operator|=
name|devstat_mmap
block|,
operator|.
name|d_name
operator|=
literal|"devstat"
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|statspage
block|{
name|TAILQ_ENTRY
argument_list|(
argument|statspage
argument_list|)
name|list
expr_stmt|;
name|struct
name|devstat
modifier|*
name|stat
decl_stmt|;
name|u_int
name|nfree
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|statspage
argument_list|)
name|pagelist
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|pagelist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_DEVSTAT
argument_list|,
literal|"devstat"
argument_list|,
literal|"Device statistics"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|devstat_mmap
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|,
name|vm_paddr_t
modifier|*
name|paddr
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
name|struct
name|statspage
modifier|*
name|spp
decl_stmt|;
if|if
condition|(
name|nprot
operator|!=
name|VM_PROT_READ
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|TAILQ_FOREACH
argument_list|(
argument|spp
argument_list|,
argument|&pagelist
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
operator|*
name|paddr
operator|=
name|vtophys
argument_list|(
name|spp
operator|->
name|stat
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|offset
operator|-=
name|PAGE_SIZE
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|devstat
modifier|*
name|devstat_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|devstat
modifier|*
name|dsp
decl_stmt|;
name|struct
name|statspage
modifier|*
name|spp
decl_stmt|,
modifier|*
name|spp2
decl_stmt|;
name|u_int
name|u
decl_stmt|;
specifier|static
name|int
name|once
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|devstat_mutex
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|once
condition|)
block|{
name|make_dev
argument_list|(
operator|&
name|devstat_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0400
argument_list|,
name|DEVSTAT_DEVICE_NAME
argument_list|)
expr_stmt|;
name|once
operator|=
literal|1
expr_stmt|;
block|}
name|spp2
operator|=
name|NULL
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|devstat_mutex
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|spp
argument_list|,
argument|&pagelist
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|spp
operator|->
name|nfree
operator|>
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|spp
operator|!=
name|NULL
condition|)
break|break;
name|mtx_unlock
argument_list|(
operator|&
name|devstat_mutex
argument_list|)
expr_stmt|;
name|spp2
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|spp
argument_list|,
name|M_DEVSTAT
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|spp2
operator|->
name|stat
operator|=
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_DEVSTAT
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|spp2
operator|->
name|nfree
operator|=
name|statsperpage
expr_stmt|;
comment|/* 		 * If free statspages were added while the lock was released 		 * just reuse them. 		 */
name|mtx_lock
argument_list|(
operator|&
name|devstat_mutex
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|spp
argument_list|,
argument|&pagelist
argument_list|,
argument|list
argument_list|)
if|if
condition|(
name|spp
operator|->
name|nfree
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|spp
operator|==
name|NULL
condition|)
block|{
name|spp
operator|=
name|spp2
expr_stmt|;
comment|/* 			 * It would make more sense to add the new page at the 			 * head but the order on the list determine the 			 * sequence of the mapping so we can't do that. 			 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pagelist
argument_list|,
name|spp
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
name|dsp
operator|=
name|spp
operator|->
name|stat
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|statsperpage
condition|;
name|u
operator|++
control|)
block|{
if|if
condition|(
name|dsp
operator|->
name|allocated
operator|==
literal|0
condition|)
break|break;
name|dsp
operator|++
expr_stmt|;
block|}
name|spp
operator|->
name|nfree
operator|--
expr_stmt|;
name|dsp
operator|->
name|allocated
operator|=
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|devstat_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|spp2
operator|!=
name|NULL
operator|&&
name|spp2
operator|!=
name|spp
condition|)
block|{
name|free
argument_list|(
name|spp2
operator|->
name|stat
argument_list|,
name|M_DEVSTAT
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|spp2
argument_list|,
name|M_DEVSTAT
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dsp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|devstat_free
parameter_list|(
name|struct
name|devstat
modifier|*
name|dsp
parameter_list|)
block|{
name|struct
name|statspage
modifier|*
name|spp
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|devstat_mutex
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|dsp
argument_list|,
sizeof|sizeof
expr|*
name|dsp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|spp
argument_list|,
argument|&pagelist
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|dsp
operator|>=
name|spp
operator|->
name|stat
operator|&&
name|dsp
operator|<
operator|(
name|spp
operator|->
name|stat
operator|+
name|statsperpage
operator|)
condition|)
block|{
name|spp
operator|->
name|nfree
operator|++
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_sizeof
argument_list|,
name|OID_AUTO
argument_list|,
name|devstat
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|devstat
argument_list|)
argument_list|,
literal|"sizeof(struct devstat)"
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

