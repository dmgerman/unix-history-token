begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, 1998, 1999 Kenneth D. Merry.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<sys/devicestat.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|devstat_num_devs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|devstat_generation
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|devstat_version
init|=
name|DEVSTAT_VERSION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|devstat_current_devnumber
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|devstatlist
name|device_statq
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|devstat
modifier|*
name|devstat_alloc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|devstat_free
parameter_list|(
name|struct
name|devstat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|devstat_add_entry
parameter_list|(
name|struct
name|devstat
modifier|*
name|ds
parameter_list|,
specifier|const
name|char
modifier|*
name|dev_name
parameter_list|,
name|int
name|unit_number
parameter_list|,
name|u_int32_t
name|block_size
parameter_list|,
name|devstat_support_flags
name|flags
parameter_list|,
name|devstat_type_flags
name|device_type
parameter_list|,
name|devstat_priority
name|priority
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Allocate a devstat and initialize it  */
end_comment

begin_function
name|struct
name|devstat
modifier|*
name|devstat_new_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|dev_name
parameter_list|,
name|int
name|unit_number
parameter_list|,
name|u_int32_t
name|block_size
parameter_list|,
name|devstat_support_flags
name|flags
parameter_list|,
name|devstat_type_flags
name|device_type
parameter_list|,
name|devstat_priority
name|priority
parameter_list|)
block|{
name|struct
name|devstat
modifier|*
name|ds
decl_stmt|;
name|ds
operator|=
name|devstat_alloc
argument_list|()
expr_stmt|;
name|devstat_add_entry
argument_list|(
name|ds
argument_list|,
name|dev_name
argument_list|,
name|unit_number
argument_list|,
name|block_size
argument_list|,
name|flags
argument_list|,
name|device_type
argument_list|,
name|priority
argument_list|)
expr_stmt|;
return|return
operator|(
name|ds
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Take a malloced and zeroed devstat structure given to us, fill it in   * and add it to the queue of devices.    */
end_comment

begin_function
specifier|static
name|void
name|devstat_add_entry
parameter_list|(
name|struct
name|devstat
modifier|*
name|ds
parameter_list|,
specifier|const
name|char
modifier|*
name|dev_name
parameter_list|,
name|int
name|unit_number
parameter_list|,
name|u_int32_t
name|block_size
parameter_list|,
name|devstat_support_flags
name|flags
parameter_list|,
name|devstat_type_flags
name|device_type
parameter_list|,
name|devstat_priority
name|priority
parameter_list|)
block|{
name|struct
name|devstatlist
modifier|*
name|devstat_head
decl_stmt|;
name|struct
name|devstat
modifier|*
name|ds_tmp
decl_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|devstat_num_devs
operator|==
literal|0
condition|)
name|STAILQ_INIT
argument_list|(
operator|&
name|device_statq
argument_list|)
expr_stmt|;
name|devstat_generation
operator|++
expr_stmt|;
name|devstat_num_devs
operator|++
expr_stmt|;
name|devstat_head
operator|=
operator|&
name|device_statq
expr_stmt|;
comment|/* 	 * Priority sort.  Each driver passes in its priority when it adds 	 * its devstat entry.  Drivers are sorted first by priority, and 	 * then by probe order. 	 *  	 * For the first device, we just insert it, since the priority 	 * doesn't really matter yet.  Subsequent devices are inserted into 	 * the list using the order outlined above. 	 */
if|if
condition|(
name|devstat_num_devs
operator|==
literal|1
condition|)
name|STAILQ_INSERT_TAIL
argument_list|(
name|devstat_head
argument_list|,
name|ds
argument_list|,
name|dev_links
argument_list|)
expr_stmt|;
else|else
block|{
name|STAILQ_FOREACH
argument_list|(
argument|ds_tmp
argument_list|,
argument|devstat_head
argument_list|,
argument|dev_links
argument_list|)
block|{
name|struct
name|devstat
modifier|*
name|ds_next
decl_stmt|;
name|ds_next
operator|=
name|STAILQ_NEXT
argument_list|(
name|ds_tmp
argument_list|,
name|dev_links
argument_list|)
expr_stmt|;
comment|/* 			 * If we find a break between higher and lower 			 * priority items, and if this item fits in the 			 * break, insert it.  This also applies if the 			 * "lower priority item" is the end of the list. 			 */
if|if
condition|(
operator|(
name|priority
operator|<=
name|ds_tmp
operator|->
name|priority
operator|)
operator|&&
operator|(
operator|(
name|ds_next
operator|==
name|NULL
operator|)
operator|||
operator|(
name|priority
operator|>
name|ds_next
operator|->
name|priority
operator|)
operator|)
condition|)
block|{
name|STAILQ_INSERT_AFTER
argument_list|(
name|devstat_head
argument_list|,
name|ds_tmp
argument_list|,
name|ds
argument_list|,
name|dev_links
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|priority
operator|>
name|ds_tmp
operator|->
name|priority
condition|)
block|{
comment|/* 				 * If this is the case, we should be able 				 * to insert ourselves at the head of the 				 * list.  If we can't, something is wrong. 				 */
if|if
condition|(
name|ds_tmp
operator|==
name|STAILQ_FIRST
argument_list|(
name|devstat_head
argument_list|)
condition|)
block|{
name|STAILQ_INSERT_HEAD
argument_list|(
name|devstat_head
argument_list|,
name|ds
argument_list|,
name|dev_links
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|STAILQ_INSERT_TAIL
argument_list|(
name|devstat_head
argument_list|,
name|ds
argument_list|,
name|dev_links
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"devstat_add_entry: HELP! "
literal|"sorting problem detected "
literal|"for %s%d\n"
argument_list|,
name|dev_name
argument_list|,
name|unit_number
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
name|ds
operator|->
name|device_number
operator|=
name|devstat_current_devnumber
operator|++
expr_stmt|;
name|ds
operator|->
name|unit_number
operator|=
name|unit_number
expr_stmt|;
name|strlcpy
argument_list|(
name|ds
operator|->
name|device_name
argument_list|,
name|dev_name
argument_list|,
name|DEVSTAT_NAME_LEN
argument_list|)
expr_stmt|;
name|ds
operator|->
name|block_size
operator|=
name|block_size
expr_stmt|;
name|ds
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|ds
operator|->
name|device_type
operator|=
name|device_type
expr_stmt|;
name|ds
operator|->
name|priority
operator|=
name|priority
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|ds
operator|->
name|dev_creation_time
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a devstat structure from the list of devices.  */
end_comment

begin_function
name|void
name|devstat_remove_entry
parameter_list|(
name|struct
name|devstat
modifier|*
name|ds
parameter_list|)
block|{
name|struct
name|devstatlist
modifier|*
name|devstat_head
decl_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
return|return;
name|devstat_generation
operator|++
expr_stmt|;
name|devstat_num_devs
operator|--
expr_stmt|;
name|devstat_head
operator|=
operator|&
name|device_statq
expr_stmt|;
comment|/* Remove this entry from the devstat queue */
name|STAILQ_REMOVE
argument_list|(
name|devstat_head
argument_list|,
name|ds
argument_list|,
name|devstat
argument_list|,
name|dev_links
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|allocated
condition|)
name|devstat_free
argument_list|(
name|ds
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Record a transaction start.  */
end_comment

begin_function
name|void
name|devstat_start_transaction
parameter_list|(
name|struct
name|devstat
modifier|*
name|ds
parameter_list|)
block|{
comment|/* sanity check */
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * We only want to set the start time when we are going from idle 	 * to busy.  The start time is really the start of the latest busy 	 * period. 	 */
if|if
condition|(
name|ds
operator|->
name|busy_count
operator|==
literal|0
condition|)
name|getmicrouptime
argument_list|(
operator|&
name|ds
operator|->
name|start_time
argument_list|)
expr_stmt|;
name|ds
operator|->
name|busy_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Record the ending of a transaction, and incrment the various counters.  */
end_comment

begin_function
name|void
name|devstat_end_transaction
parameter_list|(
name|struct
name|devstat
modifier|*
name|ds
parameter_list|,
name|u_int32_t
name|bytes
parameter_list|,
name|devstat_tag_type
name|tag_type
parameter_list|,
name|devstat_trans_flags
name|flags
parameter_list|)
block|{
name|struct
name|timeval
name|busy_time
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
return|return;
name|getmicrouptime
argument_list|(
operator|&
name|ds
operator|->
name|last_comp_time
argument_list|)
expr_stmt|;
name|ds
operator|->
name|busy_count
operator|--
expr_stmt|;
comment|/* 	 * There might be some transactions (DEVSTAT_NO_DATA) that don't 	 * transfer any data. 	 */
if|if
condition|(
name|flags
operator|==
name|DEVSTAT_READ
condition|)
block|{
name|ds
operator|->
name|bytes_read
operator|+=
name|bytes
expr_stmt|;
name|ds
operator|->
name|num_reads
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|==
name|DEVSTAT_WRITE
condition|)
block|{
name|ds
operator|->
name|bytes_written
operator|+=
name|bytes
expr_stmt|;
name|ds
operator|->
name|num_writes
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|==
name|DEVSTAT_FREE
condition|)
block|{
name|ds
operator|->
name|bytes_freed
operator|+=
name|bytes
expr_stmt|;
name|ds
operator|->
name|num_frees
operator|++
expr_stmt|;
block|}
else|else
name|ds
operator|->
name|num_other
operator|++
expr_stmt|;
comment|/* 	 * Keep a count of the various tag types sent. 	 */
if|if
condition|(
operator|(
name|ds
operator|->
name|flags
operator|&
name|DEVSTAT_NO_ORDERED_TAGS
operator|)
operator|==
literal|0
operator|&&
name|tag_type
operator|!=
name|DEVSTAT_TAG_NONE
condition|)
name|ds
operator|->
name|tag_types
index|[
name|tag_type
index|]
operator|++
expr_stmt|;
comment|/* 	 * We only update the busy time when we go idle.  Otherwise, this 	 * calculation would require many more clock cycles. 	 */
if|if
condition|(
name|ds
operator|->
name|busy_count
operator|==
literal|0
condition|)
block|{
comment|/* Calculate how long we were busy */
name|busy_time
operator|=
name|ds
operator|->
name|last_comp_time
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|busy_time
argument_list|,
operator|&
name|ds
operator|->
name|start_time
argument_list|)
expr_stmt|;
comment|/* Add our busy time to the total busy time. */
name|timevaladd
argument_list|(
operator|&
name|ds
operator|->
name|busy_time
argument_list|,
operator|&
name|busy_time
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ds
operator|->
name|busy_count
operator|<
literal|0
condition|)
name|printf
argument_list|(
literal|"devstat_end_transaction: HELP!! busy_count "
literal|"for %s%d is< 0 (%d)!\n"
argument_list|,
name|ds
operator|->
name|device_name
argument_list|,
name|ds
operator|->
name|unit_number
argument_list|,
name|ds
operator|->
name|busy_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|devstat_end_transaction_bio
parameter_list|(
name|struct
name|devstat
modifier|*
name|ds
parameter_list|,
name|struct
name|bio
modifier|*
name|bp
parameter_list|)
block|{
name|devstat_trans_flags
name|flg
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_DELETE
condition|)
name|flg
operator|=
name|DEVSTAT_FREE
expr_stmt|;
elseif|else
if|if
condition|(
name|bp
operator|->
name|bio_cmd
operator|==
name|BIO_READ
condition|)
name|flg
operator|=
name|DEVSTAT_READ
expr_stmt|;
else|else
name|flg
operator|=
name|DEVSTAT_WRITE
expr_stmt|;
name|devstat_end_transaction
argument_list|(
name|ds
argument_list|,
name|bp
operator|->
name|bio_bcount
operator|-
name|bp
operator|->
name|bio_resid
argument_list|,
name|DEVSTAT_TAG_SIMPLE
argument_list|,
name|flg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the sysctl handler for the devstat package.  The data pushed out  * on the kern.devstat.all sysctl variable consists of the current devstat  * generation number, and then an array of devstat structures, one for each  * device in the system.  *  * I'm really not too fond of this method of doing things, but there really  * aren't that many alternatives.  We must have some method of making sure  * that the generation number the user gets corresponds with the data the  * user gets.  If the user makes a separate sysctl call to get the  * generation, and then a sysctl call to get the device statistics, the  * device list could have changed in that brief period of time.  By  * supplying the generation number along with the statistics output, we can  * guarantee that the generation number and the statistics match up.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_devstat
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|devstat
modifier|*
name|nds
decl_stmt|;
name|struct
name|devstatlist
modifier|*
name|devstat_head
decl_stmt|;
if|if
condition|(
name|devstat_num_devs
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
name|devstat_head
operator|=
operator|&
name|device_statq
expr_stmt|;
comment|/* 	 * First push out the generation number. 	 */
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|devstat_generation
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now push out all the devices. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|nds
operator|=
name|STAILQ_FIRST
argument_list|(
name|devstat_head
argument_list|)
init|;
operator|(
name|nds
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|i
operator|<
name|devstat_num_devs
operator|)
operator|&&
operator|(
name|error
operator|==
literal|0
operator|)
condition|;
name|nds
operator|=
name|STAILQ_NEXT
argument_list|(
name|nds
argument_list|,
name|dev_links
argument_list|)
operator|,
name|i
operator|++
control|)
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|nds
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|devstat
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sysctl entries for devstat.  The first one is a node that all the rest  * hang off of.   */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|devstat
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"Device Statistics"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_devstat
argument_list|,
name|OID_AUTO
argument_list|,
name|all
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_devstat
argument_list|,
literal|"S,devstat"
argument_list|,
literal|"All devices in the devstat list"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Export the number of devices in the system so that userland utilities  * can determine how much memory to allocate to hold all the devices.  */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_devstat
argument_list|,
name|OID_AUTO
argument_list|,
name|numdevs
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|devstat_num_devs
argument_list|,
literal|0
argument_list|,
literal|"Number of devices in the devstat list"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_kern_devstat
argument_list|,
name|OID_AUTO
argument_list|,
name|generation
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|devstat_generation
argument_list|,
literal|0
argument_list|,
literal|"Devstat list generation"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_devstat
argument_list|,
name|OID_AUTO
argument_list|,
name|version
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|devstat_version
argument_list|,
literal|0
argument_list|,
literal|"Devstat list version number"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|statsperpage
value|(PAGE_SIZE / sizeof(struct devstat))
end_define

begin_decl_stmt
specifier|static
name|d_mmap_t
name|devstat_mmap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|devstat_cdevsw
init|=
block|{
operator|.
name|d_open
operator|=
name|nullopen
block|,
operator|.
name|d_close
operator|=
name|nullclose
block|,
operator|.
name|d_mmap
operator|=
name|devstat_mmap
block|,
operator|.
name|d_name
operator|=
literal|"devstat"
block|,
operator|.
name|d_maj
operator|=
name|MAJOR_AUTO
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|statspage
block|{
name|TAILQ_ENTRY
argument_list|(
argument|statspage
argument_list|)
name|list
expr_stmt|;
name|struct
name|devstat
modifier|*
name|stat
decl_stmt|;
name|u_int
name|nfree
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|statspage
argument_list|)
name|pagelist
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|pagelist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_DEVSTAT
argument_list|,
literal|"devstat"
argument_list|,
literal|"Device statistics"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|devstat_mmap
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|,
name|vm_offset_t
modifier|*
name|paddr
parameter_list|,
name|int
name|nprot
parameter_list|)
block|{
name|struct
name|statspage
modifier|*
name|spp
decl_stmt|;
if|if
condition|(
name|nprot
operator|!=
name|VM_PROT_READ
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|TAILQ_FOREACH
argument_list|(
argument|spp
argument_list|,
argument|&pagelist
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
operator|*
name|paddr
operator|=
name|vtophys
argument_list|(
name|spp
operator|->
name|stat
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|offset
operator|-=
name|PAGE_SIZE
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|devstat
modifier|*
name|devstat_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|devstat
modifier|*
name|dsp
decl_stmt|;
name|struct
name|statspage
modifier|*
name|spp
decl_stmt|;
name|u_int
name|u
decl_stmt|;
specifier|static
name|int
name|once
decl_stmt|;
if|if
condition|(
operator|!
name|once
condition|)
block|{
name|make_dev
argument_list|(
operator|&
name|devstat_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0400
argument_list|,
literal|"devstat"
argument_list|)
expr_stmt|;
name|once
operator|++
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|spp
argument_list|,
argument|&pagelist
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|spp
operator|->
name|nfree
operator|>
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|spp
operator|==
name|NULL
condition|)
block|{
name|spp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|spp
argument_list|,
name|M_DEVSTAT
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pagelist
argument_list|,
name|spp
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|spp
operator|->
name|stat
operator|=
name|malloc
argument_list|(
name|PAGE_SIZE
argument_list|,
name|M_DEVSTAT
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|spp
operator|->
name|nfree
operator|=
name|statsperpage
expr_stmt|;
block|}
name|dsp
operator|=
name|spp
operator|->
name|stat
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|statsperpage
condition|;
name|u
operator|++
control|)
block|{
if|if
condition|(
name|dsp
operator|->
name|allocated
operator|==
literal|0
condition|)
break|break;
name|dsp
operator|++
expr_stmt|;
block|}
name|spp
operator|->
name|nfree
operator|--
expr_stmt|;
name|dsp
operator|->
name|allocated
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|dsp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|devstat_free
parameter_list|(
name|struct
name|devstat
modifier|*
name|dsp
parameter_list|)
block|{
name|struct
name|statspage
modifier|*
name|spp
decl_stmt|;
name|bzero
argument_list|(
name|dsp
argument_list|,
sizeof|sizeof
expr|*
name|dsp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|spp
argument_list|,
argument|&pagelist
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|dsp
operator|>=
name|spp
operator|->
name|stat
operator|&&
name|dsp
operator|<
operator|(
name|spp
operator|->
name|stat
operator|+
name|statsperpage
operator|)
condition|)
block|{
name|spp
operator|->
name|nfree
operator|++
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

end_unit

