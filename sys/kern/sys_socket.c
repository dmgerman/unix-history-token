begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)sys_socket.c	8.1 (Berkeley) 6/10/93  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/aio.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/sigio.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_comment
comment|/* XXX */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<sys/unpcb.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|aio
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"socket AIO stats"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|empty_results
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|empty_results
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|empty_results
argument_list|,
literal|0
argument_list|,
literal|"socket operation returned EAGAIN"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|empty_retries
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|empty_retries
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|empty_retries
argument_list|,
literal|0
argument_list|,
literal|"socket operation retries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|fo_rdwr_t
name|soo_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_rdwr_t
name|soo_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_ioctl_t
name|soo_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_poll_t
name|soo_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|fo_kqfilter_t
name|soo_kqfilter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_stat_t
name|soo_stat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_close_t
name|soo_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_fill_kinfo_t
name|soo_fill_kinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_aio_queue_t
name|soo_aio_queue
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|soo_aio_cancel
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|fileops
name|socketops
init|=
block|{
operator|.
name|fo_read
operator|=
name|soo_read
block|,
operator|.
name|fo_write
operator|=
name|soo_write
block|,
operator|.
name|fo_truncate
operator|=
name|invfo_truncate
block|,
operator|.
name|fo_ioctl
operator|=
name|soo_ioctl
block|,
operator|.
name|fo_poll
operator|=
name|soo_poll
block|,
operator|.
name|fo_kqfilter
operator|=
name|soo_kqfilter
block|,
operator|.
name|fo_stat
operator|=
name|soo_stat
block|,
operator|.
name|fo_close
operator|=
name|soo_close
block|,
operator|.
name|fo_chmod
operator|=
name|invfo_chmod
block|,
operator|.
name|fo_chown
operator|=
name|invfo_chown
block|,
operator|.
name|fo_sendfile
operator|=
name|invfo_sendfile
block|,
operator|.
name|fo_fill_kinfo
operator|=
name|soo_fill_kinfo
block|,
operator|.
name|fo_aio_queue
operator|=
name|soo_aio_queue
block|,
operator|.
name|fo_flags
operator|=
name|DFLAG_PASSABLE
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|soo_read
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_socket_check_receive
argument_list|(
name|active_cred
argument_list|,
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
name|error
operator|=
name|soreceive
argument_list|(
name|so
argument_list|,
literal|0
argument_list|,
name|uio
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|soo_write
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_socket_check_send
argument_list|(
name|active_cred
argument_list|,
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
name|error
operator|=
name|sosend
argument_list|(
name|so
argument_list|,
literal|0
argument_list|,
name|uio
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|uio
operator|->
name|uio_td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EPIPE
operator|&&
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_NOSIGPIPE
operator|)
operator|==
literal|0
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|uio
operator|->
name|uio_td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|tdsignal
argument_list|(
name|uio
operator|->
name|uio_td
argument_list|,
name|SIGPIPE
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|uio
operator|->
name|uio_td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|soo_ioctl
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FIONBIO
case|:
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
name|so
operator|->
name|so_state
operator||=
name|SS_NBIO
expr_stmt|;
else|else
name|so
operator|->
name|so_state
operator|&=
operator|~
name|SS_NBIO
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIOASYNC
case|:
comment|/* 		 * XXXRW: This code separately acquires SOCK_LOCK(so) and 		 * SOCKBUF_LOCK(&so->so_rcv) even though they are the same 		 * mutex to avoid introducing the assumption that they are 		 * the same. 		 */
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
condition|)
block|{
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_state
operator||=
name|SS_ASYNC
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator||=
name|SB_ASYNC
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator||=
name|SB_ASYNC
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_state
operator|&=
operator|~
name|SS_ASYNC
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator|&=
operator|~
name|SB_ASYNC
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator|&=
operator|~
name|SB_ASYNC
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FIONREAD
case|:
comment|/* Unlocked read. */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sbavail
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIONWRITE
case|:
comment|/* Unlocked read. */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sbavail
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIONSPACE
case|:
comment|/* Unlocked read. */
if|if
condition|(
operator|(
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|<
name|sbused
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
operator|)
operator|||
operator|(
name|so
operator|->
name|so_snd
operator|.
name|sb_mbmax
operator|<
name|so
operator|->
name|so_snd
operator|.
name|sb_mbcnt
operator|)
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|0
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIOSETOWN
case|:
name|error
operator|=
name|fsetown
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|,
operator|&
name|so
operator|->
name|so_sigio
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIOGETOWN
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|fgetown
argument_list|(
operator|&
name|so
operator|->
name|so_sigio
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSPGRP
case|:
name|error
operator|=
name|fsetown
argument_list|(
operator|-
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
argument_list|,
operator|&
name|so
operator|->
name|so_sigio
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGPGRP
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|-
name|fgetown
argument_list|(
operator|&
name|so
operator|->
name|so_sigio
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCATMARK
case|:
comment|/* Unlocked read. */
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_RCVATMARK
operator|)
operator|!=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* 		 * Interface/routing/protocol specific ioctls: interface and 		 * routing ioctls should have a different entry since a 		 * socket is unnecessary. 		 */
if|if
condition|(
name|IOCGROUP
argument_list|(
name|cmd
argument_list|)
operator|==
literal|'i'
condition|)
name|error
operator|=
name|ifioctl
argument_list|(
name|so
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|td
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IOCGROUP
argument_list|(
name|cmd
argument_list|)
operator|==
literal|'r'
condition|)
block|{
name|CURVNET_SET
argument_list|(
name|so
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
name|error
operator|=
name|rtioctl_fib
argument_list|(
name|cmd
argument_list|,
name|data
argument_list|,
name|so
operator|->
name|so_fibnum
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|CURVNET_SET
argument_list|(
name|so
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
name|error
operator|=
operator|(
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_control
call|)
argument_list|(
name|so
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
operator|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|soo_poll
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|int
name|error
decl_stmt|;
name|error
operator|=
name|mac_socket_check_poll
argument_list|(
name|active_cred
argument_list|,
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
name|sopoll
argument_list|(
name|so
argument_list|,
name|events
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|,
name|td
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|soo_stat
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|stat
modifier|*
name|ub
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|int
name|error
decl_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ub
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ub
argument_list|)
argument_list|)
expr_stmt|;
name|ub
operator|->
name|st_mode
operator|=
name|S_IFSOCK
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_socket_check_stat
argument_list|(
name|active_cred
argument_list|,
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
comment|/* 	 * If SBS_CANTRCVMORE is set, but there's still data left in the 	 * receive buffer, the socket is still readable. 	 */
name|sb
operator|=
operator|&
name|so
operator|->
name|so_rcv
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sb
operator|->
name|sb_state
operator|&
name|SBS_CANTRCVMORE
operator|)
operator|==
literal|0
operator|||
name|sbavail
argument_list|(
name|sb
argument_list|)
condition|)
name|ub
operator|->
name|st_mode
operator||=
name|S_IRUSR
operator||
name|S_IRGRP
operator||
name|S_IROTH
expr_stmt|;
name|ub
operator|->
name|st_size
operator|=
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|-
name|sb
operator|->
name|sb_ctl
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sb
operator|=
operator|&
name|so
operator|->
name|so_snd
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sb
operator|->
name|sb_state
operator|&
name|SBS_CANTSENDMORE
operator|)
operator|==
literal|0
condition|)
name|ub
operator|->
name|st_mode
operator||=
name|S_IWUSR
operator||
name|S_IWGRP
operator||
name|S_IWOTH
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|ub
operator|->
name|st_uid
operator|=
name|so
operator|->
name|so_cred
operator|->
name|cr_uid
expr_stmt|;
name|ub
operator|->
name|st_gid
operator|=
name|so
operator|->
name|so_cred
operator|->
name|cr_gid
expr_stmt|;
return|return
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_sense
call|)
argument_list|(
name|so
argument_list|,
name|ub
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * API socket close on file pointer.  We call soclose() to close the socket  * (including initiating closing protocols).  soclose() will sorele() the  * file reference but the actual socket will not go away until the socket's  * ref count hits 0.  */
end_comment

begin_function
specifier|static
name|int
name|soo_close
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|fp
operator|->
name|f_data
expr_stmt|;
name|fp
operator|->
name|f_ops
operator|=
operator|&
name|badfileops
expr_stmt|;
name|fp
operator|->
name|f_data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|so
condition|)
name|error
operator|=
name|soclose
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|soo_fill_kinfo
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|kinfo_file
modifier|*
name|kif
parameter_list|,
name|struct
name|filedesc
modifier|*
name|fdp
parameter_list|)
block|{
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inpcb
decl_stmt|;
name|struct
name|unpcb
modifier|*
name|unpcb
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|error
decl_stmt|;
name|kif
operator|->
name|kf_type
operator|=
name|KF_TYPE_SOCKET
expr_stmt|;
name|so
operator|=
name|fp
operator|->
name|f_data
expr_stmt|;
name|kif
operator|->
name|kf_sock_domain
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|->
name|dom_family
expr_stmt|;
name|kif
operator|->
name|kf_sock_type
operator|=
name|so
operator|->
name|so_type
expr_stmt|;
name|kif
operator|->
name|kf_sock_protocol
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
expr_stmt|;
name|kif
operator|->
name|kf_un
operator|.
name|kf_sock
operator|.
name|kf_sock_pcb
operator|=
operator|(
name|uintptr_t
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
switch|switch
condition|(
name|kif
operator|->
name|kf_sock_domain
condition|)
block|{
case|case
name|AF_INET
case|:
case|case
name|AF_INET6
case|:
if|if
condition|(
name|kif
operator|->
name|kf_sock_protocol
operator|==
name|IPPROTO_TCP
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_pcb
operator|!=
name|NULL
condition|)
block|{
name|inpcb
operator|=
operator|(
expr|struct
name|inpcb
operator|*
operator|)
operator|(
name|so
operator|->
name|so_pcb
operator|)
expr_stmt|;
name|kif
operator|->
name|kf_un
operator|.
name|kf_sock
operator|.
name|kf_sock_inpcb
operator|=
operator|(
name|uintptr_t
operator|)
name|inpcb
operator|->
name|inp_ppcb
expr_stmt|;
block|}
block|}
break|break;
case|case
name|AF_UNIX
case|:
if|if
condition|(
name|so
operator|->
name|so_pcb
operator|!=
name|NULL
condition|)
block|{
name|unpcb
operator|=
operator|(
expr|struct
name|unpcb
operator|*
operator|)
operator|(
name|so
operator|->
name|so_pcb
operator|)
expr_stmt|;
if|if
condition|(
name|unpcb
operator|->
name|unp_conn
condition|)
block|{
name|kif
operator|->
name|kf_un
operator|.
name|kf_sock
operator|.
name|kf_sock_unpconn
operator|=
operator|(
name|uintptr_t
operator|)
name|unpcb
operator|->
name|unp_conn
expr_stmt|;
name|kif
operator|->
name|kf_un
operator|.
name|kf_sock
operator|.
name|kf_sock_rcv_sb_state
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
expr_stmt|;
name|kif
operator|->
name|kf_un
operator|.
name|kf_sock
operator|.
name|kf_sock_snd_sb_state
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_state
expr_stmt|;
block|}
block|}
break|break;
block|}
name|error
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_sockaddr
argument_list|(
name|so
argument_list|,
operator|&
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|sa
operator|->
name|sa_len
operator|<=
sizeof|sizeof
argument_list|(
name|kif
operator|->
name|kf_sa_local
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|sa
argument_list|,
operator|&
name|kif
operator|->
name|kf_sa_local
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sa
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_peeraddr
argument_list|(
name|so
argument_list|,
operator|&
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|sa
operator|->
name|sa_len
operator|<=
sizeof|sizeof
argument_list|(
name|kif
operator|->
name|kf_sa_peer
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|sa
argument_list|,
operator|&
name|kif
operator|->
name|kf_sa_peer
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sa
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|kif
operator|->
name|kf_path
argument_list|,
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|->
name|dom_name
argument_list|,
sizeof|sizeof
argument_list|(
name|kif
operator|->
name|kf_path
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|task
argument_list|)
name|soaio_jobs
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|soaio_jobs_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|task
name|soaio_kproc_task
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|soaio_starting
decl_stmt|,
name|soaio_idle
decl_stmt|,
name|soaio_queued
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|unrhdr
modifier|*
name|soaio_kproc_unr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|soaio_max_procs
init|=
name|MAX_AIO_PROCS
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|max_procs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|soaio_max_procs
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of kernel processes to use for async socket IO"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|soaio_num_procs
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|num_procs
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|soaio_num_procs
argument_list|,
literal|0
argument_list|,
literal|"Number of active kernel processes for async socket IO"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|soaio_target_procs
init|=
name|TARGET_AIO_PROCS
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|target_procs
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|soaio_target_procs
argument_list|,
literal|0
argument_list|,
literal|"Preferred number of ready kernel processes for async socket IO"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|soaio_lifetime
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc_aio
argument_list|,
name|OID_AUTO
argument_list|,
name|lifetime
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|soaio_lifetime
argument_list|,
literal|0
argument_list|,
literal|"Maximum lifetime for idle aiod"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|soaio_kproc_loop
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|myvm
decl_stmt|;
name|struct
name|task
modifier|*
name|task
decl_stmt|;
name|int
name|error
decl_stmt|,
name|id
decl_stmt|,
name|pending
decl_stmt|;
name|id
operator|=
operator|(
name|intptr_t
operator|)
name|arg
expr_stmt|;
comment|/* 	 * Grab an extra reference on the daemon's vmspace so that it 	 * doesn't get freed by jobs that switch to a different 	 * vmspace. 	 */
name|p
operator|=
name|curproc
expr_stmt|;
name|myvm
operator|=
name|vmspace_acquire_ref
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|soaio_jobs_lock
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|soaio_starting
operator|>
literal|0
argument_list|)
expr_stmt|;
name|soaio_starting
operator|--
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|soaio_jobs
argument_list|)
condition|)
block|{
name|task
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|soaio_jobs
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|soaio_jobs
argument_list|,
name|ta_link
argument_list|)
expr_stmt|;
name|soaio_queued
operator|--
expr_stmt|;
name|pending
operator|=
name|task
operator|->
name|ta_pending
expr_stmt|;
name|task
operator|->
name|ta_pending
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|soaio_jobs_lock
argument_list|)
expr_stmt|;
name|task
operator|->
name|ta_func
argument_list|(
name|task
operator|->
name|ta_context
argument_list|,
name|pending
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|soaio_jobs_lock
argument_list|)
expr_stmt|;
block|}
name|MPASS
argument_list|(
name|soaio_queued
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_vmspace
operator|!=
name|myvm
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|soaio_jobs_lock
argument_list|)
expr_stmt|;
name|vmspace_switch_aio
argument_list|(
name|myvm
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|soaio_jobs_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|soaio_idle
operator|++
expr_stmt|;
name|error
operator|=
name|mtx_sleep
argument_list|(
operator|&
name|soaio_idle
argument_list|,
operator|&
name|soaio_jobs_lock
argument_list|,
literal|0
argument_list|,
literal|"-"
argument_list|,
name|soaio_lifetime
argument_list|)
expr_stmt|;
name|soaio_idle
operator|--
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
operator|&&
name|STAILQ_EMPTY
argument_list|(
operator|&
name|soaio_jobs
argument_list|)
operator|&&
name|soaio_num_procs
operator|>
name|soaio_target_procs
condition|)
break|break;
block|}
name|soaio_num_procs
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|soaio_jobs_lock
argument_list|)
expr_stmt|;
name|free_unr
argument_list|(
name|soaio_kproc_unr
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|kproc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|soaio_kproc_create
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|,
name|id
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|soaio_jobs_lock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|soaio_num_procs
operator|<
name|soaio_target_procs
condition|)
block|{
comment|/* Must create */
block|}
elseif|else
if|if
condition|(
name|soaio_num_procs
operator|>=
name|soaio_max_procs
condition|)
block|{
comment|/* 			 * Hit the limit on kernel processes, don't 			 * create another one. 			 */
break|break;
block|}
elseif|else
if|if
condition|(
name|soaio_queued
operator|<=
name|soaio_idle
operator|+
name|soaio_starting
condition|)
block|{
comment|/* 			 * No more AIO jobs waiting for a process to be 			 * created, so stop. 			 */
break|break;
block|}
name|soaio_starting
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|soaio_jobs_lock
argument_list|)
expr_stmt|;
name|id
operator|=
name|alloc_unr
argument_list|(
name|soaio_kproc_unr
argument_list|)
expr_stmt|;
name|error
operator|=
name|kproc_create
argument_list|(
name|soaio_kproc_loop
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|id
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"soaiod%d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free_unr
argument_list|(
name|soaio_kproc_unr
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|soaio_jobs_lock
argument_list|)
expr_stmt|;
name|soaio_starting
operator|--
expr_stmt|;
break|break;
block|}
name|mtx_lock
argument_list|(
operator|&
name|soaio_jobs_lock
argument_list|)
expr_stmt|;
name|soaio_num_procs
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|soaio_jobs_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|soaio_enqueue
parameter_list|(
name|struct
name|task
modifier|*
name|task
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|soaio_jobs_lock
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|task
operator|->
name|ta_pending
operator|==
literal|0
argument_list|)
expr_stmt|;
name|task
operator|->
name|ta_pending
operator|++
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|soaio_jobs
argument_list|,
name|task
argument_list|,
name|ta_link
argument_list|)
expr_stmt|;
name|soaio_queued
operator|++
expr_stmt|;
if|if
condition|(
name|soaio_queued
operator|<=
name|soaio_idle
condition|)
name|wakeup_one
argument_list|(
operator|&
name|soaio_idle
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|soaio_num_procs
operator|<
name|soaio_max_procs
condition|)
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|soaio_kproc_task
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|soaio_jobs_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|soaio_init
parameter_list|(
name|void
parameter_list|)
block|{
name|soaio_lifetime
operator|=
name|AIOD_LIFETIME_DEFAULT
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|soaio_jobs
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|soaio_jobs_lock
argument_list|,
literal|"soaio jobs"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|soaio_kproc_unr
operator|=
name|new_unrhdr
argument_list|(
literal|1
argument_list|,
name|INT_MAX
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|soaio_kproc_task
argument_list|,
literal|0
argument_list|,
name|soaio_kproc_create
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|soaio_target_procs
operator|>
literal|0
condition|)
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|soaio_kproc_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|soaio
argument_list|,
name|SI_SUB_VFS
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|soaio_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|__inline
name|int
name|soaio_ready
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockbuf
modifier|*
name|sb
parameter_list|)
block|{
return|return
operator|(
name|sb
operator|==
operator|&
name|so
operator|->
name|so_rcv
condition|?
name|soreadable
argument_list|(
name|so
argument_list|)
else|:
name|sowriteable
argument_list|(
name|so
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|soaio_process_job
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|struct
name|ucred
modifier|*
name|td_savedcred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
name|uio
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|size_t
name|cnt
decl_stmt|,
name|done
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|aio_switch_vmspace
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|fp
operator|=
name|job
operator|->
name|fd_file
expr_stmt|;
name|retry
label|:
name|td_savedcred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
name|td
operator|->
name|td_ucred
operator|=
name|job
operator|->
name|cred
expr_stmt|;
name|done
operator|=
name|job
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|status
expr_stmt|;
name|cnt
operator|=
name|job
operator|->
name|uaiocb
operator|.
name|aio_nbytes
operator|-
name|done
expr_stmt|;
name|iov
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|job
operator|->
name|uaiocb
operator|.
name|aio_buf
operator|+
name|done
operator|)
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|cnt
expr_stmt|;
name|uio
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|uio
operator|.
name|uio_resid
operator|=
name|cnt
expr_stmt|;
name|uio
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
expr_stmt|;
name|uio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
name|flags
operator|=
name|MSG_NBIO
expr_stmt|;
comment|/* TODO: Charge ru_msg* to job. */
if|if
condition|(
name|sb
operator|==
operator|&
name|so
operator|->
name|so_rcv
condition|)
block|{
name|uio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_socket_check_receive
argument_list|(
name|fp
operator|->
name|f_cred
argument_list|,
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
endif|#
directive|endif
name|error
operator|=
name|soreceive
argument_list|(
name|so
argument_list|,
name|NULL
argument_list|,
operator|&
name|uio
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uio
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_socket_check_send
argument_list|(
name|fp
operator|->
name|f_cred
argument_list|,
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
endif|#
directive|endif
name|error
operator|=
name|sosend
argument_list|(
name|so
argument_list|,
name|NULL
argument_list|,
operator|&
name|uio
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EPIPE
operator|&&
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_NOSIGPIPE
operator|)
operator|==
literal|0
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|job
operator|->
name|userproc
argument_list|)
expr_stmt|;
name|kern_psignal
argument_list|(
name|job
operator|->
name|userproc
argument_list|,
name|SIGPIPE
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|job
operator|->
name|userproc
argument_list|)
expr_stmt|;
block|}
block|}
name|done
operator|+=
name|cnt
operator|-
name|uio
operator|.
name|uio_resid
expr_stmt|;
name|job
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|status
operator|=
name|done
expr_stmt|;
name|td
operator|->
name|td_ucred
operator|=
name|td_savedcred
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
block|{
comment|/* 		 * The request was either partially completed or not 		 * completed at all due to racing with a read() or 		 * write() on the socket.  If the socket is 		 * non-blocking, return with any partial completion. 		 * If the socket is blocking or if no progress has 		 * been made, requeue this request at the head of the 		 * queue to try again when the socket is ready. 		 */
name|MPASS
argument_list|(
name|done
operator|!=
name|job
operator|->
name|uaiocb
operator|.
name|aio_nbytes
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
operator|==
literal|0
operator|||
operator|!
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|)
condition|)
block|{
name|empty_results
operator|++
expr_stmt|;
if|if
condition|(
name|soaio_ready
argument_list|(
name|so
argument_list|,
name|sb
argument_list|)
condition|)
block|{
name|empty_retries
operator|++
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
operator|!
name|aio_set_cancel_function
argument_list|(
name|job
argument_list|,
name|soo_aio_cancel
argument_list|)
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
operator|!=
literal|0
condition|)
name|aio_complete
argument_list|(
name|job
argument_list|,
name|done
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|aio_cancel
argument_list|(
name|job
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|sb
operator|->
name|sb_aiojobq
argument_list|,
name|job
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|done
operator|!=
literal|0
operator|&&
operator|(
name|error
operator|==
name|ERESTART
operator|||
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|EWOULDBLOCK
operator|)
condition|)
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|aio_complete
argument_list|(
name|job
argument_list|,
operator|-
literal|1
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
name|aio_complete
argument_list|(
name|job
argument_list|,
name|done
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|soaio_process_sb
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockbuf
modifier|*
name|sb
parameter_list|)
block|{
name|struct
name|kaiocb
modifier|*
name|job
decl_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sb
operator|->
name|sb_aiojobq
argument_list|)
operator|&&
name|soaio_ready
argument_list|(
name|so
argument_list|,
name|sb
argument_list|)
condition|)
block|{
name|job
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sb
operator|->
name|sb_aiojobq
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sb
operator|->
name|sb_aiojobq
argument_list|,
name|job
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aio_clear_cancel_function
argument_list|(
name|job
argument_list|)
condition|)
continue|continue;
name|soaio_process_job
argument_list|(
name|so
argument_list|,
name|sb
argument_list|,
name|job
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there are still pending requests, the socket must not be 	 * ready so set SB_AIO to request a wakeup when the socket 	 * becomes ready. 	 */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sb
operator|->
name|sb_aiojobq
argument_list|)
condition|)
name|sb
operator|->
name|sb_flags
operator||=
name|SB_AIO
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_AIO_RUNNING
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|ACCEPT_LOCK
argument_list|()
expr_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sorele
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|soaio_rcv
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|context
expr_stmt|;
name|soaio_process_sb
argument_list|(
name|so
argument_list|,
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|soaio_snd
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|context
expr_stmt|;
name|soaio_process_sb
argument_list|(
name|so
argument_list|,
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sowakeup_aio
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockbuf
modifier|*
name|sb
parameter_list|)
block|{
name|SOCKBUF_LOCK_ASSERT
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_AIO
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_AIO_RUNNING
condition|)
return|return;
name|sb
operator|->
name|sb_flags
operator||=
name|SB_AIO_RUNNING
expr_stmt|;
if|if
condition|(
name|sb
operator|==
operator|&
name|so
operator|->
name|so_snd
condition|)
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|soref
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
operator|&
name|so
operator|->
name|so_snd
condition|)
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|soaio_enqueue
argument_list|(
operator|&
name|sb
operator|->
name|sb_aiotask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|soo_aio_cancel
parameter_list|(
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
name|long
name|done
decl_stmt|;
name|int
name|opcode
decl_stmt|;
name|so
operator|=
name|job
operator|->
name|fd_file
operator|->
name|f_data
expr_stmt|;
name|opcode
operator|=
name|job
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|LIO_READ
condition|)
name|sb
operator|=
operator|&
name|so
operator|->
name|so_rcv
expr_stmt|;
else|else
block|{
name|MPASS
argument_list|(
name|opcode
operator|==
name|LIO_WRITE
argument_list|)
expr_stmt|;
name|sb
operator|=
operator|&
name|so
operator|->
name|so_snd
expr_stmt|;
block|}
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aio_cancel_cleared
argument_list|(
name|job
argument_list|)
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sb
operator|->
name|sb_aiojobq
argument_list|,
name|job
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sb
operator|->
name|sb_aiojobq
argument_list|)
condition|)
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_AIO
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|done
operator|=
name|job
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|status
expr_stmt|;
if|if
condition|(
name|done
operator|!=
literal|0
condition|)
name|aio_complete
argument_list|(
name|job
argument_list|,
name|done
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|aio_cancel
argument_list|(
name|job
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|soo_aio_queue
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|so
operator|=
name|fp
operator|->
name|f_data
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_aio_queue
call|)
argument_list|(
name|so
argument_list|,
name|job
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|job
operator|->
name|uaiocb
operator|.
name|aio_lio_opcode
condition|)
block|{
case|case
name|LIO_READ
case|:
name|sb
operator|=
operator|&
name|so
operator|->
name|so_rcv
expr_stmt|;
break|break;
case|case
name|LIO_WRITE
case|:
name|sb
operator|=
operator|&
name|so
operator|->
name|so_snd
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aio_set_cancel_function
argument_list|(
name|job
argument_list|,
name|soo_aio_cancel
argument_list|)
condition|)
name|panic
argument_list|(
literal|"new job was cancelled"
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sb
operator|->
name|sb_aiojobq
argument_list|,
name|job
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|job
operator|->
name|uaiocb
operator|.
name|_aiocb_private
operator|.
name|status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sb
operator|->
name|sb_flags
operator|&
name|SB_AIO_RUNNING
operator|)
condition|)
block|{
if|if
condition|(
name|soaio_ready
argument_list|(
name|so
argument_list|,
name|sb
argument_list|)
condition|)
name|sowakeup_aio
argument_list|(
name|so
argument_list|,
name|sb
argument_list|)
expr_stmt|;
else|else
name|sb
operator|->
name|sb_flags
operator||=
name|SB_AIO
expr_stmt|;
block|}
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

