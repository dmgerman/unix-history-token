begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1988 University of Utah.  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department. Originally from University of Wisconsin.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: Utah $Hdr: uipc_shm.c 1.9 89/08/14$  *	from: @(#)sysv_shm.c	7.15 (Berkeley) 5/13/91  *	$Id: sysv_shm.c,v 1.9 1994/01/21 09:56:31 davidg Exp $  */
end_comment

begin_comment
comment|/*  * System V shared memory routines.  * TEMPORARY, until mmap is in place;  * needed now for HP-UX compatibility and X server (yech!).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYSVSHM
end_ifdef

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"shm.h"
end_include

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"mman.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm_kern.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm_inherit.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm_pager.h"
end_include

begin_include
include|#
directive|include
file|"vm/vm_user.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HPUXCOMPAT
end_ifdef

begin_include
include|#
directive|include
file|"hp300/hpux/hpux.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* From shm.h */
end_comment

begin_decl_stmt
name|struct
name|shmid_ds
modifier|*
name|shmsegs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|shminfo
name|shminfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|shmat
argument_list|()
decl_stmt|,
name|shmctl
argument_list|()
decl_stmt|,
name|shmdt
argument_list|()
decl_stmt|,
name|shmget
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|shmcalls
index|[]
function_decl|)
parameter_list|()
init|=
block|{
name|shmat
operator|,
function_decl|shmctl
operator|,
function_decl|shmdt
operator|,
function_decl|shmget
end_function_decl

begin_comment
unit|};
comment|/* XXX */
end_comment

begin_decl_stmt
name|int
name|shmtot
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Per process internal structure for managing segments.  * Each process using shm will have an array of ``shmseg'' of these.  */
end_comment

begin_struct
struct|struct
name|shmdesc
block|{
name|vm_offset_t
name|shmd_uva
decl_stmt|;
name|int
name|shmd_id
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Per segment internal structure (shm_handle).  */
end_comment

begin_struct
struct|struct
name|shmhandle
block|{
name|vm_offset_t
name|shmh_kva
decl_stmt|;
name|caddr_t
name|shmh_id
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|extern
name|int
name|ipcaccess
parameter_list|(
name|struct
name|ipc_perm
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ucred
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shmufree
parameter_list|(
name|struct
name|proc
modifier|*
parameter_list|,
name|struct
name|shmdesc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shmfree
parameter_list|(
name|struct
name|shmid_ds
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|shmvalid
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|vm_map_t
name|shm_map
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* address space for shared memory segments */
end_comment

begin_function
name|void
name|shminit
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|vm_offset_t
name|whocares1
decl_stmt|,
name|whocares2
decl_stmt|;
name|shm_map
operator|=
name|kmem_suballoc
argument_list|(
name|kernel_map
argument_list|,
operator|&
name|whocares1
argument_list|,
operator|&
name|whocares2
argument_list|,
name|shminfo
operator|.
name|shmall
operator|*
name|NBPG
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|shminfo
operator|.
name|shmmni
operator|>
name|SHMMMNI
condition|)
name|shminfo
operator|.
name|shmmni
operator|=
name|SHMMMNI
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmmni
condition|;
name|i
operator|++
control|)
block|{
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|seq
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|TEXT_SET
argument_list|(
name|pseudo_set
argument_list|,
name|shminit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Entry point for all SHM calls  */
end_comment

begin_struct
struct|struct
name|shmsys_args
block|{
name|u_int
name|which
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|shmsys
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|,
name|retval
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|shmsys_args
modifier|*
name|uap
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
if|if
condition|(
name|uap
operator|->
name|which
operator|>=
sizeof|sizeof
argument_list|(
name|shmcalls
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|shmcalls
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
call|(
modifier|*
name|shmcalls
index|[
name|uap
operator|->
name|which
index|]
call|)
argument_list|(
name|p
argument_list|,
operator|&
name|uap
index|[
literal|1
index|]
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get a shared memory segment  */
end_comment

begin_struct
struct|struct
name|shmget_args
block|{
name|key_t
name|key
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|shmflg
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|shmget
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|,
name|retval
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|shmget_args
modifier|*
name|uap
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
specifier|register
name|struct
name|shmid_ds
modifier|*
name|shp
decl_stmt|;
specifier|register
name|struct
name|ucred
modifier|*
name|cred
init|=
name|p
operator|->
name|p_ucred
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|,
name|size
decl_stmt|,
name|rval
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|shmhandle
modifier|*
name|shmh
decl_stmt|;
comment|/* look up the specified shm_id */
if|if
condition|(
name|uap
operator|->
name|key
operator|!=
name|IPC_PRIVATE
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmmni
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|mode
operator|&
name|SHM_ALLOC
operator|)
operator|&&
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|key
operator|==
name|uap
operator|->
name|key
condition|)
block|{
name|rval
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
else|else
name|i
operator|=
name|shminfo
operator|.
name|shmmni
expr_stmt|;
comment|/* create a new shared segment if necessary */
if|if
condition|(
name|i
operator|==
name|shminfo
operator|.
name|shmmni
condition|)
block|{
if|if
condition|(
operator|(
name|uap
operator|->
name|shmflg
operator|&
name|IPC_CREAT
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|size
operator|<
name|shminfo
operator|.
name|shmmin
operator|||
name|uap
operator|->
name|size
operator|>
name|shminfo
operator|.
name|shmmax
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmmni
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|mode
operator|&
name|SHM_ALLOC
operator|)
operator|==
literal|0
condition|)
block|{
name|rval
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|shminfo
operator|.
name|shmmni
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|size
operator|=
name|clrnd
argument_list|(
name|btoc
argument_list|(
name|uap
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmtot
operator|+
name|size
operator|>
name|shminfo
operator|.
name|shmall
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|shp
operator|=
operator|&
name|shmsegs
index|[
name|rval
index|]
expr_stmt|;
comment|/* 		 * We need to do a couple of things to ensure consistency 		 * in case we sleep in malloc().  We mark segment as 		 * allocated so that other shmgets() will not allocate it. 		 * We mark it as "destroyed" to insure that shmvalid() is 		 * false making most operations fail (XXX).  We set the key, 		 * so that other shmget()s will fail. 		 */
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|=
name|SHM_ALLOC
operator||
name|SHM_DEST
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|key
operator|=
name|uap
operator|->
name|key
expr_stmt|;
name|shmh
operator|=
operator|(
expr|struct
name|shmhandle
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|shmhandle
argument_list|)
argument_list|,
name|M_SHM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|shmh
operator|->
name|shmh_kva
operator|=
literal|0
expr_stmt|;
name|shmh
operator|->
name|shmh_id
operator|=
call|(
name|caddr_t
call|)
argument_list|(
literal|0xc0000000UL
operator||
name|rval
argument_list|)
expr_stmt|;
comment|/* XXX */
name|error
operator|=
name|vm_mmap
argument_list|(
name|shm_map
argument_list|,
operator|&
name|shmh
operator|->
name|shmh_kva
argument_list|,
name|ctob
argument_list|(
name|size
argument_list|)
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_DEFAULT
argument_list|,
name|MAP_ANON
argument_list|,
name|shmh
operator|->
name|shmh_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|shmh
argument_list|,
name|M_SHM
argument_list|)
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|shp
operator|->
name|shm_handle
operator|=
operator|(
name|void
operator|*
operator|)
name|shmh
expr_stmt|;
name|shmtot
operator|+=
name|size
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|cuid
operator|=
name|shp
operator|->
name|shm_perm
operator|.
name|uid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|cgid
operator|=
name|shp
operator|->
name|shm_perm
operator|.
name|gid
operator|=
name|cred
operator|->
name|cr_gid
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|=
name|SHM_ALLOC
operator||
operator|(
name|uap
operator|->
name|shmflg
operator|&
literal|0777
operator|)
expr_stmt|;
name|shp
operator|->
name|shm_segsz
operator|=
name|uap
operator|->
name|size
expr_stmt|;
name|shp
operator|->
name|shm_cpid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|shp
operator|->
name|shm_lpid
operator|=
name|shp
operator|->
name|shm_nattch
operator|=
literal|0
expr_stmt|;
name|shp
operator|->
name|shm_atime
operator|=
name|shp
operator|->
name|shm_dtime
operator|=
literal|0
expr_stmt|;
name|shp
operator|->
name|shm_ctime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
block|}
else|else
block|{
name|shp
operator|=
operator|&
name|shmsegs
index|[
name|rval
index|]
expr_stmt|;
comment|/* XXX: probably not the right thing to do */
if|if
condition|(
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|&
name|SHM_DEST
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|ipcaccess
argument_list|(
operator|&
name|shp
operator|->
name|shm_perm
argument_list|,
name|uap
operator|->
name|shmflg
operator|&
literal|0777
argument_list|,
name|cred
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|size
operator|&&
name|uap
operator|->
name|size
operator|>
name|shp
operator|->
name|shm_segsz
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|uap
operator|->
name|shmflg
operator|&
name|IPC_CREAT
operator|)
operator|&&
operator|(
name|uap
operator|->
name|shmflg
operator|&
name|IPC_EXCL
operator|)
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
operator|*
name|retval
operator|=
name|shp
operator|->
name|shm_perm
operator|.
name|seq
operator|*
name|SHMMMNI
operator|+
name|rval
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Shared memory control  */
end_comment

begin_struct
struct|struct
name|shmctl_args
block|{
name|int
name|shmid
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|buf
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|shmctl
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|,
name|retval
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|shmctl_args
modifier|*
name|uap
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
specifier|register
name|struct
name|shmid_ds
modifier|*
name|shp
decl_stmt|;
specifier|register
name|struct
name|ucred
modifier|*
name|cred
init|=
name|p
operator|->
name|p_ucred
decl_stmt|;
name|struct
name|shmid_ds
name|sbuf
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|shmvalid
argument_list|(
name|uap
operator|->
name|shmid
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|shp
operator|=
operator|&
name|shmsegs
index|[
name|uap
operator|->
name|shmid
operator|%
name|SHMMMNI
index|]
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
name|IPC_STAT
case|:
if|if
condition|(
name|error
operator|=
name|ipcaccess
argument_list|(
operator|&
name|shp
operator|->
name|shm_perm
argument_list|,
name|IPC_R
argument_list|,
name|cred
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|shp
argument_list|,
name|uap
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|shp
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|IPC_SET
case|:
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|&&
name|cred
operator|->
name|cr_uid
operator|!=
name|shp
operator|->
name|shm_perm
operator|.
name|uid
operator|&&
name|cred
operator|->
name|cr_uid
operator|!=
name|shp
operator|->
name|shm_perm
operator|.
name|cuid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|buf
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sbuf
argument_list|,
sizeof|sizeof
name|sbuf
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|shp
operator|->
name|shm_perm
operator|.
name|uid
operator|=
name|sbuf
operator|.
name|shm_perm
operator|.
name|uid
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|gid
operator|=
name|sbuf
operator|.
name|shm_perm
operator|.
name|gid
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|=
operator|(
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|&
operator|~
literal|0777
operator|)
operator||
operator|(
name|sbuf
operator|.
name|shm_perm
operator|.
name|mode
operator|&
literal|0777
operator|)
expr_stmt|;
name|shp
operator|->
name|shm_ctime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
break|break;
case|case
name|IPC_RMID
case|:
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|&&
name|cred
operator|->
name|cr_uid
operator|!=
name|shp
operator|->
name|shm_perm
operator|.
name|uid
operator|&&
name|cred
operator|->
name|cr_uid
operator|!=
name|shp
operator|->
name|shm_perm
operator|.
name|cuid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* set ctime? */
name|shp
operator|->
name|shm_perm
operator|.
name|key
operator|=
name|IPC_PRIVATE
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator||=
name|SHM_DEST
expr_stmt|;
if|if
condition|(
name|shp
operator|->
name|shm_nattch
operator|<=
literal|0
condition|)
name|shmfree
argument_list|(
name|shp
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HPUXCOMPAT
case|case
name|SHM_LOCK
case|:
case|case
name|SHM_UNLOCK
case|:
comment|/* don't really do anything, but make them think we did */
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SHPUX
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|&&
name|cred
operator|->
name|cr_uid
operator|!=
name|shp
operator|->
name|shm_perm
operator|.
name|uid
operator|&&
name|cred
operator|->
name|cr_uid
operator|!=
name|shp
operator|->
name|shm_perm
operator|.
name|cuid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
break|break;
endif|#
directive|endif
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach to shared memory segment.  */
end_comment

begin_struct
struct|struct
name|shmat_args
block|{
name|int
name|shmid
decl_stmt|;
name|caddr_t
name|shmaddr
decl_stmt|;
name|int
name|shmflg
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|shmat
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|,
name|retval
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|shmat_args
modifier|*
name|uap
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
specifier|register
name|struct
name|shmid_ds
modifier|*
name|shp
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
name|caddr_t
name|uva
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|struct
name|shmdesc
modifier|*
name|shmd
decl_stmt|;
comment|/* 	 * Allocate descriptors now (before validity check) 	 * in case malloc() blocks. 	 */
name|shmd
operator|=
operator|(
expr|struct
name|shmdesc
operator|*
operator|)
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
expr_stmt|;
name|size
operator|=
name|shminfo
operator|.
name|shmseg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|shmdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmd
operator|==
name|NULL
condition|)
block|{
name|shmd
operator|=
operator|(
expr|struct
name|shmdesc
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|,
name|M_SHM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|shmd
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
operator|=
operator|(
name|caddr_t
operator|)
name|shmd
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|=
name|shmvalid
argument_list|(
name|uap
operator|->
name|shmid
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|shp
operator|=
operator|&
name|shmsegs
index|[
name|uap
operator|->
name|shmid
operator|%
name|SHMMMNI
index|]
expr_stmt|;
if|if
condition|(
name|shp
operator|->
name|shm_handle
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"shmat NULL handle"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|ipcaccess
argument_list|(
operator|&
name|shp
operator|->
name|shm_perm
argument_list|,
operator|(
name|uap
operator|->
name|shmflg
operator|&
name|SHM_RDONLY
operator|)
condition|?
name|IPC_R
else|:
name|IPC_R
operator||
name|IPC_W
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|uva
operator|=
name|uap
operator|->
name|shmaddr
expr_stmt|;
if|if
condition|(
name|uva
operator|&&
operator|(
operator|(
name|int
operator|)
name|uva
operator|&
operator|(
name|SHMLBA
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|uap
operator|->
name|shmflg
operator|&
name|SHM_RND
condition|)
name|uva
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|int
operator|)
name|uva
operator|&
operator|~
operator|(
name|SHMLBA
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Make sure user doesn't use more than their fair share 	 */
for|for
control|(
name|size
operator|=
literal|0
init|;
name|size
operator|<
name|shminfo
operator|.
name|shmseg
condition|;
name|size
operator|++
control|)
block|{
if|if
condition|(
name|shmd
operator|->
name|shmd_uva
operator|==
literal|0
condition|)
break|break;
name|shmd
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|>=
name|shminfo
operator|.
name|shmseg
condition|)
return|return
operator|(
name|EMFILE
operator|)
return|;
name|size
operator|=
name|ctob
argument_list|(
name|clrnd
argument_list|(
name|btoc
argument_list|(
name|shp
operator|->
name|shm_segsz
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|prot
operator|=
name|VM_PROT_READ
expr_stmt|;
if|if
condition|(
operator|(
name|uap
operator|->
name|shmflg
operator|&
name|SHM_RDONLY
operator|)
operator|==
literal|0
condition|)
name|prot
operator||=
name|VM_PROT_WRITE
expr_stmt|;
name|flags
operator|=
name|MAP_ANON
operator||
name|MAP_SHARED
expr_stmt|;
if|if
condition|(
name|uva
condition|)
name|flags
operator||=
name|MAP_FIXED
expr_stmt|;
else|else
name|uva
operator|=
operator|(
name|caddr_t
operator|)
literal|0x1000000UL
expr_stmt|;
comment|/* XXX */
name|error
operator|=
name|vm_mmap
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|uva
argument_list|,
operator|(
name|vm_size_t
operator|)
name|size
argument_list|,
name|prot
argument_list|,
name|VM_PROT_DEFAULT
argument_list|,
name|flags
argument_list|,
operator|(
operator|(
expr|struct
name|shmhandle
operator|*
operator|)
name|shp
operator|->
name|shm_handle
operator|)
operator|->
name|shmh_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|shmd
operator|->
name|shmd_uva
operator|=
operator|(
name|vm_offset_t
operator|)
name|uva
expr_stmt|;
name|shmd
operator|->
name|shmd_id
operator|=
name|uap
operator|->
name|shmid
expr_stmt|;
comment|/* 	 * Fill in the remaining fields 	 */
name|shp
operator|->
name|shm_lpid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|shp
operator|->
name|shm_atime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|shp
operator|->
name|shm_nattch
operator|++
expr_stmt|;
operator|*
name|retval
operator|=
operator|(
name|int
operator|)
name|uva
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detach from shared memory segment.  */
end_comment

begin_struct
struct|struct
name|shmdt_args
block|{
name|caddr_t
name|shmaddr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|shmdt
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|,
name|retval
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|shmdt_args
modifier|*
name|uap
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
specifier|register
name|struct
name|shmdesc
modifier|*
name|shmd
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|shmd
operator|=
operator|(
expr|struct
name|shmdesc
operator|*
operator|)
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmseg
condition|;
name|i
operator|++
operator|,
name|shmd
operator|++
control|)
if|if
condition|(
name|shmd
operator|->
name|shmd_uva
operator|&&
name|shmd
operator|->
name|shmd_uva
operator|==
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|shmaddr
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|shminfo
operator|.
name|shmseg
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|shmufree
argument_list|(
name|p
argument_list|,
name|shmd
argument_list|)
expr_stmt|;
name|shmsegs
index|[
name|shmd
operator|->
name|shmd_id
operator|%
name|SHMMMNI
index|]
operator|.
name|shm_lpid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|shmfork
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|,
name|isvfork
parameter_list|)
name|struct
name|proc
modifier|*
name|p1
decl_stmt|,
decl|*
name|p2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|isvfork
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|shmdesc
modifier|*
name|shmd
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
comment|/* 	 * Copy parents descriptive information 	 */
name|size
operator|=
name|shminfo
operator|.
name|shmseg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|shmdesc
argument_list|)
expr_stmt|;
name|shmd
operator|=
operator|(
expr|struct
name|shmdesc
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|,
name|M_SHM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|p1
operator|->
name|p_vmspace
operator|->
name|vm_shm
argument_list|,
operator|(
name|caddr_t
operator|)
name|shmd
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p2
operator|->
name|p_vmspace
operator|->
name|vm_shm
operator|=
operator|(
name|caddr_t
operator|)
name|shmd
expr_stmt|;
comment|/* 	 * Increment reference counts 	 */
for|for
control|(
name|size
operator|=
literal|0
init|;
name|size
operator|<
name|shminfo
operator|.
name|shmseg
condition|;
name|size
operator|++
operator|,
name|shmd
operator|++
control|)
if|if
condition|(
name|shmd
operator|->
name|shmd_uva
condition|)
name|shmsegs
index|[
name|shmd
operator|->
name|shmd_id
operator|%
name|SHMMMNI
index|]
operator|.
name|shm_nattch
operator|++
expr_stmt|;
block|}
end_block

begin_function
name|void
name|shmexit
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|shmdesc
modifier|*
name|shmd
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|shmd
operator|=
operator|(
expr|struct
name|shmdesc
operator|*
operator|)
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmseg
condition|;
name|i
operator|++
operator|,
name|shmd
operator|++
control|)
if|if
condition|(
name|shmd
operator|->
name|shmd_uva
condition|)
name|shmufree
argument_list|(
name|p
argument_list|,
name|shmd
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
argument_list|,
name|M_SHM
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|shmvalid
parameter_list|(
name|id
parameter_list|)
specifier|register
name|int
name|id
decl_stmt|;
block|{
specifier|register
name|struct
name|shmid_ds
modifier|*
name|shp
decl_stmt|;
if|if
condition|(
name|id
operator|<
literal|0
operator|||
operator|(
name|id
operator|%
name|SHMMMNI
operator|)
operator|>=
name|shminfo
operator|.
name|shmmni
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|shp
operator|=
operator|&
name|shmsegs
index|[
name|id
operator|%
name|SHMMMNI
index|]
expr_stmt|;
if|if
condition|(
name|shp
operator|->
name|shm_perm
operator|.
name|seq
operator|==
operator|(
name|id
operator|/
name|SHMMMNI
operator|)
operator|&&
operator|(
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|&
operator|(
name|SHM_ALLOC
operator||
name|SHM_DEST
operator|)
operator|)
operator|==
name|SHM_ALLOC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free user resources associated with a shared memory segment  */
end_comment

begin_function
specifier|static
name|void
name|shmufree
parameter_list|(
name|p
parameter_list|,
name|shmd
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|shmdesc
modifier|*
name|shmd
decl_stmt|;
block|{
specifier|register
name|struct
name|shmid_ds
modifier|*
name|shp
decl_stmt|;
name|shp
operator|=
operator|&
name|shmsegs
index|[
name|shmd
operator|->
name|shmd_id
operator|%
name|SHMMMNI
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|vm_deallocate
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|shmd
operator|->
name|shmd_uva
argument_list|,
name|ctob
argument_list|(
name|clrnd
argument_list|(
name|btoc
argument_list|(
name|shp
operator|->
name|shm_segsz
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|shmd
operator|->
name|shmd_id
operator|=
literal|0
expr_stmt|;
name|shmd
operator|->
name|shmd_uva
operator|=
literal|0
expr_stmt|;
name|shp
operator|->
name|shm_dtime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
operator|--
name|shp
operator|->
name|shm_nattch
operator|<=
literal|0
operator|&&
operator|(
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|&
name|SHM_DEST
operator|)
condition|)
name|shmfree
argument_list|(
name|shp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Deallocate resources associated with a shared memory segment  */
end_comment

begin_function
specifier|static
name|void
name|shmfree
parameter_list|(
name|shp
parameter_list|)
specifier|register
name|struct
name|shmid_ds
modifier|*
name|shp
decl_stmt|;
block|{
if|if
condition|(
name|shp
operator|->
name|shm_handle
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"shmfree"
argument_list|)
expr_stmt|;
comment|/* 	 * Lose our lingering object reference by deallocating space 	 * in kernel.  Pager will also be deallocated as a side-effect. 	 */
name|vm_deallocate
argument_list|(
name|shm_map
argument_list|,
operator|(
operator|(
expr|struct
name|shmhandle
operator|*
operator|)
name|shp
operator|->
name|shm_handle
operator|)
operator|->
name|shmh_kva
argument_list|,
name|ctob
argument_list|(
name|clrnd
argument_list|(
name|btoc
argument_list|(
name|shp
operator|->
name|shm_segsz
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|shp
operator|->
name|shm_handle
argument_list|,
name|M_SHM
argument_list|)
expr_stmt|;
name|shp
operator|->
name|shm_handle
operator|=
name|NULL
expr_stmt|;
name|shmtot
operator|-=
name|clrnd
argument_list|(
name|btoc
argument_list|(
name|shp
operator|->
name|shm_segsz
argument_list|)
argument_list|)
expr_stmt|;
name|shp
operator|->
name|shm_perm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Increment the sequence number to ensure that outstanding 	 * shmids for this segment will be invalid in the event that 	 * the segment is reallocated.  Note that shmids must be 	 * positive as decreed by SVID. 	 */
name|shp
operator|->
name|shm_perm
operator|.
name|seq
operator|++
expr_stmt|;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|shp
operator|->
name|shm_perm
operator|.
name|seq
operator|*
name|SHMMMNI
argument_list|)
operator|<
literal|0
condition|)
name|shp
operator|->
name|shm_perm
operator|.
name|seq
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYSVSHM */
end_comment

end_unit

