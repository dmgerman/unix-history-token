begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*	$NetBSD: sysv_shm.c,v 1.23 1994/07/04 23:25:12 glass Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1994 Adam Glass and Charles Hannum.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Adam Glass and Charles  *	Hannum.  * 4. The names of the authors may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/shm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_comment
comment|/*  * Provides the following externally accessible functions:  *  * shminit(void);		           initialization  * shmexit(struct proc *)                  cleanup  * shmfork(struct proc *, struct proc *, int) fork handling  * shmsys(arg1, arg2, arg3, arg4);         shm{at,ctl,dt,get}(arg2, arg3, arg4)  *  * Structures:  * shmsegs (an array of 'struct shmid_ds')  * per proc array of 'struct shmmap_state'  */
end_comment

begin_function_decl
name|int
name|oshmctl
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|shmat
argument_list|()
decl_stmt|,
name|shmctl
argument_list|()
decl_stmt|,
name|shmdt
argument_list|()
decl_stmt|,
name|shmget
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|shmcalls
index|[]
function_decl|)
parameter_list|()
init|=
block|{
name|shmat
operator|,
function_decl|oshmctl
operator|,
function_decl|shmdt
operator|,
function_decl|shmget
operator|,
function_decl|shmctl
end_function_decl

begin_define
unit|};
define|#
directive|define
name|SHMSEG_FREE
value|0x0200
end_define

begin_define
define|#
directive|define
name|SHMSEG_REMOVED
value|0x0400
end_define

begin_define
define|#
directive|define
name|SHMSEG_ALLOCATED
value|0x0800
end_define

begin_define
define|#
directive|define
name|SHMSEG_WANTED
value|0x1000
end_define

begin_decl_stmt
name|vm_map_t
name|sysvshm_map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|shm_last_free
decl_stmt|,
name|shm_nused
decl_stmt|,
name|shm_committed
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|shm_handle
block|{
name|vm_offset_t
name|kva
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|shmmap_state
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|int
name|shmid
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|shm_deallocate_segment
name|__P
argument_list|(
operator|(
expr|struct
name|shmid_ds
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|shm_find_segment_by_key
name|__P
argument_list|(
operator|(
name|key_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|shmid_ds
modifier|*
name|shm_find_segment_by_shmid
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|shm_delete_mapping
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|,
expr|struct
name|shmmap_state
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|shm_find_segment_by_key
parameter_list|(
name|key
parameter_list|)
name|key_t
name|key
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmmni
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|mode
operator|&
name|SHMSEG_ALLOCATED
operator|)
operator|&&
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|key
operator|==
name|key
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|shmid_ds
modifier|*
name|shm_find_segment_by_shmid
parameter_list|(
name|shmid
parameter_list|)
name|int
name|shmid
decl_stmt|;
block|{
name|int
name|segnum
decl_stmt|;
name|struct
name|shmid_ds
modifier|*
name|shmseg
decl_stmt|;
name|segnum
operator|=
name|IPCID_TO_IX
argument_list|(
name|shmid
argument_list|)
expr_stmt|;
if|if
condition|(
name|segnum
operator|<
literal|0
operator|||
name|segnum
operator|>=
name|shminfo
operator|.
name|shmmni
condition|)
return|return
name|NULL
return|;
name|shmseg
operator|=
operator|&
name|shmsegs
index|[
name|segnum
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|&
operator|(
name|SHMSEG_ALLOCATED
operator||
name|SHMSEG_REMOVED
operator|)
operator|)
operator|!=
name|SHMSEG_ALLOCATED
operator|||
name|shmseg
operator|->
name|shm_perm
operator|.
name|seq
operator|!=
name|IPCID_TO_SEQ
argument_list|(
name|shmid
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|shmseg
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|shm_deallocate_segment
parameter_list|(
name|shmseg
parameter_list|)
name|struct
name|shmid_ds
modifier|*
name|shmseg
decl_stmt|;
block|{
name|struct
name|shm_handle
modifier|*
name|shm_handle
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|shm_handle
operator|=
name|shmseg
operator|->
name|shm_internal
expr_stmt|;
name|size
operator|=
operator|(
name|shmseg
operator|->
name|shm_segsz
operator|+
name|CLOFSET
operator|)
operator|&
operator|~
name|CLOFSET
expr_stmt|;
operator|(
name|void
operator|)
name|vm_map_remove
argument_list|(
name|sysvshm_map
argument_list|,
name|shm_handle
operator|->
name|kva
argument_list|,
name|shm_handle
operator|->
name|kva
operator|+
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|shm_handle
argument_list|,
name|M_SHM
argument_list|)
expr_stmt|;
name|shmseg
operator|->
name|shm_internal
operator|=
name|NULL
expr_stmt|;
name|shm_committed
operator|-=
name|btoc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|shm_nused
operator|--
expr_stmt|;
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|=
name|SHMSEG_FREE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|shm_delete_mapping
parameter_list|(
name|p
parameter_list|,
name|shmmap_s
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|shmmap_state
modifier|*
name|shmmap_s
decl_stmt|;
block|{
name|struct
name|shmid_ds
modifier|*
name|shmseg
decl_stmt|;
name|int
name|segnum
decl_stmt|,
name|result
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|segnum
operator|=
name|IPCID_TO_IX
argument_list|(
name|shmmap_s
operator|->
name|shmid
argument_list|)
expr_stmt|;
name|shmseg
operator|=
operator|&
name|shmsegs
index|[
name|segnum
index|]
expr_stmt|;
name|size
operator|=
operator|(
name|shmseg
operator|->
name|shm_segsz
operator|+
name|CLOFSET
operator|)
operator|&
operator|~
name|CLOFSET
expr_stmt|;
name|result
operator|=
name|vm_map_remove
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|shmmap_s
operator|->
name|va
argument_list|,
name|shmmap_s
operator|->
name|va
operator|+
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|KERN_SUCCESS
condition|)
return|return
name|EINVAL
return|;
name|shmmap_s
operator|->
name|shmid
operator|=
operator|-
literal|1
expr_stmt|;
name|shmseg
operator|->
name|shm_dtime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
operator|(
operator|--
name|shmseg
operator|->
name|shm_nattch
operator|<=
literal|0
operator|)
operator|&&
operator|(
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|&
name|SHMSEG_REMOVED
operator|)
condition|)
block|{
name|shm_deallocate_segment
argument_list|(
name|shmseg
argument_list|)
expr_stmt|;
name|shm_last_free
operator|=
name|segnum
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_struct
struct|struct
name|shmdt_args
block|{
name|void
modifier|*
name|shmaddr
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|shmdt
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|,
name|retval
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|shmdt_args
modifier|*
name|uap
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
name|struct
name|shmmap_state
modifier|*
name|shmmap_s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|shmmap_s
operator|=
operator|(
expr|struct
name|shmmap_state
operator|*
operator|)
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
expr_stmt|;
if|if
condition|(
name|shmmap_s
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmseg
condition|;
name|i
operator|++
operator|,
name|shmmap_s
operator|++
control|)
if|if
condition|(
name|shmmap_s
operator|->
name|shmid
operator|!=
operator|-
literal|1
operator|&&
name|shmmap_s
operator|->
name|va
operator|==
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|shmaddr
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|shminfo
operator|.
name|shmseg
condition|)
return|return
name|EINVAL
return|;
return|return
name|shm_delete_mapping
argument_list|(
name|p
argument_list|,
name|shmmap_s
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|shmat_args
block|{
name|int
name|shmid
decl_stmt|;
name|void
modifier|*
name|shmaddr
decl_stmt|;
name|int
name|shmflg
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|shmat
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|,
name|retval
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|shmat_args
modifier|*
name|uap
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|p
operator|->
name|p_ucred
decl_stmt|;
name|struct
name|shmid_ds
modifier|*
name|shmseg
decl_stmt|;
name|struct
name|shmmap_state
modifier|*
name|shmmap_s
init|=
name|NULL
decl_stmt|;
name|vm_offset_t
name|attach_va
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|shmmap_s
operator|=
operator|(
expr|struct
name|shmmap_state
operator|*
operator|)
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
expr_stmt|;
if|if
condition|(
name|shmmap_s
operator|==
name|NULL
condition|)
block|{
name|size
operator|=
name|shminfo
operator|.
name|shmseg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|shmmap_state
argument_list|)
expr_stmt|;
name|shmmap_s
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_SHM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmseg
condition|;
name|i
operator|++
control|)
name|shmmap_s
index|[
name|i
index|]
operator|.
name|shmid
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
operator|=
operator|(
name|caddr_t
operator|)
name|shmmap_s
expr_stmt|;
block|}
name|shmseg
operator|=
name|shm_find_segment_by_shmid
argument_list|(
name|uap
operator|->
name|shmid
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmseg
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
name|error
operator|=
name|ipcperm
argument_list|(
name|cred
argument_list|,
operator|&
name|shmseg
operator|->
name|shm_perm
argument_list|,
operator|(
name|uap
operator|->
name|shmflg
operator|&
name|SHM_RDONLY
operator|)
condition|?
name|IPC_R
else|:
name|IPC_R
operator||
name|IPC_W
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmseg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|shmmap_s
operator|->
name|shmid
operator|==
operator|-
literal|1
condition|)
break|break;
name|shmmap_s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|shminfo
operator|.
name|shmseg
condition|)
return|return
name|EMFILE
return|;
name|size
operator|=
operator|(
name|shmseg
operator|->
name|shm_segsz
operator|+
name|CLOFSET
operator|)
operator|&
operator|~
name|CLOFSET
expr_stmt|;
name|prot
operator|=
name|VM_PROT_READ
expr_stmt|;
if|if
condition|(
operator|(
name|uap
operator|->
name|shmflg
operator|&
name|SHM_RDONLY
operator|)
operator|==
literal|0
condition|)
name|prot
operator||=
name|VM_PROT_WRITE
expr_stmt|;
name|flags
operator|=
name|MAP_ANON
operator||
name|MAP_SHARED
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|shmaddr
condition|)
block|{
name|flags
operator||=
name|MAP_FIXED
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|shmflg
operator|&
name|SHM_RND
condition|)
name|attach_va
operator|=
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|shmaddr
operator|&
operator|~
operator|(
name|SHMLBA
operator|-
literal|1
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|shmaddr
operator|&
operator|(
name|SHMLBA
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|attach_va
operator|=
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|shmaddr
expr_stmt|;
else|else
return|return
name|EINVAL
return|;
block|}
else|else
block|{
comment|/* This is just a hint to vm_mmap() about where to put it. */
name|attach_va
operator|=
name|round_page
argument_list|(
name|p
operator|->
name|p_vmspace
operator|->
name|vm_daddr
operator|+
name|MAXDSIZ
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|vm_mmap
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
operator|&
name|attach_va
argument_list|,
name|size
argument_list|,
name|prot
argument_list|,
name|VM_PROT_DEFAULT
argument_list|,
name|flags
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|shmid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|shmmap_s
operator|->
name|va
operator|=
name|attach_va
expr_stmt|;
name|shmmap_s
operator|->
name|shmid
operator|=
name|uap
operator|->
name|shmid
expr_stmt|;
name|shmseg
operator|->
name|shm_lpid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|shmseg
operator|->
name|shm_atime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|shmseg
operator|->
name|shm_nattch
operator|++
expr_stmt|;
operator|*
name|retval
operator|=
name|attach_va
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_struct
struct|struct
name|oshmid_ds
block|{
name|struct
name|ipc_perm
name|shm_perm
decl_stmt|;
comment|/* operation perms */
name|int
name|shm_segsz
decl_stmt|;
comment|/* size of segment (bytes) */
name|ushort
name|shm_cpid
decl_stmt|;
comment|/* pid, creator */
name|ushort
name|shm_lpid
decl_stmt|;
comment|/* pid, last operation */
name|short
name|shm_nattch
decl_stmt|;
comment|/* no. of current attaches */
name|time_t
name|shm_atime
decl_stmt|;
comment|/* last attach time */
name|time_t
name|shm_dtime
decl_stmt|;
comment|/* last detach time */
name|time_t
name|shm_ctime
decl_stmt|;
comment|/* last change time */
name|void
modifier|*
name|shm_handle
decl_stmt|;
comment|/* internal handle for shm segment */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|oshmctl_args
block|{
name|int
name|shmid
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|struct
name|oshmid_ds
modifier|*
name|ubuf
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|oshmctl
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|,
name|retval
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|oshmctl_args
modifier|*
name|uap
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|COMPAT_43
name|int
name|error
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|p
operator|->
name|p_ucred
decl_stmt|;
name|struct
name|shmid_ds
modifier|*
name|shmseg
decl_stmt|;
name|struct
name|oshmid_ds
name|outbuf
decl_stmt|;
name|shmseg
operator|=
name|shm_find_segment_by_shmid
argument_list|(
name|uap
operator|->
name|shmid
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmseg
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
name|IPC_STAT
case|:
name|error
operator|=
name|ipcperm
argument_list|(
name|cred
argument_list|,
operator|&
name|shmseg
operator|->
name|shm_perm
argument_list|,
name|IPC_R
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|outbuf
operator|.
name|shm_perm
operator|=
name|shmseg
operator|->
name|shm_perm
expr_stmt|;
name|outbuf
operator|.
name|shm_segsz
operator|=
name|shmseg
operator|->
name|shm_segsz
expr_stmt|;
name|outbuf
operator|.
name|shm_cpid
operator|=
name|shmseg
operator|->
name|shm_cpid
expr_stmt|;
name|outbuf
operator|.
name|shm_lpid
operator|=
name|shmseg
operator|->
name|shm_lpid
expr_stmt|;
name|outbuf
operator|.
name|shm_nattch
operator|=
name|shmseg
operator|->
name|shm_nattch
expr_stmt|;
name|outbuf
operator|.
name|shm_atime
operator|=
name|shmseg
operator|->
name|shm_atime
expr_stmt|;
name|outbuf
operator|.
name|shm_dtime
operator|=
name|shmseg
operator|->
name|shm_dtime
expr_stmt|;
name|outbuf
operator|.
name|shm_ctime
operator|=
name|shmseg
operator|->
name|shm_ctime
expr_stmt|;
name|outbuf
operator|.
name|shm_handle
operator|=
name|shmseg
operator|->
name|shm_internal
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|outbuf
argument_list|,
name|uap
operator|->
name|ubuf
argument_list|,
sizeof|sizeof
argument_list|(
name|outbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
break|break;
default|default:
return|return
name|shmctl
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|retval
argument_list|)
return|;
block|}
return|return
literal|0
return|;
else|#
directive|else
return|return
name|EINVAL
return|;
endif|#
directive|endif
block|}
end_function

begin_struct
struct|struct
name|shmctl_args
block|{
name|int
name|shmid
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|struct
name|shmid_ds
modifier|*
name|ubuf
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|shmctl
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|,
name|retval
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|shmctl_args
modifier|*
name|uap
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|p
operator|->
name|p_ucred
decl_stmt|;
name|struct
name|shmid_ds
name|inbuf
decl_stmt|;
name|struct
name|shmid_ds
modifier|*
name|shmseg
decl_stmt|;
name|shmseg
operator|=
name|shm_find_segment_by_shmid
argument_list|(
name|uap
operator|->
name|shmid
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmseg
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
name|IPC_STAT
case|:
name|error
operator|=
name|ipcperm
argument_list|(
name|cred
argument_list|,
operator|&
name|shmseg
operator|->
name|shm_perm
argument_list|,
name|IPC_R
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|shmseg
argument_list|,
name|uap
operator|->
name|ubuf
argument_list|,
sizeof|sizeof
argument_list|(
name|inbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
break|break;
case|case
name|IPC_SET
case|:
name|error
operator|=
name|ipcperm
argument_list|(
name|cred
argument_list|,
operator|&
name|shmseg
operator|->
name|shm_perm
argument_list|,
name|IPC_M
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|ubuf
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|inbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|inbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|shmseg
operator|->
name|shm_perm
operator|.
name|uid
operator|=
name|inbuf
operator|.
name|shm_perm
operator|.
name|uid
expr_stmt|;
name|shmseg
operator|->
name|shm_perm
operator|.
name|gid
operator|=
name|inbuf
operator|.
name|shm_perm
operator|.
name|gid
expr_stmt|;
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|=
operator|(
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|&
operator|~
name|ACCESSPERMS
operator|)
operator||
operator|(
name|inbuf
operator|.
name|shm_perm
operator|.
name|mode
operator|&
name|ACCESSPERMS
operator|)
expr_stmt|;
name|shmseg
operator|->
name|shm_ctime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
break|break;
case|case
name|IPC_RMID
case|:
name|error
operator|=
name|ipcperm
argument_list|(
name|cred
argument_list|,
operator|&
name|shmseg
operator|->
name|shm_perm
argument_list|,
name|IPC_M
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|shmseg
operator|->
name|shm_perm
operator|.
name|key
operator|=
name|IPC_PRIVATE
expr_stmt|;
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator||=
name|SHMSEG_REMOVED
expr_stmt|;
if|if
condition|(
name|shmseg
operator|->
name|shm_nattch
operator|<=
literal|0
condition|)
block|{
name|shm_deallocate_segment
argument_list|(
name|shmseg
argument_list|)
expr_stmt|;
name|shm_last_free
operator|=
name|IPCID_TO_IX
argument_list|(
name|uap
operator|->
name|shmid
argument_list|)
expr_stmt|;
block|}
break|break;
if|#
directive|if
literal|0
block|case SHM_LOCK: 	case SHM_UNLOCK:
endif|#
directive|endif
default|default:
return|return
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_struct
struct|struct
name|shmget_args
block|{
name|key_t
name|key
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|shmflg
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|shmget_existing
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|,
name|mode
parameter_list|,
name|segnum
parameter_list|,
name|retval
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|shmget_args
modifier|*
name|uap
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|segnum
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
name|struct
name|shmid_ds
modifier|*
name|shmseg
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|p
operator|->
name|p_ucred
decl_stmt|;
name|int
name|error
decl_stmt|;
name|shmseg
operator|=
operator|&
name|shmsegs
index|[
name|segnum
index|]
expr_stmt|;
if|if
condition|(
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|&
name|SHMSEG_REMOVED
condition|)
block|{
comment|/* 		 * This segment is in the process of being allocated.  Wait 		 * until it's done, and look the key up again (in case the 		 * allocation failed or it was freed). 		 */
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator||=
name|SHMSEG_WANTED
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|shmseg
argument_list|,
name|PLOCK
operator||
name|PCATCH
argument_list|,
literal|"shmget"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
return|return
name|EAGAIN
return|;
block|}
name|error
operator|=
name|ipcperm
argument_list|(
name|cred
argument_list|,
operator|&
name|shmseg
operator|->
name|shm_perm
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|uap
operator|->
name|size
operator|&&
name|uap
operator|->
name|size
operator|>
name|shmseg
operator|->
name|shm_segsz
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
operator|(
name|uap
operator|->
name|shmflg
operator|&
operator|(
name|IPC_CREAT
operator||
name|IPC_EXCL
operator|)
operator|)
operator|==
operator|(
name|IPC_CREAT
operator||
name|IPC_EXCL
operator|)
condition|)
return|return
name|EEXIST
return|;
operator|*
name|retval
operator|=
name|IXSEQ_TO_IPCID
argument_list|(
name|segnum
argument_list|,
name|shmseg
operator|->
name|shm_perm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|shmget_allocate_segment
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|,
name|mode
parameter_list|,
name|retval
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|shmget_args
modifier|*
name|uap
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|segnum
decl_stmt|,
name|result
decl_stmt|,
name|shmid
decl_stmt|,
name|size
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|p
operator|->
name|p_ucred
decl_stmt|;
name|struct
name|shmid_ds
modifier|*
name|shmseg
decl_stmt|;
name|struct
name|shm_handle
modifier|*
name|shm_handle
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|size
operator|<
name|shminfo
operator|.
name|shmmin
operator|||
name|uap
operator|->
name|size
operator|>
name|shminfo
operator|.
name|shmmax
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|shm_nused
operator|>=
name|shminfo
operator|.
name|shmmni
condition|)
comment|/* any shmids left? */
return|return
name|ENOSPC
return|;
name|size
operator|=
operator|(
name|uap
operator|->
name|size
operator|+
name|CLOFSET
operator|)
operator|&
operator|~
name|CLOFSET
expr_stmt|;
if|if
condition|(
name|shm_committed
operator|+
name|btoc
argument_list|(
name|size
argument_list|)
operator|>
name|shminfo
operator|.
name|shmall
condition|)
return|return
name|ENOMEM
return|;
if|if
condition|(
name|shm_last_free
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmmni
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|mode
operator|&
name|SHMSEG_FREE
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|shminfo
operator|.
name|shmmni
condition|)
name|panic
argument_list|(
literal|"shmseg free count inconsistent"
argument_list|)
expr_stmt|;
name|segnum
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|segnum
operator|=
name|shm_last_free
expr_stmt|;
name|shm_last_free
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|shmseg
operator|=
operator|&
name|shmsegs
index|[
name|segnum
index|]
expr_stmt|;
comment|/* 	 * In case we sleep in malloc(), mark the segment present but deleted 	 * so that noone else tries to create the same key. 	 */
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|=
name|SHMSEG_ALLOCATED
operator||
name|SHMSEG_REMOVED
expr_stmt|;
name|shmseg
operator|->
name|shm_perm
operator|.
name|key
operator|=
name|uap
operator|->
name|key
expr_stmt|;
name|shmseg
operator|->
name|shm_perm
operator|.
name|seq
operator|=
operator|(
name|shmseg
operator|->
name|shm_perm
operator|.
name|seq
operator|+
literal|1
operator|)
operator|&
literal|0x7fff
expr_stmt|;
name|shm_handle
operator|=
operator|(
expr|struct
name|shm_handle
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|shm_handle
argument_list|)
argument_list|,
name|M_SHM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|shmid
operator|=
name|IXSEQ_TO_IPCID
argument_list|(
name|segnum
argument_list|,
name|shmseg
operator|->
name|shm_perm
argument_list|)
expr_stmt|;
name|result
operator|=
name|vm_mmap
argument_list|(
name|sysvshm_map
argument_list|,
operator|&
name|shm_handle
operator|->
name|kva
argument_list|,
name|size
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_DEFAULT
argument_list|,
name|MAP_ANON
argument_list|,
operator|(
name|caddr_t
operator|)
name|shmid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|=
name|SHMSEG_FREE
expr_stmt|;
name|shm_last_free
operator|=
name|segnum
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|shm_handle
argument_list|,
name|M_SHM
argument_list|)
expr_stmt|;
comment|/* Just in case. */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|shmseg
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|shmseg
operator|->
name|shm_internal
operator|=
name|shm_handle
expr_stmt|;
name|shmseg
operator|->
name|shm_perm
operator|.
name|cuid
operator|=
name|shmseg
operator|->
name|shm_perm
operator|.
name|uid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|shmseg
operator|->
name|shm_perm
operator|.
name|cgid
operator|=
name|shmseg
operator|->
name|shm_perm
operator|.
name|gid
operator|=
name|cred
operator|->
name|cr_gid
expr_stmt|;
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|=
operator|(
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|&
name|SHMSEG_WANTED
operator|)
operator||
operator|(
name|mode
operator|&
name|ACCESSPERMS
operator|)
operator||
name|SHMSEG_ALLOCATED
expr_stmt|;
name|shmseg
operator|->
name|shm_segsz
operator|=
name|uap
operator|->
name|size
expr_stmt|;
name|shmseg
operator|->
name|shm_cpid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|shmseg
operator|->
name|shm_lpid
operator|=
name|shmseg
operator|->
name|shm_nattch
operator|=
literal|0
expr_stmt|;
name|shmseg
operator|->
name|shm_atime
operator|=
name|shmseg
operator|->
name|shm_dtime
operator|=
literal|0
expr_stmt|;
name|shmseg
operator|->
name|shm_ctime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|shm_committed
operator|+=
name|btoc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|shm_nused
operator|++
expr_stmt|;
if|if
condition|(
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|&
name|SHMSEG_WANTED
condition|)
block|{
comment|/* 		 * Somebody else wanted this key while we were asleep.  Wake 		 * them up now. 		 */
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|&=
operator|~
name|SHMSEG_WANTED
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|shmseg
argument_list|)
expr_stmt|;
block|}
operator|*
name|retval
operator|=
name|shmid
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|shmget
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|,
name|retval
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|shmget_args
modifier|*
name|uap
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
name|int
name|segnum
decl_stmt|,
name|mode
decl_stmt|,
name|error
decl_stmt|;
name|mode
operator|=
name|uap
operator|->
name|shmflg
operator|&
name|ACCESSPERMS
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|key
operator|!=
name|IPC_PRIVATE
condition|)
block|{
name|again
label|:
name|segnum
operator|=
name|shm_find_segment_by_key
argument_list|(
name|uap
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|segnum
operator|>=
literal|0
condition|)
block|{
name|error
operator|=
name|shmget_existing
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|mode
argument_list|,
name|segnum
argument_list|,
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EAGAIN
condition|)
goto|goto
name|again
goto|;
return|return
name|error
return|;
block|}
if|if
condition|(
operator|(
name|uap
operator|->
name|shmflg
operator|&
name|IPC_CREAT
operator|)
operator|==
literal|0
condition|)
return|return
name|ENOENT
return|;
block|}
return|return
name|shmget_allocate_segment
argument_list|(
name|p
argument_list|,
name|uap
argument_list|,
name|mode
argument_list|,
name|retval
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|shmsys_args
block|{
name|u_int
name|which
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|shmsys
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|,
name|retval
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|shmsys_args
modifier|*
name|uap
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
block|{
if|if
condition|(
name|uap
operator|->
name|which
operator|>=
sizeof|sizeof
argument_list|(
name|shmcalls
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|shmcalls
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
name|EINVAL
return|;
return|return
operator|(
call|(
modifier|*
name|shmcalls
index|[
name|uap
operator|->
name|which
index|]
call|)
argument_list|(
name|p
argument_list|,
operator|&
name|uap
index|[
literal|1
index|]
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|shmfork
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|,
name|isvfork
parameter_list|)
name|struct
name|proc
modifier|*
name|p1
decl_stmt|,
decl|*
name|p2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|isvfork
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|shmmap_state
modifier|*
name|shmmap_s
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size
operator|=
name|shminfo
operator|.
name|shmseg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|shmmap_state
argument_list|)
expr_stmt|;
name|shmmap_s
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_SHM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|p1
operator|->
name|p_vmspace
operator|->
name|vm_shm
argument_list|,
operator|(
name|caddr_t
operator|)
name|shmmap_s
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p2
operator|->
name|p_vmspace
operator|->
name|vm_shm
operator|=
operator|(
name|caddr_t
operator|)
name|shmmap_s
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmseg
condition|;
name|i
operator|++
operator|,
name|shmmap_s
operator|++
control|)
if|if
condition|(
name|shmmap_s
operator|->
name|shmid
operator|!=
operator|-
literal|1
condition|)
name|shmsegs
index|[
name|IPCID_TO_IX
argument_list|(
name|shmmap_s
operator|->
name|shmid
argument_list|)
index|]
operator|.
name|shm_nattch
operator|++
expr_stmt|;
block|}
end_block

begin_function
name|void
name|shmexit
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|shmmap_state
modifier|*
name|shmmap_s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|shmmap_s
operator|=
operator|(
expr|struct
name|shmmap_state
operator|*
operator|)
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmseg
condition|;
name|i
operator|++
operator|,
name|shmmap_s
operator|++
control|)
if|if
condition|(
name|shmmap_s
operator|->
name|shmid
operator|!=
operator|-
literal|1
condition|)
name|shm_delete_mapping
argument_list|(
name|p
argument_list|,
name|shmmap_s
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
argument_list|,
name|M_SHM
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|shminit
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|vm_offset_t
name|garbage1
decl_stmt|,
name|garbage2
decl_stmt|;
comment|/* actually this *should* be pageable.  SHM_{LOCK,UNLOCK} */
name|sysvshm_map
operator|=
name|kmem_suballoc
argument_list|(
name|kernel_map
argument_list|,
operator|&
name|garbage1
argument_list|,
operator|&
name|garbage2
argument_list|,
name|shminfo
operator|.
name|shmall
operator|*
name|NBPG
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmmni
condition|;
name|i
operator|++
control|)
block|{
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|mode
operator|=
name|SHMSEG_FREE
expr_stmt|;
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|seq
operator|=
literal|0
expr_stmt|;
block|}
name|shm_last_free
operator|=
literal|0
expr_stmt|;
name|shm_nused
operator|=
literal|0
expr_stmt|;
name|shm_committed
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

