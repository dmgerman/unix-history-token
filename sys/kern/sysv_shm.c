begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*	$NetBSD: sysv_shm.c,v 1.23 1994/07/04 23:25:12 glass Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1994 Adam Glass and Charles Hannum.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Adam Glass and Charles  *	Hannum.  * 4. The names of the authors may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_sysvipc.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/shm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_SHM
argument_list|,
literal|"shm"
argument_list|,
literal|"SVID compatible shared memory segments"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct_decl
struct_decl|struct
name|oshmctl_args
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|int
name|oshmctl
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|oshmctl_args
modifier|*
name|uap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|shmget_allocate_segment
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|shmget_args
modifier|*
name|uap
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|shmget_existing
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|shmget_args
modifier|*
name|uap
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|segnum
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* XXX casting to (sy_call_t *) is bogus, as usual. */
end_comment

begin_decl_stmt
specifier|static
name|sy_call_t
modifier|*
name|shmcalls
index|[]
init|=
block|{
operator|(
name|sy_call_t
operator|*
operator|)
name|shmat
block|,
operator|(
name|sy_call_t
operator|*
operator|)
name|oshmctl
block|,
operator|(
name|sy_call_t
operator|*
operator|)
name|shmdt
block|,
operator|(
name|sy_call_t
operator|*
operator|)
name|shmget
block|,
operator|(
name|sy_call_t
operator|*
operator|)
name|shmctl
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SHMSEG_FREE
value|0x0200
end_define

begin_define
define|#
directive|define
name|SHMSEG_REMOVED
value|0x0400
end_define

begin_define
define|#
directive|define
name|SHMSEG_ALLOCATED
value|0x0800
end_define

begin_define
define|#
directive|define
name|SHMSEG_WANTED
value|0x1000
end_define

begin_decl_stmt
specifier|static
name|int
name|shm_last_free
decl_stmt|,
name|shm_nused
decl_stmt|,
name|shm_committed
decl_stmt|,
name|shmalloced
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|shmid_ds
modifier|*
name|shmsegs
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|shm_handle
block|{
comment|/* vm_offset_t kva; */
name|vm_object_t
name|shm_object
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|shmmap_state
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|int
name|shmid
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|shm_deallocate_segment
parameter_list|(
name|struct
name|shmid_ds
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|shm_find_segment_by_key
parameter_list|(
name|key_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|shmid_ds
modifier|*
name|shm_find_segment_by_shmid
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|shmid_ds
modifier|*
name|shm_find_segment_by_shmidx
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|shm_delete_mapping
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|shmmap_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shmrealloc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shminit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysvshm_modload
parameter_list|(
name|struct
name|module
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|shmunload
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shmexit_myhook
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|shmfork_myhook
parameter_list|(
name|struct
name|proc
modifier|*
name|p1
parameter_list|,
name|struct
name|proc
modifier|*
name|p2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_shmsegs
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Tuneable values.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SHMMAXPGS
end_ifndef

begin_define
define|#
directive|define
name|SHMMAXPGS
value|8192
end_define

begin_comment
comment|/* Note: sysv shared memory is swap backed. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SHMMAX
end_ifndef

begin_define
define|#
directive|define
name|SHMMAX
value|(SHMMAXPGS*PAGE_SIZE)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SHMMIN
end_ifndef

begin_define
define|#
directive|define
name|SHMMIN
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SHMMNI
end_ifndef

begin_define
define|#
directive|define
name|SHMMNI
value|192
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SHMSEG
end_ifndef

begin_define
define|#
directive|define
name|SHMSEG
value|128
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SHMALL
end_ifndef

begin_define
define|#
directive|define
name|SHMALL
value|(SHMMAXPGS)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|shminfo
name|shminfo
init|=
block|{
name|SHMMAX
block|,
name|SHMMIN
block|,
name|SHMMNI
block|,
name|SHMSEG
block|,
name|SHMALL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|shm_use_phys
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_kern_ipc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|shmmax
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|shminfo
operator|.
name|shmmax
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|shmmin
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|shminfo
operator|.
name|shmmin
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|shmmni
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|shminfo
operator|.
name|shmmni
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|shmseg
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|shminfo
operator|.
name|shmseg
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|shmall
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|shminfo
operator|.
name|shmall
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|shm_use_phys
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|shm_use_phys
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|shmsegs
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_shmsegs
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|shm_find_segment_by_key
parameter_list|(
name|key
parameter_list|)
name|key_t
name|key
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shmalloced
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|mode
operator|&
name|SHMSEG_ALLOCATED
operator|)
operator|&&
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|key
operator|==
name|key
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|shmid_ds
modifier|*
name|shm_find_segment_by_shmid
parameter_list|(
name|shmid
parameter_list|)
name|int
name|shmid
decl_stmt|;
block|{
name|int
name|segnum
decl_stmt|;
name|struct
name|shmid_ds
modifier|*
name|shmseg
decl_stmt|;
name|segnum
operator|=
name|IPCID_TO_IX
argument_list|(
name|shmid
argument_list|)
expr_stmt|;
if|if
condition|(
name|segnum
operator|<
literal|0
operator|||
name|segnum
operator|>=
name|shmalloced
condition|)
return|return
name|NULL
return|;
name|shmseg
operator|=
operator|&
name|shmsegs
index|[
name|segnum
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|&
operator|(
name|SHMSEG_ALLOCATED
operator||
name|SHMSEG_REMOVED
operator|)
operator|)
operator|!=
name|SHMSEG_ALLOCATED
operator|||
name|shmseg
operator|->
name|shm_perm
operator|.
name|seq
operator|!=
name|IPCID_TO_SEQ
argument_list|(
name|shmid
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|shmseg
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|shmid_ds
modifier|*
name|shm_find_segment_by_shmidx
parameter_list|(
name|int
name|segnum
parameter_list|)
block|{
name|struct
name|shmid_ds
modifier|*
name|shmseg
decl_stmt|;
if|if
condition|(
name|segnum
operator|<
literal|0
operator|||
name|segnum
operator|>=
name|shmalloced
condition|)
return|return
name|NULL
return|;
name|shmseg
operator|=
operator|&
name|shmsegs
index|[
name|segnum
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|&
operator|(
name|SHMSEG_ALLOCATED
operator||
name|SHMSEG_REMOVED
operator|)
operator|)
operator|!=
name|SHMSEG_ALLOCATED
condition|)
return|return
name|NULL
return|;
return|return
name|shmseg
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|shm_deallocate_segment
parameter_list|(
name|shmseg
parameter_list|)
name|struct
name|shmid_ds
modifier|*
name|shmseg
decl_stmt|;
block|{
name|struct
name|shm_handle
modifier|*
name|shm_handle
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|shm_handle
operator|=
name|shmseg
operator|->
name|shm_internal
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|shm_handle
operator|->
name|shm_object
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|shm_handle
argument_list|,
name|M_SHM
argument_list|)
expr_stmt|;
name|shmseg
operator|->
name|shm_internal
operator|=
name|NULL
expr_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|shmseg
operator|->
name|shm_segsz
argument_list|)
expr_stmt|;
name|shm_committed
operator|-=
name|btoc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|shm_nused
operator|--
expr_stmt|;
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|=
name|SHMSEG_FREE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|shm_delete_mapping
parameter_list|(
name|p
parameter_list|,
name|shmmap_s
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|shmmap_state
modifier|*
name|shmmap_s
decl_stmt|;
block|{
name|struct
name|shmid_ds
modifier|*
name|shmseg
decl_stmt|;
name|int
name|segnum
decl_stmt|,
name|result
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|segnum
operator|=
name|IPCID_TO_IX
argument_list|(
name|shmmap_s
operator|->
name|shmid
argument_list|)
expr_stmt|;
name|shmseg
operator|=
operator|&
name|shmsegs
index|[
name|segnum
index|]
expr_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|shmseg
operator|->
name|shm_segsz
argument_list|)
expr_stmt|;
name|result
operator|=
name|vm_map_remove
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|shmmap_s
operator|->
name|va
argument_list|,
name|shmmap_s
operator|->
name|va
operator|+
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|KERN_SUCCESS
condition|)
return|return
name|EINVAL
return|;
name|shmmap_s
operator|->
name|shmid
operator|=
operator|-
literal|1
expr_stmt|;
name|shmseg
operator|->
name|shm_dtime
operator|=
name|time_second
expr_stmt|;
if|if
condition|(
operator|(
operator|--
name|shmseg
operator|->
name|shm_nattch
operator|<=
literal|0
operator|)
operator|&&
operator|(
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|&
name|SHMSEG_REMOVED
operator|)
condition|)
block|{
name|shm_deallocate_segment
argument_list|(
name|shmseg
argument_list|)
expr_stmt|;
name|shm_last_free
operator|=
name|segnum
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|shmdt_args
block|{
name|void
modifier|*
name|shmaddr
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
name|int
name|shmdt
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|shmdt_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|shmmap_state
modifier|*
name|shmmap_s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|jail_sysvipc_allowed
operator|&&
name|jailed
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|shmmap_s
operator|=
operator|(
expr|struct
name|shmmap_state
operator|*
operator|)
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
expr_stmt|;
if|if
condition|(
name|shmmap_s
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmseg
condition|;
name|i
operator|++
operator|,
name|shmmap_s
operator|++
control|)
block|{
if|if
condition|(
name|shmmap_s
operator|->
name|shmid
operator|!=
operator|-
literal|1
operator|&&
name|shmmap_s
operator|->
name|va
operator|==
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|shmaddr
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|shminfo
operator|.
name|shmseg
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|error
operator|=
name|shm_delete_mapping
argument_list|(
name|p
argument_list|,
name|shmmap_s
argument_list|)
expr_stmt|;
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|shmat_args
block|{
name|int
name|shmid
decl_stmt|;
name|void
modifier|*
name|shmaddr
decl_stmt|;
name|int
name|shmflg
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
name|int
name|shmat
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|shmat_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|shmid_ds
modifier|*
name|shmseg
decl_stmt|;
name|struct
name|shmmap_state
modifier|*
name|shmmap_s
init|=
name|NULL
decl_stmt|;
name|struct
name|shm_handle
modifier|*
name|shm_handle
decl_stmt|;
name|vm_offset_t
name|attach_va
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|jail_sysvipc_allowed
operator|&&
name|jailed
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|shmmap_s
operator|=
operator|(
expr|struct
name|shmmap_state
operator|*
operator|)
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
expr_stmt|;
if|if
condition|(
name|shmmap_s
operator|==
name|NULL
condition|)
block|{
name|size
operator|=
name|shminfo
operator|.
name|shmseg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|shmmap_state
argument_list|)
expr_stmt|;
name|shmmap_s
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_SHM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmseg
condition|;
name|i
operator|++
control|)
name|shmmap_s
index|[
name|i
index|]
operator|.
name|shmid
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
operator|=
operator|(
name|caddr_t
operator|)
name|shmmap_s
expr_stmt|;
block|}
name|shmseg
operator|=
name|shm_find_segment_by_shmid
argument_list|(
name|uap
operator|->
name|shmid
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmseg
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|shmseg
operator|->
name|shm_perm
argument_list|,
operator|(
name|uap
operator|->
name|shmflg
operator|&
name|SHM_RDONLY
operator|)
condition|?
name|IPC_R
else|:
name|IPC_R
operator||
name|IPC_W
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done2
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmseg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|shmmap_s
operator|->
name|shmid
operator|==
operator|-
literal|1
condition|)
break|break;
name|shmmap_s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|shminfo
operator|.
name|shmseg
condition|)
block|{
name|error
operator|=
name|EMFILE
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|size
operator|=
name|round_page
argument_list|(
name|shmseg
operator|->
name|shm_segsz
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VM_PROT_READ_IS_EXEC
name|prot
operator|=
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
expr_stmt|;
else|#
directive|else
name|prot
operator|=
name|VM_PROT_READ
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|uap
operator|->
name|shmflg
operator|&
name|SHM_RDONLY
operator|)
operator|==
literal|0
condition|)
name|prot
operator||=
name|VM_PROT_WRITE
expr_stmt|;
name|flags
operator|=
name|MAP_ANON
operator||
name|MAP_SHARED
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|shmaddr
condition|)
block|{
name|flags
operator||=
name|MAP_FIXED
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|shmflg
operator|&
name|SHM_RND
condition|)
block|{
name|attach_va
operator|=
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|shmaddr
operator|&
operator|~
operator|(
name|SHMLBA
operator|-
literal|1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|shmaddr
operator|&
operator|(
name|SHMLBA
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|attach_va
operator|=
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|shmaddr
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * This is just a hint to vm_map_find() about where to 		 * put it. 		 */
name|attach_va
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|p
operator|->
name|p_vmspace
operator|->
name|vm_taddr
operator|+
name|maxtsiz
operator|+
name|maxdsiz
argument_list|)
expr_stmt|;
block|}
name|shm_handle
operator|=
name|shmseg
operator|->
name|shm_internal
expr_stmt|;
name|vm_object_reference
argument_list|(
name|shm_handle
operator|->
name|shm_object
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_map_find
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|shm_handle
operator|->
name|shm_object
argument_list|,
literal|0
argument_list|,
operator|&
name|attach_va
argument_list|,
name|size
argument_list|,
operator|(
name|flags
operator|&
name|MAP_FIXED
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|,
name|prot
argument_list|,
name|prot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|vm_map_inherit
argument_list|(
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|attach_va
argument_list|,
name|attach_va
operator|+
name|size
argument_list|,
name|VM_INHERIT_SHARE
argument_list|)
expr_stmt|;
name|shmmap_s
operator|->
name|va
operator|=
name|attach_va
expr_stmt|;
name|shmmap_s
operator|->
name|shmid
operator|=
name|uap
operator|->
name|shmid
expr_stmt|;
name|shmseg
operator|->
name|shm_lpid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|shmseg
operator|->
name|shm_atime
operator|=
name|time_second
expr_stmt|;
name|shmseg
operator|->
name|shm_nattch
operator|++
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|attach_va
expr_stmt|;
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|oshmid_ds
block|{
name|struct
name|ipc_perm
name|shm_perm
decl_stmt|;
comment|/* operation perms */
name|int
name|shm_segsz
decl_stmt|;
comment|/* size of segment (bytes) */
name|ushort
name|shm_cpid
decl_stmt|;
comment|/* pid, creator */
name|ushort
name|shm_lpid
decl_stmt|;
comment|/* pid, last operation */
name|short
name|shm_nattch
decl_stmt|;
comment|/* no. of current attaches */
name|time_t
name|shm_atime
decl_stmt|;
comment|/* last attach time */
name|time_t
name|shm_dtime
decl_stmt|;
comment|/* last detach time */
name|time_t
name|shm_ctime
decl_stmt|;
comment|/* last change time */
name|void
modifier|*
name|shm_handle
decl_stmt|;
comment|/* internal handle for shm segment */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|oshmctl_args
block|{
name|int
name|shmid
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|struct
name|oshmid_ds
modifier|*
name|ubuf
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
specifier|static
name|int
name|oshmctl
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|oshmctl_args
modifier|*
name|uap
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|COMPAT_43
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|shmid_ds
modifier|*
name|shmseg
decl_stmt|;
name|struct
name|oshmid_ds
name|outbuf
decl_stmt|;
if|if
condition|(
operator|!
name|jail_sysvipc_allowed
operator|&&
name|jailed
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|shmseg
operator|=
name|shm_find_segment_by_shmid
argument_list|(
name|uap
operator|->
name|shmid
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmseg
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
name|IPC_STAT
case|:
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|shmseg
operator|->
name|shm_perm
argument_list|,
name|IPC_R
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done2
goto|;
name|outbuf
operator|.
name|shm_perm
operator|=
name|shmseg
operator|->
name|shm_perm
expr_stmt|;
name|outbuf
operator|.
name|shm_segsz
operator|=
name|shmseg
operator|->
name|shm_segsz
expr_stmt|;
name|outbuf
operator|.
name|shm_cpid
operator|=
name|shmseg
operator|->
name|shm_cpid
expr_stmt|;
name|outbuf
operator|.
name|shm_lpid
operator|=
name|shmseg
operator|->
name|shm_lpid
expr_stmt|;
name|outbuf
operator|.
name|shm_nattch
operator|=
name|shmseg
operator|->
name|shm_nattch
expr_stmt|;
name|outbuf
operator|.
name|shm_atime
operator|=
name|shmseg
operator|->
name|shm_atime
expr_stmt|;
name|outbuf
operator|.
name|shm_dtime
operator|=
name|shmseg
operator|->
name|shm_dtime
expr_stmt|;
name|outbuf
operator|.
name|shm_ctime
operator|=
name|shmseg
operator|->
name|shm_ctime
expr_stmt|;
name|outbuf
operator|.
name|shm_handle
operator|=
name|shmseg
operator|->
name|shm_internal
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|outbuf
argument_list|,
name|uap
operator|->
name|ubuf
argument_list|,
sizeof|sizeof
argument_list|(
name|outbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done2
goto|;
break|break;
default|default:
comment|/* XXX casting to (sy_call_t *) is bogus, as usual. */
name|error
operator|=
operator|(
operator|(
name|sy_call_t
operator|*
operator|)
name|shmctl
operator|)
operator|(
name|td
operator|,
name|uap
operator|)
expr_stmt|;
break|break;
block|}
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
else|#
directive|else
return|return
name|EINVAL
return|;
endif|#
directive|endif
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|shmctl_args
block|{
name|int
name|shmid
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|struct
name|shmid_ds
modifier|*
name|buf
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
name|int
name|shmctl
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|shmctl_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|shmid_ds
name|inbuf
decl_stmt|;
name|struct
name|shmid_ds
modifier|*
name|shmseg
decl_stmt|;
if|if
condition|(
operator|!
name|jail_sysvipc_allowed
operator|&&
name|jailed
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
name|IPC_INFO
case|:
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|shminfo
argument_list|,
name|uap
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|shminfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done2
goto|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|shmalloced
expr_stmt|;
goto|goto
name|done2
goto|;
case|case
name|SHM_INFO
case|:
block|{
name|struct
name|shm_info
name|shm_info
decl_stmt|;
name|shm_info
operator|.
name|used_ids
operator|=
name|shm_nused
expr_stmt|;
name|shm_info
operator|.
name|shm_rss
operator|=
literal|0
expr_stmt|;
comment|/*XXX where to get from ? */
name|shm_info
operator|.
name|shm_tot
operator|=
literal|0
expr_stmt|;
comment|/*XXX where to get from ? */
name|shm_info
operator|.
name|shm_swp
operator|=
literal|0
expr_stmt|;
comment|/*XXX where to get from ? */
name|shm_info
operator|.
name|swap_attempts
operator|=
literal|0
expr_stmt|;
comment|/*XXX where to get from ? */
name|shm_info
operator|.
name|swap_successes
operator|=
literal|0
expr_stmt|;
comment|/*XXX where to get from ? */
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|shm_info
argument_list|,
name|uap
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|shm_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done2
goto|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|shmalloced
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|uap
operator|->
name|cmd
operator|)
operator|==
name|SHM_STAT
condition|)
name|shmseg
operator|=
name|shm_find_segment_by_shmidx
argument_list|(
name|uap
operator|->
name|shmid
argument_list|)
expr_stmt|;
else|else
name|shmseg
operator|=
name|shm_find_segment_by_shmid
argument_list|(
name|uap
operator|->
name|shmid
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmseg
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
name|SHM_STAT
case|:
case|case
name|IPC_STAT
case|:
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|shmseg
operator|->
name|shm_perm
argument_list|,
name|IPC_R
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done2
goto|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|shmseg
argument_list|,
name|uap
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|inbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done2
goto|;
elseif|else
if|if
condition|(
operator|(
name|uap
operator|->
name|cmd
operator|)
operator|==
name|SHM_STAT
condition|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|IXSEQ_TO_IPCID
argument_list|(
name|uap
operator|->
name|shmid
argument_list|,
name|shmseg
operator|->
name|shm_perm
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPC_SET
case|:
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|shmseg
operator|->
name|shm_perm
argument_list|,
name|IPC_M
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done2
goto|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|buf
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|inbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|inbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done2
goto|;
name|shmseg
operator|->
name|shm_perm
operator|.
name|uid
operator|=
name|inbuf
operator|.
name|shm_perm
operator|.
name|uid
expr_stmt|;
name|shmseg
operator|->
name|shm_perm
operator|.
name|gid
operator|=
name|inbuf
operator|.
name|shm_perm
operator|.
name|gid
expr_stmt|;
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|=
operator|(
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|&
operator|~
name|ACCESSPERMS
operator|)
operator||
operator|(
name|inbuf
operator|.
name|shm_perm
operator|.
name|mode
operator|&
name|ACCESSPERMS
operator|)
expr_stmt|;
name|shmseg
operator|->
name|shm_ctime
operator|=
name|time_second
expr_stmt|;
break|break;
case|case
name|IPC_RMID
case|:
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|shmseg
operator|->
name|shm_perm
argument_list|,
name|IPC_M
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done2
goto|;
name|shmseg
operator|->
name|shm_perm
operator|.
name|key
operator|=
name|IPC_PRIVATE
expr_stmt|;
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator||=
name|SHMSEG_REMOVED
expr_stmt|;
if|if
condition|(
name|shmseg
operator|->
name|shm_nattch
operator|<=
literal|0
condition|)
block|{
name|shm_deallocate_segment
argument_list|(
name|shmseg
argument_list|)
expr_stmt|;
name|shm_last_free
operator|=
name|IPCID_TO_IX
argument_list|(
name|uap
operator|->
name|shmid
argument_list|)
expr_stmt|;
block|}
break|break;
if|#
directive|if
literal|0
block|case SHM_LOCK: 	case SHM_UNLOCK:
endif|#
directive|endif
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|shmget_args
block|{
name|key_t
name|key
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|shmflg
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|shmget_existing
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|,
name|mode
parameter_list|,
name|segnum
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|shmget_args
modifier|*
name|uap
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|segnum
decl_stmt|;
block|{
name|struct
name|shmid_ds
modifier|*
name|shmseg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|shmseg
operator|=
operator|&
name|shmsegs
index|[
name|segnum
index|]
expr_stmt|;
if|if
condition|(
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|&
name|SHMSEG_REMOVED
condition|)
block|{
comment|/* 		 * This segment is in the process of being allocated.  Wait 		 * until it's done, and look the key up again (in case the 		 * allocation failed or it was freed). 		 */
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator||=
name|SHMSEG_WANTED
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|shmseg
argument_list|,
name|PLOCK
operator||
name|PCATCH
argument_list|,
literal|"shmget"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
return|return
name|EAGAIN
return|;
block|}
if|if
condition|(
operator|(
name|uap
operator|->
name|shmflg
operator|&
operator|(
name|IPC_CREAT
operator||
name|IPC_EXCL
operator|)
operator|)
operator|==
operator|(
name|IPC_CREAT
operator||
name|IPC_EXCL
operator|)
condition|)
return|return
name|EEXIST
return|;
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|shmseg
operator|->
name|shm_perm
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|uap
operator|->
name|size
operator|&&
name|uap
operator|->
name|size
operator|>
name|shmseg
operator|->
name|shm_segsz
condition|)
return|return
name|EINVAL
return|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|IXSEQ_TO_IPCID
argument_list|(
name|segnum
argument_list|,
name|shmseg
operator|->
name|shm_perm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|shmget_allocate_segment
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|,
name|mode
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|shmget_args
modifier|*
name|uap
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|segnum
decl_stmt|,
name|shmid
decl_stmt|,
name|size
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|td
operator|->
name|td_ucred
decl_stmt|;
name|struct
name|shmid_ds
modifier|*
name|shmseg
decl_stmt|;
name|struct
name|shm_handle
modifier|*
name|shm_handle
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|size
operator|<
name|shminfo
operator|.
name|shmmin
operator|||
name|uap
operator|->
name|size
operator|>
name|shminfo
operator|.
name|shmmax
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|shm_nused
operator|>=
name|shminfo
operator|.
name|shmmni
condition|)
comment|/* Any shmids left? */
return|return
name|ENOSPC
return|;
name|size
operator|=
name|round_page
argument_list|(
name|uap
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|shm_committed
operator|+
name|btoc
argument_list|(
name|size
argument_list|)
operator|>
name|shminfo
operator|.
name|shmall
condition|)
return|return
name|ENOMEM
return|;
if|if
condition|(
name|shm_last_free
operator|<
literal|0
condition|)
block|{
name|shmrealloc
argument_list|()
expr_stmt|;
comment|/* Maybe expand the shmsegs[] array. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shmalloced
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|mode
operator|&
name|SHMSEG_FREE
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|shmalloced
condition|)
return|return
name|ENOSPC
return|;
name|segnum
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|segnum
operator|=
name|shm_last_free
expr_stmt|;
name|shm_last_free
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|shmseg
operator|=
operator|&
name|shmsegs
index|[
name|segnum
index|]
expr_stmt|;
comment|/* 	 * In case we sleep in malloc(), mark the segment present but deleted 	 * so that noone else tries to create the same key. 	 */
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|=
name|SHMSEG_ALLOCATED
operator||
name|SHMSEG_REMOVED
expr_stmt|;
name|shmseg
operator|->
name|shm_perm
operator|.
name|key
operator|=
name|uap
operator|->
name|key
expr_stmt|;
name|shmseg
operator|->
name|shm_perm
operator|.
name|seq
operator|=
operator|(
name|shmseg
operator|->
name|shm_perm
operator|.
name|seq
operator|+
literal|1
operator|)
operator|&
literal|0x7fff
expr_stmt|;
name|shm_handle
operator|=
operator|(
expr|struct
name|shm_handle
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|shm_handle
argument_list|)
argument_list|,
name|M_SHM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|shmid
operator|=
name|IXSEQ_TO_IPCID
argument_list|(
name|segnum
argument_list|,
name|shmseg
operator|->
name|shm_perm
argument_list|)
expr_stmt|;
comment|/* 	 * We make sure that we have allocated a pager before we need 	 * to. 	 */
if|if
condition|(
name|shm_use_phys
condition|)
block|{
name|shm_handle
operator|->
name|shm_object
operator|=
name|vm_pager_allocate
argument_list|(
name|OBJT_PHYS
argument_list|,
literal|0
argument_list|,
name|size
argument_list|,
name|VM_PROT_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shm_handle
operator|->
name|shm_object
operator|=
name|vm_pager_allocate
argument_list|(
name|OBJT_SWAP
argument_list|,
literal|0
argument_list|,
name|size
argument_list|,
name|VM_PROT_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|vm_object_clear_flag
argument_list|(
name|shm_handle
operator|->
name|shm_object
argument_list|,
name|OBJ_ONEMAPPING
argument_list|)
expr_stmt|;
name|vm_object_set_flag
argument_list|(
name|shm_handle
operator|->
name|shm_object
argument_list|,
name|OBJ_NOSPLIT
argument_list|)
expr_stmt|;
name|shmseg
operator|->
name|shm_internal
operator|=
name|shm_handle
expr_stmt|;
name|shmseg
operator|->
name|shm_perm
operator|.
name|cuid
operator|=
name|shmseg
operator|->
name|shm_perm
operator|.
name|uid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|shmseg
operator|->
name|shm_perm
operator|.
name|cgid
operator|=
name|shmseg
operator|->
name|shm_perm
operator|.
name|gid
operator|=
name|cred
operator|->
name|cr_gid
expr_stmt|;
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|=
operator|(
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|&
name|SHMSEG_WANTED
operator|)
operator||
operator|(
name|mode
operator|&
name|ACCESSPERMS
operator|)
operator||
name|SHMSEG_ALLOCATED
expr_stmt|;
name|shmseg
operator|->
name|shm_segsz
operator|=
name|uap
operator|->
name|size
expr_stmt|;
name|shmseg
operator|->
name|shm_cpid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
name|shmseg
operator|->
name|shm_lpid
operator|=
name|shmseg
operator|->
name|shm_nattch
operator|=
literal|0
expr_stmt|;
name|shmseg
operator|->
name|shm_atime
operator|=
name|shmseg
operator|->
name|shm_dtime
operator|=
literal|0
expr_stmt|;
name|shmseg
operator|->
name|shm_ctime
operator|=
name|time_second
expr_stmt|;
name|shm_committed
operator|+=
name|btoc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|shm_nused
operator|++
expr_stmt|;
if|if
condition|(
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|&
name|SHMSEG_WANTED
condition|)
block|{
comment|/* 		 * Somebody else wanted this key while we were asleep.  Wake 		 * them up now. 		 */
name|shmseg
operator|->
name|shm_perm
operator|.
name|mode
operator|&=
operator|~
name|SHMSEG_WANTED
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|shmseg
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|shmid
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
name|int
name|shmget
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|shmget_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|segnum
decl_stmt|,
name|mode
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|jail_sysvipc_allowed
operator|&&
name|jailed
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|mode
operator|=
name|uap
operator|->
name|shmflg
operator|&
name|ACCESSPERMS
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|key
operator|!=
name|IPC_PRIVATE
condition|)
block|{
name|again
label|:
name|segnum
operator|=
name|shm_find_segment_by_key
argument_list|(
name|uap
operator|->
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|segnum
operator|>=
literal|0
condition|)
block|{
name|error
operator|=
name|shmget_existing
argument_list|(
name|td
argument_list|,
name|uap
argument_list|,
name|mode
argument_list|,
name|segnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EAGAIN
condition|)
goto|goto
name|again
goto|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
operator|(
name|uap
operator|->
name|shmflg
operator|&
name|IPC_CREAT
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
block|}
name|error
operator|=
name|shmget_allocate_segment
argument_list|(
name|td
argument_list|,
name|uap
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
name|int
name|shmsys
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
comment|/* XXX actually varargs. */
name|struct
name|shmsys_args
comment|/* { 		u_int	which; 		int	a2; 		int	a3; 		int	a4; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|jail_sysvipc_allowed
operator|&&
name|jailed
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|which
operator|>=
sizeof|sizeof
argument_list|(
name|shmcalls
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|shmcalls
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|shmcalls
index|[
name|uap
operator|->
name|which
index|]
call|)
argument_list|(
name|td
argument_list|,
operator|&
name|uap
operator|->
name|a2
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|shmfork_myhook
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|)
name|struct
name|proc
modifier|*
name|p1
decl_stmt|,
decl|*
name|p2
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|shmmap_state
modifier|*
name|shmmap_s
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size
operator|=
name|shminfo
operator|.
name|shmseg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|shmmap_state
argument_list|)
expr_stmt|;
name|shmmap_s
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_SHM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|p1
operator|->
name|p_vmspace
operator|->
name|vm_shm
argument_list|,
operator|(
name|caddr_t
operator|)
name|shmmap_s
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p2
operator|->
name|p_vmspace
operator|->
name|vm_shm
operator|=
operator|(
name|caddr_t
operator|)
name|shmmap_s
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmseg
condition|;
name|i
operator|++
operator|,
name|shmmap_s
operator|++
control|)
if|if
condition|(
name|shmmap_s
operator|->
name|shmid
operator|!=
operator|-
literal|1
condition|)
name|shmsegs
index|[
name|IPCID_TO_IX
argument_list|(
name|shmmap_s
operator|->
name|shmid
argument_list|)
index|]
operator|.
name|shm_nattch
operator|++
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|void
name|shmexit_myhook
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|shmmap_state
modifier|*
name|shmmap_s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|shmmap_s
operator|=
operator|(
expr|struct
name|shmmap_state
operator|*
operator|)
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmseg
condition|;
name|i
operator|++
operator|,
name|shmmap_s
operator|++
control|)
if|if
condition|(
name|shmmap_s
operator|->
name|shmid
operator|!=
operator|-
literal|1
condition|)
name|shm_delete_mapping
argument_list|(
name|p
argument_list|,
name|shmmap_s
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
argument_list|,
name|M_SHM
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_vmspace
operator|->
name|vm_shm
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|shmrealloc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|shmid_ds
modifier|*
name|newsegs
decl_stmt|;
if|if
condition|(
name|shmalloced
operator|>=
name|shminfo
operator|.
name|shmmni
condition|)
return|return;
name|newsegs
operator|=
name|malloc
argument_list|(
name|shminfo
operator|.
name|shmmni
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|newsegs
argument_list|)
argument_list|,
name|M_SHM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsegs
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shmalloced
condition|;
name|i
operator|++
control|)
name|bcopy
argument_list|(
operator|&
name|shmsegs
index|[
name|i
index|]
argument_list|,
operator|&
name|newsegs
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|newsegs
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|shminfo
operator|.
name|shmmni
condition|;
name|i
operator|++
control|)
block|{
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|mode
operator|=
name|SHMSEG_FREE
expr_stmt|;
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|seq
operator|=
literal|0
expr_stmt|;
block|}
name|free
argument_list|(
name|shmsegs
argument_list|,
name|M_SHM
argument_list|)
expr_stmt|;
name|shmsegs
operator|=
name|newsegs
expr_stmt|;
name|shmalloced
operator|=
name|shminfo
operator|.
name|shmmni
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|shminit
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.shmmaxpgs"
argument_list|,
operator|&
name|shminfo
operator|.
name|shmall
argument_list|)
expr_stmt|;
name|shminfo
operator|.
name|shmmax
operator|=
name|shminfo
operator|.
name|shmall
operator|*
name|PAGE_SIZE
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.shmmin"
argument_list|,
operator|&
name|shminfo
operator|.
name|shmmin
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.shmmni"
argument_list|,
operator|&
name|shminfo
operator|.
name|shmmni
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.shmseg"
argument_list|,
operator|&
name|shminfo
operator|.
name|shmseg
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.shm_use_phys"
argument_list|,
operator|&
name|shm_use_phys
argument_list|)
expr_stmt|;
name|shmalloced
operator|=
name|shminfo
operator|.
name|shmmni
expr_stmt|;
name|shmsegs
operator|=
name|malloc
argument_list|(
name|shmalloced
operator|*
sizeof|sizeof
argument_list|(
name|shmsegs
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|M_SHM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmsegs
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"cannot allocate initial memory for sysvshm"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shmalloced
condition|;
name|i
operator|++
control|)
block|{
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|mode
operator|=
name|SHMSEG_FREE
expr_stmt|;
name|shmsegs
index|[
name|i
index|]
operator|.
name|shm_perm
operator|.
name|seq
operator|=
literal|0
expr_stmt|;
block|}
name|shm_last_free
operator|=
literal|0
expr_stmt|;
name|shm_nused
operator|=
literal|0
expr_stmt|;
name|shm_committed
operator|=
literal|0
expr_stmt|;
name|shmexit_hook
operator|=
operator|&
name|shmexit_myhook
expr_stmt|;
name|shmfork_hook
operator|=
operator|&
name|shmfork_myhook
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|shmunload
parameter_list|()
block|{
if|if
condition|(
name|shm_nused
operator|>
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|free
argument_list|(
name|shmsegs
argument_list|,
name|M_SHM
argument_list|)
expr_stmt|;
name|shmexit_hook
operator|=
name|NULL
expr_stmt|;
name|shmfork_hook
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_shmsegs
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
return|return
operator|(
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|shmsegs
argument_list|,
name|shmalloced
operator|*
sizeof|sizeof
argument_list|(
name|shmsegs
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysvshm_modload
parameter_list|(
name|struct
name|module
modifier|*
name|module
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|shminit
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|error
operator|=
name|shmunload
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|sysvshm_mod
init|=
block|{
literal|"sysvshm"
block|,
operator|&
name|sysvshm_modload
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|shmsys
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|shmat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|shmctl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|shmdt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|shmget
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|sysvshm
argument_list|,
name|sysvshm_mod
argument_list|,
name|SI_SUB_SYSV_SHM
argument_list|,
name|SI_ORDER_FIRST
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|sysvshm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

