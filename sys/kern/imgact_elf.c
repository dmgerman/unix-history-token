begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 David O'Brien  * Copyright (c) 1995-1996 SÃ¸ren Schmidt  * Copyright (c) 1996 Peter Wemm  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software withough specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_rlimit.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact_elf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/pioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<machine/elf.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_define
define|#
directive|define
name|OLD_EI_BRAND
value|8
end_define

begin_expr_stmt
name|__ElfType
argument_list|(
name|Brandinfo
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__ElfType
argument_list|(
name|Auxargs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|elf_check_header
name|__P
argument_list|(
operator|(
specifier|const
name|Elf_Ehdr
operator|*
name|hdr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf_freebsd_fixup
name|__P
argument_list|(
operator|(
name|register_t
operator|*
operator|*
name|stack_base
operator|,
expr|struct
name|image_params
operator|*
name|imgp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf_load_file
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
name|p
operator|,
specifier|const
name|char
operator|*
name|file
operator|,
name|u_long
operator|*
name|addr
operator|,
name|u_long
operator|*
name|entry
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf_load_section
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
name|p
operator|,
expr|struct
name|vmspace
operator|*
name|vmspace
operator|,
expr|struct
name|vnode
operator|*
name|vp
operator|,
name|vm_offset_t
name|offset
operator|,
name|caddr_t
name|vmaddr
operator|,
name|size_t
name|memsz
operator|,
name|size_t
name|filsz
operator|,
name|vm_prot_t
name|prot
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|exec_elf_imgact
name|__P
argument_list|(
operator|(
expr|struct
name|image_params
operator|*
name|imgp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf_trace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|elf_trace
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|elf_trace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|sysentvec
name|elf_freebsd_sysvec
init|=
block|{
name|SYS_MAXSYSCALL
block|,
name|sysent
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|elf_freebsd_fixup
block|,
name|sendsig
block|,
name|sigcode
block|,
operator|&
name|szsigcode
block|,
literal|0
block|,
literal|"FreeBSD ELF"
block|,
name|elf_coredump
block|,
name|NULL
block|,
name|MINSIGSTKSZ
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf_Brandinfo
name|freebsd_brand_info
init|=
block|{
name|ELFOSABI_FREEBSD
block|,
literal|"FreeBSD"
block|,
literal|""
block|,
literal|"/usr/libexec/ld-elf.so.1"
block|,
operator|&
name|elf_freebsd_sysvec
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf_Brandinfo
modifier|*
name|elf_brand_list
index|[
name|MAX_BRANDS
index|]
init|=
block|{
operator|&
name|freebsd_brand_info
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|elf_insert_brand_entry
parameter_list|(
name|Elf_Brandinfo
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAX_BRANDS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|elf_brand_list
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|elf_brand_list
index|[
name|i
index|]
operator|=
name|entry
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|MAX_BRANDS
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|elf_remove_brand_entry
parameter_list|(
name|Elf_Brandinfo
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAX_BRANDS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|elf_brand_list
index|[
name|i
index|]
operator|==
name|entry
condition|)
block|{
name|elf_brand_list
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|MAX_BRANDS
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|elf_brand_inuse
parameter_list|(
name|Elf_Brandinfo
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|rval
init|=
name|FALSE
decl_stmt|;
name|sx_slock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&allproc
argument_list|,
argument|p_list
argument_list|)
block|{
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|==
name|entry
operator|->
name|sysvec
condition|)
block|{
name|rval
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
name|sx_sunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|elf_check_header
parameter_list|(
specifier|const
name|Elf_Ehdr
modifier|*
name|hdr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|IS_ELF
argument_list|(
operator|*
name|hdr
argument_list|)
operator|||
name|hdr
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|ELF_TARG_CLASS
operator|||
name|hdr
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
operator|!=
name|ELF_TARG_DATA
operator|||
name|hdr
operator|->
name|e_ident
index|[
name|EI_VERSION
index|]
operator|!=
name|EV_CURRENT
condition|)
return|return
name|ENOEXEC
return|;
if|if
condition|(
operator|!
name|ELF_MACHINE_OK
argument_list|(
name|hdr
operator|->
name|e_machine
argument_list|)
condition|)
return|return
name|ENOEXEC
return|;
if|if
condition|(
name|hdr
operator|->
name|e_version
operator|!=
name|ELF_TARG_VER
condition|)
return|return
name|ENOEXEC
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|elf_load_section
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|vmspace
modifier|*
name|vmspace
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|,
name|caddr_t
name|vmaddr
parameter_list|,
name|size_t
name|memsz
parameter_list|,
name|size_t
name|filsz
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|size_t
name|map_len
decl_stmt|;
name|vm_offset_t
name|map_addr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rv
decl_stmt|;
name|size_t
name|copy_len
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|vm_offset_t
name|file_addr
decl_stmt|;
name|vm_offset_t
name|data_buf
init|=
literal|0
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
name|VOP_GETVOBJECT
argument_list|(
name|vp
argument_list|,
operator|&
name|object
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * It's necessary to fail if the filsz + offset taken from the 	 * header is greater than the actual file pager object's size. 	 * If we were to allow this, then the vm_map_find() below would 	 * walk right off the end of the file object and into the ether. 	 * 	 * While I'm here, might as well check for something else that 	 * is invalid: filsz cannot be greater than memsz. 	 */
if|if
condition|(
operator|(
name|off_t
operator|)
name|filsz
operator|+
name|offset
operator|>
name|object
operator|->
name|un_pager
operator|.
name|vnp
operator|.
name|vnp_size
operator|||
name|filsz
operator|>
name|memsz
condition|)
block|{
name|uprintf
argument_list|(
literal|"elf_load_section: truncated ELF file\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOEXEC
operator|)
return|;
block|}
name|map_addr
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vmaddr
argument_list|)
expr_stmt|;
name|file_addr
operator|=
name|trunc_page
argument_list|(
name|offset
argument_list|)
expr_stmt|;
comment|/* 	 * We have two choices.  We can either clear the data in the last page 	 * of an oversized mapping, or we can start the anon mapping a page 	 * early and copy the initialized data into that first page.  We 	 * choose the second.. 	 */
if|if
condition|(
name|memsz
operator|>
name|filsz
condition|)
name|map_len
operator|=
name|trunc_page
argument_list|(
name|offset
operator|+
name|filsz
argument_list|)
operator|-
name|file_addr
expr_stmt|;
else|else
name|map_len
operator|=
name|round_page
argument_list|(
name|offset
operator|+
name|filsz
argument_list|)
operator|-
name|file_addr
expr_stmt|;
if|if
condition|(
name|map_len
operator|!=
literal|0
condition|)
block|{
name|vm_object_reference
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vm_map_lock
argument_list|(
operator|&
name|vmspace
operator|->
name|vm_map
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_map_insert
argument_list|(
operator|&
name|vmspace
operator|->
name|vm_map
argument_list|,
name|object
argument_list|,
name|file_addr
argument_list|,
comment|/* file offset */
name|map_addr
argument_list|,
comment|/* virtual start */
name|map_addr
operator|+
name|map_len
argument_list|,
comment|/* virtual end */
name|prot
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|MAP_COPY_ON_WRITE
operator||
name|MAP_PREFAULT
argument_list|)
expr_stmt|;
name|vm_map_unlock
argument_list|(
operator|&
name|vmspace
operator|->
name|vm_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|vm_object_deallocate
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* we can stop now if we've covered it all */
if|if
condition|(
name|memsz
operator|==
name|filsz
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
comment|/* 	 * We have to get the remaining bit of the file into the first part 	 * of the oversized map segment.  This is normally because the .data 	 * segment in the file is extended to provide bss.  It's a neat idea 	 * to try and save a page, but it's a pain in the behind to implement. 	 */
name|copy_len
operator|=
operator|(
name|offset
operator|+
name|filsz
operator|)
operator|-
name|trunc_page
argument_list|(
name|offset
operator|+
name|filsz
argument_list|)
expr_stmt|;
name|map_addr
operator|=
name|trunc_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vmaddr
operator|+
name|filsz
argument_list|)
expr_stmt|;
name|map_len
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vmaddr
operator|+
name|memsz
argument_list|)
operator|-
name|map_addr
expr_stmt|;
comment|/* This had damn well better be true! */
if|if
condition|(
name|map_len
operator|!=
literal|0
condition|)
block|{
name|vm_map_lock
argument_list|(
operator|&
name|vmspace
operator|->
name|vm_map
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_map_insert
argument_list|(
operator|&
name|vmspace
operator|->
name|vm_map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|map_addr
argument_list|,
name|map_addr
operator|+
name|map_len
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vm_map_unlock
argument_list|(
operator|&
name|vmspace
operator|->
name|vm_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
block|}
if|if
condition|(
name|copy_len
operator|!=
literal|0
condition|)
block|{
name|vm_object_reference
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_map_find
argument_list|(
name|exec_map
argument_list|,
name|object
argument_list|,
name|trunc_page
argument_list|(
name|offset
operator|+
name|filsz
argument_list|)
argument_list|,
operator|&
name|data_buf
argument_list|,
name|PAGE_SIZE
argument_list|,
name|TRUE
argument_list|,
name|VM_PROT_READ
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|MAP_COPY_ON_WRITE
operator||
name|MAP_PREFAULT_PARTIAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|vm_object_deallocate
argument_list|(
name|object
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* send the page fragment to user space */
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|data_buf
argument_list|,
operator|(
name|caddr_t
operator|)
name|map_addr
argument_list|,
name|copy_len
argument_list|)
expr_stmt|;
name|vm_map_remove
argument_list|(
name|exec_map
argument_list|,
name|data_buf
argument_list|,
name|data_buf
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * set it to the specified protection 	 */
name|vm_map_protect
argument_list|(
operator|&
name|vmspace
operator|->
name|vm_map
argument_list|,
name|map_addr
argument_list|,
name|map_addr
operator|+
name|map_len
argument_list|,
name|prot
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Load the file "file" into memory.  It may be either a shared object  * or an executable.  *  * The "addr" reference parameter is in/out.  On entry, it specifies  * the address where a shared object should be loaded.  If the file is  * an executable, this value is ignored.  On exit, "addr" specifies  * where the file was actually loaded.  *  * The "entry" reference parameter is out only.  On exit, it specifies  * the entry point for the loaded file.  */
end_comment

begin_function
specifier|static
name|int
name|elf_load_file
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|u_long
modifier|*
name|addr
parameter_list|,
name|u_long
modifier|*
name|entry
parameter_list|)
block|{
specifier|const
name|Elf_Ehdr
modifier|*
name|hdr
init|=
name|NULL
decl_stmt|;
specifier|const
name|Elf_Phdr
modifier|*
name|phdr
init|=
name|NULL
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vmspace
init|=
name|p
operator|->
name|p_vmspace
decl_stmt|;
name|struct
name|vattr
name|attr
decl_stmt|;
name|struct
name|image_params
name|image_params
decl_stmt|,
modifier|*
name|imgp
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|u_long
name|rbase
decl_stmt|;
name|u_long
name|base_addr
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|numsegs
decl_stmt|;
name|imgp
operator|=
operator|&
name|image_params
expr_stmt|;
comment|/* 	 * Initialize part of the common data 	 */
name|imgp
operator|->
name|proc
operator|=
name|p
expr_stmt|;
name|imgp
operator|->
name|uap
operator|=
name|NULL
expr_stmt|;
name|imgp
operator|->
name|attr
operator|=
operator|&
name|attr
expr_stmt|;
name|imgp
operator|->
name|firstpage
operator|=
name|NULL
expr_stmt|;
name|imgp
operator|->
name|image_header
operator|=
operator|(
name|char
operator|*
operator|)
name|kmem_alloc_wait
argument_list|(
name|exec_map
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|imgp
operator|->
name|image_header
operator|==
name|NULL
condition|)
block|{
name|nd
operator|.
name|ni_vp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|LOCKLEAF
operator||
name|FOLLOW
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|file
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|nd
operator|.
name|ni_vp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|imgp
operator|->
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
comment|/* 	 * Check permissions, modes, uid, etc on the file, and "open" it. 	 */
name|error
operator|=
name|exec_check_permissions
argument_list|(
name|imgp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|error
operator|=
name|exec_map_first_page
argument_list|(
name|imgp
argument_list|)
expr_stmt|;
comment|/* 	 * Also make certain that the interpreter stays the same, so set 	 * its VTEXT flag, too. 	 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|nd
operator|.
name|ni_vp
operator|->
name|v_flag
operator||=
name|VTEXT
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
literal|0
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
name|hdr
operator|=
operator|(
specifier|const
name|Elf_Ehdr
operator|*
operator|)
name|imgp
operator|->
name|image_header
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|elf_check_header
argument_list|(
name|hdr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|hdr
operator|->
name|e_type
operator|==
name|ET_DYN
condition|)
name|rbase
operator|=
operator|*
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|hdr
operator|->
name|e_type
operator|==
name|ET_EXEC
condition|)
name|rbase
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Only support headers that fit within first page for now */
if|if
condition|(
operator|(
name|hdr
operator|->
name|e_phoff
operator|>
name|PAGE_SIZE
operator|)
operator|||
operator|(
name|hdr
operator|->
name|e_phoff
operator|+
name|hdr
operator|->
name|e_phentsize
operator|*
name|hdr
operator|->
name|e_phnum
operator|)
operator|>
name|PAGE_SIZE
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|phdr
operator|=
operator|(
specifier|const
name|Elf_Phdr
operator|*
operator|)
operator|(
name|imgp
operator|->
name|image_header
operator|+
name|hdr
operator|->
name|e_phoff
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|numsegs
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|e_phnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_type
operator|==
name|PT_LOAD
condition|)
block|{
comment|/* Loadable segment */
name|prot
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_flags
operator|&
name|PF_X
condition|)
name|prot
operator||=
name|VM_PROT_EXECUTE
expr_stmt|;
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_flags
operator|&
name|PF_W
condition|)
name|prot
operator||=
name|VM_PROT_WRITE
expr_stmt|;
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_flags
operator|&
name|PF_R
condition|)
name|prot
operator||=
name|VM_PROT_READ
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|elf_load_section
argument_list|(
name|p
argument_list|,
name|vmspace
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_offset
argument_list|,
operator|(
name|caddr_t
operator|)
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|+
name|rbase
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_filesz
argument_list|,
name|prot
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* 			 * Establish the base address if this is the 			 * first segment. 			 */
if|if
condition|(
name|numsegs
operator|==
literal|0
condition|)
name|base_addr
operator|=
name|trunc_page
argument_list|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|+
name|rbase
argument_list|)
expr_stmt|;
name|numsegs
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|addr
operator|=
name|base_addr
expr_stmt|;
operator|*
name|entry
operator|=
operator|(
name|unsigned
name|long
operator|)
name|hdr
operator|->
name|e_entry
operator|+
name|rbase
expr_stmt|;
name|fail
label|:
if|if
condition|(
name|imgp
operator|->
name|firstpage
condition|)
name|exec_unmap_first_page
argument_list|(
name|imgp
argument_list|)
expr_stmt|;
if|if
condition|(
name|imgp
operator|->
name|image_header
condition|)
name|kmem_free_wakeup
argument_list|(
name|exec_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|imgp
operator|->
name|image_header
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|.
name|ni_vp
condition|)
name|vrele
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * non static, as it can be overridden by start_init()  */
end_comment

begin_decl_stmt
name|int
name|fallback_elf_brand
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|fallback_elf_brand
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|fallback_elf_brand
argument_list|,
operator|-
literal|1
argument_list|,
literal|"ELF brand of last resort"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|exec_elf_imgact
parameter_list|(
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|)
block|{
specifier|const
name|Elf_Ehdr
modifier|*
name|hdr
init|=
operator|(
specifier|const
name|Elf_Ehdr
operator|*
operator|)
name|imgp
operator|->
name|image_header
decl_stmt|;
specifier|const
name|Elf_Phdr
modifier|*
name|phdr
decl_stmt|;
name|Elf_Auxargs
modifier|*
name|elf_auxargs
init|=
name|NULL
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vmspace
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|u_long
name|text_size
init|=
literal|0
decl_stmt|,
name|data_size
init|=
literal|0
decl_stmt|;
name|u_long
name|text_addr
init|=
literal|0
decl_stmt|,
name|data_addr
init|=
literal|0
decl_stmt|;
name|u_long
name|addr
decl_stmt|,
name|entry
init|=
literal|0
decl_stmt|,
name|proghdr
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|interp
init|=
name|NULL
decl_stmt|;
name|Elf_Brandinfo
modifier|*
name|brand_info
decl_stmt|;
name|char
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
comment|/* 	 * Do we have a valid ELF header ? 	 */
if|if
condition|(
name|elf_check_header
argument_list|(
name|hdr
argument_list|)
operator|!=
literal|0
operator|||
name|hdr
operator|->
name|e_type
operator|!=
name|ET_EXEC
condition|)
return|return
operator|-
literal|1
return|;
comment|/* 	 * From here on down, we return an errno, not -1, as we've 	 * detected an ELF file. 	 */
if|if
condition|(
operator|(
name|hdr
operator|->
name|e_phoff
operator|>
name|PAGE_SIZE
operator|)
operator|||
operator|(
name|hdr
operator|->
name|e_phoff
operator|+
name|hdr
operator|->
name|e_phentsize
operator|*
name|hdr
operator|->
name|e_phnum
operator|)
operator|>
name|PAGE_SIZE
condition|)
block|{
comment|/* Only support headers in first page for now */
return|return
name|ENOEXEC
return|;
block|}
name|phdr
operator|=
operator|(
specifier|const
name|Elf_Phdr
operator|*
operator|)
operator|(
name|imgp
operator|->
name|image_header
operator|+
name|hdr
operator|->
name|e_phoff
operator|)
expr_stmt|;
comment|/* 	 * From this point on, we may have resources that need to be freed. 	 */
comment|/* 	 * Yeah, I'm paranoid.  There is every reason in the world to get 	 * VTEXT now since from here on out, there are places we can have 	 * a context switch.  Better safe than sorry; I really don't want 	 * the file to change while it's being loaded. 	 */
name|mtx_lock
argument_list|(
operator|&
name|imgp
operator|->
name|vp
operator|->
name|v_interlock
argument_list|)
expr_stmt|;
name|imgp
operator|->
name|vp
operator|->
name|v_flag
operator||=
name|VTEXT
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|imgp
operator|->
name|vp
operator|->
name|v_interlock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|exec_extract_strings
argument_list|(
name|imgp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
name|exec_new_vmspace
argument_list|(
name|imgp
argument_list|)
expr_stmt|;
name|vmspace
operator|=
name|imgp
operator|->
name|proc
operator|->
name|p_vmspace
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|e_phnum
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_type
condition|)
block|{
case|case
name|PT_LOAD
case|:
comment|/* Loadable segment */
name|prot
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_flags
operator|&
name|PF_X
condition|)
name|prot
operator||=
name|VM_PROT_EXECUTE
expr_stmt|;
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_flags
operator|&
name|PF_W
condition|)
name|prot
operator||=
name|VM_PROT_WRITE
expr_stmt|;
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_flags
operator|&
name|PF_R
condition|)
name|prot
operator||=
name|VM_PROT_READ
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|elf_load_section
argument_list|(
name|imgp
operator|->
name|proc
argument_list|,
name|vmspace
argument_list|,
name|imgp
operator|->
name|vp
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_offset
argument_list|,
operator|(
name|caddr_t
operator|)
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_filesz
argument_list|,
name|prot
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* 			 * Is this .text or .data ?? 			 * 			 * We only handle one each of those yet XXX 			 */
if|if
condition|(
name|hdr
operator|->
name|e_entry
operator|>=
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|&&
name|hdr
operator|->
name|e_entry
operator|<
operator|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|+
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
operator|)
condition|)
block|{
name|text_addr
operator|=
name|trunc_page
argument_list|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
argument_list|)
expr_stmt|;
name|text_size
operator|=
name|round_page
argument_list|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
operator|+
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|-
name|text_addr
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
name|u_long
operator|)
name|hdr
operator|->
name|e_entry
expr_stmt|;
block|}
else|else
block|{
name|data_addr
operator|=
name|trunc_page
argument_list|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
argument_list|)
expr_stmt|;
name|data_size
operator|=
name|round_page
argument_list|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
operator|+
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|-
name|data_addr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PT_INTERP
case|:
comment|/* Path to interpreter */
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_filesz
operator|>
name|MAXPATHLEN
operator|||
name|phdr
index|[
name|i
index|]
operator|.
name|p_offset
operator|+
name|phdr
index|[
name|i
index|]
operator|.
name|p_filesz
operator|>
name|PAGE_SIZE
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|interp
operator|=
name|imgp
operator|->
name|image_header
operator|+
name|phdr
index|[
name|i
index|]
operator|.
name|p_offset
expr_stmt|;
break|break;
case|case
name|PT_PHDR
case|:
comment|/* Program header table info */
name|proghdr
operator|=
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|vmspace
operator|->
name|vm_tsize
operator|=
name|text_size
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|vmspace
operator|->
name|vm_taddr
operator|=
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|text_addr
expr_stmt|;
name|vmspace
operator|->
name|vm_dsize
operator|=
name|data_size
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|vmspace
operator|->
name|vm_daddr
operator|=
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|data_addr
expr_stmt|;
name|addr
operator|=
name|ELF_RTLD_ADDR
argument_list|(
name|vmspace
argument_list|)
expr_stmt|;
name|imgp
operator|->
name|entry_addr
operator|=
name|entry
expr_stmt|;
name|brand_info
operator|=
name|NULL
expr_stmt|;
comment|/* We support three types of branding -- (1) the ELF EI_OSABI field 	 * that SCO added to the ELF spec, (2) FreeBSD 3.x's traditional string 	 * branding w/in the ELF header, and (3) path of the `interp_path' 	 * field.  We should also look for an ".note.ABI-tag" ELF section now 	 * in all Linux ELF binaries, FreeBSD 4.1+, and some NetBSD ones. 	 */
comment|/* If the executable has a brand, search for it in the brand list. */
if|if
condition|(
name|brand_info
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_BRANDS
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Brandinfo
modifier|*
name|bi
init|=
name|elf_brand_list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|bi
operator|!=
name|NULL
operator|&&
operator|(
name|hdr
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|==
name|bi
operator|->
name|brand
operator|||
literal|0
operator|==
name|strncmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|hdr
operator|->
name|e_ident
index|[
name|OLD_EI_BRAND
index|]
argument_list|,
name|bi
operator|->
name|compat_3_brand
argument_list|,
name|strlen
argument_list|(
name|bi
operator|->
name|compat_3_brand
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|brand_info
operator|=
name|bi
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Lacking a known brand, search for a recognized interpreter. */
if|if
condition|(
name|brand_info
operator|==
name|NULL
operator|&&
name|interp
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_BRANDS
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Brandinfo
modifier|*
name|bi
init|=
name|elf_brand_list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|bi
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|interp
argument_list|,
name|bi
operator|->
name|interp_path
argument_list|)
operator|==
literal|0
condition|)
block|{
name|brand_info
operator|=
name|bi
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Lacking a recognized interpreter, try the default brand */
if|if
condition|(
name|brand_info
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_BRANDS
condition|;
name|i
operator|++
control|)
block|{
name|Elf_Brandinfo
modifier|*
name|bi
init|=
name|elf_brand_list
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|bi
operator|!=
name|NULL
operator|&&
name|fallback_elf_brand
operator|==
name|bi
operator|->
name|brand
condition|)
block|{
name|brand_info
operator|=
name|bi
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|brand_info
operator|==
name|NULL
condition|)
block|{
name|uprintf
argument_list|(
literal|"ELF binary type \"%u\" not known.\n"
argument_list|,
name|hdr
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|imgp
operator|->
name|proc
operator|->
name|p_sysent
operator|=
name|brand_info
operator|->
name|sysvec
expr_stmt|;
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|path
argument_list|,
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|brand_info
operator|->
name|emul_path
argument_list|,
name|interp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|elf_load_file
argument_list|(
name|imgp
operator|->
name|proc
argument_list|,
name|path
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|imgp
operator|->
name|entry_addr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|elf_load_file
argument_list|(
name|imgp
operator|->
name|proc
argument_list|,
name|interp
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|imgp
operator|->
name|entry_addr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|uprintf
argument_list|(
literal|"ELF interpreter %s not found\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
block|}
comment|/* 	 * Construct auxargs table (used by the fixup routine) 	 */
name|elf_auxargs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Elf_Auxargs
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|elf_auxargs
operator|->
name|execfd
operator|=
operator|-
literal|1
expr_stmt|;
name|elf_auxargs
operator|->
name|phdr
operator|=
name|proghdr
expr_stmt|;
name|elf_auxargs
operator|->
name|phent
operator|=
name|hdr
operator|->
name|e_phentsize
expr_stmt|;
name|elf_auxargs
operator|->
name|phnum
operator|=
name|hdr
operator|->
name|e_phnum
expr_stmt|;
name|elf_auxargs
operator|->
name|pagesz
operator|=
name|PAGE_SIZE
expr_stmt|;
name|elf_auxargs
operator|->
name|base
operator|=
name|addr
expr_stmt|;
name|elf_auxargs
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|elf_auxargs
operator|->
name|entry
operator|=
name|entry
expr_stmt|;
name|elf_auxargs
operator|->
name|trace
operator|=
name|elf_trace
expr_stmt|;
name|imgp
operator|->
name|auxargs
operator|=
name|elf_auxargs
expr_stmt|;
name|imgp
operator|->
name|interpreted
operator|=
literal|0
expr_stmt|;
name|fail
label|:
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|elf_freebsd_fixup
parameter_list|(
name|register_t
modifier|*
modifier|*
name|stack_base
parameter_list|,
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|)
block|{
name|Elf_Auxargs
modifier|*
name|args
init|=
operator|(
name|Elf_Auxargs
operator|*
operator|)
name|imgp
operator|->
name|auxargs
decl_stmt|;
name|register_t
modifier|*
name|pos
decl_stmt|;
name|pos
operator|=
operator|*
name|stack_base
operator|+
operator|(
name|imgp
operator|->
name|argc
operator|+
name|imgp
operator|->
name|envc
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|trace
condition|)
block|{
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_DEBUG
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|->
name|execfd
operator|!=
operator|-
literal|1
condition|)
block|{
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_EXECFD
argument_list|,
name|args
operator|->
name|execfd
argument_list|)
expr_stmt|;
block|}
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_PHDR
argument_list|,
name|args
operator|->
name|phdr
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_PHENT
argument_list|,
name|args
operator|->
name|phent
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_PHNUM
argument_list|,
name|args
operator|->
name|phnum
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_PAGESZ
argument_list|,
name|args
operator|->
name|pagesz
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_FLAGS
argument_list|,
name|args
operator|->
name|flags
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_ENTRY
argument_list|,
name|args
operator|->
name|entry
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_BASE
argument_list|,
name|args
operator|->
name|base
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|imgp
operator|->
name|auxargs
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|imgp
operator|->
name|auxargs
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|stack_base
operator|)
operator|--
expr_stmt|;
name|suword
argument_list|(
operator|*
name|stack_base
argument_list|,
operator|(
name|long
operator|)
name|imgp
operator|->
name|argc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Code for generating ELF core dumps.  */
end_comment

begin_typedef
typedef|typedef
name|void
argument_list|(
argument|*segment_callback
argument_list|)
name|__P
argument_list|(
operator|(
name|vm_map_entry_t
operator|,
name|void
operator|*
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_comment
comment|/* Closure for cb_put_phdr(). */
end_comment

begin_struct
struct|struct
name|phdr_closure
block|{
name|Elf_Phdr
modifier|*
name|phdr
decl_stmt|;
comment|/* Program header to fill in */
name|Elf_Off
name|offset
decl_stmt|;
comment|/* Offset of segment in core file */
block|}
struct|;
end_struct

begin_comment
comment|/* Closure for cb_size_segment(). */
end_comment

begin_struct
struct|struct
name|sseg_closure
block|{
name|int
name|count
decl_stmt|;
comment|/* Count of writable segments. */
name|size_t
name|size
decl_stmt|;
comment|/* Total size of all writable segments. */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|cb_put_phdr
name|__P
argument_list|(
operator|(
name|vm_map_entry_t
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cb_size_segment
name|__P
argument_list|(
operator|(
name|vm_map_entry_t
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|each_writable_segment
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|,
name|segment_callback
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf_corehdr
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|,
expr|struct
name|vnode
operator|*
operator|,
expr|struct
name|ucred
operator|*
operator|,
name|int
operator|,
name|void
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_puthdr
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|,
name|void
operator|*
operator|,
name|size_t
operator|*
operator|,
specifier|const
name|prstatus_t
operator|*
operator|,
specifier|const
name|prfpregset_t
operator|*
operator|,
specifier|const
name|prpsinfo_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|elf_putnote
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|size_t
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
specifier|const
name|void
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|osreldate
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|elf_coredump
parameter_list|(
name|p
parameter_list|,
name|vp
parameter_list|,
name|limit
parameter_list|)
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|off_t
name|limit
decl_stmt|;
block|{
specifier|register
name|struct
name|ucred
modifier|*
name|cred
init|=
name|p
operator|->
name|p_ucred
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|sseg_closure
name|seginfo
decl_stmt|;
name|void
modifier|*
name|hdr
decl_stmt|;
name|size_t
name|hdrsize
decl_stmt|;
comment|/* Size the program segments. */
name|seginfo
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|seginfo
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|each_writable_segment
argument_list|(
name|p
argument_list|,
name|cb_size_segment
argument_list|,
operator|&
name|seginfo
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the size of the core file header area by making 	 * a dry run of generating it.  Nothing is written, but the 	 * size is calculated. 	 */
name|hdrsize
operator|=
literal|0
expr_stmt|;
name|elf_puthdr
argument_list|(
operator|(
expr|struct
name|proc
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|hdrsize
argument_list|,
operator|(
specifier|const
name|prstatus_t
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|prfpregset_t
operator|*
operator|)
name|NULL
argument_list|,
operator|(
specifier|const
name|prpsinfo_t
operator|*
operator|)
name|NULL
argument_list|,
name|seginfo
operator|.
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdrsize
operator|+
name|seginfo
operator|.
name|size
operator|>=
name|limit
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* 	 * Allocate memory for building the header, fill it up, 	 * and write it out. 	 */
name|hdr
operator|=
name|malloc
argument_list|(
name|hdrsize
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
operator|==
name|NULL
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
name|error
operator|=
name|elf_corehdr
argument_list|(
name|p
argument_list|,
name|vp
argument_list|,
name|cred
argument_list|,
name|seginfo
operator|.
name|count
argument_list|,
name|hdr
argument_list|,
name|hdrsize
argument_list|)
expr_stmt|;
comment|/* Write the contents of all of the writable segments. */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|Elf_Phdr
modifier|*
name|php
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|php
operator|=
operator|(
name|Elf_Phdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|hdr
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Ehdr
argument_list|)
operator|)
operator|+
literal|1
expr_stmt|;
name|offset
operator|=
name|hdrsize
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seginfo
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_WRITE
argument_list|,
name|vp
argument_list|,
operator|(
name|caddr_t
operator|)
name|php
operator|->
name|p_vaddr
argument_list|,
name|php
operator|->
name|p_filesz
argument_list|,
name|offset
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|IO_NODELOCKED
operator||
name|IO_UNIT
argument_list|,
name|cred
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|offset
operator|+=
name|php
operator|->
name|p_filesz
expr_stmt|;
name|php
operator|++
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|hdr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * A callback for each_writable_segment() to write out the segment's  * program header entry.  */
end_comment

begin_function
specifier|static
name|void
name|cb_put_phdr
parameter_list|(
name|entry
parameter_list|,
name|closure
parameter_list|)
name|vm_map_entry_t
name|entry
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|phdr_closure
modifier|*
name|phc
init|=
operator|(
expr|struct
name|phdr_closure
operator|*
operator|)
name|closure
decl_stmt|;
name|Elf_Phdr
modifier|*
name|phdr
init|=
name|phc
operator|->
name|phdr
decl_stmt|;
name|phc
operator|->
name|offset
operator|=
name|round_page
argument_list|(
name|phc
operator|->
name|offset
argument_list|)
expr_stmt|;
name|phdr
operator|->
name|p_type
operator|=
name|PT_LOAD
expr_stmt|;
name|phdr
operator|->
name|p_offset
operator|=
name|phc
operator|->
name|offset
expr_stmt|;
name|phdr
operator|->
name|p_vaddr
operator|=
name|entry
operator|->
name|start
expr_stmt|;
name|phdr
operator|->
name|p_paddr
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_filesz
operator|=
name|phdr
operator|->
name|p_memsz
operator|=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
name|phdr
operator|->
name|p_align
operator|=
name|PAGE_SIZE
expr_stmt|;
name|phdr
operator|->
name|p_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|protection
operator|&
name|VM_PROT_READ
condition|)
name|phdr
operator|->
name|p_flags
operator||=
name|PF_R
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|protection
operator|&
name|VM_PROT_WRITE
condition|)
name|phdr
operator|->
name|p_flags
operator||=
name|PF_W
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|protection
operator|&
name|VM_PROT_EXECUTE
condition|)
name|phdr
operator|->
name|p_flags
operator||=
name|PF_X
expr_stmt|;
name|phc
operator|->
name|offset
operator|+=
name|phdr
operator|->
name|p_filesz
expr_stmt|;
name|phc
operator|->
name|phdr
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A callback for each_writable_segment() to gather information about  * the number of segments and their total size.  */
end_comment

begin_function
specifier|static
name|void
name|cb_size_segment
parameter_list|(
name|entry
parameter_list|,
name|closure
parameter_list|)
name|vm_map_entry_t
name|entry
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|sseg_closure
modifier|*
name|ssc
init|=
operator|(
expr|struct
name|sseg_closure
operator|*
operator|)
name|closure
decl_stmt|;
name|ssc
operator|->
name|count
operator|++
expr_stmt|;
name|ssc
operator|->
name|size
operator|+=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * For each writable segment in the process's memory map, call the given  * function with a pointer to the map entry and some arbitrary  * caller-supplied data.  */
end_comment

begin_function
specifier|static
name|void
name|each_writable_segment
parameter_list|(
name|p
parameter_list|,
name|func
parameter_list|,
name|closure
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|segment_callback
name|func
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|vm_map_t
name|map
init|=
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
for|for
control|(
name|entry
operator|=
name|map
operator|->
name|header
operator|.
name|next
init|;
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
name|vm_object_t
name|obj
decl_stmt|;
if|if
condition|(
operator|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_IS_SUB_MAP
operator|)
operator|||
operator|(
name|entry
operator|->
name|protection
operator|&
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
operator|)
operator|)
operator|!=
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
operator|)
condition|)
continue|continue;
comment|/* 		** Dont include memory segment in the coredump if 		** MAP_NOCORE is set in mmap(2) or MADV_NOCORE in 		** madvise(2). 		*/
if|if
condition|(
name|entry
operator|->
name|eflags
operator|&
name|MAP_ENTRY_NOCOREDUMP
condition|)
continue|continue;
if|if
condition|(
operator|(
name|obj
operator|=
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Find the deepest backing object. */
while|while
condition|(
name|obj
operator|->
name|backing_object
operator|!=
name|NULL
condition|)
name|obj
operator|=
name|obj
operator|->
name|backing_object
expr_stmt|;
comment|/* Ignore memory-mapped devices and such things. */
if|if
condition|(
name|obj
operator|->
name|type
operator|!=
name|OBJT_DEFAULT
operator|&&
name|obj
operator|->
name|type
operator|!=
name|OBJT_SWAP
operator|&&
name|obj
operator|->
name|type
operator|!=
name|OBJT_VNODE
condition|)
continue|continue;
call|(
modifier|*
name|func
call|)
argument_list|(
name|entry
argument_list|,
name|closure
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Write the core file header to the file, including padding up to  * the page boundary.  */
end_comment

begin_function
specifier|static
name|int
name|elf_corehdr
parameter_list|(
name|p
parameter_list|,
name|vp
parameter_list|,
name|cred
parameter_list|,
name|numsegs
parameter_list|,
name|hdr
parameter_list|,
name|hdrsize
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|int
name|numsegs
decl_stmt|;
name|size_t
name|hdrsize
decl_stmt|;
name|void
modifier|*
name|hdr
decl_stmt|;
block|{
name|size_t
name|off
decl_stmt|;
name|prstatus_t
name|status
decl_stmt|;
name|prfpregset_t
name|fpregset
decl_stmt|;
name|prpsinfo_t
name|psinfo
decl_stmt|;
comment|/* Gather the information for the header. */
name|bzero
argument_list|(
operator|&
name|status
argument_list|,
sizeof|sizeof
name|status
argument_list|)
expr_stmt|;
name|status
operator|.
name|pr_version
operator|=
name|PRSTATUS_VERSION
expr_stmt|;
name|status
operator|.
name|pr_statussz
operator|=
sizeof|sizeof
argument_list|(
name|prstatus_t
argument_list|)
expr_stmt|;
name|status
operator|.
name|pr_gregsetsz
operator|=
sizeof|sizeof
argument_list|(
name|gregset_t
argument_list|)
expr_stmt|;
name|status
operator|.
name|pr_fpregsetsz
operator|=
sizeof|sizeof
argument_list|(
name|fpregset_t
argument_list|)
expr_stmt|;
name|status
operator|.
name|pr_osreldate
operator|=
name|osreldate
expr_stmt|;
name|status
operator|.
name|pr_cursig
operator|=
name|p
operator|->
name|p_sig
expr_stmt|;
name|status
operator|.
name|pr_pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|fill_regs
argument_list|(
name|p
argument_list|,
operator|&
name|status
operator|.
name|pr_reg
argument_list|)
expr_stmt|;
name|fill_fpregs
argument_list|(
name|p
argument_list|,
operator|&
name|fpregset
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|psinfo
argument_list|,
sizeof|sizeof
name|psinfo
argument_list|)
expr_stmt|;
name|psinfo
operator|.
name|pr_version
operator|=
name|PRPSINFO_VERSION
expr_stmt|;
name|psinfo
operator|.
name|pr_psinfosz
operator|=
sizeof|sizeof
argument_list|(
name|prpsinfo_t
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|psinfo
operator|.
name|pr_fname
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|MAXCOMLEN
argument_list|)
expr_stmt|;
comment|/* XXX - We don't fill in the command line arguments properly yet. */
name|strncpy
argument_list|(
name|psinfo
operator|.
name|pr_psargs
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|PRARGSZ
argument_list|)
expr_stmt|;
comment|/* Fill in the header. */
name|bzero
argument_list|(
name|hdr
argument_list|,
name|hdrsize
argument_list|)
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|elf_puthdr
argument_list|(
name|p
argument_list|,
name|hdr
argument_list|,
operator|&
name|off
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|fpregset
argument_list|,
operator|&
name|psinfo
argument_list|,
name|numsegs
argument_list|)
expr_stmt|;
comment|/* Write it to the core file. */
return|return
name|vn_rdwr
argument_list|(
name|UIO_WRITE
argument_list|,
name|vp
argument_list|,
name|hdr
argument_list|,
name|hdrsize
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
operator||
name|IO_UNIT
argument_list|,
name|cred
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf_puthdr
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
modifier|*
name|off
parameter_list|,
specifier|const
name|prstatus_t
modifier|*
name|status
parameter_list|,
specifier|const
name|prfpregset_t
modifier|*
name|fpregset
parameter_list|,
specifier|const
name|prpsinfo_t
modifier|*
name|psinfo
parameter_list|,
name|int
name|numsegs
parameter_list|)
block|{
name|size_t
name|ehoff
decl_stmt|;
name|size_t
name|phoff
decl_stmt|;
name|size_t
name|noteoff
decl_stmt|;
name|size_t
name|notesz
decl_stmt|;
name|ehoff
operator|=
operator|*
name|off
expr_stmt|;
operator|*
name|off
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_Ehdr
argument_list|)
expr_stmt|;
name|phoff
operator|=
operator|*
name|off
expr_stmt|;
operator|*
name|off
operator|+=
operator|(
name|numsegs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Phdr
argument_list|)
expr_stmt|;
name|noteoff
operator|=
operator|*
name|off
expr_stmt|;
name|elf_putnote
argument_list|(
name|dst
argument_list|,
name|off
argument_list|,
literal|"FreeBSD"
argument_list|,
name|NT_PRSTATUS
argument_list|,
name|status
argument_list|,
sizeof|sizeof
expr|*
name|status
argument_list|)
expr_stmt|;
name|elf_putnote
argument_list|(
name|dst
argument_list|,
name|off
argument_list|,
literal|"FreeBSD"
argument_list|,
name|NT_FPREGSET
argument_list|,
name|fpregset
argument_list|,
sizeof|sizeof
expr|*
name|fpregset
argument_list|)
expr_stmt|;
name|elf_putnote
argument_list|(
name|dst
argument_list|,
name|off
argument_list|,
literal|"FreeBSD"
argument_list|,
name|NT_PRPSINFO
argument_list|,
name|psinfo
argument_list|,
sizeof|sizeof
expr|*
name|psinfo
argument_list|)
expr_stmt|;
name|notesz
operator|=
operator|*
name|off
operator|-
name|noteoff
expr_stmt|;
comment|/* Align up to a page boundary for the program segments. */
operator|*
name|off
operator|=
name|round_page
argument_list|(
operator|*
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
block|{
name|Elf_Ehdr
modifier|*
name|ehdr
decl_stmt|;
name|Elf_Phdr
modifier|*
name|phdr
decl_stmt|;
name|struct
name|phdr_closure
name|phc
decl_stmt|;
comment|/* 		 * Fill in the ELF header. 		 */
name|ehdr
operator|=
operator|(
name|Elf_Ehdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
name|ehoff
operator|)
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_MAG0
index|]
operator|=
name|ELFMAG0
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_MAG1
index|]
operator|=
name|ELFMAG1
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_MAG2
index|]
operator|=
name|ELFMAG2
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_MAG3
index|]
operator|=
name|ELFMAG3
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|=
name|ELF_CLASS
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
operator|=
name|ELF_DATA
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_VERSION
index|]
operator|=
name|EV_CURRENT
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|=
name|ELFOSABI_FREEBSD
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_ABIVERSION
index|]
operator|=
literal|0
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_PAD
index|]
operator|=
literal|0
expr_stmt|;
name|ehdr
operator|->
name|e_type
operator|=
name|ET_CORE
expr_stmt|;
name|ehdr
operator|->
name|e_machine
operator|=
name|ELF_ARCH
expr_stmt|;
name|ehdr
operator|->
name|e_version
operator|=
name|EV_CURRENT
expr_stmt|;
name|ehdr
operator|->
name|e_entry
operator|=
literal|0
expr_stmt|;
name|ehdr
operator|->
name|e_phoff
operator|=
name|phoff
expr_stmt|;
name|ehdr
operator|->
name|e_flags
operator|=
literal|0
expr_stmt|;
name|ehdr
operator|->
name|e_ehsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Ehdr
argument_list|)
expr_stmt|;
name|ehdr
operator|->
name|e_phentsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Phdr
argument_list|)
expr_stmt|;
name|ehdr
operator|->
name|e_phnum
operator|=
name|numsegs
operator|+
literal|1
expr_stmt|;
name|ehdr
operator|->
name|e_shentsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Shdr
argument_list|)
expr_stmt|;
name|ehdr
operator|->
name|e_shnum
operator|=
literal|0
expr_stmt|;
name|ehdr
operator|->
name|e_shstrndx
operator|=
name|SHN_UNDEF
expr_stmt|;
comment|/* 		 * Fill in the program header entries. 		 */
name|phdr
operator|=
operator|(
name|Elf_Phdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
name|phoff
operator|)
expr_stmt|;
comment|/* The note segement. */
name|phdr
operator|->
name|p_type
operator|=
name|PT_NOTE
expr_stmt|;
name|phdr
operator|->
name|p_offset
operator|=
name|noteoff
expr_stmt|;
name|phdr
operator|->
name|p_vaddr
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_paddr
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_filesz
operator|=
name|notesz
expr_stmt|;
name|phdr
operator|->
name|p_memsz
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_flags
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_align
operator|=
literal|0
expr_stmt|;
name|phdr
operator|++
expr_stmt|;
comment|/* All the writable segments from the program. */
name|phc
operator|.
name|phdr
operator|=
name|phdr
expr_stmt|;
name|phc
operator|.
name|offset
operator|=
operator|*
name|off
expr_stmt|;
name|each_writable_segment
argument_list|(
name|p
argument_list|,
name|cb_put_phdr
argument_list|,
operator|&
name|phc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elf_putnote
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
modifier|*
name|off
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|void
modifier|*
name|desc
parameter_list|,
name|size_t
name|descsz
parameter_list|)
block|{
name|Elf_Note
name|note
decl_stmt|;
name|note
operator|.
name|n_namesz
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|note
operator|.
name|n_descsz
operator|=
name|descsz
expr_stmt|;
name|note
operator|.
name|n_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
operator|&
name|note
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
operator|*
name|off
argument_list|,
sizeof|sizeof
name|note
argument_list|)
expr_stmt|;
operator|*
name|off
operator|+=
sizeof|sizeof
name|note
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
operator|*
name|off
argument_list|,
name|note
operator|.
name|n_namesz
argument_list|)
expr_stmt|;
operator|*
name|off
operator|+=
name|roundup2
argument_list|(
name|note
operator|.
name|n_namesz
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|desc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
operator|*
name|off
argument_list|,
name|note
operator|.
name|n_descsz
argument_list|)
expr_stmt|;
operator|*
name|off
operator|+=
name|roundup2
argument_list|(
name|note
operator|.
name|n_descsz
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Size
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Tell kern_execve.c about it, with a little help from the linker.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|execsw
name|elf_execsw
init|=
block|{
name|exec_elf_imgact
block|,
literal|"ELF"
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|EXEC_SET
argument_list|(
name|elf
argument_list|,
name|elf_execsw
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

