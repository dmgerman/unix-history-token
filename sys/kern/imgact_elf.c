begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1995-1996 SÃ¸ren Schmidt  * Copyright (c) 1996 Peter Wemm  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software withough specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *	$Id: imgact_elf.c,v 1.10 1996/10/16 17:51:05 sos Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact_elf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/lock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_prot.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<i386/linux/linux_syscall.h>
end_include

begin_include
include|#
directive|include
file|<i386/linux/linux.h>
end_include

begin_define
define|#
directive|define
name|MAX_PHDR
value|32
end_define

begin_comment
comment|/* XXX enough ? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|map_pages
name|__P
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
name|vp
operator|,
name|vm_offset_t
name|offset
operator|,
name|vm_offset_t
operator|*
name|buf
operator|,
name|vm_size_t
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unmap_pages
name|__P
argument_list|(
operator|(
name|vm_offset_t
name|buf
operator|,
name|vm_size_t
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf_check_permissions
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
name|p
operator|,
expr|struct
name|vnode
operator|*
name|vp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf_check_header
name|__P
argument_list|(
operator|(
specifier|const
name|Elf32_Ehdr
operator|*
name|hdr
operator|,
name|int
name|type
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf_load_section
name|__P
argument_list|(
operator|(
expr|struct
name|vmspace
operator|*
name|vmspace
operator|,
expr|struct
name|vnode
operator|*
name|vp
operator|,
name|vm_offset_t
name|offset
operator|,
name|caddr_t
name|vmaddr
operator|,
name|size_t
name|memsz
operator|,
name|size_t
name|filsz
operator|,
name|vm_prot_t
name|prot
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf_load_file
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
name|p
operator|,
name|char
operator|*
name|file
operator|,
name|u_long
operator|*
name|addr
operator|,
name|u_long
operator|*
name|entry
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf_freebsd_fixup
name|__P
argument_list|(
operator|(
name|int
operator|*
operator|*
name|stack_base
operator|,
expr|struct
name|image_params
operator|*
name|imgp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|exec_elf_imgact
name|__P
argument_list|(
operator|(
expr|struct
name|image_params
operator|*
name|imgp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|elf_trace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
literal|1
argument_list|,
name|elf_trace
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|elf_trace
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|UPRINTF
value|if (elf_trace) uprintf
end_define

begin_decl_stmt
specifier|static
name|struct
name|sysentvec
name|elf_freebsd_sysvec
init|=
block|{
name|SYS_MAXSYSCALL
block|,
name|sysent
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|elf_freebsd_fixup
block|,
name|sendsig
block|,
name|sigcode
block|,
operator|&
name|szsigcode
block|,
literal|0
block|,
literal|"FreeBSD ELF"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf32_Brandinfo
name|freebsd_brand_info
init|=
block|{
literal|"FreeBSD"
block|,
literal|""
block|,
literal|"/usr/libexec/ld-elf.so.1"
block|,
operator|&
name|elf_freebsd_sysvec
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Elf32_Brandinfo
modifier|*
name|elf_brand_list
index|[
name|MAX_BRANDS
index|]
init|=
block|{
operator|&
name|freebsd_brand_info
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|elf_insert_brand_entry
parameter_list|(
name|Elf32_Brandinfo
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAX_BRANDS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|elf_brand_list
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|elf_brand_list
index|[
name|i
index|]
operator|=
name|entry
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|MAX_BRANDS
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|elf_remove_brand_entry
parameter_list|(
name|Elf32_Brandinfo
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MAX_BRANDS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|elf_brand_list
index|[
name|i
index|]
operator|==
name|entry
condition|)
block|{
name|elf_brand_list
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|MAX_BRANDS
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|map_pages
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|,
name|vm_offset_t
modifier|*
name|buf
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|vm_offset_t
name|kern_buf
decl_stmt|;
name|vm_size_t
name|pageoff
decl_stmt|;
comment|/* 	 * The request may not be aligned, and may even cross several 	 * page boundaries in the file... 	 */
name|pageoff
operator|=
operator|(
name|offset
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
name|offset
operator|-=
name|pageoff
expr_stmt|;
comment|/* start of first aligned page to map */
name|size
operator|+=
name|pageoff
expr_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* size of aligned pages to map */
if|if
condition|(
name|error
operator|=
name|vm_mmap
argument_list|(
name|kernel_map
argument_list|,
operator|&
name|kern_buf
argument_list|,
name|size
argument_list|,
name|VM_PROT_READ
argument_list|,
name|VM_PROT_READ
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
name|vp
argument_list|,
name|offset
argument_list|)
condition|)
return|return
name|error
return|;
operator|*
name|buf
operator|=
name|kern_buf
operator|+
name|pageoff
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unmap_pages
parameter_list|(
name|vm_offset_t
name|buf
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|vm_size_t
name|pageoff
decl_stmt|;
name|pageoff
operator|=
operator|(
name|buf
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
name|buf
operator|-=
name|pageoff
expr_stmt|;
comment|/* start of first aligned page to map */
name|size
operator|+=
name|pageoff
expr_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* size of aligned pages to map */
name|vm_map_remove
argument_list|(
name|kernel_map
argument_list|,
name|buf
argument_list|,
name|buf
operator|+
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|elf_check_permissions
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
block|{
name|struct
name|vattr
name|attr
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Check number of open-for-writes on the file and deny execution 	 *	if there are any. 	 */
if|if
condition|(
name|vp
operator|->
name|v_writecount
condition|)
block|{
return|return
operator|(
name|ETXTBSY
operator|)
return|;
block|}
comment|/* Get file attributes */
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|attr
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * 1) Check if file execution is disabled for the filesystem that this 	 *	file resides on. 	 * 2) Insure that at least one execute bit is on - otherwise root 	 *	will always succeed, and we don't want to happen unless the 	 *	file really is executable. 	 * 3) Insure that the file is a regular file. 	 */
if|if
condition|(
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_NOEXEC
operator|)
operator|||
operator|(
operator|(
name|attr
operator|.
name|va_mode
operator|&
literal|0111
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|attr
operator|.
name|va_type
operator|!=
name|VREG
operator|)
condition|)
block|{
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
comment|/* 	 * Zero length files can't be exec'd 	 */
if|if
condition|(
name|attr
operator|.
name|va_size
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOEXEC
operator|)
return|;
comment|/* 	 *  Check for execute permission to file based on current credentials. 	 *	Then call filesystem specific open routine (which does nothing 	 *	in the general case). 	 */
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VEXEC
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|vp
argument_list|,
name|FREAD
argument_list|,
name|p
operator|->
name|p_ucred
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|elf_check_header
parameter_list|(
specifier|const
name|Elf32_Ehdr
modifier|*
name|hdr
parameter_list|,
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|hdr
operator|->
name|e_ident
index|[
name|EI_MAG0
index|]
operator|==
name|ELFMAG0
operator|&&
name|hdr
operator|->
name|e_ident
index|[
name|EI_MAG1
index|]
operator|==
name|ELFMAG1
operator|&&
name|hdr
operator|->
name|e_ident
index|[
name|EI_MAG2
index|]
operator|==
name|ELFMAG2
operator|&&
name|hdr
operator|->
name|e_ident
index|[
name|EI_MAG3
index|]
operator|==
name|ELFMAG3
operator|)
condition|)
return|return
name|ENOEXEC
return|;
if|if
condition|(
name|hdr
operator|->
name|e_machine
operator|!=
name|EM_386
operator|&&
name|hdr
operator|->
name|e_machine
operator|!=
name|EM_486
condition|)
return|return
name|ENOEXEC
return|;
if|if
condition|(
name|hdr
operator|->
name|e_type
operator|!=
name|type
condition|)
return|return
name|ENOEXEC
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|elf_load_section
parameter_list|(
name|struct
name|vmspace
modifier|*
name|vmspace
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|vm_offset_t
name|offset
parameter_list|,
name|caddr_t
name|vmaddr
parameter_list|,
name|size_t
name|memsz
parameter_list|,
name|size_t
name|filsz
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|size_t
name|map_len
decl_stmt|;
name|vm_offset_t
name|map_addr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unsigned
name|char
modifier|*
name|data_buf
init|=
literal|0
decl_stmt|;
name|size_t
name|copy_len
decl_stmt|;
name|map_addr
operator|=
name|trunc_page
argument_list|(
name|vmaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|memsz
operator|>
name|filsz
condition|)
name|map_len
operator|=
name|trunc_page
argument_list|(
name|offset
operator|+
name|filsz
argument_list|)
operator|-
name|trunc_page
argument_list|(
name|offset
argument_list|)
expr_stmt|;
else|else
name|map_len
operator|=
name|round_page
argument_list|(
name|offset
operator|+
name|filsz
argument_list|)
operator|-
name|trunc_page
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|vm_mmap
argument_list|(
operator|&
name|vmspace
operator|->
name|vm_map
argument_list|,
operator|&
name|map_addr
argument_list|,
name|map_len
argument_list|,
name|prot
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_FIXED
argument_list|,
operator|(
name|caddr_t
operator|)
name|vp
argument_list|,
name|trunc_page
argument_list|(
name|offset
argument_list|)
argument_list|)
condition|)
return|return
name|error
return|;
if|if
condition|(
name|memsz
operator|==
name|filsz
condition|)
return|return
literal|0
return|;
comment|/* 	 * We have to map the remaining bit of the file into the kernel's 	 * memory map, allocate some anonymous memory, and copy that last 	 * bit into it. The remaining space should be .bss... 	 */
name|copy_len
operator|=
operator|(
name|offset
operator|+
name|filsz
operator|)
operator|-
name|trunc_page
argument_list|(
name|offset
operator|+
name|filsz
argument_list|)
expr_stmt|;
name|map_addr
operator|=
name|trunc_page
argument_list|(
name|vmaddr
operator|+
name|filsz
argument_list|)
expr_stmt|;
name|map_len
operator|=
name|round_page
argument_list|(
name|vmaddr
operator|+
name|memsz
argument_list|)
operator|-
name|map_addr
expr_stmt|;
if|if
condition|(
name|map_len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|vm_map_find
argument_list|(
operator|&
name|vmspace
operator|->
name|vm_map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|map_addr
argument_list|,
name|map_len
argument_list|,
name|FALSE
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|error
return|;
block|}
if|if
condition|(
name|error
operator|=
name|vm_mmap
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|data_buf
argument_list|,
name|PAGE_SIZE
argument_list|,
name|VM_PROT_READ
argument_list|,
name|VM_PROT_READ
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
name|vp
argument_list|,
name|trunc_page
argument_list|(
name|offset
operator|+
name|filsz
argument_list|)
argument_list|)
condition|)
return|return
name|error
return|;
name|error
operator|=
name|copyout
argument_list|(
name|data_buf
argument_list|,
operator|(
name|caddr_t
operator|)
name|map_addr
argument_list|,
name|copy_len
argument_list|)
expr_stmt|;
name|vm_map_remove
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|data_buf
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|data_buf
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* 	 * set it to the specified protection 	 */
name|vm_map_protect
argument_list|(
operator|&
name|vmspace
operator|->
name|vm_map
argument_list|,
name|map_addr
argument_list|,
name|map_addr
operator|+
name|map_len
argument_list|,
name|prot
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|UPRINTF
argument_list|(
literal|"bss size %d (%x)\n"
argument_list|,
name|map_len
operator|-
name|copy_len
argument_list|,
name|map_len
operator|-
name|copy_len
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|elf_load_file
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|file
parameter_list|,
name|u_long
modifier|*
name|addr
parameter_list|,
name|u_long
modifier|*
name|entry
parameter_list|)
block|{
name|Elf32_Ehdr
modifier|*
name|hdr
init|=
name|NULL
decl_stmt|;
name|Elf32_Phdr
modifier|*
name|phdr
init|=
name|NULL
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vmspace
init|=
name|p
operator|->
name|p_vmspace
decl_stmt|;
name|vm_prot_t
name|prot
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|text_size
init|=
literal|0
decl_stmt|,
name|data_size
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|text_addr
init|=
literal|0
decl_stmt|,
name|data_addr
init|=
literal|0
decl_stmt|;
name|int
name|header_size
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|LOCKLEAF
operator||
name|FOLLOW
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|file
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|nd
operator|.
name|ni_vp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* 	 * Check permissions, modes, uid, etc on the file, and "open" it. 	 */
name|error
operator|=
name|elf_check_permissions
argument_list|(
name|p
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
comment|/* 	 * No longer need this, and it prevents demand paging. 	 */
name|VOP_UNLOCK
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Map in the header 	 */
if|if
condition|(
name|error
operator|=
name|map_pages
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
literal|0
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Do we have a valid ELF header ? 	 */
if|if
condition|(
name|error
operator|=
name|elf_check_header
argument_list|(
name|hdr
argument_list|,
name|ET_DYN
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * ouch, need to bounds check in case user gives us a corrupted 	 * file with an insane header size 	 */
if|if
condition|(
name|hdr
operator|->
name|e_phnum
operator|>
name|MAX_PHDR
condition|)
block|{
comment|/* XXX: ever more than this? */
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|header_size
operator|=
name|hdr
operator|->
name|e_phentsize
operator|*
name|hdr
operator|->
name|e_phnum
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|map_pages
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
name|hdr
operator|->
name|e_phoff
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|phdr
argument_list|,
name|header_size
argument_list|)
condition|)
goto|goto
name|fail
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|e_phnum
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_type
condition|)
block|{
case|case
name|PT_NULL
case|:
comment|/* NULL section */
name|UPRINTF
argument_list|(
literal|"ELF(file) PT_NULL section\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_LOAD
case|:
comment|/* Loadable segment */
block|{
name|UPRINTF
argument_list|(
literal|"ELF(file) PT_LOAD section "
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_flags
operator|&
name|PF_X
condition|)
name|prot
operator||=
name|VM_PROT_EXECUTE
expr_stmt|;
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_flags
operator|&
name|PF_W
condition|)
name|prot
operator||=
name|VM_PROT_WRITE
expr_stmt|;
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_flags
operator|&
name|PF_R
condition|)
name|prot
operator||=
name|VM_PROT_READ
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|elf_load_section
argument_list|(
name|vmspace
argument_list|,
name|nd
operator|.
name|ni_vp
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_offset
argument_list|,
operator|(
name|caddr_t
operator|)
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|+
operator|(
operator|*
name|addr
operator|)
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_filesz
argument_list|,
name|prot
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* 			 * Is this .text or .data ?? 			 * 			 * We only handle one each of those yet XXX 			 */
if|if
condition|(
name|hdr
operator|->
name|e_entry
operator|>=
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|&&
name|hdr
operator|->
name|e_entry
operator|<
operator|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|+
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
operator|)
condition|)
block|{
name|text_addr
operator|=
name|trunc_page
argument_list|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|+
operator|(
operator|*
name|addr
operator|)
argument_list|)
expr_stmt|;
name|text_size
operator|=
name|round_page
argument_list|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
operator|+
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|-
name|trunc_page
argument_list|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|entry
operator|=
operator|(
name|unsigned
name|long
operator|)
name|hdr
operator|->
name|e_entry
operator|+
operator|(
operator|*
name|addr
operator|)
expr_stmt|;
name|UPRINTF
argument_list|(
literal|".text<%08x,%08x> entry=%08x\n"
argument_list|,
name|text_addr
argument_list|,
name|text_size
argument_list|,
operator|*
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data_addr
operator|=
name|trunc_page
argument_list|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|+
operator|(
operator|*
name|addr
operator|)
argument_list|)
expr_stmt|;
name|data_size
operator|=
name|round_page
argument_list|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
operator|+
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|-
name|trunc_page
argument_list|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
argument_list|)
argument_list|)
expr_stmt|;
name|UPRINTF
argument_list|(
literal|".data<%08x,%08x>\n"
argument_list|,
name|data_addr
argument_list|,
name|data_size
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PT_DYNAMIC
case|:
comment|/* Dynamic link information */
name|UPRINTF
argument_list|(
literal|"ELF(file) PT_DYNAMIC section\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_INTERP
case|:
comment|/* Path to interpreter */
name|UPRINTF
argument_list|(
literal|"ELF(file) PT_INTERP section\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_NOTE
case|:
comment|/* Note section */
name|UPRINTF
argument_list|(
literal|"ELF(file) PT_NOTE section\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_SHLIB
case|:
comment|/* Shared lib section  */
name|UPRINTF
argument_list|(
literal|"ELF(file) PT_SHLIB section\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_PHDR
case|:
comment|/* Program header table info */
name|UPRINTF
argument_list|(
literal|"ELF(file) PT_PHDR section\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|UPRINTF
argument_list|(
literal|"ELF(file) %d section ??\n"
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_type
argument_list|)
expr_stmt|;
block|}
block|}
name|fail
label|:
if|if
condition|(
name|phdr
condition|)
name|unmap_pages
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|phdr
argument_list|,
name|header_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdr
condition|)
name|unmap_pages
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|exec_elf_imgact
parameter_list|(
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|)
block|{
specifier|const
name|Elf32_Ehdr
modifier|*
name|hdr
init|=
operator|(
specifier|const
name|Elf32_Ehdr
operator|*
operator|)
name|imgp
operator|->
name|image_header
decl_stmt|;
specifier|const
name|Elf32_Phdr
modifier|*
name|phdr
decl_stmt|,
modifier|*
name|mapped_phdr
init|=
name|NULL
decl_stmt|;
name|Elf32_Auxargs
modifier|*
name|elf_auxargs
init|=
name|NULL
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vmspace
init|=
name|imgp
operator|->
name|proc
operator|->
name|p_vmspace
decl_stmt|;
name|vm_prot_t
name|prot
init|=
literal|0
decl_stmt|;
name|u_long
name|text_size
init|=
literal|0
decl_stmt|,
name|data_size
init|=
literal|0
decl_stmt|;
name|u_long
name|text_addr
init|=
literal|0
decl_stmt|,
name|data_addr
init|=
literal|0
decl_stmt|;
name|u_long
name|addr
decl_stmt|,
name|entry
init|=
literal|0
decl_stmt|,
name|proghdr
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|header_size
init|=
literal|0
decl_stmt|,
name|interp_len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|interp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|brand
init|=
name|NULL
decl_stmt|;
name|char
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
comment|/* 	 * Do we have a valid ELF header ? 	 */
if|if
condition|(
name|elf_check_header
argument_list|(
name|hdr
argument_list|,
name|ET_EXEC
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* 	 * From here on down, we return an errno, not -1, as we've 	 * detected an ELF file. 	 */
comment|/* 	 * ouch, need to bounds check in case user gives us a corrupted 	 * file with an insane header size 	 */
if|if
condition|(
name|hdr
operator|->
name|e_phnum
operator|>
name|MAX_PHDR
condition|)
block|{
comment|/* XXX: ever more than this? */
return|return
name|ENOEXEC
return|;
block|}
name|header_size
operator|=
name|hdr
operator|->
name|e_phentsize
operator|*
name|hdr
operator|->
name|e_phnum
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|e_phoff
operator|>
name|PAGE_SIZE
operator|)
operator|||
operator|(
name|hdr
operator|->
name|e_phoff
operator|+
name|header_size
operator|)
operator|>
name|PAGE_SIZE
condition|)
block|{
comment|/* 		 * Ouch ! we only get one page full of header... 		 * Try to map it in ourselves, and see how we go. 	   	 */
if|if
condition|(
name|error
operator|=
name|map_pages
argument_list|(
name|imgp
operator|->
name|vp
argument_list|,
name|hdr
operator|->
name|e_phoff
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|mapped_phdr
argument_list|,
name|header_size
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * Save manual mapping for cleanup 		 */
name|phdr
operator|=
name|mapped_phdr
expr_stmt|;
block|}
else|else
block|{
name|phdr
operator|=
operator|(
specifier|const
name|Elf32_Phdr
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|imgp
operator|->
name|image_header
operator|+
name|hdr
operator|->
name|e_phoff
operator|)
expr_stmt|;
block|}
comment|/* 	 * From this point on, we may have resources that need to be freed. 	 */
if|if
condition|(
name|error
operator|=
name|exec_extract_strings
argument_list|(
name|imgp
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|exec_new_vmspace
argument_list|(
name|imgp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|e_phnum
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_type
condition|)
block|{
case|case
name|PT_NULL
case|:
comment|/* NULL section */
name|UPRINTF
argument_list|(
literal|"ELF PT_NULL section\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_LOAD
case|:
comment|/* Loadable segment */
block|{
name|UPRINTF
argument_list|(
literal|"ELF PT_LOAD section "
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_flags
operator|&
name|PF_X
condition|)
name|prot
operator||=
name|VM_PROT_EXECUTE
expr_stmt|;
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_flags
operator|&
name|PF_W
condition|)
name|prot
operator||=
name|VM_PROT_WRITE
expr_stmt|;
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_flags
operator|&
name|PF_R
condition|)
name|prot
operator||=
name|VM_PROT_READ
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|elf_load_section
argument_list|(
name|vmspace
argument_list|,
name|imgp
operator|->
name|vp
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_offset
argument_list|,
operator|(
name|caddr_t
operator|)
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_filesz
argument_list|,
name|prot
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* 			 * Is this .text or .data ?? 			 * 			 * We only handle one each of those yet XXX 			 */
if|if
condition|(
name|hdr
operator|->
name|e_entry
operator|>=
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|&&
name|hdr
operator|->
name|e_entry
operator|<
operator|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|+
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
operator|)
condition|)
block|{
name|text_addr
operator|=
name|trunc_page
argument_list|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
argument_list|)
expr_stmt|;
name|text_size
operator|=
name|round_page
argument_list|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
operator|+
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|-
name|text_addr
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
name|u_long
operator|)
name|hdr
operator|->
name|e_entry
expr_stmt|;
name|UPRINTF
argument_list|(
literal|".text<%08x,%08x> entry=%08x\n"
argument_list|,
name|text_addr
argument_list|,
name|text_size
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data_addr
operator|=
name|trunc_page
argument_list|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
argument_list|)
expr_stmt|;
name|data_size
operator|=
name|round_page
argument_list|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
operator|+
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|-
name|data_addr
argument_list|)
expr_stmt|;
name|UPRINTF
argument_list|(
literal|".data<%08x,%08x>\n"
argument_list|,
name|data_addr
argument_list|,
name|data_size
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PT_DYNAMIC
case|:
comment|/* Dynamic link information */
name|UPRINTF
argument_list|(
literal|"ELF PT_DYNAMIC section ??\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_INTERP
case|:
comment|/* Path to interpreter */
name|UPRINTF
argument_list|(
literal|"ELF PT_INTERP section "
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_filesz
operator|>
name|MAXPATHLEN
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|interp_len
operator|=
name|MAXPATHLEN
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|map_pages
argument_list|(
name|imgp
operator|->
name|vp
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_offset
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|interp
argument_list|,
name|interp_len
argument_list|)
condition|)
goto|goto
name|fail
goto|;
name|UPRINTF
argument_list|(
literal|"<%s>\n"
argument_list|,
name|interp
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_NOTE
case|:
comment|/* Note section */
name|UPRINTF
argument_list|(
literal|"ELF PT_NOTE section\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_SHLIB
case|:
comment|/* Shared lib section  */
name|UPRINTF
argument_list|(
literal|"ELF PT_SHLIB section\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_PHDR
case|:
comment|/* Program header table info */
name|UPRINTF
argument_list|(
literal|"ELF PT_PHDR section<%x>\n"
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
argument_list|)
expr_stmt|;
name|proghdr
operator|=
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
expr_stmt|;
break|break;
default|default:
name|UPRINTF
argument_list|(
literal|"ELF %d section ??\n"
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_type
argument_list|)
expr_stmt|;
block|}
block|}
name|vmspace
operator|->
name|vm_tsize
operator|=
name|text_size
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|vmspace
operator|->
name|vm_taddr
operator|=
operator|(
name|caddr_t
operator|)
name|text_addr
expr_stmt|;
name|vmspace
operator|->
name|vm_dsize
operator|=
name|data_size
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|vmspace
operator|->
name|vm_daddr
operator|=
operator|(
name|caddr_t
operator|)
name|data_addr
expr_stmt|;
name|addr
operator|=
literal|2
operator|*
name|MAXDSIZ
expr_stmt|;
comment|/* May depend on OS type XXX */
name|imgp
operator|->
name|entry_addr
operator|=
name|entry
expr_stmt|;
comment|/*  	 * So which kind (brand) of ELF binary do we have at hand 	 * FreeBSD, Linux, SVR4 or something else ?? 	 * If its has a interpreter section try that first 	 */
if|if
condition|(
name|interp
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_BRANDS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|elf_brand_list
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|interp
argument_list|,
name|elf_brand_list
index|[
name|i
index|]
operator|->
name|interp_path
argument_list|)
condition|)
block|{
name|imgp
operator|->
name|proc
operator|->
name|p_sysent
operator|=
name|elf_brand_list
index|[
name|i
index|]
operator|->
name|sysvec
expr_stmt|;
name|strcpy
argument_list|(
name|path
argument_list|,
name|elf_brand_list
index|[
name|i
index|]
operator|->
name|emul_path
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
name|elf_brand_list
index|[
name|i
index|]
operator|->
name|interp_path
argument_list|)
expr_stmt|;
name|UPRINTF
argument_list|(
literal|"interpreter=<%s> %s\n"
argument_list|,
name|elf_brand_list
index|[
name|i
index|]
operator|->
name|interp_path
argument_list|,
name|elf_brand_list
index|[
name|i
index|]
operator|->
name|emul_path
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* 	 * If there is no interpreter, or recognition of it 	 * failed, se if the binary is branded. 	 */
if|if
condition|(
operator|!
name|interp
operator|||
name|i
operator|==
name|MAX_BRANDS
condition|)
block|{
name|brand
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|hdr
operator|->
name|e_ident
index|[
name|EI_BRAND
index|]
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_BRANDS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|elf_brand_list
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|brand
argument_list|,
name|elf_brand_list
index|[
name|i
index|]
operator|->
name|brand
argument_list|)
condition|)
block|{
name|imgp
operator|->
name|proc
operator|->
name|p_sysent
operator|=
name|elf_brand_list
index|[
name|i
index|]
operator|->
name|sysvec
expr_stmt|;
if|if
condition|(
name|interp
condition|)
block|{
name|strcpy
argument_list|(
name|path
argument_list|,
name|elf_brand_list
index|[
name|i
index|]
operator|->
name|emul_path
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|path
argument_list|,
name|elf_brand_list
index|[
name|i
index|]
operator|->
name|interp_path
argument_list|)
expr_stmt|;
name|UPRINTF
argument_list|(
literal|"interpreter=<%s> %s\n"
argument_list|,
name|elf_brand_list
index|[
name|i
index|]
operator|->
name|interp_path
argument_list|,
name|elf_brand_list
index|[
name|i
index|]
operator|->
name|emul_path
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
name|i
operator|==
name|MAX_BRANDS
condition|)
block|{
name|uprintf
argument_list|(
literal|"ELF binary type not known\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|interp
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|elf_load_file
argument_list|(
name|imgp
operator|->
name|proc
argument_list|,
name|path
argument_list|,
operator|&
name|addr
argument_list|,
comment|/* XXX */
operator|&
name|imgp
operator|->
name|entry_addr
argument_list|)
condition|)
block|{
name|uprintf
argument_list|(
literal|"ELF interpreter %s not found\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
name|UPRINTF
argument_list|(
literal|"Executing %s binary\n"
argument_list|,
name|elf_brand_list
index|[
name|i
index|]
operator|->
name|brand
argument_list|)
expr_stmt|;
comment|/* 	 * Construct auxargs table (used by the fixup routine) 	 */
name|elf_auxargs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Elf32_Auxargs
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|elf_auxargs
operator|->
name|execfd
operator|=
operator|-
literal|1
expr_stmt|;
name|elf_auxargs
operator|->
name|phdr
operator|=
name|proghdr
expr_stmt|;
name|elf_auxargs
operator|->
name|phent
operator|=
name|hdr
operator|->
name|e_phentsize
expr_stmt|;
name|elf_auxargs
operator|->
name|phnum
operator|=
name|hdr
operator|->
name|e_phnum
expr_stmt|;
name|elf_auxargs
operator|->
name|pagesz
operator|=
name|PAGE_SIZE
expr_stmt|;
name|elf_auxargs
operator|->
name|base
operator|=
name|addr
expr_stmt|;
name|elf_auxargs
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|elf_auxargs
operator|->
name|entry
operator|=
name|entry
expr_stmt|;
name|elf_auxargs
operator|->
name|trace
operator|=
name|elf_trace
expr_stmt|;
name|imgp
operator|->
name|auxargs
operator|=
name|elf_auxargs
expr_stmt|;
name|imgp
operator|->
name|interpreted
operator|=
literal|0
expr_stmt|;
comment|/* don't allow modifying the file while we run it */
name|imgp
operator|->
name|vp
operator|->
name|v_flag
operator||=
name|VTEXT
expr_stmt|;
name|fail
label|:
if|if
condition|(
name|mapped_phdr
condition|)
name|unmap_pages
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|mapped_phdr
argument_list|,
name|header_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp
condition|)
name|unmap_pages
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|interp
argument_list|,
name|interp_len
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|elf_freebsd_fixup
parameter_list|(
name|int
modifier|*
modifier|*
name|stack_base
parameter_list|,
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|)
block|{
name|Elf32_Auxargs
modifier|*
name|args
init|=
operator|(
name|Elf32_Auxargs
operator|*
operator|)
name|imgp
operator|->
name|auxargs
decl_stmt|;
name|int
modifier|*
name|pos
decl_stmt|;
name|pos
operator|=
operator|*
name|stack_base
operator|+
operator|(
name|imgp
operator|->
name|argc
operator|+
name|imgp
operator|->
name|envc
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|trace
condition|)
block|{
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_DEBUG
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|->
name|execfd
operator|!=
operator|-
literal|1
condition|)
block|{
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_EXECFD
argument_list|,
name|args
operator|->
name|execfd
argument_list|)
expr_stmt|;
block|}
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_PHDR
argument_list|,
name|args
operator|->
name|phdr
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_PHENT
argument_list|,
name|args
operator|->
name|phent
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_PHNUM
argument_list|,
name|args
operator|->
name|phnum
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_PAGESZ
argument_list|,
name|args
operator|->
name|pagesz
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_FLAGS
argument_list|,
name|args
operator|->
name|flags
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_ENTRY
argument_list|,
name|args
operator|->
name|entry
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_BASE
argument_list|,
name|args
operator|->
name|base
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|imgp
operator|->
name|auxargs
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|imgp
operator|->
name|auxargs
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|stack_base
operator|)
operator|--
expr_stmt|;
operator|*
operator|*
name|stack_base
operator|=
operator|(
name|int
operator|)
name|imgp
operator|->
name|argc
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Tell kern_execve.c about it, with a little help from the linker.  * Since `const' objects end up in the text segment, TEXT_SET is the  * correct directive to use.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|execsw
name|elf_execsw
init|=
block|{
name|exec_elf_imgact
block|,
literal|"ELF"
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TEXT_SET
argument_list|(
name|execsw_set
argument_list|,
name|elf_execsw
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

