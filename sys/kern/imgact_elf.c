begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 David O'Brien  * Copyright (c) 1995-1996 SÃ¸ren Schmidt  * Copyright (c) 1996 Peter Wemm  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_capsicum.h"
end_include

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_gzio.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/capsicum.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/gzio.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact_elf.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/pioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/racct.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sf_buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<machine/elf.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_define
define|#
directive|define
name|ELF_NOTE_ROUNDSIZE
value|4
end_define

begin_define
define|#
directive|define
name|OLD_EI_BRAND
value|8
end_define

begin_function_decl
specifier|static
name|int
name|__elfN
function_decl|(
name|check_header
function_decl|)
parameter_list|(
specifier|const
name|Elf_Ehdr
modifier|*
name|hdr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Elf_Brandinfo
modifier|*
name|__elfN
function_decl|(
name|get_brandinfo
function_decl|)
parameter_list|(
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|,
specifier|const
name|char
modifier|*
name|interp
parameter_list|,
name|int
name|interp_name_len
parameter_list|,
name|int32_t
modifier|*
name|osrel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|__elfN
function_decl|(
name|load_file
function_decl|)
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|u_long
modifier|*
name|addr
parameter_list|,
name|u_long
modifier|*
name|entry
parameter_list|,
name|size_t
name|pagesize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|__elfN
function_decl|(
name|load_section
function_decl|)
parameter_list|(
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|caddr_t
name|vmaddr
parameter_list|,
name|size_t
name|memsz
parameter_list|,
name|size_t
name|filsz
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|size_t
name|pagesize
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|__CONCAT
argument_list|(
name|exec_
argument_list|,
name|__elfN
argument_list|(
name|imgact
argument_list|)
argument_list|)
argument_list|(
expr|struct
name|image_params
operator|*
name|imgp
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|boolean_t
name|__elfN
function_decl|(
name|freebsd_trans_osrel
function_decl|)
parameter_list|(
specifier|const
name|Elf_Note
modifier|*
name|note
parameter_list|,
name|int32_t
modifier|*
name|osrel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|kfreebsd_trans_osrel
parameter_list|(
specifier|const
name|Elf_Note
modifier|*
name|note
parameter_list|,
name|int32_t
modifier|*
name|osrel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|__elfN
function_decl|(
name|check_note
function_decl|)
parameter_list|(
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|,
name|Elf_Brandnote
modifier|*
name|checknote
parameter_list|,
name|int32_t
modifier|*
name|osrel
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_prot_t
name|__elfN
function_decl|(
name|trans_prot
function_decl|)
parameter_list|(
name|Elf_Word
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Elf_Word
name|__elfN
function_decl|(
name|untrans_prot
function_decl|)
parameter_list|(
name|vm_prot_t
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|__CONCAT
argument_list|(
name|elf
argument_list|,
name|__ELF_WORD_SIZE
argument_list|)
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|CORE_BUF_SIZE
value|(16 * 1024)
end_define

begin_function_decl
name|int
name|__elfN
parameter_list|(
name|fallback_brand
parameter_list|)
init|=
operator|-
literal|1
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|__CONCAT
argument_list|(
name|_kern_elf
argument_list|,
name|__ELF_WORD_SIZE
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|fallback_brand
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|__elfN
argument_list|(
name|fallback_brand
argument_list|)
argument_list|,
literal|0
argument_list|,
name|__XSTRING
argument_list|(
name|__CONCAT
argument_list|(
name|ELF
argument_list|,
name|__ELF_WORD_SIZE
argument_list|)
argument_list|)
literal|" brand of last resort"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|elf_legacy_coredump
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|__elfN
argument_list|(
name|legacy_coredump
argument_list|)
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|elf_legacy_coredump
argument_list|,
literal|0
argument_list|,
literal|"include all and only RW pages in core dumps"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
name|int
name|__elfN
parameter_list|(
name|nxstack
parameter_list|)
init|=
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__powerpc64__
argument_list|)
comment|/* both 64 and 32 bit */
operator|||
expr|\
operator|(
name|defined
argument_list|(
name|__arm__
argument_list|)
operator|&&
name|__ARM_ARCH
operator|>=
literal|7
operator|)
operator|||
name|defined
argument_list|(
name|__aarch64__
argument_list|)
literal|1
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_expr_stmt
literal|0
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|__CONCAT
argument_list|(
name|_kern_elf
argument_list|,
name|__ELF_WORD_SIZE
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|nxstack
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|__elfN
argument_list|(
name|nxstack
argument_list|)
argument_list|,
literal|0
argument_list|,
name|__XSTRING
argument_list|(
name|__CONCAT
argument_list|(
name|ELF
argument_list|,
name|__ELF_WORD_SIZE
argument_list|)
argument_list|)
literal|": enable non-executable stack"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|__ELF_WORD_SIZE
operator|==
literal|32
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
end_if

begin_decl_stmt
name|int
name|i386_read_exec
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_elf32
argument_list|,
name|OID_AUTO
argument_list|,
name|read_exec
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|i386_read_exec
argument_list|,
literal|0
argument_list|,
literal|"enable execution from readable segments"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|Elf_Brandinfo
modifier|*
name|elf_brand_list
index|[
name|MAX_BRANDS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|trunc_page_ps
parameter_list|(
name|va
parameter_list|,
name|ps
parameter_list|)
value|rounddown2(va, ps)
end_define

begin_define
define|#
directive|define
name|round_page_ps
parameter_list|(
name|va
parameter_list|,
name|ps
parameter_list|)
value|roundup2(va, ps)
end_define

begin_define
define|#
directive|define
name|aligned
parameter_list|(
name|a
parameter_list|,
name|t
parameter_list|)
value|(trunc_page_ps((u_long)(a), sizeof(t)) == (u_long)(a))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|FREEBSD_ABI_VENDOR
index|[]
init|=
literal|"FreeBSD"
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Elf_Brandnote
name|__elfN
parameter_list|(
name|freebsd_brandnote
parameter_list|)
init|=
block|{
operator|.
name|hdr
operator|.
name|n_namesz
operator|=
sizeof|sizeof
argument_list|(
name|FREEBSD_ABI_VENDOR
argument_list|)
operator|,
function_decl|.hdr.n_descsz
init|=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
operator|,
function_decl|.hdr.n_type
init|=
name|NT_FREEBSD_ABI_TAG
operator|,
function_decl|.vendor
init|=
name|FREEBSD_ABI_VENDOR
operator|,
function_decl|.flags
init|=
name|BN_TRANSLATE_OSREL
operator|,
function_decl|.trans_osrel
init|=
name|__elfN
argument_list|(
argument|freebsd_trans_osrel
argument_list|)
init|}
function_decl|;
end_function_decl

begin_function
specifier|static
name|boolean_t
name|__elfN
function|(
name|freebsd_trans_osrel
function|)
parameter_list|(
specifier|const
name|Elf_Note
modifier|*
name|note
parameter_list|,
name|int32_t
modifier|*
name|osrel
parameter_list|)
block|{
name|uintptr_t
name|p
decl_stmt|;
name|p
operator|=
call|(
name|uintptr_t
call|)
argument_list|(
name|note
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|+=
name|roundup2
argument_list|(
name|note
operator|->
name|n_namesz
argument_list|,
name|ELF_NOTE_ROUNDSIZE
argument_list|)
expr_stmt|;
operator|*
name|osrel
operator|=
operator|*
operator|(
specifier|const
name|int32_t
operator|*
operator|)
operator|(
name|p
operator|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
name|GNU_ABI_VENDOR
index|[]
init|=
literal|"GNU"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|GNU_KFREEBSD_ABI_DESC
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_function_decl
name|Elf_Brandnote
name|__elfN
parameter_list|(
name|kfreebsd_brandnote
parameter_list|)
init|=
block|{
operator|.
name|hdr
operator|.
name|n_namesz
operator|=
sizeof|sizeof
argument_list|(
name|GNU_ABI_VENDOR
argument_list|)
operator|,
function_decl|.hdr.n_descsz
init|=
literal|16
operator|,
comment|/* XXX at least 16 */
function_decl|.hdr.n_type
init|=
literal|1
operator|,
function_decl|.vendor
init|=
name|GNU_ABI_VENDOR
operator|,
function_decl|.flags
init|=
name|BN_TRANSLATE_OSREL
operator|,
function_decl|.trans_osrel
init|=
name|kfreebsd_trans_osrel
init|}
function_decl|;
end_function_decl

begin_function
specifier|static
name|boolean_t
name|kfreebsd_trans_osrel
parameter_list|(
specifier|const
name|Elf_Note
modifier|*
name|note
parameter_list|,
name|int32_t
modifier|*
name|osrel
parameter_list|)
block|{
specifier|const
name|Elf32_Word
modifier|*
name|desc
decl_stmt|;
name|uintptr_t
name|p
decl_stmt|;
name|p
operator|=
call|(
name|uintptr_t
call|)
argument_list|(
name|note
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|+=
name|roundup2
argument_list|(
name|note
operator|->
name|n_namesz
argument_list|,
name|ELF_NOTE_ROUNDSIZE
argument_list|)
expr_stmt|;
name|desc
operator|=
operator|(
specifier|const
name|Elf32_Word
operator|*
operator|)
name|p
expr_stmt|;
if|if
condition|(
name|desc
index|[
literal|0
index|]
operator|!=
name|GNU_KFREEBSD_ABI_DESC
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* 	 * Debian GNU/kFreeBSD embed the earliest compatible kernel version 	 * (__FreeBSD_version:<major><two digit minor>Rxx) in the LSB way. 	 */
operator|*
name|osrel
operator|=
name|desc
index|[
literal|1
index|]
operator|*
literal|100000
operator|+
name|desc
index|[
literal|2
index|]
operator|*
literal|1000
operator|+
name|desc
index|[
literal|3
index|]
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__elfN
function|(
name|insert_brand_entry
function|)
parameter_list|(
name|Elf_Brandinfo
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_BRANDS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|elf_brand_list
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|elf_brand_list
index|[
name|i
index|]
operator|=
name|entry
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|MAX_BRANDS
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING: %s: could not insert brandinfo entry: %p\n"
argument_list|,
name|__func__
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__elfN
function|(
name|remove_brand_entry
function|)
parameter_list|(
name|Elf_Brandinfo
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_BRANDS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|elf_brand_list
index|[
name|i
index|]
operator|==
name|entry
condition|)
block|{
name|elf_brand_list
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|MAX_BRANDS
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__elfN
function|(
name|brand_inuse
function|)
parameter_list|(
name|Elf_Brandinfo
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|rval
init|=
name|FALSE
decl_stmt|;
name|sx_slock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|FOREACH_PROC_IN_SYSTEM
argument_list|(
argument|p
argument_list|)
block|{
if|if
condition|(
name|p
operator|->
name|p_sysent
operator|==
name|entry
operator|->
name|sysvec
condition|)
block|{
name|rval
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
name|sx_sunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|Elf_Brandinfo
modifier|*
name|__elfN
function|(
name|get_brandinfo
function|)
parameter_list|(
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|,
specifier|const
name|char
modifier|*
name|interp
parameter_list|,
name|int
name|interp_name_len
parameter_list|,
name|int32_t
modifier|*
name|osrel
parameter_list|)
block|{
specifier|const
name|Elf_Ehdr
modifier|*
name|hdr
init|=
operator|(
specifier|const
name|Elf_Ehdr
operator|*
operator|)
name|imgp
operator|->
name|image_header
decl_stmt|;
name|Elf_Brandinfo
modifier|*
name|bi
decl_stmt|,
modifier|*
name|bi_m
decl_stmt|;
name|boolean_t
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * We support four types of branding -- (1) the ELF EI_OSABI field 	 * that SCO added to the ELF spec, (2) FreeBSD 3.x's traditional string 	 * branding w/in the ELF header, (3) path of the `interp_path' 	 * field, and (4) the ".note.ABI-tag" ELF section. 	 */
comment|/* Look for an ".note.ABI-tag" ELF section */
name|bi_m
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_BRANDS
condition|;
name|i
operator|++
control|)
block|{
name|bi
operator|=
name|elf_brand_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bi
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|interp
operator|!=
name|NULL
operator|&&
operator|(
name|bi
operator|->
name|flags
operator|&
name|BI_BRAND_ONLY_STATIC
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|hdr
operator|->
name|e_machine
operator|==
name|bi
operator|->
name|machine
operator|&&
operator|(
name|bi
operator|->
name|flags
operator|&
operator|(
name|BI_BRAND_NOTE
operator||
name|BI_BRAND_NOTE_MANDATORY
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|__elfN
argument_list|(
name|check_note
argument_list|)
argument_list|(
name|imgp
argument_list|,
name|bi
operator|->
name|brand_note
argument_list|,
name|osrel
argument_list|)
expr_stmt|;
comment|/* Give brand a chance to veto check_note's guess */
if|if
condition|(
name|ret
operator|&&
name|bi
operator|->
name|header_supported
condition|)
name|ret
operator|=
name|bi
operator|->
name|header_supported
argument_list|(
name|imgp
argument_list|)
expr_stmt|;
comment|/* 			 * If note checker claimed the binary, but the 			 * interpreter path in the image does not 			 * match default one for the brand, try to 			 * search for other brands with the same 			 * interpreter.  Either there is better brand 			 * with the right interpreter, or, failing 			 * this, we return first brand which accepted 			 * our note and, optionally, header. 			 */
if|if
condition|(
name|ret
operator|&&
name|bi_m
operator|==
name|NULL
operator|&&
name|interp
operator|!=
name|NULL
operator|&&
operator|(
name|bi
operator|->
name|interp_path
operator|==
name|NULL
operator|||
operator|(
name|strlen
argument_list|(
name|bi
operator|->
name|interp_path
argument_list|)
operator|+
literal|1
operator|!=
name|interp_name_len
operator|||
name|strncmp
argument_list|(
name|interp
argument_list|,
name|bi
operator|->
name|interp_path
argument_list|,
name|interp_name_len
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|bi_m
operator|=
name|bi
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|bi
operator|)
return|;
block|}
block|}
if|if
condition|(
name|bi_m
operator|!=
name|NULL
condition|)
return|return
operator|(
name|bi_m
operator|)
return|;
comment|/* If the executable has a brand, search for it in the brand list. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_BRANDS
condition|;
name|i
operator|++
control|)
block|{
name|bi
operator|=
name|elf_brand_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bi
operator|==
name|NULL
operator|||
operator|(
name|bi
operator|->
name|flags
operator|&
name|BI_BRAND_NOTE_MANDATORY
operator|)
operator|!=
literal|0
operator|||
operator|(
name|interp
operator|!=
name|NULL
operator|&&
operator|(
name|bi
operator|->
name|flags
operator|&
name|BI_BRAND_ONLY_STATIC
operator|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|hdr
operator|->
name|e_machine
operator|==
name|bi
operator|->
name|machine
operator|&&
operator|(
name|hdr
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|==
name|bi
operator|->
name|brand
operator|||
operator|(
name|bi
operator|->
name|compat_3_brand
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|hdr
operator|->
name|e_ident
index|[
name|OLD_EI_BRAND
index|]
argument_list|,
name|bi
operator|->
name|compat_3_brand
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Looks good, but give brand a chance to veto */
if|if
condition|(
operator|!
name|bi
operator|->
name|header_supported
operator|||
name|bi
operator|->
name|header_supported
argument_list|(
name|imgp
argument_list|)
condition|)
block|{
comment|/* 				 * Again, prefer strictly matching 				 * interpreter path. 				 */
if|if
condition|(
name|interp_name_len
operator|==
literal|0
operator|&&
name|bi
operator|->
name|interp_path
operator|==
name|NULL
condition|)
return|return
operator|(
name|bi
operator|)
return|;
if|if
condition|(
name|bi
operator|->
name|interp_path
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|bi
operator|->
name|interp_path
argument_list|)
operator|+
literal|1
operator|==
name|interp_name_len
operator|&&
name|strncmp
argument_list|(
name|interp
argument_list|,
name|bi
operator|->
name|interp_path
argument_list|,
name|interp_name_len
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|bi
operator|)
return|;
if|if
condition|(
name|bi_m
operator|==
name|NULL
condition|)
name|bi_m
operator|=
name|bi
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|bi_m
operator|!=
name|NULL
condition|)
return|return
operator|(
name|bi_m
operator|)
return|;
comment|/* No known brand, see if the header is recognized by any brand */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_BRANDS
condition|;
name|i
operator|++
control|)
block|{
name|bi
operator|=
name|elf_brand_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bi
operator|==
name|NULL
operator|||
name|bi
operator|->
name|flags
operator|&
name|BI_BRAND_NOTE_MANDATORY
operator|||
name|bi
operator|->
name|header_supported
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|hdr
operator|->
name|e_machine
operator|==
name|bi
operator|->
name|machine
condition|)
block|{
name|ret
operator|=
name|bi
operator|->
name|header_supported
argument_list|(
name|imgp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|bi
operator|)
return|;
block|}
block|}
comment|/* Lacking a known brand, search for a recognized interpreter. */
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_BRANDS
condition|;
name|i
operator|++
control|)
block|{
name|bi
operator|=
name|elf_brand_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bi
operator|==
name|NULL
operator|||
operator|(
name|bi
operator|->
name|flags
operator|&
operator|(
name|BI_BRAND_NOTE_MANDATORY
operator||
name|BI_BRAND_ONLY_STATIC
operator|)
operator|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|hdr
operator|->
name|e_machine
operator|==
name|bi
operator|->
name|machine
operator|&&
name|bi
operator|->
name|interp_path
operator|!=
name|NULL
operator|&&
comment|/* ELF image p_filesz includes terminating zero */
name|strlen
argument_list|(
name|bi
operator|->
name|interp_path
argument_list|)
operator|+
literal|1
operator|==
name|interp_name_len
operator|&&
name|strncmp
argument_list|(
name|interp
argument_list|,
name|bi
operator|->
name|interp_path
argument_list|,
name|interp_name_len
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|bi
operator|)
return|;
block|}
block|}
comment|/* Lacking a recognized interpreter, try the default brand */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_BRANDS
condition|;
name|i
operator|++
control|)
block|{
name|bi
operator|=
name|elf_brand_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bi
operator|==
name|NULL
operator|||
operator|(
name|bi
operator|->
name|flags
operator|&
name|BI_BRAND_NOTE_MANDATORY
operator|)
operator|!=
literal|0
operator|||
operator|(
name|interp
operator|!=
name|NULL
operator|&&
operator|(
name|bi
operator|->
name|flags
operator|&
name|BI_BRAND_ONLY_STATIC
operator|)
operator|!=
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|hdr
operator|->
name|e_machine
operator|==
name|bi
operator|->
name|machine
operator|&&
name|__elfN
argument_list|(
name|fallback_brand
argument_list|)
operator|==
name|bi
operator|->
name|brand
condition|)
return|return
operator|(
name|bi
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__elfN
function|(
name|check_header
function|)
parameter_list|(
specifier|const
name|Elf_Ehdr
modifier|*
name|hdr
parameter_list|)
block|{
name|Elf_Brandinfo
modifier|*
name|bi
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|IS_ELF
argument_list|(
operator|*
name|hdr
argument_list|)
operator|||
name|hdr
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|!=
name|ELF_TARG_CLASS
operator|||
name|hdr
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
operator|!=
name|ELF_TARG_DATA
operator|||
name|hdr
operator|->
name|e_ident
index|[
name|EI_VERSION
index|]
operator|!=
name|EV_CURRENT
operator|||
name|hdr
operator|->
name|e_phentsize
operator|!=
sizeof|sizeof
argument_list|(
name|Elf_Phdr
argument_list|)
operator|||
name|hdr
operator|->
name|e_version
operator|!=
name|ELF_TARG_VER
condition|)
return|return
operator|(
name|ENOEXEC
operator|)
return|;
comment|/* 	 * Make sure we have at least one brand for this machine. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_BRANDS
condition|;
name|i
operator|++
control|)
block|{
name|bi
operator|=
name|elf_brand_list
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bi
operator|!=
name|NULL
operator|&&
name|bi
operator|->
name|machine
operator|==
name|hdr
operator|->
name|e_machine
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|MAX_BRANDS
condition|)
return|return
operator|(
name|ENOEXEC
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__elfN
function|(
name|map_partial
function|)
parameter_list|(
name|vm_map_t
name|map
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vm_offset_t
name|off
decl_stmt|;
comment|/* 	 * Create the page if it doesn't exist yet. Ignore errors. 	 */
name|vm_map_fixed
argument_list|(
name|map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|trunc_page
argument_list|(
name|start
argument_list|)
argument_list|,
name|round_page
argument_list|(
name|end
argument_list|)
operator|-
name|trunc_page
argument_list|(
name|start
argument_list|)
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|MAP_CHECK_EXCL
argument_list|)
expr_stmt|;
comment|/* 	 * Find the page from the underlying object. 	 */
if|if
condition|(
name|object
operator|!=
name|NULL
condition|)
block|{
name|sf
operator|=
name|vm_imgact_map_page
argument_list|(
name|object
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf
operator|==
name|NULL
condition|)
return|return
operator|(
name|KERN_FAILURE
operator|)
return|;
name|off
operator|=
name|offset
operator|-
name|trunc_page
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
operator|+
name|off
argument_list|,
operator|(
name|caddr_t
operator|)
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|vm_imgact_unmap_page
argument_list|(
name|sf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|KERN_FAILURE
operator|)
return|;
block|}
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__elfN
function|(
name|map_insert
function|)
parameter_list|(
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|,
name|vm_map_t
name|map
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|int
name|cow
parameter_list|)
block|{
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|vm_offset_t
name|off
decl_stmt|;
name|vm_size_t
name|sz
decl_stmt|;
name|int
name|error
decl_stmt|,
name|locked
decl_stmt|,
name|rv
decl_stmt|;
if|if
condition|(
name|start
operator|!=
name|trunc_page
argument_list|(
name|start
argument_list|)
condition|)
block|{
name|rv
operator|=
name|__elfN
argument_list|(
name|map_partial
argument_list|)
argument_list|(
name|map
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|start
argument_list|,
name|round_page
argument_list|(
name|start
argument_list|)
argument_list|,
name|prot
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
return|return
operator|(
name|rv
operator|)
return|;
name|offset
operator|+=
name|round_page
argument_list|(
name|start
argument_list|)
operator|-
name|start
expr_stmt|;
name|start
operator|=
name|round_page
argument_list|(
name|start
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|!=
name|round_page
argument_list|(
name|end
argument_list|)
condition|)
block|{
name|rv
operator|=
name|__elfN
argument_list|(
name|map_partial
argument_list|)
argument_list|(
name|map
argument_list|,
name|object
argument_list|,
name|offset
operator|+
name|trunc_page
argument_list|(
name|end
argument_list|)
operator|-
name|start
argument_list|,
name|trunc_page
argument_list|(
name|end
argument_list|)
argument_list|,
name|end
argument_list|,
name|prot
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
return|return
operator|(
name|rv
operator|)
return|;
name|end
operator|=
name|trunc_page
argument_list|(
name|end
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|>=
name|end
condition|)
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
if|if
condition|(
operator|(
name|offset
operator|&
name|PAGE_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The mapping is not page aligned.  This means that we have 		 * to copy the data. 		 */
name|rv
operator|=
name|vm_map_fixed
argument_list|(
name|map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|,
name|prot
operator||
name|VM_PROT_WRITE
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|MAP_CHECK_EXCL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
return|return
operator|(
name|rv
operator|)
return|;
if|if
condition|(
name|object
operator|==
name|NULL
condition|)
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
for|for
control|(
init|;
name|start
operator|<
name|end
condition|;
name|start
operator|+=
name|sz
control|)
block|{
name|sf
operator|=
name|vm_imgact_map_page
argument_list|(
name|object
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf
operator|==
name|NULL
condition|)
return|return
operator|(
name|KERN_FAILURE
operator|)
return|;
name|off
operator|=
name|offset
operator|-
name|trunc_page
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|sz
operator|=
name|end
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|sz
operator|>
name|PAGE_SIZE
operator|-
name|off
condition|)
name|sz
operator|=
name|PAGE_SIZE
operator|-
name|off
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
operator|+
name|off
argument_list|,
operator|(
name|caddr_t
operator|)
name|start
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|vm_imgact_unmap_page
argument_list|(
name|sf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|KERN_FAILURE
operator|)
return|;
name|offset
operator|+=
name|sz
expr_stmt|;
block|}
block|}
else|else
block|{
name|vm_object_reference
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_map_fixed
argument_list|(
name|map
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|,
name|prot
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|cow
operator||
name|MAP_CHECK_EXCL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|locked
operator|=
name|VOP_ISLOCKED
argument_list|(
name|imgp
operator|->
name|vp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|imgp
operator|->
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|imgp
operator|->
name|vp
argument_list|,
name|locked
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
block|}
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__elfN
function|(
name|load_section
function|)
parameter_list|(
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|caddr_t
name|vmaddr
parameter_list|,
name|size_t
name|memsz
parameter_list|,
name|size_t
name|filsz
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|size_t
name|pagesize
parameter_list|)
block|{
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|size_t
name|map_len
decl_stmt|;
name|vm_map_t
name|map
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|vm_offset_t
name|off
decl_stmt|,
name|map_addr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rv
decl_stmt|,
name|cow
decl_stmt|;
name|size_t
name|copy_len
decl_stmt|;
name|vm_ooffset_t
name|file_addr
decl_stmt|;
comment|/* 	 * It's necessary to fail if the filsz + offset taken from the 	 * header is greater than the actual file pager object's size. 	 * If we were to allow this, then the vm_map_find() below would 	 * walk right off the end of the file object and into the ether. 	 * 	 * While I'm here, might as well check for something else that 	 * is invalid: filsz cannot be greater than memsz. 	 */
if|if
condition|(
operator|(
name|filsz
operator|!=
literal|0
operator|&&
operator|(
name|off_t
operator|)
name|filsz
operator|+
name|offset
operator|>
name|imgp
operator|->
name|attr
operator|->
name|va_size
operator|)
operator|||
name|filsz
operator|>
name|memsz
condition|)
block|{
name|uprintf
argument_list|(
literal|"elf_load_section: truncated ELF file\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOEXEC
operator|)
return|;
block|}
name|object
operator|=
name|imgp
operator|->
name|object
expr_stmt|;
name|map
operator|=
operator|&
name|imgp
operator|->
name|proc
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
name|map_addr
operator|=
name|trunc_page_ps
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vmaddr
argument_list|,
name|pagesize
argument_list|)
expr_stmt|;
name|file_addr
operator|=
name|trunc_page_ps
argument_list|(
name|offset
argument_list|,
name|pagesize
argument_list|)
expr_stmt|;
comment|/* 	 * We have two choices.  We can either clear the data in the last page 	 * of an oversized mapping, or we can start the anon mapping a page 	 * early and copy the initialized data into that first page.  We 	 * choose the second. 	 */
if|if
condition|(
name|filsz
operator|==
literal|0
condition|)
name|map_len
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|memsz
operator|>
name|filsz
condition|)
name|map_len
operator|=
name|trunc_page_ps
argument_list|(
name|offset
operator|+
name|filsz
argument_list|,
name|pagesize
argument_list|)
operator|-
name|file_addr
expr_stmt|;
else|else
name|map_len
operator|=
name|round_page_ps
argument_list|(
name|offset
operator|+
name|filsz
argument_list|,
name|pagesize
argument_list|)
operator|-
name|file_addr
expr_stmt|;
if|if
condition|(
name|map_len
operator|!=
literal|0
condition|)
block|{
comment|/* cow flags: don't dump readonly sections in core */
name|cow
operator|=
name|MAP_COPY_ON_WRITE
operator||
name|MAP_PREFAULT
operator||
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|?
literal|0
else|:
name|MAP_DISABLE_COREDUMP
operator|)
expr_stmt|;
name|rv
operator|=
name|__elfN
argument_list|(
name|map_insert
argument_list|)
argument_list|(
name|imgp
argument_list|,
name|map
argument_list|,
name|object
argument_list|,
name|file_addr
argument_list|,
comment|/* file offset */
name|map_addr
argument_list|,
comment|/* virtual start */
name|map_addr
operator|+
name|map_len
argument_list|,
comment|/* virtual end */
name|prot
argument_list|,
name|cow
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* we can stop now if we've covered it all */
if|if
condition|(
name|memsz
operator|==
name|filsz
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * We have to get the remaining bit of the file into the first part 	 * of the oversized map segment.  This is normally because the .data 	 * segment in the file is extended to provide bss.  It's a neat idea 	 * to try and save a page, but it's a pain in the behind to implement. 	 */
name|copy_len
operator|=
name|filsz
operator|==
literal|0
condition|?
literal|0
else|:
operator|(
name|offset
operator|+
name|filsz
operator|)
operator|-
name|trunc_page_ps
argument_list|(
name|offset
operator|+
name|filsz
argument_list|,
name|pagesize
argument_list|)
expr_stmt|;
name|map_addr
operator|=
name|trunc_page_ps
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vmaddr
operator|+
name|filsz
argument_list|,
name|pagesize
argument_list|)
expr_stmt|;
name|map_len
operator|=
name|round_page_ps
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vmaddr
operator|+
name|memsz
argument_list|,
name|pagesize
argument_list|)
operator|-
name|map_addr
expr_stmt|;
comment|/* This had damn well better be true! */
if|if
condition|(
name|map_len
operator|!=
literal|0
condition|)
block|{
name|rv
operator|=
name|__elfN
argument_list|(
name|map_insert
argument_list|)
argument_list|(
name|imgp
argument_list|,
name|map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|map_addr
argument_list|,
name|map_addr
operator|+
name|map_len
argument_list|,
name|VM_PROT_ALL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|copy_len
operator|!=
literal|0
condition|)
block|{
name|sf
operator|=
name|vm_imgact_map_page
argument_list|(
name|object
argument_list|,
name|offset
operator|+
name|filsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf
operator|==
name|NULL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
comment|/* send the page fragment to user space */
name|off
operator|=
name|trunc_page_ps
argument_list|(
name|offset
operator|+
name|filsz
argument_list|,
name|pagesize
argument_list|)
operator|-
name|trunc_page
argument_list|(
name|offset
operator|+
name|filsz
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
operator|+
name|off
argument_list|,
operator|(
name|caddr_t
operator|)
name|map_addr
argument_list|,
name|copy_len
argument_list|)
expr_stmt|;
name|vm_imgact_unmap_page
argument_list|(
name|sf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * set it to the specified protection. 	 */
name|vm_map_protect
argument_list|(
name|map
argument_list|,
name|trunc_page
argument_list|(
name|map_addr
argument_list|)
argument_list|,
name|round_page
argument_list|(
name|map_addr
operator|+
name|map_len
argument_list|)
argument_list|,
name|prot
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Load the file "file" into memory.  It may be either a shared object  * or an executable.  *  * The "addr" reference parameter is in/out.  On entry, it specifies  * the address where a shared object should be loaded.  If the file is  * an executable, this value is ignored.  On exit, "addr" specifies  * where the file was actually loaded.  *  * The "entry" reference parameter is out only.  On exit, it specifies  * the entry point for the loaded file.  */
end_comment

begin_function
specifier|static
name|int
name|__elfN
function|(
name|load_file
function|)
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|u_long
modifier|*
name|addr
parameter_list|,
name|u_long
modifier|*
name|entry
parameter_list|,
name|size_t
name|pagesize
parameter_list|)
block|{
struct|struct
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|vattr
name|attr
decl_stmt|;
name|struct
name|image_params
name|image_params
decl_stmt|;
block|}
modifier|*
name|tempdata
struct|;
specifier|const
name|Elf_Ehdr
modifier|*
name|hdr
init|=
name|NULL
decl_stmt|;
specifier|const
name|Elf_Phdr
modifier|*
name|phdr
init|=
name|NULL
decl_stmt|;
name|struct
name|nameidata
modifier|*
name|nd
decl_stmt|;
name|struct
name|vattr
modifier|*
name|attr
decl_stmt|;
name|struct
name|image_params
modifier|*
name|imgp
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|u_long
name|rbase
decl_stmt|;
name|u_long
name|base_addr
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|numsegs
decl_stmt|;
ifdef|#
directive|ifdef
name|CAPABILITY_MODE
comment|/* 	 * XXXJA: This check can go away once we are sufficiently confident 	 * that the checks in namei() are correct. 	 */
if|if
condition|(
name|IN_CAPABILITY_MODE
argument_list|(
name|curthread
argument_list|)
condition|)
return|return
operator|(
name|ECAPMODE
operator|)
return|;
endif|#
directive|endif
name|tempdata
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tempdata
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nd
operator|=
operator|&
name|tempdata
operator|->
name|nd
expr_stmt|;
name|attr
operator|=
operator|&
name|tempdata
operator|->
name|attr
expr_stmt|;
name|imgp
operator|=
operator|&
name|tempdata
operator|->
name|image_params
expr_stmt|;
comment|/* 	 * Initialize part of the common data 	 */
name|imgp
operator|->
name|proc
operator|=
name|p
expr_stmt|;
name|imgp
operator|->
name|attr
operator|=
name|attr
expr_stmt|;
name|imgp
operator|->
name|firstpage
operator|=
name|NULL
expr_stmt|;
name|imgp
operator|->
name|image_header
operator|=
name|NULL
expr_stmt|;
name|imgp
operator|->
name|object
operator|=
name|NULL
expr_stmt|;
name|imgp
operator|->
name|execlabel
operator|=
name|NULL
expr_stmt|;
name|NDINIT
argument_list|(
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|LOCKLEAF
operator||
name|FOLLOW
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|file
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|namei
argument_list|(
name|nd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|nd
operator|->
name|ni_vp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|NDFREE
argument_list|(
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|imgp
operator|->
name|vp
operator|=
name|nd
operator|->
name|ni_vp
expr_stmt|;
comment|/* 	 * Check permissions, modes, uid, etc on the file, and "open" it. 	 */
name|error
operator|=
name|exec_check_permissions
argument_list|(
name|imgp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
name|error
operator|=
name|exec_map_first_page
argument_list|(
name|imgp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|fail
goto|;
comment|/* 	 * Also make certain that the interpreter stays the same, so set 	 * its VV_TEXT flag, too. 	 */
name|VOP_SET_TEXT
argument_list|(
name|nd
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
name|imgp
operator|->
name|object
operator|=
name|nd
operator|->
name|ni_vp
operator|->
name|v_object
expr_stmt|;
name|hdr
operator|=
operator|(
specifier|const
name|Elf_Ehdr
operator|*
operator|)
name|imgp
operator|->
name|image_header
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|__elfN
argument_list|(
name|check_header
argument_list|)
argument_list|(
name|hdr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|hdr
operator|->
name|e_type
operator|==
name|ET_DYN
condition|)
name|rbase
operator|=
operator|*
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|hdr
operator|->
name|e_type
operator|==
name|ET_EXEC
condition|)
name|rbase
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Only support headers that fit within first page for now      */
if|if
condition|(
operator|(
name|hdr
operator|->
name|e_phoff
operator|>
name|PAGE_SIZE
operator|)
operator|||
operator|(
name|u_int
operator|)
name|hdr
operator|->
name|e_phentsize
operator|*
name|hdr
operator|->
name|e_phnum
operator|>
name|PAGE_SIZE
operator|-
name|hdr
operator|->
name|e_phoff
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|phdr
operator|=
operator|(
specifier|const
name|Elf_Phdr
operator|*
operator|)
operator|(
name|imgp
operator|->
name|image_header
operator|+
name|hdr
operator|->
name|e_phoff
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|aligned
argument_list|(
name|phdr
argument_list|,
name|Elf_Addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|numsegs
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|e_phnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_type
operator|==
name|PT_LOAD
operator|&&
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
operator|!=
literal|0
condition|)
block|{
comment|/* Loadable segment */
name|prot
operator|=
name|__elfN
argument_list|(
name|trans_prot
argument_list|)
argument_list|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_flags
argument_list|)
expr_stmt|;
name|error
operator|=
name|__elfN
argument_list|(
name|load_section
argument_list|)
argument_list|(
name|imgp
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_offset
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|+
name|rbase
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_filesz
argument_list|,
name|prot
argument_list|,
name|pagesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
comment|/* 			 * Establish the base address if this is the 			 * first segment. 			 */
if|if
condition|(
name|numsegs
operator|==
literal|0
condition|)
name|base_addr
operator|=
name|trunc_page
argument_list|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|+
name|rbase
argument_list|)
expr_stmt|;
name|numsegs
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|addr
operator|=
name|base_addr
expr_stmt|;
operator|*
name|entry
operator|=
operator|(
name|unsigned
name|long
operator|)
name|hdr
operator|->
name|e_entry
operator|+
name|rbase
expr_stmt|;
name|fail
label|:
if|if
condition|(
name|imgp
operator|->
name|firstpage
condition|)
name|exec_unmap_first_page
argument_list|(
name|imgp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|->
name|ni_vp
condition|)
name|vput
argument_list|(
name|nd
operator|->
name|ni_vp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tempdata
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|__CONCAT
argument_list|(
name|exec_
argument_list|,
name|__elfN
argument_list|(
name|imgact
argument_list|)
argument_list|)
argument_list|(
expr|struct
name|image_params
operator|*
name|imgp
argument_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
specifier|const
name|Elf_Ehdr
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|Elf_Phdr
modifier|*
name|phdr
decl_stmt|;
name|Elf_Auxargs
modifier|*
name|elf_auxargs
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vmspace
decl_stmt|;
specifier|const
name|char
modifier|*
name|err_str
decl_stmt|,
modifier|*
name|newinterp
decl_stmt|;
name|char
modifier|*
name|interp
decl_stmt|,
modifier|*
name|interp_buf
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|Elf_Brandinfo
modifier|*
name|brand_info
decl_stmt|;
name|struct
name|sysentvec
modifier|*
name|sv
decl_stmt|;
name|vm_prot_t
name|prot
decl_stmt|;
name|u_long
name|text_size
decl_stmt|,
name|data_size
decl_stmt|,
name|total_size
decl_stmt|,
name|text_addr
decl_stmt|,
name|data_addr
decl_stmt|;
name|u_long
name|seg_size
decl_stmt|,
name|seg_addr
decl_stmt|,
name|addr
decl_stmt|,
name|baddr
decl_stmt|,
name|et_dyn_addr
decl_stmt|,
name|entry
decl_stmt|,
name|proghdr
decl_stmt|;
name|int32_t
name|osrel
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|,
name|interp_name_len
decl_stmt|,
name|have_interp
decl_stmt|;
name|hdr
operator|=
operator|(
specifier|const
name|Elf_Ehdr
operator|*
operator|)
name|imgp
operator|->
name|image_header
expr_stmt|;
comment|/* 	 * Do we have a valid ELF header ? 	 * 	 * Only allow ET_EXEC& ET_DYN here, reject ET_DYN later 	 * if particular brand doesn't support it. 	 */
if|if
condition|(
name|__elfN
argument_list|(
name|check_header
argument_list|)
argument_list|(
name|hdr
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|hdr
operator|->
name|e_type
operator|!=
name|ET_EXEC
operator|&&
name|hdr
operator|->
name|e_type
operator|!=
name|ET_DYN
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * From here on down, we return an errno, not -1, as we've 	 * detected an ELF file. 	 */
if|if
condition|(
operator|(
name|hdr
operator|->
name|e_phoff
operator|>
name|PAGE_SIZE
operator|)
operator|||
operator|(
name|u_int
operator|)
name|hdr
operator|->
name|e_phentsize
operator|*
name|hdr
operator|->
name|e_phnum
operator|>
name|PAGE_SIZE
operator|-
name|hdr
operator|->
name|e_phoff
condition|)
block|{
comment|/* Only support headers in first page for now */
name|uprintf
argument_list|(
literal|"Program headers not in the first page\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOEXEC
operator|)
return|;
block|}
name|phdr
operator|=
operator|(
specifier|const
name|Elf_Phdr
operator|*
operator|)
operator|(
name|imgp
operator|->
name|image_header
operator|+
name|hdr
operator|->
name|e_phoff
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|aligned
argument_list|(
name|phdr
argument_list|,
name|Elf_Addr
argument_list|)
condition|)
block|{
name|uprintf
argument_list|(
literal|"Unaligned program headers\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOEXEC
operator|)
return|;
block|}
name|n
operator|=
name|error
operator|=
literal|0
expr_stmt|;
name|baddr
operator|=
literal|0
expr_stmt|;
name|osrel
operator|=
literal|0
expr_stmt|;
name|text_size
operator|=
name|data_size
operator|=
name|total_size
operator|=
name|text_addr
operator|=
name|data_addr
operator|=
literal|0
expr_stmt|;
name|entry
operator|=
name|proghdr
operator|=
literal|0
expr_stmt|;
name|interp_name_len
operator|=
literal|0
expr_stmt|;
name|err_str
operator|=
name|newinterp
operator|=
name|NULL
expr_stmt|;
name|interp
operator|=
name|interp_buf
operator|=
name|NULL
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|e_phnum
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_type
condition|)
block|{
case|case
name|PT_LOAD
case|:
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|baddr
operator|=
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
expr_stmt|;
name|n
operator|++
expr_stmt|;
break|break;
case|case
name|PT_INTERP
case|:
comment|/* Path to interpreter */
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_filesz
operator|>
name|MAXPATHLEN
condition|)
block|{
name|uprintf
argument_list|(
literal|"Invalid PT_INTERP\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|uprintf
argument_list|(
literal|"Multiple PT_INTERP headers\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|interp_name_len
operator|=
name|phdr
index|[
name|i
index|]
operator|.
name|p_filesz
expr_stmt|;
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_offset
operator|>
name|PAGE_SIZE
operator|||
name|interp_name_len
operator|>
name|PAGE_SIZE
operator|-
name|phdr
index|[
name|i
index|]
operator|.
name|p_offset
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|imgp
operator|->
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|interp_buf
operator|=
name|malloc
argument_list|(
name|interp_name_len
operator|+
literal|1
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|imgp
operator|->
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|imgp
operator|->
name|vp
argument_list|,
name|interp_buf
argument_list|,
name|interp_name_len
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_offset
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|NOCRED
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|uprintf
argument_list|(
literal|"i/o error PT_INTERP\n"
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|interp_buf
index|[
name|interp_name_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|interp
operator|=
name|interp_buf
expr_stmt|;
block|}
else|else
block|{
name|interp
operator|=
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|imgp
operator|->
name|image_header
argument_list|)
operator|+
name|phdr
index|[
name|i
index|]
operator|.
name|p_offset
expr_stmt|;
block|}
break|break;
case|case
name|PT_GNU_STACK
case|:
if|if
condition|(
name|__elfN
argument_list|(
name|nxstack
argument_list|)
condition|)
name|imgp
operator|->
name|stack_prot
operator|=
name|__elfN
argument_list|(
name|trans_prot
argument_list|)
argument_list|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_flags
argument_list|)
expr_stmt|;
name|imgp
operator|->
name|stack_sz
operator|=
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
expr_stmt|;
break|break;
block|}
block|}
name|brand_info
operator|=
name|__elfN
argument_list|(
name|get_brandinfo
argument_list|)
argument_list|(
name|imgp
argument_list|,
name|interp
argument_list|,
name|interp_name_len
argument_list|,
operator|&
name|osrel
argument_list|)
expr_stmt|;
if|if
condition|(
name|brand_info
operator|==
name|NULL
condition|)
block|{
name|uprintf
argument_list|(
literal|"ELF binary type \"%u\" not known.\n"
argument_list|,
name|hdr
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|hdr
operator|->
name|e_type
operator|==
name|ET_DYN
condition|)
block|{
if|if
condition|(
operator|(
name|brand_info
operator|->
name|flags
operator|&
name|BI_CAN_EXEC_DYN
operator|)
operator|==
literal|0
condition|)
block|{
name|uprintf
argument_list|(
literal|"Cannot execute shared object\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
comment|/* 		 * Honour the base load address from the dso if it is 		 * non-zero for some reason. 		 */
if|if
condition|(
name|baddr
operator|==
literal|0
condition|)
name|et_dyn_addr
operator|=
name|ET_DYN_LOAD_ADDR
expr_stmt|;
else|else
name|et_dyn_addr
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|et_dyn_addr
operator|=
literal|0
expr_stmt|;
name|sv
operator|=
name|brand_info
operator|->
name|sysvec
expr_stmt|;
if|if
condition|(
name|interp
operator|!=
name|NULL
operator|&&
name|brand_info
operator|->
name|interp_newpath
operator|!=
name|NULL
condition|)
name|newinterp
operator|=
name|brand_info
operator|->
name|interp_newpath
expr_stmt|;
comment|/* 	 * Avoid a possible deadlock if the current address space is destroyed 	 * and that address space maps the locked vnode.  In the common case, 	 * the locked vnode's v_usecount is decremented but remains greater 	 * than zero.  Consequently, the vnode lock is not needed by vrele(). 	 * However, in cases where the vnode lock is external, such as nullfs, 	 * v_usecount may become zero. 	 * 	 * The VV_TEXT flag prevents modifications to the executable while 	 * the vnode is unlocked. 	 */
name|VOP_UNLOCK
argument_list|(
name|imgp
operator|->
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|exec_new_vmspace
argument_list|(
name|imgp
argument_list|,
name|sv
argument_list|)
expr_stmt|;
name|imgp
operator|->
name|proc
operator|->
name|p_sysent
operator|=
name|sv
expr_stmt|;
name|vn_lock
argument_list|(
name|imgp
operator|->
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|ret
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|e_phnum
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_type
condition|)
block|{
case|case
name|PT_LOAD
case|:
comment|/* Loadable segment */
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
operator|==
literal|0
condition|)
break|break;
name|prot
operator|=
name|__elfN
argument_list|(
name|trans_prot
argument_list|)
argument_list|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_flags
argument_list|)
expr_stmt|;
name|error
operator|=
name|__elfN
argument_list|(
name|load_section
argument_list|)
argument_list|(
name|imgp
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_offset
argument_list|,
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|+
name|et_dyn_addr
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
argument_list|,
name|phdr
index|[
name|i
index|]
operator|.
name|p_filesz
argument_list|,
name|prot
argument_list|,
name|sv
operator|->
name|sv_pagesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|ret
goto|;
comment|/* 			 * If this segment contains the program headers, 			 * remember their virtual address for the AT_PHDR 			 * aux entry. Static binaries don't usually include 			 * a PT_PHDR entry. 			 */
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_offset
operator|==
literal|0
operator|&&
name|hdr
operator|->
name|e_phoff
operator|+
name|hdr
operator|->
name|e_phnum
operator|*
name|hdr
operator|->
name|e_phentsize
operator|<=
name|phdr
index|[
name|i
index|]
operator|.
name|p_filesz
condition|)
name|proghdr
operator|=
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|+
name|hdr
operator|->
name|e_phoff
operator|+
name|et_dyn_addr
expr_stmt|;
name|seg_addr
operator|=
name|trunc_page
argument_list|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|+
name|et_dyn_addr
argument_list|)
expr_stmt|;
name|seg_size
operator|=
name|round_page
argument_list|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_memsz
operator|+
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|+
name|et_dyn_addr
operator|-
name|seg_addr
argument_list|)
expr_stmt|;
comment|/* 			 * Make the largest executable segment the official 			 * text segment and all others data. 			 * 			 * Note that obreak() assumes that data_addr +  			 * data_size == end of data load area, and the ELF 			 * file format expects segments to be sorted by 			 * address.  If multiple data segments exist, the 			 * last one will be used. 			 */
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_flags
operator|&
name|PF_X
operator|&&
name|text_size
operator|<
name|seg_size
condition|)
block|{
name|text_size
operator|=
name|seg_size
expr_stmt|;
name|text_addr
operator|=
name|seg_addr
expr_stmt|;
block|}
else|else
block|{
name|data_size
operator|=
name|seg_size
expr_stmt|;
name|data_addr
operator|=
name|seg_addr
expr_stmt|;
block|}
name|total_size
operator|+=
name|seg_size
expr_stmt|;
break|break;
case|case
name|PT_PHDR
case|:
comment|/* Program header table info */
name|proghdr
operator|=
name|phdr
index|[
name|i
index|]
operator|.
name|p_vaddr
operator|+
name|et_dyn_addr
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|data_addr
operator|==
literal|0
operator|&&
name|data_size
operator|==
literal|0
condition|)
block|{
name|data_addr
operator|=
name|text_addr
expr_stmt|;
name|data_size
operator|=
name|text_size
expr_stmt|;
block|}
name|entry
operator|=
operator|(
name|u_long
operator|)
name|hdr
operator|->
name|e_entry
operator|+
name|et_dyn_addr
expr_stmt|;
comment|/* 	 * Check limits.  It should be safe to check the 	 * limits after loading the segments since we do 	 * not actually fault in all the segments pages. 	 */
name|PROC_LOCK
argument_list|(
name|imgp
operator|->
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_size
operator|>
name|lim_cur_proc
argument_list|(
name|imgp
operator|->
name|proc
argument_list|,
name|RLIMIT_DATA
argument_list|)
condition|)
name|err_str
operator|=
literal|"Data segment size exceeds process limit"
expr_stmt|;
elseif|else
if|if
condition|(
name|text_size
operator|>
name|maxtsiz
condition|)
name|err_str
operator|=
literal|"Text segment size exceeds system limit"
expr_stmt|;
elseif|else
if|if
condition|(
name|total_size
operator|>
name|lim_cur_proc
argument_list|(
name|imgp
operator|->
name|proc
argument_list|,
name|RLIMIT_VMEM
argument_list|)
condition|)
name|err_str
operator|=
literal|"Total segment size exceeds process limit"
expr_stmt|;
elseif|else
if|if
condition|(
name|racct_set
argument_list|(
name|imgp
operator|->
name|proc
argument_list|,
name|RACCT_DATA
argument_list|,
name|data_size
argument_list|)
operator|!=
literal|0
condition|)
name|err_str
operator|=
literal|"Data segment size exceeds resource limit"
expr_stmt|;
elseif|else
if|if
condition|(
name|racct_set
argument_list|(
name|imgp
operator|->
name|proc
argument_list|,
name|RACCT_VMEM
argument_list|,
name|total_size
argument_list|)
operator|!=
literal|0
condition|)
name|err_str
operator|=
literal|"Total segment size exceeds resource limit"
expr_stmt|;
if|if
condition|(
name|err_str
operator|!=
name|NULL
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|imgp
operator|->
name|proc
argument_list|)
expr_stmt|;
name|uprintf
argument_list|(
literal|"%s\n"
argument_list|,
name|err_str
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|vmspace
operator|=
name|imgp
operator|->
name|proc
operator|->
name|p_vmspace
expr_stmt|;
name|vmspace
operator|->
name|vm_tsize
operator|=
name|text_size
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|vmspace
operator|->
name|vm_taddr
operator|=
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|text_addr
expr_stmt|;
name|vmspace
operator|->
name|vm_dsize
operator|=
name|data_size
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|vmspace
operator|->
name|vm_daddr
operator|=
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|data_addr
expr_stmt|;
comment|/* 	 * We load the dynamic linker where a userland call 	 * to mmap(0, ...) would put it.  The rationale behind this 	 * calculation is that it leaves room for the heap to grow to 	 * its maximum allowed size. 	 */
name|addr
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vmspace
operator|->
name|vm_daddr
operator|+
name|lim_max
argument_list|(
name|td
argument_list|,
name|RLIMIT_DATA
argument_list|)
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|imgp
operator|->
name|proc
argument_list|)
expr_stmt|;
name|imgp
operator|->
name|entry_addr
operator|=
name|entry
expr_stmt|;
if|if
condition|(
name|interp
operator|!=
name|NULL
condition|)
block|{
name|have_interp
operator|=
name|FALSE
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|imgp
operator|->
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|brand_info
operator|->
name|emul_path
operator|!=
name|NULL
operator|&&
name|brand_info
operator|->
name|emul_path
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|path
operator|=
name|malloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|path
argument_list|,
name|MAXPATHLEN
argument_list|,
literal|"%s%s"
argument_list|,
name|brand_info
operator|->
name|emul_path
argument_list|,
name|interp
argument_list|)
expr_stmt|;
name|error
operator|=
name|__elfN
argument_list|(
name|load_file
argument_list|)
argument_list|(
name|imgp
operator|->
name|proc
argument_list|,
name|path
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|imgp
operator|->
name|entry_addr
argument_list|,
name|sv
operator|->
name|sv_pagesize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|path
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|have_interp
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|have_interp
operator|&&
name|newinterp
operator|!=
name|NULL
operator|&&
operator|(
name|brand_info
operator|->
name|interp_path
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|interp
argument_list|,
name|brand_info
operator|->
name|interp_path
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|__elfN
argument_list|(
name|load_file
argument_list|)
argument_list|(
name|imgp
operator|->
name|proc
argument_list|,
name|newinterp
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|imgp
operator|->
name|entry_addr
argument_list|,
name|sv
operator|->
name|sv_pagesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|have_interp
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|have_interp
condition|)
block|{
name|error
operator|=
name|__elfN
argument_list|(
name|load_file
argument_list|)
argument_list|(
name|imgp
operator|->
name|proc
argument_list|,
name|interp
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|imgp
operator|->
name|entry_addr
argument_list|,
name|sv
operator|->
name|sv_pagesize
argument_list|)
expr_stmt|;
block|}
name|vn_lock
argument_list|(
name|imgp
operator|->
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|uprintf
argument_list|(
literal|"ELF interpreter %s not found, error %d\n"
argument_list|,
name|interp
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
block|}
else|else
name|addr
operator|=
name|et_dyn_addr
expr_stmt|;
comment|/* 	 * Construct auxargs table (used by the fixup routine) 	 */
name|elf_auxargs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Elf_Auxargs
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|elf_auxargs
operator|->
name|execfd
operator|=
operator|-
literal|1
expr_stmt|;
name|elf_auxargs
operator|->
name|phdr
operator|=
name|proghdr
expr_stmt|;
name|elf_auxargs
operator|->
name|phent
operator|=
name|hdr
operator|->
name|e_phentsize
expr_stmt|;
name|elf_auxargs
operator|->
name|phnum
operator|=
name|hdr
operator|->
name|e_phnum
expr_stmt|;
name|elf_auxargs
operator|->
name|pagesz
operator|=
name|PAGE_SIZE
expr_stmt|;
name|elf_auxargs
operator|->
name|base
operator|=
name|addr
expr_stmt|;
name|elf_auxargs
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|elf_auxargs
operator|->
name|entry
operator|=
name|entry
expr_stmt|;
name|elf_auxargs
operator|->
name|hdr_eflags
operator|=
name|hdr
operator|->
name|e_flags
expr_stmt|;
name|imgp
operator|->
name|auxargs
operator|=
name|elf_auxargs
expr_stmt|;
name|imgp
operator|->
name|interpreted
operator|=
literal|0
expr_stmt|;
name|imgp
operator|->
name|reloc_base
operator|=
name|addr
expr_stmt|;
name|imgp
operator|->
name|proc
operator|->
name|p_osrel
operator|=
name|osrel
expr_stmt|;
name|imgp
operator|->
name|proc
operator|->
name|p_elf_machine
operator|=
name|hdr
operator|->
name|e_machine
expr_stmt|;
name|imgp
operator|->
name|proc
operator|->
name|p_elf_flags
operator|=
name|hdr
operator|->
name|e_flags
expr_stmt|;
name|ret
label|:
name|free
argument_list|(
name|interp_buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_decl_stmt

begin_define
define|#
directive|define
name|suword
value|__CONCAT(suword, __ELF_WORD_SIZE)
end_define

begin_function
name|int
name|__elfN
function|(
name|freebsd_fixup
function|)
parameter_list|(
name|register_t
modifier|*
modifier|*
name|stack_base
parameter_list|,
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|)
block|{
name|Elf_Auxargs
modifier|*
name|args
init|=
operator|(
name|Elf_Auxargs
operator|*
operator|)
name|imgp
operator|->
name|auxargs
decl_stmt|;
name|Elf_Addr
modifier|*
name|base
decl_stmt|;
name|Elf_Addr
modifier|*
name|pos
decl_stmt|;
name|base
operator|=
operator|(
name|Elf_Addr
operator|*
operator|)
operator|*
name|stack_base
expr_stmt|;
name|pos
operator|=
name|base
operator|+
operator|(
name|imgp
operator|->
name|args
operator|->
name|argc
operator|+
name|imgp
operator|->
name|args
operator|->
name|envc
operator|+
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|execfd
operator|!=
operator|-
literal|1
condition|)
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_EXECFD
argument_list|,
name|args
operator|->
name|execfd
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_PHDR
argument_list|,
name|args
operator|->
name|phdr
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_PHENT
argument_list|,
name|args
operator|->
name|phent
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_PHNUM
argument_list|,
name|args
operator|->
name|phnum
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_PAGESZ
argument_list|,
name|args
operator|->
name|pagesz
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_FLAGS
argument_list|,
name|args
operator|->
name|flags
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_ENTRY
argument_list|,
name|args
operator|->
name|entry
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_BASE
argument_list|,
name|args
operator|->
name|base
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AT_EHDRFLAGS
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_EHDRFLAGS
argument_list|,
name|args
operator|->
name|hdr_eflags
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|imgp
operator|->
name|execpathp
operator|!=
literal|0
condition|)
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_EXECPATH
argument_list|,
name|imgp
operator|->
name|execpathp
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_OSRELDATE
argument_list|,
name|imgp
operator|->
name|proc
operator|->
name|p_ucred
operator|->
name|cr_prison
operator|->
name|pr_osreldate
argument_list|)
expr_stmt|;
if|if
condition|(
name|imgp
operator|->
name|canary
operator|!=
literal|0
condition|)
block|{
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_CANARY
argument_list|,
name|imgp
operator|->
name|canary
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_CANARYLEN
argument_list|,
name|imgp
operator|->
name|canarylen
argument_list|)
expr_stmt|;
block|}
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_NCPUS
argument_list|,
name|mp_ncpus
argument_list|)
expr_stmt|;
if|if
condition|(
name|imgp
operator|->
name|pagesizes
operator|!=
literal|0
condition|)
block|{
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_PAGESIZES
argument_list|,
name|imgp
operator|->
name|pagesizes
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_PAGESIZESLEN
argument_list|,
name|imgp
operator|->
name|pagesizeslen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|imgp
operator|->
name|sysent
operator|->
name|sv_timekeep_base
operator|!=
literal|0
condition|)
block|{
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_TIMEKEEP
argument_list|,
name|imgp
operator|->
name|sysent
operator|->
name|sv_timekeep_base
argument_list|)
expr_stmt|;
block|}
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_STACKPROT
argument_list|,
name|imgp
operator|->
name|sysent
operator|->
name|sv_shared_page_obj
operator|!=
name|NULL
operator|&&
name|imgp
operator|->
name|stack_prot
operator|!=
literal|0
condition|?
name|imgp
operator|->
name|stack_prot
else|:
name|imgp
operator|->
name|sysent
operator|->
name|sv_stackprot
argument_list|)
expr_stmt|;
name|AUXARGS_ENTRY
argument_list|(
name|pos
argument_list|,
name|AT_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|imgp
operator|->
name|auxargs
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|imgp
operator|->
name|auxargs
operator|=
name|NULL
expr_stmt|;
name|base
operator|--
expr_stmt|;
name|suword
argument_list|(
name|base
argument_list|,
operator|(
name|long
operator|)
name|imgp
operator|->
name|args
operator|->
name|argc
argument_list|)
expr_stmt|;
operator|*
name|stack_base
operator|=
operator|(
name|register_t
operator|*
operator|)
name|base
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Code for generating ELF core dumps.  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|segment_callback
function_decl|)
parameter_list|(
name|vm_map_entry_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* Closure for cb_put_phdr(). */
end_comment

begin_struct
struct|struct
name|phdr_closure
block|{
name|Elf_Phdr
modifier|*
name|phdr
decl_stmt|;
comment|/* Program header to fill in */
name|Elf_Off
name|offset
decl_stmt|;
comment|/* Offset of segment in core file */
block|}
struct|;
end_struct

begin_comment
comment|/* Closure for cb_size_segment(). */
end_comment

begin_struct
struct|struct
name|sseg_closure
block|{
name|int
name|count
decl_stmt|;
comment|/* Count of writable segments. */
name|size_t
name|size
decl_stmt|;
comment|/* Total size of all writable segments. */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|outfunc_t
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|sbuf
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|note_info
block|{
name|int
name|type
decl_stmt|;
comment|/* Note type. */
name|outfunc_t
name|outfunc
decl_stmt|;
comment|/* Output function. */
name|void
modifier|*
name|outarg
decl_stmt|;
comment|/* Argument for the output function. */
name|size_t
name|outsize
decl_stmt|;
comment|/* Output size. */
name|TAILQ_ENTRY
argument_list|(
argument|note_info
argument_list|)
name|link
expr_stmt|;
comment|/* Link to the next note info. */
block|}
struct|;
end_struct

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|note_info_list
argument_list|,
name|note_info
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Coredump output parameters. */
end_comment

begin_struct
struct|struct
name|coredump_params
block|{
name|off_t
name|offset
decl_stmt|;
name|struct
name|ucred
modifier|*
name|active_cred
decl_stmt|;
name|struct
name|ucred
modifier|*
name|file_cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|gzio_stream
modifier|*
name|gzs
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|cb_put_phdr
parameter_list|(
name|vm_map_entry_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cb_size_segment
parameter_list|(
name|vm_map_entry_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|core_write
parameter_list|(
name|struct
name|coredump_params
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|off_t
parameter_list|,
name|enum
name|uio_seg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|each_writable_segment
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|segment_callback
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|__elfN
function_decl|(
name|corehdr
function_decl|)
parameter_list|(
name|struct
name|coredump_params
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|note_info_list
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__elfN
function_decl|(
name|prepare_notes
function_decl|)
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|struct
name|note_info_list
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__elfN
function_decl|(
name|puthdr
function_decl|)
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|int
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__elfN
function_decl|(
name|putnote
function_decl|)
parameter_list|(
name|struct
name|note_info
modifier|*
parameter_list|,
name|struct
name|sbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|register_note
parameter_list|(
name|struct
name|note_info_list
modifier|*
parameter_list|,
name|int
parameter_list|,
name|outfunc_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sbuf_drain_core_output
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sbuf_drain_count
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__elfN
function_decl|(
name|note_fpregset
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|sbuf
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__elfN
function_decl|(
name|note_prpsinfo
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|sbuf
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__elfN
function_decl|(
name|note_prstatus
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|sbuf
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__elfN
function_decl|(
name|note_threadmd
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|sbuf
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__elfN
function_decl|(
name|note_thrmisc
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|sbuf
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__elfN
function_decl|(
name|note_procstat_auxv
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|sbuf
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__elfN
function_decl|(
name|note_procstat_proc
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|sbuf
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__elfN
function_decl|(
name|note_procstat_psstrings
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|sbuf
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|note_procstat_files
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|sbuf
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|note_procstat_groups
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|sbuf
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|note_procstat_osrel
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|sbuf
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|note_procstat_rlimit
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|sbuf
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|note_procstat_umask
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|sbuf
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|note_procstat_vmmap
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|sbuf
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|GZIO
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|compress_user_cores_gzlevel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Write out a core segment to the compression stream.  */
end_comment

begin_function
specifier|static
name|int
name|compress_chunk
parameter_list|(
name|struct
name|coredump_params
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|base
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|u_int
name|chunk_len
decl_stmt|;
name|int
name|error
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|chunk_len
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
name|CORE_BUF_SIZE
argument_list|)
expr_stmt|;
comment|/* 		 * We can get EFAULT error here. 		 * In that case zero out the current chunk of the segment. 		 */
name|error
operator|=
name|copyin
argument_list|(
name|base
argument_list|,
name|buf
argument_list|,
name|chunk_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|bzero
argument_list|(
name|buf
argument_list|,
name|chunk_len
argument_list|)
expr_stmt|;
name|error
operator|=
name|gzio_write
argument_list|(
name|p
operator|->
name|gzs
argument_list|,
name|buf
argument_list|,
name|chunk_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|base
operator|+=
name|chunk_len
expr_stmt|;
name|len
operator|-=
name|chunk_len
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|core_gz_write
parameter_list|(
name|void
modifier|*
name|base
parameter_list|,
name|size_t
name|len
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
name|core_write
argument_list|(
operator|(
expr|struct
name|coredump_params
operator|*
operator|)
name|arg
argument_list|,
name|base
argument_list|,
name|len
argument_list|,
name|offset
argument_list|,
name|UIO_SYSSPACE
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GZIO */
end_comment

begin_function
specifier|static
name|int
name|core_write
parameter_list|(
name|struct
name|coredump_params
modifier|*
name|p
parameter_list|,
specifier|const
name|void
modifier|*
name|base
parameter_list|,
name|size_t
name|len
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|enum
name|uio_seg
name|seg
parameter_list|)
block|{
return|return
operator|(
name|vn_rdwr_inchunks
argument_list|(
name|UIO_WRITE
argument_list|,
name|p
operator|->
name|vp
argument_list|,
name|__DECONST
argument_list|(
name|void
operator|*
argument_list|,
name|base
argument_list|)
argument_list|,
name|len
argument_list|,
name|offset
argument_list|,
name|seg
argument_list|,
name|IO_UNIT
operator||
name|IO_DIRECT
operator||
name|IO_RANGELOCKED
argument_list|,
name|p
operator|->
name|active_cred
argument_list|,
name|p
operator|->
name|file_cred
argument_list|,
name|NULL
argument_list|,
name|p
operator|->
name|td
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|core_output
parameter_list|(
name|void
modifier|*
name|base
parameter_list|,
name|size_t
name|len
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|struct
name|coredump_params
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|tmpbuf
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|GZIO
if|if
condition|(
name|p
operator|->
name|gzs
operator|!=
name|NULL
condition|)
return|return
operator|(
name|compress_chunk
argument_list|(
name|p
argument_list|,
name|base
argument_list|,
name|tmpbuf
argument_list|,
name|len
argument_list|)
operator|)
return|;
endif|#
directive|endif
comment|/* 	 * EFAULT is a non-fatal error that we can get, for example, 	 * if the segment is backed by a file but extends beyond its 	 * end. 	 */
name|error
operator|=
name|core_write
argument_list|(
name|p
argument_list|,
name|base
argument_list|,
name|len
argument_list|,
name|offset
argument_list|,
name|UIO_USERSPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EFAULT
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Failed to fully fault in a core file segment "
literal|"at VA %p with size 0x%zx to be written at offset 0x%jx "
literal|"for process %s\n"
argument_list|,
name|base
argument_list|,
name|len
argument_list|,
name|offset
argument_list|,
name|curproc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
comment|/* 		 * Write a "real" zero byte at the end of the target region 		 * in the case this is the last segment. 		 * The intermediate space will be implicitly zero-filled. 		 */
name|error
operator|=
name|core_write
argument_list|(
name|p
argument_list|,
name|zero_region
argument_list|,
literal|1
argument_list|,
name|offset
operator|+
name|len
operator|-
literal|1
argument_list|,
name|UIO_SYSSPACE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Drain into a core file.  */
end_comment

begin_function
specifier|static
name|int
name|sbuf_drain_core_output
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|coredump_params
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|,
name|locked
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|coredump_params
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* 	 * Some kern_proc out routines that print to this sbuf may 	 * call us with the process lock held. Draining with the 	 * non-sleepable lock held is unsafe. The lock is needed for 	 * those routines when dumping a live process. In our case we 	 * can safely release the lock before draining and acquire 	 * again after. 	 */
name|locked
operator|=
name|PROC_LOCKED
argument_list|(
name|p
operator|->
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
condition|)
name|PROC_UNLOCK
argument_list|(
name|p
operator|->
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GZIO
if|if
condition|(
name|p
operator|->
name|gzs
operator|!=
name|NULL
condition|)
name|error
operator|=
name|gzio_write
argument_list|(
name|p
operator|->
name|gzs
argument_list|,
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|data
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|error
operator|=
name|core_write
argument_list|(
name|p
argument_list|,
name|__DECONST
argument_list|(
name|void
operator|*
argument_list|,
name|data
argument_list|)
argument_list|,
name|len
argument_list|,
name|p
operator|->
name|offset
argument_list|,
name|UIO_SYSSPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
condition|)
name|PROC_LOCK
argument_list|(
name|p
operator|->
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
name|error
operator|)
return|;
name|p
operator|->
name|offset
operator|+=
name|len
expr_stmt|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Drain into a counter.  */
end_comment

begin_function
specifier|static
name|int
name|sbuf_drain_count
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|char
modifier|*
name|data
name|__unused
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|size_t
modifier|*
name|sizep
decl_stmt|;
name|sizep
operator|=
operator|(
name|size_t
operator|*
operator|)
name|arg
expr_stmt|;
operator|*
name|sizep
operator|+=
name|len
expr_stmt|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__elfN
function|(
name|coredump
function|)
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|off_t
name|limit
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ucred
modifier|*
name|cred
init|=
name|td
operator|->
name|td_ucred
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|sseg_closure
name|seginfo
decl_stmt|;
name|struct
name|note_info_list
name|notelst
decl_stmt|;
name|struct
name|coredump_params
name|params
decl_stmt|;
name|struct
name|note_info
modifier|*
name|ninfo
decl_stmt|;
name|void
modifier|*
name|hdr
decl_stmt|,
modifier|*
name|tmpbuf
decl_stmt|;
name|size_t
name|hdrsize
decl_stmt|,
name|notesz
decl_stmt|,
name|coresize
decl_stmt|;
ifdef|#
directive|ifdef
name|GZIO
name|boolean_t
name|compress
decl_stmt|;
name|compress
operator|=
operator|(
name|flags
operator|&
name|IMGACT_CORE_COMPRESS
operator|)
operator|!=
literal|0
expr_stmt|;
endif|#
directive|endif
name|hdr
operator|=
name|NULL
expr_stmt|;
name|tmpbuf
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|notelst
argument_list|)
expr_stmt|;
comment|/* Size the program segments. */
name|seginfo
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|seginfo
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|each_writable_segment
argument_list|(
name|td
argument_list|,
name|cb_size_segment
argument_list|,
operator|&
name|seginfo
argument_list|)
expr_stmt|;
comment|/* 	 * Collect info about the core file header area. 	 */
name|hdrsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Ehdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Phdr
argument_list|)
operator|*
operator|(
literal|1
operator|+
name|seginfo
operator|.
name|count
operator|)
expr_stmt|;
name|__elfN
argument_list|(
name|prepare_notes
argument_list|)
argument_list|(
name|td
argument_list|,
operator|&
name|notelst
argument_list|,
operator|&
name|notesz
argument_list|)
expr_stmt|;
name|coresize
operator|=
name|round_page
argument_list|(
name|hdrsize
operator|+
name|notesz
argument_list|)
operator|+
name|seginfo
operator|.
name|size
expr_stmt|;
comment|/* Set up core dump parameters. */
name|params
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|params
operator|.
name|active_cred
operator|=
name|cred
expr_stmt|;
name|params
operator|.
name|file_cred
operator|=
name|NOCRED
expr_stmt|;
name|params
operator|.
name|td
operator|=
name|td
expr_stmt|;
name|params
operator|.
name|vp
operator|=
name|vp
expr_stmt|;
name|params
operator|.
name|gzs
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|RACCT
if|if
condition|(
name|racct_enable
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|error
operator|=
name|racct_add
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|RACCT_CORE
argument_list|,
name|coresize
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|coresize
operator|>=
name|limit
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
ifdef|#
directive|ifdef
name|GZIO
comment|/* Create a compression stream if necessary. */
if|if
condition|(
name|compress
condition|)
block|{
name|params
operator|.
name|gzs
operator|=
name|gzio_init
argument_list|(
name|core_gz_write
argument_list|,
name|GZIO_DEFLATE
argument_list|,
name|CORE_BUF_SIZE
argument_list|,
name|compress_user_cores_gzlevel
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|gzs
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|tmpbuf
operator|=
name|malloc
argument_list|(
name|CORE_BUF_SIZE
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Allocate memory for building the header, fill it up, 	 * and write it out following the notes. 	 */
name|hdr
operator|=
name|malloc
argument_list|(
name|hdrsize
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|__elfN
argument_list|(
name|corehdr
argument_list|)
argument_list|(
operator|&
name|params
argument_list|,
name|seginfo
operator|.
name|count
argument_list|,
name|hdr
argument_list|,
name|hdrsize
argument_list|,
operator|&
name|notelst
argument_list|,
name|notesz
argument_list|)
expr_stmt|;
comment|/* Write the contents of all of the writable segments. */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|Elf_Phdr
modifier|*
name|php
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|php
operator|=
operator|(
name|Elf_Phdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|hdr
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Ehdr
argument_list|)
operator|)
operator|+
literal|1
expr_stmt|;
name|offset
operator|=
name|round_page
argument_list|(
name|hdrsize
operator|+
name|notesz
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seginfo
operator|.
name|count
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|core_output
argument_list|(
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|php
operator|->
name|p_vaddr
argument_list|,
name|php
operator|->
name|p_filesz
argument_list|,
name|offset
argument_list|,
operator|&
name|params
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|offset
operator|+=
name|php
operator|->
name|p_filesz
expr_stmt|;
name|php
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|GZIO
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|compress
condition|)
name|error
operator|=
name|gzio_flush
argument_list|(
name|params
operator|.
name|gzs
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|error
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"Failed to write core file for process %s (error %d)\n"
argument_list|,
name|curproc
operator|->
name|p_comm
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|done
label|:
ifdef|#
directive|ifdef
name|GZIO
if|if
condition|(
name|compress
condition|)
block|{
name|free
argument_list|(
name|tmpbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|gzs
operator|!=
name|NULL
condition|)
name|gzio_fini
argument_list|(
name|params
operator|.
name|gzs
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
operator|(
name|ninfo
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|notelst
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|notelst
argument_list|,
name|ninfo
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ninfo
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hdr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|hdr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A callback for each_writable_segment() to write out the segment's  * program header entry.  */
end_comment

begin_function
specifier|static
name|void
name|cb_put_phdr
parameter_list|(
name|entry
parameter_list|,
name|closure
parameter_list|)
name|vm_map_entry_t
name|entry
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|phdr_closure
modifier|*
name|phc
init|=
operator|(
expr|struct
name|phdr_closure
operator|*
operator|)
name|closure
decl_stmt|;
name|Elf_Phdr
modifier|*
name|phdr
init|=
name|phc
operator|->
name|phdr
decl_stmt|;
name|phc
operator|->
name|offset
operator|=
name|round_page
argument_list|(
name|phc
operator|->
name|offset
argument_list|)
expr_stmt|;
name|phdr
operator|->
name|p_type
operator|=
name|PT_LOAD
expr_stmt|;
name|phdr
operator|->
name|p_offset
operator|=
name|phc
operator|->
name|offset
expr_stmt|;
name|phdr
operator|->
name|p_vaddr
operator|=
name|entry
operator|->
name|start
expr_stmt|;
name|phdr
operator|->
name|p_paddr
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_filesz
operator|=
name|phdr
operator|->
name|p_memsz
operator|=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
name|phdr
operator|->
name|p_align
operator|=
name|PAGE_SIZE
expr_stmt|;
name|phdr
operator|->
name|p_flags
operator|=
name|__elfN
argument_list|(
name|untrans_prot
argument_list|)
argument_list|(
name|entry
operator|->
name|protection
argument_list|)
expr_stmt|;
name|phc
operator|->
name|offset
operator|+=
name|phdr
operator|->
name|p_filesz
expr_stmt|;
name|phc
operator|->
name|phdr
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A callback for each_writable_segment() to gather information about  * the number of segments and their total size.  */
end_comment

begin_function
specifier|static
name|void
name|cb_size_segment
parameter_list|(
name|entry
parameter_list|,
name|closure
parameter_list|)
name|vm_map_entry_t
name|entry
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|sseg_closure
modifier|*
name|ssc
init|=
operator|(
expr|struct
name|sseg_closure
operator|*
operator|)
name|closure
decl_stmt|;
name|ssc
operator|->
name|count
operator|++
expr_stmt|;
name|ssc
operator|->
name|size
operator|+=
name|entry
operator|->
name|end
operator|-
name|entry
operator|->
name|start
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * For each writable segment in the process's memory map, call the given  * function with a pointer to the map entry and some arbitrary  * caller-supplied data.  */
end_comment

begin_function
specifier|static
name|void
name|each_writable_segment
parameter_list|(
name|td
parameter_list|,
name|func
parameter_list|,
name|closure
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|segment_callback
name|func
decl_stmt|;
name|void
modifier|*
name|closure
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|vm_map_t
name|map
init|=
operator|&
name|p
operator|->
name|p_vmspace
operator|->
name|vm_map
decl_stmt|;
name|vm_map_entry_t
name|entry
decl_stmt|;
name|vm_object_t
name|backing_object
decl_stmt|,
name|object
decl_stmt|;
name|boolean_t
name|ignore_entry
decl_stmt|;
name|vm_map_lock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
for|for
control|(
name|entry
operator|=
name|map
operator|->
name|header
operator|.
name|next
init|;
name|entry
operator|!=
operator|&
name|map
operator|->
name|header
condition|;
name|entry
operator|=
name|entry
operator|->
name|next
control|)
block|{
comment|/* 		 * Don't dump inaccessible mappings, deal with legacy 		 * coredump mode. 		 * 		 * Note that read-only segments related to the elf binary 		 * are marked MAP_ENTRY_NOCOREDUMP now so we no longer 		 * need to arbitrarily ignore such segments. 		 */
if|if
condition|(
name|elf_legacy_coredump
condition|)
block|{
if|if
condition|(
operator|(
name|entry
operator|->
name|protection
operator|&
name|VM_PROT_RW
operator|)
operator|!=
name|VM_PROT_RW
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|entry
operator|->
name|protection
operator|&
name|VM_PROT_ALL
operator|)
operator|==
literal|0
condition|)
continue|continue;
block|}
comment|/* 		 * Dont include memory segment in the coredump if 		 * MAP_NOCORE is set in mmap(2) or MADV_NOCORE in 		 * madvise(2).  Do not dump submaps (i.e. parts of the 		 * kernel map). 		 */
if|if
condition|(
name|entry
operator|->
name|eflags
operator|&
operator|(
name|MAP_ENTRY_NOCOREDUMP
operator||
name|MAP_ENTRY_IS_SUB_MAP
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|object
operator|=
name|entry
operator|->
name|object
operator|.
name|vm_object
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Ignore memory-mapped devices and such things. */
name|VM_OBJECT_RLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|backing_object
operator|=
name|object
operator|->
name|backing_object
operator|)
operator|!=
name|NULL
condition|)
block|{
name|VM_OBJECT_RLOCK
argument_list|(
name|backing_object
argument_list|)
expr_stmt|;
name|VM_OBJECT_RUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|object
operator|=
name|backing_object
expr_stmt|;
block|}
name|ignore_entry
operator|=
name|object
operator|->
name|type
operator|!=
name|OBJT_DEFAULT
operator|&&
name|object
operator|->
name|type
operator|!=
name|OBJT_SWAP
operator|&&
name|object
operator|->
name|type
operator|!=
name|OBJT_VNODE
operator|&&
name|object
operator|->
name|type
operator|!=
name|OBJT_PHYS
expr_stmt|;
name|VM_OBJECT_RUNLOCK
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignore_entry
condition|)
continue|continue;
call|(
modifier|*
name|func
call|)
argument_list|(
name|entry
argument_list|,
name|closure
argument_list|)
expr_stmt|;
block|}
name|vm_map_unlock_read
argument_list|(
name|map
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write the core file header to the file, including padding up to  * the page boundary.  */
end_comment

begin_function
specifier|static
name|int
name|__elfN
function|(
name|corehdr
function|)
parameter_list|(
name|struct
name|coredump_params
modifier|*
name|p
parameter_list|,
name|int
name|numsegs
parameter_list|,
name|void
modifier|*
name|hdr
parameter_list|,
name|size_t
name|hdrsize
parameter_list|,
name|struct
name|note_info_list
modifier|*
name|notelst
parameter_list|,
name|size_t
name|notesz
parameter_list|)
block|{
name|struct
name|note_info
modifier|*
name|ninfo
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Fill in the header. */
name|bzero
argument_list|(
name|hdr
argument_list|,
name|hdrsize
argument_list|)
expr_stmt|;
name|__elfN
function_decl|(
name|puthdr
function_decl|)
parameter_list|(
name|p
operator|->
name|td
parameter_list|,
name|hdr
parameter_list|,
name|hdrsize
parameter_list|,
name|numsegs
parameter_list|,
name|notesz
parameter_list|)
function_decl|;
name|sb
operator|=
name|sbuf_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|CORE_BUF_SIZE
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|sbuf_set_drain
argument_list|(
name|sb
argument_list|,
name|sbuf_drain_core_output
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|sbuf_start_section
argument_list|(
name|sb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
name|hdr
argument_list|,
name|hdrsize
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ninfo
argument_list|,
argument|notelst
argument_list|,
argument|link
argument_list|)
name|__elfN
function_decl|(
name|putnote
function_decl|)
parameter_list|(
name|ninfo
parameter_list|,
name|sb
parameter_list|)
function_decl|;
comment|/* Align up to a page boundary for the program segments. */
name|sbuf_end_section
argument_list|(
name|sb
argument_list|,
operator|-
literal|1
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__elfN
function|(
name|prepare_notes
function|)
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|note_info_list
modifier|*
name|list
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|thread
modifier|*
name|thr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
name|size
operator|+=
name|register_note
argument_list|(
name|list
argument_list|,
name|NT_PRPSINFO
argument_list|,
name|__elfN
argument_list|(
name|note_prpsinfo
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* 	 * To have the debugger select the right thread (LWP) as the initial 	 * thread, we dump the state of the thread passed to us in td first. 	 * This is the thread that causes the core dump and thus likely to 	 * be the right thread one wants to have selected in the debugger. 	 */
name|thr
operator|=
name|td
expr_stmt|;
while|while
condition|(
name|thr
operator|!=
name|NULL
condition|)
block|{
name|size
operator|+=
name|register_note
argument_list|(
name|list
argument_list|,
name|NT_PRSTATUS
argument_list|,
name|__elfN
argument_list|(
name|note_prstatus
argument_list|)
argument_list|,
name|thr
argument_list|)
expr_stmt|;
name|size
operator|+=
name|register_note
argument_list|(
name|list
argument_list|,
name|NT_FPREGSET
argument_list|,
name|__elfN
argument_list|(
name|note_fpregset
argument_list|)
argument_list|,
name|thr
argument_list|)
expr_stmt|;
name|size
operator|+=
name|register_note
argument_list|(
name|list
argument_list|,
name|NT_THRMISC
argument_list|,
name|__elfN
argument_list|(
name|note_thrmisc
argument_list|)
argument_list|,
name|thr
argument_list|)
expr_stmt|;
name|size
operator|+=
name|register_note
argument_list|(
name|list
argument_list|,
operator|-
literal|1
argument_list|,
name|__elfN
argument_list|(
name|note_threadmd
argument_list|)
argument_list|,
name|thr
argument_list|)
expr_stmt|;
name|thr
operator|=
operator|(
name|thr
operator|==
name|td
operator|)
condition|?
name|TAILQ_FIRST
argument_list|(
operator|&
name|p
operator|->
name|p_threads
argument_list|)
else|:
name|TAILQ_NEXT
argument_list|(
name|thr
argument_list|,
name|td_plist
argument_list|)
expr_stmt|;
if|if
condition|(
name|thr
operator|==
name|td
condition|)
name|thr
operator|=
name|TAILQ_NEXT
argument_list|(
name|thr
argument_list|,
name|td_plist
argument_list|)
expr_stmt|;
block|}
name|size
operator|+=
name|register_note
argument_list|(
name|list
argument_list|,
name|NT_PROCSTAT_PROC
argument_list|,
name|__elfN
argument_list|(
name|note_procstat_proc
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|size
operator|+=
name|register_note
argument_list|(
name|list
argument_list|,
name|NT_PROCSTAT_FILES
argument_list|,
name|note_procstat_files
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|size
operator|+=
name|register_note
argument_list|(
name|list
argument_list|,
name|NT_PROCSTAT_VMMAP
argument_list|,
name|note_procstat_vmmap
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|size
operator|+=
name|register_note
argument_list|(
name|list
argument_list|,
name|NT_PROCSTAT_GROUPS
argument_list|,
name|note_procstat_groups
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|size
operator|+=
name|register_note
argument_list|(
name|list
argument_list|,
name|NT_PROCSTAT_UMASK
argument_list|,
name|note_procstat_umask
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|size
operator|+=
name|register_note
argument_list|(
name|list
argument_list|,
name|NT_PROCSTAT_RLIMIT
argument_list|,
name|note_procstat_rlimit
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|size
operator|+=
name|register_note
argument_list|(
name|list
argument_list|,
name|NT_PROCSTAT_OSREL
argument_list|,
name|note_procstat_osrel
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|size
operator|+=
name|register_note
argument_list|(
name|list
argument_list|,
name|NT_PROCSTAT_PSSTRINGS
argument_list|,
name|__elfN
argument_list|(
name|note_procstat_psstrings
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|size
operator|+=
name|register_note
argument_list|(
name|list
argument_list|,
name|NT_PROCSTAT_AUXV
argument_list|,
name|__elfN
argument_list|(
name|note_procstat_auxv
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__elfN
function|(
name|puthdr
function|)
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|hdr
parameter_list|,
name|size_t
name|hdrsize
parameter_list|,
name|int
name|numsegs
parameter_list|,
name|size_t
name|notesz
parameter_list|)
block|{
name|Elf_Ehdr
modifier|*
name|ehdr
decl_stmt|;
name|Elf_Phdr
modifier|*
name|phdr
decl_stmt|;
name|struct
name|phdr_closure
name|phc
decl_stmt|;
name|ehdr
operator|=
operator|(
name|Elf_Ehdr
operator|*
operator|)
name|hdr
expr_stmt|;
name|phdr
operator|=
operator|(
name|Elf_Phdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|hdr
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Ehdr
argument_list|)
operator|)
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_MAG0
index|]
operator|=
name|ELFMAG0
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_MAG1
index|]
operator|=
name|ELFMAG1
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_MAG2
index|]
operator|=
name|ELFMAG2
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_MAG3
index|]
operator|=
name|ELFMAG3
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|=
name|ELF_CLASS
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
operator|=
name|ELF_DATA
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_VERSION
index|]
operator|=
name|EV_CURRENT
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
operator|=
name|ELFOSABI_FREEBSD
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_ABIVERSION
index|]
operator|=
literal|0
expr_stmt|;
name|ehdr
operator|->
name|e_ident
index|[
name|EI_PAD
index|]
operator|=
literal|0
expr_stmt|;
name|ehdr
operator|->
name|e_type
operator|=
name|ET_CORE
expr_stmt|;
name|ehdr
operator|->
name|e_machine
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_elf_machine
expr_stmt|;
name|ehdr
operator|->
name|e_version
operator|=
name|EV_CURRENT
expr_stmt|;
name|ehdr
operator|->
name|e_entry
operator|=
literal|0
expr_stmt|;
name|ehdr
operator|->
name|e_phoff
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Ehdr
argument_list|)
expr_stmt|;
name|ehdr
operator|->
name|e_flags
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_elf_flags
expr_stmt|;
name|ehdr
operator|->
name|e_ehsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Ehdr
argument_list|)
expr_stmt|;
name|ehdr
operator|->
name|e_phentsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Phdr
argument_list|)
expr_stmt|;
name|ehdr
operator|->
name|e_phnum
operator|=
name|numsegs
operator|+
literal|1
expr_stmt|;
name|ehdr
operator|->
name|e_shentsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Shdr
argument_list|)
expr_stmt|;
name|ehdr
operator|->
name|e_shnum
operator|=
literal|0
expr_stmt|;
name|ehdr
operator|->
name|e_shstrndx
operator|=
name|SHN_UNDEF
expr_stmt|;
comment|/* 	 * Fill in the program header entries. 	 */
comment|/* The note segement. */
name|phdr
operator|->
name|p_type
operator|=
name|PT_NOTE
expr_stmt|;
name|phdr
operator|->
name|p_offset
operator|=
name|hdrsize
expr_stmt|;
name|phdr
operator|->
name|p_vaddr
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_paddr
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_filesz
operator|=
name|notesz
expr_stmt|;
name|phdr
operator|->
name|p_memsz
operator|=
literal|0
expr_stmt|;
name|phdr
operator|->
name|p_flags
operator|=
name|PF_R
expr_stmt|;
name|phdr
operator|->
name|p_align
operator|=
name|ELF_NOTE_ROUNDSIZE
expr_stmt|;
name|phdr
operator|++
expr_stmt|;
comment|/* All the writable segments from the program. */
name|phc
operator|.
name|phdr
operator|=
name|phdr
expr_stmt|;
name|phc
operator|.
name|offset
operator|=
name|round_page
argument_list|(
name|hdrsize
operator|+
name|notesz
argument_list|)
expr_stmt|;
name|each_writable_segment
argument_list|(
name|td
argument_list|,
name|cb_put_phdr
argument_list|,
operator|&
name|phc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|register_note
parameter_list|(
name|struct
name|note_info_list
modifier|*
name|list
parameter_list|,
name|int
name|type
parameter_list|,
name|outfunc_t
name|out
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|note_info
modifier|*
name|ninfo
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|notesize
decl_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
name|out
argument_list|(
name|arg
argument_list|,
name|NULL
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|ninfo
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ninfo
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ninfo
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|ninfo
operator|->
name|outfunc
operator|=
name|out
expr_stmt|;
name|ninfo
operator|->
name|outarg
operator|=
name|arg
expr_stmt|;
name|ninfo
operator|->
name|outsize
operator|=
name|size
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|list
argument_list|,
name|ninfo
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|size
operator|)
return|;
name|notesize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Note
argument_list|)
operator|+
comment|/* note header */
name|roundup2
argument_list|(
sizeof|sizeof
argument_list|(
name|FREEBSD_ABI_VENDOR
argument_list|)
argument_list|,
name|ELF_NOTE_ROUNDSIZE
argument_list|)
operator|+
comment|/* note name */
name|roundup2
argument_list|(
name|size
argument_list|,
name|ELF_NOTE_ROUNDSIZE
argument_list|)
expr_stmt|;
comment|/* note description */
return|return
operator|(
name|notesize
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|append_note_data
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|size_t
name|padded_len
decl_stmt|;
name|padded_len
operator|=
name|roundup2
argument_list|(
name|len
argument_list|,
name|ELF_NOTE_ROUNDSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dst
operator|+
name|len
argument_list|,
name|padded_len
operator|-
name|len
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|padded_len
operator|)
return|;
block|}
end_function

begin_function
name|size_t
name|__elfN
function|(
name|populate_note
function|)
parameter_list|(
name|int
name|type
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
modifier|*
name|descp
parameter_list|)
block|{
name|Elf_Note
modifier|*
name|note
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|notesize
decl_stmt|;
name|buf
operator|=
name|dst
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
name|note
operator|=
operator|(
name|Elf_Note
operator|*
operator|)
name|buf
expr_stmt|;
name|note
operator|->
name|n_namesz
operator|=
sizeof|sizeof
argument_list|(
name|FREEBSD_ABI_VENDOR
argument_list|)
expr_stmt|;
name|note
operator|->
name|n_descsz
operator|=
name|size
expr_stmt|;
name|note
operator|->
name|n_type
operator|=
name|type
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|note
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|append_note_data
argument_list|(
name|FREEBSD_ABI_VENDOR
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|FREEBSD_ABI_VENDOR
argument_list|)
argument_list|)
expr_stmt|;
name|append_note_data
argument_list|(
name|src
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|descp
operator|!=
name|NULL
condition|)
operator|*
name|descp
operator|=
name|buf
expr_stmt|;
block|}
name|notesize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Note
argument_list|)
operator|+
comment|/* note header */
name|roundup2
argument_list|(
sizeof|sizeof
argument_list|(
name|FREEBSD_ABI_VENDOR
argument_list|)
argument_list|,
name|ELF_NOTE_ROUNDSIZE
argument_list|)
operator|+
comment|/* note name */
name|roundup2
argument_list|(
name|size
argument_list|,
name|ELF_NOTE_ROUNDSIZE
argument_list|)
expr_stmt|;
comment|/* note description */
return|return
operator|(
name|notesize
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__elfN
function|(
name|putnote
function|)
parameter_list|(
name|struct
name|note_info
modifier|*
name|ninfo
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|)
block|{
name|Elf_Note
name|note
decl_stmt|;
name|ssize_t
name|old_len
decl_stmt|,
name|sect_len
decl_stmt|;
name|size_t
name|new_len
decl_stmt|,
name|descsz
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|ninfo
operator|->
name|type
operator|==
operator|-
literal|1
condition|)
block|{
name|ninfo
operator|->
name|outfunc
argument_list|(
name|ninfo
operator|->
name|outarg
argument_list|,
name|sb
argument_list|,
operator|&
name|ninfo
operator|->
name|outsize
argument_list|)
expr_stmt|;
return|return;
block|}
name|note
operator|.
name|n_namesz
operator|=
sizeof|sizeof
argument_list|(
name|FREEBSD_ABI_VENDOR
argument_list|)
expr_stmt|;
name|note
operator|.
name|n_descsz
operator|=
name|ninfo
operator|->
name|outsize
expr_stmt|;
name|note
operator|.
name|n_type
operator|=
name|ninfo
operator|->
name|type
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
operator|&
name|note
argument_list|,
sizeof|sizeof
argument_list|(
name|note
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_start_section
argument_list|(
name|sb
argument_list|,
operator|&
name|old_len
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
name|FREEBSD_ABI_VENDOR
argument_list|,
sizeof|sizeof
argument_list|(
name|FREEBSD_ABI_VENDOR
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_end_section
argument_list|(
name|sb
argument_list|,
name|old_len
argument_list|,
name|ELF_NOTE_ROUNDSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|note
operator|.
name|n_descsz
operator|==
literal|0
condition|)
return|return;
name|sbuf_start_section
argument_list|(
name|sb
argument_list|,
operator|&
name|old_len
argument_list|)
expr_stmt|;
name|ninfo
operator|->
name|outfunc
argument_list|(
name|ninfo
operator|->
name|outarg
argument_list|,
name|sb
argument_list|,
operator|&
name|ninfo
operator|->
name|outsize
argument_list|)
expr_stmt|;
name|sect_len
operator|=
name|sbuf_end_section
argument_list|(
name|sb
argument_list|,
name|old_len
argument_list|,
name|ELF_NOTE_ROUNDSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect_len
operator|<
literal|0
condition|)
return|return;
name|new_len
operator|=
operator|(
name|size_t
operator|)
name|sect_len
expr_stmt|;
name|descsz
operator|=
name|roundup
argument_list|(
name|note
operator|.
name|n_descsz
argument_list|,
name|ELF_NOTE_ROUNDSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_len
operator|<
name|descsz
condition|)
block|{
comment|/* 		 * It is expected that individual note emitters will correctly 		 * predict their expected output size and fill up to that size 		 * themselves, padding in a format-specific way if needed. 		 * However, in case they don't, just do it here with zeros. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|descsz
operator|-
name|new_len
condition|;
name|i
operator|++
control|)
name|sbuf_putc
argument_list|(
name|sb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_len
operator|>
name|descsz
condition|)
block|{
comment|/* 		 * We can't always truncate sb -- we may have drained some 		 * of it already. 		 */
name|KASSERT
argument_list|(
name|new_len
operator|==
name|descsz
argument_list|,
operator|(
literal|"%s: Note type %u changed as we "
literal|"read it (%zu> %zu).  Since it is longer than "
literal|"expected, this coredump's notes are corrupt.  THIS "
literal|"IS A BUG in the note_procstat routine for type %u.\n"
operator|,
name|__func__
operator|,
operator|(
name|unsigned
operator|)
name|note
operator|.
name|n_type
operator|,
name|new_len
operator|,
name|descsz
operator|,
operator|(
name|unsigned
operator|)
name|note
operator|.
name|n_type
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Miscellaneous note out functions.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD32
argument_list|)
operator|&&
name|__ELF_WORD_SIZE
operator|==
literal|32
end_if

begin_include
include|#
directive|include
file|<compat/freebsd32/freebsd32.h>
end_include

begin_typedef
typedef|typedef
name|struct
name|prstatus32
name|elf_prstatus_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|prpsinfo32
name|elf_prpsinfo_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|fpreg32
name|elf_prfpregset_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|fpreg32
name|elf_fpregset_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|reg32
name|elf_gregset_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|thrmisc32
name|elf_thrmisc_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ELF_KERN_PROC_MASK
value|KERN_PROC_MASK32
end_define

begin_typedef
typedef|typedef
name|struct
name|kinfo_proc32
name|elf_kinfo_proc_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint32_t
name|elf_ps_strings_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|prstatus_t
name|elf_prstatus_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|prpsinfo_t
name|elf_prpsinfo_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|prfpregset_t
name|elf_prfpregset_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|prfpregset_t
name|elf_fpregset_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|gregset_t
name|elf_gregset_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|thrmisc_t
name|elf_thrmisc_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ELF_KERN_PROC_MASK
value|0
end_define

begin_typedef
typedef|typedef
name|struct
name|kinfo_proc
name|elf_kinfo_proc_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|vm_offset_t
name|elf_ps_strings_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|__elfN
function|(
name|note_prpsinfo
function|)
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|struct
name|sbuf
name|sbarg
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|elf_prpsinfo_t
modifier|*
name|psinfo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|sb
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|*
name|sizep
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|psinfo
argument_list|)
argument_list|,
operator|(
literal|"invalid size"
operator|)
argument_list|)
expr_stmt|;
name|psinfo
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|psinfo
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|psinfo
operator|->
name|pr_version
operator|=
name|PRPSINFO_VERSION
expr_stmt|;
name|psinfo
operator|->
name|pr_psinfosz
operator|=
sizeof|sizeof
argument_list|(
name|elf_prpsinfo_t
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|psinfo
operator|->
name|pr_fname
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
sizeof|sizeof
argument_list|(
name|psinfo
operator|->
name|pr_fname
argument_list|)
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_args
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
name|psinfo
operator|->
name|pr_psargs
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|p
operator|->
name|p_args
operator|->
name|ar_length
condition|)
name|len
operator|=
name|p
operator|->
name|p_args
operator|->
name|ar_length
expr_stmt|;
name|memcpy
argument_list|(
name|psinfo
operator|->
name|pr_psargs
argument_list|,
name|p
operator|->
name|p_args
operator|->
name|ar_args
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|_PHOLD
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sbuf_new
argument_list|(
operator|&
name|sbarg
argument_list|,
name|psinfo
operator|->
name|pr_psargs
argument_list|,
sizeof|sizeof
argument_list|(
name|psinfo
operator|->
name|pr_psargs
argument_list|)
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|error
operator|=
name|proc_getargv
argument_list|(
name|curthread
argument_list|,
name|p
argument_list|,
operator|&
name|sbarg
argument_list|)
expr_stmt|;
name|PRELE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbuf_finish
argument_list|(
operator|&
name|sbarg
argument_list|)
operator|==
literal|0
condition|)
name|len
operator|=
name|sbuf_len
argument_list|(
operator|&
name|sbarg
argument_list|)
operator|-
literal|1
expr_stmt|;
else|else
name|len
operator|=
sizeof|sizeof
argument_list|(
name|psinfo
operator|->
name|pr_psargs
argument_list|)
operator|-
literal|1
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sbarg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|||
name|len
operator|==
literal|0
condition|)
name|strlcpy
argument_list|(
name|psinfo
operator|->
name|pr_psargs
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
sizeof|sizeof
argument_list|(
name|psinfo
operator|->
name|pr_psargs
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|KASSERT
argument_list|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|psinfo
operator|->
name|pr_psargs
argument_list|)
argument_list|,
operator|(
literal|"len is too long: %zu vs %zu"
operator|,
name|len
operator|,
sizeof|sizeof
argument_list|(
name|psinfo
operator|->
name|pr_psargs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|psinfo
operator|->
name|pr_psargs
expr_stmt|;
name|end
operator|=
name|cp
operator|+
name|len
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cp
operator|=
name|memchr
argument_list|(
name|cp
argument_list|,
literal|'\0'
argument_list|,
name|end
operator|-
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
break|break;
operator|*
name|cp
operator|=
literal|' '
expr_stmt|;
block|}
block|}
name|psinfo
operator|->
name|pr_pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
name|psinfo
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|psinfo
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|psinfo
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
operator|*
name|sizep
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|psinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__elfN
function|(
name|note_prstatus
function|)
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|elf_prstatus_t
modifier|*
name|status
decl_stmt|;
name|td
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|sb
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|*
name|sizep
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|status
argument_list|)
argument_list|,
operator|(
literal|"invalid size"
operator|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|status
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|status
operator|->
name|pr_version
operator|=
name|PRSTATUS_VERSION
expr_stmt|;
name|status
operator|->
name|pr_statussz
operator|=
sizeof|sizeof
argument_list|(
name|elf_prstatus_t
argument_list|)
expr_stmt|;
name|status
operator|->
name|pr_gregsetsz
operator|=
sizeof|sizeof
argument_list|(
name|elf_gregset_t
argument_list|)
expr_stmt|;
name|status
operator|->
name|pr_fpregsetsz
operator|=
sizeof|sizeof
argument_list|(
name|elf_fpregset_t
argument_list|)
expr_stmt|;
name|status
operator|->
name|pr_osreldate
operator|=
name|osreldate
expr_stmt|;
name|status
operator|->
name|pr_cursig
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_sig
expr_stmt|;
name|status
operator|->
name|pr_pid
operator|=
name|td
operator|->
name|td_tid
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD32
argument_list|)
operator|&&
name|__ELF_WORD_SIZE
operator|==
literal|32
name|fill_regs32
argument_list|(
name|td
argument_list|,
operator|&
name|status
operator|->
name|pr_reg
argument_list|)
expr_stmt|;
else|#
directive|else
name|fill_regs
argument_list|(
name|td
argument_list|,
operator|&
name|status
operator|->
name|pr_reg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
name|status
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|status
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
operator|*
name|sizep
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__elfN
function|(
name|note_fpregset
function|)
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|elf_prfpregset_t
modifier|*
name|fpregset
decl_stmt|;
name|td
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|sb
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|*
name|sizep
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|fpregset
argument_list|)
argument_list|,
operator|(
literal|"invalid size"
operator|)
argument_list|)
expr_stmt|;
name|fpregset
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|fpregset
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD32
argument_list|)
operator|&&
name|__ELF_WORD_SIZE
operator|==
literal|32
name|fill_fpregs32
argument_list|(
name|td
argument_list|,
name|fpregset
argument_list|)
expr_stmt|;
else|#
directive|else
name|fill_fpregs
argument_list|(
name|td
argument_list|,
name|fpregset
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
name|fpregset
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fpregset
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fpregset
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
operator|*
name|sizep
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|fpregset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__elfN
function|(
name|note_thrmisc
function|)
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|elf_thrmisc_t
name|thrmisc
decl_stmt|;
name|td
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|sb
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|*
name|sizep
operator|==
sizeof|sizeof
argument_list|(
name|thrmisc
argument_list|)
argument_list|,
operator|(
literal|"invalid size"
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|thrmisc
operator|.
name|_pad
argument_list|,
sizeof|sizeof
argument_list|(
name|thrmisc
operator|.
name|_pad
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|thrmisc
operator|.
name|pr_tname
argument_list|,
name|td
operator|->
name|td_name
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
operator|&
name|thrmisc
argument_list|,
sizeof|sizeof
argument_list|(
name|thrmisc
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|sizep
operator|=
sizeof|sizeof
argument_list|(
name|thrmisc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allow for MD specific notes, as well as any MD  * specific preparations for writing MI notes.  */
end_comment

begin_function
specifier|static
name|void
name|__elfN
function|(
name|note_threadmd
function|)
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|td
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|arg
expr_stmt|;
name|size
operator|=
operator|*
name|sizep
expr_stmt|;
if|if
condition|(
name|size
operator|!=
literal|0
operator|&&
name|sb
operator|!=
name|NULL
condition|)
name|buf
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_TEMP
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
name|NULL
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
name|__elfN
argument_list|(
name|dump_thread
argument_list|)
argument_list|(
name|td
argument_list|,
name|buf
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sb
operator|==
name|NULL
operator|||
operator|*
name|sizep
operator|==
name|size
argument_list|,
operator|(
literal|"invalid size"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
literal|0
operator|&&
name|sb
operator|!=
name|NULL
condition|)
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KINFO_PROC_SIZE
end_ifdef

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_proc
argument_list|)
operator|==
name|KINFO_PROC_SIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|__elfN
function|(
name|note_procstat_proc
function|)
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|structsize
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|arg
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
operator|+
name|p
operator|->
name|p_numthreads
operator|*
sizeof|sizeof
argument_list|(
name|elf_kinfo_proc_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|*
name|sizep
operator|==
name|size
argument_list|,
operator|(
literal|"invalid size"
operator|)
argument_list|)
expr_stmt|;
name|structsize
operator|=
sizeof|sizeof
argument_list|(
name|elf_kinfo_proc_t
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
operator|&
name|structsize
argument_list|,
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
argument_list|)
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|kern_proc_out
argument_list|(
name|p
argument_list|,
name|sb
argument_list|,
name|ELF_KERN_PROC_MASK
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
block|}
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KINFO_FILE_SIZE
end_ifdef

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_file
argument_list|)
operator|==
name|KINFO_FILE_SIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|note_procstat_files
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|sect_sz
decl_stmt|,
name|i
decl_stmt|;
name|ssize_t
name|start_len
decl_stmt|,
name|sect_len
decl_stmt|;
name|int
name|structsize
decl_stmt|,
name|filedesc_flags
decl_stmt|;
if|if
condition|(
name|coredump_pack_fileinfo
condition|)
name|filedesc_flags
operator|=
name|KERN_FILEDESC_PACK_KINFO
expr_stmt|;
else|else
name|filedesc_flags
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|arg
expr_stmt|;
name|structsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
name|sb
operator|=
name|sbuf_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|sbuf_set_drain
argument_list|(
name|sb
argument_list|,
name|sbuf_drain_count
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
operator|&
name|structsize
argument_list|,
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|kern_proc_filedesc_out
argument_list|(
name|p
argument_list|,
name|sb
argument_list|,
operator|-
literal|1
argument_list|,
name|filedesc_flags
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
name|sbuf_start_section
argument_list|(
name|sb
argument_list|,
operator|&
name|start_len
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
operator|&
name|structsize
argument_list|,
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|kern_proc_filedesc_out
argument_list|(
name|p
argument_list|,
name|sb
argument_list|,
operator|*
name|sizep
operator|-
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
argument_list|,
name|filedesc_flags
argument_list|)
expr_stmt|;
name|sect_len
operator|=
name|sbuf_end_section
argument_list|(
name|sb
argument_list|,
name|start_len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect_len
operator|<
literal|0
condition|)
return|return;
name|sect_sz
operator|=
name|sect_len
expr_stmt|;
name|KASSERT
argument_list|(
name|sect_sz
operator|<=
operator|*
name|sizep
argument_list|,
operator|(
literal|"kern_proc_filedesc_out did not respect maxlen; "
literal|"requested %zu, got %zu"
operator|,
operator|*
name|sizep
operator|-
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
operator|,
name|sect_sz
operator|-
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|sizep
operator|-
name|sect_sz
operator|&&
name|sb
operator|->
name|s_error
operator|==
literal|0
condition|;
name|i
operator|++
control|)
name|sbuf_putc
argument_list|(
name|sb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KINFO_VMENTRY_SIZE
end_ifdef

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_vmentry
argument_list|)
operator|==
name|KINFO_VMENTRY_SIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|note_procstat_vmmap
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|structsize
decl_stmt|,
name|vmmap_flags
decl_stmt|;
if|if
condition|(
name|coredump_pack_vmmapinfo
condition|)
name|vmmap_flags
operator|=
name|KERN_VMMAP_PACK_KINFO
expr_stmt|;
else|else
name|vmmap_flags
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|arg
expr_stmt|;
name|structsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_vmentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
name|sb
operator|=
name|sbuf_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|sbuf_set_drain
argument_list|(
name|sb
argument_list|,
name|sbuf_drain_count
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
operator|&
name|structsize
argument_list|,
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|kern_proc_vmmap_out
argument_list|(
name|p
argument_list|,
name|sb
argument_list|,
operator|-
literal|1
argument_list|,
name|vmmap_flags
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
operator|&
name|structsize
argument_list|,
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|kern_proc_vmmap_out
argument_list|(
name|p
argument_list|,
name|sb
argument_list|,
operator|*
name|sizep
operator|-
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
argument_list|,
name|vmmap_flags
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|note_procstat_groups
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|structsize
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|arg
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
operator|+
name|p
operator|->
name|p_ucred
operator|->
name|cr_ngroups
operator|*
sizeof|sizeof
argument_list|(
name|gid_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|*
name|sizep
operator|==
name|size
argument_list|,
operator|(
literal|"invalid size"
operator|)
argument_list|)
expr_stmt|;
name|structsize
operator|=
sizeof|sizeof
argument_list|(
name|gid_t
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
operator|&
name|structsize
argument_list|,
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
name|p
operator|->
name|p_ucred
operator|->
name|cr_groups
argument_list|,
name|p
operator|->
name|p_ucred
operator|->
name|cr_ngroups
operator|*
sizeof|sizeof
argument_list|(
name|gid_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|note_procstat_umask
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|structsize
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|arg
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|p
operator|->
name|p_fd
operator|->
name|fd_cmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|*
name|sizep
operator|==
name|size
argument_list|,
operator|(
literal|"invalid size"
operator|)
argument_list|)
expr_stmt|;
name|structsize
operator|=
sizeof|sizeof
argument_list|(
name|p
operator|->
name|p_fd
operator|->
name|fd_cmask
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
operator|&
name|structsize
argument_list|,
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
operator|&
name|p
operator|->
name|p_fd
operator|->
name|fd_cmask
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|p_fd
operator|->
name|fd_cmask
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|note_procstat_rlimit
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|rlimit
name|rlim
index|[
name|RLIM_NLIMITS
index|]
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|structsize
decl_stmt|,
name|i
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|arg
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|rlim
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|*
name|sizep
operator|==
name|size
argument_list|,
operator|(
literal|"invalid size"
operator|)
argument_list|)
expr_stmt|;
name|structsize
operator|=
sizeof|sizeof
argument_list|(
name|rlim
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
operator|&
name|structsize
argument_list|,
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RLIM_NLIMITS
condition|;
name|i
operator|++
control|)
name|lim_rlimit_proc
argument_list|(
name|p
argument_list|,
name|i
argument_list|,
operator|&
name|rlim
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
name|rlim
argument_list|,
sizeof|sizeof
argument_list|(
name|rlim
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|note_procstat_osrel
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|structsize
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|arg
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|p
operator|->
name|p_osrel
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|*
name|sizep
operator|==
name|size
argument_list|,
operator|(
literal|"invalid size"
operator|)
argument_list|)
expr_stmt|;
name|structsize
operator|=
sizeof|sizeof
argument_list|(
name|p
operator|->
name|p_osrel
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
operator|&
name|structsize
argument_list|,
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
operator|&
name|p
operator|->
name|p_osrel
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|p_osrel
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__elfN
function|(
name|note_procstat_psstrings
function|)
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|elf_ps_strings_t
name|ps_strings
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|structsize
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|arg
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ps_strings
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|*
name|sizep
operator|==
name|size
argument_list|,
operator|(
literal|"invalid size"
operator|)
argument_list|)
expr_stmt|;
name|structsize
operator|=
sizeof|sizeof
argument_list|(
name|ps_strings
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD32
argument_list|)
operator|&&
name|__ELF_WORD_SIZE
operator|==
literal|32
name|ps_strings
operator|=
name|PTROUT
argument_list|(
name|p
operator|->
name|p_sysent
operator|->
name|sv_psstrings
argument_list|)
expr_stmt|;
else|#
directive|else
name|ps_strings
operator|=
name|p
operator|->
name|p_sysent
operator|->
name|sv_psstrings
expr_stmt|;
endif|#
directive|endif
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
operator|&
name|structsize
argument_list|,
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
operator|&
name|ps_strings
argument_list|,
sizeof|sizeof
argument_list|(
name|ps_strings
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__elfN
function|(
name|note_procstat_auxv
function|)
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|sbuf
modifier|*
name|sb
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|structsize
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
name|sb
operator|=
name|sbuf_new
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|128
argument_list|,
name|SBUF_FIXEDLEN
argument_list|)
expr_stmt|;
name|sbuf_set_drain
argument_list|(
name|sb
argument_list|,
name|sbuf_drain_count
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
operator|&
name|structsize
argument_list|,
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
argument_list|)
expr_stmt|;
name|PHOLD
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|proc_getauxv
argument_list|(
name|curthread
argument_list|,
name|p
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|PRELE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
name|structsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Auxinfo
argument_list|)
expr_stmt|;
name|sbuf_bcat
argument_list|(
name|sb
argument_list|,
operator|&
name|structsize
argument_list|,
sizeof|sizeof
argument_list|(
name|structsize
argument_list|)
argument_list|)
expr_stmt|;
name|PHOLD
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|proc_getauxv
argument_list|(
name|curthread
argument_list|,
name|p
argument_list|,
name|sb
argument_list|)
expr_stmt|;
name|PRELE
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|__elfN
function|(
name|parse_notes
function|)
parameter_list|(
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|,
name|Elf_Brandnote
modifier|*
name|checknote
parameter_list|,
name|int32_t
modifier|*
name|osrel
parameter_list|,
specifier|const
name|Elf_Phdr
modifier|*
name|pnote
parameter_list|)
block|{
specifier|const
name|Elf_Note
modifier|*
name|note
decl_stmt|,
modifier|*
name|note0
decl_stmt|,
modifier|*
name|note_end
decl_stmt|;
specifier|const
name|char
modifier|*
name|note_name
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|boolean_t
name|res
decl_stmt|;
comment|/* We need some limit, might as well use PAGE_SIZE. */
if|if
condition|(
name|pnote
operator|==
name|NULL
operator|||
name|pnote
operator|->
name|p_filesz
operator|>
name|PAGE_SIZE
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|imgp
operator|->
name|vp
argument_list|,
literal|"parse_notes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pnote
operator|->
name|p_offset
operator|>
name|PAGE_SIZE
operator|||
name|pnote
operator|->
name|p_filesz
operator|>
name|PAGE_SIZE
operator|-
name|pnote
operator|->
name|p_offset
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|imgp
operator|->
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|pnote
operator|->
name|p_filesz
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|imgp
operator|->
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|imgp
operator|->
name|vp
argument_list|,
name|buf
argument_list|,
name|pnote
operator|->
name|p_filesz
argument_list|,
name|pnote
operator|->
name|p_offset
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|IO_NODELOCKED
argument_list|,
name|curthread
operator|->
name|td_ucred
argument_list|,
name|NOCRED
argument_list|,
name|NULL
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|uprintf
argument_list|(
literal|"i/o error PT_NOTE\n"
argument_list|)
expr_stmt|;
name|res
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|note
operator|=
name|note0
operator|=
operator|(
specifier|const
name|Elf_Note
operator|*
operator|)
name|buf
expr_stmt|;
name|note_end
operator|=
operator|(
specifier|const
name|Elf_Note
operator|*
operator|)
operator|(
name|buf
operator|+
name|pnote
operator|->
name|p_filesz
operator|)
expr_stmt|;
block|}
else|else
block|{
name|note
operator|=
name|note0
operator|=
operator|(
specifier|const
name|Elf_Note
operator|*
operator|)
operator|(
name|imgp
operator|->
name|image_header
operator|+
name|pnote
operator|->
name|p_offset
operator|)
expr_stmt|;
name|note_end
operator|=
operator|(
specifier|const
name|Elf_Note
operator|*
operator|)
operator|(
name|imgp
operator|->
name|image_header
operator|+
name|pnote
operator|->
name|p_offset
operator|+
name|pnote
operator|->
name|p_filesz
operator|)
expr_stmt|;
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|100
operator|&&
name|note
operator|>=
name|note0
operator|&&
name|note
operator|<
name|note_end
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|aligned
argument_list|(
name|note
argument_list|,
name|Elf32_Addr
argument_list|)
operator|||
operator|(
specifier|const
name|char
operator|*
operator|)
name|note_end
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
name|note
operator|<
sizeof|sizeof
argument_list|(
name|Elf_Note
argument_list|)
condition|)
block|{
name|res
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|note
operator|->
name|n_namesz
operator|!=
name|checknote
operator|->
name|hdr
operator|.
name|n_namesz
operator|||
name|note
operator|->
name|n_descsz
operator|!=
name|checknote
operator|->
name|hdr
operator|.
name|n_descsz
operator|||
name|note
operator|->
name|n_type
operator|!=
name|checknote
operator|->
name|hdr
operator|.
name|n_type
condition|)
goto|goto
name|nextnote
goto|;
name|note_name
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|note
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|note_name
operator|+
name|checknote
operator|->
name|hdr
operator|.
name|n_namesz
operator|>=
operator|(
specifier|const
name|char
operator|*
operator|)
name|note_end
operator|||
name|strncmp
argument_list|(
name|checknote
operator|->
name|vendor
argument_list|,
name|note_name
argument_list|,
name|checknote
operator|->
name|hdr
operator|.
name|n_namesz
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|nextnote
goto|;
comment|/* 		 * Fetch the osreldate for binary 		 * from the ELF OSABI-note if necessary. 		 */
if|if
condition|(
operator|(
name|checknote
operator|->
name|flags
operator|&
name|BN_TRANSLATE_OSREL
operator|)
operator|!=
literal|0
operator|&&
name|checknote
operator|->
name|trans_osrel
operator|!=
name|NULL
condition|)
block|{
name|res
operator|=
name|checknote
operator|->
name|trans_osrel
argument_list|(
name|note
argument_list|,
name|osrel
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|res
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|ret
goto|;
name|nextnote
label|:
name|note
operator|=
operator|(
specifier|const
name|Elf_Note
operator|*
operator|)
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|note
operator|+
literal|1
operator|)
operator|+
name|roundup2
argument_list|(
name|note
operator|->
name|n_namesz
argument_list|,
name|ELF_NOTE_ROUNDSIZE
argument_list|)
operator|+
name|roundup2
argument_list|(
name|note
operator|->
name|n_descsz
argument_list|,
name|ELF_NOTE_ROUNDSIZE
argument_list|)
operator|)
expr_stmt|;
block|}
name|res
operator|=
name|FALSE
expr_stmt|;
name|ret
label|:
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to find the appropriate ABI-note section for checknote,  * fetch the osreldate for binary from the ELF OSABI-note. Only the  * first page of the image is searched, the same as for headers.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|__elfN
function|(
name|check_note
function|)
parameter_list|(
name|struct
name|image_params
modifier|*
name|imgp
parameter_list|,
name|Elf_Brandnote
modifier|*
name|checknote
parameter_list|,
name|int32_t
modifier|*
name|osrel
parameter_list|)
block|{
specifier|const
name|Elf_Phdr
modifier|*
name|phdr
decl_stmt|;
specifier|const
name|Elf_Ehdr
modifier|*
name|hdr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|hdr
operator|=
operator|(
specifier|const
name|Elf_Ehdr
operator|*
operator|)
name|imgp
operator|->
name|image_header
expr_stmt|;
name|phdr
operator|=
operator|(
specifier|const
name|Elf_Phdr
operator|*
operator|)
operator|(
name|imgp
operator|->
name|image_header
operator|+
name|hdr
operator|->
name|e_phoff
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hdr
operator|->
name|e_phnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|phdr
index|[
name|i
index|]
operator|.
name|p_type
operator|==
name|PT_NOTE
operator|&&
name|__elfN
argument_list|(
name|parse_notes
argument_list|)
argument_list|(
name|imgp
argument_list|,
name|checknote
argument_list|,
name|osrel
argument_list|,
operator|&
name|phdr
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Tell kern_execve.c about it, with a little help from the linker.  */
end_comment

begin_function_decl
specifier|static
name|struct
name|execsw
name|__elfN
parameter_list|(
name|execsw
parameter_list|)
init|=
block|{
name|__CONCAT
argument_list|(
name|exec_
argument_list|,
name|__elfN
argument_list|(
name|imgact
argument_list|)
argument_list|)
operator|,
function_decl|__XSTRING
parameter_list|(
function_decl|__CONCAT
parameter_list|(
name|ELF
parameter_list|,
name|__ELF_WORD_SIZE
parameter_list|)
end_function_decl

begin_expr_stmt
unit|) };
name|EXEC_SET
argument_list|(
name|__CONCAT
argument_list|(
name|elf
argument_list|,
name|__ELF_WORD_SIZE
argument_list|)
argument_list|,
name|__elfN
argument_list|(
name|execsw
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|vm_prot_t
name|__elfN
function|(
name|trans_prot
function|)
parameter_list|(
name|Elf_Word
name|flags
parameter_list|)
block|{
name|vm_prot_t
name|prot
decl_stmt|;
name|prot
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PF_X
condition|)
name|prot
operator||=
name|VM_PROT_EXECUTE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PF_W
condition|)
name|prot
operator||=
name|VM_PROT_WRITE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PF_R
condition|)
name|prot
operator||=
name|VM_PROT_READ
expr_stmt|;
if|#
directive|if
name|__ELF_WORD_SIZE
operator|==
literal|32
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
if|if
condition|(
name|i386_read_exec
operator|&&
operator|(
name|flags
operator|&
name|PF_R
operator|)
condition|)
name|prot
operator||=
name|VM_PROT_EXECUTE
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
return|return
operator|(
name|prot
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|Elf_Word
name|__elfN
function|(
name|untrans_prot
function|)
parameter_list|(
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|Elf_Word
name|flags
decl_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prot
operator|&
name|VM_PROT_EXECUTE
condition|)
name|flags
operator||=
name|PF_X
expr_stmt|;
if|if
condition|(
name|prot
operator|&
name|VM_PROT_READ
condition|)
name|flags
operator||=
name|PF_R
expr_stmt|;
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
name|flags
operator||=
name|PF_W
expr_stmt|;
return|return
operator|(
name|flags
operator|)
return|;
block|}
end_function

end_unit

