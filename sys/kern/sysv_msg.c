begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Implementation of SVID messages  *  * Author:  Daniel Boulet  *  * Copyright 1993 Daniel Boulet and RTMX Inc.  *  * This system call was implemented by Daniel Boulet under contract from RTMX.  *  * Redistribution and use in source forms, with and without modification,  * are permitted provided that this entire comment appears intact.  *  * Redistribution in binary form may occur without any restrictions.  * Obviously, it would be nice if you gave credit where credit is due  * but requiring it would be too onerous.  *  * This software is provided ``AS IS'' without any warranties of any kind.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2003-2005 McAfee, Inc.  * Copyright (c) 2016-2017 Robert N. M. Watson  * All rights reserved.  *  * This software was developed for the FreeBSD Project in part by McAfee  * Research, the Security Research Division of McAfee, Inc under DARPA/SPAWAR  * contract N66001-01-C-8035 ("CBOSS"), as part of the DARPA CHATS research  * program.  *  * Portions of this software were developed by BAE Systems, the University of  * Cambridge Computer Laboratory, and Memorial University under DARPA/AFRL  * contract FA8650-15-C-7558 ("CADETS"), as part of the DARPA Transparent  * Computing (TC) research program.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_sysvipc.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/msg.h>
end_include

begin_include
include|#
directive|include
file|<sys/racct.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<security/audit/audit.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_expr_stmt
name|FEATURE
argument_list|(
name|sysv_msg
argument_list|,
literal|"System V message queues support"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_MSG
argument_list|,
literal|"msg"
argument_list|,
literal|"SVID compatible message queues"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|msginit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msgunload
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysvmsg_modload
parameter_list|(
name|struct
name|module
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msq_remove
parameter_list|(
name|struct
name|msqid_kernel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|prison
modifier|*
name|msg_find_prison
parameter_list|(
name|struct
name|ucred
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msq_prison_cansee
parameter_list|(
name|struct
name|prison
modifier|*
parameter_list|,
name|struct
name|msqid_kernel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msg_prison_check
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msg_prison_set
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msg_prison_get
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|msg_prison_remove
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|msg_prison_cleanup
parameter_list|(
name|struct
name|prison
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MSG_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|a
parameter_list|)
value|printf a
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|a
parameter_list|)
value|(void)0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|msg_freehdr
parameter_list|(
name|struct
name|msg
modifier|*
name|msghdr
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|MSGSSZ
end_ifndef

begin_define
define|#
directive|define
name|MSGSSZ
value|8
end_define

begin_comment
comment|/* Each segment must be 2^N long */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MSGSEG
end_ifndef

begin_define
define|#
directive|define
name|MSGSEG
value|2048
end_define

begin_comment
comment|/* must be less than 32767 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MSGMAX
value|(MSGSSZ*MSGSEG)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MSGMNB
end_ifndef

begin_define
define|#
directive|define
name|MSGMNB
value|2048
end_define

begin_comment
comment|/* max # of bytes in a queue */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MSGMNI
end_ifndef

begin_define
define|#
directive|define
name|MSGMNI
value|40
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MSGTQL
end_ifndef

begin_define
define|#
directive|define
name|MSGTQL
value|40
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Based on the configuration parameters described in an SVR2 (yes, two)  * config(1m) man page.  *  * Each message is broken up and stored in segments that are msgssz bytes  * long.  For efficiency reasons, this should be a power of two.  Also,  * it doesn't make sense if it is less than 8 or greater than about 256.  * Consequently, msginit in kern/sysv_msg.c checks that msgssz is a power of  * two between 8 and 1024 inclusive (and panic's if it isn't).  */
end_comment

begin_decl_stmt
name|struct
name|msginfo
name|msginfo
init|=
block|{
name|MSGMAX
block|,
comment|/* max chars in a message */
name|MSGMNI
block|,
comment|/* # of message queue identifiers */
name|MSGMNB
block|,
comment|/* max chars in a queue */
name|MSGTQL
block|,
comment|/* max messages in system */
name|MSGSSZ
block|,
comment|/* size of a message segment */
comment|/* (must be small power of 2 greater than 4) */
name|MSGSEG
comment|/* number of message segments */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * macros to convert between msqid_ds's and msqid's.  * (specific to this implementation)  */
end_comment

begin_define
define|#
directive|define
name|MSQID
parameter_list|(
name|ix
parameter_list|,
name|ds
parameter_list|)
value|((ix)& 0xffff | (((ds).msg_perm.seq<< 16)& 0xffff0000))
end_define

begin_define
define|#
directive|define
name|MSQID_IX
parameter_list|(
name|id
parameter_list|)
value|((id)& 0xffff)
end_define

begin_define
define|#
directive|define
name|MSQID_SEQ
parameter_list|(
name|id
parameter_list|)
value|(((id)>> 16)& 0xffff)
end_define

begin_comment
comment|/*  * The rest of this file is specific to this particular implementation.  */
end_comment

begin_struct
struct|struct
name|msgmap
block|{
name|short
name|next
decl_stmt|;
comment|/* next segment in buffer */
comment|/* -1 -> available */
comment|/* 0..(MSGSEG-1) -> index of next segment */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MSG_LOCKED
value|01000
end_define

begin_comment
comment|/* Is this msqid_ds locked? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nfree_msgmaps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of free map entries */
end_comment

begin_decl_stmt
specifier|static
name|short
name|free_msgmaps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* head of linked list of free map entries */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|msg
modifier|*
name|free_msghdrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of free msg headers */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|msgpool
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MSGMAX byte long msg buffer pool */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|msgmap
modifier|*
name|msgmaps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MSGSEG msgmap structures */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|msg
modifier|*
name|msghdrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MSGTQL msg headers */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|msqid_kernel
modifier|*
name|msqids
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MSGMNI msqid_kernel struct's */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|msq_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* global mutex for message queues. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|msg_prison_slot
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* prison OSD slot */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|syscall_helper_data
name|msg_syscalls
index|[]
init|=
block|{
name|SYSCALL_INIT_HELPER
argument_list|(
name|msgctl
argument_list|)
block|,
name|SYSCALL_INIT_HELPER
argument_list|(
name|msgget
argument_list|)
block|,
name|SYSCALL_INIT_HELPER
argument_list|(
name|msgsnd
argument_list|)
block|,
name|SYSCALL_INIT_HELPER
argument_list|(
name|msgrcv
argument_list|)
block|,
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD4
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD5
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|COMPAT_FREEBSD6
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD7
argument_list|)
name|SYSCALL_INIT_HELPER
argument_list|(
name|msgsys
argument_list|)
block|,
name|SYSCALL_INIT_HELPER_COMPAT
argument_list|(
name|freebsd7_msgctl
argument_list|)
block|,
endif|#
directive|endif
name|SYSCALL_INIT_LAST
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
end_ifdef

begin_include
include|#
directive|include
file|<compat/freebsd32/freebsd32.h>
end_include

begin_include
include|#
directive|include
file|<compat/freebsd32/freebsd32_ipc.h>
end_include

begin_include
include|#
directive|include
file|<compat/freebsd32/freebsd32_proto.h>
end_include

begin_include
include|#
directive|include
file|<compat/freebsd32/freebsd32_signal.h>
end_include

begin_include
include|#
directive|include
file|<compat/freebsd32/freebsd32_syscall.h>
end_include

begin_include
include|#
directive|include
file|<compat/freebsd32/freebsd32_util.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|syscall_helper_data
name|msg32_syscalls
index|[]
init|=
block|{
name|SYSCALL32_INIT_HELPER
argument_list|(
name|freebsd32_msgctl
argument_list|)
block|,
name|SYSCALL32_INIT_HELPER
argument_list|(
name|freebsd32_msgsnd
argument_list|)
block|,
name|SYSCALL32_INIT_HELPER
argument_list|(
name|freebsd32_msgrcv
argument_list|)
block|,
name|SYSCALL32_INIT_HELPER_COMPAT
argument_list|(
name|msgget
argument_list|)
block|,
name|SYSCALL32_INIT_HELPER
argument_list|(
name|freebsd32_msgsys
argument_list|)
block|,
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD4
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD5
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|COMPAT_FREEBSD6
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD7
argument_list|)
name|SYSCALL32_INIT_HELPER
argument_list|(
name|freebsd7_freebsd32_msgctl
argument_list|)
block|,
endif|#
directive|endif
name|SYSCALL_INIT_LAST
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|msginit
parameter_list|()
block|{
name|struct
name|prison
modifier|*
name|pr
decl_stmt|;
name|void
modifier|*
modifier|*
name|rsv
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|osd_method_t
name|methods
index|[
name|PR_MAXMETHOD
index|]
init|=
block|{
index|[
name|PR_METHOD_CHECK
index|]
operator|=
name|msg_prison_check
block|,
index|[
name|PR_METHOD_SET
index|]
operator|=
name|msg_prison_set
block|,
index|[
name|PR_METHOD_GET
index|]
operator|=
name|msg_prison_get
block|,
index|[
name|PR_METHOD_REMOVE
index|]
operator|=
name|msg_prison_remove
block|, 	}
decl_stmt|;
name|msginfo
operator|.
name|msgmax
operator|=
name|msginfo
operator|.
name|msgseg
operator|*
name|msginfo
operator|.
name|msgssz
expr_stmt|;
name|msgpool
operator|=
name|malloc
argument_list|(
name|msginfo
operator|.
name|msgmax
argument_list|,
name|M_MSG
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|msgmaps
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msgmap
argument_list|)
operator|*
name|msginfo
operator|.
name|msgseg
argument_list|,
name|M_MSG
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|msghdrs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msg
argument_list|)
operator|*
name|msginfo
operator|.
name|msgtql
argument_list|,
name|M_MSG
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|msqids
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msqid_kernel
argument_list|)
operator|*
name|msginfo
operator|.
name|msgmni
argument_list|,
name|M_MSG
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * msginfo.msgssz should be a power of two for efficiency reasons. 	 * It is also pretty silly if msginfo.msgssz is less than 8 	 * or greater than about 256 so ... 	 */
name|i
operator|=
literal|8
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|1024
operator|&&
name|i
operator|!=
name|msginfo
operator|.
name|msgssz
condition|)
name|i
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|msginfo
operator|.
name|msgssz
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"msginfo.msgssz=%d (0x%x)\n"
operator|,
name|msginfo
operator|.
name|msgssz
operator|,
name|msginfo
operator|.
name|msgssz
operator|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"msginfo.msgssz not a small power of 2"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msginfo
operator|.
name|msgseg
operator|>
literal|32767
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"msginfo.msgseg=%d\n"
operator|,
name|msginfo
operator|.
name|msgseg
operator|)
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"msginfo.msgseg> 32767"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msginfo
operator|.
name|msgseg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|msgmaps
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|next
operator|=
name|i
expr_stmt|;
name|msgmaps
index|[
name|i
index|]
operator|.
name|next
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* implies entry is available */
block|}
name|free_msgmaps
operator|=
literal|0
expr_stmt|;
name|nfree_msgmaps
operator|=
name|msginfo
operator|.
name|msgseg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msginfo
operator|.
name|msgtql
condition|;
name|i
operator|++
control|)
block|{
name|msghdrs
index|[
name|i
index|]
operator|.
name|msg_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|msghdrs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|msg_next
operator|=
operator|&
name|msghdrs
index|[
name|i
index|]
expr_stmt|;
name|msghdrs
index|[
name|i
index|]
operator|.
name|msg_next
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_sysvmsg_init
argument_list|(
operator|&
name|msghdrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|free_msghdrs
operator|=
operator|&
name|msghdrs
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msginfo
operator|.
name|msgmni
condition|;
name|i
operator|++
control|)
block|{
name|msqids
index|[
name|i
index|]
operator|.
name|u
operator|.
name|msg_qbytes
operator|=
literal|0
expr_stmt|;
comment|/* implies entry is available */
name|msqids
index|[
name|i
index|]
operator|.
name|u
operator|.
name|msg_perm
operator|.
name|seq
operator|=
literal|0
expr_stmt|;
comment|/* reset to a known value */
name|msqids
index|[
name|i
index|]
operator|.
name|u
operator|.
name|msg_perm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_sysvmsq_init
argument_list|(
operator|&
name|msqids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|mtx_init
argument_list|(
operator|&
name|msq_mtx
argument_list|,
literal|"msq"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* Set current prisons according to their allow.sysvipc. */
name|msg_prison_slot
operator|=
name|osd_jail_register
argument_list|(
name|NULL
argument_list|,
name|methods
argument_list|)
expr_stmt|;
name|rsv
operator|=
name|osd_reserve
argument_list|(
name|msg_prison_slot
argument_list|)
expr_stmt|;
name|prison_lock
argument_list|(
operator|&
name|prison0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|osd_jail_set_reserved
argument_list|(
operator|&
name|prison0
argument_list|,
name|msg_prison_slot
argument_list|,
name|rsv
argument_list|,
operator|&
name|prison0
argument_list|)
expr_stmt|;
name|prison_unlock
argument_list|(
operator|&
name|prison0
argument_list|)
expr_stmt|;
name|rsv
operator|=
name|NULL
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|allprison_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pr
argument_list|,
argument|&allprison
argument_list|,
argument|pr_list
argument_list|)
block|{
if|if
condition|(
name|rsv
operator|==
name|NULL
condition|)
name|rsv
operator|=
name|osd_reserve
argument_list|(
name|msg_prison_slot
argument_list|)
expr_stmt|;
name|prison_lock
argument_list|(
name|pr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pr
operator|->
name|pr_allow
operator|&
name|PR_ALLOW_SYSVIPC
operator|)
operator|&&
name|pr
operator|->
name|pr_ref
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|osd_jail_set_reserved
argument_list|(
name|pr
argument_list|,
name|msg_prison_slot
argument_list|,
name|rsv
argument_list|,
operator|&
name|prison0
argument_list|)
expr_stmt|;
name|rsv
operator|=
name|NULL
expr_stmt|;
block|}
name|prison_unlock
argument_list|(
name|pr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rsv
operator|!=
name|NULL
condition|)
name|osd_free_reserved
argument_list|(
name|rsv
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|allprison_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|syscall_helper_register
argument_list|(
name|msg_syscalls
argument_list|,
name|SY_THR_STATIC_KLD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
name|error
operator|=
name|syscall32_helper_register
argument_list|(
name|msg32_syscalls
argument_list|,
name|SY_THR_STATIC_KLD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msgunload
parameter_list|()
block|{
name|struct
name|msqid_kernel
modifier|*
name|msqkptr
decl_stmt|;
name|int
name|msqid
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|syscall_helper_unregister
argument_list|(
name|msg_syscalls
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
name|syscall32_helper_unregister
argument_list|(
name|msg32_syscalls
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|msqid
operator|=
literal|0
init|;
name|msqid
operator|<
name|msginfo
operator|.
name|msgmni
condition|;
name|msqid
operator|++
control|)
block|{
name|msqkptr
operator|=
operator|&
name|msqids
index|[
name|msqid
index|]
expr_stmt|;
if|if
condition|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_qbytes
operator|!=
literal|0
operator|||
operator|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|mode
operator|&
name|MSG_LOCKED
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|msqid
operator|!=
name|msginfo
operator|.
name|msgmni
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|msg_prison_slot
operator|!=
literal|0
condition|)
name|osd_jail_deregister
argument_list|(
name|msg_prison_slot
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msginfo
operator|.
name|msgtql
condition|;
name|i
operator|++
control|)
name|mac_sysvmsg_destroy
argument_list|(
operator|&
name|msghdrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|msqid
operator|=
literal|0
init|;
name|msqid
operator|<
name|msginfo
operator|.
name|msgmni
condition|;
name|msqid
operator|++
control|)
name|mac_sysvmsq_destroy
argument_list|(
operator|&
name|msqids
index|[
name|msqid
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|msgpool
argument_list|,
name|M_MSG
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msgmaps
argument_list|,
name|M_MSG
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msghdrs
argument_list|,
name|M_MSG
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msqids
argument_list|,
name|M_MSG
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|msq_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysvmsg_modload
parameter_list|(
name|struct
name|module
modifier|*
name|module
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|error
operator|=
name|msginit
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|msgunload
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|error
operator|=
name|msgunload
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|sysvmsg_mod
init|=
block|{
literal|"sysvmsg"
block|,
operator|&
name|sysvmsg_modload
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|sysvmsg
argument_list|,
name|sysvmsg_mod
argument_list|,
name|SI_SUB_SYSV_MSG
argument_list|,
name|SI_ORDER_FIRST
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|sysvmsg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|msg_freehdr
parameter_list|(
name|msghdr
parameter_list|)
name|struct
name|msg
modifier|*
name|msghdr
decl_stmt|;
block|{
while|while
condition|(
name|msghdr
operator|->
name|msg_ts
operator|>
literal|0
condition|)
block|{
name|short
name|next
decl_stmt|;
if|if
condition|(
name|msghdr
operator|->
name|msg_spot
operator|<
literal|0
operator|||
name|msghdr
operator|->
name|msg_spot
operator|>=
name|msginfo
operator|.
name|msgseg
condition|)
name|panic
argument_list|(
literal|"msghdr->msg_spot out of range"
argument_list|)
expr_stmt|;
name|next
operator|=
name|msgmaps
index|[
name|msghdr
operator|->
name|msg_spot
index|]
operator|.
name|next
expr_stmt|;
name|msgmaps
index|[
name|msghdr
operator|->
name|msg_spot
index|]
operator|.
name|next
operator|=
name|free_msgmaps
expr_stmt|;
name|free_msgmaps
operator|=
name|msghdr
operator|->
name|msg_spot
expr_stmt|;
name|nfree_msgmaps
operator|++
expr_stmt|;
name|msghdr
operator|->
name|msg_spot
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|msghdr
operator|->
name|msg_ts
operator|>=
name|msginfo
operator|.
name|msgssz
condition|)
name|msghdr
operator|->
name|msg_ts
operator|-=
name|msginfo
operator|.
name|msgssz
expr_stmt|;
else|else
name|msghdr
operator|->
name|msg_ts
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|msghdr
operator|->
name|msg_spot
operator|!=
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"msghdr->msg_spot != -1"
argument_list|)
expr_stmt|;
name|msghdr
operator|->
name|msg_next
operator|=
name|free_msghdrs
expr_stmt|;
name|free_msghdrs
operator|=
name|msghdr
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_sysvmsg_cleanup
argument_list|(
name|msghdr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|msq_remove
parameter_list|(
name|struct
name|msqid_kernel
modifier|*
name|msqkptr
parameter_list|)
block|{
name|struct
name|msg
modifier|*
name|msghdr
decl_stmt|;
name|racct_sub_cred
argument_list|(
name|msqkptr
operator|->
name|cred
argument_list|,
name|RACCT_NMSGQ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|racct_sub_cred
argument_list|(
name|msqkptr
operator|->
name|cred
argument_list|,
name|RACCT_MSGQQUEUED
argument_list|,
name|msqkptr
operator|->
name|u
operator|.
name|msg_qnum
argument_list|)
expr_stmt|;
name|racct_sub_cred
argument_list|(
name|msqkptr
operator|->
name|cred
argument_list|,
name|RACCT_MSGQSIZE
argument_list|,
name|msqkptr
operator|->
name|u
operator|.
name|msg_cbytes
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|msqkptr
operator|->
name|cred
argument_list|)
expr_stmt|;
name|msqkptr
operator|->
name|cred
operator|=
name|NULL
expr_stmt|;
comment|/* Free the message headers */
name|msghdr
operator|=
name|msqkptr
operator|->
name|u
operator|.
name|msg_first
expr_stmt|;
while|while
condition|(
name|msghdr
operator|!=
name|NULL
condition|)
block|{
name|struct
name|msg
modifier|*
name|msghdr_tmp
decl_stmt|;
comment|/* Free the segments of each message */
name|msqkptr
operator|->
name|u
operator|.
name|msg_cbytes
operator|-=
name|msghdr
operator|->
name|msg_ts
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_qnum
operator|--
expr_stmt|;
name|msghdr_tmp
operator|=
name|msghdr
expr_stmt|;
name|msghdr
operator|=
name|msghdr
operator|->
name|msg_next
expr_stmt|;
name|msg_freehdr
argument_list|(
name|msghdr_tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_cbytes
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"msg_cbytes is screwed up"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_qnum
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"msg_qnum is screwed up"
argument_list|)
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_qbytes
operator|=
literal|0
expr_stmt|;
comment|/* Mark it as free */
ifdef|#
directive|ifdef
name|MAC
name|mac_sysvmsq_cleanup
argument_list|(
name|msqkptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wakeup
argument_list|(
name|msqkptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|prison
modifier|*
name|msg_find_prison
parameter_list|(
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{
name|struct
name|prison
modifier|*
name|pr
decl_stmt|,
modifier|*
name|rpr
decl_stmt|;
name|pr
operator|=
name|cred
operator|->
name|cr_prison
expr_stmt|;
name|prison_lock
argument_list|(
name|pr
argument_list|)
expr_stmt|;
name|rpr
operator|=
name|osd_jail_get
argument_list|(
name|pr
argument_list|,
name|msg_prison_slot
argument_list|)
expr_stmt|;
name|prison_unlock
argument_list|(
name|pr
argument_list|)
expr_stmt|;
return|return
name|rpr
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msq_prison_cansee
parameter_list|(
name|struct
name|prison
modifier|*
name|rpr
parameter_list|,
name|struct
name|msqid_kernel
modifier|*
name|msqkptr
parameter_list|)
block|{
if|if
condition|(
name|msqkptr
operator|->
name|cred
operator|==
name|NULL
operator|||
operator|!
operator|(
name|rpr
operator|==
name|msqkptr
operator|->
name|cred
operator|->
name|cr_prison
operator|||
name|prison_ischild
argument_list|(
name|rpr
argument_list|,
name|msqkptr
operator|->
name|cred
operator|->
name|cr_prison
argument_list|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|msgctl_args
block|{
name|int
name|msqid
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|struct
name|msqid_ds
modifier|*
name|buf
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sys_msgctl
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|msgctl_args
modifier|*
name|uap
parameter_list|)
block|{
name|int
name|msqid
init|=
name|uap
operator|->
name|msqid
decl_stmt|;
name|int
name|cmd
init|=
name|uap
operator|->
name|cmd
decl_stmt|;
name|struct
name|msqid_ds
name|msqbuf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"call to msgctl(%d, %d, %p)\n"
operator|,
name|msqid
operator|,
name|cmd
operator|,
name|uap
operator|->
name|buf
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|IPC_SET
operator|&&
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|buf
argument_list|,
operator|&
name|msqbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msqbuf
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|kern_msgctl
argument_list|(
name|td
argument_list|,
name|msqid
argument_list|,
name|cmd
argument_list|,
operator|&
name|msqbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|IPC_STAT
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|msqbuf
argument_list|,
name|uap
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msqid_ds
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kern_msgctl
parameter_list|(
name|td
parameter_list|,
name|msqid
parameter_list|,
name|cmd
parameter_list|,
name|msqbuf
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|msqid
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|struct
name|msqid_ds
modifier|*
name|msqbuf
decl_stmt|;
block|{
name|int
name|rval
decl_stmt|,
name|error
decl_stmt|,
name|msqix
decl_stmt|;
name|struct
name|msqid_kernel
modifier|*
name|msqkptr
decl_stmt|;
name|struct
name|prison
modifier|*
name|rpr
decl_stmt|;
name|rpr
operator|=
name|msg_find_prison
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
name|AUDIT_ARG_SVIPC_CMD
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|AUDIT_ARG_SVIPC_ID
argument_list|(
name|msqid
argument_list|)
expr_stmt|;
name|msqix
operator|=
name|IPCID_TO_IX
argument_list|(
name|msqid
argument_list|)
expr_stmt|;
if|if
condition|(
name|msqix
operator|<
literal|0
operator|||
name|msqix
operator|>=
name|msginfo
operator|.
name|msgmni
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"msqid (%d) out of range (0<=msqid<%d)\n"
operator|,
name|msqix
operator|,
name|msginfo
operator|.
name|msgmni
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|msqkptr
operator|=
operator|&
name|msqids
index|[
name|msqix
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|msq_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_qbytes
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"no such msqid\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|seq
operator|!=
name|IPCID_TO_SEQ
argument_list|(
name|msqid
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"wrong sequence number\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|error
operator|=
name|msq_prison_cansee
argument_list|(
name|rpr
argument_list|,
name|msqkptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"requester can't see prison\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_sysvmsq_check_msqctl
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|msqkptr
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
endif|#
directive|endif
name|error
operator|=
literal|0
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|IPC_RMID
case|:
block|{
ifdef|#
directive|ifdef
name|MAC
name|struct
name|msg
modifier|*
name|msghdr
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
argument_list|,
name|IPC_M
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
ifdef|#
directive|ifdef
name|MAC
comment|/* 		 * Check that the thread has MAC access permissions to 		 * individual msghdrs.  Note: We need to do this in a 		 * separate loop because the actual loop alters the 		 * msq/msghdr info as it progresses, and there is no going 		 * back if half the way through we discover that the 		 * thread cannot free a certain msghdr.  The msq will get 		 * into an inconsistent state. 		 */
for|for
control|(
name|msghdr
operator|=
name|msqkptr
operator|->
name|u
operator|.
name|msg_first
init|;
name|msghdr
operator|!=
name|NULL
condition|;
name|msghdr
operator|=
name|msghdr
operator|->
name|msg_next
control|)
block|{
name|error
operator|=
name|mac_sysvmsq_check_msgrmid
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|msghdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
block|}
endif|#
directive|endif
name|msq_remove
argument_list|(
name|msqkptr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IPC_SET
case|:
name|AUDIT_ARG_SVIPC_PERM
argument_list|(
operator|&
name|msqbuf
operator|->
name|msg_perm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
argument_list|,
name|IPC_M
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
name|msqbuf
operator|->
name|msg_qbytes
operator|>
name|msqkptr
operator|->
name|u
operator|.
name|msg_qbytes
condition|)
block|{
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_IPC_MSGSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
name|msqbuf
operator|->
name|msg_qbytes
operator|>
name|msginfo
operator|.
name|msgmnb
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"can't increase msg_qbytes beyond %d"
literal|"(truncating)\n"
operator|,
name|msginfo
operator|.
name|msgmnb
operator|)
argument_list|)
expr_stmt|;
name|msqbuf
operator|->
name|msg_qbytes
operator|=
name|msginfo
operator|.
name|msgmnb
expr_stmt|;
comment|/* silently restrict qbytes to system limit */
block|}
if|if
condition|(
name|msqbuf
operator|->
name|msg_qbytes
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"can't reduce msg_qbytes to 0\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* non-standard errno! */
goto|goto
name|done2
goto|;
block|}
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|uid
operator|=
name|msqbuf
operator|->
name|msg_perm
operator|.
name|uid
expr_stmt|;
comment|/* change the owner */
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|gid
operator|=
name|msqbuf
operator|->
name|msg_perm
operator|.
name|gid
expr_stmt|;
comment|/* change the owner */
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|mode
operator|=
operator|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|mode
operator|&
operator|~
literal|0777
operator|)
operator||
operator|(
name|msqbuf
operator|->
name|msg_perm
operator|.
name|mode
operator|&
literal|0777
operator|)
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_qbytes
operator|=
name|msqbuf
operator|->
name|msg_qbytes
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_ctime
operator|=
name|time_second
expr_stmt|;
break|break;
case|case
name|IPC_STAT
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"requester doesn't have read access\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
operator|*
name|msqbuf
operator|=
name|msqkptr
operator|->
name|u
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_ucred
operator|->
name|cr_prison
operator|!=
name|msqkptr
operator|->
name|cred
operator|->
name|cr_prison
condition|)
name|msqbuf
operator|->
name|msg_perm
operator|.
name|key
operator|=
name|IPC_PRIVATE
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
operator|(
literal|"invalid command %d\n"
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|rval
expr_stmt|;
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|msq_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|msgget_args
block|{
name|key_t
name|key
decl_stmt|;
name|int
name|msgflg
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sys_msgget
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|msgget_args
modifier|*
name|uap
parameter_list|)
block|{
name|int
name|msqid
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|key
init|=
name|uap
operator|->
name|key
decl_stmt|;
name|int
name|msgflg
init|=
name|uap
operator|->
name|msgflg
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|td
operator|->
name|td_ucred
decl_stmt|;
name|struct
name|msqid_kernel
modifier|*
name|msqkptr
init|=
name|NULL
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"msgget(0x%x, 0%o)\n"
operator|,
name|key
operator|,
name|msgflg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg_find_prison
argument_list|(
name|cred
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|msq_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|IPC_PRIVATE
condition|)
block|{
for|for
control|(
name|msqid
operator|=
literal|0
init|;
name|msqid
operator|<
name|msginfo
operator|.
name|msgmni
condition|;
name|msqid
operator|++
control|)
block|{
name|msqkptr
operator|=
operator|&
name|msqids
index|[
name|msqid
index|]
expr_stmt|;
if|if
condition|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_qbytes
operator|!=
literal|0
operator|&&
name|msqkptr
operator|->
name|cred
operator|!=
name|NULL
operator|&&
name|msqkptr
operator|->
name|cred
operator|->
name|cr_prison
operator|==
name|cred
operator|->
name|cr_prison
operator|&&
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|key
operator|==
name|key
condition|)
break|break;
block|}
if|if
condition|(
name|msqid
operator|<
name|msginfo
operator|.
name|msgmni
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"found public key\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msgflg
operator|&
name|IPC_CREAT
operator|)
operator|&&
operator|(
name|msgflg
operator|&
name|IPC_EXCL
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"not exclusive\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|AUDIT_ARG_SVIPC_ID
argument_list|(
name|IXSEQ_TO_IPCID
argument_list|(
name|msqid
argument_list|,
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
argument_list|,
name|msgflg
operator|&
literal|0700
argument_list|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"requester doesn't have 0%o access\n"
operator|,
name|msgflg
operator|&
literal|0700
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_sysvmsq_check_msqget
argument_list|(
name|cred
argument_list|,
name|msqkptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
endif|#
directive|endif
goto|goto
name|found
goto|;
block|}
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"need to allocate the msqid_ds\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|IPC_PRIVATE
operator|||
operator|(
name|msgflg
operator|&
name|IPC_CREAT
operator|)
condition|)
block|{
for|for
control|(
name|msqid
operator|=
literal|0
init|;
name|msqid
operator|<
name|msginfo
operator|.
name|msgmni
condition|;
name|msqid
operator|++
control|)
block|{
comment|/* 			 * Look for an unallocated and unlocked msqid_ds. 			 * msqid_ds's can be locked by msgsnd or msgrcv while 			 * they are copying the message in/out.  We can't 			 * re-use the entry until they release it. 			 */
name|msqkptr
operator|=
operator|&
name|msqids
index|[
name|msqid
index|]
expr_stmt|;
if|if
condition|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_qbytes
operator|==
literal|0
operator|&&
operator|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|mode
operator|&
name|MSG_LOCKED
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|msqid
operator|==
name|msginfo
operator|.
name|msgmni
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"no more msqid_ds's available\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
ifdef|#
directive|ifdef
name|RACCT
if|if
condition|(
name|racct_enable
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|error
operator|=
name|racct_add
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|RACCT_NMSGQ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
block|}
endif|#
directive|endif
name|DPRINTF
argument_list|(
operator|(
literal|"msqid %d is available\n"
operator|,
name|msqid
operator|)
argument_list|)
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|cuid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|uid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|cgid
operator|=
name|cred
operator|->
name|cr_gid
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|gid
operator|=
name|cred
operator|->
name|cr_gid
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|mode
operator|=
operator|(
name|msgflg
operator|&
literal|0777
operator|)
expr_stmt|;
name|msqkptr
operator|->
name|cred
operator|=
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
comment|/* Make sure that the returned msqid is unique */
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|seq
operator|=
operator|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|seq
operator|+
literal|1
operator|)
operator|&
literal|0x7fff
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_first
operator|=
name|NULL
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_last
operator|=
name|NULL
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_cbytes
operator|=
literal|0
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_qnum
operator|=
literal|0
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_qbytes
operator|=
name|msginfo
operator|.
name|msgmnb
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_lspid
operator|=
literal|0
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_lrpid
operator|=
literal|0
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_stime
operator|=
literal|0
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_rtime
operator|=
literal|0
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_ctime
operator|=
name|time_second
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_sysvmsq_create
argument_list|(
name|cred
argument_list|,
name|msqkptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|AUDIT_ARG_SVIPC_PERM
argument_list|(
operator|&
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"didn't find it and wasn't asked to create it\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|found
label|:
comment|/* Construct the unique msqid */
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|IXSEQ_TO_IPCID
argument_list|(
name|msqid
argument_list|,
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
argument_list|)
expr_stmt|;
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|msq_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|msgsnd_args
block|{
name|int
name|msqid
decl_stmt|;
specifier|const
name|void
modifier|*
name|msgp
decl_stmt|;
comment|/* XXX msgp is actually mtext. */
name|size_t
name|msgsz
decl_stmt|;
name|int
name|msgflg
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|kern_msgsnd
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|msqid
parameter_list|,
specifier|const
name|void
modifier|*
name|msgp
parameter_list|,
name|size_t
name|msgsz
parameter_list|,
name|int
name|msgflg
parameter_list|,
name|long
name|mtype
parameter_list|)
block|{
name|int
name|msqix
decl_stmt|,
name|segs_needed
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|msqid_kernel
modifier|*
name|msqkptr
decl_stmt|;
name|struct
name|msg
modifier|*
name|msghdr
decl_stmt|;
name|struct
name|prison
modifier|*
name|rpr
decl_stmt|;
name|short
name|next
decl_stmt|;
ifdef|#
directive|ifdef
name|RACCT
name|size_t
name|saved_msgsz
decl_stmt|;
endif|#
directive|endif
name|rpr
operator|=
name|msg_find_prison
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|msq_mtx
argument_list|)
expr_stmt|;
name|AUDIT_ARG_SVIPC_ID
argument_list|(
name|msqid
argument_list|)
expr_stmt|;
name|msqix
operator|=
name|IPCID_TO_IX
argument_list|(
name|msqid
argument_list|)
expr_stmt|;
if|if
condition|(
name|msqix
operator|<
literal|0
operator|||
name|msqix
operator|>=
name|msginfo
operator|.
name|msgmni
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"msqid (%d) out of range (0<=msqid<%d)\n"
operator|,
name|msqix
operator|,
name|msginfo
operator|.
name|msgmni
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|msqkptr
operator|=
operator|&
name|msqids
index|[
name|msqix
index|]
expr_stmt|;
name|AUDIT_ARG_SVIPC_PERM
argument_list|(
operator|&
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
argument_list|)
expr_stmt|;
if|if
condition|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_qbytes
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"no such message queue id\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|seq
operator|!=
name|IPCID_TO_SEQ
argument_list|(
name|msqid
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"wrong sequence number\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|msq_prison_cansee
argument_list|(
name|rpr
argument_list|,
name|msqkptr
argument_list|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"requester can't see prison\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
argument_list|,
name|IPC_W
argument_list|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"requester doesn't have write access\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_sysvmsq_check_msqsnd
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|msqkptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RACCT
if|if
condition|(
name|racct_enable
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|racct_add
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|RACCT_MSGQQUEUED
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|saved_msgsz
operator|=
name|msgsz
expr_stmt|;
if|if
condition|(
name|racct_add
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|RACCT_MSGQSIZE
argument_list|,
name|msgsz
argument_list|)
condition|)
block|{
name|racct_sub
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|RACCT_MSGQQUEUED
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|segs_needed
operator|=
name|howmany
argument_list|(
name|msgsz
argument_list|,
name|msginfo
operator|.
name|msgssz
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"msgsz=%zu, msgssz=%d, segs_needed=%d\n"
operator|,
name|msgsz
operator|,
name|msginfo
operator|.
name|msgssz
operator|,
name|segs_needed
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|need_more_resources
init|=
literal|0
decl_stmt|;
comment|/* 		 * check msgsz 		 * (inside this loop in case msg_qbytes changes while we sleep) 		 */
if|if
condition|(
name|msgsz
operator|>
name|msqkptr
operator|->
name|u
operator|.
name|msg_qbytes
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"msgsz> msqkptr->u.msg_qbytes\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done3
goto|;
block|}
if|if
condition|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|mode
operator|&
name|MSG_LOCKED
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"msqid is locked\n"
operator|)
argument_list|)
expr_stmt|;
name|need_more_resources
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|msgsz
operator|+
name|msqkptr
operator|->
name|u
operator|.
name|msg_cbytes
operator|>
name|msqkptr
operator|->
name|u
operator|.
name|msg_qbytes
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"msgsz + msg_cbytes> msg_qbytes\n"
operator|)
argument_list|)
expr_stmt|;
name|need_more_resources
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|segs_needed
operator|>
name|nfree_msgmaps
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"segs_needed> nfree_msgmaps\n"
operator|)
argument_list|)
expr_stmt|;
name|need_more_resources
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|free_msghdrs
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"no more msghdrs\n"
operator|)
argument_list|)
expr_stmt|;
name|need_more_resources
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|need_more_resources
condition|)
block|{
name|int
name|we_own_it
decl_stmt|;
if|if
condition|(
operator|(
name|msgflg
operator|&
name|IPC_NOWAIT
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"need more resources but caller "
literal|"doesn't want to wait\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|done3
goto|;
block|}
if|if
condition|(
operator|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|mode
operator|&
name|MSG_LOCKED
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"we don't own the msqid_ds\n"
operator|)
argument_list|)
expr_stmt|;
name|we_own_it
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Force later arrivals to wait for our 				   request */
name|DPRINTF
argument_list|(
operator|(
literal|"we own the msqid_ds\n"
operator|)
argument_list|)
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|mode
operator||=
name|MSG_LOCKED
expr_stmt|;
name|we_own_it
operator|=
literal|1
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"msgsnd:  goodnight\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
name|msqkptr
argument_list|,
operator|&
name|msq_mtx
argument_list|,
operator|(
name|PZERO
operator|-
literal|4
operator|)
operator||
name|PCATCH
argument_list|,
literal|"msgsnd"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"msgsnd:  good morning, error=%d\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|we_own_it
condition|)
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|mode
operator|&=
operator|~
name|MSG_LOCKED
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"msgsnd:  timed out\n"
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"msgsnd:  interrupted system call\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|done3
goto|;
block|}
comment|/* 			 * Make sure that the msq queue still exists 			 */
if|if
condition|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_qbytes
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"msqid deleted\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIDRM
expr_stmt|;
goto|goto
name|done3
goto|;
block|}
block|}
else|else
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"got all the resources that we need\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * We have the resources that we need. 	 * Make sure! 	 */
if|if
condition|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|mode
operator|&
name|MSG_LOCKED
condition|)
name|panic
argument_list|(
literal|"msg_perm.mode& MSG_LOCKED"
argument_list|)
expr_stmt|;
if|if
condition|(
name|segs_needed
operator|>
name|nfree_msgmaps
condition|)
name|panic
argument_list|(
literal|"segs_needed> nfree_msgmaps"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgsz
operator|+
name|msqkptr
operator|->
name|u
operator|.
name|msg_cbytes
operator|>
name|msqkptr
operator|->
name|u
operator|.
name|msg_qbytes
condition|)
name|panic
argument_list|(
literal|"msgsz + msg_cbytes> msg_qbytes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_msghdrs
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"no more msghdrs"
argument_list|)
expr_stmt|;
comment|/* 	 * Re-lock the msqid_ds in case we page-fault when copying in the 	 * message 	 */
if|if
condition|(
operator|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|mode
operator|&
name|MSG_LOCKED
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"msqid_ds is already locked"
argument_list|)
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|mode
operator||=
name|MSG_LOCKED
expr_stmt|;
comment|/* 	 * Allocate a message header 	 */
name|msghdr
operator|=
name|free_msghdrs
expr_stmt|;
name|free_msghdrs
operator|=
name|msghdr
operator|->
name|msg_next
expr_stmt|;
name|msghdr
operator|->
name|msg_spot
operator|=
operator|-
literal|1
expr_stmt|;
name|msghdr
operator|->
name|msg_ts
operator|=
name|msgsz
expr_stmt|;
name|msghdr
operator|->
name|msg_type
operator|=
name|mtype
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
comment|/* 	 * XXXMAC: Should the mac_sysvmsq_check_msgmsq check follow here 	 * immediately?  Or, should it be checked just before the msg is 	 * enqueued in the msgq (as it is done now)? 	 */
name|mac_sysvmsg_create
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|msqkptr
argument_list|,
name|msghdr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Allocate space for the message 	 */
while|while
condition|(
name|segs_needed
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|nfree_msgmaps
operator|<=
literal|0
condition|)
name|panic
argument_list|(
literal|"not enough msgmaps"
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_msgmaps
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"nil free_msgmaps"
argument_list|)
expr_stmt|;
name|next
operator|=
name|free_msgmaps
expr_stmt|;
if|if
condition|(
name|next
operator|<=
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"next too low #1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|>=
name|msginfo
operator|.
name|msgseg
condition|)
name|panic
argument_list|(
literal|"next out of range #1"
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"allocating segment %d to message\n"
operator|,
name|next
operator|)
argument_list|)
expr_stmt|;
name|free_msgmaps
operator|=
name|msgmaps
index|[
name|next
index|]
operator|.
name|next
expr_stmt|;
name|nfree_msgmaps
operator|--
expr_stmt|;
name|msgmaps
index|[
name|next
index|]
operator|.
name|next
operator|=
name|msghdr
operator|->
name|msg_spot
expr_stmt|;
name|msghdr
operator|->
name|msg_spot
operator|=
name|next
expr_stmt|;
name|segs_needed
operator|--
expr_stmt|;
block|}
comment|/* 	 * Validate the message type 	 */
if|if
condition|(
name|msghdr
operator|->
name|msg_type
operator|<
literal|1
condition|)
block|{
name|msg_freehdr
argument_list|(
name|msghdr
argument_list|)
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|mode
operator|&=
operator|~
name|MSG_LOCKED
expr_stmt|;
name|wakeup
argument_list|(
name|msqkptr
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"mtype (%ld)< 1\n"
operator|,
name|msghdr
operator|->
name|msg_type
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done3
goto|;
block|}
comment|/* 	 * Copy in the message body 	 */
name|next
operator|=
name|msghdr
operator|->
name|msg_spot
expr_stmt|;
while|while
condition|(
name|msgsz
operator|>
literal|0
condition|)
block|{
name|size_t
name|tlen
decl_stmt|;
if|if
condition|(
name|msgsz
operator|>
name|msginfo
operator|.
name|msgssz
condition|)
name|tlen
operator|=
name|msginfo
operator|.
name|msgssz
expr_stmt|;
else|else
name|tlen
operator|=
name|msgsz
expr_stmt|;
if|if
condition|(
name|next
operator|<=
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"next too low #2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|>=
name|msginfo
operator|.
name|msgseg
condition|)
name|panic
argument_list|(
literal|"next out of range #2"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|msq_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|msgp
argument_list|,
operator|&
name|msgpool
index|[
name|next
operator|*
name|msginfo
operator|.
name|msgssz
index|]
argument_list|,
name|tlen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|msq_mtx
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"error %d copying in message segment\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|msg_freehdr
argument_list|(
name|msghdr
argument_list|)
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|mode
operator|&=
operator|~
name|MSG_LOCKED
expr_stmt|;
name|wakeup
argument_list|(
name|msqkptr
argument_list|)
expr_stmt|;
goto|goto
name|done3
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|msq_mtx
argument_list|)
expr_stmt|;
name|msgsz
operator|-=
name|tlen
expr_stmt|;
name|msgp
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|msgp
operator|+
name|tlen
expr_stmt|;
name|next
operator|=
name|msgmaps
index|[
name|next
index|]
operator|.
name|next
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|!=
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"didn't use all the msg segments"
argument_list|)
expr_stmt|;
comment|/* 	 * We've got the message.  Unlock the msqid_ds. 	 */
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|mode
operator|&=
operator|~
name|MSG_LOCKED
expr_stmt|;
comment|/* 	 * Make sure that the msqid_ds is still allocated. 	 */
if|if
condition|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_qbytes
operator|==
literal|0
condition|)
block|{
name|msg_freehdr
argument_list|(
name|msghdr
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|msqkptr
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIDRM
expr_stmt|;
goto|goto
name|done3
goto|;
block|}
ifdef|#
directive|ifdef
name|MAC
comment|/* 	 * Note: Since the task/thread allocates the msghdr and usually 	 * primes it with its own MAC label, for a majority of policies, it 	 * won't be necessary to check whether the msghdr has access 	 * permissions to the msgq.  The mac_sysvmsq_check_msqsnd check would 	 * suffice in that case.  However, this hook may be required where 	 * individual policies derive a non-identical label for the msghdr 	 * from the current thread label and may want to check the msghdr 	 * enqueue permissions, along with read/write permissions to the 	 * msgq. 	 */
name|error
operator|=
name|mac_sysvmsq_check_msgmsq
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|msghdr
argument_list|,
name|msqkptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|msg_freehdr
argument_list|(
name|msghdr
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|msqkptr
argument_list|)
expr_stmt|;
goto|goto
name|done3
goto|;
block|}
endif|#
directive|endif
comment|/* 	 * Put the message into the queue 	 */
if|if
condition|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_first
operator|==
name|NULL
condition|)
block|{
name|msqkptr
operator|->
name|u
operator|.
name|msg_first
operator|=
name|msghdr
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_last
operator|=
name|msghdr
expr_stmt|;
block|}
else|else
block|{
name|msqkptr
operator|->
name|u
operator|.
name|msg_last
operator|->
name|msg_next
operator|=
name|msghdr
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_last
operator|=
name|msghdr
expr_stmt|;
block|}
name|msqkptr
operator|->
name|u
operator|.
name|msg_last
operator|->
name|msg_next
operator|=
name|NULL
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_cbytes
operator|+=
name|msghdr
operator|->
name|msg_ts
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_qnum
operator|++
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_lspid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_stime
operator|=
name|time_second
expr_stmt|;
name|wakeup
argument_list|(
name|msqkptr
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|done3
label|:
ifdef|#
directive|ifdef
name|RACCT
if|if
condition|(
name|racct_enable
operator|&&
name|error
operator|!=
literal|0
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|racct_sub
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|RACCT_MSGQQUEUED
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|racct_sub
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|RACCT_MSGQSIZE
argument_list|,
name|saved_msgsz
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|msq_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sys_msgsnd
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|msgsnd_args
modifier|*
name|uap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|long
name|mtype
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"call to msgsnd(%d, %p, %zu, %d)\n"
operator|,
name|uap
operator|->
name|msqid
operator|,
name|uap
operator|->
name|msgp
operator|,
name|uap
operator|->
name|msgsz
operator|,
name|uap
operator|->
name|msgflg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|msgp
argument_list|,
operator|&
name|mtype
argument_list|,
sizeof|sizeof
argument_list|(
name|mtype
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"error %d copying the message type\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|kern_msgsnd
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|msqid
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|uap
operator|->
name|msgp
operator|+
sizeof|sizeof
argument_list|(
name|mtype
argument_list|)
argument_list|,
name|uap
operator|->
name|msgsz
argument_list|,
name|uap
operator|->
name|msgflg
argument_list|,
name|mtype
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|msgrcv_args
block|{
name|int
name|msqid
decl_stmt|;
name|void
modifier|*
name|msgp
decl_stmt|;
name|size_t
name|msgsz
decl_stmt|;
name|long
name|msgtyp
decl_stmt|;
name|int
name|msgflg
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* XXX msgp is actually mtext. */
end_comment

begin_function
name|int
name|kern_msgrcv
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|msqid
parameter_list|,
name|void
modifier|*
name|msgp
parameter_list|,
name|size_t
name|msgsz
parameter_list|,
name|long
name|msgtyp
parameter_list|,
name|int
name|msgflg
parameter_list|,
name|long
modifier|*
name|mtype
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|struct
name|msqid_kernel
modifier|*
name|msqkptr
decl_stmt|;
name|struct
name|msg
modifier|*
name|msghdr
decl_stmt|;
name|struct
name|prison
modifier|*
name|rpr
decl_stmt|;
name|int
name|msqix
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|short
name|next
decl_stmt|;
name|rpr
operator|=
name|msg_find_prison
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
name|AUDIT_ARG_SVIPC_ID
argument_list|(
name|msqid
argument_list|)
expr_stmt|;
name|msqix
operator|=
name|IPCID_TO_IX
argument_list|(
name|msqid
argument_list|)
expr_stmt|;
if|if
condition|(
name|msqix
operator|<
literal|0
operator|||
name|msqix
operator|>=
name|msginfo
operator|.
name|msgmni
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"msqid (%d) out of range (0<=msqid<%d)\n"
operator|,
name|msqix
operator|,
name|msginfo
operator|.
name|msgmni
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|msqkptr
operator|=
operator|&
name|msqids
index|[
name|msqix
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|msq_mtx
argument_list|)
expr_stmt|;
name|AUDIT_ARG_SVIPC_PERM
argument_list|(
operator|&
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
argument_list|)
expr_stmt|;
if|if
condition|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_qbytes
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"no such message queue id\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|seq
operator|!=
name|IPCID_TO_SEQ
argument_list|(
name|msqid
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"wrong sequence number\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|msq_prison_cansee
argument_list|(
name|rpr
argument_list|,
name|msqkptr
argument_list|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"requester can't see prison\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"requester doesn't have read access\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_sysvmsq_check_msqrcv
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|msqkptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
endif|#
directive|endif
name|msghdr
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|msghdr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|msgtyp
operator|==
literal|0
condition|)
block|{
name|msghdr
operator|=
name|msqkptr
operator|->
name|u
operator|.
name|msg_first
expr_stmt|;
if|if
condition|(
name|msghdr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|msgsz
operator|<
name|msghdr
operator|->
name|msg_ts
operator|&&
operator|(
name|msgflg
operator|&
name|MSG_NOERROR
operator|)
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"first message on the queue "
literal|"is too big (want %zu, got %d)\n"
operator|,
name|msgsz
operator|,
name|msghdr
operator|->
name|msg_ts
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_sysvmsq_check_msgrcv
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|msghdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
endif|#
directive|endif
if|if
condition|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_first
operator|==
name|msqkptr
operator|->
name|u
operator|.
name|msg_last
condition|)
block|{
name|msqkptr
operator|->
name|u
operator|.
name|msg_first
operator|=
name|NULL
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_last
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|msqkptr
operator|->
name|u
operator|.
name|msg_first
operator|=
name|msghdr
operator|->
name|msg_next
expr_stmt|;
if|if
condition|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_first
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"msg_first/last screwed up #1"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|struct
name|msg
modifier|*
name|previous
decl_stmt|;
name|struct
name|msg
modifier|*
modifier|*
name|prev
decl_stmt|;
name|previous
operator|=
name|NULL
expr_stmt|;
name|prev
operator|=
operator|&
operator|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_first
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|msghdr
operator|=
operator|*
name|prev
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Is this message's type an exact match or is 				 * this message's type less than or equal to 				 * the absolute value of a negative msgtyp? 				 * Note that the second half of this test can 				 * NEVER be true if msgtyp is positive since 				 * msg_type is always positive! 				 */
if|if
condition|(
name|msgtyp
operator|==
name|msghdr
operator|->
name|msg_type
operator|||
name|msghdr
operator|->
name|msg_type
operator|<=
operator|-
name|msgtyp
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"found message type %ld, "
literal|"requested %ld\n"
operator|,
name|msghdr
operator|->
name|msg_type
operator|,
name|msgtyp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgsz
operator|<
name|msghdr
operator|->
name|msg_ts
operator|&&
operator|(
name|msgflg
operator|&
name|MSG_NOERROR
operator|)
operator|==
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"requested message "
literal|"on the queue is too big "
literal|"(want %zu, got %hu)\n"
operator|,
name|msgsz
operator|,
name|msghdr
operator|->
name|msg_ts
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_sysvmsq_check_msgrcv
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|msghdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
endif|#
directive|endif
operator|*
name|prev
operator|=
name|msghdr
operator|->
name|msg_next
expr_stmt|;
if|if
condition|(
name|msghdr
operator|==
name|msqkptr
operator|->
name|u
operator|.
name|msg_last
condition|)
block|{
if|if
condition|(
name|previous
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|prev
operator|!=
operator|&
name|msqkptr
operator|->
name|u
operator|.
name|msg_first
condition|)
name|panic
argument_list|(
literal|"msg_first/last screwed up #2"
argument_list|)
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_first
operator|=
name|NULL
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_last
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|prev
operator|==
operator|&
name|msqkptr
operator|->
name|u
operator|.
name|msg_first
condition|)
name|panic
argument_list|(
literal|"msg_first/last screwed up #3"
argument_list|)
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_last
operator|=
name|previous
expr_stmt|;
block|}
block|}
break|break;
block|}
name|previous
operator|=
name|msghdr
expr_stmt|;
name|prev
operator|=
operator|&
operator|(
name|msghdr
operator|->
name|msg_next
operator|)
expr_stmt|;
block|}
block|}
comment|/* 		 * We've either extracted the msghdr for the appropriate 		 * message or there isn't one. 		 * If there is one then bail out of this loop. 		 */
if|if
condition|(
name|msghdr
operator|!=
name|NULL
condition|)
break|break;
comment|/* 		 * Hmph!  No message found.  Does the user want to wait? 		 */
if|if
condition|(
operator|(
name|msgflg
operator|&
name|IPC_NOWAIT
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"no appropriate message found (msgtyp=%ld)\n"
operator|,
name|msgtyp
operator|)
argument_list|)
expr_stmt|;
comment|/* The SVID says to return ENOMSG. */
name|error
operator|=
name|ENOMSG
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
comment|/* 		 * Wait for something to happen 		 */
name|DPRINTF
argument_list|(
operator|(
literal|"msgrcv:  goodnight\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
name|msqkptr
argument_list|,
operator|&
name|msq_mtx
argument_list|,
operator|(
name|PZERO
operator|-
literal|4
operator|)
operator||
name|PCATCH
argument_list|,
literal|"msgrcv"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"msgrcv:  good morning (error=%d)\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"msgrcv:  interrupted system call\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
comment|/* 		 * Make sure that the msq queue still exists 		 */
if|if
condition|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_qbytes
operator|==
literal|0
operator|||
name|msqkptr
operator|->
name|u
operator|.
name|msg_perm
operator|.
name|seq
operator|!=
name|IPCID_TO_SEQ
argument_list|(
name|msqid
argument_list|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"msqid deleted\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EIDRM
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
block|}
comment|/* 	 * Return the message to the user. 	 * 	 * First, do the bookkeeping (before we risk being interrupted). 	 */
name|msqkptr
operator|->
name|u
operator|.
name|msg_cbytes
operator|-=
name|msghdr
operator|->
name|msg_ts
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_qnum
operator|--
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_lrpid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
name|msqkptr
operator|->
name|u
operator|.
name|msg_rtime
operator|=
name|time_second
expr_stmt|;
name|racct_sub_cred
argument_list|(
name|msqkptr
operator|->
name|cred
argument_list|,
name|RACCT_MSGQQUEUED
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|racct_sub_cred
argument_list|(
name|msqkptr
operator|->
name|cred
argument_list|,
name|RACCT_MSGQSIZE
argument_list|,
name|msghdr
operator|->
name|msg_ts
argument_list|)
expr_stmt|;
comment|/* 	 * Make msgsz the actual amount that we'll be returning. 	 * Note that this effectively truncates the message if it is too long 	 * (since msgsz is never increased). 	 */
name|DPRINTF
argument_list|(
operator|(
literal|"found a message, msgsz=%zu, msg_ts=%hu\n"
operator|,
name|msgsz
operator|,
name|msghdr
operator|->
name|msg_ts
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgsz
operator|>
name|msghdr
operator|->
name|msg_ts
condition|)
name|msgsz
operator|=
name|msghdr
operator|->
name|msg_ts
expr_stmt|;
operator|*
name|mtype
operator|=
name|msghdr
operator|->
name|msg_type
expr_stmt|;
comment|/* 	 * Return the segments to the user 	 */
name|next
operator|=
name|msghdr
operator|->
name|msg_spot
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
name|msgsz
condition|;
name|len
operator|+=
name|msginfo
operator|.
name|msgssz
control|)
block|{
name|size_t
name|tlen
decl_stmt|;
if|if
condition|(
name|msgsz
operator|-
name|len
operator|>
name|msginfo
operator|.
name|msgssz
condition|)
name|tlen
operator|=
name|msginfo
operator|.
name|msgssz
expr_stmt|;
else|else
name|tlen
operator|=
name|msgsz
operator|-
name|len
expr_stmt|;
if|if
condition|(
name|next
operator|<=
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"next too low #3"
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|>=
name|msginfo
operator|.
name|msgseg
condition|)
name|panic
argument_list|(
literal|"next out of range #3"
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|msq_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|msgpool
index|[
name|next
operator|*
name|msginfo
operator|.
name|msgssz
index|]
argument_list|,
name|msgp
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|msq_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"error (%d) copying out message segment\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|msg_freehdr
argument_list|(
name|msghdr
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|msqkptr
argument_list|)
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|msgp
operator|=
operator|(
name|char
operator|*
operator|)
name|msgp
operator|+
name|tlen
expr_stmt|;
name|next
operator|=
name|msgmaps
index|[
name|next
index|]
operator|.
name|next
expr_stmt|;
block|}
comment|/* 	 * Done, return the actual number of bytes copied out. 	 */
name|msg_freehdr
argument_list|(
name|msghdr
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|msqkptr
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|msgsz
expr_stmt|;
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|msq_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sys_msgrcv
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|msgrcv_args
modifier|*
name|uap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|long
name|mtype
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"call to msgrcv(%d, %p, %zu, %ld, %d)\n"
operator|,
name|uap
operator|->
name|msqid
operator|,
name|uap
operator|->
name|msgp
operator|,
name|uap
operator|->
name|msgsz
operator|,
name|uap
operator|->
name|msgtyp
operator|,
name|uap
operator|->
name|msgflg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|kern_msgrcv
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|msqid
argument_list|,
operator|(
name|char
operator|*
operator|)
name|uap
operator|->
name|msgp
operator|+
sizeof|sizeof
argument_list|(
name|mtype
argument_list|)
argument_list|,
name|uap
operator|->
name|msgsz
argument_list|,
name|uap
operator|->
name|msgtyp
argument_list|,
name|uap
operator|->
name|msgflg
argument_list|,
operator|&
name|mtype
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|mtype
argument_list|,
name|uap
operator|->
name|msgp
argument_list|,
sizeof|sizeof
argument_list|(
name|mtype
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|DPRINTF
argument_list|(
operator|(
literal|"error %d copying the message type\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_msqids
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|msqid_kernel
name|tmsqk
decl_stmt|;
name|struct
name|prison
modifier|*
name|pr
decl_stmt|,
modifier|*
name|rpr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|pr
operator|=
name|req
operator|->
name|td
operator|->
name|td_ucred
operator|->
name|cr_prison
expr_stmt|;
name|rpr
operator|=
name|msg_find_prison
argument_list|(
name|req
operator|->
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msginfo
operator|.
name|msgmni
condition|;
name|i
operator|++
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|msq_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|msqids
index|[
name|i
index|]
operator|.
name|u
operator|.
name|msg_qbytes
operator|==
literal|0
operator|||
name|rpr
operator|==
name|NULL
operator|||
name|msq_prison_cansee
argument_list|(
name|rpr
argument_list|,
operator|&
name|msqids
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
name|bzero
argument_list|(
operator|&
name|tmsqk
argument_list|,
sizeof|sizeof
argument_list|(
name|tmsqk
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|tmsqk
operator|=
name|msqids
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|tmsqk
operator|.
name|cred
operator|->
name|cr_prison
operator|!=
name|pr
condition|)
name|tmsqk
operator|.
name|u
operator|.
name|msg_perm
operator|.
name|key
operator|=
name|IPC_PRIVATE
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|msq_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|tmsqk
argument_list|,
sizeof|sizeof
argument_list|(
name|tmsqk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|msgmax
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|msginfo
operator|.
name|msgmax
argument_list|,
literal|0
argument_list|,
literal|"Maximum message size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|msgmni
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|msginfo
operator|.
name|msgmni
argument_list|,
literal|0
argument_list|,
literal|"Number of message queue identifiers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|msgmnb
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|msginfo
operator|.
name|msgmnb
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of bytes in a queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|msgtql
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|msginfo
operator|.
name|msgtql
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of messages in the system"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|msgssz
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|msginfo
operator|.
name|msgssz
argument_list|,
literal|0
argument_list|,
literal|"Size of a message segment"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|msgseg
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|msginfo
operator|.
name|msgseg
argument_list|,
literal|0
argument_list|,
literal|"Number of message segments"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|msqids
argument_list|,
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_msqids
argument_list|,
literal|""
argument_list|,
literal|"Message queue IDs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|msg_prison_check
parameter_list|(
name|void
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|prison
modifier|*
name|pr
init|=
name|obj
decl_stmt|;
name|struct
name|prison
modifier|*
name|prpr
decl_stmt|;
name|struct
name|vfsoptlist
modifier|*
name|opts
init|=
name|data
decl_stmt|;
name|int
name|error
decl_stmt|,
name|jsys
decl_stmt|;
comment|/* 	 * sysvmsg is a jailsys integer. 	 * It must be "disable" if the parent jail is disabled. 	 */
name|error
operator|=
name|vfs_copyopt
argument_list|(
name|opts
argument_list|,
literal|"sysvmsg"
argument_list|,
operator|&
name|jsys
argument_list|,
sizeof|sizeof
argument_list|(
name|jsys
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
block|{
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|jsys
condition|)
block|{
case|case
name|JAIL_SYS_DISABLE
case|:
break|break;
case|case
name|JAIL_SYS_NEW
case|:
case|case
name|JAIL_SYS_INHERIT
case|:
name|prison_lock
argument_list|(
name|pr
operator|->
name|pr_parent
argument_list|)
expr_stmt|;
name|prpr
operator|=
name|osd_jail_get
argument_list|(
name|pr
operator|->
name|pr_parent
argument_list|,
name|msg_prison_slot
argument_list|)
expr_stmt|;
name|prison_unlock
argument_list|(
name|pr
operator|->
name|pr_parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|prpr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msg_prison_set
parameter_list|(
name|void
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|prison
modifier|*
name|pr
init|=
name|obj
decl_stmt|;
name|struct
name|prison
modifier|*
name|tpr
decl_stmt|,
modifier|*
name|orpr
decl_stmt|,
modifier|*
name|nrpr
decl_stmt|,
modifier|*
name|trpr
decl_stmt|;
name|struct
name|vfsoptlist
modifier|*
name|opts
init|=
name|data
decl_stmt|;
name|void
modifier|*
name|rsv
decl_stmt|;
name|int
name|jsys
decl_stmt|,
name|descend
decl_stmt|;
comment|/* 	 * sysvmsg controls which jail is the root of the associated msgs (this 	 * jail or same as the parent), or if the feature is available at all. 	 */
if|if
condition|(
name|vfs_copyopt
argument_list|(
name|opts
argument_list|,
literal|"sysvmsg"
argument_list|,
operator|&
name|jsys
argument_list|,
sizeof|sizeof
argument_list|(
name|jsys
argument_list|)
argument_list|)
operator|==
name|ENOENT
condition|)
name|jsys
operator|=
name|vfs_flagopt
argument_list|(
name|opts
argument_list|,
literal|"allow.sysvipc"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|?
name|JAIL_SYS_INHERIT
else|:
name|vfs_flagopt
argument_list|(
name|opts
argument_list|,
literal|"allow.nosysvipc"
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
condition|?
name|JAIL_SYS_DISABLE
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|jsys
operator|==
name|JAIL_SYS_DISABLE
condition|)
block|{
name|prison_lock
argument_list|(
name|pr
argument_list|)
expr_stmt|;
name|orpr
operator|=
name|osd_jail_get
argument_list|(
name|pr
argument_list|,
name|msg_prison_slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|orpr
operator|!=
name|NULL
condition|)
name|osd_jail_del
argument_list|(
name|pr
argument_list|,
name|msg_prison_slot
argument_list|)
expr_stmt|;
name|prison_unlock
argument_list|(
name|pr
argument_list|)
expr_stmt|;
if|if
condition|(
name|orpr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|orpr
operator|==
name|pr
condition|)
name|msg_prison_cleanup
argument_list|(
name|pr
argument_list|)
expr_stmt|;
comment|/* Disable all child jails as well. */
name|FOREACH_PRISON_DESCENDANT
argument_list|(
argument|pr
argument_list|,
argument|tpr
argument_list|,
argument|descend
argument_list|)
block|{
name|prison_lock
argument_list|(
name|tpr
argument_list|)
expr_stmt|;
name|trpr
operator|=
name|osd_jail_get
argument_list|(
name|tpr
argument_list|,
name|msg_prison_slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|trpr
operator|!=
name|NULL
condition|)
block|{
name|osd_jail_del
argument_list|(
name|tpr
argument_list|,
name|msg_prison_slot
argument_list|)
expr_stmt|;
name|prison_unlock
argument_list|(
name|tpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|trpr
operator|==
name|tpr
condition|)
name|msg_prison_cleanup
argument_list|(
name|tpr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prison_unlock
argument_list|(
name|tpr
argument_list|)
expr_stmt|;
name|descend
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|jsys
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|jsys
operator|==
name|JAIL_SYS_NEW
condition|)
name|nrpr
operator|=
name|pr
expr_stmt|;
else|else
block|{
name|prison_lock
argument_list|(
name|pr
operator|->
name|pr_parent
argument_list|)
expr_stmt|;
name|nrpr
operator|=
name|osd_jail_get
argument_list|(
name|pr
operator|->
name|pr_parent
argument_list|,
name|msg_prison_slot
argument_list|)
expr_stmt|;
name|prison_unlock
argument_list|(
name|pr
operator|->
name|pr_parent
argument_list|)
expr_stmt|;
block|}
name|rsv
operator|=
name|osd_reserve
argument_list|(
name|msg_prison_slot
argument_list|)
expr_stmt|;
name|prison_lock
argument_list|(
name|pr
argument_list|)
expr_stmt|;
name|orpr
operator|=
name|osd_jail_get
argument_list|(
name|pr
argument_list|,
name|msg_prison_slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|orpr
operator|!=
name|nrpr
condition|)
operator|(
name|void
operator|)
name|osd_jail_set_reserved
argument_list|(
name|pr
argument_list|,
name|msg_prison_slot
argument_list|,
name|rsv
argument_list|,
name|nrpr
argument_list|)
expr_stmt|;
else|else
name|osd_free_reserved
argument_list|(
name|rsv
argument_list|)
expr_stmt|;
name|prison_unlock
argument_list|(
name|pr
argument_list|)
expr_stmt|;
if|if
condition|(
name|orpr
operator|!=
name|nrpr
condition|)
block|{
if|if
condition|(
name|orpr
operator|==
name|pr
condition|)
name|msg_prison_cleanup
argument_list|(
name|pr
argument_list|)
expr_stmt|;
if|if
condition|(
name|orpr
operator|!=
name|NULL
condition|)
block|{
comment|/* Change child jails matching the old root, */
name|FOREACH_PRISON_DESCENDANT
argument_list|(
argument|pr
argument_list|,
argument|tpr
argument_list|,
argument|descend
argument_list|)
block|{
name|prison_lock
argument_list|(
name|tpr
argument_list|)
expr_stmt|;
name|trpr
operator|=
name|osd_jail_get
argument_list|(
name|tpr
argument_list|,
name|msg_prison_slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|trpr
operator|==
name|orpr
condition|)
block|{
operator|(
name|void
operator|)
name|osd_jail_set
argument_list|(
name|tpr
argument_list|,
name|msg_prison_slot
argument_list|,
name|nrpr
argument_list|)
expr_stmt|;
name|prison_unlock
argument_list|(
name|tpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|trpr
operator|==
name|tpr
condition|)
name|msg_prison_cleanup
argument_list|(
name|tpr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prison_unlock
argument_list|(
name|tpr
argument_list|)
expr_stmt|;
name|descend
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msg_prison_get
parameter_list|(
name|void
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|prison
modifier|*
name|pr
init|=
name|obj
decl_stmt|;
name|struct
name|prison
modifier|*
name|rpr
decl_stmt|;
name|struct
name|vfsoptlist
modifier|*
name|opts
init|=
name|data
decl_stmt|;
name|int
name|error
decl_stmt|,
name|jsys
decl_stmt|;
comment|/* Set sysvmsg based on the jail's root prison. */
name|prison_lock
argument_list|(
name|pr
argument_list|)
expr_stmt|;
name|rpr
operator|=
name|osd_jail_get
argument_list|(
name|pr
argument_list|,
name|msg_prison_slot
argument_list|)
expr_stmt|;
name|prison_unlock
argument_list|(
name|pr
argument_list|)
expr_stmt|;
name|jsys
operator|=
name|rpr
operator|==
name|NULL
condition|?
name|JAIL_SYS_DISABLE
else|:
name|rpr
operator|==
name|pr
condition|?
name|JAIL_SYS_NEW
else|:
name|JAIL_SYS_INHERIT
expr_stmt|;
name|error
operator|=
name|vfs_setopt
argument_list|(
name|opts
argument_list|,
literal|"sysvmsg"
argument_list|,
operator|&
name|jsys
argument_list|,
sizeof|sizeof
argument_list|(
name|jsys
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|msg_prison_remove
parameter_list|(
name|void
modifier|*
name|obj
parameter_list|,
name|void
modifier|*
name|data
name|__unused
parameter_list|)
block|{
name|struct
name|prison
modifier|*
name|pr
init|=
name|obj
decl_stmt|;
name|struct
name|prison
modifier|*
name|rpr
decl_stmt|;
name|prison_lock
argument_list|(
name|pr
argument_list|)
expr_stmt|;
name|rpr
operator|=
name|osd_jail_get
argument_list|(
name|pr
argument_list|,
name|msg_prison_slot
argument_list|)
expr_stmt|;
name|prison_unlock
argument_list|(
name|pr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpr
operator|==
name|pr
condition|)
name|msg_prison_cleanup
argument_list|(
name|pr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|msg_prison_cleanup
parameter_list|(
name|struct
name|prison
modifier|*
name|pr
parameter_list|)
block|{
name|struct
name|msqid_kernel
modifier|*
name|msqkptr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Remove any msqs that belong to this jail. */
name|mtx_lock
argument_list|(
operator|&
name|msq_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msginfo
operator|.
name|msgmni
condition|;
name|i
operator|++
control|)
block|{
name|msqkptr
operator|=
operator|&
name|msqids
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|msqkptr
operator|->
name|u
operator|.
name|msg_qbytes
operator|!=
literal|0
operator|&&
name|msqkptr
operator|->
name|cred
operator|!=
name|NULL
operator|&&
name|msqkptr
operator|->
name|cred
operator|->
name|cr_prison
operator|==
name|pr
condition|)
name|msq_remove
argument_list|(
name|msqkptr
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|msq_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_JAIL_PARAM_SYS_NODE
argument_list|(
name|sysvmsg
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|"SYSV message queues"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
end_ifdef

begin_function
name|int
name|freebsd32_msgsys
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd32_msgsys_args
modifier|*
name|uap
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD4
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD5
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|COMPAT_FREEBSD6
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD7
argument_list|)
name|AUDIT_ARG_SVIPC_WHICH
argument_list|(
name|uap
operator|->
name|which
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|which
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
name|freebsd7_freebsd32_msgctl
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|freebsd7_freebsd32_msgctl_args
operator|*
operator|)
operator|&
name|uap
operator|->
name|a2
argument_list|)
operator|)
return|;
case|case
literal|2
case|:
return|return
operator|(
name|freebsd32_msgsnd
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|freebsd32_msgsnd_args
operator|*
operator|)
operator|&
name|uap
operator|->
name|a2
argument_list|)
operator|)
return|;
case|case
literal|3
case|:
return|return
operator|(
name|freebsd32_msgrcv
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|freebsd32_msgrcv_args
operator|*
operator|)
operator|&
name|uap
operator|->
name|a2
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|sys_msgsys
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|msgsys_args
operator|*
operator|)
name|uap
argument_list|)
operator|)
return|;
block|}
else|#
directive|else
return|return
operator|(
name|nosys
argument_list|(
name|td
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD4
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD5
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|COMPAT_FREEBSD6
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD7
argument_list|)
end_if

begin_function
name|int
name|freebsd7_freebsd32_msgctl
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd7_freebsd32_msgctl_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|msqid_ds
name|msqbuf
decl_stmt|;
name|struct
name|msqid_ds32_old
name|msqbuf32
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|cmd
operator|==
name|IPC_SET
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|buf
argument_list|,
operator|&
name|msqbuf32
argument_list|,
sizeof|sizeof
argument_list|(
name|msqbuf32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|freebsd32_ipcperm_old_in
argument_list|(
operator|&
name|msqbuf32
operator|.
name|msg_perm
argument_list|,
operator|&
name|msqbuf
operator|.
name|msg_perm
argument_list|)
expr_stmt|;
name|PTRIN_CP
argument_list|(
name|msqbuf32
argument_list|,
name|msqbuf
argument_list|,
name|msg_first
argument_list|)
expr_stmt|;
name|PTRIN_CP
argument_list|(
name|msqbuf32
argument_list|,
name|msqbuf
argument_list|,
name|msg_last
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf32
argument_list|,
name|msqbuf
argument_list|,
name|msg_cbytes
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf32
argument_list|,
name|msqbuf
argument_list|,
name|msg_qnum
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf32
argument_list|,
name|msqbuf
argument_list|,
name|msg_qbytes
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf32
argument_list|,
name|msqbuf
argument_list|,
name|msg_lspid
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf32
argument_list|,
name|msqbuf
argument_list|,
name|msg_lrpid
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf32
argument_list|,
name|msqbuf
argument_list|,
name|msg_stime
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf32
argument_list|,
name|msqbuf
argument_list|,
name|msg_rtime
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf32
argument_list|,
name|msqbuf
argument_list|,
name|msg_ctime
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|kern_msgctl
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|msqid
argument_list|,
name|uap
operator|->
name|cmd
argument_list|,
operator|&
name|msqbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|cmd
operator|==
name|IPC_STAT
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|msqbuf32
argument_list|,
sizeof|sizeof
argument_list|(
name|msqbuf32
argument_list|)
argument_list|)
expr_stmt|;
name|freebsd32_ipcperm_old_out
argument_list|(
operator|&
name|msqbuf
operator|.
name|msg_perm
argument_list|,
operator|&
name|msqbuf32
operator|.
name|msg_perm
argument_list|)
expr_stmt|;
name|PTROUT_CP
argument_list|(
name|msqbuf
argument_list|,
name|msqbuf32
argument_list|,
name|msg_first
argument_list|)
expr_stmt|;
name|PTROUT_CP
argument_list|(
name|msqbuf
argument_list|,
name|msqbuf32
argument_list|,
name|msg_last
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqbuf32
argument_list|,
name|msg_cbytes
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqbuf32
argument_list|,
name|msg_qnum
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqbuf32
argument_list|,
name|msg_qbytes
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqbuf32
argument_list|,
name|msg_lspid
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqbuf32
argument_list|,
name|msg_lrpid
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqbuf32
argument_list|,
name|msg_stime
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqbuf32
argument_list|,
name|msg_rtime
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqbuf32
argument_list|,
name|msg_ctime
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|msqbuf32
argument_list|,
name|uap
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msqid_ds32
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|freebsd32_msgctl
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd32_msgctl_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|msqid_ds
name|msqbuf
decl_stmt|;
name|struct
name|msqid_ds32
name|msqbuf32
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|cmd
operator|==
name|IPC_SET
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|buf
argument_list|,
operator|&
name|msqbuf32
argument_list|,
sizeof|sizeof
argument_list|(
name|msqbuf32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|freebsd32_ipcperm_in
argument_list|(
operator|&
name|msqbuf32
operator|.
name|msg_perm
argument_list|,
operator|&
name|msqbuf
operator|.
name|msg_perm
argument_list|)
expr_stmt|;
name|PTRIN_CP
argument_list|(
name|msqbuf32
argument_list|,
name|msqbuf
argument_list|,
name|msg_first
argument_list|)
expr_stmt|;
name|PTRIN_CP
argument_list|(
name|msqbuf32
argument_list|,
name|msqbuf
argument_list|,
name|msg_last
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf32
argument_list|,
name|msqbuf
argument_list|,
name|msg_cbytes
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf32
argument_list|,
name|msqbuf
argument_list|,
name|msg_qnum
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf32
argument_list|,
name|msqbuf
argument_list|,
name|msg_qbytes
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf32
argument_list|,
name|msqbuf
argument_list|,
name|msg_lspid
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf32
argument_list|,
name|msqbuf
argument_list|,
name|msg_lrpid
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf32
argument_list|,
name|msqbuf
argument_list|,
name|msg_stime
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf32
argument_list|,
name|msqbuf
argument_list|,
name|msg_rtime
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf32
argument_list|,
name|msqbuf
argument_list|,
name|msg_ctime
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|kern_msgctl
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|msqid
argument_list|,
name|uap
operator|->
name|cmd
argument_list|,
operator|&
name|msqbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|cmd
operator|==
name|IPC_STAT
condition|)
block|{
name|freebsd32_ipcperm_out
argument_list|(
operator|&
name|msqbuf
operator|.
name|msg_perm
argument_list|,
operator|&
name|msqbuf32
operator|.
name|msg_perm
argument_list|)
expr_stmt|;
name|PTROUT_CP
argument_list|(
name|msqbuf
argument_list|,
name|msqbuf32
argument_list|,
name|msg_first
argument_list|)
expr_stmt|;
name|PTROUT_CP
argument_list|(
name|msqbuf
argument_list|,
name|msqbuf32
argument_list|,
name|msg_last
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqbuf32
argument_list|,
name|msg_cbytes
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqbuf32
argument_list|,
name|msg_qnum
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqbuf32
argument_list|,
name|msg_qbytes
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqbuf32
argument_list|,
name|msg_lspid
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqbuf32
argument_list|,
name|msg_lrpid
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqbuf32
argument_list|,
name|msg_stime
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqbuf32
argument_list|,
name|msg_rtime
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqbuf32
argument_list|,
name|msg_ctime
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|msqbuf32
argument_list|,
name|uap
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msqid_ds32
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|freebsd32_msgsnd
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd32_msgsnd_args
modifier|*
name|uap
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|msgp
decl_stmt|;
name|long
name|mtype
decl_stmt|;
name|int32_t
name|mtype32
decl_stmt|;
name|int
name|error
decl_stmt|;
name|msgp
operator|=
name|PTRIN
argument_list|(
name|uap
operator|->
name|msgp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|msgp
argument_list|,
operator|&
name|mtype32
argument_list|,
sizeof|sizeof
argument_list|(
name|mtype32
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mtype
operator|=
name|mtype32
expr_stmt|;
return|return
operator|(
name|kern_msgsnd
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|msqid
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|msgp
operator|+
sizeof|sizeof
argument_list|(
name|mtype32
argument_list|)
argument_list|,
name|uap
operator|->
name|msgsz
argument_list|,
name|uap
operator|->
name|msgflg
argument_list|,
name|mtype
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|freebsd32_msgrcv
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd32_msgrcv_args
modifier|*
name|uap
parameter_list|)
block|{
name|void
modifier|*
name|msgp
decl_stmt|;
name|long
name|mtype
decl_stmt|;
name|int32_t
name|mtype32
decl_stmt|;
name|int
name|error
decl_stmt|;
name|msgp
operator|=
name|PTRIN
argument_list|(
name|uap
operator|->
name|msgp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|kern_msgrcv
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|msqid
argument_list|,
operator|(
name|char
operator|*
operator|)
name|msgp
operator|+
sizeof|sizeof
argument_list|(
name|mtype32
argument_list|)
argument_list|,
name|uap
operator|->
name|msgsz
argument_list|,
name|uap
operator|->
name|msgtyp
argument_list|,
name|uap
operator|->
name|msgflg
argument_list|,
operator|&
name|mtype
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mtype32
operator|=
operator|(
name|int32_t
operator|)
name|mtype
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|mtype32
argument_list|,
name|msgp
argument_list|,
sizeof|sizeof
argument_list|(
name|mtype32
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD4
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD5
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|COMPAT_FREEBSD6
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_FREEBSD7
argument_list|)
end_if

begin_comment
comment|/* XXX casting to (sy_call_t *) is bogus, as usual. */
end_comment

begin_decl_stmt
specifier|static
name|sy_call_t
modifier|*
name|msgcalls
index|[]
init|=
block|{
operator|(
name|sy_call_t
operator|*
operator|)
name|freebsd7_msgctl
block|,
operator|(
name|sy_call_t
operator|*
operator|)
name|sys_msgget
block|,
operator|(
name|sy_call_t
operator|*
operator|)
name|sys_msgsnd
block|,
operator|(
name|sy_call_t
operator|*
operator|)
name|sys_msgrcv
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Entry point for all MSG calls.  *  * XXX actually varargs.  * struct msgsys_args {  *		int	which;  *		int	a2;  *		int	a3;  *		int	a4;  *		int	a5;  *		int	a6;  *	} *uap;  */
end_comment

begin_function
name|int
name|sys_msgsys
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|msgsys_args
modifier|*
name|uap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|AUDIT_ARG_SVIPC_WHICH
argument_list|(
name|uap
operator|->
name|which
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|which
operator|<
literal|0
operator|||
name|uap
operator|->
name|which
operator|>=
name|nitems
argument_list|(
name|msgcalls
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
call|(
modifier|*
name|msgcalls
index|[
name|uap
operator|->
name|which
index|]
call|)
argument_list|(
name|td
argument_list|,
operator|&
name|uap
operator|->
name|a2
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|CP
end_ifndef

begin_define
define|#
directive|define
name|CP
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|,
name|fld
parameter_list|)
value|do { (dst).fld = (src).fld; } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|freebsd7_msgctl_args
block|{
name|int
name|msqid
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|struct
name|msqid_ds_old
modifier|*
name|buf
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|freebsd7_msgctl
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|freebsd7_msgctl_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|msqid_ds_old
name|msqold
decl_stmt|;
name|struct
name|msqid_ds
name|msqbuf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"call to freebsd7_msgctl(%d, %d, %p)\n"
operator|,
name|uap
operator|->
name|msqid
operator|,
name|uap
operator|->
name|cmd
operator|,
name|uap
operator|->
name|buf
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|cmd
operator|==
name|IPC_SET
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|buf
argument_list|,
operator|&
name|msqold
argument_list|,
sizeof|sizeof
argument_list|(
name|msqold
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ipcperm_old2new
argument_list|(
operator|&
name|msqold
operator|.
name|msg_perm
argument_list|,
operator|&
name|msqbuf
operator|.
name|msg_perm
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqold
argument_list|,
name|msqbuf
argument_list|,
name|msg_first
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqold
argument_list|,
name|msqbuf
argument_list|,
name|msg_last
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqold
argument_list|,
name|msqbuf
argument_list|,
name|msg_cbytes
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqold
argument_list|,
name|msqbuf
argument_list|,
name|msg_qnum
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqold
argument_list|,
name|msqbuf
argument_list|,
name|msg_qbytes
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqold
argument_list|,
name|msqbuf
argument_list|,
name|msg_lspid
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqold
argument_list|,
name|msqbuf
argument_list|,
name|msg_lrpid
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqold
argument_list|,
name|msqbuf
argument_list|,
name|msg_stime
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqold
argument_list|,
name|msqbuf
argument_list|,
name|msg_rtime
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqold
argument_list|,
name|msqbuf
argument_list|,
name|msg_ctime
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|kern_msgctl
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|msqid
argument_list|,
name|uap
operator|->
name|cmd
argument_list|,
operator|&
name|msqbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|cmd
operator|==
name|IPC_STAT
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|msqold
argument_list|,
sizeof|sizeof
argument_list|(
name|msqold
argument_list|)
argument_list|)
expr_stmt|;
name|ipcperm_new2old
argument_list|(
operator|&
name|msqbuf
operator|.
name|msg_perm
argument_list|,
operator|&
name|msqold
operator|.
name|msg_perm
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqold
argument_list|,
name|msg_first
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqold
argument_list|,
name|msg_last
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqold
argument_list|,
name|msg_cbytes
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqold
argument_list|,
name|msg_qnum
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqold
argument_list|,
name|msg_qbytes
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqold
argument_list|,
name|msg_lspid
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqold
argument_list|,
name|msg_lrpid
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqold
argument_list|,
name|msg_stime
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqold
argument_list|,
name|msg_rtime
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|msqbuf
argument_list|,
name|msqold
argument_list|,
name|msg_ctime
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|msqold
argument_list|,
name|uap
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msqid_ds_old
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|CP
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPAT_FREEBSD4 || COMPAT_FREEBSD5 || COMPAT_FREEBSD6 || 	   COMPAT_FREEBSD7 */
end_comment

end_unit

