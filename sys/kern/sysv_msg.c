begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * Implementation of SVID messages  *  * Author:  Daniel Boulet  *  * Copyright 1993 Daniel Boulet and RTMX Inc.  *  * This system call was implemented by Daniel Boulet under contract from RTMX.  *  * Redistribution and use in source forms, with and without modification,  * are permitted provided that this entire comment appears intact.  *  * Redistribution in binary form may occur without any restrictions.  * Obviously, it would be nice if you gave credit where credit is due  * but requiring it would be too onerous.  *  * This software is provided ``AS IS'' without any warranties of any kind.  */
end_comment

begin_include
include|#
directive|include
file|"opt_sysvipc.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/msg.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_MSG
argument_list|,
literal|"msg"
argument_list|,
literal|"SVID compatible message queues"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|void
name|msginit
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|msgunload
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sysvmsg_modload
name|__P
argument_list|(
operator|(
expr|struct
name|module
operator|*
operator|,
name|int
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MSG_DEBUG
end_define

begin_undef
undef|#
directive|undef
name|MSG_DEBUG_OK
end_undef

begin_decl_stmt
specifier|static
name|void
name|msg_freehdr
name|__P
argument_list|(
operator|(
expr|struct
name|msg
operator|*
name|msghdr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX casting to (sy_call_t *) is bogus, as usual. */
end_comment

begin_decl_stmt
specifier|static
name|sy_call_t
modifier|*
name|msgcalls
index|[]
init|=
block|{
operator|(
name|sy_call_t
operator|*
operator|)
name|msgctl
block|,
operator|(
name|sy_call_t
operator|*
operator|)
name|msgget
block|,
operator|(
name|sy_call_t
operator|*
operator|)
name|msgsnd
block|,
operator|(
name|sy_call_t
operator|*
operator|)
name|msgrcv
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|msg
block|{
name|struct
name|msg
modifier|*
name|msg_next
decl_stmt|;
comment|/* next msg in the chain */
name|long
name|msg_type
decl_stmt|;
comment|/* type of this message */
comment|/*>0 -> type of this message */
comment|/* 0 -> free header */
name|u_short
name|msg_ts
decl_stmt|;
comment|/* size of this message */
name|short
name|msg_spot
decl_stmt|;
comment|/* location of start of msg in buffer */
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|MSGSSZ
end_ifndef

begin_define
define|#
directive|define
name|MSGSSZ
value|8
end_define

begin_comment
comment|/* Each segment must be 2^N long */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MSGSEG
end_ifndef

begin_define
define|#
directive|define
name|MSGSEG
value|2048
end_define

begin_comment
comment|/* must be less than 32767 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MSGMAX
value|(MSGSSZ*MSGSEG)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MSGMNB
end_ifndef

begin_define
define|#
directive|define
name|MSGMNB
value|2048
end_define

begin_comment
comment|/* max # of bytes in a queue */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MSGMNI
end_ifndef

begin_define
define|#
directive|define
name|MSGMNI
value|40
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MSGTQL
end_ifndef

begin_define
define|#
directive|define
name|MSGTQL
value|40
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Based on the configuration parameters described in an SVR2 (yes, two)  * config(1m) man page.  *  * Each message is broken up and stored in segments that are msgssz bytes  * long.  For efficiency reasons, this should be a power of two.  Also,  * it doesn't make sense if it is less than 8 or greater than about 256.  * Consequently, msginit in kern/sysv_msg.c checks that msgssz is a power of  * two between 8 and 1024 inclusive (and panic's if it isn't).  */
end_comment

begin_decl_stmt
name|struct
name|msginfo
name|msginfo
init|=
block|{
name|MSGMAX
block|,
comment|/* max chars in a message */
name|MSGMNI
block|,
comment|/* # of message queue identifiers */
name|MSGMNB
block|,
comment|/* max chars in a queue */
name|MSGTQL
block|,
comment|/* max messages in system */
name|MSGSSZ
block|,
comment|/* size of a message segment */
comment|/* (must be small power of 2 greater than 4) */
name|MSGSEG
comment|/* number of message segments */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * macros to convert between msqid_ds's and msqid's.  * (specific to this implementation)  */
end_comment

begin_define
define|#
directive|define
name|MSQID
parameter_list|(
name|ix
parameter_list|,
name|ds
parameter_list|)
value|((ix)& 0xffff | (((ds).msg_perm.seq<< 16)& 0xffff0000))
end_define

begin_define
define|#
directive|define
name|MSQID_IX
parameter_list|(
name|id
parameter_list|)
value|((id)& 0xffff)
end_define

begin_define
define|#
directive|define
name|MSQID_SEQ
parameter_list|(
name|id
parameter_list|)
value|(((id)>> 16)& 0xffff)
end_define

begin_comment
comment|/*  * The rest of this file is specific to this particular implementation.  */
end_comment

begin_struct
struct|struct
name|msgmap
block|{
name|short
name|next
decl_stmt|;
comment|/* next segment in buffer */
comment|/* -1 -> available */
comment|/* 0..(MSGSEG-1) -> index of next segment */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MSG_LOCKED
value|01000
end_define

begin_comment
comment|/* Is this msqid_ds locked? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nfree_msgmaps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of free map entries */
end_comment

begin_decl_stmt
specifier|static
name|short
name|free_msgmaps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* head of linked list of free map entries */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|msg
modifier|*
name|free_msghdrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of free msg headers */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|msgpool
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MSGMAX byte long msg buffer pool */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|msgmap
modifier|*
name|msgmaps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MSGSEG msgmap structures */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|msg
modifier|*
name|msghdrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MSGTQL msg headers */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|msqid_ds
modifier|*
name|msqids
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MSGMNI msqid_ds struct's */
end_comment

begin_function
specifier|static
name|void
name|msginit
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|msgpool
operator|=
name|malloc
argument_list|(
name|msginfo
operator|.
name|msgmax
argument_list|,
name|M_MSG
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgpool
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"msgpool is NULL"
argument_list|)
expr_stmt|;
name|msgmaps
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msgmap
argument_list|)
operator|*
name|msginfo
operator|.
name|msgseg
argument_list|,
name|M_MSG
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgmaps
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"msgmaps is NULL"
argument_list|)
expr_stmt|;
name|msghdrs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msg
argument_list|)
operator|*
name|msginfo
operator|.
name|msgtql
argument_list|,
name|M_MSG
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|msghdrs
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"msghdrs is NULL"
argument_list|)
expr_stmt|;
name|msqids
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msqid_ds
argument_list|)
operator|*
name|msginfo
operator|.
name|msgmni
argument_list|,
name|M_MSG
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|msqids
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"msqids is NULL"
argument_list|)
expr_stmt|;
comment|/* 	 * msginfo.msgssz should be a power of two for efficiency reasons. 	 * It is also pretty silly if msginfo.msgssz is less than 8 	 * or greater than about 256 so ... 	 */
name|i
operator|=
literal|8
expr_stmt|;
while|while
condition|(
name|i
operator|<
literal|1024
operator|&&
name|i
operator|!=
name|msginfo
operator|.
name|msgssz
condition|)
name|i
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|msginfo
operator|.
name|msgssz
condition|)
block|{
name|printf
argument_list|(
literal|"msginfo.msgssz=%d (0x%x)\n"
argument_list|,
name|msginfo
operator|.
name|msgssz
argument_list|,
name|msginfo
operator|.
name|msgssz
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"msginfo.msgssz not a small power of 2"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msginfo
operator|.
name|msgseg
operator|>
literal|32767
condition|)
block|{
name|printf
argument_list|(
literal|"msginfo.msgseg=%d\n"
argument_list|,
name|msginfo
operator|.
name|msgseg
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"msginfo.msgseg> 32767"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msgmaps
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"msgmaps is NULL"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msginfo
operator|.
name|msgseg
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|msgmaps
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|next
operator|=
name|i
expr_stmt|;
name|msgmaps
index|[
name|i
index|]
operator|.
name|next
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* implies entry is available */
block|}
name|free_msgmaps
operator|=
literal|0
expr_stmt|;
name|nfree_msgmaps
operator|=
name|msginfo
operator|.
name|msgseg
expr_stmt|;
if|if
condition|(
name|msghdrs
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"msghdrs is NULL"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msginfo
operator|.
name|msgtql
condition|;
name|i
operator|++
control|)
block|{
name|msghdrs
index|[
name|i
index|]
operator|.
name|msg_type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|msghdrs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|msg_next
operator|=
operator|&
name|msghdrs
index|[
name|i
index|]
expr_stmt|;
name|msghdrs
index|[
name|i
index|]
operator|.
name|msg_next
operator|=
name|NULL
expr_stmt|;
block|}
name|free_msghdrs
operator|=
operator|&
name|msghdrs
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|msqids
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"msqids is NULL"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msginfo
operator|.
name|msgmni
condition|;
name|i
operator|++
control|)
block|{
name|msqids
index|[
name|i
index|]
operator|.
name|msg_qbytes
operator|=
literal|0
expr_stmt|;
comment|/* implies entry is available */
name|msqids
index|[
name|i
index|]
operator|.
name|msg_perm
operator|.
name|seq
operator|=
literal|0
expr_stmt|;
comment|/* reset to a known value */
name|msqids
index|[
name|i
index|]
operator|.
name|msg_perm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|msgunload
parameter_list|()
block|{
name|struct
name|msqid_ds
modifier|*
name|msqptr
decl_stmt|;
name|int
name|msqid
decl_stmt|;
for|for
control|(
name|msqid
operator|=
literal|0
init|;
name|msqid
operator|<
name|msginfo
operator|.
name|msgmni
condition|;
name|msqid
operator|++
control|)
block|{
comment|/* 		 * Look for an unallocated and unlocked msqid_ds. 		 * msqid_ds's can be locked by msgsnd or msgrcv while 		 * they are copying the message in/out.  We can't 		 * re-use the entry until they release it. 		 */
name|msqptr
operator|=
operator|&
name|msqids
index|[
name|msqid
index|]
expr_stmt|;
if|if
condition|(
name|msqptr
operator|->
name|msg_qbytes
operator|!=
literal|0
operator|||
operator|(
name|msqptr
operator|->
name|msg_perm
operator|.
name|mode
operator|&
name|MSG_LOCKED
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|msqid
operator|!=
name|msginfo
operator|.
name|msgmni
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|free
argument_list|(
name|msgpool
argument_list|,
name|M_MSG
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msgmaps
argument_list|,
name|M_MSG
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msghdrs
argument_list|,
name|M_MSG
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msqids
argument_list|,
name|M_MSG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysvmsg_modload
parameter_list|(
name|struct
name|module
modifier|*
name|module
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|msginit
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|error
operator|=
name|msgunload
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|sysvmsg_mod
init|=
block|{
literal|"sysvmsg"
block|,
operator|&
name|sysvmsg_modload
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|msgsys
argument_list|,
literal|6
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|msgctl
argument_list|,
literal|3
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|msgget
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|msgsnd
argument_list|,
literal|4
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|msgrcv
argument_list|,
literal|5
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|sysvmsg
argument_list|,
name|sysvmsg_mod
argument_list|,
name|SI_SUB_SYSV_MSG
argument_list|,
name|SI_ORDER_FIRST
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|sysvmsg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Entry point for all MSG calls  */
end_comment

begin_function
name|int
name|msgsys
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
comment|/* XXX actually varargs. */
name|struct
name|msgsys_args
comment|/* { 		u_int	which; 		int	a2; 		int	a3; 		int	a4; 		int	a5; 		int	a6; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|jail_sysvipc_allowed
operator|&&
name|jailed
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|)
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|which
operator|>=
sizeof|sizeof
argument_list|(
name|msgcalls
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|msgcalls
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
call|(
modifier|*
name|msgcalls
index|[
name|uap
operator|->
name|which
index|]
call|)
argument_list|(
name|p
argument_list|,
operator|&
name|uap
operator|->
name|a2
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|msg_freehdr
parameter_list|(
name|msghdr
parameter_list|)
name|struct
name|msg
modifier|*
name|msghdr
decl_stmt|;
block|{
while|while
condition|(
name|msghdr
operator|->
name|msg_ts
operator|>
literal|0
condition|)
block|{
name|short
name|next
decl_stmt|;
if|if
condition|(
name|msghdr
operator|->
name|msg_spot
operator|<
literal|0
operator|||
name|msghdr
operator|->
name|msg_spot
operator|>=
name|msginfo
operator|.
name|msgseg
condition|)
name|panic
argument_list|(
literal|"msghdr->msg_spot out of range"
argument_list|)
expr_stmt|;
name|next
operator|=
name|msgmaps
index|[
name|msghdr
operator|->
name|msg_spot
index|]
operator|.
name|next
expr_stmt|;
name|msgmaps
index|[
name|msghdr
operator|->
name|msg_spot
index|]
operator|.
name|next
operator|=
name|free_msgmaps
expr_stmt|;
name|free_msgmaps
operator|=
name|msghdr
operator|->
name|msg_spot
expr_stmt|;
name|nfree_msgmaps
operator|++
expr_stmt|;
name|msghdr
operator|->
name|msg_spot
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|msghdr
operator|->
name|msg_ts
operator|>=
name|msginfo
operator|.
name|msgssz
condition|)
name|msghdr
operator|->
name|msg_ts
operator|-=
name|msginfo
operator|.
name|msgssz
expr_stmt|;
else|else
name|msghdr
operator|->
name|msg_ts
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|msghdr
operator|->
name|msg_spot
operator|!=
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"msghdr->msg_spot != -1"
argument_list|)
expr_stmt|;
name|msghdr
operator|->
name|msg_next
operator|=
name|free_msghdrs
expr_stmt|;
name|free_msghdrs
operator|=
name|msghdr
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|msgctl_args
block|{
name|int
name|msqid
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|struct
name|msqid_ds
modifier|*
name|buf
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|msgctl
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|msgctl_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|msqid
init|=
name|uap
operator|->
name|msqid
decl_stmt|;
name|int
name|cmd
init|=
name|uap
operator|->
name|cmd
decl_stmt|;
name|struct
name|msqid_ds
modifier|*
name|user_msqptr
init|=
name|uap
operator|->
name|buf
decl_stmt|;
name|int
name|rval
decl_stmt|,
name|eval
decl_stmt|;
name|struct
name|msqid_ds
name|msqbuf
decl_stmt|;
specifier|register
name|struct
name|msqid_ds
modifier|*
name|msqptr
decl_stmt|;
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"call to msgctl(%d, %d, 0x%x)\n"
argument_list|,
name|msqid
argument_list|,
name|cmd
argument_list|,
name|user_msqptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|jail_sysvipc_allowed
operator|&&
name|jailed
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|)
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
name|msqid
operator|=
name|IPCID_TO_IX
argument_list|(
name|msqid
argument_list|)
expr_stmt|;
if|if
condition|(
name|msqid
operator|<
literal|0
operator|||
name|msqid
operator|>=
name|msginfo
operator|.
name|msgmni
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"msqid (%d) out of range (0<=msqid<%d)\n"
argument_list|,
name|msqid
argument_list|,
name|msginfo
operator|.
name|msgmni
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|msqptr
operator|=
operator|&
name|msqids
index|[
name|msqid
index|]
expr_stmt|;
if|if
condition|(
name|msqptr
operator|->
name|msg_qbytes
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"no such msqid\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|msqptr
operator|->
name|msg_perm
operator|.
name|seq
operator|!=
name|IPCID_TO_SEQ
argument_list|(
name|uap
operator|->
name|msqid
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"wrong sequence number\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|eval
operator|=
literal|0
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|IPC_RMID
case|:
block|{
name|struct
name|msg
modifier|*
name|msghdr
decl_stmt|;
if|if
condition|(
operator|(
name|eval
operator|=
name|ipcperm
argument_list|(
name|p
argument_list|,
operator|&
name|msqptr
operator|->
name|msg_perm
argument_list|,
name|IPC_M
argument_list|)
operator|)
condition|)
return|return
operator|(
name|eval
operator|)
return|;
comment|/* Free the message headers */
name|msghdr
operator|=
name|msqptr
operator|->
name|msg_first
expr_stmt|;
while|while
condition|(
name|msghdr
operator|!=
name|NULL
condition|)
block|{
name|struct
name|msg
modifier|*
name|msghdr_tmp
decl_stmt|;
comment|/* Free the segments of each message */
name|msqptr
operator|->
name|msg_cbytes
operator|-=
name|msghdr
operator|->
name|msg_ts
expr_stmt|;
name|msqptr
operator|->
name|msg_qnum
operator|--
expr_stmt|;
name|msghdr_tmp
operator|=
name|msghdr
expr_stmt|;
name|msghdr
operator|=
name|msghdr
operator|->
name|msg_next
expr_stmt|;
name|msg_freehdr
argument_list|(
name|msghdr_tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msqptr
operator|->
name|msg_cbytes
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"msg_cbytes is screwed up"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msqptr
operator|->
name|msg_qnum
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"msg_qnum is screwed up"
argument_list|)
expr_stmt|;
name|msqptr
operator|->
name|msg_qbytes
operator|=
literal|0
expr_stmt|;
comment|/* Mark it as free */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|msqptr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IPC_SET
case|:
if|if
condition|(
operator|(
name|eval
operator|=
name|ipcperm
argument_list|(
name|p
argument_list|,
operator|&
name|msqptr
operator|->
name|msg_perm
argument_list|,
name|IPC_M
argument_list|)
operator|)
condition|)
return|return
operator|(
name|eval
operator|)
return|;
if|if
condition|(
operator|(
name|eval
operator|=
name|copyin
argument_list|(
name|user_msqptr
argument_list|,
operator|&
name|msqbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msqbuf
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|eval
operator|)
return|;
if|if
condition|(
name|msqbuf
operator|.
name|msg_qbytes
operator|>
name|msqptr
operator|->
name|msg_qbytes
condition|)
block|{
name|eval
operator|=
name|suser
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|eval
condition|)
return|return
operator|(
name|eval
operator|)
return|;
block|}
if|if
condition|(
name|msqbuf
operator|.
name|msg_qbytes
operator|>
name|msginfo
operator|.
name|msgmnb
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"can't increase msg_qbytes beyond %d (truncating)\n"
argument_list|,
name|msginfo
operator|.
name|msgmnb
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|msqbuf
operator|.
name|msg_qbytes
operator|=
name|msginfo
operator|.
name|msgmnb
expr_stmt|;
comment|/* silently restrict qbytes to system limit */
block|}
if|if
condition|(
name|msqbuf
operator|.
name|msg_qbytes
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"can't reduce msg_qbytes to 0\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* non-standard errno! */
block|}
name|msqptr
operator|->
name|msg_perm
operator|.
name|uid
operator|=
name|msqbuf
operator|.
name|msg_perm
operator|.
name|uid
expr_stmt|;
comment|/* change the owner */
name|msqptr
operator|->
name|msg_perm
operator|.
name|gid
operator|=
name|msqbuf
operator|.
name|msg_perm
operator|.
name|gid
expr_stmt|;
comment|/* change the owner */
name|msqptr
operator|->
name|msg_perm
operator|.
name|mode
operator|=
operator|(
name|msqptr
operator|->
name|msg_perm
operator|.
name|mode
operator|&
operator|~
literal|0777
operator|)
operator||
operator|(
name|msqbuf
operator|.
name|msg_perm
operator|.
name|mode
operator|&
literal|0777
operator|)
expr_stmt|;
name|msqptr
operator|->
name|msg_qbytes
operator|=
name|msqbuf
operator|.
name|msg_qbytes
expr_stmt|;
name|msqptr
operator|->
name|msg_ctime
operator|=
name|time_second
expr_stmt|;
break|break;
case|case
name|IPC_STAT
case|:
if|if
condition|(
operator|(
name|eval
operator|=
name|ipcperm
argument_list|(
name|p
argument_list|,
operator|&
name|msqptr
operator|->
name|msg_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"requester doesn't have read access\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|eval
operator|)
return|;
block|}
name|eval
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|msqptr
argument_list|,
name|user_msqptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msqid_ds
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"invalid command %d\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|eval
operator|==
literal|0
condition|)
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|rval
expr_stmt|;
return|return
operator|(
name|eval
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|msgget_args
block|{
name|key_t
name|key
decl_stmt|;
name|int
name|msgflg
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|msgget
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|msgget_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|msqid
decl_stmt|,
name|eval
decl_stmt|;
name|int
name|key
init|=
name|uap
operator|->
name|key
decl_stmt|;
name|int
name|msgflg
init|=
name|uap
operator|->
name|msgflg
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|p
operator|->
name|p_ucred
decl_stmt|;
specifier|register
name|struct
name|msqid_ds
modifier|*
name|msqptr
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"msgget(0x%x, 0%o)\n"
argument_list|,
name|key
argument_list|,
name|msgflg
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|jail_sysvipc_allowed
operator|&&
name|jailed
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|)
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
if|if
condition|(
name|key
operator|!=
name|IPC_PRIVATE
condition|)
block|{
for|for
control|(
name|msqid
operator|=
literal|0
init|;
name|msqid
operator|<
name|msginfo
operator|.
name|msgmni
condition|;
name|msqid
operator|++
control|)
block|{
name|msqptr
operator|=
operator|&
name|msqids
index|[
name|msqid
index|]
expr_stmt|;
if|if
condition|(
name|msqptr
operator|->
name|msg_qbytes
operator|!=
literal|0
operator|&&
name|msqptr
operator|->
name|msg_perm
operator|.
name|key
operator|==
name|key
condition|)
break|break;
block|}
if|if
condition|(
name|msqid
operator|<
name|msginfo
operator|.
name|msgmni
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"found public key\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|msgflg
operator|&
name|IPC_CREAT
operator|)
operator|&&
operator|(
name|msgflg
operator|&
name|IPC_EXCL
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"not exclusive\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|eval
operator|=
name|ipcperm
argument_list|(
name|p
argument_list|,
operator|&
name|msqptr
operator|->
name|msg_perm
argument_list|,
name|msgflg
operator|&
literal|0700
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"requester doesn't have 0%o access\n"
argument_list|,
name|msgflg
operator|&
literal|0700
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|eval
operator|)
return|;
block|}
goto|goto
name|found
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"need to allocate the msqid_ds\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|key
operator|==
name|IPC_PRIVATE
operator|||
operator|(
name|msgflg
operator|&
name|IPC_CREAT
operator|)
condition|)
block|{
for|for
control|(
name|msqid
operator|=
literal|0
init|;
name|msqid
operator|<
name|msginfo
operator|.
name|msgmni
condition|;
name|msqid
operator|++
control|)
block|{
comment|/* 			 * Look for an unallocated and unlocked msqid_ds. 			 * msqid_ds's can be locked by msgsnd or msgrcv while 			 * they are copying the message in/out.  We can't 			 * re-use the entry until they release it. 			 */
name|msqptr
operator|=
operator|&
name|msqids
index|[
name|msqid
index|]
expr_stmt|;
if|if
condition|(
name|msqptr
operator|->
name|msg_qbytes
operator|==
literal|0
operator|&&
operator|(
name|msqptr
operator|->
name|msg_perm
operator|.
name|mode
operator|&
name|MSG_LOCKED
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|msqid
operator|==
name|msginfo
operator|.
name|msgmni
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"no more msqid_ds's available\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"msqid %d is available\n"
argument_list|,
name|msqid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|msqptr
operator|->
name|msg_perm
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|msqptr
operator|->
name|msg_perm
operator|.
name|cuid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|msqptr
operator|->
name|msg_perm
operator|.
name|uid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|msqptr
operator|->
name|msg_perm
operator|.
name|cgid
operator|=
name|cred
operator|->
name|cr_gid
expr_stmt|;
name|msqptr
operator|->
name|msg_perm
operator|.
name|gid
operator|=
name|cred
operator|->
name|cr_gid
expr_stmt|;
name|msqptr
operator|->
name|msg_perm
operator|.
name|mode
operator|=
operator|(
name|msgflg
operator|&
literal|0777
operator|)
expr_stmt|;
comment|/* Make sure that the returned msqid is unique */
name|msqptr
operator|->
name|msg_perm
operator|.
name|seq
operator|++
expr_stmt|;
name|msqptr
operator|->
name|msg_first
operator|=
name|NULL
expr_stmt|;
name|msqptr
operator|->
name|msg_last
operator|=
name|NULL
expr_stmt|;
name|msqptr
operator|->
name|msg_cbytes
operator|=
literal|0
expr_stmt|;
name|msqptr
operator|->
name|msg_qnum
operator|=
literal|0
expr_stmt|;
name|msqptr
operator|->
name|msg_qbytes
operator|=
name|msginfo
operator|.
name|msgmnb
expr_stmt|;
name|msqptr
operator|->
name|msg_lspid
operator|=
literal|0
expr_stmt|;
name|msqptr
operator|->
name|msg_lrpid
operator|=
literal|0
expr_stmt|;
name|msqptr
operator|->
name|msg_stime
operator|=
literal|0
expr_stmt|;
name|msqptr
operator|->
name|msg_rtime
operator|=
literal|0
expr_stmt|;
name|msqptr
operator|->
name|msg_ctime
operator|=
name|time_second
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"didn't find it and wasn't asked to create it\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|found
label|:
comment|/* Construct the unique msqid */
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|IXSEQ_TO_IPCID
argument_list|(
name|msqid
argument_list|,
name|msqptr
operator|->
name|msg_perm
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|msgsnd_args
block|{
name|int
name|msqid
decl_stmt|;
name|void
modifier|*
name|msgp
decl_stmt|;
name|size_t
name|msgsz
decl_stmt|;
name|int
name|msgflg
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|msgsnd
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|msgsnd_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|msqid
init|=
name|uap
operator|->
name|msqid
decl_stmt|;
name|void
modifier|*
name|user_msgp
init|=
name|uap
operator|->
name|msgp
decl_stmt|;
name|size_t
name|msgsz
init|=
name|uap
operator|->
name|msgsz
decl_stmt|;
name|int
name|msgflg
init|=
name|uap
operator|->
name|msgflg
decl_stmt|;
name|int
name|segs_needed
decl_stmt|,
name|eval
decl_stmt|;
specifier|register
name|struct
name|msqid_ds
modifier|*
name|msqptr
decl_stmt|;
specifier|register
name|struct
name|msg
modifier|*
name|msghdr
decl_stmt|;
name|short
name|next
decl_stmt|;
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"call to msgsnd(%d, 0x%x, %d, %d)\n"
argument_list|,
name|msqid
argument_list|,
name|user_msgp
argument_list|,
name|msgsz
argument_list|,
name|msgflg
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|jail_sysvipc_allowed
operator|&&
name|jailed
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|)
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
name|msqid
operator|=
name|IPCID_TO_IX
argument_list|(
name|msqid
argument_list|)
expr_stmt|;
if|if
condition|(
name|msqid
operator|<
literal|0
operator|||
name|msqid
operator|>=
name|msginfo
operator|.
name|msgmni
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"msqid (%d) out of range (0<=msqid<%d)\n"
argument_list|,
name|msqid
argument_list|,
name|msginfo
operator|.
name|msgmni
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|msqptr
operator|=
operator|&
name|msqids
index|[
name|msqid
index|]
expr_stmt|;
if|if
condition|(
name|msqptr
operator|->
name|msg_qbytes
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"no such message queue id\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|msqptr
operator|->
name|msg_perm
operator|.
name|seq
operator|!=
name|IPCID_TO_SEQ
argument_list|(
name|uap
operator|->
name|msqid
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"wrong sequence number\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|eval
operator|=
name|ipcperm
argument_list|(
name|p
argument_list|,
operator|&
name|msqptr
operator|->
name|msg_perm
argument_list|,
name|IPC_W
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"requester doesn't have write access\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|eval
operator|)
return|;
block|}
name|segs_needed
operator|=
operator|(
name|msgsz
operator|+
name|msginfo
operator|.
name|msgssz
operator|-
literal|1
operator|)
operator|/
name|msginfo
operator|.
name|msgssz
expr_stmt|;
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"msgsz=%d, msgssz=%d, segs_needed=%d\n"
argument_list|,
name|msgsz
argument_list|,
name|msginfo
operator|.
name|msgssz
argument_list|,
name|segs_needed
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|need_more_resources
init|=
literal|0
decl_stmt|;
comment|/* 		 * check msgsz 		 * (inside this loop in case msg_qbytes changes while we sleep) 		 */
if|if
condition|(
name|msgsz
operator|>
name|msqptr
operator|->
name|msg_qbytes
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"msgsz> msqptr->msg_qbytes\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|msqptr
operator|->
name|msg_perm
operator|.
name|mode
operator|&
name|MSG_LOCKED
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"msqid is locked\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|need_more_resources
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|msgsz
operator|+
name|msqptr
operator|->
name|msg_cbytes
operator|>
name|msqptr
operator|->
name|msg_qbytes
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"msgsz + msg_cbytes> msg_qbytes\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|need_more_resources
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|segs_needed
operator|>
name|nfree_msgmaps
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"segs_needed> nfree_msgmaps\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|need_more_resources
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|free_msghdrs
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"no more msghdrs\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|need_more_resources
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|need_more_resources
condition|)
block|{
name|int
name|we_own_it
decl_stmt|;
if|if
condition|(
operator|(
name|msgflg
operator|&
name|IPC_NOWAIT
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"need more resources but caller doesn't want to wait\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|msqptr
operator|->
name|msg_perm
operator|.
name|mode
operator|&
name|MSG_LOCKED
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"we don't own the msqid_ds\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|we_own_it
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Force later arrivals to wait for our 				   request */
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"we own the msqid_ds\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|msqptr
operator|->
name|msg_perm
operator|.
name|mode
operator||=
name|MSG_LOCKED
expr_stmt|;
name|we_own_it
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"goodnight\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|eval
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|msqptr
argument_list|,
operator|(
name|PZERO
operator|-
literal|4
operator|)
operator||
name|PCATCH
argument_list|,
literal|"msgwait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"good morning, eval=%d\n"
argument_list|,
name|eval
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|we_own_it
condition|)
name|msqptr
operator|->
name|msg_perm
operator|.
name|mode
operator|&=
operator|~
name|MSG_LOCKED
expr_stmt|;
if|if
condition|(
name|eval
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"msgsnd:  interrupted system call\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
comment|/* 			 * Make sure that the msq queue still exists 			 */
if|if
condition|(
name|msqptr
operator|->
name|msg_qbytes
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"msqid deleted\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EIDRM
operator|)
return|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"got all the resources that we need\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
comment|/* 	 * We have the resources that we need. 	 * Make sure! 	 */
if|if
condition|(
name|msqptr
operator|->
name|msg_perm
operator|.
name|mode
operator|&
name|MSG_LOCKED
condition|)
name|panic
argument_list|(
literal|"msg_perm.mode& MSG_LOCKED"
argument_list|)
expr_stmt|;
if|if
condition|(
name|segs_needed
operator|>
name|nfree_msgmaps
condition|)
name|panic
argument_list|(
literal|"segs_needed> nfree_msgmaps"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgsz
operator|+
name|msqptr
operator|->
name|msg_cbytes
operator|>
name|msqptr
operator|->
name|msg_qbytes
condition|)
name|panic
argument_list|(
literal|"msgsz + msg_cbytes> msg_qbytes"
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_msghdrs
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"no more msghdrs"
argument_list|)
expr_stmt|;
comment|/* 	 * Re-lock the msqid_ds in case we page-fault when copying in the 	 * message 	 */
if|if
condition|(
operator|(
name|msqptr
operator|->
name|msg_perm
operator|.
name|mode
operator|&
name|MSG_LOCKED
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"msqid_ds is already locked"
argument_list|)
expr_stmt|;
name|msqptr
operator|->
name|msg_perm
operator|.
name|mode
operator||=
name|MSG_LOCKED
expr_stmt|;
comment|/* 	 * Allocate a message header 	 */
name|msghdr
operator|=
name|free_msghdrs
expr_stmt|;
name|free_msghdrs
operator|=
name|msghdr
operator|->
name|msg_next
expr_stmt|;
name|msghdr
operator|->
name|msg_spot
operator|=
operator|-
literal|1
expr_stmt|;
name|msghdr
operator|->
name|msg_ts
operator|=
name|msgsz
expr_stmt|;
comment|/* 	 * Allocate space for the message 	 */
while|while
condition|(
name|segs_needed
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|nfree_msgmaps
operator|<=
literal|0
condition|)
name|panic
argument_list|(
literal|"not enough msgmaps"
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_msgmaps
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"nil free_msgmaps"
argument_list|)
expr_stmt|;
name|next
operator|=
name|free_msgmaps
expr_stmt|;
if|if
condition|(
name|next
operator|<=
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"next too low #1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|>=
name|msginfo
operator|.
name|msgseg
condition|)
name|panic
argument_list|(
literal|"next out of range #1"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"allocating segment %d to message\n"
argument_list|,
name|next
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free_msgmaps
operator|=
name|msgmaps
index|[
name|next
index|]
operator|.
name|next
expr_stmt|;
name|nfree_msgmaps
operator|--
expr_stmt|;
name|msgmaps
index|[
name|next
index|]
operator|.
name|next
operator|=
name|msghdr
operator|->
name|msg_spot
expr_stmt|;
name|msghdr
operator|->
name|msg_spot
operator|=
name|next
expr_stmt|;
name|segs_needed
operator|--
expr_stmt|;
block|}
comment|/* 	 * Copy in the message type 	 */
if|if
condition|(
operator|(
name|eval
operator|=
name|copyin
argument_list|(
name|user_msgp
argument_list|,
operator|&
name|msghdr
operator|->
name|msg_type
argument_list|,
sizeof|sizeof
argument_list|(
name|msghdr
operator|->
name|msg_type
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"error %d copying the message type\n"
argument_list|,
name|eval
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|msg_freehdr
argument_list|(
name|msghdr
argument_list|)
expr_stmt|;
name|msqptr
operator|->
name|msg_perm
operator|.
name|mode
operator|&=
operator|~
name|MSG_LOCKED
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|msqptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|eval
operator|)
return|;
block|}
name|user_msgp
operator|=
operator|(
name|char
operator|*
operator|)
name|user_msgp
operator|+
sizeof|sizeof
argument_list|(
name|msghdr
operator|->
name|msg_type
argument_list|)
expr_stmt|;
comment|/* 	 * Validate the message type 	 */
if|if
condition|(
name|msghdr
operator|->
name|msg_type
operator|<
literal|1
condition|)
block|{
name|msg_freehdr
argument_list|(
name|msghdr
argument_list|)
expr_stmt|;
name|msqptr
operator|->
name|msg_perm
operator|.
name|mode
operator|&=
operator|~
name|MSG_LOCKED
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|msqptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"mtype (%d)< 1\n"
argument_list|,
name|msghdr
operator|->
name|msg_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Copy in the message body 	 */
name|next
operator|=
name|msghdr
operator|->
name|msg_spot
expr_stmt|;
while|while
condition|(
name|msgsz
operator|>
literal|0
condition|)
block|{
name|size_t
name|tlen
decl_stmt|;
if|if
condition|(
name|msgsz
operator|>
name|msginfo
operator|.
name|msgssz
condition|)
name|tlen
operator|=
name|msginfo
operator|.
name|msgssz
expr_stmt|;
else|else
name|tlen
operator|=
name|msgsz
expr_stmt|;
if|if
condition|(
name|next
operator|<=
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"next too low #2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|>=
name|msginfo
operator|.
name|msgseg
condition|)
name|panic
argument_list|(
literal|"next out of range #2"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|eval
operator|=
name|copyin
argument_list|(
name|user_msgp
argument_list|,
operator|&
name|msgpool
index|[
name|next
operator|*
name|msginfo
operator|.
name|msgssz
index|]
argument_list|,
name|tlen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"error %d copying in message segment\n"
argument_list|,
name|eval
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|msg_freehdr
argument_list|(
name|msghdr
argument_list|)
expr_stmt|;
name|msqptr
operator|->
name|msg_perm
operator|.
name|mode
operator|&=
operator|~
name|MSG_LOCKED
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|msqptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|eval
operator|)
return|;
block|}
name|msgsz
operator|-=
name|tlen
expr_stmt|;
name|user_msgp
operator|=
operator|(
name|char
operator|*
operator|)
name|user_msgp
operator|+
name|tlen
expr_stmt|;
name|next
operator|=
name|msgmaps
index|[
name|next
index|]
operator|.
name|next
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|!=
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"didn't use all the msg segments"
argument_list|)
expr_stmt|;
comment|/* 	 * We've got the message.  Unlock the msqid_ds. 	 */
name|msqptr
operator|->
name|msg_perm
operator|.
name|mode
operator|&=
operator|~
name|MSG_LOCKED
expr_stmt|;
comment|/* 	 * Make sure that the msqid_ds is still allocated. 	 */
if|if
condition|(
name|msqptr
operator|->
name|msg_qbytes
operator|==
literal|0
condition|)
block|{
name|msg_freehdr
argument_list|(
name|msghdr
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|msqptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIDRM
operator|)
return|;
block|}
comment|/* 	 * Put the message into the queue 	 */
if|if
condition|(
name|msqptr
operator|->
name|msg_first
operator|==
name|NULL
condition|)
block|{
name|msqptr
operator|->
name|msg_first
operator|=
name|msghdr
expr_stmt|;
name|msqptr
operator|->
name|msg_last
operator|=
name|msghdr
expr_stmt|;
block|}
else|else
block|{
name|msqptr
operator|->
name|msg_last
operator|->
name|msg_next
operator|=
name|msghdr
expr_stmt|;
name|msqptr
operator|->
name|msg_last
operator|=
name|msghdr
expr_stmt|;
block|}
name|msqptr
operator|->
name|msg_last
operator|->
name|msg_next
operator|=
name|NULL
expr_stmt|;
name|msqptr
operator|->
name|msg_cbytes
operator|+=
name|msghdr
operator|->
name|msg_ts
expr_stmt|;
name|msqptr
operator|->
name|msg_qnum
operator|++
expr_stmt|;
name|msqptr
operator|->
name|msg_lspid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|msqptr
operator|->
name|msg_stime
operator|=
name|time_second
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|msqptr
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|msgrcv_args
block|{
name|int
name|msqid
decl_stmt|;
name|void
modifier|*
name|msgp
decl_stmt|;
name|size_t
name|msgsz
decl_stmt|;
name|long
name|msgtyp
decl_stmt|;
name|int
name|msgflg
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|msgrcv
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|msgrcv_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|msqid
init|=
name|uap
operator|->
name|msqid
decl_stmt|;
name|void
modifier|*
name|user_msgp
init|=
name|uap
operator|->
name|msgp
decl_stmt|;
name|size_t
name|msgsz
init|=
name|uap
operator|->
name|msgsz
decl_stmt|;
name|long
name|msgtyp
init|=
name|uap
operator|->
name|msgtyp
decl_stmt|;
name|int
name|msgflg
init|=
name|uap
operator|->
name|msgflg
decl_stmt|;
name|size_t
name|len
decl_stmt|;
specifier|register
name|struct
name|msqid_ds
modifier|*
name|msqptr
decl_stmt|;
specifier|register
name|struct
name|msg
modifier|*
name|msghdr
decl_stmt|;
name|int
name|eval
decl_stmt|;
name|short
name|next
decl_stmt|;
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"call to msgrcv(%d, 0x%x, %d, %ld, %d)\n"
argument_list|,
name|msqid
argument_list|,
name|user_msgp
argument_list|,
name|msgsz
argument_list|,
name|msgtyp
argument_list|,
name|msgflg
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|jail_sysvipc_allowed
operator|&&
name|jailed
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|)
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
name|msqid
operator|=
name|IPCID_TO_IX
argument_list|(
name|msqid
argument_list|)
expr_stmt|;
if|if
condition|(
name|msqid
operator|<
literal|0
operator|||
name|msqid
operator|>=
name|msginfo
operator|.
name|msgmni
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"msqid (%d) out of range (0<=msqid<%d)\n"
argument_list|,
name|msqid
argument_list|,
name|msginfo
operator|.
name|msgmni
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|msqptr
operator|=
operator|&
name|msqids
index|[
name|msqid
index|]
expr_stmt|;
if|if
condition|(
name|msqptr
operator|->
name|msg_qbytes
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"no such message queue id\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|msqptr
operator|->
name|msg_perm
operator|.
name|seq
operator|!=
name|IPCID_TO_SEQ
argument_list|(
name|uap
operator|->
name|msqid
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"wrong sequence number\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|eval
operator|=
name|ipcperm
argument_list|(
name|p
argument_list|,
operator|&
name|msqptr
operator|->
name|msg_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"requester doesn't have read access\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|eval
operator|)
return|;
block|}
name|msghdr
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|msghdr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|msgtyp
operator|==
literal|0
condition|)
block|{
name|msghdr
operator|=
name|msqptr
operator|->
name|msg_first
expr_stmt|;
if|if
condition|(
name|msghdr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|msgsz
operator|<
name|msghdr
operator|->
name|msg_ts
operator|&&
operator|(
name|msgflg
operator|&
name|MSG_NOERROR
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"first message on the queue is too big (want %d, got %d)\n"
argument_list|,
name|msgsz
argument_list|,
name|msghdr
operator|->
name|msg_ts
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|E2BIG
operator|)
return|;
block|}
if|if
condition|(
name|msqptr
operator|->
name|msg_first
operator|==
name|msqptr
operator|->
name|msg_last
condition|)
block|{
name|msqptr
operator|->
name|msg_first
operator|=
name|NULL
expr_stmt|;
name|msqptr
operator|->
name|msg_last
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|msqptr
operator|->
name|msg_first
operator|=
name|msghdr
operator|->
name|msg_next
expr_stmt|;
if|if
condition|(
name|msqptr
operator|->
name|msg_first
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"msg_first/last screwed up #1"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|struct
name|msg
modifier|*
name|previous
decl_stmt|;
name|struct
name|msg
modifier|*
modifier|*
name|prev
decl_stmt|;
name|previous
operator|=
name|NULL
expr_stmt|;
name|prev
operator|=
operator|&
operator|(
name|msqptr
operator|->
name|msg_first
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|msghdr
operator|=
operator|*
name|prev
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Is this message's type an exact match or is 				 * this message's type less than or equal to 				 * the absolute value of a negative msgtyp? 				 * Note that the second half of this test can 				 * NEVER be true if msgtyp is positive since 				 * msg_type is always positive! 				 */
if|if
condition|(
name|msgtyp
operator|==
name|msghdr
operator|->
name|msg_type
operator|||
name|msghdr
operator|->
name|msg_type
operator|<=
operator|-
name|msgtyp
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"found message type %d, requested %d\n"
argument_list|,
name|msghdr
operator|->
name|msg_type
argument_list|,
name|msgtyp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|msgsz
operator|<
name|msghdr
operator|->
name|msg_ts
operator|&&
operator|(
name|msgflg
operator|&
name|MSG_NOERROR
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"requested message on the queue is too big (want %d, got %d)\n"
argument_list|,
name|msgsz
argument_list|,
name|msghdr
operator|->
name|msg_ts
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|E2BIG
operator|)
return|;
block|}
operator|*
name|prev
operator|=
name|msghdr
operator|->
name|msg_next
expr_stmt|;
if|if
condition|(
name|msghdr
operator|==
name|msqptr
operator|->
name|msg_last
condition|)
block|{
if|if
condition|(
name|previous
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|prev
operator|!=
operator|&
name|msqptr
operator|->
name|msg_first
condition|)
name|panic
argument_list|(
literal|"msg_first/last screwed up #2"
argument_list|)
expr_stmt|;
name|msqptr
operator|->
name|msg_first
operator|=
name|NULL
expr_stmt|;
name|msqptr
operator|->
name|msg_last
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|prev
operator|==
operator|&
name|msqptr
operator|->
name|msg_first
condition|)
name|panic
argument_list|(
literal|"msg_first/last screwed up #3"
argument_list|)
expr_stmt|;
name|msqptr
operator|->
name|msg_last
operator|=
name|previous
expr_stmt|;
block|}
block|}
break|break;
block|}
name|previous
operator|=
name|msghdr
expr_stmt|;
name|prev
operator|=
operator|&
operator|(
name|msghdr
operator|->
name|msg_next
operator|)
expr_stmt|;
block|}
block|}
comment|/* 		 * We've either extracted the msghdr for the appropriate 		 * message or there isn't one. 		 * If there is one then bail out of this loop. 		 */
if|if
condition|(
name|msghdr
operator|!=
name|NULL
condition|)
break|break;
comment|/* 		 * Hmph!  No message found.  Does the user want to wait? 		 */
if|if
condition|(
operator|(
name|msgflg
operator|&
name|IPC_NOWAIT
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"no appropriate message found (msgtyp=%d)\n"
argument_list|,
name|msgtyp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* The SVID says to return ENOMSG. */
ifdef|#
directive|ifdef
name|ENOMSG
return|return
operator|(
name|ENOMSG
operator|)
return|;
else|#
directive|else
comment|/* Unfortunately, BSD doesn't define that code yet! */
return|return
operator|(
name|EAGAIN
operator|)
return|;
endif|#
directive|endif
block|}
comment|/* 		 * Wait for something to happen 		 */
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"msgrcv:  goodnight\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|eval
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|msqptr
argument_list|,
operator|(
name|PZERO
operator|-
literal|4
operator|)
operator||
name|PCATCH
argument_list|,
literal|"msgwait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"msgrcv:  good morning (eval=%d)\n"
argument_list|,
name|eval
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|eval
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"msgsnd:  interrupted system call\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
comment|/* 		 * Make sure that the msq queue still exists 		 */
if|if
condition|(
name|msqptr
operator|->
name|msg_qbytes
operator|==
literal|0
operator|||
name|msqptr
operator|->
name|msg_perm
operator|.
name|seq
operator|!=
name|IPCID_TO_SEQ
argument_list|(
name|uap
operator|->
name|msqid
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"msqid deleted\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EIDRM
operator|)
return|;
block|}
block|}
comment|/* 	 * Return the message to the user. 	 * 	 * First, do the bookkeeping (before we risk being interrupted). 	 */
name|msqptr
operator|->
name|msg_cbytes
operator|-=
name|msghdr
operator|->
name|msg_ts
expr_stmt|;
name|msqptr
operator|->
name|msg_qnum
operator|--
expr_stmt|;
name|msqptr
operator|->
name|msg_lrpid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|msqptr
operator|->
name|msg_rtime
operator|=
name|time_second
expr_stmt|;
comment|/* 	 * Make msgsz the actual amount that we'll be returning. 	 * Note that this effectively truncates the message if it is too long 	 * (since msgsz is never increased). 	 */
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"found a message, msgsz=%d, msg_ts=%d\n"
argument_list|,
name|msgsz
argument_list|,
name|msghdr
operator|->
name|msg_ts
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|msgsz
operator|>
name|msghdr
operator|->
name|msg_ts
condition|)
name|msgsz
operator|=
name|msghdr
operator|->
name|msg_ts
expr_stmt|;
comment|/* 	 * Return the type to the user. 	 */
name|eval
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
operator|(
name|msghdr
operator|->
name|msg_type
operator|)
argument_list|,
name|user_msgp
argument_list|,
sizeof|sizeof
argument_list|(
name|msghdr
operator|->
name|msg_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eval
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"error (%d) copying out message type\n"
argument_list|,
name|eval
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|msg_freehdr
argument_list|(
name|msghdr
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|msqptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|eval
operator|)
return|;
block|}
name|user_msgp
operator|=
operator|(
name|char
operator|*
operator|)
name|user_msgp
operator|+
sizeof|sizeof
argument_list|(
name|msghdr
operator|->
name|msg_type
argument_list|)
expr_stmt|;
comment|/* 	 * Return the segments to the user 	 */
name|next
operator|=
name|msghdr
operator|->
name|msg_spot
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
name|msgsz
condition|;
name|len
operator|+=
name|msginfo
operator|.
name|msgssz
control|)
block|{
name|size_t
name|tlen
decl_stmt|;
if|if
condition|(
name|msgsz
operator|-
name|len
operator|>
name|msginfo
operator|.
name|msgssz
condition|)
name|tlen
operator|=
name|msginfo
operator|.
name|msgssz
expr_stmt|;
else|else
name|tlen
operator|=
name|msgsz
operator|-
name|len
expr_stmt|;
if|if
condition|(
name|next
operator|<=
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"next too low #3"
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|>=
name|msginfo
operator|.
name|msgseg
condition|)
name|panic
argument_list|(
literal|"next out of range #3"
argument_list|)
expr_stmt|;
name|eval
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|msgpool
index|[
name|next
operator|*
name|msginfo
operator|.
name|msgssz
index|]
argument_list|,
name|user_msgp
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|eval
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MSG_DEBUG_OK
name|printf
argument_list|(
literal|"error (%d) copying out message segment\n"
argument_list|,
name|eval
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|msg_freehdr
argument_list|(
name|msghdr
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|msqptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|eval
operator|)
return|;
block|}
name|user_msgp
operator|=
operator|(
name|char
operator|*
operator|)
name|user_msgp
operator|+
name|tlen
expr_stmt|;
name|next
operator|=
name|msgmaps
index|[
name|next
index|]
operator|.
name|next
expr_stmt|;
block|}
comment|/* 	 * Done, return the actual number of bytes copied out. 	 */
name|msg_freehdr
argument_list|(
name|msghdr
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|msqptr
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|msgsz
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

