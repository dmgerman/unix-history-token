begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Implementation of SVID semaphores  *  * Author:  Daniel Boulet  *  * This software is provided ``AS IS'' without any warranties of any kind.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2003-2005 McAfee, Inc.  * All rights reserved.  *  * This software was developed for the FreeBSD Project in part by McAfee  * Research, the Security Research Division of McAfee, Inc under DARPA/SPAWAR  * contract N66001-01-C-8035 ("CBOSS"), as part of the DARPA CHATS research  * program.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_sysvipc.h"
end_include

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sem.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_SEM
argument_list|,
literal|"sem"
argument_list|,
literal|"SVID compatible semaphores"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SEM_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|a
parameter_list|)
value|printf a
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|a
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|seminit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysvsem_modload
parameter_list|(
name|struct
name|module
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|semunload
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|semexit_myhook
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_sema
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|semvalid
parameter_list|(
name|int
name|semid
parameter_list|,
name|struct
name|semid_kernel
modifier|*
name|semakptr
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct_decl
struct_decl|struct
name|__semctl_args
struct_decl|;
end_struct_decl

begin_function_decl
name|int
name|__semctl
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|__semctl_args
modifier|*
name|uap
parameter_list|)
function_decl|;
end_function_decl

begin_struct_decl
struct_decl|struct
name|semget_args
struct_decl|;
end_struct_decl

begin_function_decl
name|int
name|semget
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|semget_args
modifier|*
name|uap
parameter_list|)
function_decl|;
end_function_decl

begin_struct_decl
struct_decl|struct
name|semop_args
struct_decl|;
end_struct_decl

begin_function_decl
name|int
name|semop
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|semop_args
modifier|*
name|uap
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|sem_undo
modifier|*
name|semu_alloc
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|semundo_adjust
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|sem_undo
modifier|*
modifier|*
name|supptr
parameter_list|,
name|int
name|semid
parameter_list|,
name|int
name|semnum
parameter_list|,
name|int
name|adjval
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|semundo_clear
parameter_list|(
name|int
name|semid
parameter_list|,
name|int
name|semnum
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* XXX casting to (sy_call_t *) is bogus, as usual. */
end_comment

begin_decl_stmt
specifier|static
name|sy_call_t
modifier|*
name|semcalls
index|[]
init|=
block|{
operator|(
name|sy_call_t
operator|*
operator|)
name|__semctl
block|,
operator|(
name|sy_call_t
operator|*
operator|)
name|semget
block|,
operator|(
name|sy_call_t
operator|*
operator|)
name|semop
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|sem_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* semaphore global lock */
end_comment

begin_decl_stmt
specifier|static
name|int
name|semtot
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|semid_kernel
modifier|*
name|sema
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* semaphore id pool */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
modifier|*
name|sema_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* semaphore id pool mutexes*/
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sem
modifier|*
name|sem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* semaphore pool */
end_comment

begin_macro
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|sem_undo
argument_list|)
end_macro

begin_expr_stmt
name|semu_list
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* list of active undo structures */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|semu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* undo structure pool */
end_comment

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|semexit_tag
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SEMUNDO_MTX
value|sem_mtx
end_define

begin_define
define|#
directive|define
name|SEMUNDO_LOCK
parameter_list|()
value|mtx_lock(&SEMUNDO_MTX);
end_define

begin_define
define|#
directive|define
name|SEMUNDO_UNLOCK
parameter_list|()
value|mtx_unlock(&SEMUNDO_MTX);
end_define

begin_define
define|#
directive|define
name|SEMUNDO_LOCKASSERT
parameter_list|(
name|how
parameter_list|)
value|mtx_assert(&SEMUNDO_MTX, (how));
end_define

begin_struct
struct|struct
name|sem
block|{
name|u_short
name|semval
decl_stmt|;
comment|/* semaphore value */
name|pid_t
name|sempid
decl_stmt|;
comment|/* pid of last operation */
name|u_short
name|semncnt
decl_stmt|;
comment|/* # awaiting semval> cval */
name|u_short
name|semzcnt
decl_stmt|;
comment|/* # awaiting semval = 0 */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Undo structure (one per process)  */
end_comment

begin_struct
struct|struct
name|sem_undo
block|{
name|SLIST_ENTRY
argument_list|(
argument|sem_undo
argument_list|)
name|un_next
expr_stmt|;
comment|/* ptr to next active undo structure */
name|struct
name|proc
modifier|*
name|un_proc
decl_stmt|;
comment|/* owner of this structure */
name|short
name|un_cnt
decl_stmt|;
comment|/* # of active entries */
struct|struct
name|undo
block|{
name|short
name|un_adjval
decl_stmt|;
comment|/* adjust on exit values */
name|short
name|un_num
decl_stmt|;
comment|/* semaphore # */
name|int
name|un_id
decl_stmt|;
comment|/* semid */
block|}
name|un_ent
index|[
literal|1
index|]
struct|;
comment|/* undo entries */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Configuration parameters  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SEMMNI
end_ifndef

begin_define
define|#
directive|define
name|SEMMNI
value|10
end_define

begin_comment
comment|/* # of semaphore identifiers */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SEMMNS
end_ifndef

begin_define
define|#
directive|define
name|SEMMNS
value|60
end_define

begin_comment
comment|/* # of semaphores in system */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SEMUME
end_ifndef

begin_define
define|#
directive|define
name|SEMUME
value|10
end_define

begin_comment
comment|/* max # of undo entries per process */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SEMMNU
end_ifndef

begin_define
define|#
directive|define
name|SEMMNU
value|30
end_define

begin_comment
comment|/* # of undo structures in system */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* shouldn't need tuning */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SEMMAP
end_ifndef

begin_define
define|#
directive|define
name|SEMMAP
value|30
end_define

begin_comment
comment|/* # of entries in semaphore map */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SEMMSL
end_ifndef

begin_define
define|#
directive|define
name|SEMMSL
value|SEMMNS
end_define

begin_comment
comment|/* max # of semaphores per id */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SEMOPM
end_ifndef

begin_define
define|#
directive|define
name|SEMOPM
value|100
end_define

begin_comment
comment|/* max # of operations per semop call */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SEMVMX
value|32767
end_define

begin_comment
comment|/* semaphore maximum value */
end_comment

begin_define
define|#
directive|define
name|SEMAEM
value|16384
end_define

begin_comment
comment|/* adjust on exit max value */
end_comment

begin_comment
comment|/*  * Due to the way semaphore memory is allocated, we have to ensure that  * SEMUSZ is properly aligned.  */
end_comment

begin_define
define|#
directive|define
name|SEM_ALIGN
parameter_list|(
name|bytes
parameter_list|)
value|(((bytes) + (sizeof(long) - 1))& ~(sizeof(long) - 1))
end_define

begin_comment
comment|/* actual size of an undo structure */
end_comment

begin_define
define|#
directive|define
name|SEMUSZ
value|SEM_ALIGN(offsetof(struct sem_undo, un_ent[SEMUME]))
end_define

begin_comment
comment|/*  * Macro to find a particular sem_undo vector  */
end_comment

begin_define
define|#
directive|define
name|SEMU
parameter_list|(
name|ix
parameter_list|)
define|\
value|((struct sem_undo *)(((intptr_t)semu)+ix * seminfo.semusz))
end_define

begin_comment
comment|/*  * semaphore info struct  */
end_comment

begin_decl_stmt
name|struct
name|seminfo
name|seminfo
init|=
block|{
name|SEMMAP
block|,
comment|/* # of entries in semaphore map */
name|SEMMNI
block|,
comment|/* # of semaphore identifiers */
name|SEMMNS
block|,
comment|/* # of semaphores in system */
name|SEMMNU
block|,
comment|/* # of undo structures in system */
name|SEMMSL
block|,
comment|/* max # of semaphores per id */
name|SEMOPM
block|,
comment|/* max # of operations per semop call */
name|SEMUME
block|,
comment|/* max # of undo entries per process */
name|SEMUSZ
block|,
comment|/* size in bytes of undo structure */
name|SEMVMX
block|,
comment|/* semaphore maximum value */
name|SEMAEM
comment|/* adjust on exit max value */
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|semmap
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|seminfo
operator|.
name|semmap
argument_list|,
literal|0
argument_list|,
literal|"Number of entries in the semaphore map"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|semmni
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|seminfo
operator|.
name|semmni
argument_list|,
literal|0
argument_list|,
literal|"Number of semaphore identifiers"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|semmns
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|seminfo
operator|.
name|semmns
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of semaphores in the system"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|semmnu
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|seminfo
operator|.
name|semmnu
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of undo structures in the system"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|semmsl
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|seminfo
operator|.
name|semmsl
argument_list|,
literal|0
argument_list|,
literal|"Max semaphores per id"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|semopm
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|seminfo
operator|.
name|semopm
argument_list|,
literal|0
argument_list|,
literal|"Max operations per semop call"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|semume
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|seminfo
operator|.
name|semume
argument_list|,
literal|0
argument_list|,
literal|"Max undo entries per process"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|semusz
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|seminfo
operator|.
name|semusz
argument_list|,
literal|0
argument_list|,
literal|"Size in bytes of undo structure"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|semvmx
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|seminfo
operator|.
name|semvmx
argument_list|,
literal|0
argument_list|,
literal|"Semaphore maximum value"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|semaem
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|seminfo
operator|.
name|semaem
argument_list|,
literal|0
argument_list|,
literal|"Adjust on exit max value"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|sema
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_sema
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|seminit
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.semmap"
argument_list|,
operator|&
name|seminfo
operator|.
name|semmap
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.semmni"
argument_list|,
operator|&
name|seminfo
operator|.
name|semmni
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.semmns"
argument_list|,
operator|&
name|seminfo
operator|.
name|semmns
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.semmnu"
argument_list|,
operator|&
name|seminfo
operator|.
name|semmnu
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.semmsl"
argument_list|,
operator|&
name|seminfo
operator|.
name|semmsl
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.semopm"
argument_list|,
operator|&
name|seminfo
operator|.
name|semopm
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.semume"
argument_list|,
operator|&
name|seminfo
operator|.
name|semume
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.semusz"
argument_list|,
operator|&
name|seminfo
operator|.
name|semusz
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.semvmx"
argument_list|,
operator|&
name|seminfo
operator|.
name|semvmx
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.semaem"
argument_list|,
operator|&
name|seminfo
operator|.
name|semaem
argument_list|)
expr_stmt|;
name|sem
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sem
argument_list|)
operator|*
name|seminfo
operator|.
name|semmns
argument_list|,
name|M_SEM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sema
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|semid_kernel
argument_list|)
operator|*
name|seminfo
operator|.
name|semmni
argument_list|,
name|M_SEM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sema_mtx
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mtx
argument_list|)
operator|*
name|seminfo
operator|.
name|semmni
argument_list|,
name|M_SEM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|semu
operator|=
name|malloc
argument_list|(
name|seminfo
operator|.
name|semmnu
operator|*
name|seminfo
operator|.
name|semusz
argument_list|,
name|M_SEM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seminfo
operator|.
name|semmni
condition|;
name|i
operator|++
control|)
block|{
name|sema
index|[
name|i
index|]
operator|.
name|u
operator|.
name|sem_base
operator|=
literal|0
expr_stmt|;
name|sema
index|[
name|i
index|]
operator|.
name|u
operator|.
name|sem_perm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|sema
index|[
name|i
index|]
operator|.
name|u
operator|.
name|sem_perm
operator|.
name|seq
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_init_sysv_sem
argument_list|(
operator|&
name|sema
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seminfo
operator|.
name|semmni
condition|;
name|i
operator|++
control|)
name|mtx_init
argument_list|(
operator|&
name|sema_mtx
index|[
name|i
index|]
argument_list|,
literal|"semid"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seminfo
operator|.
name|semmnu
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|sem_undo
modifier|*
name|suptr
init|=
name|SEMU
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|suptr
operator|->
name|un_proc
operator|=
name|NULL
expr_stmt|;
block|}
name|SLIST_INIT
argument_list|(
operator|&
name|semu_list
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sem_mtx
argument_list|,
literal|"sem"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|semexit_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|process_exit
argument_list|,
name|semexit_myhook
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|semunload
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|semtot
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|process_exit
argument_list|,
name|semexit_tag
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seminfo
operator|.
name|semmni
condition|;
name|i
operator|++
control|)
name|mac_destroy_sysv_sem
argument_list|(
operator|&
name|sema
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|sem
argument_list|,
name|M_SEM
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sema
argument_list|,
name|M_SEM
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|semu
argument_list|,
name|M_SEM
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seminfo
operator|.
name|semmni
condition|;
name|i
operator|++
control|)
name|mtx_destroy
argument_list|(
operator|&
name|sema_mtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sem_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysvsem_modload
parameter_list|(
name|struct
name|module
modifier|*
name|module
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|seminit
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|error
operator|=
name|semunload
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|sysvsem_mod
init|=
block|{
literal|"sysvsem"
block|,
operator|&
name|sysvsem_modload
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|semsys
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|__semctl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|semget
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|semop
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|sysvsem
argument_list|,
name|sysvsem_mod
argument_list|,
name|SI_SUB_SYSV_SEM
argument_list|,
name|SI_ORDER_FIRST
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|sysvsem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Entry point for all SEM calls.  */
end_comment

begin_function
name|int
name|semsys
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
comment|/* XXX actually varargs. */
name|struct
name|semsys_args
comment|/* { 		int	which; 		int	a2; 		int	a3; 		int	a4; 		int	a5; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|jail_sysvipc_allowed
operator|&&
name|jailed
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|which
operator|<
literal|0
operator|||
name|uap
operator|->
name|which
operator|>=
sizeof|sizeof
argument_list|(
name|semcalls
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|semcalls
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
call|(
modifier|*
name|semcalls
index|[
name|uap
operator|->
name|which
index|]
call|)
argument_list|(
name|td
argument_list|,
operator|&
name|uap
operator|->
name|a2
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new sem_undo structure for a process  * (returns ptr to structure or NULL if no more room)  */
end_comment

begin_function
specifier|static
name|struct
name|sem_undo
modifier|*
name|semu_alloc
parameter_list|(
name|td
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|sem_undo
modifier|*
name|suptr
decl_stmt|;
name|struct
name|sem_undo
modifier|*
modifier|*
name|supptr
decl_stmt|;
name|int
name|attempt
decl_stmt|;
name|SEMUNDO_LOCKASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Try twice to allocate something. 	 * (we'll purge an empty structure after the first pass so 	 * two passes are always enough) 	 */
for|for
control|(
name|attempt
operator|=
literal|0
init|;
name|attempt
operator|<
literal|2
condition|;
name|attempt
operator|++
control|)
block|{
comment|/* 		 * Look for a free structure. 		 * Fill it in and return it if we find one. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seminfo
operator|.
name|semmnu
condition|;
name|i
operator|++
control|)
block|{
name|suptr
operator|=
name|SEMU
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|suptr
operator|->
name|un_proc
operator|==
name|NULL
condition|)
block|{
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|semu_list
argument_list|,
name|suptr
argument_list|,
name|un_next
argument_list|)
expr_stmt|;
name|suptr
operator|->
name|un_cnt
operator|=
literal|0
expr_stmt|;
name|suptr
operator|->
name|un_proc
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
return|return
operator|(
name|suptr
operator|)
return|;
block|}
block|}
comment|/* 		 * We didn't find a free one, if this is the first attempt 		 * then try to free a structure. 		 */
if|if
condition|(
name|attempt
operator|==
literal|0
condition|)
block|{
comment|/* All the structures are in use - try to free one */
name|int
name|did_something
init|=
literal|0
decl_stmt|;
name|SLIST_FOREACH_PREVPTR
argument_list|(
argument|suptr
argument_list|,
argument|supptr
argument_list|,
argument|&semu_list
argument_list|,
argument|un_next
argument_list|)
block|{
if|if
condition|(
name|suptr
operator|->
name|un_cnt
operator|==
literal|0
condition|)
block|{
name|suptr
operator|->
name|un_proc
operator|=
name|NULL
expr_stmt|;
name|did_something
operator|=
literal|1
expr_stmt|;
operator|*
name|supptr
operator|=
name|SLIST_NEXT
argument_list|(
name|suptr
argument_list|,
name|un_next
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we didn't free anything then just give-up */
if|if
condition|(
operator|!
name|did_something
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
comment|/* 			 * The second pass failed even though we freed 			 * something after the first pass! 			 * This is IMPOSSIBLE! 			 */
name|panic
argument_list|(
literal|"semu_alloc - second attempt failed"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Adjust a particular entry for a particular proc  */
end_comment

begin_function
specifier|static
name|int
name|semundo_adjust
parameter_list|(
name|td
parameter_list|,
name|supptr
parameter_list|,
name|semid
parameter_list|,
name|semnum
parameter_list|,
name|adjval
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|sem_undo
modifier|*
modifier|*
name|supptr
decl_stmt|;
name|int
name|semid
decl_stmt|,
name|semnum
decl_stmt|;
name|int
name|adjval
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|sem_undo
modifier|*
name|suptr
decl_stmt|;
name|struct
name|undo
modifier|*
name|sunptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SEMUNDO_LOCKASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Look for and remember the sem_undo if the caller doesn't provide 	   it */
name|suptr
operator|=
operator|*
name|supptr
expr_stmt|;
if|if
condition|(
name|suptr
operator|==
name|NULL
condition|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|suptr
argument_list|,
argument|&semu_list
argument_list|,
argument|un_next
argument_list|)
block|{
if|if
condition|(
name|suptr
operator|->
name|un_proc
operator|==
name|p
condition|)
block|{
operator|*
name|supptr
operator|=
name|suptr
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|suptr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|adjval
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|suptr
operator|=
name|semu_alloc
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|suptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
operator|*
name|supptr
operator|=
name|suptr
expr_stmt|;
block|}
block|}
comment|/* 	 * Look for the requested entry and adjust it (delete if adjval becomes 	 * 0). 	 */
name|sunptr
operator|=
operator|&
name|suptr
operator|->
name|un_ent
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|suptr
operator|->
name|un_cnt
condition|;
name|i
operator|++
operator|,
name|sunptr
operator|++
control|)
block|{
if|if
condition|(
name|sunptr
operator|->
name|un_id
operator|!=
name|semid
operator|||
name|sunptr
operator|->
name|un_num
operator|!=
name|semnum
condition|)
continue|continue;
if|if
condition|(
name|adjval
operator|!=
literal|0
condition|)
block|{
name|adjval
operator|+=
name|sunptr
operator|->
name|un_adjval
expr_stmt|;
if|if
condition|(
name|adjval
operator|>
name|seminfo
operator|.
name|semaem
operator|||
name|adjval
operator|<
operator|-
name|seminfo
operator|.
name|semaem
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
block|}
name|sunptr
operator|->
name|un_adjval
operator|=
name|adjval
expr_stmt|;
if|if
condition|(
name|sunptr
operator|->
name|un_adjval
operator|==
literal|0
condition|)
block|{
name|suptr
operator|->
name|un_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|suptr
operator|->
name|un_cnt
condition|)
name|suptr
operator|->
name|un_ent
index|[
name|i
index|]
operator|=
name|suptr
operator|->
name|un_ent
index|[
name|suptr
operator|->
name|un_cnt
index|]
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Didn't find the right entry - create it */
if|if
condition|(
name|adjval
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|adjval
operator|>
name|seminfo
operator|.
name|semaem
operator|||
name|adjval
operator|<
operator|-
name|seminfo
operator|.
name|semaem
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
if|if
condition|(
name|suptr
operator|->
name|un_cnt
operator|!=
name|seminfo
operator|.
name|semume
condition|)
block|{
name|sunptr
operator|=
operator|&
name|suptr
operator|->
name|un_ent
index|[
name|suptr
operator|->
name|un_cnt
index|]
expr_stmt|;
name|suptr
operator|->
name|un_cnt
operator|++
expr_stmt|;
name|sunptr
operator|->
name|un_adjval
operator|=
name|adjval
expr_stmt|;
name|sunptr
operator|->
name|un_id
operator|=
name|semid
expr_stmt|;
name|sunptr
operator|->
name|un_num
operator|=
name|semnum
expr_stmt|;
block|}
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|semundo_clear
parameter_list|(
name|semid
parameter_list|,
name|semnum
parameter_list|)
name|int
name|semid
decl_stmt|,
name|semnum
decl_stmt|;
block|{
name|struct
name|sem_undo
modifier|*
name|suptr
decl_stmt|;
name|SEMUNDO_LOCKASSERT
argument_list|(
name|MA_OWNED
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|suptr
argument_list|,
argument|&semu_list
argument_list|,
argument|un_next
argument_list|)
block|{
name|struct
name|undo
modifier|*
name|sunptr
init|=
operator|&
name|suptr
operator|->
name|un_ent
index|[
literal|0
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|suptr
operator|->
name|un_cnt
condition|)
block|{
if|if
condition|(
name|sunptr
operator|->
name|un_id
operator|==
name|semid
condition|)
block|{
if|if
condition|(
name|semnum
operator|==
operator|-
literal|1
operator|||
name|sunptr
operator|->
name|un_num
operator|==
name|semnum
condition|)
block|{
name|suptr
operator|->
name|un_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|suptr
operator|->
name|un_cnt
condition|)
block|{
name|suptr
operator|->
name|un_ent
index|[
name|i
index|]
operator|=
name|suptr
operator|->
name|un_ent
index|[
name|suptr
operator|->
name|un_cnt
index|]
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|semnum
operator|!=
operator|-
literal|1
condition|)
break|break;
block|}
name|i
operator|++
operator|,
name|sunptr
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|semvalid
parameter_list|(
name|semid
parameter_list|,
name|semakptr
parameter_list|)
name|int
name|semid
decl_stmt|;
name|struct
name|semid_kernel
modifier|*
name|semakptr
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
operator|.
name|mode
operator|&
name|SEM_ALLOC
operator|)
operator|==
literal|0
operator|||
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
operator|.
name|seq
operator|!=
name|IPCID_TO_SEQ
argument_list|(
name|semid
argument_list|)
condition|?
name|EINVAL
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note that the user-mode half of this passes a union, not a pointer.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|__semctl_args
block|{
name|int
name|semid
decl_stmt|;
name|int
name|semnum
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|union
name|semun
modifier|*
name|arg
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|__semctl
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|__semctl_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|semid_ds
name|dsbuf
decl_stmt|;
name|union
name|semun
name|arg
decl_stmt|,
name|semun
decl_stmt|;
name|register_t
name|rval
decl_stmt|;
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
name|SEM_STAT
case|:
case|case
name|IPC_SET
case|:
case|case
name|IPC_STAT
case|:
case|case
name|GETALL
case|:
case|case
name|SETVAL
case|:
case|case
name|SETALL
case|:
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|arg
argument_list|,
operator|&
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
block|}
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
name|SEM_STAT
case|:
case|case
name|IPC_STAT
case|:
name|semun
operator|.
name|buf
operator|=
operator|&
name|dsbuf
expr_stmt|;
break|break;
case|case
name|IPC_SET
case|:
name|error
operator|=
name|copyin
argument_list|(
name|arg
operator|.
name|buf
argument_list|,
operator|&
name|dsbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dsbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|semun
operator|.
name|buf
operator|=
operator|&
name|dsbuf
expr_stmt|;
break|break;
case|case
name|GETALL
case|:
case|case
name|SETALL
case|:
name|semun
operator|.
name|array
operator|=
name|arg
operator|.
name|array
expr_stmt|;
break|break;
case|case
name|SETVAL
case|:
name|semun
operator|.
name|val
operator|=
name|arg
operator|.
name|val
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|kern_semctl
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|semid
argument_list|,
name|uap
operator|->
name|semnum
argument_list|,
name|uap
operator|->
name|cmd
argument_list|,
operator|&
name|semun
argument_list|,
operator|&
name|rval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
name|SEM_STAT
case|:
case|case
name|IPC_STAT
case|:
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|dsbuf
argument_list|,
name|arg
operator|.
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|dsbuf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|rval
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kern_semctl
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|semid
parameter_list|,
name|int
name|semnum
parameter_list|,
name|int
name|cmd
parameter_list|,
name|union
name|semun
modifier|*
name|arg
parameter_list|,
name|register_t
modifier|*
name|rval
parameter_list|)
block|{
name|u_short
modifier|*
name|array
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|td
operator|->
name|td_ucred
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|semid_ds
modifier|*
name|sbuf
decl_stmt|;
name|struct
name|semid_kernel
modifier|*
name|semakptr
decl_stmt|;
name|struct
name|mtx
modifier|*
name|sema_mtxp
decl_stmt|;
name|u_short
name|usval
decl_stmt|,
name|count
decl_stmt|;
name|int
name|semidx
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"call to semctl(%d, %d, %d, 0x%p)\n"
operator|,
name|semid
operator|,
name|semnum
operator|,
name|cmd
operator|,
name|arg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|jail_sysvipc_allowed
operator|&&
name|jailed
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
name|array
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SEM_STAT
case|:
comment|/* 		 * For this command we assume semid is an array index 		 * rather than an IPC id. 		 */
if|if
condition|(
name|semid
operator|<
literal|0
operator|||
name|semid
operator|>=
name|seminfo
operator|.
name|semmni
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|semakptr
operator|=
operator|&
name|sema
index|[
name|semid
index|]
expr_stmt|;
name|sema_mtxp
operator|=
operator|&
name|sema_mtx
index|[
name|semid
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
name|sema_mtxp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
operator|.
name|mode
operator|&
name|SEM_ALLOC
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_sysv_semctl
argument_list|(
name|cred
argument_list|,
name|semakptr
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
endif|#
directive|endif
name|bcopy
argument_list|(
operator|&
name|semakptr
operator|->
name|u
argument_list|,
name|arg
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|semid_ds
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rval
operator|=
name|IXSEQ_TO_IPCID
argument_list|(
name|semid
argument_list|,
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|sema_mtxp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|semidx
operator|=
name|IPCID_TO_IX
argument_list|(
name|semid
argument_list|)
expr_stmt|;
if|if
condition|(
name|semidx
operator|<
literal|0
operator|||
name|semidx
operator|>=
name|seminfo
operator|.
name|semmni
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|semakptr
operator|=
operator|&
name|sema
index|[
name|semidx
index|]
expr_stmt|;
name|sema_mtxp
operator|=
operator|&
name|sema_mtx
index|[
name|semidx
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
name|sema_mtxp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_sysv_semctl
argument_list|(
name|cred
argument_list|,
name|semakptr
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
endif|#
directive|endif
name|error
operator|=
literal|0
expr_stmt|;
operator|*
name|rval
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|IPC_RMID
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|semvalid
argument_list|(
name|semid
argument_list|,
name|semakptr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
argument_list|,
name|IPC_M
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
operator|.
name|cuid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
operator|.
name|uid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|semtot
operator|-=
name|semakptr
operator|->
name|u
operator|.
name|sem_nsems
expr_stmt|;
for|for
control|(
name|i
operator|=
name|semakptr
operator|->
name|u
operator|.
name|sem_base
operator|-
name|sem
init|;
name|i
operator|<
name|semtot
condition|;
name|i
operator|++
control|)
name|sem
index|[
name|i
index|]
operator|=
name|sem
index|[
name|i
operator|+
name|semakptr
operator|->
name|u
operator|.
name|sem_nsems
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seminfo
operator|.
name|semmni
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sema
index|[
name|i
index|]
operator|.
name|u
operator|.
name|sem_perm
operator|.
name|mode
operator|&
name|SEM_ALLOC
operator|)
operator|&&
name|sema
index|[
name|i
index|]
operator|.
name|u
operator|.
name|sem_base
operator|>
name|semakptr
operator|->
name|u
operator|.
name|sem_base
condition|)
name|sema
index|[
name|i
index|]
operator|.
name|u
operator|.
name|sem_base
operator|-=
name|semakptr
operator|->
name|u
operator|.
name|sem_nsems
expr_stmt|;
block|}
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_cleanup_sysv_sem
argument_list|(
name|semakptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SEMUNDO_LOCK
argument_list|()
expr_stmt|;
name|semundo_clear
argument_list|(
name|semidx
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|SEMUNDO_UNLOCK
argument_list|()
expr_stmt|;
name|wakeup
argument_list|(
name|semakptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPC_SET
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|semvalid
argument_list|(
name|semid
argument_list|,
name|semakptr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
argument_list|,
name|IPC_M
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
name|sbuf
operator|=
name|arg
operator|->
name|buf
expr_stmt|;
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
operator|.
name|uid
operator|=
name|sbuf
operator|->
name|sem_perm
operator|.
name|uid
expr_stmt|;
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
operator|.
name|gid
operator|=
name|sbuf
operator|->
name|sem_perm
operator|.
name|gid
expr_stmt|;
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
operator|.
name|mode
operator|=
operator|(
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
operator|.
name|mode
operator|&
operator|~
literal|0777
operator|)
operator||
operator|(
name|sbuf
operator|->
name|sem_perm
operator|.
name|mode
operator|&
literal|0777
operator|)
expr_stmt|;
name|semakptr
operator|->
name|u
operator|.
name|sem_ctime
operator|=
name|time_second
expr_stmt|;
break|break;
case|case
name|IPC_STAT
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|semvalid
argument_list|(
name|semid
argument_list|,
name|semakptr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
name|bcopy
argument_list|(
operator|&
name|semakptr
operator|->
name|u
argument_list|,
name|arg
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|semid_ds
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GETNCNT
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|semvalid
argument_list|(
name|semid
argument_list|,
name|semakptr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
name|semnum
operator|<
literal|0
operator|||
name|semnum
operator|>=
name|semakptr
operator|->
name|u
operator|.
name|sem_nsems
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
operator|*
name|rval
operator|=
name|semakptr
operator|->
name|u
operator|.
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semncnt
expr_stmt|;
break|break;
case|case
name|GETPID
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|semvalid
argument_list|(
name|semid
argument_list|,
name|semakptr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
name|semnum
operator|<
literal|0
operator|||
name|semnum
operator|>=
name|semakptr
operator|->
name|u
operator|.
name|sem_nsems
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
operator|*
name|rval
operator|=
name|semakptr
operator|->
name|u
operator|.
name|sem_base
index|[
name|semnum
index|]
operator|.
name|sempid
expr_stmt|;
break|break;
case|case
name|GETVAL
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|semvalid
argument_list|(
name|semid
argument_list|,
name|semakptr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
name|semnum
operator|<
literal|0
operator|||
name|semnum
operator|>=
name|semakptr
operator|->
name|u
operator|.
name|sem_nsems
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
operator|*
name|rval
operator|=
name|semakptr
operator|->
name|u
operator|.
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semval
expr_stmt|;
break|break;
case|case
name|GETALL
case|:
comment|/* 		 * Unfortunately, callers of this function don't know 		 * in advance how many semaphores are in this set. 		 * While we could just allocate the maximum size array 		 * and pass the actual size back to the caller, that 		 * won't work for SETALL since we can't copyin() more 		 * data than the user specified as we may return a 		 * spurious EFAULT. 		 *  		 * Note that the number of semaphores in a set is 		 * fixed for the life of that set.  The only way that 		 * the 'count' could change while are blocked in 		 * malloc() is if this semaphore set were destroyed 		 * and a new one created with the same index. 		 * However, semvalid() will catch that due to the 		 * sequence number unless exactly 0x8000 (or a 		 * multiple thereof) semaphore sets for the same index 		 * are created and destroyed while we are in malloc! 		 * 		 */
name|count
operator|=
name|semakptr
operator|->
name|u
operator|.
name|sem_nsems
expr_stmt|;
name|mtx_unlock
argument_list|(
name|sema_mtxp
argument_list|)
expr_stmt|;
name|array
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|array
argument_list|)
operator|*
name|count
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|sema_mtxp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|semvalid
argument_list|(
name|semid
argument_list|,
name|semakptr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
name|KASSERT
argument_list|(
name|count
operator|==
name|semakptr
operator|->
name|u
operator|.
name|sem_nsems
argument_list|,
operator|(
literal|"nsems changed"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|semakptr
operator|->
name|u
operator|.
name|sem_nsems
condition|;
name|i
operator|++
control|)
name|array
index|[
name|i
index|]
operator|=
name|semakptr
operator|->
name|u
operator|.
name|sem_base
index|[
name|i
index|]
operator|.
name|semval
expr_stmt|;
name|mtx_unlock
argument_list|(
name|sema_mtxp
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|array
argument_list|,
name|arg
operator|->
name|array
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|array
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
name|sema_mtxp
argument_list|)
expr_stmt|;
break|break;
case|case
name|GETZCNT
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|semvalid
argument_list|(
name|semid
argument_list|,
name|semakptr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
name|semnum
operator|<
literal|0
operator|||
name|semnum
operator|>=
name|semakptr
operator|->
name|u
operator|.
name|sem_nsems
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
operator|*
name|rval
operator|=
name|semakptr
operator|->
name|u
operator|.
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semzcnt
expr_stmt|;
break|break;
case|case
name|SETVAL
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|semvalid
argument_list|(
name|semid
argument_list|,
name|semakptr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
argument_list|,
name|IPC_W
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
name|semnum
operator|<
literal|0
operator|||
name|semnum
operator|>=
name|semakptr
operator|->
name|u
operator|.
name|sem_nsems
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
name|arg
operator|->
name|val
operator|<
literal|0
operator|||
name|arg
operator|->
name|val
operator|>
name|seminfo
operator|.
name|semvmx
condition|)
block|{
name|error
operator|=
name|ERANGE
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|semakptr
operator|->
name|u
operator|.
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semval
operator|=
name|arg
operator|->
name|val
expr_stmt|;
name|SEMUNDO_LOCK
argument_list|()
expr_stmt|;
name|semundo_clear
argument_list|(
name|semidx
argument_list|,
name|semnum
argument_list|)
expr_stmt|;
name|SEMUNDO_UNLOCK
argument_list|()
expr_stmt|;
name|wakeup
argument_list|(
name|semakptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SETALL
case|:
comment|/* 		 * See comment on GETALL for why 'count' shouldn't change 		 * and why we require a userland buffer. 		 */
name|count
operator|=
name|semakptr
operator|->
name|u
operator|.
name|sem_nsems
expr_stmt|;
name|mtx_unlock
argument_list|(
name|sema_mtxp
argument_list|)
expr_stmt|;
name|array
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|array
argument_list|)
operator|*
name|count
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|arg
operator|->
name|array
argument_list|,
name|array
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|array
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|mtx_lock
argument_list|(
name|sema_mtxp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|semvalid
argument_list|(
name|semid
argument_list|,
name|semakptr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
name|KASSERT
argument_list|(
name|count
operator|==
name|semakptr
operator|->
name|u
operator|.
name|sem_nsems
argument_list|,
operator|(
literal|"nsems changed"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
argument_list|,
name|IPC_W
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|semakptr
operator|->
name|u
operator|.
name|sem_nsems
condition|;
name|i
operator|++
control|)
block|{
name|usval
operator|=
name|array
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|usval
operator|>
name|seminfo
operator|.
name|semvmx
condition|)
block|{
name|error
operator|=
name|ERANGE
expr_stmt|;
break|break;
block|}
name|semakptr
operator|->
name|u
operator|.
name|sem_base
index|[
name|i
index|]
operator|.
name|semval
operator|=
name|usval
expr_stmt|;
block|}
name|SEMUNDO_LOCK
argument_list|()
expr_stmt|;
name|semundo_clear
argument_list|(
name|semidx
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|SEMUNDO_UNLOCK
argument_list|()
expr_stmt|;
name|wakeup
argument_list|(
name|semakptr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|done2
label|:
name|mtx_unlock
argument_list|(
name|sema_mtxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|array
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|array
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|semget_args
block|{
name|key_t
name|key
decl_stmt|;
name|int
name|nsems
decl_stmt|;
name|int
name|semflg
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|semget
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|semget_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|semid
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|key
init|=
name|uap
operator|->
name|key
decl_stmt|;
name|int
name|nsems
init|=
name|uap
operator|->
name|nsems
decl_stmt|;
name|int
name|semflg
init|=
name|uap
operator|->
name|semflg
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|td
operator|->
name|td_ucred
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"semget(0x%x, %d, 0%o)\n"
operator|,
name|key
operator|,
name|nsems
operator|,
name|semflg
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|jail_sysvipc_allowed
operator|&&
name|jailed
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|IPC_PRIVATE
condition|)
block|{
for|for
control|(
name|semid
operator|=
literal|0
init|;
name|semid
operator|<
name|seminfo
operator|.
name|semmni
condition|;
name|semid
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sema
index|[
name|semid
index|]
operator|.
name|u
operator|.
name|sem_perm
operator|.
name|mode
operator|&
name|SEM_ALLOC
operator|)
operator|&&
name|sema
index|[
name|semid
index|]
operator|.
name|u
operator|.
name|sem_perm
operator|.
name|key
operator|==
name|key
condition|)
break|break;
block|}
if|if
condition|(
name|semid
operator|<
name|seminfo
operator|.
name|semmni
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"found public key\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|sema
index|[
name|semid
index|]
operator|.
name|u
operator|.
name|sem_perm
argument_list|,
name|semflg
operator|&
literal|0700
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
name|nsems
operator|>
literal|0
operator|&&
name|sema
index|[
name|semid
index|]
operator|.
name|u
operator|.
name|sem_nsems
operator|<
name|nsems
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"too small\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
operator|(
name|semflg
operator|&
name|IPC_CREAT
operator|)
operator|&&
operator|(
name|semflg
operator|&
name|IPC_EXCL
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"not exclusive\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_sysv_semget
argument_list|(
name|cred
argument_list|,
operator|&
name|sema
index|[
name|semid
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
endif|#
directive|endif
goto|goto
name|found
goto|;
block|}
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"need to allocate the semid_kernel\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|IPC_PRIVATE
operator|||
operator|(
name|semflg
operator|&
name|IPC_CREAT
operator|)
condition|)
block|{
if|if
condition|(
name|nsems
operator|<=
literal|0
operator|||
name|nsems
operator|>
name|seminfo
operator|.
name|semmsl
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"nsems out of range (0<%d<=%d)\n"
operator|,
name|nsems
operator|,
name|seminfo
operator|.
name|semmsl
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
name|nsems
operator|>
name|seminfo
operator|.
name|semmns
operator|-
name|semtot
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"not enough semaphores left (need %d, got %d)\n"
operator|,
name|nsems
operator|,
name|seminfo
operator|.
name|semmns
operator|-
name|semtot
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
for|for
control|(
name|semid
operator|=
literal|0
init|;
name|semid
operator|<
name|seminfo
operator|.
name|semmni
condition|;
name|semid
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sema
index|[
name|semid
index|]
operator|.
name|u
operator|.
name|sem_perm
operator|.
name|mode
operator|&
name|SEM_ALLOC
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|semid
operator|==
name|seminfo
operator|.
name|semmni
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"no more semid_kernel's available\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"semid %d is available\n"
operator|,
name|semid
operator|)
argument_list|)
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|u
operator|.
name|sem_perm
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|u
operator|.
name|sem_perm
operator|.
name|cuid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|u
operator|.
name|sem_perm
operator|.
name|uid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|u
operator|.
name|sem_perm
operator|.
name|cgid
operator|=
name|cred
operator|->
name|cr_gid
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|u
operator|.
name|sem_perm
operator|.
name|gid
operator|=
name|cred
operator|->
name|cr_gid
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|u
operator|.
name|sem_perm
operator|.
name|mode
operator|=
operator|(
name|semflg
operator|&
literal|0777
operator|)
operator||
name|SEM_ALLOC
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|u
operator|.
name|sem_perm
operator|.
name|seq
operator|=
operator|(
name|sema
index|[
name|semid
index|]
operator|.
name|u
operator|.
name|sem_perm
operator|.
name|seq
operator|+
literal|1
operator|)
operator|&
literal|0x7fff
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|u
operator|.
name|sem_nsems
operator|=
name|nsems
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|u
operator|.
name|sem_otime
operator|=
literal|0
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|u
operator|.
name|sem_ctime
operator|=
name|time_second
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|u
operator|.
name|sem_base
operator|=
operator|&
name|sem
index|[
name|semtot
index|]
expr_stmt|;
name|semtot
operator|+=
name|nsems
expr_stmt|;
name|bzero
argument_list|(
name|sema
index|[
name|semid
index|]
operator|.
name|u
operator|.
name|sem_base
argument_list|,
sizeof|sizeof
argument_list|(
name|sema
index|[
name|semid
index|]
operator|.
name|u
operator|.
name|sem_base
index|[
literal|0
index|]
argument_list|)
operator|*
name|nsems
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_create_sysv_sem
argument_list|(
name|cred
argument_list|,
operator|&
name|sema
index|[
name|semid
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
operator|(
literal|"sembase = %p, next = %p\n"
operator|,
name|sema
index|[
name|semid
index|]
operator|.
name|u
operator|.
name|sem_base
operator|,
operator|&
name|sem
index|[
name|semtot
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"didn't find it and wasn't asked to create it\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|found
label|:
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|IXSEQ_TO_IPCID
argument_list|(
name|semid
argument_list|,
name|sema
index|[
name|semid
index|]
operator|.
name|u
operator|.
name|sem_perm
argument_list|)
expr_stmt|;
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|semop_args
block|{
name|int
name|semid
decl_stmt|;
name|struct
name|sembuf
modifier|*
name|sops
decl_stmt|;
name|size_t
name|nsops
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|semop
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|semop_args
modifier|*
name|uap
decl_stmt|;
block|{
define|#
directive|define
name|SMALL_SOPS
value|8
name|struct
name|sembuf
name|small_sops
index|[
name|SMALL_SOPS
index|]
decl_stmt|;
name|int
name|semid
init|=
name|uap
operator|->
name|semid
decl_stmt|;
name|size_t
name|nsops
init|=
name|uap
operator|->
name|nsops
decl_stmt|;
name|struct
name|sembuf
modifier|*
name|sops
decl_stmt|;
name|struct
name|semid_kernel
modifier|*
name|semakptr
decl_stmt|;
name|struct
name|sembuf
modifier|*
name|sopptr
init|=
literal|0
decl_stmt|;
name|struct
name|sem
modifier|*
name|semptr
init|=
literal|0
decl_stmt|;
name|struct
name|sem_undo
modifier|*
name|suptr
decl_stmt|;
name|struct
name|mtx
modifier|*
name|sema_mtxp
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|do_wakeup
decl_stmt|,
name|do_undos
decl_stmt|;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|sops
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|DPRINTF
argument_list|(
operator|(
literal|"call to semop(%d, %p, %u)\n"
operator|,
name|semid
operator|,
name|sops
operator|,
name|nsops
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|jail_sysvipc_allowed
operator|&&
name|jailed
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
name|semid
operator|=
name|IPCID_TO_IX
argument_list|(
name|semid
argument_list|)
expr_stmt|;
comment|/* Convert back to zero origin */
if|if
condition|(
name|semid
operator|<
literal|0
operator|||
name|semid
operator|>=
name|seminfo
operator|.
name|semmni
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Allocate memory for sem_ops */
if|if
condition|(
name|nsops
operator|<=
name|SMALL_SOPS
condition|)
name|sops
operator|=
name|small_sops
expr_stmt|;
elseif|else
if|if
condition|(
name|nsops
operator|<=
name|seminfo
operator|.
name|semopm
condition|)
name|sops
operator|=
name|malloc
argument_list|(
name|nsops
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sops
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
else|else
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"too many sops (max=%d, nsops=%d)\n"
operator|,
name|seminfo
operator|.
name|semopm
operator|,
name|nsops
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|E2BIG
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|sops
argument_list|,
name|sops
argument_list|,
name|nsops
operator|*
sizeof|sizeof
argument_list|(
name|sops
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"error = %d from copyin(%p, %p, %d)\n"
operator|,
name|error
operator|,
name|uap
operator|->
name|sops
operator|,
name|sops
operator|,
name|nsops
operator|*
sizeof|sizeof
argument_list|(
name|sops
index|[
literal|0
index|]
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sops
operator|!=
name|small_sops
condition|)
name|free
argument_list|(
name|sops
argument_list|,
name|M_SEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|semakptr
operator|=
operator|&
name|sema
index|[
name|semid
index|]
expr_stmt|;
name|sema_mtxp
operator|=
operator|&
name|sema_mtx
index|[
name|semid
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
name|sema_mtxp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
operator|.
name|mode
operator|&
name|SEM_ALLOC
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
operator|.
name|seq
operator|!=
name|IPCID_TO_SEQ
argument_list|(
name|uap
operator|->
name|semid
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
comment|/* 	 * Initial pass thru sops to see what permissions are needed. 	 * Also perform any checks that don't need repeating on each 	 * attempt to satisfy the request vector. 	 */
name|j
operator|=
literal|0
expr_stmt|;
comment|/* permission needed */
name|do_undos
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsops
condition|;
name|i
operator|++
control|)
block|{
name|sopptr
operator|=
operator|&
name|sops
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sopptr
operator|->
name|sem_num
operator|>=
name|semakptr
operator|->
name|u
operator|.
name|sem_nsems
condition|)
block|{
name|error
operator|=
name|EFBIG
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
name|sopptr
operator|->
name|sem_flg
operator|&
name|SEM_UNDO
operator|&&
name|sopptr
operator|->
name|sem_op
operator|!=
literal|0
condition|)
name|do_undos
operator|=
literal|1
expr_stmt|;
name|j
operator||=
operator|(
name|sopptr
operator|->
name|sem_op
operator|==
literal|0
operator|)
condition|?
name|SEM_R
else|:
name|SEM_A
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
argument_list|,
name|j
argument_list|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"error = %d from ipaccess\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_sysv_semop
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|semakptr
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
endif|#
directive|endif
comment|/* 	 * Loop trying to satisfy the vector of requests. 	 * If we reach a point where we must wait, any requests already 	 * performed are rolled back and we go to sleep until some other 	 * process wakes us up.  At this point, we start all over again. 	 * 	 * This ensures that from the perspective of other tasks, a set 	 * of requests is atomic (never partially satisfied). 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|do_wakeup
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* error return if necessary */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsops
condition|;
name|i
operator|++
control|)
block|{
name|sopptr
operator|=
operator|&
name|sops
index|[
name|i
index|]
expr_stmt|;
name|semptr
operator|=
operator|&
name|semakptr
operator|->
name|u
operator|.
name|sem_base
index|[
name|sopptr
operator|->
name|sem_num
index|]
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"semop:  semakptr=%p, sem_base=%p, "
literal|"semptr=%p, sem[%d]=%d : op=%d, flag=%s\n"
operator|,
name|semakptr
operator|,
name|semakptr
operator|->
name|u
operator|.
name|sem_base
operator|,
name|semptr
operator|,
name|sopptr
operator|->
name|sem_num
operator|,
name|semptr
operator|->
name|semval
operator|,
name|sopptr
operator|->
name|sem_op
operator|,
operator|(
name|sopptr
operator|->
name|sem_flg
operator|&
name|IPC_NOWAIT
operator|)
condition|?
literal|"nowait"
else|:
literal|"wait"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sopptr
operator|->
name|sem_op
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|semptr
operator|->
name|semval
operator|+
name|sopptr
operator|->
name|sem_op
operator|<
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"semop:  can't do it now\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|semptr
operator|->
name|semval
operator|+=
name|sopptr
operator|->
name|sem_op
expr_stmt|;
if|if
condition|(
name|semptr
operator|->
name|semval
operator|==
literal|0
operator|&&
name|semptr
operator|->
name|semzcnt
operator|>
literal|0
condition|)
name|do_wakeup
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sopptr
operator|->
name|sem_op
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|semptr
operator|->
name|semval
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"semop:  not zero now\n"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|semptr
operator|->
name|semval
operator|+
name|sopptr
operator|->
name|sem_op
operator|>
name|seminfo
operator|.
name|semvmx
condition|)
block|{
name|error
operator|=
name|ERANGE
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|semptr
operator|->
name|semncnt
operator|>
literal|0
condition|)
name|do_wakeup
operator|=
literal|1
expr_stmt|;
name|semptr
operator|->
name|semval
operator|+=
name|sopptr
operator|->
name|sem_op
expr_stmt|;
block|}
block|}
comment|/* 		 * Did we get through the entire vector? 		 */
if|if
condition|(
name|i
operator|>=
name|nsops
condition|)
goto|goto
name|done
goto|;
comment|/* 		 * No ... rollback anything that we've already done 		 */
name|DPRINTF
argument_list|(
operator|(
literal|"semop:  rollback 0 through %d\n"
operator|,
name|i
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|semakptr
operator|->
name|u
operator|.
name|sem_base
index|[
name|sops
index|[
name|j
index|]
operator|.
name|sem_num
index|]
operator|.
name|semval
operator|-=
name|sops
index|[
name|j
index|]
operator|.
name|sem_op
expr_stmt|;
comment|/* If we detected an error, return it */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
comment|/* 		 * If the request that we couldn't satisfy has the 		 * NOWAIT flag set then return with EAGAIN. 		 */
if|if
condition|(
name|sopptr
operator|->
name|sem_flg
operator|&
name|IPC_NOWAIT
condition|)
block|{
name|error
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
name|sopptr
operator|->
name|sem_op
operator|==
literal|0
condition|)
name|semptr
operator|->
name|semzcnt
operator|++
expr_stmt|;
else|else
name|semptr
operator|->
name|semncnt
operator|++
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"semop:  good night!\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
name|semakptr
argument_list|,
name|sema_mtxp
argument_list|,
operator|(
name|PZERO
operator|-
literal|4
operator|)
operator||
name|PCATCH
argument_list|,
literal|"semwait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"semop:  good morning (error=%d)!\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
comment|/* return code is checked below, after sem[nz]cnt-- */
comment|/* 		 * Make sure that the semaphore still exists 		 */
if|if
condition|(
operator|(
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
operator|.
name|mode
operator|&
name|SEM_ALLOC
operator|)
operator|==
literal|0
operator|||
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
operator|.
name|seq
operator|!=
name|IPCID_TO_SEQ
argument_list|(
name|uap
operator|->
name|semid
argument_list|)
condition|)
block|{
name|error
operator|=
name|EIDRM
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
comment|/* 		 * The semaphore is still alive.  Readjust the count of 		 * waiting processes. 		 */
if|if
condition|(
name|sopptr
operator|->
name|sem_op
operator|==
literal|0
condition|)
name|semptr
operator|->
name|semzcnt
operator|--
expr_stmt|;
else|else
name|semptr
operator|->
name|semncnt
operator|--
expr_stmt|;
comment|/* 		 * Is it really morning, or was our sleep interrupted? 		 * (Delayed check of msleep() return code because we 		 * need to decrement sem[nz]cnt either way.) 		 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"semop:  good morning!\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|done
label|:
comment|/* 	 * Process any SEM_UNDO requests. 	 */
if|if
condition|(
name|do_undos
condition|)
block|{
name|SEMUNDO_LOCK
argument_list|()
expr_stmt|;
name|suptr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsops
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * We only need to deal with SEM_UNDO's for non-zero 			 * op's. 			 */
name|int
name|adjval
decl_stmt|;
if|if
condition|(
operator|(
name|sops
index|[
name|i
index|]
operator|.
name|sem_flg
operator|&
name|SEM_UNDO
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|adjval
operator|=
name|sops
index|[
name|i
index|]
operator|.
name|sem_op
expr_stmt|;
if|if
condition|(
name|adjval
operator|==
literal|0
condition|)
continue|continue;
name|error
operator|=
name|semundo_adjust
argument_list|(
name|td
argument_list|,
operator|&
name|suptr
argument_list|,
name|semid
argument_list|,
name|sops
index|[
name|i
index|]
operator|.
name|sem_num
argument_list|,
operator|-
name|adjval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
continue|continue;
comment|/* 			 * Oh-Oh!  We ran out of either sem_undo's or undo's. 			 * Rollback the adjustments to this point and then 			 * rollback the semaphore ups and down so we can return 			 * with an error with all structures restored.  We 			 * rollback the undo's in the exact reverse order that 			 * we applied them.  This guarantees that we won't run 			 * out of space as we roll things back out. 			 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|=
name|i
operator|-
name|j
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|sops
index|[
name|k
index|]
operator|.
name|sem_flg
operator|&
name|SEM_UNDO
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|adjval
operator|=
name|sops
index|[
name|k
index|]
operator|.
name|sem_op
expr_stmt|;
if|if
condition|(
name|adjval
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|semundo_adjust
argument_list|(
name|td
argument_list|,
operator|&
name|suptr
argument_list|,
name|semid
argument_list|,
name|sops
index|[
name|k
index|]
operator|.
name|sem_num
argument_list|,
name|adjval
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"semop - can't undo undos"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsops
condition|;
name|j
operator|++
control|)
name|semakptr
operator|->
name|u
operator|.
name|sem_base
index|[
name|sops
index|[
name|j
index|]
operator|.
name|sem_num
index|]
operator|.
name|semval
operator|-=
name|sops
index|[
name|j
index|]
operator|.
name|sem_op
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"error = %d from semundo_adjust\n"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|SEMUNDO_UNLOCK
argument_list|()
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
comment|/* loop through the sops */
name|SEMUNDO_UNLOCK
argument_list|()
expr_stmt|;
block|}
comment|/* if (do_undos) */
comment|/* We're definitely done - set the sempid's and time */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsops
condition|;
name|i
operator|++
control|)
block|{
name|sopptr
operator|=
operator|&
name|sops
index|[
name|i
index|]
expr_stmt|;
name|semptr
operator|=
operator|&
name|semakptr
operator|->
name|u
operator|.
name|sem_base
index|[
name|sopptr
operator|->
name|sem_num
index|]
expr_stmt|;
name|semptr
operator|->
name|sempid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
block|}
name|semakptr
operator|->
name|u
operator|.
name|sem_otime
operator|=
name|time_second
expr_stmt|;
comment|/* 	 * Do a wakeup if any semaphore was up'd whilst something was 	 * sleeping on it. 	 */
if|if
condition|(
name|do_wakeup
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"semop:  doing wakeup\n"
operator|)
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|semakptr
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"semop:  back from wakeup\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"semop:  done\n"
operator|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|done2
label|:
name|mtx_unlock
argument_list|(
name|sema_mtxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sops
operator|!=
name|small_sops
condition|)
name|free
argument_list|(
name|sops
argument_list|,
name|M_SEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Go through the undo structures for this process and apply the adjustments to  * semaphores.  */
end_comment

begin_function
specifier|static
name|void
name|semexit_myhook
parameter_list|(
name|arg
parameter_list|,
name|p
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|sem_undo
modifier|*
name|suptr
decl_stmt|;
name|struct
name|sem_undo
modifier|*
modifier|*
name|supptr
decl_stmt|;
comment|/* 	 * Go through the chain of undo vectors looking for one 	 * associated with this process. 	 */
name|SEMUNDO_LOCK
argument_list|()
expr_stmt|;
name|SLIST_FOREACH_PREVPTR
argument_list|(
argument|suptr
argument_list|,
argument|supptr
argument_list|,
argument|&semu_list
argument_list|,
argument|un_next
argument_list|)
block|{
if|if
condition|(
name|suptr
operator|->
name|un_proc
operator|==
name|p
condition|)
block|{
operator|*
name|supptr
operator|=
name|SLIST_NEXT
argument_list|(
name|suptr
argument_list|,
name|un_next
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|SEMUNDO_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|suptr
operator|==
name|NULL
condition|)
return|return;
name|DPRINTF
argument_list|(
operator|(
literal|"proc @%p has undo structure with %d entries\n"
operator|,
name|p
operator|,
name|suptr
operator|->
name|un_cnt
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If there are any active undo elements then process them. 	 */
if|if
condition|(
name|suptr
operator|->
name|un_cnt
operator|>
literal|0
condition|)
block|{
name|int
name|ix
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|suptr
operator|->
name|un_cnt
condition|;
name|ix
operator|++
control|)
block|{
name|int
name|semid
init|=
name|suptr
operator|->
name|un_ent
index|[
name|ix
index|]
operator|.
name|un_id
decl_stmt|;
name|int
name|semnum
init|=
name|suptr
operator|->
name|un_ent
index|[
name|ix
index|]
operator|.
name|un_num
decl_stmt|;
name|int
name|adjval
init|=
name|suptr
operator|->
name|un_ent
index|[
name|ix
index|]
operator|.
name|un_adjval
decl_stmt|;
name|struct
name|semid_kernel
modifier|*
name|semakptr
decl_stmt|;
name|struct
name|mtx
modifier|*
name|sema_mtxp
decl_stmt|;
name|semakptr
operator|=
operator|&
name|sema
index|[
name|semid
index|]
expr_stmt|;
name|sema_mtxp
operator|=
operator|&
name|sema_mtx
index|[
name|semid
index|]
expr_stmt|;
name|mtx_lock
argument_list|(
name|sema_mtxp
argument_list|)
expr_stmt|;
name|SEMUNDO_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|semakptr
operator|->
name|u
operator|.
name|sem_perm
operator|.
name|mode
operator|&
name|SEM_ALLOC
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"semexit - semid not allocated"
argument_list|)
expr_stmt|;
if|if
condition|(
name|semnum
operator|>=
name|semakptr
operator|->
name|u
operator|.
name|sem_nsems
condition|)
name|panic
argument_list|(
literal|"semexit - semnum out of range"
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"semexit:  %p id=%d num=%d(adj=%d) ; sem=%d\n"
operator|,
name|suptr
operator|->
name|un_proc
operator|,
name|suptr
operator|->
name|un_ent
index|[
name|ix
index|]
operator|.
name|un_id
operator|,
name|suptr
operator|->
name|un_ent
index|[
name|ix
index|]
operator|.
name|un_num
operator|,
name|suptr
operator|->
name|un_ent
index|[
name|ix
index|]
operator|.
name|un_adjval
operator|,
name|semakptr
operator|->
name|u
operator|.
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semval
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|adjval
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|semakptr
operator|->
name|u
operator|.
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semval
operator|<
operator|-
name|adjval
condition|)
name|semakptr
operator|->
name|u
operator|.
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semval
operator|=
literal|0
expr_stmt|;
else|else
name|semakptr
operator|->
name|u
operator|.
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semval
operator|+=
name|adjval
expr_stmt|;
block|}
else|else
name|semakptr
operator|->
name|u
operator|.
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semval
operator|+=
name|adjval
expr_stmt|;
name|wakeup
argument_list|(
name|semakptr
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"semexit:  back from wakeup\n"
operator|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|sema_mtxp
argument_list|)
expr_stmt|;
name|SEMUNDO_UNLOCK
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* 	 * Deallocate the undo vector. 	 */
name|DPRINTF
argument_list|(
operator|(
literal|"removing vector\n"
operator|)
argument_list|)
expr_stmt|;
name|SEMUNDO_LOCK
argument_list|()
expr_stmt|;
name|suptr
operator|->
name|un_proc
operator|=
name|NULL
expr_stmt|;
name|SEMUNDO_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_sema
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
return|return
operator|(
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|sema
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|semid_kernel
argument_list|)
operator|*
name|seminfo
operator|.
name|semmni
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

