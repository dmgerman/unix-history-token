begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * Implementation of SVID semaphores  *  * Author:  Daniel Boulet  *  * This software is provided ``AS IS'' without any warranties of any kind.  */
end_comment

begin_include
include|#
directive|include
file|"opt_sysvipc.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sem.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_SEM
argument_list|,
literal|"sem"
argument_list|,
literal|"SVID compatible semaphores"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|void
name|seminit
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sysvsem_modload
name|__P
argument_list|(
operator|(
expr|struct
name|module
operator|*
operator|,
name|int
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|semunload
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|semexit_myhook
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sysctl_sema
name|__P
argument_list|(
operator|(
name|SYSCTL_HANDLER_ARGS
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct_decl
struct_decl|struct
name|__semctl_args
struct_decl|;
end_struct_decl

begin_decl_stmt
name|int
name|__semctl
name|__P
argument_list|(
operator|(
expr|struct
name|thread
operator|*
name|td
operator|,
expr|struct
name|__semctl_args
operator|*
name|uap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|semget_args
struct_decl|;
end_struct_decl

begin_decl_stmt
name|int
name|semget
name|__P
argument_list|(
operator|(
expr|struct
name|thread
operator|*
name|td
operator|,
expr|struct
name|semget_args
operator|*
name|uap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|semop_args
struct_decl|;
end_struct_decl

begin_decl_stmt
name|int
name|semop
name|__P
argument_list|(
operator|(
expr|struct
name|thread
operator|*
name|td
operator|,
expr|struct
name|semop_args
operator|*
name|uap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|sem_undo
modifier|*
name|semu_alloc
name|__P
argument_list|(
operator|(
expr|struct
name|thread
operator|*
name|td
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|semundo_adjust
name|__P
argument_list|(
operator|(
expr|struct
name|thread
operator|*
name|td
operator|,
expr|struct
name|sem_undo
operator|*
operator|*
name|supptr
operator|,
name|int
name|semid
operator|,
name|int
name|semnum
operator|,
name|int
name|adjval
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|semundo_clear
name|__P
argument_list|(
operator|(
name|int
name|semid
operator|,
name|int
name|semnum
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX casting to (sy_call_t *) is bogus, as usual. */
end_comment

begin_decl_stmt
specifier|static
name|sy_call_t
modifier|*
name|semcalls
index|[]
init|=
block|{
operator|(
name|sy_call_t
operator|*
operator|)
name|__semctl
block|,
operator|(
name|sy_call_t
operator|*
operator|)
name|semget
block|,
operator|(
name|sy_call_t
operator|*
operator|)
name|semop
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|semtot
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|semid_ds
modifier|*
name|sema
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* semaphore id pool */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sem
modifier|*
name|sem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* semaphore pool */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sem_undo
modifier|*
name|semu_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of active undo structures */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|semu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* undo structure pool */
end_comment

begin_struct
struct|struct
name|sem
block|{
name|u_short
name|semval
decl_stmt|;
comment|/* semaphore value */
name|pid_t
name|sempid
decl_stmt|;
comment|/* pid of last operation */
name|u_short
name|semncnt
decl_stmt|;
comment|/* # awaiting semval> cval */
name|u_short
name|semzcnt
decl_stmt|;
comment|/* # awaiting semval = 0 */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Undo structure (one per process)  */
end_comment

begin_struct
struct|struct
name|sem_undo
block|{
name|struct
name|sem_undo
modifier|*
name|un_next
decl_stmt|;
comment|/* ptr to next active undo structure */
name|struct
name|proc
modifier|*
name|un_proc
decl_stmt|;
comment|/* owner of this structure */
name|short
name|un_cnt
decl_stmt|;
comment|/* # of active entries */
struct|struct
name|undo
block|{
name|short
name|un_adjval
decl_stmt|;
comment|/* adjust on exit values */
name|short
name|un_num
decl_stmt|;
comment|/* semaphore # */
name|int
name|un_id
decl_stmt|;
comment|/* semid */
block|}
name|un_ent
index|[
literal|1
index|]
struct|;
comment|/* undo entries */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Configuration parameters  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SEMMNI
end_ifndef

begin_define
define|#
directive|define
name|SEMMNI
value|10
end_define

begin_comment
comment|/* # of semaphore identifiers */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SEMMNS
end_ifndef

begin_define
define|#
directive|define
name|SEMMNS
value|60
end_define

begin_comment
comment|/* # of semaphores in system */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SEMUME
end_ifndef

begin_define
define|#
directive|define
name|SEMUME
value|10
end_define

begin_comment
comment|/* max # of undo entries per process */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SEMMNU
end_ifndef

begin_define
define|#
directive|define
name|SEMMNU
value|30
end_define

begin_comment
comment|/* # of undo structures in system */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* shouldn't need tuning */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SEMMAP
end_ifndef

begin_define
define|#
directive|define
name|SEMMAP
value|30
end_define

begin_comment
comment|/* # of entries in semaphore map */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SEMMSL
end_ifndef

begin_define
define|#
directive|define
name|SEMMSL
value|SEMMNS
end_define

begin_comment
comment|/* max # of semaphores per id */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SEMOPM
end_ifndef

begin_define
define|#
directive|define
name|SEMOPM
value|100
end_define

begin_comment
comment|/* max # of operations per semop call */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SEMVMX
value|32767
end_define

begin_comment
comment|/* semaphore maximum value */
end_comment

begin_define
define|#
directive|define
name|SEMAEM
value|16384
end_define

begin_comment
comment|/* adjust on exit max value */
end_comment

begin_comment
comment|/*  * Due to the way semaphore memory is allocated, we have to ensure that  * SEMUSZ is properly aligned.  */
end_comment

begin_define
define|#
directive|define
name|SEM_ALIGN
parameter_list|(
name|bytes
parameter_list|)
value|(((bytes) + (sizeof(long) - 1))& ~(sizeof(long) - 1))
end_define

begin_comment
comment|/* actual size of an undo structure */
end_comment

begin_define
define|#
directive|define
name|SEMUSZ
value|SEM_ALIGN(offsetof(struct sem_undo, un_ent[SEMUME]))
end_define

begin_comment
comment|/*  * Macro to find a particular sem_undo vector  */
end_comment

begin_define
define|#
directive|define
name|SEMU
parameter_list|(
name|ix
parameter_list|)
value|((struct sem_undo *)(((intptr_t)semu)+ix * seminfo.semusz))
end_define

begin_comment
comment|/*  * semaphore info struct  */
end_comment

begin_decl_stmt
name|struct
name|seminfo
name|seminfo
init|=
block|{
name|SEMMAP
block|,
comment|/* # of entries in semaphore map */
name|SEMMNI
block|,
comment|/* # of semaphore identifiers */
name|SEMMNS
block|,
comment|/* # of semaphores in system */
name|SEMMNU
block|,
comment|/* # of undo structures in system */
name|SEMMSL
block|,
comment|/* max # of semaphores per id */
name|SEMOPM
block|,
comment|/* max # of operations per semop call */
name|SEMUME
block|,
comment|/* max # of undo entries per process */
name|SEMUSZ
block|,
comment|/* size in bytes of undo structure */
name|SEMVMX
block|,
comment|/* semaphore maximum value */
name|SEMAEM
comment|/* adjust on exit max value */
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_kern_ipc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|semmap
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|seminfo
operator|.
name|semmap
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|semmni
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|seminfo
operator|.
name|semmni
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|semmns
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|seminfo
operator|.
name|semmns
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|semmnu
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|seminfo
operator|.
name|semmnu
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|semmsl
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|seminfo
operator|.
name|semmsl
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|semopm
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|seminfo
operator|.
name|semopm
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|semume
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|seminfo
operator|.
name|semume
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|semusz
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|seminfo
operator|.
name|semusz
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|semvmx
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|seminfo
operator|.
name|semvmx
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|semaem
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|seminfo
operator|.
name|semaem
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|sema
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_sema
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|seminit
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.semmap"
argument_list|,
operator|&
name|seminfo
operator|.
name|semmap
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.semmni"
argument_list|,
operator|&
name|seminfo
operator|.
name|semmni
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.semmns"
argument_list|,
operator|&
name|seminfo
operator|.
name|semmns
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.semmnu"
argument_list|,
operator|&
name|seminfo
operator|.
name|semmnu
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.semmsl"
argument_list|,
operator|&
name|seminfo
operator|.
name|semmsl
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.semopm"
argument_list|,
operator|&
name|seminfo
operator|.
name|semopm
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.semume"
argument_list|,
operator|&
name|seminfo
operator|.
name|semume
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.semusz"
argument_list|,
operator|&
name|seminfo
operator|.
name|semusz
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.semvmx"
argument_list|,
operator|&
name|seminfo
operator|.
name|semvmx
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.semaem"
argument_list|,
operator|&
name|seminfo
operator|.
name|semaem
argument_list|)
expr_stmt|;
name|sem
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sem
argument_list|)
operator|*
name|seminfo
operator|.
name|semmns
argument_list|,
name|M_SEM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sem
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"sem is NULL"
argument_list|)
expr_stmt|;
name|sema
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|semid_ds
argument_list|)
operator|*
name|seminfo
operator|.
name|semmni
argument_list|,
name|M_SEM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sema
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"sema is NULL"
argument_list|)
expr_stmt|;
name|semu
operator|=
name|malloc
argument_list|(
name|seminfo
operator|.
name|semmnu
operator|*
name|seminfo
operator|.
name|semusz
argument_list|,
name|M_SEM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|semu
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"semu is NULL"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seminfo
operator|.
name|semmni
condition|;
name|i
operator|++
control|)
block|{
name|sema
index|[
name|i
index|]
operator|.
name|sem_base
operator|=
literal|0
expr_stmt|;
name|sema
index|[
name|i
index|]
operator|.
name|sem_perm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seminfo
operator|.
name|semmnu
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|sem_undo
modifier|*
name|suptr
init|=
name|SEMU
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|suptr
operator|->
name|un_proc
operator|=
name|NULL
expr_stmt|;
block|}
name|semu_list
operator|=
name|NULL
expr_stmt|;
name|at_exit
argument_list|(
name|semexit_myhook
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|semunload
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|semtot
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|free
argument_list|(
name|sem
argument_list|,
name|M_SEM
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sema
argument_list|,
name|M_SEM
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|semu
argument_list|,
name|M_SEM
argument_list|)
expr_stmt|;
name|rm_at_exit
argument_list|(
name|semexit_myhook
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysvsem_modload
parameter_list|(
name|struct
name|module
modifier|*
name|module
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|seminit
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|error
operator|=
name|semunload
argument_list|()
expr_stmt|;
break|break;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|sysvsem_mod
init|=
block|{
literal|"sysvsem"
block|,
operator|&
name|sysvsem_modload
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|semsys
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|__semctl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|semget
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCALL_MODULE_HELPER
argument_list|(
name|semop
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|sysvsem
argument_list|,
name|sysvsem_mod
argument_list|,
name|SI_SUB_SYSV_SEM
argument_list|,
name|SI_ORDER_FIRST
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|sysvsem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Entry point for all SEM calls  *  * MPSAFE  */
end_comment

begin_function
name|int
name|semsys
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
comment|/* XXX actually varargs. */
name|struct
name|semsys_args
comment|/* { 		u_int	which; 		int	a2; 		int	a3; 		int	a4; 		int	a5; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|!
name|jail_sysvipc_allowed
operator|&&
name|jailed
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|which
operator|>=
sizeof|sizeof
argument_list|(
name|semcalls
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|semcalls
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|semcalls
index|[
name|uap
operator|->
name|which
index|]
call|)
argument_list|(
name|td
argument_list|,
operator|&
name|uap
operator|->
name|a2
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new sem_undo structure for a process  * (returns ptr to structure or NULL if no more room)  */
end_comment

begin_function
specifier|static
name|struct
name|sem_undo
modifier|*
name|semu_alloc
parameter_list|(
name|td
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|sem_undo
modifier|*
name|suptr
decl_stmt|;
specifier|register
name|struct
name|sem_undo
modifier|*
modifier|*
name|supptr
decl_stmt|;
name|int
name|attempt
decl_stmt|;
comment|/* 	 * Try twice to allocate something. 	 * (we'll purge any empty structures after the first pass so 	 * two passes are always enough) 	 */
for|for
control|(
name|attempt
operator|=
literal|0
init|;
name|attempt
operator|<
literal|2
condition|;
name|attempt
operator|++
control|)
block|{
comment|/* 		 * Look for a free structure. 		 * Fill it in and return it if we find one. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seminfo
operator|.
name|semmnu
condition|;
name|i
operator|++
control|)
block|{
name|suptr
operator|=
name|SEMU
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|suptr
operator|->
name|un_proc
operator|==
name|NULL
condition|)
block|{
name|suptr
operator|->
name|un_next
operator|=
name|semu_list
expr_stmt|;
name|semu_list
operator|=
name|suptr
expr_stmt|;
name|suptr
operator|->
name|un_cnt
operator|=
literal|0
expr_stmt|;
name|suptr
operator|->
name|un_proc
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
return|return
operator|(
name|suptr
operator|)
return|;
block|}
block|}
comment|/* 		 * We didn't find a free one, if this is the first attempt 		 * then try to free some structures. 		 */
if|if
condition|(
name|attempt
operator|==
literal|0
condition|)
block|{
comment|/* All the structures are in use - try to free some */
name|int
name|did_something
init|=
literal|0
decl_stmt|;
name|supptr
operator|=
operator|&
name|semu_list
expr_stmt|;
while|while
condition|(
operator|(
name|suptr
operator|=
operator|*
name|supptr
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|suptr
operator|->
name|un_cnt
operator|==
literal|0
condition|)
block|{
name|suptr
operator|->
name|un_proc
operator|=
name|NULL
expr_stmt|;
operator|*
name|supptr
operator|=
name|suptr
operator|->
name|un_next
expr_stmt|;
name|did_something
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|supptr
operator|=
operator|&
operator|(
name|suptr
operator|->
name|un_next
operator|)
expr_stmt|;
block|}
comment|/* If we didn't free anything then just give-up */
if|if
condition|(
operator|!
name|did_something
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
comment|/* 			 * The second pass failed even though we freed 			 * something after the first pass! 			 * This is IMPOSSIBLE! 			 */
name|panic
argument_list|(
literal|"semu_alloc - second attempt failed"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Adjust a particular entry for a particular proc  */
end_comment

begin_function
specifier|static
name|int
name|semundo_adjust
parameter_list|(
name|td
parameter_list|,
name|supptr
parameter_list|,
name|semid
parameter_list|,
name|semnum
parameter_list|,
name|adjval
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|sem_undo
modifier|*
modifier|*
name|supptr
decl_stmt|;
name|int
name|semid
decl_stmt|,
name|semnum
decl_stmt|;
name|int
name|adjval
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
specifier|register
name|struct
name|sem_undo
modifier|*
name|suptr
decl_stmt|;
specifier|register
name|struct
name|undo
modifier|*
name|sunptr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Look for and remember the sem_undo if the caller doesn't provide 	   it */
name|suptr
operator|=
operator|*
name|supptr
expr_stmt|;
if|if
condition|(
name|suptr
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|suptr
operator|=
name|semu_list
init|;
name|suptr
operator|!=
name|NULL
condition|;
name|suptr
operator|=
name|suptr
operator|->
name|un_next
control|)
block|{
if|if
condition|(
name|suptr
operator|->
name|un_proc
operator|==
name|p
condition|)
block|{
operator|*
name|supptr
operator|=
name|suptr
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|suptr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|adjval
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|suptr
operator|=
name|semu_alloc
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|suptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
operator|*
name|supptr
operator|=
name|suptr
expr_stmt|;
block|}
block|}
comment|/* 	 * Look for the requested entry and adjust it (delete if adjval becomes 	 * 0). 	 */
name|sunptr
operator|=
operator|&
name|suptr
operator|->
name|un_ent
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|suptr
operator|->
name|un_cnt
condition|;
name|i
operator|++
operator|,
name|sunptr
operator|++
control|)
block|{
if|if
condition|(
name|sunptr
operator|->
name|un_id
operator|!=
name|semid
operator|||
name|sunptr
operator|->
name|un_num
operator|!=
name|semnum
condition|)
continue|continue;
if|if
condition|(
name|adjval
operator|!=
literal|0
condition|)
block|{
name|adjval
operator|+=
name|sunptr
operator|->
name|un_adjval
expr_stmt|;
if|if
condition|(
name|adjval
operator|>
name|seminfo
operator|.
name|semaem
operator|||
name|adjval
operator|<
operator|-
name|seminfo
operator|.
name|semaem
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
block|}
name|sunptr
operator|->
name|un_adjval
operator|=
name|adjval
expr_stmt|;
if|if
condition|(
name|sunptr
operator|->
name|un_adjval
operator|==
literal|0
condition|)
block|{
name|suptr
operator|->
name|un_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|suptr
operator|->
name|un_cnt
condition|)
name|suptr
operator|->
name|un_ent
index|[
name|i
index|]
operator|=
name|suptr
operator|->
name|un_ent
index|[
name|suptr
operator|->
name|un_cnt
index|]
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Didn't find the right entry - create it */
if|if
condition|(
name|adjval
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|adjval
operator|>
name|seminfo
operator|.
name|semaem
operator|||
name|adjval
operator|<
operator|-
name|seminfo
operator|.
name|semaem
condition|)
return|return
operator|(
name|ERANGE
operator|)
return|;
if|if
condition|(
name|suptr
operator|->
name|un_cnt
operator|!=
name|seminfo
operator|.
name|semume
condition|)
block|{
name|sunptr
operator|=
operator|&
name|suptr
operator|->
name|un_ent
index|[
name|suptr
operator|->
name|un_cnt
index|]
expr_stmt|;
name|suptr
operator|->
name|un_cnt
operator|++
expr_stmt|;
name|sunptr
operator|->
name|un_adjval
operator|=
name|adjval
expr_stmt|;
name|sunptr
operator|->
name|un_id
operator|=
name|semid
expr_stmt|;
name|sunptr
operator|->
name|un_num
operator|=
name|semnum
expr_stmt|;
block|}
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|semundo_clear
parameter_list|(
name|semid
parameter_list|,
name|semnum
parameter_list|)
name|int
name|semid
decl_stmt|,
name|semnum
decl_stmt|;
block|{
specifier|register
name|struct
name|sem_undo
modifier|*
name|suptr
decl_stmt|;
for|for
control|(
name|suptr
operator|=
name|semu_list
init|;
name|suptr
operator|!=
name|NULL
condition|;
name|suptr
operator|=
name|suptr
operator|->
name|un_next
control|)
block|{
specifier|register
name|struct
name|undo
modifier|*
name|sunptr
init|=
operator|&
name|suptr
operator|->
name|un_ent
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|suptr
operator|->
name|un_cnt
condition|)
block|{
if|if
condition|(
name|sunptr
operator|->
name|un_id
operator|==
name|semid
condition|)
block|{
if|if
condition|(
name|semnum
operator|==
operator|-
literal|1
operator|||
name|sunptr
operator|->
name|un_num
operator|==
name|semnum
condition|)
block|{
name|suptr
operator|->
name|un_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|suptr
operator|->
name|un_cnt
condition|)
block|{
name|suptr
operator|->
name|un_ent
index|[
name|i
index|]
operator|=
name|suptr
operator|->
name|un_ent
index|[
name|suptr
operator|->
name|un_cnt
index|]
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|semnum
operator|!=
operator|-
literal|1
condition|)
break|break;
block|}
name|i
operator|++
operator|,
name|sunptr
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Note that the user-mode half of this passes a union, not a pointer  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|__semctl_args
block|{
name|int
name|semid
decl_stmt|;
name|int
name|semnum
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|union
name|semun
modifier|*
name|arg
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
name|int
name|__semctl
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
specifier|register
name|struct
name|__semctl_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|semid
init|=
name|uap
operator|->
name|semid
decl_stmt|;
name|int
name|semnum
init|=
name|uap
operator|->
name|semnum
decl_stmt|;
name|int
name|cmd
init|=
name|uap
operator|->
name|cmd
decl_stmt|;
name|union
name|semun
modifier|*
name|arg
init|=
name|uap
operator|->
name|arg
decl_stmt|;
name|union
name|semun
name|real_arg
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|td
operator|->
name|td_ucred
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rval
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|semid_ds
name|sbuf
decl_stmt|;
specifier|register
name|struct
name|semid_ds
modifier|*
name|semaptr
decl_stmt|;
name|u_short
name|usval
decl_stmt|;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"call to semctl(%d, %d, %d, 0x%x)\n"
argument_list|,
name|semid
argument_list|,
name|semnum
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|jail_sysvipc_allowed
operator|&&
name|jailed
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SEM_STAT
case|:
if|if
condition|(
name|semid
operator|<
literal|0
operator|||
name|semid
operator|>=
name|seminfo
operator|.
name|semmni
condition|)
name|UGAR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|semaptr
operator|=
operator|&
name|sema
index|[
name|semid
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|semaptr
operator|->
name|sem_perm
operator|.
name|mode
operator|&
name|SEM_ALLOC
operator|)
operator|==
literal|0
condition|)
name|UGAR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semaptr
operator|->
name|sem_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
name|UGAR
argument_list|(
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|real_arg
argument_list|,
sizeof|sizeof
argument_list|(
name|real_arg
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|UGAR
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|semaptr
argument_list|,
name|real_arg
operator|.
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|semid_ds
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|IXSEQ_TO_IPCID
argument_list|(
name|semid
argument_list|,
name|semaptr
operator|->
name|sem_perm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|rval
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|semid
operator|=
name|IPCID_TO_IX
argument_list|(
name|semid
argument_list|)
expr_stmt|;
if|if
condition|(
name|semid
operator|<
literal|0
operator|||
name|semid
operator|>=
name|seminfo
operator|.
name|semmni
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|semaptr
operator|=
operator|&
name|sema
index|[
name|semid
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|semaptr
operator|->
name|sem_perm
operator|.
name|mode
operator|&
name|SEM_ALLOC
operator|)
operator|==
literal|0
operator|||
name|semaptr
operator|->
name|sem_perm
operator|.
name|seq
operator|!=
name|IPCID_TO_SEQ
argument_list|(
name|uap
operator|->
name|semid
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|IPC_RMID
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semaptr
operator|->
name|sem_perm
argument_list|,
name|IPC_M
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
name|semaptr
operator|->
name|sem_perm
operator|.
name|cuid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|semaptr
operator|->
name|sem_perm
operator|.
name|uid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|semtot
operator|-=
name|semaptr
operator|->
name|sem_nsems
expr_stmt|;
for|for
control|(
name|i
operator|=
name|semaptr
operator|->
name|sem_base
operator|-
name|sem
init|;
name|i
operator|<
name|semtot
condition|;
name|i
operator|++
control|)
name|sem
index|[
name|i
index|]
operator|=
name|sem
index|[
name|i
operator|+
name|semaptr
operator|->
name|sem_nsems
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seminfo
operator|.
name|semmni
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sema
index|[
name|i
index|]
operator|.
name|sem_perm
operator|.
name|mode
operator|&
name|SEM_ALLOC
operator|)
operator|&&
name|sema
index|[
name|i
index|]
operator|.
name|sem_base
operator|>
name|semaptr
operator|->
name|sem_base
condition|)
name|sema
index|[
name|i
index|]
operator|.
name|sem_base
operator|-=
name|semaptr
operator|->
name|sem_nsems
expr_stmt|;
block|}
name|semaptr
operator|->
name|sem_perm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|semundo_clear
argument_list|(
name|semid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|semaptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPC_SET
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semaptr
operator|->
name|sem_perm
argument_list|,
name|IPC_M
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|real_arg
argument_list|,
sizeof|sizeof
argument_list|(
name|real_arg
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|real_arg
operator|.
name|buf
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sbuf
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|done2
goto|;
block|}
name|semaptr
operator|->
name|sem_perm
operator|.
name|uid
operator|=
name|sbuf
operator|.
name|sem_perm
operator|.
name|uid
expr_stmt|;
name|semaptr
operator|->
name|sem_perm
operator|.
name|gid
operator|=
name|sbuf
operator|.
name|sem_perm
operator|.
name|gid
expr_stmt|;
name|semaptr
operator|->
name|sem_perm
operator|.
name|mode
operator|=
operator|(
name|semaptr
operator|->
name|sem_perm
operator|.
name|mode
operator|&
operator|~
literal|0777
operator|)
operator||
operator|(
name|sbuf
operator|.
name|sem_perm
operator|.
name|mode
operator|&
literal|0777
operator|)
expr_stmt|;
name|semaptr
operator|->
name|sem_ctime
operator|=
name|time_second
expr_stmt|;
break|break;
case|case
name|IPC_STAT
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semaptr
operator|->
name|sem_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|real_arg
argument_list|,
sizeof|sizeof
argument_list|(
name|real_arg
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|semaptr
argument_list|,
name|real_arg
operator|.
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|semid_ds
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GETNCNT
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semaptr
operator|->
name|sem_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
name|semnum
operator|<
literal|0
operator|||
name|semnum
operator|>=
name|semaptr
operator|->
name|sem_nsems
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|rval
operator|=
name|semaptr
operator|->
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semncnt
expr_stmt|;
break|break;
case|case
name|GETPID
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semaptr
operator|->
name|sem_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
name|semnum
operator|<
literal|0
operator|||
name|semnum
operator|>=
name|semaptr
operator|->
name|sem_nsems
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|rval
operator|=
name|semaptr
operator|->
name|sem_base
index|[
name|semnum
index|]
operator|.
name|sempid
expr_stmt|;
break|break;
case|case
name|GETVAL
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semaptr
operator|->
name|sem_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
name|semnum
operator|<
literal|0
operator|||
name|semnum
operator|>=
name|semaptr
operator|->
name|sem_nsems
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|rval
operator|=
name|semaptr
operator|->
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semval
expr_stmt|;
break|break;
case|case
name|GETALL
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semaptr
operator|->
name|sem_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|real_arg
argument_list|,
sizeof|sizeof
argument_list|(
name|real_arg
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|semaptr
operator|->
name|sem_nsems
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|semaptr
operator|->
name|sem_base
index|[
name|i
index|]
operator|.
name|semval
argument_list|,
operator|&
name|real_arg
operator|.
name|array
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|real_arg
operator|.
name|array
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
break|break;
case|case
name|GETZCNT
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semaptr
operator|->
name|sem_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
name|semnum
operator|<
literal|0
operator|||
name|semnum
operator|>=
name|semaptr
operator|->
name|sem_nsems
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|rval
operator|=
name|semaptr
operator|->
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semzcnt
expr_stmt|;
break|break;
case|case
name|SETVAL
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semaptr
operator|->
name|sem_perm
argument_list|,
name|IPC_W
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
name|semnum
operator|<
literal|0
operator|||
name|semnum
operator|>=
name|semaptr
operator|->
name|sem_nsems
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|real_arg
argument_list|,
sizeof|sizeof
argument_list|(
name|real_arg
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
name|real_arg
operator|.
name|val
operator|<
literal|0
operator|||
name|real_arg
operator|.
name|val
operator|>
name|seminfo
operator|.
name|semvmx
condition|)
block|{
name|error
operator|=
name|ERANGE
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|semaptr
operator|->
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semval
operator|=
name|real_arg
operator|.
name|val
expr_stmt|;
name|semundo_clear
argument_list|(
name|semid
argument_list|,
name|semnum
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|semaptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SETALL
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semaptr
operator|->
name|sem_perm
argument_list|,
name|IPC_W
argument_list|)
operator|)
condition|)
goto|goto
name|done2
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|real_arg
argument_list|,
sizeof|sizeof
argument_list|(
name|real_arg
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|semaptr
operator|->
name|sem_nsems
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|copyin
argument_list|(
operator|&
name|real_arg
operator|.
name|array
index|[
name|i
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|usval
argument_list|,
sizeof|sizeof
argument_list|(
name|real_arg
operator|.
name|array
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|usval
operator|>
name|seminfo
operator|.
name|semvmx
condition|)
block|{
name|error
operator|=
name|ERANGE
expr_stmt|;
break|break;
block|}
name|semaptr
operator|->
name|sem_base
index|[
name|i
index|]
operator|.
name|semval
operator|=
name|usval
expr_stmt|;
block|}
name|semundo_clear
argument_list|(
name|semid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|semaptr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|rval
expr_stmt|;
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|semget_args
block|{
name|key_t
name|key
decl_stmt|;
name|int
name|nsems
decl_stmt|;
name|int
name|semflg
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
name|int
name|semget
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
specifier|register
name|struct
name|semget_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|semid
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|key
init|=
name|uap
operator|->
name|key
decl_stmt|;
name|int
name|nsems
init|=
name|uap
operator|->
name|nsems
decl_stmt|;
name|int
name|semflg
init|=
name|uap
operator|->
name|semflg
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|td
operator|->
name|td_ucred
decl_stmt|;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semget(0x%x, %d, 0%o)\n"
argument_list|,
name|key
argument_list|,
name|nsems
argument_list|,
name|semflg
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|jail_sysvipc_allowed
operator|&&
name|jailed
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|IPC_PRIVATE
condition|)
block|{
for|for
control|(
name|semid
operator|=
literal|0
init|;
name|semid
operator|<
name|seminfo
operator|.
name|semmni
condition|;
name|semid
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
operator|.
name|mode
operator|&
name|SEM_ALLOC
operator|)
operator|&&
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
operator|.
name|key
operator|==
name|key
condition|)
break|break;
block|}
if|if
condition|(
name|semid
operator|<
name|seminfo
operator|.
name|semmni
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"found public key\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
argument_list|,
name|semflg
operator|&
literal|0700
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
name|nsems
operator|>
literal|0
operator|&&
name|sema
index|[
name|semid
index|]
operator|.
name|sem_nsems
operator|<
name|nsems
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"too small\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
operator|(
name|semflg
operator|&
name|IPC_CREAT
operator|)
operator|&&
operator|(
name|semflg
operator|&
name|IPC_EXCL
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"not exclusive\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
goto|goto
name|found
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"need to allocate the semid_ds\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|key
operator|==
name|IPC_PRIVATE
operator|||
operator|(
name|semflg
operator|&
name|IPC_CREAT
operator|)
condition|)
block|{
if|if
condition|(
name|nsems
operator|<=
literal|0
operator|||
name|nsems
operator|>
name|seminfo
operator|.
name|semmsl
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"nsems out of range (0<%d<=%d)\n"
argument_list|,
name|nsems
argument_list|,
name|seminfo
operator|.
name|semmsl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
name|nsems
operator|>
name|seminfo
operator|.
name|semmns
operator|-
name|semtot
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"not enough semaphores left (need %d, got %d)\n"
argument_list|,
name|nsems
argument_list|,
name|seminfo
operator|.
name|semmns
operator|-
name|semtot
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
for|for
control|(
name|semid
operator|=
literal|0
init|;
name|semid
operator|<
name|seminfo
operator|.
name|semmni
condition|;
name|semid
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
operator|.
name|mode
operator|&
name|SEM_ALLOC
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|semid
operator|==
name|seminfo
operator|.
name|semmni
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"no more semid_ds's available\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|ENOSPC
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semid %d is available\n"
argument_list|,
name|semid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
operator|.
name|cuid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
operator|.
name|uid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
operator|.
name|cgid
operator|=
name|cred
operator|->
name|cr_gid
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
operator|.
name|gid
operator|=
name|cred
operator|->
name|cr_gid
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
operator|.
name|mode
operator|=
operator|(
name|semflg
operator|&
literal|0777
operator|)
operator||
name|SEM_ALLOC
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
operator|.
name|seq
operator|=
operator|(
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
operator|.
name|seq
operator|+
literal|1
operator|)
operator|&
literal|0x7fff
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|sem_nsems
operator|=
name|nsems
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|sem_otime
operator|=
literal|0
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|sem_ctime
operator|=
name|time_second
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|sem_base
operator|=
operator|&
name|sem
index|[
name|semtot
index|]
expr_stmt|;
name|semtot
operator|+=
name|nsems
expr_stmt|;
name|bzero
argument_list|(
name|sema
index|[
name|semid
index|]
operator|.
name|sem_base
argument_list|,
sizeof|sizeof
argument_list|(
name|sema
index|[
name|semid
index|]
operator|.
name|sem_base
index|[
literal|0
index|]
argument_list|)
operator|*
name|nsems
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"sembase = 0x%x, next = 0x%x\n"
argument_list|,
name|sema
index|[
name|semid
index|]
operator|.
name|sem_base
argument_list|,
operator|&
name|sem
index|[
name|semtot
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"didn't find it and wasn't asked to create it\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|found
label|:
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|IXSEQ_TO_IPCID
argument_list|(
name|semid
argument_list|,
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
argument_list|)
expr_stmt|;
name|done2
label|:
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|semop_args
block|{
name|int
name|semid
decl_stmt|;
name|struct
name|sembuf
modifier|*
name|sops
decl_stmt|;
name|u_int
name|nsops
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MPSAFE  */
end_comment

begin_function
name|int
name|semop
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
specifier|register
name|struct
name|semop_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|semid
init|=
name|uap
operator|->
name|semid
decl_stmt|;
name|u_int
name|nsops
init|=
name|uap
operator|->
name|nsops
decl_stmt|;
name|struct
name|sembuf
modifier|*
name|sops
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|semid_ds
modifier|*
name|semaptr
decl_stmt|;
specifier|register
name|struct
name|sembuf
modifier|*
name|sopptr
decl_stmt|;
specifier|register
name|struct
name|sem
modifier|*
name|semptr
decl_stmt|;
name|struct
name|sem_undo
modifier|*
name|suptr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|error
decl_stmt|;
name|int
name|do_wakeup
decl_stmt|,
name|do_undos
decl_stmt|;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"call to semop(%d, 0x%x, %u)\n"
argument_list|,
name|semid
argument_list|,
name|sops
argument_list|,
name|nsops
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|jail_sysvipc_allowed
operator|&&
name|jailed
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
condition|)
return|return
operator|(
name|ENOSYS
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|semid
operator|=
name|IPCID_TO_IX
argument_list|(
name|semid
argument_list|)
expr_stmt|;
comment|/* Convert back to zero origin */
if|if
condition|(
name|semid
operator|<
literal|0
operator|||
name|semid
operator|>=
name|seminfo
operator|.
name|semmni
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
name|semaptr
operator|=
operator|&
name|sema
index|[
name|semid
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|semaptr
operator|->
name|sem_perm
operator|.
name|mode
operator|&
name|SEM_ALLOC
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
name|semaptr
operator|->
name|sem_perm
operator|.
name|seq
operator|!=
name|IPCID_TO_SEQ
argument_list|(
name|uap
operator|->
name|semid
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
name|nsops
operator|>
name|seminfo
operator|.
name|semopm
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"too many sops (max=%d, nsops=%d)\n"
argument_list|,
name|seminfo
operator|.
name|semopm
argument_list|,
name|nsops
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
comment|/* Allocate memory for sem_ops */
name|sops
operator|=
name|malloc
argument_list|(
name|nsops
operator|*
sizeof|sizeof
argument_list|(
name|sops
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|M_SEM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sops
condition|)
name|panic
argument_list|(
literal|"Failed to allocate %d sem_ops"
argument_list|,
name|nsops
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|sops
argument_list|,
name|sops
argument_list|,
name|nsops
operator|*
sizeof|sizeof
argument_list|(
name|sops
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"error = %d from copyin(%08x, %08x, %d)\n"
argument_list|,
name|error
argument_list|,
name|uap
operator|->
name|sops
argument_list|,
name|sops
argument_list|,
name|nsops
operator|*
sizeof|sizeof
argument_list|(
name|sops
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|done2
goto|;
block|}
comment|/* 	 * Initial pass thru sops to see what permissions are needed. 	 * Also perform any checks that don't need repeating on each 	 * attempt to satisfy the request vector. 	 */
name|j
operator|=
literal|0
expr_stmt|;
comment|/* permission needed */
name|do_undos
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsops
condition|;
name|i
operator|++
control|)
block|{
name|sopptr
operator|=
operator|&
name|sops
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sopptr
operator|->
name|sem_num
operator|>=
name|semaptr
operator|->
name|sem_nsems
condition|)
block|{
name|error
operator|=
name|EFBIG
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
name|sopptr
operator|->
name|sem_flg
operator|&
name|SEM_UNDO
operator|&&
name|sopptr
operator|->
name|sem_op
operator|!=
literal|0
condition|)
name|do_undos
operator|=
literal|1
expr_stmt|;
name|j
operator||=
operator|(
name|sopptr
operator|->
name|sem_op
operator|==
literal|0
operator|)
condition|?
name|SEM_R
else|:
name|SEM_A
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|ipcperm
argument_list|(
name|td
argument_list|,
operator|&
name|semaptr
operator|->
name|sem_perm
argument_list|,
name|j
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"error = %d from ipaccess\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|done2
goto|;
block|}
comment|/* 	 * Loop trying to satisfy the vector of requests. 	 * If we reach a point where we must wait, any requests already 	 * performed are rolled back and we go to sleep until some other 	 * process wakes us up.  At this point, we start all over again. 	 * 	 * This ensures that from the perspective of other tasks, a set 	 * of requests is atomic (never partially satisfied). 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|do_wakeup
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* error return if necessary */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsops
condition|;
name|i
operator|++
control|)
block|{
name|sopptr
operator|=
operator|&
name|sops
index|[
name|i
index|]
expr_stmt|;
name|semptr
operator|=
operator|&
name|semaptr
operator|->
name|sem_base
index|[
name|sopptr
operator|->
name|sem_num
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semop:  semaptr=%x, sem_base=%x, semptr=%x, sem[%d]=%d : op=%d, flag=%s\n"
argument_list|,
name|semaptr
argument_list|,
name|semaptr
operator|->
name|sem_base
argument_list|,
name|semptr
argument_list|,
name|sopptr
operator|->
name|sem_num
argument_list|,
name|semptr
operator|->
name|semval
argument_list|,
name|sopptr
operator|->
name|sem_op
argument_list|,
operator|(
name|sopptr
operator|->
name|sem_flg
operator|&
name|IPC_NOWAIT
operator|)
condition|?
literal|"nowait"
else|:
literal|"wait"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sopptr
operator|->
name|sem_op
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|semptr
operator|->
name|semval
operator|+
name|sopptr
operator|->
name|sem_op
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semop:  can't do it now\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
else|else
block|{
name|semptr
operator|->
name|semval
operator|+=
name|sopptr
operator|->
name|sem_op
expr_stmt|;
if|if
condition|(
name|semptr
operator|->
name|semval
operator|==
literal|0
operator|&&
name|semptr
operator|->
name|semzcnt
operator|>
literal|0
condition|)
name|do_wakeup
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sopptr
operator|->
name|sem_op
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|semptr
operator|->
name|semval
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semop:  not zero now\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|semptr
operator|->
name|semval
operator|+
name|sopptr
operator|->
name|sem_op
operator|>
name|seminfo
operator|.
name|semvmx
condition|)
block|{
name|error
operator|=
name|ERANGE
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|semptr
operator|->
name|semncnt
operator|>
literal|0
condition|)
name|do_wakeup
operator|=
literal|1
expr_stmt|;
name|semptr
operator|->
name|semval
operator|+=
name|sopptr
operator|->
name|sem_op
expr_stmt|;
block|}
block|}
comment|/* 		 * Did we get through the entire vector? 		 */
if|if
condition|(
name|i
operator|>=
name|nsops
condition|)
goto|goto
name|done
goto|;
comment|/* 		 * No ... rollback anything that we've already done 		 */
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semop:  rollback 0 through %d\n"
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|semaptr
operator|->
name|sem_base
index|[
name|sops
index|[
name|j
index|]
operator|.
name|sem_num
index|]
operator|.
name|semval
operator|-=
name|sops
index|[
name|j
index|]
operator|.
name|sem_op
expr_stmt|;
comment|/* If we detected an error, return it */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done2
goto|;
comment|/* 		 * If the request that we couldn't satisfy has the 		 * NOWAIT flag set then return with EAGAIN. 		 */
if|if
condition|(
name|sopptr
operator|->
name|sem_flg
operator|&
name|IPC_NOWAIT
condition|)
block|{
name|error
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
if|if
condition|(
name|sopptr
operator|->
name|sem_op
operator|==
literal|0
condition|)
name|semptr
operator|->
name|semzcnt
operator|++
expr_stmt|;
else|else
name|semptr
operator|->
name|semncnt
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semop:  good night!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|semaptr
argument_list|,
operator|(
name|PZERO
operator|-
literal|4
operator|)
operator||
name|PCATCH
argument_list|,
literal|"semwait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semop:  good morning (error=%d)!\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semop:  good morning!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Make sure that the semaphore still exists 		 */
if|if
condition|(
operator|(
name|semaptr
operator|->
name|sem_perm
operator|.
name|mode
operator|&
name|SEM_ALLOC
operator|)
operator|==
literal|0
operator|||
name|semaptr
operator|->
name|sem_perm
operator|.
name|seq
operator|!=
name|IPCID_TO_SEQ
argument_list|(
name|uap
operator|->
name|semid
argument_list|)
condition|)
block|{
name|error
operator|=
name|EIDRM
expr_stmt|;
goto|goto
name|done2
goto|;
block|}
comment|/* 		 * The semaphore is still alive.  Readjust the count of 		 * waiting processes. 		 */
if|if
condition|(
name|sopptr
operator|->
name|sem_op
operator|==
literal|0
condition|)
name|semptr
operator|->
name|semzcnt
operator|--
expr_stmt|;
else|else
name|semptr
operator|->
name|semncnt
operator|--
expr_stmt|;
block|}
name|done
label|:
comment|/* 	 * Process any SEM_UNDO requests. 	 */
if|if
condition|(
name|do_undos
condition|)
block|{
name|suptr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsops
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * We only need to deal with SEM_UNDO's for non-zero 			 * op's. 			 */
name|int
name|adjval
decl_stmt|;
if|if
condition|(
operator|(
name|sops
index|[
name|i
index|]
operator|.
name|sem_flg
operator|&
name|SEM_UNDO
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|adjval
operator|=
name|sops
index|[
name|i
index|]
operator|.
name|sem_op
expr_stmt|;
if|if
condition|(
name|adjval
operator|==
literal|0
condition|)
continue|continue;
name|error
operator|=
name|semundo_adjust
argument_list|(
name|td
argument_list|,
operator|&
name|suptr
argument_list|,
name|semid
argument_list|,
name|sops
index|[
name|i
index|]
operator|.
name|sem_num
argument_list|,
operator|-
name|adjval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
continue|continue;
comment|/* 			 * Oh-Oh!  We ran out of either sem_undo's or undo's. 			 * Rollback the adjustments to this point and then 			 * rollback the semaphore ups and down so we can return 			 * with an error with all structures restored.  We 			 * rollback the undo's in the exact reverse order that 			 * we applied them.  This guarantees that we won't run 			 * out of space as we roll things back out. 			 */
for|for
control|(
name|j
operator|=
name|i
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|sops
index|[
name|j
index|]
operator|.
name|sem_flg
operator|&
name|SEM_UNDO
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|adjval
operator|=
name|sops
index|[
name|j
index|]
operator|.
name|sem_op
expr_stmt|;
if|if
condition|(
name|adjval
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|semundo_adjust
argument_list|(
name|td
argument_list|,
operator|&
name|suptr
argument_list|,
name|semid
argument_list|,
name|sops
index|[
name|j
index|]
operator|.
name|sem_num
argument_list|,
name|adjval
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"semop - can't undo undos"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsops
condition|;
name|j
operator|++
control|)
name|semaptr
operator|->
name|sem_base
index|[
name|sops
index|[
name|j
index|]
operator|.
name|sem_num
index|]
operator|.
name|semval
operator|-=
name|sops
index|[
name|j
index|]
operator|.
name|sem_op
expr_stmt|;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"error = %d from semundo_adjust\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|done2
goto|;
block|}
comment|/* loop through the sops */
block|}
comment|/* if (do_undos) */
comment|/* We're definitely done - set the sempid's and time */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsops
condition|;
name|i
operator|++
control|)
block|{
name|sopptr
operator|=
operator|&
name|sops
index|[
name|i
index|]
expr_stmt|;
name|semptr
operator|=
operator|&
name|semaptr
operator|->
name|sem_base
index|[
name|sopptr
operator|->
name|sem_num
index|]
expr_stmt|;
name|semptr
operator|->
name|sempid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
block|}
name|semaptr
operator|->
name|sem_otime
operator|=
name|time_second
expr_stmt|;
comment|/* 	 * Do a wakeup if any semaphore was up'd whilst something was 	 * sleeping on it. 	 */
if|if
condition|(
name|do_wakeup
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semop:  doing wakeup\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|semaptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semop:  back from wakeup\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semop:  done\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|done2
label|:
if|if
condition|(
name|sops
condition|)
name|free
argument_list|(
name|sops
argument_list|,
name|M_SEM
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Go through the undo structures for this process and apply the adjustments to  * semaphores.  */
end_comment

begin_function
specifier|static
name|void
name|semexit_myhook
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|sem_undo
modifier|*
name|suptr
decl_stmt|;
specifier|register
name|struct
name|sem_undo
modifier|*
modifier|*
name|supptr
decl_stmt|;
comment|/* 	 * Go through the chain of undo vectors looking for one 	 * associated with this process. 	 */
for|for
control|(
name|supptr
operator|=
operator|&
name|semu_list
init|;
operator|(
name|suptr
operator|=
operator|*
name|supptr
operator|)
operator|!=
name|NULL
condition|;
name|supptr
operator|=
operator|&
name|suptr
operator|->
name|un_next
control|)
block|{
if|if
condition|(
name|suptr
operator|->
name|un_proc
operator|==
name|p
condition|)
break|break;
block|}
if|if
condition|(
name|suptr
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"proc @%08x has undo structure with %d entries\n"
argument_list|,
name|p
argument_list|,
name|suptr
operator|->
name|un_cnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If there are any active undo elements then process them. 	 */
if|if
condition|(
name|suptr
operator|->
name|un_cnt
operator|>
literal|0
condition|)
block|{
name|int
name|ix
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|suptr
operator|->
name|un_cnt
condition|;
name|ix
operator|++
control|)
block|{
name|int
name|semid
init|=
name|suptr
operator|->
name|un_ent
index|[
name|ix
index|]
operator|.
name|un_id
decl_stmt|;
name|int
name|semnum
init|=
name|suptr
operator|->
name|un_ent
index|[
name|ix
index|]
operator|.
name|un_num
decl_stmt|;
name|int
name|adjval
init|=
name|suptr
operator|->
name|un_ent
index|[
name|ix
index|]
operator|.
name|un_adjval
decl_stmt|;
name|struct
name|semid_ds
modifier|*
name|semaptr
decl_stmt|;
name|semaptr
operator|=
operator|&
name|sema
index|[
name|semid
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|semaptr
operator|->
name|sem_perm
operator|.
name|mode
operator|&
name|SEM_ALLOC
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"semexit - semid not allocated"
argument_list|)
expr_stmt|;
if|if
condition|(
name|semnum
operator|>=
name|semaptr
operator|->
name|sem_nsems
condition|)
name|panic
argument_list|(
literal|"semexit - semnum out of range"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semexit:  %08x id=%d num=%d(adj=%d) ; sem=%d\n"
argument_list|,
name|suptr
operator|->
name|un_proc
argument_list|,
name|suptr
operator|->
name|un_ent
index|[
name|ix
index|]
operator|.
name|un_id
argument_list|,
name|suptr
operator|->
name|un_ent
index|[
name|ix
index|]
operator|.
name|un_num
argument_list|,
name|suptr
operator|->
name|un_ent
index|[
name|ix
index|]
operator|.
name|un_adjval
argument_list|,
name|semaptr
operator|->
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semval
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|adjval
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|semaptr
operator|->
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semval
operator|<
operator|-
name|adjval
condition|)
name|semaptr
operator|->
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semval
operator|=
literal|0
expr_stmt|;
else|else
name|semaptr
operator|->
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semval
operator|+=
name|adjval
expr_stmt|;
block|}
else|else
name|semaptr
operator|->
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semval
operator|+=
name|adjval
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|semaptr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semexit:  back from wakeup\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* 	 * Deallocate the undo vector. 	 */
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"removing vector\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|suptr
operator|->
name|un_proc
operator|=
name|NULL
expr_stmt|;
operator|*
name|supptr
operator|=
name|suptr
operator|->
name|un_next
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_sema
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
return|return
operator|(
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|sema
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|semid_ds
argument_list|)
operator|*
name|seminfo
operator|.
name|semmni
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

