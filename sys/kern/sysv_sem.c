begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: sysv_sem.c,v 1.19 1997/08/02 14:31:38 bde Exp $ */
end_comment

begin_comment
comment|/*  * Implementation of SVID semaphores  *  * Author:  Daniel Boulet  *  * This software is provided ``AS IS'' without any warranties of any kind.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sem.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_decl_stmt
specifier|static
name|void
name|seminit
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_macro
name|SYSINIT
argument_list|(
argument|sysv_sem
argument_list|,
argument|SI_SUB_SYSV_SEM
argument_list|,
argument|SI_ORDER_FIRST
argument_list|,
argument|seminit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct_decl
struct_decl|struct
name|__semctl_args
struct_decl|;
end_struct_decl

begin_decl_stmt
name|int
name|__semctl
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
name|p
operator|,
expr|struct
name|__semctl_args
operator|*
name|uap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|semget_args
struct_decl|;
end_struct_decl

begin_decl_stmt
name|int
name|semget
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
name|p
operator|,
expr|struct
name|semget_args
operator|*
name|uap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|semop_args
struct_decl|;
end_struct_decl

begin_decl_stmt
name|int
name|semop
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
name|p
operator|,
expr|struct
name|semop_args
operator|*
name|uap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|semconfig_args
struct_decl|;
end_struct_decl

begin_decl_stmt
name|int
name|semconfig
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
name|p
operator|,
expr|struct
name|semconfig_args
operator|*
name|uap
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|sem_undo
modifier|*
name|semu_alloc
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|semundo_adjust
name|__P
argument_list|(
operator|(
expr|struct
name|proc
operator|*
name|p
operator|,
expr|struct
name|sem_undo
operator|*
operator|*
name|supptr
operator|,
name|int
name|semid
operator|,
name|int
name|semnum
operator|,
name|int
name|adjval
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|semundo_clear
name|__P
argument_list|(
operator|(
name|int
name|semid
operator|,
name|int
name|semnum
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX casting to (sy_call_t *) is bogus, as usual. */
end_comment

begin_decl_stmt
specifier|static
name|sy_call_t
modifier|*
name|semcalls
index|[]
init|=
block|{
operator|(
name|sy_call_t
operator|*
operator|)
name|__semctl
block|,
operator|(
name|sy_call_t
operator|*
operator|)
name|semget
block|,
operator|(
name|sy_call_t
operator|*
operator|)
name|semop
block|,
operator|(
name|sy_call_t
operator|*
operator|)
name|semconfig
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|semtot
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|semid_ds
modifier|*
name|sema
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* semaphore id pool */
end_comment

begin_decl_stmt
name|struct
name|sem
modifier|*
name|sem
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* semaphore pool */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sem_undo
modifier|*
name|semu_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of active undo structures */
end_comment

begin_decl_stmt
name|int
modifier|*
name|semu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* undo structure pool */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|semlock_holder
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|seminit
parameter_list|(
name|dummy
parameter_list|)
name|void
modifier|*
name|dummy
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sema
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"sema is NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|semu
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"semu is NULL"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seminfo
operator|.
name|semmni
condition|;
name|i
operator|++
control|)
block|{
name|sema
index|[
name|i
index|]
operator|.
name|sem_base
operator|=
literal|0
expr_stmt|;
name|sema
index|[
name|i
index|]
operator|.
name|sem_perm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seminfo
operator|.
name|semmnu
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|struct
name|sem_undo
modifier|*
name|suptr
init|=
name|SEMU
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|suptr
operator|->
name|un_proc
operator|=
name|NULL
expr_stmt|;
block|}
name|semu_list
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Entry point for all SEM calls  */
end_comment

begin_function
name|int
name|semsys
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
comment|/* XXX actually varargs. */
name|struct
name|semsys_args
comment|/* { 		u_int	which; 		int	a2; 		int	a3; 		int	a4; 		int	a5; 	} */
modifier|*
name|uap
decl_stmt|;
block|{
while|while
condition|(
name|semlock_holder
operator|!=
name|NULL
operator|&&
name|semlock_holder
operator|!=
name|p
condition|)
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|semlock_holder
argument_list|,
operator|(
name|PZERO
operator|-
literal|4
operator|)
argument_list|,
literal|"semsys"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|which
operator|>=
sizeof|sizeof
argument_list|(
name|semcalls
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|semcalls
index|[
literal|0
index|]
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
call|(
modifier|*
name|semcalls
index|[
name|uap
operator|->
name|which
index|]
call|)
argument_list|(
name|p
argument_list|,
operator|&
name|uap
operator|->
name|a2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock or unlock the entire semaphore facility.  *  * This will probably eventually evolve into a general purpose semaphore  * facility status enquiry mechanism (I don't like the "read /dev/kmem"  * approach currently taken by ipcs and the amount of info that we want  * to be able to extract for ipcs is probably beyond what the capability  * of the getkerninfo facility.  *  * At the time that the current version of semconfig was written, ipcs is  * the only user of the semconfig facility.  It uses it to ensure that the  * semaphore facility data structures remain static while it fishes around  * in /dev/kmem.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|semconfig_args
block|{
name|semconfig_ctl_t
name|flag
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|semconfig
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|semconfig_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|eval
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|flag
condition|)
block|{
case|case
name|SEM_CONFIG_FREEZE
case|:
name|semlock_holder
operator|=
name|p
expr_stmt|;
break|break;
case|case
name|SEM_CONFIG_THAW
case|:
name|semlock_holder
operator|=
name|NULL
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|semlock_holder
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"semconfig: unknown flag parameter value (%d) - ignored\n"
argument_list|,
name|uap
operator|->
name|flag
argument_list|)
expr_stmt|;
name|eval
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|eval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new sem_undo structure for a process  * (returns ptr to structure or NULL if no more room)  */
end_comment

begin_function
specifier|static
name|struct
name|sem_undo
modifier|*
name|semu_alloc
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|sem_undo
modifier|*
name|suptr
decl_stmt|;
specifier|register
name|struct
name|sem_undo
modifier|*
modifier|*
name|supptr
decl_stmt|;
name|int
name|attempt
decl_stmt|;
comment|/* 	 * Try twice to allocate something. 	 * (we'll purge any empty structures after the first pass so 	 * two passes are always enough) 	 */
for|for
control|(
name|attempt
operator|=
literal|0
init|;
name|attempt
operator|<
literal|2
condition|;
name|attempt
operator|++
control|)
block|{
comment|/* 		 * Look for a free structure. 		 * Fill it in and return it if we find one. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seminfo
operator|.
name|semmnu
condition|;
name|i
operator|++
control|)
block|{
name|suptr
operator|=
name|SEMU
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|suptr
operator|->
name|un_proc
operator|==
name|NULL
condition|)
block|{
name|suptr
operator|->
name|un_next
operator|=
name|semu_list
expr_stmt|;
name|semu_list
operator|=
name|suptr
expr_stmt|;
name|suptr
operator|->
name|un_cnt
operator|=
literal|0
expr_stmt|;
name|suptr
operator|->
name|un_proc
operator|=
name|p
expr_stmt|;
return|return
operator|(
name|suptr
operator|)
return|;
block|}
block|}
comment|/* 		 * We didn't find a free one, if this is the first attempt 		 * then try to free some structures. 		 */
if|if
condition|(
name|attempt
operator|==
literal|0
condition|)
block|{
comment|/* All the structures are in use - try to free some */
name|int
name|did_something
init|=
literal|0
decl_stmt|;
name|supptr
operator|=
operator|&
name|semu_list
expr_stmt|;
while|while
condition|(
operator|(
name|suptr
operator|=
operator|*
name|supptr
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|suptr
operator|->
name|un_cnt
operator|==
literal|0
condition|)
block|{
name|suptr
operator|->
name|un_proc
operator|=
name|NULL
expr_stmt|;
operator|*
name|supptr
operator|=
name|suptr
operator|->
name|un_next
expr_stmt|;
name|did_something
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|supptr
operator|=
operator|&
operator|(
name|suptr
operator|->
name|un_next
operator|)
expr_stmt|;
block|}
comment|/* If we didn't free anything then just give-up */
if|if
condition|(
operator|!
name|did_something
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
comment|/* 			 * The second pass failed even though we freed 			 * something after the first pass! 			 * This is IMPOSSIBLE! 			 */
name|panic
argument_list|(
literal|"semu_alloc - second attempt failed"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Adjust a particular entry for a particular proc  */
end_comment

begin_function
specifier|static
name|int
name|semundo_adjust
parameter_list|(
name|p
parameter_list|,
name|supptr
parameter_list|,
name|semid
parameter_list|,
name|semnum
parameter_list|,
name|adjval
parameter_list|)
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|sem_undo
modifier|*
modifier|*
name|supptr
decl_stmt|;
name|int
name|semid
decl_stmt|,
name|semnum
decl_stmt|;
name|int
name|adjval
decl_stmt|;
block|{
specifier|register
name|struct
name|sem_undo
modifier|*
name|suptr
decl_stmt|;
specifier|register
name|struct
name|undo
modifier|*
name|sunptr
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Look for and remember the sem_undo if the caller doesn't provide 	   it */
name|suptr
operator|=
operator|*
name|supptr
expr_stmt|;
if|if
condition|(
name|suptr
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|suptr
operator|=
name|semu_list
init|;
name|suptr
operator|!=
name|NULL
condition|;
name|suptr
operator|=
name|suptr
operator|->
name|un_next
control|)
block|{
if|if
condition|(
name|suptr
operator|->
name|un_proc
operator|==
name|p
condition|)
block|{
operator|*
name|supptr
operator|=
name|suptr
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|suptr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|adjval
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|suptr
operator|=
name|semu_alloc
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|suptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
operator|*
name|supptr
operator|=
name|suptr
expr_stmt|;
block|}
block|}
comment|/* 	 * Look for the requested entry and adjust it (delete if adjval becomes 	 * 0). 	 */
name|sunptr
operator|=
operator|&
name|suptr
operator|->
name|un_ent
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|suptr
operator|->
name|un_cnt
condition|;
name|i
operator|++
operator|,
name|sunptr
operator|++
control|)
block|{
if|if
condition|(
name|sunptr
operator|->
name|un_id
operator|!=
name|semid
operator|||
name|sunptr
operator|->
name|un_num
operator|!=
name|semnum
condition|)
continue|continue;
if|if
condition|(
name|adjval
operator|==
literal|0
condition|)
name|sunptr
operator|->
name|un_adjval
operator|=
literal|0
expr_stmt|;
else|else
name|sunptr
operator|->
name|un_adjval
operator|+=
name|adjval
expr_stmt|;
if|if
condition|(
name|sunptr
operator|->
name|un_adjval
operator|==
literal|0
condition|)
block|{
name|suptr
operator|->
name|un_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|suptr
operator|->
name|un_cnt
condition|)
name|suptr
operator|->
name|un_ent
index|[
name|i
index|]
operator|=
name|suptr
operator|->
name|un_ent
index|[
name|suptr
operator|->
name|un_cnt
index|]
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Didn't find the right entry - create it */
if|if
condition|(
name|adjval
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|suptr
operator|->
name|un_cnt
operator|!=
name|SEMUME
condition|)
block|{
name|sunptr
operator|=
operator|&
name|suptr
operator|->
name|un_ent
index|[
name|suptr
operator|->
name|un_cnt
index|]
expr_stmt|;
name|suptr
operator|->
name|un_cnt
operator|++
expr_stmt|;
name|sunptr
operator|->
name|un_adjval
operator|=
name|adjval
expr_stmt|;
name|sunptr
operator|->
name|un_id
operator|=
name|semid
expr_stmt|;
name|sunptr
operator|->
name|un_num
operator|=
name|semnum
expr_stmt|;
block|}
else|else
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|semundo_clear
parameter_list|(
name|semid
parameter_list|,
name|semnum
parameter_list|)
name|int
name|semid
decl_stmt|,
name|semnum
decl_stmt|;
block|{
specifier|register
name|struct
name|sem_undo
modifier|*
name|suptr
decl_stmt|;
for|for
control|(
name|suptr
operator|=
name|semu_list
init|;
name|suptr
operator|!=
name|NULL
condition|;
name|suptr
operator|=
name|suptr
operator|->
name|un_next
control|)
block|{
specifier|register
name|struct
name|undo
modifier|*
name|sunptr
init|=
operator|&
name|suptr
operator|->
name|un_ent
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|i
operator|<
name|suptr
operator|->
name|un_cnt
condition|)
block|{
if|if
condition|(
name|sunptr
operator|->
name|un_id
operator|==
name|semid
condition|)
block|{
if|if
condition|(
name|semnum
operator|==
operator|-
literal|1
operator|||
name|sunptr
operator|->
name|un_num
operator|==
name|semnum
condition|)
block|{
name|suptr
operator|->
name|un_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|suptr
operator|->
name|un_cnt
condition|)
block|{
name|suptr
operator|->
name|un_ent
index|[
name|i
index|]
operator|=
name|suptr
operator|->
name|un_ent
index|[
name|suptr
operator|->
name|un_cnt
index|]
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|semnum
operator|!=
operator|-
literal|1
condition|)
break|break;
block|}
name|i
operator|++
operator|,
name|sunptr
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Note that the user-mode half of this passes a union, not a pointer  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|__semctl_args
block|{
name|int
name|semid
decl_stmt|;
name|int
name|semnum
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|union
name|semun
modifier|*
name|arg
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|__semctl
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|__semctl_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|semid
init|=
name|uap
operator|->
name|semid
decl_stmt|;
name|int
name|semnum
init|=
name|uap
operator|->
name|semnum
decl_stmt|;
name|int
name|cmd
init|=
name|uap
operator|->
name|cmd
decl_stmt|;
name|union
name|semun
modifier|*
name|arg
init|=
name|uap
operator|->
name|arg
decl_stmt|;
name|union
name|semun
name|real_arg
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|p
operator|->
name|p_ucred
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rval
decl_stmt|,
name|eval
decl_stmt|;
name|struct
name|semid_ds
name|sbuf
decl_stmt|;
specifier|register
name|struct
name|semid_ds
modifier|*
name|semaptr
decl_stmt|;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"call to semctl(%d, %d, %d, 0x%x)\n"
argument_list|,
name|semid
argument_list|,
name|semnum
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|semid
operator|=
name|IPCID_TO_IX
argument_list|(
name|semid
argument_list|)
expr_stmt|;
if|if
condition|(
name|semid
operator|<
literal|0
operator|||
name|semid
operator|>=
name|seminfo
operator|.
name|semmsl
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|semaptr
operator|=
operator|&
name|sema
index|[
name|semid
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|semaptr
operator|->
name|sem_perm
operator|.
name|mode
operator|&
name|SEM_ALLOC
operator|)
operator|==
literal|0
operator|||
name|semaptr
operator|->
name|sem_perm
operator|.
name|seq
operator|!=
name|IPCID_TO_SEQ
argument_list|(
name|uap
operator|->
name|semid
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|eval
operator|=
literal|0
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|IPC_RMID
case|:
if|if
condition|(
operator|(
name|eval
operator|=
name|ipcperm
argument_list|(
name|cred
argument_list|,
operator|&
name|semaptr
operator|->
name|sem_perm
argument_list|,
name|IPC_M
argument_list|)
operator|)
condition|)
return|return
operator|(
name|eval
operator|)
return|;
name|semaptr
operator|->
name|sem_perm
operator|.
name|cuid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|semaptr
operator|->
name|sem_perm
operator|.
name|uid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|semtot
operator|-=
name|semaptr
operator|->
name|sem_nsems
expr_stmt|;
for|for
control|(
name|i
operator|=
name|semaptr
operator|->
name|sem_base
operator|-
name|sem
init|;
name|i
operator|<
name|semtot
condition|;
name|i
operator|++
control|)
name|sem
index|[
name|i
index|]
operator|=
name|sem
index|[
name|i
operator|+
name|semaptr
operator|->
name|sem_nsems
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seminfo
operator|.
name|semmni
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sema
index|[
name|i
index|]
operator|.
name|sem_perm
operator|.
name|mode
operator|&
name|SEM_ALLOC
operator|)
operator|&&
name|sema
index|[
name|i
index|]
operator|.
name|sem_base
operator|>
name|semaptr
operator|->
name|sem_base
condition|)
name|sema
index|[
name|i
index|]
operator|.
name|sem_base
operator|-=
name|semaptr
operator|->
name|sem_nsems
expr_stmt|;
block|}
name|semaptr
operator|->
name|sem_perm
operator|.
name|mode
operator|=
literal|0
expr_stmt|;
name|semundo_clear
argument_list|(
name|semid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|semaptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPC_SET
case|:
if|if
condition|(
operator|(
name|eval
operator|=
name|ipcperm
argument_list|(
name|cred
argument_list|,
operator|&
name|semaptr
operator|->
name|sem_perm
argument_list|,
name|IPC_M
argument_list|)
operator|)
condition|)
return|return
operator|(
name|eval
operator|)
return|;
if|if
condition|(
operator|(
name|eval
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|real_arg
argument_list|,
sizeof|sizeof
argument_list|(
name|real_arg
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|eval
operator|)
return|;
if|if
condition|(
operator|(
name|eval
operator|=
name|copyin
argument_list|(
name|real_arg
operator|.
name|buf
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|sbuf
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|eval
operator|)
return|;
name|semaptr
operator|->
name|sem_perm
operator|.
name|uid
operator|=
name|sbuf
operator|.
name|sem_perm
operator|.
name|uid
expr_stmt|;
name|semaptr
operator|->
name|sem_perm
operator|.
name|gid
operator|=
name|sbuf
operator|.
name|sem_perm
operator|.
name|gid
expr_stmt|;
name|semaptr
operator|->
name|sem_perm
operator|.
name|mode
operator|=
operator|(
name|semaptr
operator|->
name|sem_perm
operator|.
name|mode
operator|&
operator|~
literal|0777
operator|)
operator||
operator|(
name|sbuf
operator|.
name|sem_perm
operator|.
name|mode
operator|&
literal|0777
operator|)
expr_stmt|;
name|semaptr
operator|->
name|sem_ctime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
break|break;
case|case
name|IPC_STAT
case|:
if|if
condition|(
operator|(
name|eval
operator|=
name|ipcperm
argument_list|(
name|cred
argument_list|,
operator|&
name|semaptr
operator|->
name|sem_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
return|return
operator|(
name|eval
operator|)
return|;
if|if
condition|(
operator|(
name|eval
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|real_arg
argument_list|,
sizeof|sizeof
argument_list|(
name|real_arg
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|eval
operator|)
return|;
name|eval
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|semaptr
argument_list|,
name|real_arg
operator|.
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|semid_ds
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|GETNCNT
case|:
if|if
condition|(
operator|(
name|eval
operator|=
name|ipcperm
argument_list|(
name|cred
argument_list|,
operator|&
name|semaptr
operator|->
name|sem_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
return|return
operator|(
name|eval
operator|)
return|;
if|if
condition|(
name|semnum
operator|<
literal|0
operator|||
name|semnum
operator|>=
name|semaptr
operator|->
name|sem_nsems
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rval
operator|=
name|semaptr
operator|->
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semncnt
expr_stmt|;
break|break;
case|case
name|GETPID
case|:
if|if
condition|(
operator|(
name|eval
operator|=
name|ipcperm
argument_list|(
name|cred
argument_list|,
operator|&
name|semaptr
operator|->
name|sem_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
return|return
operator|(
name|eval
operator|)
return|;
if|if
condition|(
name|semnum
operator|<
literal|0
operator|||
name|semnum
operator|>=
name|semaptr
operator|->
name|sem_nsems
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rval
operator|=
name|semaptr
operator|->
name|sem_base
index|[
name|semnum
index|]
operator|.
name|sempid
expr_stmt|;
break|break;
case|case
name|GETVAL
case|:
if|if
condition|(
operator|(
name|eval
operator|=
name|ipcperm
argument_list|(
name|cred
argument_list|,
operator|&
name|semaptr
operator|->
name|sem_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
return|return
operator|(
name|eval
operator|)
return|;
if|if
condition|(
name|semnum
operator|<
literal|0
operator|||
name|semnum
operator|>=
name|semaptr
operator|->
name|sem_nsems
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rval
operator|=
name|semaptr
operator|->
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semval
expr_stmt|;
break|break;
case|case
name|GETALL
case|:
if|if
condition|(
operator|(
name|eval
operator|=
name|ipcperm
argument_list|(
name|cred
argument_list|,
operator|&
name|semaptr
operator|->
name|sem_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
return|return
operator|(
name|eval
operator|)
return|;
if|if
condition|(
operator|(
name|eval
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|real_arg
argument_list|,
sizeof|sizeof
argument_list|(
name|real_arg
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|eval
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|semaptr
operator|->
name|sem_nsems
condition|;
name|i
operator|++
control|)
block|{
name|eval
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|semaptr
operator|->
name|sem_base
index|[
name|i
index|]
operator|.
name|semval
argument_list|,
operator|&
name|real_arg
operator|.
name|array
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|real_arg
operator|.
name|array
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eval
operator|!=
literal|0
condition|)
break|break;
block|}
break|break;
case|case
name|GETZCNT
case|:
if|if
condition|(
operator|(
name|eval
operator|=
name|ipcperm
argument_list|(
name|cred
argument_list|,
operator|&
name|semaptr
operator|->
name|sem_perm
argument_list|,
name|IPC_R
argument_list|)
operator|)
condition|)
return|return
operator|(
name|eval
operator|)
return|;
if|if
condition|(
name|semnum
operator|<
literal|0
operator|||
name|semnum
operator|>=
name|semaptr
operator|->
name|sem_nsems
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|rval
operator|=
name|semaptr
operator|->
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semzcnt
expr_stmt|;
break|break;
case|case
name|SETVAL
case|:
if|if
condition|(
operator|(
name|eval
operator|=
name|ipcperm
argument_list|(
name|cred
argument_list|,
operator|&
name|semaptr
operator|->
name|sem_perm
argument_list|,
name|IPC_W
argument_list|)
operator|)
condition|)
return|return
operator|(
name|eval
operator|)
return|;
if|if
condition|(
name|semnum
operator|<
literal|0
operator|||
name|semnum
operator|>=
name|semaptr
operator|->
name|sem_nsems
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|eval
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|real_arg
argument_list|,
sizeof|sizeof
argument_list|(
name|real_arg
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|eval
operator|)
return|;
name|semaptr
operator|->
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semval
operator|=
name|real_arg
operator|.
name|val
expr_stmt|;
name|semundo_clear
argument_list|(
name|semid
argument_list|,
name|semnum
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|semaptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SETALL
case|:
if|if
condition|(
operator|(
name|eval
operator|=
name|ipcperm
argument_list|(
name|cred
argument_list|,
operator|&
name|semaptr
operator|->
name|sem_perm
argument_list|,
name|IPC_W
argument_list|)
operator|)
condition|)
return|return
operator|(
name|eval
operator|)
return|;
if|if
condition|(
operator|(
name|eval
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|real_arg
argument_list|,
sizeof|sizeof
argument_list|(
name|real_arg
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|eval
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|semaptr
operator|->
name|sem_nsems
condition|;
name|i
operator|++
control|)
block|{
name|eval
operator|=
name|copyin
argument_list|(
operator|&
name|real_arg
operator|.
name|array
index|[
name|i
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|semaptr
operator|->
name|sem_base
index|[
name|i
index|]
operator|.
name|semval
argument_list|,
sizeof|sizeof
argument_list|(
name|real_arg
operator|.
name|array
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eval
operator|!=
literal|0
condition|)
break|break;
block|}
name|semundo_clear
argument_list|(
name|semid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|semaptr
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|eval
operator|==
literal|0
condition|)
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|rval
expr_stmt|;
return|return
operator|(
name|eval
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|semget_args
block|{
name|key_t
name|key
decl_stmt|;
name|int
name|nsems
decl_stmt|;
name|int
name|semflg
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|semget
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|semget_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|semid
decl_stmt|,
name|eval
decl_stmt|;
name|int
name|key
init|=
name|uap
operator|->
name|key
decl_stmt|;
name|int
name|nsems
init|=
name|uap
operator|->
name|nsems
decl_stmt|;
name|int
name|semflg
init|=
name|uap
operator|->
name|semflg
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|p
operator|->
name|p_ucred
decl_stmt|;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semget(0x%x, %d, 0%o)\n"
argument_list|,
name|key
argument_list|,
name|nsems
argument_list|,
name|semflg
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|key
operator|!=
name|IPC_PRIVATE
condition|)
block|{
for|for
control|(
name|semid
operator|=
literal|0
init|;
name|semid
operator|<
name|seminfo
operator|.
name|semmni
condition|;
name|semid
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
operator|.
name|mode
operator|&
name|SEM_ALLOC
operator|)
operator|&&
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
operator|.
name|key
operator|==
name|key
condition|)
break|break;
block|}
if|if
condition|(
name|semid
operator|<
name|seminfo
operator|.
name|semmni
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"found public key\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|eval
operator|=
name|ipcperm
argument_list|(
name|cred
argument_list|,
operator|&
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
argument_list|,
name|semflg
operator|&
literal|0700
argument_list|)
operator|)
condition|)
return|return
operator|(
name|eval
operator|)
return|;
if|if
condition|(
name|nsems
operator|>
literal|0
operator|&&
name|sema
index|[
name|semid
index|]
operator|.
name|sem_nsems
operator|<
name|nsems
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"too small\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|semflg
operator|&
name|IPC_CREAT
operator|)
operator|&&
operator|(
name|semflg
operator|&
name|IPC_EXCL
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"not exclusive\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
goto|goto
name|found
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"need to allocate the semid_ds\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|key
operator|==
name|IPC_PRIVATE
operator|||
operator|(
name|semflg
operator|&
name|IPC_CREAT
operator|)
condition|)
block|{
if|if
condition|(
name|nsems
operator|<=
literal|0
operator|||
name|nsems
operator|>
name|seminfo
operator|.
name|semmsl
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"nsems out of range (0<%d<=%d)\n"
argument_list|,
name|nsems
argument_list|,
name|seminfo
operator|.
name|semmsl
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|nsems
operator|>
name|seminfo
operator|.
name|semmns
operator|-
name|semtot
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"not enough semaphores left (need %d, got %d)\n"
argument_list|,
name|nsems
argument_list|,
name|seminfo
operator|.
name|semmns
operator|-
name|semtot
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
for|for
control|(
name|semid
operator|=
literal|0
init|;
name|semid
operator|<
name|seminfo
operator|.
name|semmni
condition|;
name|semid
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
operator|.
name|mode
operator|&
name|SEM_ALLOC
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|semid
operator|==
name|seminfo
operator|.
name|semmni
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"no more semid_ds's available\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semid %d is available\n"
argument_list|,
name|semid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
operator|.
name|cuid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
operator|.
name|uid
operator|=
name|cred
operator|->
name|cr_uid
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
operator|.
name|cgid
operator|=
name|cred
operator|->
name|cr_gid
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
operator|.
name|gid
operator|=
name|cred
operator|->
name|cr_gid
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
operator|.
name|mode
operator|=
operator|(
name|semflg
operator|&
literal|0777
operator|)
operator||
name|SEM_ALLOC
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
operator|.
name|seq
operator|=
operator|(
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
operator|.
name|seq
operator|+
literal|1
operator|)
operator|&
literal|0x7fff
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|sem_nsems
operator|=
name|nsems
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|sem_otime
operator|=
literal|0
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|sem_ctime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
name|sema
index|[
name|semid
index|]
operator|.
name|sem_base
operator|=
operator|&
name|sem
index|[
name|semtot
index|]
expr_stmt|;
name|semtot
operator|+=
name|nsems
expr_stmt|;
name|bzero
argument_list|(
name|sema
index|[
name|semid
index|]
operator|.
name|sem_base
argument_list|,
sizeof|sizeof
argument_list|(
name|sema
index|[
name|semid
index|]
operator|.
name|sem_base
index|[
literal|0
index|]
argument_list|)
operator|*
name|nsems
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"sembase = 0x%x, next = 0x%x\n"
argument_list|,
name|sema
index|[
name|semid
index|]
operator|.
name|sem_base
argument_list|,
operator|&
name|sem
index|[
name|semtot
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"didn't find it and wasn't asked to create it\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|found
label|:
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|IXSEQ_TO_IPCID
argument_list|(
name|semid
argument_list|,
name|sema
index|[
name|semid
index|]
operator|.
name|sem_perm
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|semop_args
block|{
name|int
name|semid
decl_stmt|;
name|struct
name|sembuf
modifier|*
name|sops
decl_stmt|;
name|int
name|nsops
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|semop
parameter_list|(
name|p
parameter_list|,
name|uap
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|semop_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|semid
init|=
name|uap
operator|->
name|semid
decl_stmt|;
name|int
name|nsops
init|=
name|uap
operator|->
name|nsops
decl_stmt|;
name|struct
name|sembuf
name|sops
index|[
name|MAX_SOPS
index|]
decl_stmt|;
specifier|register
name|struct
name|semid_ds
modifier|*
name|semaptr
decl_stmt|;
specifier|register
name|struct
name|sembuf
modifier|*
name|sopptr
decl_stmt|;
specifier|register
name|struct
name|sem
modifier|*
name|semptr
decl_stmt|;
name|struct
name|sem_undo
modifier|*
name|suptr
init|=
name|NULL
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|p
operator|->
name|p_ucred
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|eval
decl_stmt|;
name|int
name|do_wakeup
decl_stmt|,
name|do_undos
decl_stmt|;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"call to semop(%d, 0x%x, %d)\n"
argument_list|,
name|semid
argument_list|,
name|sops
argument_list|,
name|nsops
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|semid
operator|=
name|IPCID_TO_IX
argument_list|(
name|semid
argument_list|)
expr_stmt|;
comment|/* Convert back to zero origin */
if|if
condition|(
name|semid
operator|<
literal|0
operator|||
name|semid
operator|>=
name|seminfo
operator|.
name|semmsl
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|semaptr
operator|=
operator|&
name|sema
index|[
name|semid
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|semaptr
operator|->
name|sem_perm
operator|.
name|mode
operator|&
name|SEM_ALLOC
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|semaptr
operator|->
name|sem_perm
operator|.
name|seq
operator|!=
name|IPCID_TO_SEQ
argument_list|(
name|uap
operator|->
name|semid
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|eval
operator|=
name|ipcperm
argument_list|(
name|cred
argument_list|,
operator|&
name|semaptr
operator|->
name|sem_perm
argument_list|,
name|IPC_W
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"eval = %d from ipaccess\n"
argument_list|,
name|eval
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|eval
operator|)
return|;
block|}
if|if
condition|(
name|nsops
operator|>
name|MAX_SOPS
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"too many sops (max=%d, nsops=%d)\n"
argument_list|,
name|MAX_SOPS
argument_list|,
name|nsops
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|E2BIG
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|eval
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|sops
argument_list|,
operator|&
name|sops
argument_list|,
name|nsops
operator|*
sizeof|sizeof
argument_list|(
name|sops
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"eval = %d from copyin(%08x, %08x, %d)\n"
argument_list|,
name|eval
argument_list|,
name|uap
operator|->
name|sops
argument_list|,
operator|&
name|sops
argument_list|,
name|nsops
operator|*
sizeof|sizeof
argument_list|(
name|sops
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|eval
operator|)
return|;
block|}
comment|/* 	 * Loop trying to satisfy the vector of requests. 	 * If we reach a point where we must wait, any requests already 	 * performed are rolled back and we go to sleep until some other 	 * process wakes us up.  At this point, we start all over again. 	 * 	 * This ensures that from the perspective of other tasks, a set 	 * of requests is atomic (never partially satisfied). 	 */
name|do_undos
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|do_wakeup
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsops
condition|;
name|i
operator|++
control|)
block|{
name|sopptr
operator|=
operator|&
name|sops
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sopptr
operator|->
name|sem_num
operator|>=
name|semaptr
operator|->
name|sem_nsems
condition|)
return|return
operator|(
name|EFBIG
operator|)
return|;
name|semptr
operator|=
operator|&
name|semaptr
operator|->
name|sem_base
index|[
name|sopptr
operator|->
name|sem_num
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semop:  semaptr=%x, sem_base=%x, semptr=%x, sem[%d]=%d : op=%d, flag=%s\n"
argument_list|,
name|semaptr
argument_list|,
name|semaptr
operator|->
name|sem_base
argument_list|,
name|semptr
argument_list|,
name|sopptr
operator|->
name|sem_num
argument_list|,
name|semptr
operator|->
name|semval
argument_list|,
name|sopptr
operator|->
name|sem_op
argument_list|,
operator|(
name|sopptr
operator|->
name|sem_flg
operator|&
name|IPC_NOWAIT
operator|)
condition|?
literal|"nowait"
else|:
literal|"wait"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sopptr
operator|->
name|sem_op
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|semptr
operator|->
name|semval
operator|+
name|sopptr
operator|->
name|sem_op
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semop:  can't do it now\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
else|else
block|{
name|semptr
operator|->
name|semval
operator|+=
name|sopptr
operator|->
name|sem_op
expr_stmt|;
if|if
condition|(
name|semptr
operator|->
name|semval
operator|==
literal|0
operator|&&
name|semptr
operator|->
name|semzcnt
operator|>
literal|0
condition|)
name|do_wakeup
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sopptr
operator|->
name|sem_flg
operator|&
name|SEM_UNDO
condition|)
name|do_undos
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sopptr
operator|->
name|sem_op
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|semptr
operator|->
name|semval
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semop:  not zero now\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|semptr
operator|->
name|semncnt
operator|>
literal|0
condition|)
name|do_wakeup
operator|=
literal|1
expr_stmt|;
name|semptr
operator|->
name|semval
operator|+=
name|sopptr
operator|->
name|sem_op
expr_stmt|;
if|if
condition|(
name|sopptr
operator|->
name|sem_flg
operator|&
name|SEM_UNDO
condition|)
name|do_undos
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 		 * Did we get through the entire vector? 		 */
if|if
condition|(
name|i
operator|>=
name|nsops
condition|)
goto|goto
name|done
goto|;
comment|/* 		 * No ... rollback anything that we've already done 		 */
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semop:  rollback 0 through %d\n"
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
name|semaptr
operator|->
name|sem_base
index|[
name|sops
index|[
name|j
index|]
operator|.
name|sem_num
index|]
operator|.
name|semval
operator|-=
name|sops
index|[
name|j
index|]
operator|.
name|sem_op
expr_stmt|;
comment|/* 		 * If the request that we couldn't satisfy has the 		 * NOWAIT flag set then return with EAGAIN. 		 */
if|if
condition|(
name|sopptr
operator|->
name|sem_flg
operator|&
name|IPC_NOWAIT
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
if|if
condition|(
name|sopptr
operator|->
name|sem_op
operator|==
literal|0
condition|)
name|semptr
operator|->
name|semzcnt
operator|++
expr_stmt|;
else|else
name|semptr
operator|->
name|semncnt
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semop:  good night!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|eval
operator|=
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|semaptr
argument_list|,
operator|(
name|PZERO
operator|-
literal|4
operator|)
operator||
name|PCATCH
argument_list|,
literal|"semwait"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semop:  good morning (eval=%d)!\n"
argument_list|,
name|eval
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|suptr
operator|=
name|NULL
expr_stmt|;
comment|/* sem_undo may have been reallocated */
if|if
condition|(
name|eval
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semop:  good morning!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Make sure that the semaphore still exists 		 */
if|if
condition|(
operator|(
name|semaptr
operator|->
name|sem_perm
operator|.
name|mode
operator|&
name|SEM_ALLOC
operator|)
operator|==
literal|0
operator|||
name|semaptr
operator|->
name|sem_perm
operator|.
name|seq
operator|!=
name|IPCID_TO_SEQ
argument_list|(
name|uap
operator|->
name|semid
argument_list|)
condition|)
block|{
comment|/* The man page says to return EIDRM. */
comment|/* Unfortunately, BSD doesn't define that code! */
ifdef|#
directive|ifdef
name|EIDRM
return|return
operator|(
name|EIDRM
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|EINVAL
operator|)
return|;
endif|#
directive|endif
block|}
comment|/* 		 * The semaphore is still alive.  Readjust the count of 		 * waiting processes. 		 */
if|if
condition|(
name|sopptr
operator|->
name|sem_op
operator|==
literal|0
condition|)
name|semptr
operator|->
name|semzcnt
operator|--
expr_stmt|;
else|else
name|semptr
operator|->
name|semncnt
operator|--
expr_stmt|;
block|}
name|done
label|:
comment|/* 	 * Process any SEM_UNDO requests. 	 */
if|if
condition|(
name|do_undos
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsops
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * We only need to deal with SEM_UNDO's for non-zero 			 * op's. 			 */
name|int
name|adjval
decl_stmt|;
if|if
condition|(
operator|(
name|sops
index|[
name|i
index|]
operator|.
name|sem_flg
operator|&
name|SEM_UNDO
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|adjval
operator|=
name|sops
index|[
name|i
index|]
operator|.
name|sem_op
expr_stmt|;
if|if
condition|(
name|adjval
operator|==
literal|0
condition|)
continue|continue;
name|eval
operator|=
name|semundo_adjust
argument_list|(
name|p
argument_list|,
operator|&
name|suptr
argument_list|,
name|semid
argument_list|,
name|sops
index|[
name|i
index|]
operator|.
name|sem_num
argument_list|,
operator|-
name|adjval
argument_list|)
expr_stmt|;
if|if
condition|(
name|eval
operator|==
literal|0
condition|)
continue|continue;
comment|/* 			 * Oh-Oh!  We ran out of either sem_undo's or undo's. 			 * Rollback the adjustments to this point and then 			 * rollback the semaphore ups and down so we can return 			 * with an error with all structures restored.  We 			 * rollback the undo's in the exact reverse order that 			 * we applied them.  This guarantees that we won't run 			 * out of space as we roll things back out. 			 */
for|for
control|(
name|j
operator|=
name|i
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|sops
index|[
name|j
index|]
operator|.
name|sem_flg
operator|&
name|SEM_UNDO
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|adjval
operator|=
name|sops
index|[
name|j
index|]
operator|.
name|sem_op
expr_stmt|;
if|if
condition|(
name|adjval
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|semundo_adjust
argument_list|(
name|p
argument_list|,
operator|&
name|suptr
argument_list|,
name|semid
argument_list|,
name|sops
index|[
name|j
index|]
operator|.
name|sem_num
argument_list|,
name|adjval
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"semop - can't undo undos"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsops
condition|;
name|j
operator|++
control|)
name|semaptr
operator|->
name|sem_base
index|[
name|sops
index|[
name|j
index|]
operator|.
name|sem_num
index|]
operator|.
name|semval
operator|-=
name|sops
index|[
name|j
index|]
operator|.
name|sem_op
expr_stmt|;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"eval = %d from semundo_adjust\n"
argument_list|,
name|eval
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|eval
operator|)
return|;
block|}
comment|/* loop through the sops */
block|}
comment|/* if (do_undos) */
comment|/* We're definitely done - set the sempid's */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsops
condition|;
name|i
operator|++
control|)
block|{
name|sopptr
operator|=
operator|&
name|sops
index|[
name|i
index|]
expr_stmt|;
name|semptr
operator|=
operator|&
name|semaptr
operator|->
name|sem_base
index|[
name|sopptr
operator|->
name|sem_num
index|]
expr_stmt|;
name|semptr
operator|->
name|sempid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
block|}
comment|/* Do a wakeup if any semaphore was up'd. */
if|if
condition|(
name|do_wakeup
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semop:  doing wakeup\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEM_WAKEUP
name|sem_wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|semaptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|semaptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf
argument_list|(
literal|"semop:  back from wakeup\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|semaptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semop:  done\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Go through the undo structures for this process and apply the adjustments to  * semaphores.  */
end_comment

begin_function
name|void
name|semexit
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|sem_undo
modifier|*
name|suptr
decl_stmt|;
specifier|register
name|struct
name|sem_undo
modifier|*
modifier|*
name|supptr
decl_stmt|;
name|int
name|did_something
decl_stmt|;
comment|/* 	 * If somebody else is holding the global semaphore facility lock 	 * then sleep until it is released. 	 */
while|while
condition|(
name|semlock_holder
operator|!=
name|NULL
operator|&&
name|semlock_holder
operator|!=
name|p
condition|)
block|{
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semaphore facility locked - sleeping ...\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|semlock_holder
argument_list|,
operator|(
name|PZERO
operator|-
literal|4
operator|)
argument_list|,
literal|"semext"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|did_something
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Go through the chain of undo vectors looking for one 	 * associated with this process. 	 */
for|for
control|(
name|supptr
operator|=
operator|&
name|semu_list
init|;
operator|(
name|suptr
operator|=
operator|*
name|supptr
operator|)
operator|!=
name|NULL
condition|;
name|supptr
operator|=
operator|&
name|suptr
operator|->
name|un_next
control|)
block|{
if|if
condition|(
name|suptr
operator|->
name|un_proc
operator|==
name|p
condition|)
break|break;
block|}
if|if
condition|(
name|suptr
operator|==
name|NULL
condition|)
goto|goto
name|unlock
goto|;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"proc @%08x has undo structure with %d entries\n"
argument_list|,
name|p
argument_list|,
name|suptr
operator|->
name|un_cnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If there are any active undo elements then process them. 	 */
if|if
condition|(
name|suptr
operator|->
name|un_cnt
operator|>
literal|0
condition|)
block|{
name|int
name|ix
decl_stmt|;
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|suptr
operator|->
name|un_cnt
condition|;
name|ix
operator|++
control|)
block|{
name|int
name|semid
init|=
name|suptr
operator|->
name|un_ent
index|[
name|ix
index|]
operator|.
name|un_id
decl_stmt|;
name|int
name|semnum
init|=
name|suptr
operator|->
name|un_ent
index|[
name|ix
index|]
operator|.
name|un_num
decl_stmt|;
name|int
name|adjval
init|=
name|suptr
operator|->
name|un_ent
index|[
name|ix
index|]
operator|.
name|un_adjval
decl_stmt|;
name|struct
name|semid_ds
modifier|*
name|semaptr
decl_stmt|;
name|semaptr
operator|=
operator|&
name|sema
index|[
name|semid
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|semaptr
operator|->
name|sem_perm
operator|.
name|mode
operator|&
name|SEM_ALLOC
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"semexit - semid not allocated"
argument_list|)
expr_stmt|;
if|if
condition|(
name|semnum
operator|>=
name|semaptr
operator|->
name|sem_nsems
condition|)
name|panic
argument_list|(
literal|"semexit - semnum out of range"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semexit:  %08x id=%d num=%d(adj=%d) ; sem=%d\n"
argument_list|,
name|suptr
operator|->
name|un_proc
argument_list|,
name|suptr
operator|->
name|un_ent
index|[
name|ix
index|]
operator|.
name|un_id
argument_list|,
name|suptr
operator|->
name|un_ent
index|[
name|ix
index|]
operator|.
name|un_num
argument_list|,
name|suptr
operator|->
name|un_ent
index|[
name|ix
index|]
operator|.
name|un_adjval
argument_list|,
name|semaptr
operator|->
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semval
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|adjval
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|semaptr
operator|->
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semval
operator|<
operator|-
name|adjval
condition|)
name|semaptr
operator|->
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semval
operator|=
literal|0
expr_stmt|;
else|else
name|semaptr
operator|->
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semval
operator|+=
name|adjval
expr_stmt|;
block|}
else|else
name|semaptr
operator|->
name|sem_base
index|[
name|semnum
index|]
operator|.
name|semval
operator|+=
name|adjval
expr_stmt|;
ifdef|#
directive|ifdef
name|SEM_WAKEUP
name|sem_wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|semaptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|semaptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"semexit:  back from wakeup\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* 	 * Deallocate the undo vector. 	 */
ifdef|#
directive|ifdef
name|SEM_DEBUG
name|printf
argument_list|(
literal|"removing vector\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|suptr
operator|->
name|un_proc
operator|=
name|NULL
expr_stmt|;
operator|*
name|supptr
operator|=
name|suptr
operator|->
name|un_next
expr_stmt|;
name|unlock
label|:
comment|/* 	 * If the exiting process is holding the global semaphore facility 	 * lock then release it. 	 */
if|if
condition|(
name|semlock_holder
operator|==
name|p
condition|)
block|{
name|semlock_holder
operator|=
name|NULL
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|semlock_holder
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

