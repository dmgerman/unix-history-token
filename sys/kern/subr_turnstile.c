begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 Berkeley Software Design, Inc. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Berkeley Software Design Inc's name may not be used to endorse or  *    promote products derived from this software without specific prior  *    written permission.  *  * THIS SOFTWARE IS PROVIDED BY BERKELEY SOFTWARE DESIGN INC ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL BERKELEY SOFTWARE DESIGN INC BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from BSDI $Id: mutex_witness.c,v 1.1.2.20 2000/04/27 03:10:27 cp Exp $  *	and BSDI $Id: synch_machdep.c,v 2.3.2.39 2000/04/27 03:10:25 cp Exp $  */
end_comment

begin_comment
comment|/*  * Implementation of turnstiles used to hold queue of threads blocked on  * non-sleepable locks.  Sleepable locks use condition variables to  * implement their queues.  Turnstiles differ from a sleep queue in that  * turnstile queue's are assigned to a lock held by an owning thread.  Thus,  * when one thread is enqueued onto a turnstile, it can lend its priority  * to the owning thread.  *  * We wish to avoid bloating locks with an embedded turnstile and we do not  * want to use back-pointers in the locks for the same reason.  Thus, we  * use a similar approach to that of Solaris 7 as described in Solaris  * Internals by Jim Mauro and Richard McDougall.  Turnstiles are looked up  * in a hash table based on the address of the lock.  Each entry in the  * hash table is a linked-lists of turnstiles and is called a turnstile  * chain.  Each chain contains a spin mutex that protects all of the  * turnstiles in the chain.  *  * Each time a thread is created, a turnstile is malloc'd and attached to  * that thread.  When a thread blocks on a lock, if it is the first thread  * to block, it lends its turnstile to the lock.  If the lock already has  * a turnstile, then it gives its turnstile to the lock's turnstile's free  * list.  When a thread is woken up, it takes a turnstile from the free list  * if there are any other waiters.  If it is the only thread blocked on the  * lock, then it reclaims the turnstile associated with the lock and removes  * it from the hash table.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_turnstile_profiling.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/turnstile.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<sys/lockmgr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Constants for the hash table of turnstile chains.  TC_SHIFT is a magic  * number chosen because the sleep queue's use the same value for the  * shift.  Basically, we ignore the lower 8 bits of the address.  * TC_TABLESIZE must be a power of two for TC_MASK to work properly.  */
end_comment

begin_define
define|#
directive|define
name|TC_TABLESIZE
value|128
end_define

begin_comment
comment|/* Must be power of 2. */
end_comment

begin_define
define|#
directive|define
name|TC_MASK
value|(TC_TABLESIZE - 1)
end_define

begin_define
define|#
directive|define
name|TC_SHIFT
value|8
end_define

begin_define
define|#
directive|define
name|TC_HASH
parameter_list|(
name|lock
parameter_list|)
value|(((uintptr_t)(lock)>> TC_SHIFT)& TC_MASK)
end_define

begin_define
define|#
directive|define
name|TC_LOOKUP
parameter_list|(
name|lock
parameter_list|)
value|&turnstile_chains[TC_HASH(lock)]
end_define

begin_comment
comment|/*  * There are three different lists of turnstiles as follows.  The list  * connected by ts_link entries is a per-thread list of all the turnstiles  * attached to locks that we own.  This is used to fixup our priority when  * a lock is released.  The other two lists use the ts_hash entries.  The  * first of these two is the turnstile chain list that a turnstile is on  * when it is attached to a lock.  The second list to use ts_hash is the  * free list hung off of a turnstile that is attached to a lock.  *  * Each turnstile contains three lists of threads.  The two ts_blocked lists  * are linked list of threads blocked on the turnstile's lock.  One list is  * for exclusive waiters, and the other is for shared waiters.  The  * ts_pending list is a linked list of threads previously awakened by  * turnstile_signal() or turnstile_wait() that are waiting to be put on  * the run queue.  *  * Locking key:  *  c - turnstile chain lock  *  q - td_contested lock  */
end_comment

begin_struct
struct|struct
name|turnstile
block|{
name|struct
name|threadqueue
name|ts_blocked
index|[
literal|2
index|]
decl_stmt|;
comment|/* (c + q) Blocked threads. */
name|struct
name|threadqueue
name|ts_pending
decl_stmt|;
comment|/* (c) Pending threads. */
name|LIST_ENTRY
argument_list|(
argument|turnstile
argument_list|)
name|ts_hash
expr_stmt|;
comment|/* (c) Chain and free list. */
name|LIST_ENTRY
argument_list|(
argument|turnstile
argument_list|)
name|ts_link
expr_stmt|;
comment|/* (q) Contested locks. */
name|LIST_HEAD
argument_list|(
argument_list|,
argument|turnstile
argument_list|)
name|ts_free
expr_stmt|;
comment|/* (c) Free turnstiles. */
name|struct
name|lock_object
modifier|*
name|ts_lockobj
decl_stmt|;
comment|/* (c) Lock we reference. */
name|struct
name|thread
modifier|*
name|ts_owner
decl_stmt|;
comment|/* (c + q) Who owns the lock. */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|turnstile_chain
block|{
name|LIST_HEAD
argument_list|(
argument_list|,
argument|turnstile
argument_list|)
name|tc_turnstiles
expr_stmt|;
comment|/* List of turnstiles. */
name|struct
name|mtx
name|tc_lock
decl_stmt|;
comment|/* Spin lock for this chain. */
ifdef|#
directive|ifdef
name|TURNSTILE_PROFILING
name|u_int
name|tc_depth
decl_stmt|;
comment|/* Length of tc_queues. */
name|u_int
name|tc_max_depth
decl_stmt|;
comment|/* Max length of tc_queues. */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|TURNSTILE_PROFILING
end_ifdef

begin_decl_stmt
name|u_int
name|turnstile_max_depth
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|turnstile
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"turnstile profiling"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_debug_turnstile
argument_list|,
name|OID_AUTO
argument_list|,
name|chains
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"turnstile chain stats"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_debug_turnstile
argument_list|,
name|OID_AUTO
argument_list|,
name|max_depth
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|turnstile_max_depth
argument_list|,
literal|0
argument_list|,
literal|"maxmimum depth achieved of a single chain"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|td_contested_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|turnstile_chain
name|turnstile_chains
index|[
name|TC_TABLESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_TURNSTILE
argument_list|,
literal|"turnstiles"
argument_list|,
literal|"turnstiles"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Prototypes for non-exported routines.  */
end_comment

begin_function_decl
specifier|static
name|void
name|init_turnstile0
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|TURNSTILE_PROFILING
end_ifdef

begin_function_decl
specifier|static
name|void
name|init_turnstile_profiling
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|propagate_priority
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|turnstile_adjust_thread
parameter_list|(
name|struct
name|turnstile
modifier|*
name|ts
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|thread
modifier|*
name|turnstile_first_waiter
parameter_list|(
name|struct
name|turnstile
modifier|*
name|ts
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|turnstile_setowner
parameter_list|(
name|struct
name|turnstile
modifier|*
name|ts
parameter_list|,
name|struct
name|thread
modifier|*
name|owner
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Walks the chain of turnstiles and their owners to propagate the priority  * of the thread being blocked to all the threads holding locks that have to  * release their locks before this thread can run again.  */
end_comment

begin_function
specifier|static
name|void
name|propagate_priority
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|turnstile_chain
modifier|*
name|tc
decl_stmt|;
name|struct
name|turnstile
modifier|*
name|ts
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|pri
operator|=
name|td
operator|->
name|td_priority
expr_stmt|;
name|ts
operator|=
name|td
operator|->
name|td_blocked
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|td
operator|=
name|ts
operator|->
name|ts_owner
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * This might be a read lock with no owner.  There's 			 * not much we can do, so just bail. 			 */
return|return;
block|}
name|MPASS
argument_list|(
name|td
operator|->
name|td_proc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_magic
operator|==
name|P_MAGIC
argument_list|)
expr_stmt|;
comment|/* 		 * If the thread is asleep, then we are probably about 		 * to deadlock.  To make debugging this easier, just 		 * panic and tell the user which thread misbehaved so 		 * they can hopefully get a stack trace from the truly 		 * misbehaving thread. 		 */
if|if
condition|(
name|TD_IS_SLEEPING
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Sleeping thread (tid %d, pid %d) owns a non-sleepable lock\n"
argument_list|,
name|td
operator|->
name|td_tid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DDB
name|db_trace_thread
argument_list|(
name|td
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|panic
argument_list|(
literal|"sleeping thread"
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If this thread already has higher priority than the 		 * thread that is being blocked, we are finished. 		 */
if|if
condition|(
name|td
operator|->
name|td_priority
operator|<=
name|pri
condition|)
return|return;
comment|/* 		 * Bump this thread's priority. 		 */
name|sched_lend_prio
argument_list|(
name|td
argument_list|,
name|pri
argument_list|)
expr_stmt|;
comment|/* 		 * If lock holder is actually running or on the run queue 		 * then we are done. 		 */
if|if
condition|(
name|TD_IS_RUNNING
argument_list|(
name|td
argument_list|)
operator|||
name|TD_ON_RUNQ
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|MPASS
argument_list|(
name|td
operator|->
name|td_blocked
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|SMP
comment|/* 		 * For UP, we check to see if td is curthread (this shouldn't 		 * ever happen however as it would mean we are in a deadlock.) 		 */
name|KASSERT
argument_list|(
name|td
operator|!=
name|curthread
argument_list|,
operator|(
literal|"Deadlock detected"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * If we aren't blocked on a lock, we should be. 		 */
name|KASSERT
argument_list|(
name|TD_ON_LOCK
argument_list|(
name|td
argument_list|)
argument_list|,
operator|(
literal|"thread %d(%s):%d holds %s but isn't blocked on a lock\n"
operator|,
name|td
operator|->
name|td_tid
operator|,
name|td
operator|->
name|td_proc
operator|->
name|p_comm
operator|,
name|td
operator|->
name|td_state
operator|,
name|ts
operator|->
name|ts_lockobj
operator|->
name|lo_name
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Pick up the lock that td is blocked on. 		 */
name|ts
operator|=
name|td
operator|->
name|td_blocked
expr_stmt|;
name|MPASS
argument_list|(
name|ts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tc
operator|=
name|TC_LOOKUP
argument_list|(
name|ts
operator|->
name|ts_lockobj
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
comment|/* Resort td on the list if needed. */
if|if
condition|(
operator|!
name|turnstile_adjust_thread
argument_list|(
name|ts
argument_list|,
name|td
argument_list|)
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Adjust the thread's position on a turnstile after its priority has been  * changed.  */
end_comment

begin_function
specifier|static
name|int
name|turnstile_adjust_thread
parameter_list|(
name|struct
name|turnstile
modifier|*
name|ts
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|turnstile_chain
modifier|*
name|tc
decl_stmt|;
name|struct
name|thread
modifier|*
name|td1
decl_stmt|,
modifier|*
name|td2
decl_stmt|;
name|int
name|queue
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|TD_ON_LOCK
argument_list|(
name|td
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * This thread may not be blocked on this turnstile anymore 	 * but instead might already be woken up on another CPU 	 * that is waiting on sched_lock in turnstile_unpend() to 	 * finish waking this thread up.  We can detect this case 	 * by checking to see if this thread has been given a 	 * turnstile by either turnstile_signal() or 	 * turnstile_broadcast().  In this case, treat the thread as 	 * if it was already running. 	 */
if|if
condition|(
name|td
operator|->
name|td_turnstile
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Check if the thread needs to be moved on the blocked chain. 	 * It needs to be moved if either its priority is lower than 	 * the previous thread or higher than the next thread. 	 */
name|tc
operator|=
name|TC_LOOKUP
argument_list|(
name|ts
operator|->
name|ts_lockobj
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|td1
operator|=
name|TAILQ_PREV
argument_list|(
name|td
argument_list|,
name|threadqueue
argument_list|,
name|td_lockq
argument_list|)
expr_stmt|;
name|td2
operator|=
name|TAILQ_NEXT
argument_list|(
name|td
argument_list|,
name|td_lockq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|td1
operator|!=
name|NULL
operator|&&
name|td
operator|->
name|td_priority
operator|<
name|td1
operator|->
name|td_priority
operator|)
operator|||
operator|(
name|td2
operator|!=
name|NULL
operator|&&
name|td
operator|->
name|td_priority
operator|>
name|td2
operator|->
name|td_priority
operator|)
condition|)
block|{
comment|/* 		 * Remove thread from blocked chain and determine where 		 * it should be moved to. 		 */
name|queue
operator|=
name|td
operator|->
name|td_tsqueue
expr_stmt|;
name|MPASS
argument_list|(
name|queue
operator|==
name|TS_EXCLUSIVE_QUEUE
operator|||
name|queue
operator|==
name|TS_SHARED_QUEUE
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|td_contested_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|queue
index|]
argument_list|,
name|td
argument_list|,
name|td_lockq
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|td1
argument_list|,
argument|&ts->ts_blocked[queue]
argument_list|,
argument|td_lockq
argument_list|)
block|{
name|MPASS
argument_list|(
name|td1
operator|->
name|td_proc
operator|->
name|p_magic
operator|==
name|P_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|td1
operator|->
name|td_priority
operator|>
name|td
operator|->
name|td_priority
condition|)
break|break;
block|}
if|if
condition|(
name|td1
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|queue
index|]
argument_list|,
name|td
argument_list|,
name|td_lockq
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_BEFORE
argument_list|(
name|td1
argument_list|,
name|td
argument_list|,
name|td_lockq
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|td_contested_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|td1
operator|==
name|NULL
condition|)
name|CTR3
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"turnstile_adjust_thread: td %d put at tail on [%p] %s"
argument_list|,
name|td
operator|->
name|td_tid
argument_list|,
name|ts
operator|->
name|ts_lockobj
argument_list|,
name|ts
operator|->
name|ts_lockobj
operator|->
name|lo_name
argument_list|)
expr_stmt|;
else|else
name|CTR4
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"turnstile_adjust_thread: td %d moved before %d on [%p] %s"
argument_list|,
name|td
operator|->
name|td_tid
argument_list|,
name|td1
operator|->
name|td_tid
argument_list|,
name|ts
operator|->
name|ts_lockobj
argument_list|,
name|ts
operator|->
name|ts_lockobj
operator|->
name|lo_name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Early initialization of turnstiles.  This is not done via a SYSINIT()  * since this needs to be initialized very early when mutexes are first  * initialized.  */
end_comment

begin_function
name|void
name|init_turnstiles
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TC_TABLESIZE
condition|;
name|i
operator|++
control|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|turnstile_chains
index|[
name|i
index|]
operator|.
name|tc_turnstiles
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|turnstile_chains
index|[
name|i
index|]
operator|.
name|tc_lock
argument_list|,
literal|"turnstile chain"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
block|}
name|mtx_init
argument_list|(
operator|&
name|td_contested_lock
argument_list|,
literal|"td_contested"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|thread0
operator|.
name|td_contested
argument_list|)
expr_stmt|;
name|thread0
operator|.
name|td_turnstile
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TURNSTILE_PROFILING
end_ifdef

begin_function
specifier|static
name|void
name|init_turnstile_profiling
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sysctl_oid
modifier|*
name|chain_oid
decl_stmt|;
name|char
name|chain_name
index|[
literal|10
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TC_TABLESIZE
condition|;
name|i
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|chain_name
argument_list|,
sizeof|sizeof
argument_list|(
name|chain_name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|chain_oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|NULL
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_debug_turnstile_chains
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|chain_name
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"turnstile chain stats"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|NULL
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|chain_oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"depth"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|turnstile_chains
index|[
name|i
index|]
operator|.
name|tc_depth
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_UINT
argument_list|(
name|NULL
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|chain_oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"max_depth"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|turnstile_chains
index|[
name|i
index|]
operator|.
name|tc_max_depth
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|turnstile_profiling
argument_list|,
name|SI_SUB_LOCK
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|init_turnstile_profiling
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|init_turnstile0
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|thread0
operator|.
name|td_turnstile
operator|=
name|turnstile_alloc
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|turnstile0
argument_list|,
name|SI_SUB_LOCK
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|init_turnstile0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Update a thread on the turnstile list after it's priority has been changed.  * The old priority is passed in as an argument.  */
end_comment

begin_function
name|void
name|turnstile_adjust
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|u_char
name|oldpri
parameter_list|)
block|{
name|struct
name|turnstile_chain
modifier|*
name|tc
decl_stmt|;
name|struct
name|turnstile
modifier|*
name|ts
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|TD_ON_LOCK
argument_list|(
name|td
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Pick up the lock that td is blocked on. 	 */
name|ts
operator|=
name|td
operator|->
name|td_blocked
expr_stmt|;
name|MPASS
argument_list|(
name|ts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|tc
operator|=
name|TC_LOOKUP
argument_list|(
name|ts
operator|->
name|ts_lockobj
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
comment|/* Resort the turnstile on the list. */
if|if
condition|(
operator|!
name|turnstile_adjust_thread
argument_list|(
name|ts
argument_list|,
name|td
argument_list|)
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If our priority was lowered and we are at the head of the 	 * turnstile, then propagate our new priority up the chain. 	 * Note that we currently don't try to revoke lent priorities 	 * when our priority goes up. 	 */
name|MPASS
argument_list|(
name|td
operator|->
name|td_tsqueue
operator|==
name|TS_EXCLUSIVE_QUEUE
operator|||
name|td
operator|->
name|td_tsqueue
operator|==
name|TS_SHARED_QUEUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|TAILQ_FIRST
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|td
operator|->
name|td_tsqueue
index|]
argument_list|)
operator|&&
name|td
operator|->
name|td_priority
operator|<
name|oldpri
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
name|propagate_priority
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
else|else
name|mtx_unlock_spin
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the owner of the lock this turnstile is attached to.  */
end_comment

begin_function
specifier|static
name|void
name|turnstile_setowner
parameter_list|(
name|struct
name|turnstile
modifier|*
name|ts
parameter_list|,
name|struct
name|thread
modifier|*
name|owner
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|td_contested_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ts
operator|->
name|ts_owner
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* A shared lock might not have an owner. */
if|if
condition|(
name|owner
operator|==
name|NULL
condition|)
return|return;
name|MPASS
argument_list|(
name|owner
operator|->
name|td_proc
operator|->
name|p_magic
operator|==
name|P_MAGIC
argument_list|)
expr_stmt|;
name|ts
operator|->
name|ts_owner
operator|=
name|owner
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|owner
operator|->
name|td_contested
argument_list|,
name|ts
argument_list|,
name|ts_link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Malloc a turnstile for a new thread, initialize it and return it.  */
end_comment

begin_function
name|struct
name|turnstile
modifier|*
name|turnstile_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|turnstile
modifier|*
name|ts
decl_stmt|;
name|ts
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|turnstile
argument_list|)
argument_list|,
name|M_TURNSTILE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|TS_EXCLUSIVE_QUEUE
index|]
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|TS_SHARED_QUEUE
index|]
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ts
operator|->
name|ts_pending
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ts
operator|->
name|ts_free
argument_list|)
expr_stmt|;
return|return
operator|(
name|ts
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a turnstile when a thread is destroyed.  */
end_comment

begin_function
name|void
name|turnstile_free
parameter_list|(
name|struct
name|turnstile
modifier|*
name|ts
parameter_list|)
block|{
name|MPASS
argument_list|(
name|ts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|TS_EXCLUSIVE_QUEUE
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|TS_SHARED_QUEUE
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ts
operator|->
name|ts_pending
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ts
argument_list|,
name|M_TURNSTILE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lock the turnstile chain associated with the specified lock.  */
end_comment

begin_function
name|void
name|turnstile_lock
parameter_list|(
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|turnstile_chain
modifier|*
name|tc
decl_stmt|;
name|tc
operator|=
name|TC_LOOKUP
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look up the turnstile for a lock in the hash table locking the associated  * turnstile chain along the way.  If no turnstile is found in the hash  * table, NULL is returned.  */
end_comment

begin_function
name|struct
name|turnstile
modifier|*
name|turnstile_lookup
parameter_list|(
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|turnstile_chain
modifier|*
name|tc
decl_stmt|;
name|struct
name|turnstile
modifier|*
name|ts
decl_stmt|;
name|tc
operator|=
name|TC_LOOKUP
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ts
argument_list|,
argument|&tc->tc_turnstiles
argument_list|,
argument|ts_hash
argument_list|)
if|if
condition|(
name|ts
operator|->
name|ts_lockobj
operator|==
name|lock
condition|)
return|return
operator|(
name|ts
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unlock the turnstile chain associated with a given lock.  */
end_comment

begin_function
name|void
name|turnstile_release
parameter_list|(
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|turnstile_chain
modifier|*
name|tc
decl_stmt|;
name|tc
operator|=
name|TC_LOOKUP
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return a pointer to the thread waiting on this turnstile with the  * most important priority or NULL if the turnstile has no waiters.  */
end_comment

begin_function
specifier|static
name|struct
name|thread
modifier|*
name|turnstile_first_waiter
parameter_list|(
name|struct
name|turnstile
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|std
decl_stmt|,
modifier|*
name|xtd
decl_stmt|;
name|std
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|TS_SHARED_QUEUE
index|]
argument_list|)
expr_stmt|;
name|xtd
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|TS_EXCLUSIVE_QUEUE
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|xtd
operator|==
name|NULL
operator|||
operator|(
name|std
operator|!=
name|NULL
operator|&&
name|std
operator|->
name|td_priority
operator|<
name|xtd
operator|->
name|td_priority
operator|)
condition|)
return|return
operator|(
name|std
operator|)
return|;
return|return
operator|(
name|xtd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Take ownership of a turnstile and adjust the priority of the new  * owner appropriately.  */
end_comment

begin_function
name|void
name|turnstile_claim
parameter_list|(
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|turnstile_chain
modifier|*
name|tc
decl_stmt|;
name|struct
name|turnstile
modifier|*
name|ts
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|,
modifier|*
name|owner
decl_stmt|;
name|tc
operator|=
name|TC_LOOKUP
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ts
operator|=
name|turnstile_lookup
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|owner
operator|=
name|curthread
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|td_contested_lock
argument_list|)
expr_stmt|;
name|turnstile_setowner
argument_list|(
name|ts
argument_list|,
name|owner
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|td_contested_lock
argument_list|)
expr_stmt|;
name|td
operator|=
name|turnstile_first_waiter
argument_list|(
name|ts
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|td
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_magic
operator|==
name|P_MAGIC
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Update the priority of the new owner if needed. 	 */
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_priority
operator|<
name|owner
operator|->
name|td_priority
condition|)
name|sched_lend_prio
argument_list|(
name|owner
argument_list|,
name|td
operator|->
name|td_priority
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Block the current thread on the turnstile assicated with 'lock'.  This  * function will context switch and not return until this thread has been  * woken back up.  This function must be called with the appropriate  * turnstile chain locked and will return with it unlocked.  */
end_comment

begin_function
name|void
name|turnstile_wait
parameter_list|(
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|,
name|struct
name|thread
modifier|*
name|owner
parameter_list|,
name|int
name|queue
parameter_list|)
block|{
name|struct
name|turnstile_chain
modifier|*
name|tc
decl_stmt|;
name|struct
name|turnstile
modifier|*
name|ts
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|,
modifier|*
name|td1
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|tc
operator|=
name|TC_LOOKUP
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|td
operator|->
name|td_turnstile
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|queue
operator|==
name|TS_SHARED_QUEUE
condition|)
name|MPASS
argument_list|(
name|owner
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
condition|)
name|MPASS
argument_list|(
name|owner
operator|->
name|td_proc
operator|->
name|p_magic
operator|==
name|P_MAGIC
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|queue
operator|==
name|TS_SHARED_QUEUE
operator|||
name|queue
operator|==
name|TS_EXCLUSIVE_QUEUE
argument_list|)
expr_stmt|;
comment|/* Look up the turnstile associated with the lock 'lock'. */
name|ts
operator|=
name|turnstile_lookup
argument_list|(
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * If the lock does not already have a turnstile, use this thread's 	 * turnstile.  Otherwise insert the current thread into the 	 * turnstile already in use by this lock. 	 */
if|if
condition|(
name|ts
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|TURNSTILE_PROFILING
name|tc
operator|->
name|tc_depth
operator|++
expr_stmt|;
if|if
condition|(
name|tc
operator|->
name|tc_depth
operator|>
name|tc
operator|->
name|tc_max_depth
condition|)
block|{
name|tc
operator|->
name|tc_max_depth
operator|=
name|tc
operator|->
name|tc_depth
expr_stmt|;
if|if
condition|(
name|tc
operator|->
name|tc_max_depth
operator|>
name|turnstile_max_depth
condition|)
name|turnstile_max_depth
operator|=
name|tc
operator|->
name|tc_max_depth
expr_stmt|;
block|}
endif|#
directive|endif
name|ts
operator|=
name|td
operator|->
name|td_turnstile
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|tc
operator|->
name|tc_turnstiles
argument_list|,
name|ts
argument_list|,
name|ts_hash
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ts
operator|->
name|ts_pending
argument_list|)
argument_list|,
operator|(
literal|"thread's turnstile has pending threads"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|TS_EXCLUSIVE_QUEUE
index|]
argument_list|)
argument_list|,
operator|(
literal|"thread's turnstile has exclusive waiters"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|TS_SHARED_QUEUE
index|]
argument_list|)
argument_list|,
operator|(
literal|"thread's turnstile has shared waiters"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|ts
operator|->
name|ts_free
argument_list|)
argument_list|,
operator|(
literal|"thread's turnstile has a non-empty free list"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ts
operator|->
name|ts_lockobj
operator|==
name|NULL
argument_list|,
operator|(
literal|"stale ts_lockobj pointer"
operator|)
argument_list|)
expr_stmt|;
name|ts
operator|->
name|ts_lockobj
operator|=
name|lock
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|td_contested_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|queue
index|]
argument_list|,
name|td
argument_list|,
name|td_lockq
argument_list|)
expr_stmt|;
name|turnstile_setowner
argument_list|(
name|ts
argument_list|,
name|owner
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|td_contested_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_FOREACH
argument_list|(
argument|td1
argument_list|,
argument|&ts->ts_blocked[queue]
argument_list|,
argument|td_lockq
argument_list|)
if|if
condition|(
name|td1
operator|->
name|td_priority
operator|>
name|td
operator|->
name|td_priority
condition|)
break|break;
name|mtx_lock_spin
argument_list|(
operator|&
name|td_contested_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|td1
operator|!=
name|NULL
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|td1
argument_list|,
name|td
argument_list|,
name|td_lockq
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|queue
index|]
argument_list|,
name|td
argument_list|,
name|td_lockq
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|owner
operator|==
name|ts
operator|->
name|ts_owner
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|td_contested_lock
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|td
operator|->
name|td_turnstile
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ts
operator|->
name|ts_free
argument_list|,
name|td
operator|->
name|td_turnstile
argument_list|,
name|ts_hash
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_turnstile
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Handle race condition where a thread on another CPU that owns 	 * lock 'lock' could have woken us in between us dropping the 	 * turnstile chain lock and acquiring the sched_lock. 	 */
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_TSNOBLOCK
condition|)
block|{
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_TSNOBLOCK
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|notyet
comment|/* 	 * If we're borrowing an interrupted thread's VM context, we 	 * must clean up before going to sleep. 	 */
if|if
condition|(
name|td
operator|->
name|td_ithd
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ithd
modifier|*
name|it
init|=
name|td
operator|->
name|td_ithd
decl_stmt|;
if|if
condition|(
name|it
operator|->
name|it_interrupted
condition|)
block|{
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
name|lock
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR3
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: %p interrupted %p"
argument_list|,
name|__func__
argument_list|,
name|it
argument_list|,
name|it
operator|->
name|it_interrupted
argument_list|)
expr_stmt|;
name|intr_thd_fixup
argument_list|(
name|it
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Save who we are blocked on and switch. */
name|td
operator|->
name|td_tsqueue
operator|=
name|queue
expr_stmt|;
name|td
operator|->
name|td_blocked
operator|=
name|ts
expr_stmt|;
name|td
operator|->
name|td_lockname
operator|=
name|lock
operator|->
name|lo_name
expr_stmt|;
name|TD_SET_LOCK
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|propagate_priority
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
name|lock
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR4
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: td %d blocked on [%p] %s"
argument_list|,
name|__func__
argument_list|,
name|td
operator|->
name|td_tid
argument_list|,
name|lock
argument_list|,
name|lock
operator|->
name|lo_name
argument_list|)
expr_stmt|;
name|mi_switch
argument_list|(
name|SW_VOL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|LOCK_LOG_TEST
argument_list|(
name|lock
argument_list|,
literal|0
argument_list|)
condition|)
name|CTR4
argument_list|(
name|KTR_LOCK
argument_list|,
literal|"%s: td %d free from blocked on [%p] %s"
argument_list|,
name|__func__
argument_list|,
name|td
operator|->
name|td_tid
argument_list|,
name|lock
argument_list|,
name|lock
operator|->
name|lo_name
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Pick the highest priority thread on this turnstile and put it on the  * pending list.  This must be called with the turnstile chain locked.  */
end_comment

begin_function
name|int
name|turnstile_signal
parameter_list|(
name|struct
name|turnstile
modifier|*
name|ts
parameter_list|,
name|int
name|queue
parameter_list|)
block|{
name|struct
name|turnstile_chain
modifier|*
name|tc
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|empty
decl_stmt|;
name|MPASS
argument_list|(
name|ts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|curthread
operator|->
name|td_proc
operator|->
name|p_magic
operator|==
name|P_MAGIC
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ts
operator|->
name|ts_owner
operator|==
name|curthread
operator|||
operator|(
name|queue
operator|==
name|TS_EXCLUSIVE_QUEUE
operator|&&
name|ts
operator|->
name|ts_owner
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|tc
operator|=
name|TC_LOOKUP
argument_list|(
name|ts
operator|->
name|ts_lockobj
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|queue
operator|==
name|TS_SHARED_QUEUE
operator|||
name|queue
operator|==
name|TS_EXCLUSIVE_QUEUE
argument_list|)
expr_stmt|;
comment|/* 	 * Pick the highest priority thread blocked on this lock and 	 * move it to the pending list. 	 */
name|td
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|queue
index|]
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_magic
operator|==
name|P_MAGIC
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|td_contested_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|queue
index|]
argument_list|,
name|td
argument_list|,
name|td_lockq
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|td_contested_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ts
operator|->
name|ts_pending
argument_list|,
name|td
argument_list|,
name|td_lockq
argument_list|)
expr_stmt|;
comment|/* 	 * If the turnstile is now empty, remove it from its chain and 	 * give it to the about-to-be-woken thread.  Otherwise take a 	 * turnstile from the free list and give it to the thread. 	 */
name|empty
operator|=
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|TS_EXCLUSIVE_QUEUE
index|]
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|TS_SHARED_QUEUE
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|empty
condition|)
block|{
name|MPASS
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|ts
operator|->
name|ts_free
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TURNSTILE_PROFILING
name|tc
operator|->
name|tc_depth
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|ts
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ts
operator|->
name|ts_free
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|ts
argument_list|,
name|ts_hash
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_turnstile
operator|=
name|ts
expr_stmt|;
return|return
operator|(
name|empty
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Put all blocked threads on the pending list.  This must be called with  * the turnstile chain locked.  */
end_comment

begin_function
name|void
name|turnstile_broadcast
parameter_list|(
name|struct
name|turnstile
modifier|*
name|ts
parameter_list|,
name|int
name|queue
parameter_list|)
block|{
name|struct
name|turnstile_chain
modifier|*
name|tc
decl_stmt|;
name|struct
name|turnstile
modifier|*
name|ts1
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|MPASS
argument_list|(
name|ts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|curthread
operator|->
name|td_proc
operator|->
name|p_magic
operator|==
name|P_MAGIC
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ts
operator|->
name|ts_owner
operator|==
name|curthread
operator|||
operator|(
name|queue
operator|==
name|TS_EXCLUSIVE_QUEUE
operator|&&
name|ts
operator|->
name|ts_owner
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|tc
operator|=
name|TC_LOOKUP
argument_list|(
name|ts
operator|->
name|ts_lockobj
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|queue
operator|==
name|TS_SHARED_QUEUE
operator|||
name|queue
operator|==
name|TS_EXCLUSIVE_QUEUE
argument_list|)
expr_stmt|;
comment|/* 	 * Transfer the blocked list to the pending list. 	 */
name|mtx_lock_spin
argument_list|(
operator|&
name|td_contested_lock
argument_list|)
expr_stmt|;
name|TAILQ_CONCAT
argument_list|(
operator|&
name|ts
operator|->
name|ts_pending
argument_list|,
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|queue
index|]
argument_list|,
name|td_lockq
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|td_contested_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Give a turnstile to each thread.  The last thread gets 	 * this turnstile if the turnstile is empty. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|td
argument_list|,
argument|&ts->ts_pending
argument_list|,
argument|td_lockq
argument_list|)
block|{
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|ts
operator|->
name|ts_free
argument_list|)
condition|)
block|{
name|MPASS
argument_list|(
name|TAILQ_NEXT
argument_list|(
name|td
argument_list|,
name|td_lockq
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ts1
operator|=
name|ts
expr_stmt|;
ifdef|#
directive|ifdef
name|TURNSTILE_PROFILING
name|tc
operator|->
name|tc_depth
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|ts1
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ts
operator|->
name|ts_free
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ts1
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|ts1
argument_list|,
name|ts_hash
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_turnstile
operator|=
name|ts1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Wakeup all threads on the pending list and adjust the priority of the  * current thread appropriately.  This must be called with the turnstile  * chain locked.  */
end_comment

begin_function
name|void
name|turnstile_unpend
parameter_list|(
name|struct
name|turnstile
modifier|*
name|ts
parameter_list|,
name|int
name|owner_type
parameter_list|)
block|{
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|thread
argument_list|)
name|pending_threads
expr_stmt|;
name|struct
name|turnstile_chain
modifier|*
name|tc
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|u_char
name|cp
decl_stmt|,
name|pri
decl_stmt|;
name|MPASS
argument_list|(
name|ts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ts
operator|->
name|ts_owner
operator|==
name|curthread
operator|||
operator|(
name|owner_type
operator|==
name|TS_SHARED_LOCK
operator|&&
name|ts
operator|->
name|ts_owner
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|tc
operator|=
name|TC_LOOKUP
argument_list|(
name|ts
operator|->
name|ts_lockobj
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ts
operator|->
name|ts_pending
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Move the list of pending threads out of the turnstile and 	 * into a local variable. 	 */
name|TAILQ_INIT
argument_list|(
operator|&
name|pending_threads
argument_list|)
expr_stmt|;
name|TAILQ_CONCAT
argument_list|(
operator|&
name|pending_threads
argument_list|,
operator|&
name|ts
operator|->
name|ts_pending
argument_list|,
name|td_lockq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|TS_EXCLUSIVE_QUEUE
index|]
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|TS_SHARED_QUEUE
index|]
argument_list|)
condition|)
name|ts
operator|->
name|ts_lockobj
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Remove the turnstile from this thread's list of contested locks 	 * since this thread doesn't own it anymore.  New threads will 	 * not be blocking on the turnstile until it is claimed by a new 	 * owner.  There might not be a current owner if this is a shared 	 * lock. 	 */
if|if
condition|(
name|ts
operator|->
name|ts_owner
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|td_contested_lock
argument_list|)
expr_stmt|;
name|ts
operator|->
name|ts_owner
operator|=
name|NULL
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|ts
argument_list|,
name|ts_link
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|td_contested_lock
argument_list|)
expr_stmt|;
block|}
name|critical_enter
argument_list|()
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Adjust the priority of curthread based on other contested 	 * locks it owns.  Don't lower the priority below the base 	 * priority however. 	 */
name|td
operator|=
name|curthread
expr_stmt|;
name|pri
operator|=
name|PRI_MAX
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|td_contested_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ts
argument_list|,
argument|&td->td_contested
argument_list|,
argument|ts_link
argument_list|)
block|{
name|cp
operator|=
name|turnstile_first_waiter
argument_list|(
name|ts
argument_list|)
operator|->
name|td_priority
expr_stmt|;
if|if
condition|(
name|cp
operator|<
name|pri
condition|)
name|pri
operator|=
name|cp
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|td_contested_lock
argument_list|)
expr_stmt|;
name|sched_unlend_prio
argument_list|(
name|td
argument_list|,
name|pri
argument_list|)
expr_stmt|;
comment|/* 	 * Wake up all the pending threads.  If a thread is not blocked 	 * on a lock, then it is currently executing on another CPU in 	 * turnstile_wait() or sitting on a run queue waiting to resume 	 * in turnstile_wait().  Set a flag to force it to try to acquire 	 * the lock again instead of blocking. 	 */
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|pending_threads
argument_list|)
condition|)
block|{
name|td
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pending_threads
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pending_threads
argument_list|,
name|td
argument_list|,
name|td_lockq
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_magic
operator|==
name|P_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|TD_ON_LOCK
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|td
operator|->
name|td_blocked
operator|=
name|NULL
expr_stmt|;
name|td
operator|->
name|td_lockname
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|td
operator|->
name|td_tsqueue
operator|=
literal|0xff
expr_stmt|;
endif|#
directive|endif
name|TD_CLR_LOCK
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|TD_CAN_RUN
argument_list|(
name|td
argument_list|)
argument_list|)
expr_stmt|;
name|setrunqueue
argument_list|(
name|td
argument_list|,
name|SRQ_BORING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|td_flags
operator||=
name|TDF_TSNOBLOCK
expr_stmt|;
name|MPASS
argument_list|(
name|TD_IS_RUNNING
argument_list|(
name|td
argument_list|)
operator|||
name|TD_ON_RUNQ
argument_list|(
name|td
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|critical_exit
argument_list|()
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Give up ownership of a turnstile.  This must be called with the  * turnstile chain locked.  */
end_comment

begin_function
name|void
name|turnstile_disown
parameter_list|(
name|struct
name|turnstile
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|turnstile_chain
modifier|*
name|tc
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|u_char
name|cp
decl_stmt|,
name|pri
decl_stmt|;
name|MPASS
argument_list|(
name|ts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ts
operator|->
name|ts_owner
operator|==
name|curthread
argument_list|)
expr_stmt|;
name|tc
operator|=
name|TC_LOOKUP
argument_list|(
name|ts
operator|->
name|ts_lockobj
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ts
operator|->
name|ts_pending
argument_list|)
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|TS_EXCLUSIVE_QUEUE
index|]
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|TS_SHARED_QUEUE
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Remove the turnstile from this thread's list of contested locks 	 * since this thread doesn't own it anymore.  New threads will 	 * not be blocking on the turnstile until it is claimed by a new 	 * owner. 	 */
name|mtx_lock_spin
argument_list|(
operator|&
name|td_contested_lock
argument_list|)
expr_stmt|;
name|ts
operator|->
name|ts_owner
operator|=
name|NULL
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|ts
argument_list|,
name|ts_link
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|td_contested_lock
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Adjust the priority of curthread based on other contested 	 * locks it owns.  Don't lower the priority below the base 	 * priority however. 	 */
name|td
operator|=
name|curthread
expr_stmt|;
name|pri
operator|=
name|PRI_MAX
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|td_contested_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ts
argument_list|,
argument|&td->td_contested
argument_list|,
argument|ts_link
argument_list|)
block|{
name|cp
operator|=
name|turnstile_first_waiter
argument_list|(
name|ts
argument_list|)
operator|->
name|td_priority
expr_stmt|;
if|if
condition|(
name|cp
operator|<
name|pri
condition|)
name|pri
operator|=
name|cp
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|td_contested_lock
argument_list|)
expr_stmt|;
name|sched_unlend_prio
argument_list|(
name|td
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the first thread in a turnstile.  */
end_comment

begin_function
name|struct
name|thread
modifier|*
name|turnstile_head
parameter_list|(
name|struct
name|turnstile
modifier|*
name|ts
parameter_list|,
name|int
name|queue
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|turnstile_chain
modifier|*
name|tc
decl_stmt|;
name|MPASS
argument_list|(
name|ts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|queue
operator|==
name|TS_SHARED_QUEUE
operator|||
name|queue
operator|==
name|TS_EXCLUSIVE_QUEUE
argument_list|)
expr_stmt|;
name|tc
operator|=
name|TC_LOOKUP
argument_list|(
name|ts
operator|->
name|ts_lockobj
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|queue
index|]
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if a sub-queue of a turnstile is empty.  */
end_comment

begin_function
name|int
name|turnstile_empty
parameter_list|(
name|struct
name|turnstile
modifier|*
name|ts
parameter_list|,
name|int
name|queue
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|turnstile_chain
modifier|*
name|tc
decl_stmt|;
name|MPASS
argument_list|(
name|ts
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|queue
operator|==
name|TS_SHARED_QUEUE
operator|||
name|queue
operator|==
name|TS_EXCLUSIVE_QUEUE
argument_list|)
expr_stmt|;
name|tc
operator|=
name|TC_LOOKUP
argument_list|(
name|ts
operator|->
name|ts_lockobj
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|queue
index|]
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_function
specifier|static
name|void
name|print_thread
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|db_printf
argument_list|(
literal|"%s%p (tid %d, pid %d, \"%s\")\n"
argument_list|,
name|prefix
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_tid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|?
name|td
operator|->
name|td_name
else|:
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_queue
parameter_list|(
name|struct
name|threadqueue
modifier|*
name|queue
parameter_list|,
specifier|const
name|char
modifier|*
name|header
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|db_printf
argument_list|(
literal|"%s:\n"
argument_list|,
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
name|queue
argument_list|)
condition|)
block|{
name|db_printf
argument_list|(
literal|"%sempty\n"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
return|return;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|td
argument_list|,
argument|queue
argument_list|,
argument|td_lockq
argument_list|)
block|{
name|print_thread
argument_list|(
name|td
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|turnstile
argument_list|,
argument|db_show_turnstile
argument_list|)
end_macro

begin_block
block|{
name|struct
name|turnstile_chain
modifier|*
name|tc
decl_stmt|;
name|struct
name|turnstile
modifier|*
name|ts
decl_stmt|;
name|struct
name|lock_object
modifier|*
name|lock
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|have_addr
condition|)
return|return;
comment|/* 	 * First, see if there is an active turnstile for the lock indicated 	 * by the address. 	 */
name|lock
operator|=
operator|(
expr|struct
name|lock_object
operator|*
operator|)
name|addr
expr_stmt|;
name|tc
operator|=
name|TC_LOOKUP
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ts
argument_list|,
argument|&tc->tc_turnstiles
argument_list|,
argument|ts_hash
argument_list|)
if|if
condition|(
name|ts
operator|->
name|ts_lockobj
operator|==
name|lock
condition|)
goto|goto
name|found
goto|;
comment|/* 	 * Second, see if there is an active turnstile at the address 	 * indicated. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TC_TABLESIZE
condition|;
name|i
operator|++
control|)
name|LIST_FOREACH
argument_list|(
argument|ts
argument_list|,
argument|&turnstile_chains[i].tc_turnstiles
argument_list|,
argument|ts_hash
argument_list|)
block|{
if|if
condition|(
name|ts
operator|==
operator|(
expr|struct
name|turnstile
operator|*
operator|)
name|addr
condition|)
goto|goto
name|found
goto|;
block|}
name|db_printf
argument_list|(
literal|"Unable to locate a turnstile via %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
return|return;
name|found
label|:
name|lock
operator|=
name|ts
operator|->
name|ts_lockobj
expr_stmt|;
name|db_printf
argument_list|(
literal|"Lock: %p - (%s) %s\n"
argument_list|,
name|lock
argument_list|,
name|LOCK_CLASS
argument_list|(
name|lock
argument_list|)
operator|->
name|lc_name
argument_list|,
name|lock
operator|->
name|lo_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_owner
condition|)
name|print_thread
argument_list|(
name|ts
operator|->
name|ts_owner
argument_list|,
literal|"Lock Owner: "
argument_list|)
expr_stmt|;
else|else
name|db_printf
argument_list|(
literal|"Lock Owner: none\n"
argument_list|)
expr_stmt|;
name|print_queue
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|TS_SHARED_QUEUE
index|]
argument_list|,
literal|"Shared Waiters"
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|print_queue
argument_list|(
operator|&
name|ts
operator|->
name|ts_blocked
index|[
name|TS_EXCLUSIVE_QUEUE
index|]
argument_list|,
literal|"Exclusive Waiters"
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
name|print_queue
argument_list|(
operator|&
name|ts
operator|->
name|ts_pending
argument_list|,
literal|"Pending Threads"
argument_list|,
literal|"\t"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Show all the threads a particular thread is waiting on based on  * non-sleepable and non-spin locks.  */
end_comment

begin_function
specifier|static
name|void
name|print_lockchain
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|lock_object
modifier|*
name|lock
decl_stmt|;
name|struct
name|lock_class
modifier|*
name|class
decl_stmt|;
name|struct
name|turnstile
modifier|*
name|ts
decl_stmt|;
comment|/* 	 * Follow the chain.  We keep walking as long as the thread is 	 * blocked on a turnstile that has an owner. 	 */
while|while
condition|(
operator|!
name|db_pager_quit
condition|)
block|{
name|db_printf
argument_list|(
literal|"%sthread %d (pid %d, %s) "
argument_list|,
name|prefix
argument_list|,
name|td
operator|->
name|td_tid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|?
name|td
operator|->
name|td_name
else|:
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|td
operator|->
name|td_state
condition|)
block|{
case|case
name|TDS_INACTIVE
case|:
name|db_printf
argument_list|(
literal|"is inactive\n"
argument_list|)
expr_stmt|;
return|return;
case|case
name|TDS_CAN_RUN
case|:
name|db_printf
argument_list|(
literal|"can run\n"
argument_list|)
expr_stmt|;
return|return;
case|case
name|TDS_RUNQ
case|:
name|db_printf
argument_list|(
literal|"is on a run queue\n"
argument_list|)
expr_stmt|;
return|return;
case|case
name|TDS_RUNNING
case|:
name|db_printf
argument_list|(
literal|"running on CPU %d\n"
argument_list|,
name|td
operator|->
name|td_oncpu
argument_list|)
expr_stmt|;
return|return;
case|case
name|TDS_INHIBITED
case|:
if|if
condition|(
name|TD_ON_LOCK
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|ts
operator|=
name|td
operator|->
name|td_blocked
expr_stmt|;
name|lock
operator|=
name|ts
operator|->
name|ts_lockobj
expr_stmt|;
name|class
operator|=
name|LOCK_CLASS
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"blocked on lock %p (%s) \"%s\"\n"
argument_list|,
name|lock
argument_list|,
name|class
operator|->
name|lc_name
argument_list|,
name|lock
operator|->
name|lo_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|ts_owner
operator|==
name|NULL
condition|)
return|return;
name|td
operator|=
name|ts
operator|->
name|ts_owner
expr_stmt|;
break|break;
block|}
name|db_printf
argument_list|(
literal|"inhibited\n"
argument_list|)
expr_stmt|;
return|return;
default|default:
name|db_printf
argument_list|(
literal|"??? (%#x)\n"
argument_list|,
name|td
operator|->
name|td_state
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|lockchain
argument_list|,
argument|db_show_lockchain
argument_list|)
end_macro

begin_block
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
comment|/* Figure out which thread to start with. */
if|if
condition|(
name|have_addr
condition|)
name|td
operator|=
name|db_lookup_thread
argument_list|(
name|addr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|td
operator|=
name|kdb_thread
expr_stmt|;
name|print_lockchain
argument_list|(
name|td
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|allchains
argument_list|,
argument|db_show_allchains
argument_list|)
end_macro

begin_block
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&allproc
argument_list|,
argument|p_list
argument_list|)
block|{
name|FOREACH_THREAD_IN_PROC
argument_list|(
argument|p
argument_list|,
argument|td
argument_list|)
block|{
if|if
condition|(
name|TD_ON_LOCK
argument_list|(
name|td
argument_list|)
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|td
operator|->
name|td_contested
argument_list|)
condition|)
block|{
name|db_printf
argument_list|(
literal|"chain %d:\n"
argument_list|,
name|i
operator|++
argument_list|)
expr_stmt|;
name|print_lockchain
argument_list|(
name|td
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|db_pager_quit
condition|)
return|return;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Show all the threads a particular thread is waiting on based on  * sleepable locks.  */
end_comment

begin_function
specifier|static
name|void
name|print_sleepchain
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|owner
decl_stmt|;
comment|/* 	 * Follow the chain.  We keep walking as long as the thread is 	 * blocked on a sleep lock that has an owner. 	 */
while|while
condition|(
operator|!
name|db_pager_quit
condition|)
block|{
name|db_printf
argument_list|(
literal|"%sthread %d (pid %d, %s) "
argument_list|,
name|prefix
argument_list|,
name|td
operator|->
name|td_tid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|?
name|td
operator|->
name|td_name
else|:
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|td
operator|->
name|td_state
condition|)
block|{
case|case
name|TDS_INACTIVE
case|:
name|db_printf
argument_list|(
literal|"is inactive\n"
argument_list|)
expr_stmt|;
return|return;
case|case
name|TDS_CAN_RUN
case|:
name|db_printf
argument_list|(
literal|"can run\n"
argument_list|)
expr_stmt|;
return|return;
case|case
name|TDS_RUNQ
case|:
name|db_printf
argument_list|(
literal|"is on a run queue\n"
argument_list|)
expr_stmt|;
return|return;
case|case
name|TDS_RUNNING
case|:
name|db_printf
argument_list|(
literal|"running on CPU %d\n"
argument_list|,
name|td
operator|->
name|td_oncpu
argument_list|)
expr_stmt|;
return|return;
case|case
name|TDS_INHIBITED
case|:
if|if
condition|(
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
condition|)
block|{
if|if
condition|(
name|lockmgr_chain
argument_list|(
name|td
argument_list|,
operator|&
name|owner
argument_list|)
operator|||
name|sx_chain
argument_list|(
name|td
argument_list|,
operator|&
name|owner
argument_list|)
condition|)
block|{
if|if
condition|(
name|owner
operator|==
name|NULL
condition|)
return|return;
name|td
operator|=
name|owner
expr_stmt|;
break|break;
block|}
name|db_printf
argument_list|(
literal|"sleeping on %p \"%s\"\n"
argument_list|,
name|td
operator|->
name|td_wchan
argument_list|,
name|td
operator|->
name|td_wmesg
argument_list|)
expr_stmt|;
return|return;
block|}
name|db_printf
argument_list|(
literal|"inhibited\n"
argument_list|)
expr_stmt|;
return|return;
default|default:
name|db_printf
argument_list|(
literal|"??? (%#x)\n"
argument_list|,
name|td
operator|->
name|td_state
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|sleepchain
argument_list|,
argument|db_show_sleepchain
argument_list|)
end_macro

begin_block
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
comment|/* Figure out which thread to start with. */
if|if
condition|(
name|have_addr
condition|)
name|td
operator|=
name|db_lookup_thread
argument_list|(
name|addr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|td
operator|=
name|kdb_thread
expr_stmt|;
name|print_sleepchain
argument_list|(
name|td
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_function_decl
specifier|static
name|void
name|print_waiters
parameter_list|(
name|struct
name|turnstile
modifier|*
name|ts
parameter_list|,
name|int
name|indent
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|print_waiter
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|struct
name|turnstile
modifier|*
name|ts
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|db_pager_quit
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indent
condition|;
name|i
operator|++
control|)
name|db_printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|print_thread
argument_list|(
name|td
argument_list|,
literal|"thread "
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ts
argument_list|,
argument|&td->td_contested
argument_list|,
argument|ts_link
argument_list|)
name|print_waiters
argument_list|(
name|ts
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_waiters
parameter_list|(
name|struct
name|turnstile
modifier|*
name|ts
parameter_list|,
name|int
name|indent
parameter_list|)
block|{
name|struct
name|lock_object
modifier|*
name|lock
decl_stmt|;
name|struct
name|lock_class
modifier|*
name|class
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|db_pager_quit
condition|)
return|return;
name|lock
operator|=
name|ts
operator|->
name|ts_lockobj
expr_stmt|;
name|class
operator|=
name|LOCK_CLASS
argument_list|(
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indent
condition|;
name|i
operator|++
control|)
name|db_printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"lock %p (%s) \"%s\"\n"
argument_list|,
name|lock
argument_list|,
name|class
operator|->
name|lc_name
argument_list|,
name|lock
operator|->
name|lo_name
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|td
argument_list|,
argument|&ts->ts_blocked[TS_EXCLUSIVE_QUEUE]
argument_list|,
argument|td_lockq
argument_list|)
name|print_waiter
argument_list|(
name|td
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|td
argument_list|,
argument|&ts->ts_blocked[TS_SHARED_QUEUE]
argument_list|,
argument|td_lockq
argument_list|)
name|print_waiter
argument_list|(
name|td
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|td
argument_list|,
argument|&ts->ts_pending
argument_list|,
argument|td_lockq
argument_list|)
name|print_waiter
argument_list|(
name|td
argument_list|,
name|indent
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|locktree
argument_list|,
argument|db_show_locktree
argument_list|)
end_macro

begin_block
block|{
name|struct
name|lock_object
modifier|*
name|lock
decl_stmt|;
name|struct
name|lock_class
modifier|*
name|class
decl_stmt|;
name|struct
name|turnstile_chain
modifier|*
name|tc
decl_stmt|;
name|struct
name|turnstile
modifier|*
name|ts
decl_stmt|;
if|if
condition|(
operator|!
name|have_addr
condition|)
return|return;
name|lock
operator|=
operator|(
expr|struct
name|lock_object
operator|*
operator|)
name|addr
expr_stmt|;
name|tc
operator|=
name|TC_LOOKUP
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ts
argument_list|,
argument|&tc->tc_turnstiles
argument_list|,
argument|ts_hash
argument_list|)
if|if
condition|(
name|ts
operator|->
name|ts_lockobj
operator|==
name|lock
condition|)
break|break;
if|if
condition|(
name|ts
operator|==
name|NULL
condition|)
block|{
name|class
operator|=
name|LOCK_CLASS
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"lock %p (%s) \"%s\"\n"
argument_list|,
name|lock
argument_list|,
name|class
operator|->
name|lc_name
argument_list|,
name|lock
operator|->
name|lo_name
argument_list|)
expr_stmt|;
block|}
else|else
name|print_waiters
argument_list|(
name|ts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

