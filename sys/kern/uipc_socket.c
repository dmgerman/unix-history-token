begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1988, 1990, 1993  *	The Regents of the University of California.  * Copyright (c) 2004 The FreeBSD Foundation  * Copyright (c) 2004-2008 Robert N. M. Watson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)uipc_socket.c	8.3 (Berkeley) 4/15/94  */
end_comment

begin_comment
comment|/*  * Comments on the socket life cycle:  *  * soalloc() sets of socket layer state for a socket, called only by  * socreate() and sonewconn().  Socket layer private.  *  * sodealloc() tears down socket layer state for a socket, called only by  * sofree() and sonewconn().  Socket layer private.  *  * pru_attach() associates protocol layer state with an allocated socket;  * called only once, may fail, aborting socket allocation.  This is called  * from socreate() and sonewconn().  Socket layer private.  *  * pru_detach() disassociates protocol layer state from an attached socket,  * and will be called exactly once for sockets in which pru_attach() has  * been successfully called.  If pru_attach() returned an error,  * pru_detach() will not be called.  Socket layer private.  *  * pru_abort() and pru_close() notify the protocol layer that the last  * consumer of a socket is starting to tear down the socket, and that the  * protocol should terminate the connection.  Historically, pru_abort() also  * detached protocol state from the socket state, but this is no longer the  * case.  *  * socreate() creates a socket and attaches protocol state.  This is a public  * interface that may be used by socket layer consumers to create new  * sockets.  *  * sonewconn() creates a socket and attaches protocol state.  This is a  * public interface  that may be used by protocols to create new sockets when  * a new connection is received and will be available for accept() on a  * listen socket.  *  * soclose() destroys a socket after possibly waiting for it to disconnect.  * This is a public interface that socket consumers should use to close and  * release a socket when done with it.  *  * soabort() destroys a socket without waiting for it to disconnect (used  * only for incoming connections that are already partially or fully  * connected).  This is used internally by the socket layer when clearing  * listen socket queues (due to overflow or close on the listen socket), but  * is also a public interface protocols may use to abort connections in  * their incomplete listen queues should they no longer be required.  Sockets  * placed in completed connection listen queues should not be aborted for  * reasons described in the comment above the soclose() implementation.  This  * is not a general purpose close routine, and except in the specific  * circumstances described here, should not be used.  *  * sofree() will free a socket and its protocol state if all references on  * the socket have been released, and is the public interface to attempt to  * free a socket when a reference is removed.  This is a socket layer private  * interface.  *  * NOTE: In addition to socreate() and soclose(), which provide a single  * socket reference to the consumer to be managed as required, there are two  * calls to explicitly manage socket references, soref(), and sorele().  * Currently, these are generally required only when transitioning a socket  * from a listen queue to a file descriptor, in order to prevent garbage  * collection of the socket at an untimely moment.  For a number of reasons,  * these interfaces are not preferred, and should be avoided.  *  * NOTE: With regard to VNETs the general rule is that callers do not set  * curvnet. Exceptions to this rule include soabort(), sodisconnect(),  * sofree() (and with that sorele(), sotryfree()), as well as sonewconn()  * and sorflush(), which are usually called from a pre-set VNET context.  * sopoll() currently does not need a VNET context to be set.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_sctp.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mac.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_comment
comment|/* for struct knote */
end_comment

begin_include
include|#
directive|include
file|<sys/hhook.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/khelp.h>
end_include

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
end_ifdef

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<compat/freebsd32/freebsd32.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|soreceive_rcvoob
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|so_rdknl_lock
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|so_rdknl_unlock
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|so_rdknl_assert_locked
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|so_rdknl_assert_unlocked
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|so_wrknl_lock
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|so_wrknl_unlock
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|so_wrknl_assert_locked
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|so_wrknl_assert_unlocked
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filt_sordetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_soread
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filt_sowdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_sowrite
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_soempty
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
specifier|inline
name|hhook_run_socket
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|void
modifier|*
name|hctx
parameter_list|,
name|int32_t
name|h_id
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|fo_kqfilter_t
name|soo_kqfilter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|soread_filtops
init|=
block|{
operator|.
name|f_isfd
operator|=
literal|1
block|,
operator|.
name|f_detach
operator|=
name|filt_sordetach
block|,
operator|.
name|f_event
operator|=
name|filt_soread
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|sowrite_filtops
init|=
block|{
operator|.
name|f_isfd
operator|=
literal|1
block|,
operator|.
name|f_detach
operator|=
name|filt_sowdetach
block|,
operator|.
name|f_event
operator|=
name|filt_sowrite
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|soempty_filtops
init|=
block|{
operator|.
name|f_isfd
operator|=
literal|1
block|,
operator|.
name|f_detach
operator|=
name|filt_sowdetach
block|,
operator|.
name|f_event
operator|=
name|filt_soempty
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|so_gen_t
name|so_gencnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* generation count for sockets */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_SONAME
argument_list|,
literal|"soname"
argument_list|,
literal|"socket name"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_PCB
argument_list|,
literal|"pcb"
argument_list|,
literal|"protocol control block"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|VNET_SO_ASSERT
parameter_list|(
name|so
parameter_list|)
define|\
value|VNET_ASSERT(curvnet != NULL,					\ 	    ("%s:%d curvnet is NULL, so=%p", __func__, __LINE__, (so)));
end_define

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|hhook_head
operator|*
argument_list|,
name|socket_hhh
index|[
name|HHOOK_SOCKET_LAST
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_socket_hhh
value|VNET(socket_hhh)
end_define

begin_comment
comment|/*  * Limit on the number of connections in the listen queue waiting  * for accept(2).  * NB: The original sysctl somaxconn is still available but hidden  * to prevent confusion about the actual purpose of this number.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|somaxconn
init|=
name|SOMAXCONN
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sysctl_somaxconn
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|val
decl_stmt|;
name|val
operator|=
name|somaxconn
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * The purpose of the UINT_MAX / 3 limit, is so that the formula 	 *   3 * so_qlimit / 2 	 * below, will not overflow.          */
if|if
condition|(
name|val
operator|<
literal|1
operator|||
name|val
operator|>
name|UINT_MAX
operator|/
literal|3
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|somaxconn
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|soacceptqueue
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|sysctl_somaxconn
argument_list|,
literal|"I"
argument_list|,
literal|"Maximum listen socket pending connection accept queue size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_ipc
argument_list|,
name|KIPC_SOMAXCONN
argument_list|,
name|somaxconn
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_SKIP
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|sysctl_somaxconn
argument_list|,
literal|"I"
argument_list|,
literal|"Maximum listen socket pending connection accept queue size (compat)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|numopensockets
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|numopensockets
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|numopensockets
argument_list|,
literal|0
argument_list|,
literal|"Number of open sockets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * accept_mtx locks down per-socket fields relating to accept queues.  See  * socketvar.h for an annotation of the protected fields of struct socket.  */
end_comment

begin_decl_stmt
name|struct
name|mtx
name|accept_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|accept_mtx
argument_list|,
operator|&
name|accept_mtx
argument_list|,
literal|"accept"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * so_global_mtx protects so_gencnt, numopensockets, and the per-socket  * so_gencnt field.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|so_global_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|so_global_mtx
argument_list|,
operator|&
name|so_global_mtx
argument_list|,
literal|"so_glabel"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * General IPC sysctl name space, used by sockets and a variety of other IPC  * types.  */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|KERN_IPC
argument_list|,
name|ipc
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"IPC"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Initialize the socket subsystem and set up the socket  * memory allocator.  */
end_comment

begin_decl_stmt
specifier|static
name|uma_zone_t
name|socket_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|maxsockets
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|socket_zone_change
parameter_list|(
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|maxsockets
operator|=
name|uma_zone_set_max
argument_list|(
name|socket_zone
argument_list|,
name|maxsockets
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|socket_hhook_register
parameter_list|(
name|int
name|subtype
parameter_list|)
block|{
if|if
condition|(
name|hhook_head_register
argument_list|(
name|HHOOK_TYPE_SOCKET
argument_list|,
name|subtype
argument_list|,
operator|&
name|V_socket_hhh
index|[
name|subtype
index|]
argument_list|,
name|HHOOK_NOWAIT
operator||
name|HHOOK_HEADISINVNET
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: WARNING: unable to register hook\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|socket_hhook_deregister
parameter_list|(
name|int
name|subtype
parameter_list|)
block|{
if|if
condition|(
name|hhook_head_deregister
argument_list|(
name|V_socket_hhh
index|[
name|subtype
index|]
argument_list|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: WARNING: unable to deregister hook\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|socket_init
parameter_list|(
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|socket_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"socket"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|socket
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
name|maxsockets
operator|=
name|uma_zone_set_max
argument_list|(
name|socket_zone
argument_list|,
name|maxsockets
argument_list|)
expr_stmt|;
name|uma_zone_set_warning
argument_list|(
name|socket_zone
argument_list|,
literal|"kern.ipc.maxsockets limit reached"
argument_list|)
expr_stmt|;
name|EVENTHANDLER_REGISTER
argument_list|(
name|maxsockets_change
argument_list|,
name|socket_zone_change
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|socket
argument_list|,
name|SI_SUB_PROTO_DOMAININIT
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|socket_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|socket_vnet_init
parameter_list|(
specifier|const
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* We expect a contiguous range */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|HHOOK_SOCKET_LAST
condition|;
name|i
operator|++
control|)
name|socket_hhook_register
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|VNET_SYSINIT
argument_list|(
name|socket_vnet_init
argument_list|,
name|SI_SUB_PROTO_DOMAININIT
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|socket_vnet_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|socket_vnet_uninit
parameter_list|(
specifier|const
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|HHOOK_SOCKET_LAST
condition|;
name|i
operator|++
control|)
name|socket_hhook_deregister
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|VNET_SYSUNINIT
argument_list|(
name|socket_vnet_uninit
argument_list|,
name|SI_SUB_PROTO_DOMAININIT
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|socket_vnet_uninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Initialise maxsockets.  This SYSINIT must be run after  * tunable_mbinit().  */
end_comment

begin_function
specifier|static
name|void
name|init_maxsockets
parameter_list|(
name|void
modifier|*
name|ignored
parameter_list|)
block|{
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.maxsockets"
argument_list|,
operator|&
name|maxsockets
argument_list|)
expr_stmt|;
name|maxsockets
operator|=
name|imax
argument_list|(
name|maxsockets
argument_list|,
name|maxfiles
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|param
argument_list|,
name|SI_SUB_TUNABLES
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|init_maxsockets
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Sysctl to get and set the maximum global sockets limit.  Notify protocols  * of the change so that they can update their dependent limits as required.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_maxsockets
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|newmaxsockets
decl_stmt|;
name|newmaxsockets
operator|=
name|maxsockets
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|newmaxsockets
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
condition|)
block|{
if|if
condition|(
name|newmaxsockets
operator|>
name|maxsockets
operator|&&
name|newmaxsockets
operator|<=
name|maxfiles
condition|)
block|{
name|maxsockets
operator|=
name|newmaxsockets
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|maxsockets_change
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|maxsockets
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|maxsockets
argument_list|,
literal|0
argument_list|,
name|sysctl_maxsockets
argument_list|,
literal|"IU"
argument_list|,
literal|"Maximum number of sockets available"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Socket operation routines.  These routines are called by the routines in  * sys_socket.c or from a system process, and implement the semantics of  * socket operations by switching out to the protocol specific routines.  */
end_comment

begin_comment
comment|/*  * Get a socket structure from our zone, and initialize it.  Note that it  * would probably be better to allocate socket and PCB at the same time, but  * I'm not convinced that all the protocols can be easily modified to do  * this.  *  * soalloc() returns a socket with a ref count of 0.  */
end_comment

begin_function
specifier|static
name|struct
name|socket
modifier|*
name|soalloc
parameter_list|(
name|struct
name|vnet
modifier|*
name|vnet
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|uma_zalloc
argument_list|(
name|socket_zone
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
name|mac_socket_init
argument_list|(
name|so
argument_list|,
name|M_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|uma_zfree
argument_list|(
name|socket_zone
argument_list|,
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|khelp_init_osd
argument_list|(
name|HELPER_CLASS_SOCKET
argument_list|,
operator|&
name|so
operator|->
name|osd
argument_list|)
condition|)
block|{
name|uma_zfree
argument_list|(
name|socket_zone
argument_list|,
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * The socket locking protocol allows to lock 2 sockets at a time, 	 * however, the first one must be a listening socket.  WITNESS lacks 	 * a feature to change class of an existing lock, so we use DUPOK. 	 */
name|mtx_init
argument_list|(
operator|&
name|so
operator|->
name|so_lock
argument_list|,
literal|"socket"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_DUPOK
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK_INIT
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
literal|"so_snd"
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK_INIT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
literal|"so_rcv"
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_sel
operator|=
operator|&
name|so
operator|->
name|so_rdsel
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_sel
operator|=
operator|&
name|so
operator|->
name|so_wrsel
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|so
operator|->
name|so_snd
operator|.
name|sb_sx
argument_list|,
literal|"so_snd_sx"
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
operator|.
name|sb_sx
argument_list|,
literal|"so_rcv_sx"
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|so
operator|->
name|so_snd
operator|.
name|sb_aiojobq
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
operator|.
name|sb_aiojobq
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|so
operator|->
name|so_snd
operator|.
name|sb_aiotask
argument_list|,
literal|0
argument_list|,
name|soaio_snd
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
operator|.
name|sb_aiotask
argument_list|,
literal|0
argument_list|,
name|soaio_rcv
argument_list|,
name|so
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VIMAGE
name|VNET_ASSERT
argument_list|(
name|vnet
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s:%d vnet is NULL, so=%p"
operator|,
name|__func__
operator|,
name|__LINE__
operator|,
name|so
operator|)
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_vnet
operator|=
name|vnet
expr_stmt|;
endif|#
directive|endif
comment|/* We shouldn't need the so_global_mtx */
if|if
condition|(
name|hhook_run_socket
argument_list|(
name|so
argument_list|,
name|NULL
argument_list|,
name|HHOOK_SOCKET_CREATE
argument_list|)
condition|)
block|{
comment|/* Do we need more comprehensive error returns? */
name|uma_zfree
argument_list|(
name|socket_zone
argument_list|,
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|so_global_mtx
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_gencnt
operator|=
operator|++
name|so_gencnt
expr_stmt|;
operator|++
name|numopensockets
expr_stmt|;
ifdef|#
directive|ifdef
name|VIMAGE
name|vnet
operator|->
name|vnet_sockcnt
operator|++
expr_stmt|;
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|so_global_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|so
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free the storage associated with a socket at the socket layer, tear down  * locks, labels, etc.  All protocol state is assumed already to have been  * torn down (and possibly never set up) by the caller.  */
end_comment

begin_function
specifier|static
name|void
name|sodealloc
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|so
operator|->
name|so_count
operator|==
literal|0
argument_list|,
operator|(
literal|"sodealloc(): so_count %d"
operator|,
name|so
operator|->
name|so_count
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|so
operator|->
name|so_pcb
operator|==
name|NULL
argument_list|,
operator|(
literal|"sodealloc(): so_pcb != NULL"
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|so_global_mtx
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_gencnt
operator|=
operator|++
name|so_gencnt
expr_stmt|;
operator|--
name|numopensockets
expr_stmt|;
comment|/* Could be below, but faster here. */
ifdef|#
directive|ifdef
name|VIMAGE
name|VNET_ASSERT
argument_list|(
name|so
operator|->
name|so_vnet
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s:%d so_vnet is NULL, so=%p"
operator|,
name|__func__
operator|,
name|__LINE__
operator|,
name|so
operator|)
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_vnet
operator|->
name|vnet_sockcnt
operator|--
expr_stmt|;
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|so_global_mtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_socket_destroy
argument_list|(
name|so
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hhook_run_socket
argument_list|(
name|so
argument_list|,
name|NULL
argument_list|,
name|HHOOK_SOCKET_CLOSE
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|so
operator|->
name|so_cred
argument_list|)
expr_stmt|;
name|khelp_destroy_osd
argument_list|(
operator|&
name|so
operator|->
name|osd
argument_list|)
expr_stmt|;
if|if
condition|(
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|sol_accept_filter
operator|!=
name|NULL
condition|)
name|accept_filt_setopt
argument_list|(
name|so
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
condition|)
operator|(
name|void
operator|)
name|chgsbsize
argument_list|(
name|so
operator|->
name|so_cred
operator|->
name|cr_uidinfo
argument_list|,
operator|&
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
argument_list|,
literal|0
argument_list|,
name|RLIM_INFINITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
condition|)
operator|(
name|void
operator|)
name|chgsbsize
argument_list|(
name|so
operator|->
name|so_cred
operator|->
name|cr_uidinfo
argument_list|,
operator|&
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
argument_list|,
literal|0
argument_list|,
name|RLIM_INFINITY
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|so
operator|->
name|so_snd
operator|.
name|sb_sx
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
operator|.
name|sb_sx
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK_DESTROY
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK_DESTROY
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|so
operator|->
name|so_lock
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|socket_zone
argument_list|,
name|so
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * socreate returns a socket with a ref count of 1.  The socket should be  * closed with soclose().  */
end_comment

begin_function
name|int
name|socreate
parameter_list|(
name|int
name|dom
parameter_list|,
name|struct
name|socket
modifier|*
modifier|*
name|aso
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|protosw
modifier|*
name|prp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|proto
condition|)
name|prp
operator|=
name|pffindproto
argument_list|(
name|dom
argument_list|,
name|proto
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|prp
operator|=
name|pffindtype
argument_list|(
name|dom
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|prp
operator|==
name|NULL
condition|)
block|{
comment|/* No support for domain. */
if|if
condition|(
name|pffinddomain
argument_list|(
name|dom
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
comment|/* No support for socket type. */
if|if
condition|(
name|proto
operator|==
literal|0
operator|&&
name|type
operator|!=
literal|0
condition|)
return|return
operator|(
name|EPROTOTYPE
operator|)
return|;
return|return
operator|(
name|EPROTONOSUPPORT
operator|)
return|;
block|}
if|if
condition|(
name|prp
operator|->
name|pr_usrreqs
operator|->
name|pru_attach
operator|==
name|NULL
operator|||
name|prp
operator|->
name|pr_usrreqs
operator|->
name|pru_attach
operator|==
name|pru_attach_notsupp
condition|)
return|return
operator|(
name|EPROTONOSUPPORT
operator|)
return|;
if|if
condition|(
name|prison_check_af
argument_list|(
name|cred
argument_list|,
name|prp
operator|->
name|pr_domain
operator|->
name|dom_family
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EPROTONOSUPPORT
operator|)
return|;
if|if
condition|(
name|prp
operator|->
name|pr_type
operator|!=
name|type
condition|)
return|return
operator|(
name|EPROTOTYPE
operator|)
return|;
name|so
operator|=
name|soalloc
argument_list|(
name|CRED_TO_VNET
argument_list|(
name|cred
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|so
operator|->
name|so_type
operator|=
name|type
expr_stmt|;
name|so
operator|->
name|so_cred
operator|=
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prp
operator|->
name|pr_domain
operator|->
name|dom_family
operator|==
name|PF_INET
operator|)
operator|||
operator|(
name|prp
operator|->
name|pr_domain
operator|->
name|dom_family
operator|==
name|PF_INET6
operator|)
operator|||
operator|(
name|prp
operator|->
name|pr_domain
operator|->
name|dom_family
operator|==
name|PF_ROUTE
operator|)
condition|)
name|so
operator|->
name|so_fibnum
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_fibnum
expr_stmt|;
else|else
name|so
operator|->
name|so_fibnum
operator|=
literal|0
expr_stmt|;
name|so
operator|->
name|so_proto
operator|=
name|prp
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_socket_create
argument_list|(
name|cred
argument_list|,
name|so
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|knlist_init
argument_list|(
operator|&
name|so
operator|->
name|so_rdsel
operator|.
name|si_note
argument_list|,
name|so
argument_list|,
name|so_rdknl_lock
argument_list|,
name|so_rdknl_unlock
argument_list|,
name|so_rdknl_assert_locked
argument_list|,
name|so_rdknl_assert_unlocked
argument_list|)
expr_stmt|;
name|knlist_init
argument_list|(
operator|&
name|so
operator|->
name|so_wrsel
operator|.
name|si_note
argument_list|,
name|so
argument_list|,
name|so_wrknl_lock
argument_list|,
name|so_wrknl_unlock
argument_list|,
name|so_wrknl_assert_locked
argument_list|,
name|so_wrknl_assert_unlocked
argument_list|)
expr_stmt|;
comment|/* 	 * Auto-sizing of socket buffers is managed by the protocols and 	 * the appropriate flags must be set in the pru_attach function. 	 */
name|CURVNET_SET
argument_list|(
name|so
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|prp
operator|->
name|pr_usrreqs
operator|->
name|pru_attach
call|)
argument_list|(
name|so
argument_list|,
name|proto
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|sodealloc
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|soref
argument_list|(
name|so
argument_list|)
expr_stmt|;
operator|*
name|aso
operator|=
name|so
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|REGRESSION
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|regression_sonewconn_earlytest
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_regression
argument_list|,
name|OID_AUTO
argument_list|,
name|sonewconn_earlytest
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|regression_sonewconn_earlytest
argument_list|,
literal|0
argument_list|,
literal|"Perform early sonewconn limit test"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * When an attempt at a new connection is noted on a socket which accepts  * connections, sonewconn is called.  If the connection is possible (subject  * to space constraints, etc.) then we allocate a new structure, properly  * linked into the data structure of the original socket, and return this.  * Connstatus may be 0, or SS_ISCONFIRMING, or SS_ISCONNECTED.  *  * Note: the ref count on the socket is 0 on return.  */
end_comment

begin_function
name|struct
name|socket
modifier|*
name|sonewconn
parameter_list|(
name|struct
name|socket
modifier|*
name|head
parameter_list|,
name|int
name|connstatus
parameter_list|)
block|{
specifier|static
name|struct
name|timeval
name|lastover
decl_stmt|;
specifier|static
name|struct
name|timeval
name|overinterval
init|=
block|{
literal|60
block|,
literal|0
block|}
decl_stmt|;
specifier|static
name|int
name|overcount
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|u_int
name|over
decl_stmt|;
name|SOLISTEN_LOCK
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|over
operator|=
operator|(
name|head
operator|->
name|sol_qlen
operator|>
literal|3
operator|*
name|head
operator|->
name|sol_qlimit
operator|/
literal|2
operator|)
expr_stmt|;
name|SOLISTEN_UNLOCK
argument_list|(
name|head
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REGRESSION
if|if
condition|(
name|regression_sonewconn_earlytest
operator|&&
name|over
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|over
condition|)
block|{
endif|#
directive|endif
name|overcount
operator|++
expr_stmt|;
if|if
condition|(
name|ratecheck
argument_list|(
operator|&
name|lastover
argument_list|,
operator|&
name|overinterval
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: pcb %p: Listen queue overflow: "
literal|"%i already in queue awaiting acceptance "
literal|"(%d occurrences)\n"
argument_list|,
name|__func__
argument_list|,
name|head
operator|->
name|so_pcb
argument_list|,
name|head
operator|->
name|sol_qlen
argument_list|,
name|overcount
argument_list|)
expr_stmt|;
name|overcount
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|VNET_ASSERT
argument_list|(
name|head
operator|->
name|so_vnet
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: so %p vnet is NULL"
operator|,
name|__func__
operator|,
name|head
operator|)
argument_list|)
expr_stmt|;
name|so
operator|=
name|soalloc
argument_list|(
name|head
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: pcb %p: New socket allocation failure: "
literal|"limit reached or out of memory\n"
argument_list|,
name|__func__
argument_list|,
name|head
operator|->
name|so_pcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|so
operator|->
name|so_listen
operator|=
name|head
expr_stmt|;
name|so
operator|->
name|so_type
operator|=
name|head
operator|->
name|so_type
expr_stmt|;
name|so
operator|->
name|so_linger
operator|=
name|head
operator|->
name|so_linger
expr_stmt|;
name|so
operator|->
name|so_state
operator|=
name|head
operator|->
name|so_state
operator||
name|SS_NOFDREF
expr_stmt|;
name|so
operator|->
name|so_fibnum
operator|=
name|head
operator|->
name|so_fibnum
expr_stmt|;
name|so
operator|->
name|so_proto
operator|=
name|head
operator|->
name|so_proto
expr_stmt|;
name|so
operator|->
name|so_cred
operator|=
name|crhold
argument_list|(
name|head
operator|->
name|so_cred
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_socket_newconn
argument_list|(
name|head
argument_list|,
name|so
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|knlist_init
argument_list|(
operator|&
name|so
operator|->
name|so_rdsel
operator|.
name|si_note
argument_list|,
name|so
argument_list|,
name|so_rdknl_lock
argument_list|,
name|so_rdknl_unlock
argument_list|,
name|so_rdknl_assert_locked
argument_list|,
name|so_rdknl_assert_unlocked
argument_list|)
expr_stmt|;
name|knlist_init
argument_list|(
operator|&
name|so
operator|->
name|so_wrsel
operator|.
name|si_note
argument_list|,
name|so
argument_list|,
name|so_wrknl_lock
argument_list|,
name|so_wrknl_unlock
argument_list|,
name|so_wrknl_assert_locked
argument_list|,
name|so_wrknl_assert_unlocked
argument_list|)
expr_stmt|;
name|VNET_SO_ASSERT
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|soreserve
argument_list|(
name|so
argument_list|,
name|head
operator|->
name|sol_sbsnd_hiwat
argument_list|,
name|head
operator|->
name|sol_sbrcv_hiwat
argument_list|)
condition|)
block|{
name|sodealloc
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: pcb %p: soreserve() failed\n"
argument_list|,
name|__func__
argument_list|,
name|head
operator|->
name|so_pcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_attach
call|)
argument_list|(
name|so
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|sodealloc
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: pcb %p: pru_attach() failed\n"
argument_list|,
name|__func__
argument_list|,
name|head
operator|->
name|so_pcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|so
operator|->
name|so_rcv
operator|.
name|sb_lowat
operator|=
name|head
operator|->
name|sol_sbrcv_lowat
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_lowat
operator|=
name|head
operator|->
name|sol_sbsnd_lowat
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_timeo
operator|=
name|head
operator|->
name|sol_sbrcv_timeo
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_timeo
operator|=
name|head
operator|->
name|sol_sbsnd_timeo
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator||=
name|head
operator|->
name|sol_sbrcv_flags
operator|&
name|SB_AUTOSIZE
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator||=
name|head
operator|->
name|sol_sbsnd_flags
operator|&
name|SB_AUTOSIZE
expr_stmt|;
name|SOLISTEN_LOCK
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|sol_accept_filter
operator|!=
name|NULL
condition|)
name|connstatus
operator|=
literal|0
expr_stmt|;
name|so
operator|->
name|so_state
operator||=
name|connstatus
expr_stmt|;
name|so
operator|->
name|so_options
operator|=
name|head
operator|->
name|so_options
operator|&
operator|~
name|SO_ACCEPTCONN
expr_stmt|;
name|soref
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/* A socket on (in)complete queue refs head. */
if|if
condition|(
name|connstatus
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|head
operator|->
name|sol_comp
argument_list|,
name|so
argument_list|,
name|so_list
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_qstate
operator|=
name|SQ_COMP
expr_stmt|;
name|head
operator|->
name|sol_qlen
operator|++
expr_stmt|;
name|solisten_wakeup
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/* unlocks */
block|}
else|else
block|{
comment|/* 		 * Keep removing sockets from the head until there's room for 		 * us to insert on the tail.  In pre-locking revisions, this 		 * was a simple if(), but as we could be racing with other 		 * threads and soabort() requires dropping locks, we must 		 * loop waiting for the condition to be true. 		 */
while|while
condition|(
name|head
operator|->
name|sol_incqlen
operator|>
name|head
operator|->
name|sol_qlimit
condition|)
block|{
name|struct
name|socket
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|head
operator|->
name|sol_incomp
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|head
operator|->
name|sol_incomp
argument_list|,
name|sp
argument_list|,
name|so_list
argument_list|)
expr_stmt|;
name|head
operator|->
name|sol_incqlen
operator|--
expr_stmt|;
name|SOCK_LOCK
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|so_qstate
operator|=
name|SQ_NONE
expr_stmt|;
name|sp
operator|->
name|so_listen
operator|=
name|NULL
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sorele
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/* does SOLISTEN_UNLOCK, head stays */
name|soabort
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|SOLISTEN_LOCK
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|head
operator|->
name|sol_incomp
argument_list|,
name|so
argument_list|,
name|so_list
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_qstate
operator|=
name|SQ_INCOMP
expr_stmt|;
name|head
operator|->
name|sol_incqlen
operator|++
expr_stmt|;
name|SOLISTEN_UNLOCK
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|so
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SCTP
comment|/*  * Socket part of sctp_peeloff().  Detach a new socket from an  * association.  The new socket is returned with a reference.  */
name|struct
name|socket
modifier|*
name|sopeeloff
parameter_list|(
name|struct
name|socket
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|VNET_ASSERT
argument_list|(
name|head
operator|->
name|so_vnet
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s:%d so_vnet is NULL, head=%p"
operator|,
name|__func__
operator|,
name|__LINE__
operator|,
name|head
operator|)
argument_list|)
expr_stmt|;
name|so
operator|=
name|soalloc
argument_list|(
name|head
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: pcb %p: New socket allocation failure: "
literal|"limit reached or out of memory\n"
argument_list|,
name|__func__
argument_list|,
name|head
operator|->
name|so_pcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|so
operator|->
name|so_type
operator|=
name|head
operator|->
name|so_type
expr_stmt|;
name|so
operator|->
name|so_options
operator|=
name|head
operator|->
name|so_options
expr_stmt|;
name|so
operator|->
name|so_linger
operator|=
name|head
operator|->
name|so_linger
expr_stmt|;
name|so
operator|->
name|so_state
operator|=
operator|(
name|head
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|)
operator||
name|SS_ISCONNECTED
expr_stmt|;
name|so
operator|->
name|so_fibnum
operator|=
name|head
operator|->
name|so_fibnum
expr_stmt|;
name|so
operator|->
name|so_proto
operator|=
name|head
operator|->
name|so_proto
expr_stmt|;
name|so
operator|->
name|so_cred
operator|=
name|crhold
argument_list|(
name|head
operator|->
name|so_cred
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_socket_newconn
argument_list|(
name|head
argument_list|,
name|so
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|knlist_init
argument_list|(
operator|&
name|so
operator|->
name|so_rdsel
operator|.
name|si_note
argument_list|,
name|so
argument_list|,
name|so_rdknl_lock
argument_list|,
name|so_rdknl_unlock
argument_list|,
name|so_rdknl_assert_locked
argument_list|,
name|so_rdknl_assert_unlocked
argument_list|)
expr_stmt|;
name|knlist_init
argument_list|(
operator|&
name|so
operator|->
name|so_wrsel
operator|.
name|si_note
argument_list|,
name|so
argument_list|,
name|so_wrknl_lock
argument_list|,
name|so_wrknl_unlock
argument_list|,
name|so_wrknl_assert_locked
argument_list|,
name|so_wrknl_assert_unlocked
argument_list|)
expr_stmt|;
name|VNET_SO_ASSERT
argument_list|(
name|head
argument_list|)
expr_stmt|;
if|if
condition|(
name|soreserve
argument_list|(
name|so
argument_list|,
name|head
operator|->
name|so_snd
operator|.
name|sb_hiwat
argument_list|,
name|head
operator|->
name|so_rcv
operator|.
name|sb_hiwat
argument_list|)
condition|)
block|{
name|sodealloc
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: pcb %p: soreserve() failed\n"
argument_list|,
name|__func__
argument_list|,
name|head
operator|->
name|so_pcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_attach
call|)
argument_list|(
name|so
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|sodealloc
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"%s: pcb %p: pru_attach() failed\n"
argument_list|,
name|__func__
argument_list|,
name|head
operator|->
name|so_pcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|so
operator|->
name|so_rcv
operator|.
name|sb_lowat
operator|=
name|head
operator|->
name|so_rcv
operator|.
name|sb_lowat
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_lowat
operator|=
name|head
operator|->
name|so_snd
operator|.
name|sb_lowat
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_timeo
operator|=
name|head
operator|->
name|so_rcv
operator|.
name|sb_timeo
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_timeo
operator|=
name|head
operator|->
name|so_snd
operator|.
name|sb_timeo
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator||=
name|head
operator|->
name|so_rcv
operator|.
name|sb_flags
operator|&
name|SB_AUTOSIZE
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator||=
name|head
operator|->
name|so_snd
operator|.
name|sb_flags
operator|&
name|SB_AUTOSIZE
expr_stmt|;
name|soref
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|so
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* SCTP */
name|int
name|sobind
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|CURVNET_SET
argument_list|(
name|so
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_bind
call|)
argument_list|(
name|so
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|int
name|sobindat
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|CURVNET_SET
argument_list|(
name|so
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_bindat
call|)
argument_list|(
name|fd
argument_list|,
name|so
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * solisten() transitions a socket from a non-listening state to a listening  * state, but can also be used to update the listen queue depth on an  * existing listen socket.  The protocol will call back into the sockets  * layer using solisten_proto_check() and solisten_proto() to check and set  * socket-layer listen state.  Call backs are used so that the protocol can  * acquire both protocol and socket layer locks in whatever order is required  * by the protocol.  *  * Protocol implementors are advised to hold the socket lock across the  * socket-layer test and set to avoid races at the socket layer.  */
name|int
name|solisten
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|backlog
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|CURVNET_SET
argument_list|(
name|so
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_listen
call|)
argument_list|(
name|so
argument_list|,
name|backlog
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|int
name|solisten_proto_check
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|SOCK_LOCK_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
operator|(
name|SS_ISCONNECTED
operator||
name|SS_ISCONNECTING
operator||
name|SS_ISDISCONNECTING
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|void
name|solisten_proto
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|backlog
parameter_list|)
block|{
name|int
name|sbrcv_lowat
decl_stmt|,
name|sbsnd_lowat
decl_stmt|;
name|u_int
name|sbrcv_hiwat
decl_stmt|,
name|sbsnd_hiwat
decl_stmt|;
name|short
name|sbrcv_flags
decl_stmt|,
name|sbsnd_flags
decl_stmt|;
name|sbintime_t
name|sbrcv_timeo
decl_stmt|,
name|sbsnd_timeo
decl_stmt|;
name|SOCK_LOCK_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|)
goto|goto
name|listening
goto|;
comment|/* 	 * Change this socket to listening state. 	 */
name|sbrcv_lowat
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_lowat
expr_stmt|;
name|sbsnd_lowat
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_lowat
expr_stmt|;
name|sbrcv_hiwat
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
expr_stmt|;
name|sbsnd_hiwat
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
expr_stmt|;
name|sbrcv_flags
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
expr_stmt|;
name|sbsnd_flags
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
expr_stmt|;
name|sbrcv_timeo
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_timeo
expr_stmt|;
name|sbsnd_timeo
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_timeo
expr_stmt|;
name|sbdestroy
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|sbdestroy
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|so
operator|->
name|so_snd
operator|.
name|sb_sx
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
operator|.
name|sb_sx
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK_DESTROY
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK_DESTROY
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|bzero
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|socket
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|socket
argument_list|,
name|so_rcv
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|so
operator|->
name|sol_sbrcv_lowat
operator|=
name|sbrcv_lowat
expr_stmt|;
name|so
operator|->
name|sol_sbsnd_lowat
operator|=
name|sbsnd_lowat
expr_stmt|;
name|so
operator|->
name|sol_sbrcv_hiwat
operator|=
name|sbrcv_hiwat
expr_stmt|;
name|so
operator|->
name|sol_sbsnd_hiwat
operator|=
name|sbsnd_hiwat
expr_stmt|;
name|so
operator|->
name|sol_sbrcv_flags
operator|=
name|sbrcv_flags
expr_stmt|;
name|so
operator|->
name|sol_sbsnd_flags
operator|=
name|sbsnd_flags
expr_stmt|;
name|so
operator|->
name|sol_sbrcv_timeo
operator|=
name|sbrcv_timeo
expr_stmt|;
name|so
operator|->
name|sol_sbsnd_timeo
operator|=
name|sbsnd_timeo
expr_stmt|;
name|so
operator|->
name|sol_qlen
operator|=
name|so
operator|->
name|sol_incqlen
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|so
operator|->
name|sol_incomp
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|so
operator|->
name|sol_comp
argument_list|)
expr_stmt|;
name|so
operator|->
name|sol_accept_filter
operator|=
name|NULL
expr_stmt|;
name|so
operator|->
name|sol_accept_filter_arg
operator|=
name|NULL
expr_stmt|;
name|so
operator|->
name|sol_accept_filter_str
operator|=
name|NULL
expr_stmt|;
name|so
operator|->
name|sol_upcall
operator|=
name|NULL
expr_stmt|;
name|so
operator|->
name|sol_upcallarg
operator|=
name|NULL
expr_stmt|;
name|so
operator|->
name|so_options
operator||=
name|SO_ACCEPTCONN
expr_stmt|;
name|listening
label|:
if|if
condition|(
name|backlog
operator|<
literal|0
operator|||
name|backlog
operator|>
name|somaxconn
condition|)
name|backlog
operator|=
name|somaxconn
expr_stmt|;
name|so
operator|->
name|sol_qlimit
operator|=
name|backlog
expr_stmt|;
block|}
comment|/*  * Wakeup listeners/subsystems once we have a complete connection.  * Enters with lock, returns unlocked.  */
name|void
name|solisten_wakeup
parameter_list|(
name|struct
name|socket
modifier|*
name|sol
parameter_list|)
block|{
if|if
condition|(
name|sol
operator|->
name|sol_upcall
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|sol
operator|->
name|sol_upcall
argument_list|(
name|sol
argument_list|,
name|sol
operator|->
name|sol_upcallarg
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
else|else
block|{
name|selwakeuppri
argument_list|(
operator|&
name|sol
operator|->
name|so_rdsel
argument_list|,
name|PSOCK
argument_list|)
expr_stmt|;
name|KNOTE_LOCKED
argument_list|(
operator|&
name|sol
operator|->
name|so_rdsel
operator|.
name|si_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|SOLISTEN_UNLOCK
argument_list|(
name|sol
argument_list|)
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|sol
operator|->
name|sol_comp
argument_list|)
expr_stmt|;
block|}
comment|/*  * Return single connection off a listening socket queue.  Main consumer of  * the function is kern_accept4().  Some modules, that do their own accept  * management also use the function.  *  * Listening socket must be locked on entry and is returned unlocked on  * return.  * The flags argument is set of accept4(2) flags and ACCEPT4_INHERIT.  */
name|int
name|solisten_dequeue
parameter_list|(
name|struct
name|socket
modifier|*
name|head
parameter_list|,
name|struct
name|socket
modifier|*
modifier|*
name|ret
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|error
decl_stmt|;
name|SOLISTEN_LOCK_ASSERT
argument_list|(
name|head
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|head
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|head
operator|->
name|sol_comp
argument_list|)
operator|&&
name|head
operator|->
name|so_error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|msleep
argument_list|(
operator|&
name|head
operator|->
name|sol_comp
argument_list|,
operator|&
name|head
operator|->
name|so_lock
argument_list|,
name|PSOCK
operator||
name|PCATCH
argument_list|,
literal|"accept"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|SOLISTEN_UNLOCK
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
if|if
condition|(
name|head
operator|->
name|so_error
condition|)
block|{
name|error
operator|=
name|head
operator|->
name|so_error
expr_stmt|;
name|head
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
name|SOLISTEN_UNLOCK
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|head
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|head
operator|->
name|sol_comp
argument_list|)
condition|)
block|{
name|SOLISTEN_UNLOCK
argument_list|(
name|head
argument_list|)
expr_stmt|;
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
block|}
name|so
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|head
operator|->
name|sol_comp
argument_list|)
expr_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|so
operator|->
name|so_qstate
operator|==
name|SQ_COMP
argument_list|,
operator|(
literal|"%s: so %p not SQ_COMP"
operator|,
name|__func__
operator|,
name|so
operator|)
argument_list|)
expr_stmt|;
name|soref
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|head
operator|->
name|sol_qlen
operator|--
expr_stmt|;
name|so
operator|->
name|so_qstate
operator|=
name|SQ_NONE
expr_stmt|;
name|so
operator|->
name|so_listen
operator|=
name|NULL
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|head
operator|->
name|sol_comp
argument_list|,
name|so
argument_list|,
name|so_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ACCEPT4_INHERIT
condition|)
name|so
operator|->
name|so_state
operator||=
operator|(
name|head
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|)
expr_stmt|;
else|else
name|so
operator|->
name|so_state
operator||=
operator|(
name|flags
operator|&
name|SOCK_NONBLOCK
operator|)
condition|?
name|SS_NBIO
else|:
literal|0
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sorele
argument_list|(
name|head
argument_list|)
expr_stmt|;
operator|*
name|ret
operator|=
name|so
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Evaluate the reference count and named references on a socket; if no  * references remain, free it.  This should be called whenever a reference is  * released, such as in sorele(), but also when named reference flags are  * cleared in socket or protocol code.  *  * sofree() will free the socket if:  *  * - There are no outstanding file descriptor references or related consumers  *   (so_count == 0).  *  * - The socket has been closed by user space, if ever open (SS_NOFDREF).  *  * - The protocol does not have an outstanding strong reference on the socket  *   (SS_PROTOREF).  *  * - The socket is not in a completed connection queue, so a process has been  *   notified that it is present.  If it is removed, the user process may  *   block in accept() despite select() saying the socket was ready.  */
name|void
name|sofree
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|protosw
modifier|*
name|pr
init|=
name|so
operator|->
name|so_proto
decl_stmt|;
name|SOCK_LOCK_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NOFDREF
operator|)
operator|==
literal|0
operator|||
name|so
operator|->
name|so_count
operator|!=
literal|0
operator|||
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_PROTOREF
operator|)
operator|||
operator|(
name|so
operator|->
name|so_qstate
operator|==
name|SQ_COMP
operator|)
condition|)
block|{
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|SOLISTENING
argument_list|(
name|so
argument_list|)
operator|&&
name|so
operator|->
name|so_qstate
operator|==
name|SQ_INCOMP
condition|)
block|{
name|struct
name|socket
modifier|*
name|sol
decl_stmt|;
name|sol
operator|=
name|so
operator|->
name|so_listen
expr_stmt|;
name|KASSERT
argument_list|(
name|sol
argument_list|,
operator|(
literal|"%s: so %p on incomp of NULL"
operator|,
name|__func__
operator|,
name|so
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * To solve race between close of a listening socket and 		 * a socket on its incomplete queue, we need to lock both. 		 * The order is first listening socket, then regular. 		 * Since we don't have SS_NOFDREF neither SS_PROTOREF, this 		 * function and the listening socket are the only pointers 		 * to so.  To preserve so and sol, we reference both and then 		 * relock. 		 * After relock the socket may not move to so_comp since it 		 * doesn't have PCB already, but it may be removed from 		 * so_incomp. If that happens, we share responsiblity on 		 * freeing the socket, but soclose() has already removed 		 * it from queue. 		 */
name|soref
argument_list|(
name|sol
argument_list|)
expr_stmt|;
name|soref
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SOLISTEN_LOCK
argument_list|(
name|sol
argument_list|)
expr_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_qstate
operator|==
name|SQ_INCOMP
condition|)
block|{
name|KASSERT
argument_list|(
name|so
operator|->
name|so_listen
operator|==
name|sol
argument_list|,
operator|(
literal|"%s: so %p migrated out of sol %p"
operator|,
name|__func__
operator|,
name|so
operator|,
name|sol
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sol
operator|->
name|sol_incomp
argument_list|,
name|so
argument_list|,
name|so_list
argument_list|)
expr_stmt|;
name|sol
operator|->
name|sol_incqlen
operator|--
expr_stmt|;
comment|/* This is guarenteed not to be the last. */
name|refcount_release
argument_list|(
operator|&
name|sol
operator|->
name|so_count
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_qstate
operator|=
name|SQ_NONE
expr_stmt|;
name|so
operator|->
name|so_listen
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|KASSERT
argument_list|(
name|so
operator|->
name|so_listen
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: so %p not on (in)comp with so_listen"
operator|,
name|__func__
operator|,
name|so
operator|)
argument_list|)
expr_stmt|;
name|sorele
argument_list|(
name|sol
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|so
operator|->
name|so_count
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: so %p count %u"
operator|,
name|__func__
operator|,
name|so
operator|,
name|so
operator|->
name|so_count
operator|)
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|)
name|so
operator|->
name|so_error
operator|=
name|ECONNABORTED
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|VNET_SO_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|pr_flags
operator|&
name|PR_RIGHTS
operator|&&
name|pr
operator|->
name|pr_domain
operator|->
name|dom_dispose
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|pr
operator|->
name|pr_domain
operator|->
name|dom_dispose
call|)
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|pr_usrreqs
operator|->
name|pru_detach
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|pr
operator|->
name|pr_usrreqs
operator|->
name|pru_detach
call|)
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* 	 * From this point on, we assume that no other references to this 	 * socket exist anywhere else in the stack.  Therefore, no locks need 	 * to be acquired or held. 	 * 	 * We used to do a lot of socket buffer and socket locking here, as 	 * well as invoke sorflush() and perform wakeups.  The direct call to 	 * dom_dispose() and sbrelease_internal() are an inlining of what was 	 * necessary from sorflush(). 	 * 	 * Notice that the socket buffer and kqueue state are torn down 	 * before calling pru_detach.  This means that protocols shold not 	 * assume they can perform socket wakeups, etc, in their detach code. 	 */
if|if
condition|(
operator|!
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|)
block|{
name|sbdestroy
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|sbdestroy
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|so
argument_list|)
expr_stmt|;
block|}
name|seldrain
argument_list|(
operator|&
name|so
operator|->
name|so_rdsel
argument_list|)
expr_stmt|;
name|seldrain
argument_list|(
operator|&
name|so
operator|->
name|so_wrsel
argument_list|)
expr_stmt|;
name|knlist_destroy
argument_list|(
operator|&
name|so
operator|->
name|so_rdsel
operator|.
name|si_note
argument_list|)
expr_stmt|;
name|knlist_destroy
argument_list|(
operator|&
name|so
operator|->
name|so_wrsel
operator|.
name|si_note
argument_list|)
expr_stmt|;
name|sodealloc
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
comment|/*  * Close a socket on last file table reference removal.  Initiate disconnect  * if connected.  Free socket when disconnect complete.  *  * This function will sorele() the socket.  Note that soclose() may be called  * prior to the ref count reaching zero.  The actual socket structure will  * not be freed until the ref count reaches zero.  */
name|int
name|soclose
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|accept_queue
name|lqueue
decl_stmt|;
name|bool
name|listening
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NOFDREF
operator|)
argument_list|,
operator|(
literal|"soclose: SS_NOFDREF on enter"
operator|)
argument_list|)
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|so
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
name|funsetown
argument_list|(
operator|&
name|so
operator|->
name|so_sigio
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
condition|)
block|{
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISDISCONNECTING
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|sodisconnect
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOTCONN
condition|)
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
block|}
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_LINGER
condition|)
block|{
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISDISCONNECTING
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|)
condition|)
goto|goto
name|drop
goto|;
while|while
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|so
operator|->
name|so_timeo
argument_list|,
name|PSOCK
operator||
name|PCATCH
argument_list|,
literal|"soclos"
argument_list|,
name|so
operator|->
name|so_linger
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
block|}
block|}
name|drop
label|:
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_close
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_close
call|)
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|listening
operator|=
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_ACCEPTCONN
operator|)
operator|)
condition|)
block|{
name|struct
name|socket
modifier|*
name|sp
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|lqueue
argument_list|)
expr_stmt|;
name|TAILQ_SWAP
argument_list|(
operator|&
name|lqueue
argument_list|,
operator|&
name|so
operator|->
name|sol_incomp
argument_list|,
name|socket
argument_list|,
name|so_list
argument_list|)
expr_stmt|;
name|TAILQ_CONCAT
argument_list|(
operator|&
name|lqueue
argument_list|,
operator|&
name|so
operator|->
name|sol_comp
argument_list|,
name|so_list
argument_list|)
expr_stmt|;
name|so
operator|->
name|sol_qlen
operator|=
name|so
operator|->
name|sol_incqlen
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&lqueue
argument_list|,
argument|so_list
argument_list|)
block|{
name|SOCK_LOCK
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|so_qstate
operator|=
name|SQ_NONE
expr_stmt|;
name|sp
operator|->
name|so_listen
operator|=
name|NULL
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* Guaranteed not to be the last. */
name|refcount_release
argument_list|(
operator|&
name|so
operator|->
name|so_count
argument_list|)
expr_stmt|;
block|}
block|}
name|KASSERT
argument_list|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NOFDREF
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"soclose: NOFDREF"
operator|)
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_state
operator||=
name|SS_NOFDREF
expr_stmt|;
name|sorele
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|listening
condition|)
block|{
name|struct
name|socket
modifier|*
name|sp
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&lqueue
argument_list|,
argument|so_list
argument_list|)
block|{
name|SOCK_LOCK
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|so_count
operator|==
literal|0
condition|)
block|{
name|SOCK_UNLOCK
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|soabort
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* sp is now in sofree() */
name|SOCK_UNLOCK
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * soabort() is used to abruptly tear down a connection, such as when a  * resource limit is reached (listen queue depth exceeded), or if a listen  * socket is closed while there are sockets waiting to be accepted.  *  * This interface is tricky, because it is called on an unreferenced socket,  * and must be called only by a thread that has actually removed the socket  * from the listen queue it was on, or races with other threads are risked.  *  * This interface will call into the protocol code, so must not be called  * with any socket locks held.  Protocols do call it while holding their own  * recursible protocol mutexes, but this is something that should be subject  * to review in the future.  */
name|void
name|soabort
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
comment|/* 	 * In as much as is possible, assert that no references to this 	 * socket are held.  This is not quite the same as asserting that the 	 * current thread is responsible for arranging for no references, but 	 * is as close as we can get for now. 	 */
name|KASSERT
argument_list|(
name|so
operator|->
name|so_count
operator|==
literal|0
argument_list|,
operator|(
literal|"soabort: so_count"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_PROTOREF
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"soabort: SS_PROTOREF"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|so
operator|->
name|so_state
operator|&
name|SS_NOFDREF
argument_list|,
operator|(
literal|"soabort: !SS_NOFDREF"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|so
operator|->
name|so_qstate
operator|==
name|SQ_NONE
argument_list|,
operator|(
literal|"soabort: !SQ_NONE"
operator|)
argument_list|)
expr_stmt|;
name|VNET_SO_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_abort
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_abort
call|)
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sofree
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|int
name|soaccept
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NOFDREF
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"soaccept: !NOFDREF"
operator|)
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_state
operator|&=
operator|~
name|SS_NOFDREF
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|so
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_accept
call|)
argument_list|(
name|so
argument_list|,
name|nam
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|int
name|soconnect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
name|soconnectat
argument_list|(
name|AT_FDCWD
argument_list|,
name|so
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
operator|)
return|;
block|}
name|int
name|soconnectat
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_ACCEPTCONN
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|CURVNET_SET
argument_list|(
name|so
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
comment|/* 	 * If protocol is connection-based, can only connect once. 	 * Otherwise, if connected, try to disconnect first.  This allows 	 * user to disconnect by connecting to, e.g., a null address. 	 */
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
operator|(
name|SS_ISCONNECTED
operator||
name|SS_ISCONNECTING
operator|)
operator|&&
operator|(
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
operator|)
operator|||
operator|(
name|error
operator|=
name|sodisconnect
argument_list|(
name|so
argument_list|)
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EISCONN
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Prevent accumulated error from previous connection from 		 * biting us. 		 */
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fd
operator|==
name|AT_FDCWD
condition|)
block|{
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_connect
call|)
argument_list|(
name|so
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_connectat
call|)
argument_list|(
name|fd
argument_list|,
name|so
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|int
name|soconnect2
parameter_list|(
name|struct
name|socket
modifier|*
name|so1
parameter_list|,
name|struct
name|socket
modifier|*
name|so2
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|CURVNET_SET
argument_list|(
name|so1
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|so1
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_connect2
call|)
argument_list|(
name|so1
argument_list|,
name|so2
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|int
name|sodisconnect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOTCONN
operator|)
return|;
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISDISCONNECTING
condition|)
return|return
operator|(
name|EALREADY
operator|)
return|;
name|VNET_SO_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_disconnect
call|)
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
define|#
directive|define
name|SBLOCKWAIT
parameter_list|(
name|f
parameter_list|)
value|(((f)& MSG_DONTWAIT) ? 0 : SBL_WAIT)
name|int
name|sosend_dgram
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
name|top
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|long
name|space
decl_stmt|;
name|ssize_t
name|resid
decl_stmt|;
name|int
name|clen
init|=
literal|0
decl_stmt|,
name|error
decl_stmt|,
name|dontroute
decl_stmt|;
name|KASSERT
argument_list|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_DGRAM
argument_list|,
operator|(
literal|"sosend_dgram: !SOCK_DGRAM"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_ATOMIC
argument_list|,
operator|(
literal|"sosend_dgram: !PR_ATOMIC"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|!=
name|NULL
condition|)
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
else|else
name|resid
operator|=
name|top
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* 	 * In theory resid should be unsigned.  However, space must be 	 * signed, as it might be less than 0 if we over-committed, and we 	 * must use a signed comparison of space and resid.  On the other 	 * hand, a negative resid causes us to loop sending 0-length 	 * segments to the protocol. 	 */
if|if
condition|(
name|resid
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dontroute
operator|=
operator|(
name|flags
operator|&
name|MSG_DONTROUTE
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_DONTROUTE
operator|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|td
operator|!=
name|NULL
condition|)
name|td
operator|->
name|td_ru
operator|.
name|ru_msgsnd
operator|++
expr_stmt|;
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
name|clen
operator|=
name|control
operator|->
name|m_len
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_state
operator|&
name|SBS_CANTSENDMORE
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPIPE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * `sendto' and `sendmsg' is allowed on a connection-based 		 * socket if it supports implied connect.  Return ENOTCONN if 		 * not connected and no address is supplied. 		 */
if|if
condition|(
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_IMPLOPCL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONFIRMING
operator|)
operator|==
literal|0
operator|&&
operator|!
operator|(
name|resid
operator|==
literal|0
operator|&&
name|clen
operator|!=
literal|0
operator|)
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
condition|)
name|error
operator|=
name|ENOTCONN
expr_stmt|;
else|else
name|error
operator|=
name|EDESTADDRREQ
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * Do we need MSG_OOB support in SOCK_DGRAM?  Signs here may be a 	 * problem and need fixing. 	 */
name|space
operator|=
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MSG_OOB
condition|)
name|space
operator|+=
literal|1024
expr_stmt|;
name|space
operator|-=
name|clen
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|resid
operator|>
name|space
condition|)
block|{
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|uio
operator|==
name|NULL
condition|)
block|{
name|resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MSG_EOR
condition|)
name|top
operator|->
name|m_flags
operator||=
name|M_EOR
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Copy the data from userland into a mbuf chain. 		 * If no data is to be copied in, a single empty mbuf 		 * is returned. 		 */
name|top
operator|=
name|m_uiotombuf
argument_list|(
name|uio
argument_list|,
name|M_WAITOK
argument_list|,
name|space
argument_list|,
name|max_hdr
argument_list|,
operator|(
name|M_PKTHDR
operator||
operator|(
operator|(
name|flags
operator|&
name|MSG_EOR
operator|)
condition|?
name|M_EOR
else|:
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
comment|/* only possible error */
goto|goto
name|out
goto|;
block|}
name|space
operator|-=
name|resid
operator|-
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|resid
operator|==
literal|0
argument_list|,
operator|(
literal|"sosend_dgram: resid != 0"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * XXXRW: Frobbing SO_DONTROUTE here is even worse without sblock 	 * than with. 	 */
if|if
condition|(
name|dontroute
condition|)
block|{
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_options
operator||=
name|SO_DONTROUTE
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX all the SBS_CANTSENDMORE checks previously done could be out 	 * of date.  We could have received a reset packet in an interrupt or 	 * maybe we slept while doing page faults in uiomove() etc.  We could 	 * probably recheck again inside the locking protection here, but 	 * there are probably other places that this also happens.  We must 	 * rethink this. 	 */
name|VNET_SO_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_send
call|)
argument_list|(
name|so
argument_list|,
operator|(
name|flags
operator|&
name|MSG_OOB
operator|)
condition|?
name|PRUS_OOB
else|:
comment|/* 	 * If the user set MSG_EOF, the protocol understands this flag and 	 * nothing left to send then use PRU_SEND_EOF instead of PRU_SEND. 	 */
operator|(
operator|(
name|flags
operator|&
name|MSG_EOF
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_IMPLOPCL
operator|)
operator|&&
operator|(
name|resid
operator|<=
literal|0
operator|)
operator|)
condition|?
name|PRUS_EOF
else|:
comment|/* If there is more to send set PRUS_MORETOCOME */
operator|(
name|flags
operator|&
name|MSG_MORETOCOME
operator|)
operator|||
operator|(
name|resid
operator|>
literal|0
operator|&&
name|space
operator|>
literal|0
operator|)
condition|?
name|PRUS_MORETOCOME
else|:
literal|0
argument_list|,
name|top
argument_list|,
name|addr
argument_list|,
name|control
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|dontroute
condition|)
block|{
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_options
operator|&=
operator|~
name|SO_DONTROUTE
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|clen
operator|=
literal|0
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
name|top
operator|=
name|NULL
expr_stmt|;
name|out
label|:
if|if
condition|(
name|top
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * Send on a socket.  If send must go all at once and message is larger than  * send buffering, then hard error.  Lock against other senders.  If must go  * all at once and not enough room now, then inform user that this would  * block and do nothing.  Otherwise, if nonblocking, send as much as  * possible.  The data to be sent is described by "uio" if nonzero, otherwise  * by the mbuf chain "top" (which must be null if uio is not).  Data provided  * in mbuf chain must be small enough to send all at once.  *  * Returns nonzero on error, timeout or signal; callers must check for short  * counts if EINTR/ERESTART are returned.  Data and control buffers are freed  * on return.  */
name|int
name|sosend_generic
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
name|top
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|long
name|space
decl_stmt|;
name|ssize_t
name|resid
decl_stmt|;
name|int
name|clen
init|=
literal|0
decl_stmt|,
name|error
decl_stmt|,
name|dontroute
decl_stmt|;
name|int
name|atomic
init|=
name|sosendallatonce
argument_list|(
name|so
argument_list|)
operator|||
name|top
decl_stmt|;
if|if
condition|(
name|uio
operator|!=
name|NULL
condition|)
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
else|else
name|resid
operator|=
name|top
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* 	 * In theory resid should be unsigned.  However, space must be 	 * signed, as it might be less than 0 if we over-committed, and we 	 * must use a signed comparison of space and resid.  On the other 	 * hand, a negative resid causes us to loop sending 0-length 	 * segments to the protocol. 	 * 	 * Also check to make sure that MSG_EOR isn't used on SOCK_STREAM 	 * type sockets since that's an error. 	 */
if|if
condition|(
name|resid
operator|<
literal|0
operator|||
operator|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_STREAM
operator|&&
operator|(
name|flags
operator|&
name|MSG_EOR
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dontroute
operator|=
operator|(
name|flags
operator|&
name|MSG_DONTROUTE
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_DONTROUTE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_ATOMIC
operator|)
expr_stmt|;
if|if
condition|(
name|td
operator|!=
name|NULL
condition|)
name|td
operator|->
name|td_ru
operator|.
name|ru_msgsnd
operator|++
expr_stmt|;
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
name|clen
operator|=
name|control
operator|->
name|m_len
expr_stmt|;
name|error
operator|=
name|sblock
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
name|SBLOCKWAIT
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|restart
label|:
do|do
block|{
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_state
operator|&
name|SBS_CANTSENDMORE
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPIPE
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * `sendto' and `sendmsg' is allowed on a connection- 			 * based socket if it supports implied connect. 			 * Return ENOTCONN if not connected and no address is 			 * supplied. 			 */
if|if
condition|(
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_IMPLOPCL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONFIRMING
operator|)
operator|==
literal|0
operator|&&
operator|!
operator|(
name|resid
operator|==
literal|0
operator|&&
name|clen
operator|!=
literal|0
operator|)
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|release
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
condition|)
name|error
operator|=
name|ENOTCONN
expr_stmt|;
else|else
name|error
operator|=
name|EDESTADDRREQ
expr_stmt|;
goto|goto
name|release
goto|;
block|}
block|}
name|space
operator|=
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MSG_OOB
condition|)
name|space
operator|+=
literal|1024
expr_stmt|;
if|if
condition|(
operator|(
name|atomic
operator|&&
name|resid
operator|>
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|)
operator|||
name|clen
operator|>
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|space
operator|<
name|resid
operator|+
name|clen
operator|&&
operator|(
name|atomic
operator|||
name|space
operator|<
name|so
operator|->
name|so_snd
operator|.
name|sb_lowat
operator|||
name|space
operator|<
name|clen
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|)
operator|||
operator|(
name|flags
operator|&
name|MSG_NBIO
operator|)
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
goto|goto
name|release
goto|;
block|}
name|error
operator|=
name|sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|release
goto|;
goto|goto
name|restart
goto|;
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|space
operator|-=
name|clen
expr_stmt|;
do|do
block|{
if|if
condition|(
name|uio
operator|==
name|NULL
condition|)
block|{
name|resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MSG_EOR
condition|)
name|top
operator|->
name|m_flags
operator||=
name|M_EOR
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Copy the data from userland into a mbuf 				 * chain.  If resid is 0, which can happen 				 * only if we have control to send, then 				 * a single empty mbuf is returned.  This 				 * is a workaround to prevent protocol send 				 * methods to panic. 				 */
name|top
operator|=
name|m_uiotombuf
argument_list|(
name|uio
argument_list|,
name|M_WAITOK
argument_list|,
name|space
argument_list|,
operator|(
name|atomic
condition|?
name|max_hdr
else|:
literal|0
operator|)
argument_list|,
operator|(
name|atomic
condition|?
name|M_PKTHDR
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|flags
operator|&
name|MSG_EOR
operator|)
condition|?
name|M_EOR
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
comment|/* only possible error */
goto|goto
name|release
goto|;
block|}
name|space
operator|-=
name|resid
operator|-
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
block|}
if|if
condition|(
name|dontroute
condition|)
block|{
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_options
operator||=
name|SO_DONTROUTE
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * XXX all the SBS_CANTSENDMORE checks previously 			 * done could be out of date.  We could have received 			 * a reset packet in an interrupt or maybe we slept 			 * while doing page faults in uiomove() etc.  We 			 * could probably recheck again inside the locking 			 * protection here, but there are probably other 			 * places that this also happens.  We must rethink 			 * this. 			 */
name|VNET_SO_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_send
call|)
argument_list|(
name|so
argument_list|,
operator|(
name|flags
operator|&
name|MSG_OOB
operator|)
condition|?
name|PRUS_OOB
else|:
comment|/* 			 * If the user set MSG_EOF, the protocol understands 			 * this flag and nothing left to send then use 			 * PRU_SEND_EOF instead of PRU_SEND. 			 */
operator|(
operator|(
name|flags
operator|&
name|MSG_EOF
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_IMPLOPCL
operator|)
operator|&&
operator|(
name|resid
operator|<=
literal|0
operator|)
operator|)
condition|?
name|PRUS_EOF
else|:
comment|/* If there is more to send set PRUS_MORETOCOME. */
operator|(
name|flags
operator|&
name|MSG_MORETOCOME
operator|)
operator|||
operator|(
name|resid
operator|>
literal|0
operator|&&
name|space
operator|>
literal|0
operator|)
condition|?
name|PRUS_MORETOCOME
else|:
literal|0
argument_list|,
name|top
argument_list|,
name|addr
argument_list|,
name|control
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|dontroute
condition|)
block|{
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_options
operator|&=
operator|~
name|SO_DONTROUTE
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|clen
operator|=
literal|0
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
name|top
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|release
goto|;
block|}
do|while
condition|(
name|resid
operator|&&
name|space
operator|>
literal|0
condition|)
do|;
block|}
do|while
condition|(
name|resid
condition|)
do|;
name|release
label|:
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|top
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|int
name|sosend
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
name|top
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|CURVNET_SET
argument_list|(
name|so
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|)
name|error
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_sosend
argument_list|(
name|so
argument_list|,
name|addr
argument_list|,
name|uio
argument_list|,
name|top
argument_list|,
name|control
argument_list|,
name|flags
argument_list|,
name|td
argument_list|)
expr_stmt|;
else|else
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTCONN
expr_stmt|;
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * The part of soreceive() that implements reading non-inline out-of-band  * data from a socket.  For more complete comments, see soreceive(), from  * which this code originated.  *  * Note that soreceive_rcvoob(), unlike the remainder of soreceive(), is  * unable to return an mbuf chain to the caller.  */
specifier|static
name|int
name|soreceive_rcvoob
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|protosw
modifier|*
name|pr
init|=
name|so
operator|->
name|so_proto
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|flags
operator|&
name|MSG_OOB
argument_list|,
operator|(
literal|"soreceive_rcvoob: (flags& MSG_OOB) == 0"
operator|)
argument_list|)
expr_stmt|;
name|VNET_SO_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_get
argument_list|(
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|pr
operator|->
name|pr_usrreqs
operator|->
name|pru_rcvoob
call|)
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|flags
operator|&
name|MSG_PEEK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
do|do
block|{
name|error
operator|=
name|uiomove
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|min
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|uio
operator|->
name|uio_resid
operator|&&
name|error
operator|==
literal|0
operator|&&
name|m
condition|)
do|;
name|bad
label|:
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * Following replacement or removal of the first mbuf on the first mbuf chain  * of a socket buffer, push necessary state changes back into the socket  * buffer so that other consumers see the values consistently.  'nextrecord'  * is the callers locally stored value of the original value of  * sb->sb_mb->m_nextpkt which must be restored when the lead mbuf changes.  * NOTE: 'nextrecord' may be NULL.  */
specifier|static
name|__inline
name|void
name|sockbuf_pushsync
parameter_list|(
name|struct
name|sockbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|nextrecord
parameter_list|)
block|{
name|SOCKBUF_LOCK_ASSERT
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|/* 	 * First, update for the new value of nextrecord.  If necessary, make 	 * it the first record. 	 */
if|if
condition|(
name|sb
operator|->
name|sb_mb
operator|!=
name|NULL
condition|)
name|sb
operator|->
name|sb_mb
operator|->
name|m_nextpkt
operator|=
name|nextrecord
expr_stmt|;
else|else
name|sb
operator|->
name|sb_mb
operator|=
name|nextrecord
expr_stmt|;
comment|/* 	 * Now update any dependent socket buffer fields to reflect the new 	 * state.  This is an expanded inline of SB_EMPTY_FIXUP(), with the 	 * addition of a second clause that takes care of the case where 	 * sb_mb has been updated, but remains the last record. 	 */
if|if
condition|(
name|sb
operator|->
name|sb_mb
operator|==
name|NULL
condition|)
block|{
name|sb
operator|->
name|sb_mbtail
operator|=
name|NULL
expr_stmt|;
name|sb
operator|->
name|sb_lastrecord
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sb
operator|->
name|sb_mb
operator|->
name|m_nextpkt
operator|==
name|NULL
condition|)
name|sb
operator|->
name|sb_lastrecord
operator|=
name|sb
operator|->
name|sb_mb
expr_stmt|;
block|}
comment|/*  * Implement receive operations on a socket.  We depend on the way that  * records are added to the sockbuf by sbappend.  In particular, each record  * (mbufs linked through m_next) must begin with an address if the protocol  * so specifies, followed by an optional mbuf or mbufs containing ancillary  * data, and then zero or more mbufs of data.  In order to allow parallelism  * between network receive and copying to user space, as well as avoid  * sleeping with a mutex held, we release the socket buffer mutex during the  * user space copy.  Although the sockbuf is locked, new data may still be  * appended, and thus we must maintain consistency of the sockbuf during that  * time.  *  * The caller may receive the data as a single mbuf chain by supplying an  * mbuf **mp0 for use in returning the chain.  The uio is then used only for  * the count in uio_resid.  */
name|int
name|soreceive_generic
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|psa
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp0
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|controlp
parameter_list|,
name|int
modifier|*
name|flagsp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|error
decl_stmt|,
name|offset
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|struct
name|protosw
modifier|*
name|pr
init|=
name|so
operator|->
name|so_proto
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|nextrecord
decl_stmt|;
name|int
name|moff
decl_stmt|,
name|type
init|=
literal|0
decl_stmt|;
name|ssize_t
name|orig_resid
init|=
name|uio
operator|->
name|uio_resid
decl_stmt|;
name|mp
operator|=
name|mp0
expr_stmt|;
if|if
condition|(
name|psa
operator|!=
name|NULL
condition|)
operator|*
name|psa
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
operator|*
name|controlp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|flagsp
operator|!=
name|NULL
condition|)
name|flags
operator|=
operator|*
name|flagsp
operator|&
operator|~
name|MSG_EOR
expr_stmt|;
else|else
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MSG_OOB
condition|)
return|return
operator|(
name|soreceive_rcvoob
argument_list|(
name|so
argument_list|,
name|uio
argument_list|,
name|flags
argument_list|)
operator|)
return|;
if|if
condition|(
name|mp
operator|!=
name|NULL
condition|)
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|pr
operator|->
name|pr_flags
operator|&
name|PR_WANTRCVD
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONFIRMING
operator|)
operator|&&
name|uio
operator|->
name|uio_resid
condition|)
block|{
name|VNET_SO_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pr
operator|->
name|pr_usrreqs
operator|->
name|pru_rcvd
call|)
argument_list|(
name|so
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|sblock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|SBLOCKWAIT
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|restart
label|:
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
comment|/* 	 * If we have less data than requested, block awaiting more (subject 	 * to any timeout) if: 	 *   1. the current count is less than the low water mark, or 	 *   2. MSG_DONTWAIT is not set 	 */
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
operator|(
operator|(
operator|(
name|flags
operator|&
name|MSG_DONTWAIT
operator|)
operator|==
literal|0
operator|&&
name|sbavail
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
operator|<
name|uio
operator|->
name|uio_resid
operator|)
operator|&&
name|sbavail
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
operator|<
name|so
operator|->
name|so_rcv
operator|.
name|sb_lowat
operator|&&
name|m
operator|->
name|m_nextpkt
operator|==
name|NULL
operator|&&
operator|(
name|pr
operator|->
name|pr_flags
operator|&
name|PR_ATOMIC
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|KASSERT
argument_list|(
name|m
operator|!=
name|NULL
operator|||
operator|!
name|sbavail
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
argument_list|,
operator|(
literal|"receive: m == %p sbavail == %u"
operator|,
name|m
operator|,
name|sbavail
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
goto|goto
name|dontblock
goto|;
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
goto|goto
name|release
goto|;
block|}
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
goto|goto
name|release
goto|;
block|}
else|else
goto|goto
name|dontblock
goto|;
block|}
for|for
control|(
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
if|if
condition|(
name|m
operator|->
name|m_type
operator|==
name|MT_OOBDATA
operator|||
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EOR
operator|)
condition|)
block|{
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
goto|goto
name|dontblock
goto|;
block|}
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
operator|(
name|SS_ISCONNECTED
operator||
name|SS_ISCONNECTING
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
operator|)
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|)
operator|||
operator|(
name|flags
operator|&
operator|(
name|MSG_DONTWAIT
operator||
name|MSG_NBIO
operator|)
operator|)
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
goto|goto
name|release
goto|;
block|}
name|SBLASTRECORDCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SBLASTMBUFCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|release
goto|;
goto|goto
name|restart
goto|;
block|}
name|dontblock
label|:
comment|/* 	 * From this point onward, we maintain 'nextrecord' as a cache of the 	 * pointer to the next record in the socket buffer.  We must keep the 	 * various socket buffer pointers and local stack versions of the 	 * pointers in sync, pushing out modifications before dropping the 	 * socket buffer mutex, and re-reading them when picking it up. 	 * 	 * Otherwise, we will race with the network stack appending new data 	 * or records onto the socket buffer by using inconsistent/stale 	 * versions of the field, possibly resulting in socket buffer 	 * corruption. 	 * 	 * By holding the high-level sblock(), we prevent simultaneous 	 * readers from pulling off the front of the socket buffer. 	 */
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_td
condition|)
name|uio
operator|->
name|uio_td
operator|->
name|td_ru
operator|.
name|ru_msgrcv
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|,
operator|(
literal|"soreceive: m != so->so_rcv.sb_mb"
operator|)
argument_list|)
expr_stmt|;
name|SBLASTRECORDCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SBLASTMBUFCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|nextrecord
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|pr_flags
operator|&
name|PR_ADDR
condition|)
block|{
name|KASSERT
argument_list|(
name|m
operator|->
name|m_type
operator|==
name|MT_SONAME
argument_list|,
operator|(
literal|"m->m_type == %d"
operator|,
name|m
operator|->
name|m_type
operator|)
argument_list|)
expr_stmt|;
name|orig_resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|psa
operator|!=
name|NULL
condition|)
operator|*
name|psa
operator|=
name|sodupsockaddr
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sockaddr
operator|*
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MSG_PEEK
condition|)
block|{
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
else|else
block|{
name|sbfree
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
name|sockbuf_pushsync
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|nextrecord
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Process one or more MT_CONTROL mbufs present before any data mbufs 	 * in the first mbuf chain on the socket buffer.  If MSG_PEEK, we 	 * just copy the data; if !MSG_PEEK, we call into the protocol to 	 * perform externalization (or freeing if controlp == NULL). 	 */
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|m
operator|->
name|m_type
operator|==
name|MT_CONTROL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|cm
init|=
name|NULL
decl_stmt|,
modifier|*
name|cmn
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|cme
init|=
operator|&
name|cm
decl_stmt|;
do|do
block|{
if|if
condition|(
name|flags
operator|&
name|MSG_PEEK
condition|)
block|{
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|controlp
operator|=
name|m_copym
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|controlp
operator|=
operator|&
operator|(
operator|*
name|controlp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
else|else
block|{
name|sbfree
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
operator|*
name|cme
operator|=
name|m
expr_stmt|;
name|cme
operator|=
operator|&
operator|(
operator|*
name|cme
operator|)
operator|->
name|m_next
expr_stmt|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
block|}
block|}
do|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|m
operator|->
name|m_type
operator|==
name|MT_CONTROL
condition|)
do|;
if|if
condition|(
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
name|sockbuf_pushsync
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|nextrecord
argument_list|)
expr_stmt|;
while|while
condition|(
name|cm
operator|!=
name|NULL
condition|)
block|{
name|cmn
operator|=
name|cm
operator|->
name|m_next
expr_stmt|;
name|cm
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|pr_domain
operator|->
name|dom_externalize
operator|!=
name|NULL
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|VNET_SO_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|pr
operator|->
name|pr_domain
operator|->
name|dom_externalize
call|)
argument_list|(
name|cm
argument_list|,
name|controlp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
operator|*
name|controlp
operator|=
name|cm
expr_stmt|;
else|else
name|m_freem
argument_list|(
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
block|{
name|orig_resid
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|controlp
operator|!=
name|NULL
condition|)
name|controlp
operator|=
operator|&
operator|(
operator|*
name|controlp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
name|cm
operator|=
name|cmn
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|nextrecord
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|->
name|m_nextpkt
expr_stmt|;
else|else
name|nextrecord
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
name|orig_resid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|m
operator|->
name|m_nextpkt
operator|==
name|nextrecord
argument_list|,
operator|(
literal|"soreceive: post-control, nextrecord !sync"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextrecord
operator|==
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|==
name|m
argument_list|,
operator|(
literal|"soreceive: post-control, sb_mb!=m"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_lastrecord
operator|==
name|m
argument_list|,
operator|(
literal|"soreceive: post-control, lastrecord!=m"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|type
operator|=
name|m
operator|->
name|m_type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|MT_OOBDATA
condition|)
name|flags
operator||=
name|MSG_OOB
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|==
name|nextrecord
argument_list|,
operator|(
literal|"soreceive: sb_mb != nextrecord"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|==
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_lastrecord
operator|==
name|NULL
argument_list|,
operator|(
literal|"soreceive: sb_lastercord != NULL"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SBLASTRECORDCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SBLASTMBUFCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* 	 * Now continue to read any data mbufs off of the head of the socket 	 * buffer until the read request is satisfied.  Note that 'type' is 	 * used to store the type of any mbuf reads that have happened so far 	 * such that soreceive() can stop reading if the type changes, which 	 * causes soreceive() to return only one of regular data and inline 	 * out-of-band data in a single socket receive operation. 	 */
name|moff
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_NOTAVAIL
operator|)
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If the type of mbuf has changed since the last mbuf 		 * examined ('type'), end the receive operation. 		 */
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_type
operator|==
name|MT_OOBDATA
operator|||
name|m
operator|->
name|m_type
operator|==
name|MT_CONTROL
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|m
operator|->
name|m_type
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|MT_OOBDATA
condition|)
break|break;
else|else
name|KASSERT
argument_list|(
name|m
operator|->
name|m_type
operator|==
name|MT_DATA
argument_list|,
operator|(
literal|"m->m_type == %d"
operator|,
name|m
operator|->
name|m_type
operator|)
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&=
operator|~
name|SBS_RCVATMARK
expr_stmt|;
name|len
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_oobmark
operator|&&
name|len
operator|>
name|so
operator|->
name|so_oobmark
operator|-
name|offset
condition|)
name|len
operator|=
name|so
operator|->
name|so_oobmark
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|m
operator|->
name|m_len
operator|-
name|moff
condition|)
name|len
operator|=
name|m
operator|->
name|m_len
operator|-
name|moff
expr_stmt|;
comment|/* 		 * If mp is set, just pass back the mbufs.  Otherwise copy 		 * them out via the uio, then free.  Sockbuf must be 		 * consistent here (points to current mbuf, it points to next 		 * record) when we drop priority; we must note any additions 		 * to the sockbuf when we block interrupts again. 		 */
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
block|{
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SBLASTRECORDCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SBLASTMBUFCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|moff
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 				 * The MT_SONAME mbuf has already been removed 				 * from the record, so it is necessary to 				 * remove the data mbufs, if any, to preserve 				 * the invariant in the case of PR_ADDR that 				 * requires MT_SONAME mbufs at the head of 				 * each record. 				 */
if|if
condition|(
name|pr
operator|->
name|pr_flags
operator|&
name|PR_ATOMIC
operator|&&
operator|(
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
operator|)
condition|)
operator|(
name|void
operator|)
name|sbdroprecord_locked
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
goto|goto
name|release
goto|;
block|}
block|}
else|else
name|uio
operator|->
name|uio_resid
operator|-=
name|len
expr_stmt|;
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|m
operator|->
name|m_len
operator|-
name|moff
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EOR
condition|)
name|flags
operator||=
name|MSG_EOR
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MSG_PEEK
condition|)
block|{
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|moff
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|nextrecord
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|sbfree
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|!=
name|NULL
condition|)
block|{
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
block|}
name|sockbuf_pushsync
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|nextrecord
argument_list|)
expr_stmt|;
name|SBLASTRECORDCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SBLASTMBUFCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|MSG_PEEK
condition|)
name|moff
operator|+=
name|len
expr_stmt|;
else|else
block|{
if|if
condition|(
name|mp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|MSG_DONTWAIT
condition|)
block|{
operator|*
name|mp
operator|=
name|m_copym
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
block|{
comment|/* 							 * m_copym() couldn't 							 * allocate an mbuf. 							 * Adjust uio_resid back 							 * (it was adjusted 							 * down by len bytes, 							 * which we didn't end 							 * up "copying" over). 							 */
name|uio
operator|->
name|uio_resid
operator|+=
name|len
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|m_copym
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
block|}
name|sbcut_locked
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_oobmark
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
block|{
name|so
operator|->
name|so_oobmark
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_oobmark
operator|==
literal|0
condition|)
block|{
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator||=
name|SBS_RCVATMARK
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|offset
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|so
operator|->
name|so_oobmark
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|MSG_EOR
condition|)
break|break;
comment|/* 		 * If the MSG_WAITALL flag is set (for non-atomic socket), we 		 * must not quit until "uio->uio_resid == 0" or an error 		 * termination.  If a signal/timeout occurs, return with a 		 * short count but without error.  Keep sockbuf locked 		 * against other readers. 		 */
while|while
condition|(
name|flags
operator|&
name|MSG_WAITALL
operator|&&
name|m
operator|==
name|NULL
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
operator|!
name|sosendallatonce
argument_list|(
name|so
argument_list|)
operator|&&
name|nextrecord
operator|==
name|NULL
condition|)
block|{
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_error
operator|||
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
break|break;
comment|/* 			 * Notify the protocol that some data has been 			 * drained before blocking. 			 */
if|if
condition|(
name|pr
operator|->
name|pr_flags
operator|&
name|PR_WANTRCVD
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|VNET_SO_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pr
operator|->
name|pr_usrreqs
operator|->
name|pru_rcvd
call|)
argument_list|(
name|so
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
name|SBLASTRECORDCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SBLASTMBUFCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* 			 * We could receive some data while was notifying 			 * the protocol. Skip blocking in this case. 			 */
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
goto|goto
name|release
goto|;
block|}
block|}
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|nextrecord
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
block|}
block|}
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|pr
operator|->
name|pr_flags
operator|&
name|PR_ATOMIC
condition|)
block|{
name|flags
operator||=
name|MSG_TRUNC
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|sbdroprecord_locked
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * First part is an inline SB_EMPTY_FIXUP().  Second 			 * part makes sure sb_lastrecord is up-to-date if 			 * there is still data in the socket buffer. 			 */
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|nextrecord
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|==
name|NULL
condition|)
block|{
name|so
operator|->
name|so_rcv
operator|.
name|sb_mbtail
operator|=
name|NULL
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_lastrecord
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextrecord
operator|->
name|m_nextpkt
operator|==
name|NULL
condition|)
name|so
operator|->
name|so_rcv
operator|.
name|sb_lastrecord
operator|=
name|nextrecord
expr_stmt|;
block|}
name|SBLASTRECORDCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SBLASTMBUFCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* 		 * If soreceive() is being done from the socket callback, 		 * then don't need to generate ACK to peer to update window, 		 * since ACK will be generated on return to TCP. 		 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|MSG_SOCALLBCK
operator|)
operator|&&
operator|(
name|pr
operator|->
name|pr_flags
operator|&
name|PR_WANTRCVD
operator|)
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|VNET_SO_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pr
operator|->
name|pr_usrreqs
operator|->
name|pru_rcvd
call|)
argument_list|(
name|so
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
block|}
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_resid
operator|==
name|uio
operator|->
name|uio_resid
operator|&&
name|orig_resid
operator|&&
operator|(
name|flags
operator|&
name|MSG_EOR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
operator|)
operator|==
literal|0
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|flagsp
operator|!=
name|NULL
condition|)
operator|*
name|flagsp
operator||=
name|flags
expr_stmt|;
name|release
label|:
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * Optimized version of soreceive() for stream (TCP) sockets.  * XXXAO: (MSG_WAITALL | MSG_PEEK) isn't properly handled.  */
name|int
name|soreceive_stream
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|psa
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp0
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|controlp
parameter_list|,
name|int
modifier|*
name|flagsp
parameter_list|)
block|{
name|int
name|len
init|=
literal|0
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|flags
decl_stmt|,
name|oresid
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
init|=
name|NULL
decl_stmt|;
comment|/* We only do stream sockets. */
if|if
condition|(
name|so
operator|->
name|so_type
operator|!=
name|SOCK_STREAM
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|psa
operator|!=
name|NULL
condition|)
operator|*
name|psa
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|flagsp
operator|!=
name|NULL
condition|)
name|flags
operator|=
operator|*
name|flagsp
operator|&
operator|~
name|MSG_EOR
expr_stmt|;
else|else
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MSG_OOB
condition|)
return|return
operator|(
name|soreceive_rcvoob
argument_list|(
name|so
argument_list|,
name|uio
argument_list|,
name|flags
argument_list|)
operator|)
return|;
if|if
condition|(
name|mp0
operator|!=
name|NULL
condition|)
operator|*
name|mp0
operator|=
name|NULL
expr_stmt|;
name|sb
operator|=
operator|&
name|so
operator|->
name|so_rcv
expr_stmt|;
comment|/* Prevent other readers from entering the socket. */
name|error
operator|=
name|sblock
argument_list|(
name|sb
argument_list|,
name|SBLOCKWAIT
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|/* Easy one, no space to copyout anything. */
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|oresid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
comment|/* We will never ever get anything unless we are or were connected. */
if|if
condition|(
operator|!
operator|(
name|so
operator|->
name|so_state
operator|&
operator|(
name|SS_ISCONNECTED
operator||
name|SS_ISDISCONNECTED
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|restart
label|:
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* Abort if socket has reported problems. */
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
if|if
condition|(
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|>
literal|0
condition|)
goto|goto
name|deliver
goto|;
if|if
condition|(
name|oresid
operator|>
name|uio
operator|->
name|uio_resid
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
condition|)
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Door is closed.  Deliver what is left, if any. */
if|if
condition|(
name|sb
operator|->
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
block|{
if|if
condition|(
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|>
literal|0
condition|)
goto|goto
name|deliver
goto|;
else|else
goto|goto
name|out
goto|;
block|}
comment|/* Socket buffer is empty and we shall not block. */
if|if
condition|(
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|)
operator|||
operator|(
name|flags
operator|&
operator|(
name|MSG_DONTWAIT
operator||
name|MSG_NBIO
operator|)
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Socket buffer got some data that we shall deliver now. */
if|if
condition|(
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|>
literal|0
operator|&&
operator|!
operator|(
name|flags
operator|&
name|MSG_WAITALL
operator|)
operator|&&
operator|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|)
operator|||
operator|(
name|flags
operator|&
operator|(
name|MSG_DONTWAIT
operator||
name|MSG_NBIO
operator|)
operator|)
operator|||
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|>=
name|sb
operator|->
name|sb_lowat
operator|||
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|>=
name|uio
operator|->
name|uio_resid
operator|||
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|>=
name|sb
operator|->
name|sb_hiwat
operator|)
condition|)
block|{
goto|goto
name|deliver
goto|;
block|}
comment|/* On MSG_WAITALL we must wait until all data or error arrives. */
if|if
condition|(
operator|(
name|flags
operator|&
name|MSG_WAITALL
operator|)
operator|&&
operator|(
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|>=
name|uio
operator|->
name|uio_resid
operator|||
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|>=
name|sb
operator|->
name|sb_hiwat
operator|)
condition|)
goto|goto
name|deliver
goto|;
comment|/* 	 * Wait and block until (more) data comes in. 	 * NB: Drops the sockbuf lock during wait. 	 */
name|error
operator|=
name|sbwait
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
goto|goto
name|restart
goto|;
name|deliver
label|:
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: sockbuf empty"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sb
operator|->
name|sb_mb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: sb_mb == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Statistics. */
if|if
condition|(
name|uio
operator|->
name|uio_td
condition|)
name|uio
operator|->
name|uio_td
operator|->
name|td_ru
operator|.
name|ru_msgrcv
operator|++
expr_stmt|;
comment|/* Fill uio until full or current end of socket buffer is reached. */
name|len
operator|=
name|min
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|sbavail
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp0
operator|!=
name|NULL
condition|)
block|{
comment|/* Dequeue as many mbufs as possible. */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
operator|&&
name|len
operator|>=
name|sb
operator|->
name|sb_mb
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
operator|*
name|mp0
operator|==
name|NULL
condition|)
operator|*
name|mp0
operator|=
name|sb
operator|->
name|sb_mb
expr_stmt|;
else|else
name|m_cat
argument_list|(
operator|*
name|mp0
argument_list|,
name|sb
operator|->
name|sb_mb
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|sb
operator|->
name|sb_mb
init|;
name|m
operator|!=
name|NULL
operator|&&
name|m
operator|->
name|m_len
operator|<=
name|len
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|KASSERT
argument_list|(
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_NOTAVAIL
operator|)
argument_list|,
operator|(
literal|"%s: m %p not available"
operator|,
name|__func__
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|len
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|sbfree
argument_list|(
name|sb
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|n
operator|=
name|m
expr_stmt|;
block|}
name|n
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|sb
operator|->
name|sb_mb
operator|=
name|m
expr_stmt|;
name|sb
operator|->
name|sb_lastrecord
operator|=
name|sb
operator|->
name|sb_mb
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|sb_mb
operator|==
name|NULL
condition|)
name|SB_EMPTY_FIXUP
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
comment|/* Copy the remainder. */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|sb
operator|->
name|sb_mb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: len> 0&& sb->sb_mb empty"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_copym
argument_list|(
name|sb
operator|->
name|sb_mb
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|len
operator|=
literal|0
expr_stmt|;
comment|/* Don't flush data from sockbuf. */
else|else
name|uio
operator|->
name|uio_resid
operator|-=
name|len
expr_stmt|;
if|if
condition|(
operator|*
name|mp0
operator|!=
name|NULL
condition|)
name|m_cat
argument_list|(
operator|*
name|mp0
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|else
operator|*
name|mp0
operator|=
name|m
expr_stmt|;
if|if
condition|(
operator|*
name|mp0
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
else|else
block|{
comment|/* NB: Must unlock socket buffer as uiomove may sleep. */
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|error
operator|=
name|m_mbuftouio
argument_list|(
name|uio
argument_list|,
name|sb
operator|->
name|sb_mb
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
name|SBLASTRECORDCHK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|SBLASTMBUFCHK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|/* 	 * Remove the delivered data from the socket buffer unless we 	 * were only peeking. 	 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|sbdrop_locked
argument_list|(
name|sb
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Notify protocol that we drained some data. */
if|if
condition|(
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_WANTRCVD
operator|)
operator|&&
operator|(
operator|(
operator|(
name|flags
operator|&
name|MSG_WAITALL
operator|)
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|)
operator|||
operator|!
operator|(
name|flags
operator|&
name|MSG_SOCALLBCK
operator|)
operator|)
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|VNET_SO_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_rcvd
call|)
argument_list|(
name|so
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * For MSG_WAITALL we may have to loop again and wait for 	 * more data to come in. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|MSG_WAITALL
operator|)
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
goto|goto
name|restart
goto|;
name|out
label|:
name|SOCKBUF_LOCK_ASSERT
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|SBLASTRECORDCHK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|SBLASTMBUFCHK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbunlock
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * Optimized version of soreceive() for simple datagram cases from userspace.  * Unlike in the stream case, we're able to drop a datagram if copyout()  * fails, and because we handle datagrams atomically, we don't need to use a  * sleep lock to prevent I/O interlacing.  */
name|int
name|soreceive_dgram
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|psa
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp0
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|controlp
parameter_list|,
name|int
modifier|*
name|flagsp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m2
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|error
decl_stmt|;
name|ssize_t
name|len
decl_stmt|;
name|struct
name|protosw
modifier|*
name|pr
init|=
name|so
operator|->
name|so_proto
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|nextrecord
decl_stmt|;
if|if
condition|(
name|psa
operator|!=
name|NULL
condition|)
operator|*
name|psa
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
operator|*
name|controlp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|flagsp
operator|!=
name|NULL
condition|)
name|flags
operator|=
operator|*
name|flagsp
operator|&
operator|~
name|MSG_EOR
expr_stmt|;
else|else
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* 	 * For any complicated cases, fall back to the full 	 * soreceive_generic(). 	 */
if|if
condition|(
name|mp0
operator|!=
name|NULL
operator|||
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
operator|||
operator|(
name|flags
operator|&
name|MSG_OOB
operator|)
condition|)
return|return
operator|(
name|soreceive_generic
argument_list|(
name|so
argument_list|,
name|psa
argument_list|,
name|uio
argument_list|,
name|mp0
argument_list|,
name|controlp
argument_list|,
name|flagsp
argument_list|)
operator|)
return|;
comment|/* 	 * Enforce restrictions on use. 	 */
name|KASSERT
argument_list|(
operator|(
name|pr
operator|->
name|pr_flags
operator|&
name|PR_WANTRCVD
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"soreceive_dgram: wantrcvd"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pr
operator|->
name|pr_flags
operator|&
name|PR_ATOMIC
argument_list|,
operator|(
literal|"soreceive_dgram: !atomic"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_RCVATMARK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"soreceive_dgram: SBS_RCVATMARK"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"soreceive_dgram: P_CONNREQUIRED"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Loop blocking while waiting for a datagram. 	 */
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|)
operator|==
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|sbavail
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"soreceive_dgram: sb_mb NULL but sbavail %u"
operator|,
name|sbavail
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
operator|||
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|)
operator|||
operator|(
name|flags
operator|&
operator|(
name|MSG_DONTWAIT
operator||
name|MSG_NBIO
operator|)
operator|)
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
block|}
name|SBLASTRECORDCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SBLASTMBUFCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_td
condition|)
name|uio
operator|->
name|uio_td
operator|->
name|td_ru
operator|.
name|ru_msgrcv
operator|++
expr_stmt|;
name|SBLASTRECORDCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SBLASTMBUFCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|nextrecord
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
if|if
condition|(
name|nextrecord
operator|==
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_lastrecord
operator|==
name|m
argument_list|,
operator|(
literal|"soreceive_dgram: lastrecord != m"
operator|)
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|->
name|m_nextpkt
operator|==
name|nextrecord
argument_list|,
operator|(
literal|"soreceive_dgram: m_nextpkt != nextrecord"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Pull 'm' and its chain off the front of the packet queue. 	 */
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|NULL
expr_stmt|;
name|sockbuf_pushsync
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|nextrecord
argument_list|)
expr_stmt|;
comment|/* 	 * Walk 'm's chain and free that many bytes from the socket buffer. 	 */
for|for
control|(
name|m2
operator|=
name|m
init|;
name|m2
operator|!=
name|NULL
condition|;
name|m2
operator|=
name|m2
operator|->
name|m_next
control|)
name|sbfree
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|/* 	 * Do a few last checks before we let go of the lock. 	 */
name|SBLASTRECORDCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SBLASTMBUFCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|pr_flags
operator|&
name|PR_ADDR
condition|)
block|{
name|KASSERT
argument_list|(
name|m
operator|->
name|m_type
operator|==
name|MT_SONAME
argument_list|,
operator|(
literal|"m->m_type == %d"
operator|,
name|m
operator|->
name|m_type
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|psa
operator|!=
name|NULL
condition|)
operator|*
name|psa
operator|=
name|sodupsockaddr
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sockaddr
operator|*
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* XXXRW: Can this happen? */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Packet to copyout() is now in 'm' and it is disconnected from the 	 * queue. 	 * 	 * Process one or more MT_CONTROL mbufs present before any data mbufs 	 * in the first mbuf chain on the socket buffer.  We call into the 	 * protocol to perform externalization (or freeing if controlp == 	 * NULL). In some cases there can be only MT_CONTROL mbufs without 	 * MT_DATA mbufs. 	 */
if|if
condition|(
name|m
operator|->
name|m_type
operator|==
name|MT_CONTROL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|cm
init|=
name|NULL
decl_stmt|,
modifier|*
name|cmn
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|cme
init|=
operator|&
name|cm
decl_stmt|;
do|do
block|{
name|m2
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
operator|*
name|cme
operator|=
name|m
expr_stmt|;
name|cme
operator|=
operator|&
operator|(
operator|*
name|cme
operator|)
operator|->
name|m_next
expr_stmt|;
name|m
operator|=
name|m2
expr_stmt|;
block|}
do|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|m
operator|->
name|m_type
operator|==
name|MT_CONTROL
condition|)
do|;
while|while
condition|(
name|cm
operator|!=
name|NULL
condition|)
block|{
name|cmn
operator|=
name|cm
operator|->
name|m_next
expr_stmt|;
name|cm
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|pr_domain
operator|->
name|dom_externalize
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
call|(
modifier|*
name|pr
operator|->
name|pr_domain
operator|->
name|dom_externalize
call|)
argument_list|(
name|cm
argument_list|,
name|controlp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
operator|*
name|controlp
operator|=
name|cm
expr_stmt|;
else|else
name|m_freem
argument_list|(
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|*
name|controlp
operator|!=
name|NULL
condition|)
name|controlp
operator|=
operator|&
operator|(
operator|*
name|controlp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
name|cm
operator|=
name|cmn
expr_stmt|;
block|}
block|}
name|KASSERT
argument_list|(
name|m
operator|==
name|NULL
operator|||
name|m
operator|->
name|m_type
operator|==
name|MT_DATA
argument_list|,
operator|(
literal|"soreceive_dgram: !data"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|m
operator|->
name|m_len
condition|)
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|==
name|m
operator|->
name|m_len
condition|)
name|m
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|else
block|{
name|m
operator|->
name|m_data
operator|+=
name|len
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|len
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|flags
operator||=
name|MSG_TRUNC
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flagsp
operator|!=
name|NULL
condition|)
operator|*
name|flagsp
operator||=
name|flags
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|int
name|soreceive
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|psa
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp0
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|controlp
parameter_list|,
name|int
modifier|*
name|flagsp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|CURVNET_SET
argument_list|(
name|so
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|)
name|error
operator|=
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_soreceive
argument_list|(
name|so
argument_list|,
name|psa
argument_list|,
name|uio
argument_list|,
name|mp0
argument_list|,
name|controlp
argument_list|,
name|flagsp
argument_list|)
operator|)
expr_stmt|;
else|else
name|error
operator|=
name|ENOTCONN
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|int
name|soshutdown
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|how
parameter_list|)
block|{
name|struct
name|protosw
modifier|*
name|pr
init|=
name|so
operator|->
name|so_proto
decl_stmt|;
name|int
name|error
decl_stmt|,
name|soerror_enotconn
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|how
operator|==
name|SHUT_RD
operator|||
name|how
operator|==
name|SHUT_WR
operator|||
name|how
operator|==
name|SHUT_RDWR
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|soerror_enotconn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
operator|(
name|SS_ISCONNECTED
operator||
name|SS_ISCONNECTING
operator||
name|SS_ISDISCONNECTING
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * POSIX mandates us to return ENOTCONN when shutdown(2) is 		 * invoked on a datagram sockets, however historically we would 		 * actually tear socket down. This is known to be leveraged by 		 * some applications to unblock process waiting in recvXXX(2) 		 * by other process that it shares that socket with. Try to meet 		 * both backward-compatibility and POSIX requirements by forcing 		 * ENOTCONN but still asking protocol to perform pru_shutdown(). 		 */
if|if
condition|(
name|so
operator|->
name|so_type
operator|!=
name|SOCK_DGRAM
condition|)
return|return
operator|(
name|ENOTCONN
operator|)
return|;
name|soerror_enotconn
operator|=
literal|1
expr_stmt|;
block|}
name|CURVNET_SET
argument_list|(
name|so
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|pr_usrreqs
operator|->
name|pru_flush
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|pr
operator|->
name|pr_usrreqs
operator|->
name|pru_flush
call|)
argument_list|(
name|so
argument_list|,
name|how
argument_list|)
expr_stmt|;
if|if
condition|(
name|how
operator|!=
name|SHUT_WR
condition|)
name|sorflush
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|how
operator|!=
name|SHUT_RD
condition|)
block|{
name|error
operator|=
call|(
modifier|*
name|pr
operator|->
name|pr_usrreqs
operator|->
name|pru_shutdown
call|)
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|so
operator|->
name|so_timeo
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
operator|(
name|error
operator|==
literal|0
operator|&&
name|soerror_enotconn
operator|)
condition|?
name|ENOTCONN
else|:
name|error
operator|)
return|;
block|}
name|wakeup
argument_list|(
operator|&
name|so
operator|->
name|so_timeo
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|soerror_enotconn
condition|?
name|ENOTCONN
else|:
literal|0
operator|)
return|;
block|}
name|void
name|sorflush
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
name|so
operator|->
name|so_rcv
decl_stmt|;
name|struct
name|protosw
modifier|*
name|pr
init|=
name|so
operator|->
name|so_proto
decl_stmt|;
name|struct
name|socket
name|aso
decl_stmt|;
name|VNET_SO_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* 	 * In order to avoid calling dom_dispose with the socket buffer mutex 	 * held, and in order to generally avoid holding the lock for a long 	 * time, we make a copy of the socket buffer and clear the original 	 * (except locks, state).  The new socket buffer copy won't have 	 * initialized locks so we can only call routines that won't use or 	 * assert those locks. 	 * 	 * Dislodge threads currently blocked in receive and wait to acquire 	 * a lock against other simultaneous readers before clearing the 	 * socket buffer.  Don't let our acquire be interrupted by a signal 	 * despite any existing socket disposition on interruptable waiting. 	 */
name|socantrcvmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sblock
argument_list|(
name|sb
argument_list|,
name|SBL_WAIT
operator||
name|SBL_NOINTR
argument_list|)
expr_stmt|;
comment|/* 	 * Invalidate/clear most of the sockbuf structure, but leave selinfo 	 * and mutex data unchanged. 	 */
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|aso
argument_list|,
sizeof|sizeof
argument_list|(
name|aso
argument_list|)
argument_list|)
expr_stmt|;
name|aso
operator|.
name|so_pcb
operator|=
name|so
operator|->
name|so_pcb
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sb
operator|->
name|sb_startzero
argument_list|,
operator|&
name|aso
operator|.
name|so_rcv
operator|.
name|sb_startzero
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sb
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|sockbuf
argument_list|,
name|sb_startzero
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sb
operator|->
name|sb_startzero
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sb
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|sockbuf
argument_list|,
name|sb_startzero
argument_list|)
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbunlock
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|/* 	 * Dispose of special rights and flush the copied socket.  Don't call 	 * any unsafe routines (that rely on locks being initialized) on aso. 	 */
if|if
condition|(
name|pr
operator|->
name|pr_flags
operator|&
name|PR_RIGHTS
operator|&&
name|pr
operator|->
name|pr_domain
operator|->
name|dom_dispose
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|pr
operator|->
name|pr_domain
operator|->
name|dom_dispose
call|)
argument_list|(
operator|&
name|aso
argument_list|)
expr_stmt|;
name|sbrelease_internal
argument_list|(
operator|&
name|aso
operator|.
name|so_rcv
argument_list|,
name|so
argument_list|)
expr_stmt|;
block|}
comment|/*  * Wrapper for Socket established helper hook.  * Parameters: socket, context of the hook point, hook id.  */
specifier|static
name|int
specifier|inline
name|hhook_run_socket
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|void
modifier|*
name|hctx
parameter_list|,
name|int32_t
name|h_id
parameter_list|)
block|{
name|struct
name|socket_hhook_data
name|hhook_data
init|=
block|{
operator|.
name|so
operator|=
name|so
block|,
operator|.
name|hctx
operator|=
name|hctx
block|,
operator|.
name|m
operator|=
name|NULL
block|,
operator|.
name|status
operator|=
literal|0
block|}
decl_stmt|;
name|CURVNET_SET
argument_list|(
name|so
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
name|HHOOKS_RUN_IF
argument_list|(
name|V_socket_hhh
index|[
name|h_id
index|]
argument_list|,
operator|&
name|hhook_data
argument_list|,
operator|&
name|so
operator|->
name|osd
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
comment|/* Ugly but needed, since hhooks return void for now */
return|return
operator|(
name|hhook_data
operator|.
name|status
operator|)
return|;
block|}
comment|/*  * Perhaps this routine, and sooptcopyout(), below, ought to come in an  * additional variant to handle the case where the option value needs to be  * some kind of integer, but not a specific size.  In addition to their use  * here, these functions are also called by the protocol-level pr_ctloutput()  * routines.  */
name|int
name|sooptcopyin
parameter_list|(
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|size_t
name|minlen
parameter_list|)
block|{
name|size_t
name|valsize
decl_stmt|;
comment|/* 	 * If the user gives us more than we wanted, we ignore it, but if we 	 * don't get the minimum length the caller wants, we return EINVAL. 	 * On success, sopt->sopt_valsize is set to however much we actually 	 * retrieved. 	 */
if|if
condition|(
operator|(
name|valsize
operator|=
name|sopt
operator|->
name|sopt_valsize
operator|)
operator|<
name|minlen
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|valsize
operator|>
name|len
condition|)
name|sopt
operator|->
name|sopt_valsize
operator|=
name|valsize
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_td
operator|!=
name|NULL
condition|)
return|return
operator|(
name|copyin
argument_list|(
name|sopt
operator|->
name|sopt_val
argument_list|,
name|buf
argument_list|,
name|valsize
argument_list|)
operator|)
return|;
name|bcopy
argument_list|(
name|sopt
operator|->
name|sopt_val
argument_list|,
name|buf
argument_list|,
name|valsize
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Kernel version of setsockopt(2).  *  * XXX: optlen is size_t, not socklen_t  */
name|int
name|so_setsockopt
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|optname
parameter_list|,
name|void
modifier|*
name|optval
parameter_list|,
name|size_t
name|optlen
parameter_list|)
block|{
name|struct
name|sockopt
name|sopt
decl_stmt|;
name|sopt
operator|.
name|sopt_level
operator|=
name|level
expr_stmt|;
name|sopt
operator|.
name|sopt_name
operator|=
name|optname
expr_stmt|;
name|sopt
operator|.
name|sopt_dir
operator|=
name|SOPT_SET
expr_stmt|;
name|sopt
operator|.
name|sopt_val
operator|=
name|optval
expr_stmt|;
name|sopt
operator|.
name|sopt_valsize
operator|=
name|optlen
expr_stmt|;
name|sopt
operator|.
name|sopt_td
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|sosetopt
argument_list|(
name|so
argument_list|,
operator|&
name|sopt
argument_list|)
operator|)
return|;
block|}
name|int
name|sosetopt
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|optval
decl_stmt|;
name|struct
name|linger
name|l
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|sbintime_t
name|val
decl_stmt|;
name|uint32_t
name|val32
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|struct
name|mac
name|extmac
decl_stmt|;
endif|#
directive|endif
name|CURVNET_SET
argument_list|(
name|so
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_level
operator|!=
name|SOL_SOCKET
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_ctloutput
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_ctloutput
call|)
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|SO_ACCEPTFILTER
case|:
name|error
operator|=
name|accept_filt_setopt
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
break|break;
case|case
name|SO_LINGER
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|l
argument_list|,
sizeof|sizeof
name|l
argument_list|,
sizeof|sizeof
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_linger
operator|=
name|l
operator|.
name|l_linger
expr_stmt|;
if|if
condition|(
name|l
operator|.
name|l_onoff
condition|)
name|so
operator|->
name|so_options
operator||=
name|SO_LINGER
expr_stmt|;
else|else
name|so
operator|->
name|so_options
operator|&=
operator|~
name|SO_LINGER
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
break|break;
case|case
name|SO_DEBUG
case|:
case|case
name|SO_KEEPALIVE
case|:
case|case
name|SO_DONTROUTE
case|:
case|case
name|SO_USELOOPBACK
case|:
case|case
name|SO_BROADCAST
case|:
case|case
name|SO_REUSEADDR
case|:
case|case
name|SO_REUSEPORT
case|:
case|case
name|SO_OOBINLINE
case|:
case|case
name|SO_TIMESTAMP
case|:
case|case
name|SO_BINTIME
case|:
case|case
name|SO_NOSIGPIPE
case|:
case|case
name|SO_NO_DDP
case|:
case|case
name|SO_NO_OFFLOAD
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|optval
condition|)
name|so
operator|->
name|so_options
operator||=
name|sopt
operator|->
name|sopt_name
expr_stmt|;
else|else
name|so
operator|->
name|so_options
operator|&=
operator|~
name|sopt
operator|->
name|sopt_name
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
break|break;
case|case
name|SO_SETFIB
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|optval
operator|<
literal|0
operator|||
name|optval
operator|>=
name|rt_numfibs
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|->
name|dom_family
operator|==
name|PF_INET
operator|)
operator|||
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|->
name|dom_family
operator|==
name|PF_INET6
operator|)
operator|||
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|->
name|dom_family
operator|==
name|PF_ROUTE
operator|)
operator|)
condition|)
name|so
operator|->
name|so_fibnum
operator|=
name|optval
expr_stmt|;
else|else
name|so
operator|->
name|so_fibnum
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SO_USER_COOKIE
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|val32
argument_list|,
sizeof|sizeof
name|val32
argument_list|,
sizeof|sizeof
name|val32
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|so
operator|->
name|so_user_cookie
operator|=
name|val32
expr_stmt|;
break|break;
case|case
name|SO_SNDBUF
case|:
case|case
name|SO_RCVBUF
case|:
case|case
name|SO_SNDLOWAT
case|:
case|case
name|SO_RCVLOWAT
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
comment|/* 			 * Values< 1 make no sense for any of these options, 			 * so disallow them. 			 */
if|if
condition|(
name|optval
operator|<
literal|1
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|error
operator|=
name|sbsetopt
argument_list|(
name|so
argument_list|,
name|sopt
operator|->
name|sopt_name
argument_list|,
name|optval
argument_list|)
expr_stmt|;
break|break;
case|case
name|SO_SNDTIMEO
case|:
case|case
name|SO_RCVTIMEO
case|:
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
if|if
condition|(
name|SV_CURPROC_FLAG
argument_list|(
name|SV_ILP32
argument_list|)
condition|)
block|{
name|struct
name|timeval32
name|tv32
decl_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|tv32
argument_list|,
sizeof|sizeof
name|tv32
argument_list|,
sizeof|sizeof
name|tv32
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|tv32
argument_list|,
name|tv
argument_list|,
name|tv_sec
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|tv32
argument_list|,
name|tv
argument_list|,
name|tv_usec
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|tv
argument_list|,
sizeof|sizeof
name|tv
argument_list|,
sizeof|sizeof
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|<
literal|0
operator|||
name|tv
operator|.
name|tv_usec
operator|<
literal|0
operator|||
name|tv
operator|.
name|tv_usec
operator|>=
literal|1000000
condition|)
block|{
name|error
operator|=
name|EDOM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|>
name|INT32_MAX
condition|)
name|val
operator|=
name|SBT_MAX
expr_stmt|;
else|else
name|val
operator|=
name|tvtosbt
argument_list|(
name|tv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|SO_SNDTIMEO
case|:
name|so
operator|->
name|so_snd
operator|.
name|sb_timeo
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|SO_RCVTIMEO
case|:
name|so
operator|->
name|so_rcv
operator|.
name|sb_timeo
operator|=
name|val
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SO_LABEL
case|:
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|extmac
argument_list|,
sizeof|sizeof
name|extmac
argument_list|,
sizeof|sizeof
name|extmac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|error
operator|=
name|mac_setsockopt_label
argument_list|(
name|sopt
operator|->
name|sopt_td
operator|->
name|td_ucred
argument_list|,
name|so
argument_list|,
operator|&
name|extmac
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SO_TS_CLOCK
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|optval
operator|<
literal|0
operator|||
name|optval
operator|>
name|SO_TS_CLOCK_MAX
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|so
operator|->
name|so_ts_clock
operator|=
name|optval
expr_stmt|;
break|break;
case|case
name|SO_MAX_PACING_RATE
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|val32
argument_list|,
sizeof|sizeof
argument_list|(
name|val32
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|val32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|so
operator|->
name|so_max_pacing_rate
operator|=
name|val32
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|V_socket_hhh
index|[
name|HHOOK_SOCKET_OPT
index|]
operator|->
name|hhh_nhooks
operator|>
literal|0
condition|)
name|error
operator|=
name|hhook_run_socket
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|,
name|HHOOK_SOCKET_OPT
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|so
operator|->
name|so_proto
operator|->
name|pr_ctloutput
operator|!=
name|NULL
condition|)
call|(
name|void
call|)
argument_list|(
operator|*
name|so
operator|->
name|so_proto
operator|->
name|pr_ctloutput
argument_list|)
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
block|}
name|bad
label|:
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * Helper routine for getsockopt.  */
name|int
name|sooptcopyout
parameter_list|(
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|size_t
name|valsize
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Documented get behavior is that we always return a value, possibly 	 * truncated to fit in the user's buffer.  Traditional behavior is 	 * that we always tell the user precisely how much we copied, rather 	 * than something useful like the total amount we had available for 	 * her.  Note that this interface is not idempotent; the entire 	 * answer must be generated ahead of time. 	 */
name|valsize
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|sopt
operator|->
name|sopt_valsize
argument_list|)
expr_stmt|;
name|sopt
operator|->
name|sopt_valsize
operator|=
name|valsize
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_val
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sopt
operator|->
name|sopt_td
operator|!=
name|NULL
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|buf
argument_list|,
name|sopt
operator|->
name|sopt_val
argument_list|,
name|valsize
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|buf
argument_list|,
name|sopt
operator|->
name|sopt_val
argument_list|,
name|valsize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
name|int
name|sogetopt
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|optval
decl_stmt|;
name|struct
name|linger
name|l
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|struct
name|mac
name|extmac
decl_stmt|;
endif|#
directive|endif
name|CURVNET_SET
argument_list|(
name|so
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_level
operator|!=
name|SOL_SOCKET
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_ctloutput
operator|!=
name|NULL
condition|)
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_ctloutput
call|)
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|SO_ACCEPTFILTER
case|:
name|error
operator|=
name|accept_filt_getopt
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|SO_LINGER
case|:
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|l
operator|.
name|l_onoff
operator|=
name|so
operator|->
name|so_options
operator|&
name|SO_LINGER
expr_stmt|;
name|l
operator|.
name|l_linger
operator|=
name|so
operator|->
name|so_linger
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|l
argument_list|,
sizeof|sizeof
name|l
argument_list|)
expr_stmt|;
break|break;
case|case
name|SO_USELOOPBACK
case|:
case|case
name|SO_DONTROUTE
case|:
case|case
name|SO_DEBUG
case|:
case|case
name|SO_KEEPALIVE
case|:
case|case
name|SO_REUSEADDR
case|:
case|case
name|SO_REUSEPORT
case|:
case|case
name|SO_BROADCAST
case|:
case|case
name|SO_OOBINLINE
case|:
case|case
name|SO_ACCEPTCONN
case|:
case|case
name|SO_TIMESTAMP
case|:
case|case
name|SO_BINTIME
case|:
case|case
name|SO_NOSIGPIPE
case|:
name|optval
operator|=
name|so
operator|->
name|so_options
operator|&
name|sopt
operator|->
name|sopt_name
expr_stmt|;
name|integer
label|:
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
break|break;
case|case
name|SO_TYPE
case|:
name|optval
operator|=
name|so
operator|->
name|so_type
expr_stmt|;
goto|goto
name|integer
goto|;
case|case
name|SO_PROTOCOL
case|:
name|optval
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
expr_stmt|;
goto|goto
name|integer
goto|;
case|case
name|SO_ERROR
case|:
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|optval
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
goto|goto
name|integer
goto|;
case|case
name|SO_SNDBUF
case|:
name|optval
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
expr_stmt|;
goto|goto
name|integer
goto|;
case|case
name|SO_RCVBUF
case|:
name|optval
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
expr_stmt|;
goto|goto
name|integer
goto|;
case|case
name|SO_SNDLOWAT
case|:
name|optval
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_lowat
expr_stmt|;
goto|goto
name|integer
goto|;
case|case
name|SO_RCVLOWAT
case|:
name|optval
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_lowat
expr_stmt|;
goto|goto
name|integer
goto|;
case|case
name|SO_SNDTIMEO
case|:
case|case
name|SO_RCVTIMEO
case|:
name|tv
operator|=
name|sbttotv
argument_list|(
name|sopt
operator|->
name|sopt_name
operator|==
name|SO_SNDTIMEO
condition|?
name|so
operator|->
name|so_snd
operator|.
name|sb_timeo
else|:
name|so
operator|->
name|so_rcv
operator|.
name|sb_timeo
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
if|if
condition|(
name|SV_CURPROC_FLAG
argument_list|(
name|SV_ILP32
argument_list|)
condition|)
block|{
name|struct
name|timeval32
name|tv32
decl_stmt|;
name|CP
argument_list|(
name|tv
argument_list|,
name|tv32
argument_list|,
name|tv_sec
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|tv
argument_list|,
name|tv32
argument_list|,
name|tv_usec
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|tv32
argument_list|,
sizeof|sizeof
name|tv32
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|tv
argument_list|,
sizeof|sizeof
name|tv
argument_list|)
expr_stmt|;
break|break;
case|case
name|SO_LABEL
case|:
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|extmac
argument_list|,
sizeof|sizeof
argument_list|(
name|extmac
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|extmac
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|error
operator|=
name|mac_getsockopt_label
argument_list|(
name|sopt
operator|->
name|sopt_td
operator|->
name|td_ucred
argument_list|,
name|so
argument_list|,
operator|&
name|extmac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|extmac
argument_list|,
sizeof|sizeof
name|extmac
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SO_PEERLABEL
case|:
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|extmac
argument_list|,
sizeof|sizeof
argument_list|(
name|extmac
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|extmac
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|error
operator|=
name|mac_getsockopt_peerlabel
argument_list|(
name|sopt
operator|->
name|sopt_td
operator|->
name|td_ucred
argument_list|,
name|so
argument_list|,
operator|&
name|extmac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|extmac
argument_list|,
sizeof|sizeof
name|extmac
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SO_LISTENQLIMIT
case|:
name|optval
operator|=
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|?
name|so
operator|->
name|sol_qlimit
else|:
literal|0
expr_stmt|;
goto|goto
name|integer
goto|;
case|case
name|SO_LISTENQLEN
case|:
name|optval
operator|=
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|?
name|so
operator|->
name|sol_qlen
else|:
literal|0
expr_stmt|;
goto|goto
name|integer
goto|;
case|case
name|SO_LISTENINCQLEN
case|:
name|optval
operator|=
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|?
name|so
operator|->
name|sol_incqlen
else|:
literal|0
expr_stmt|;
goto|goto
name|integer
goto|;
case|case
name|SO_TS_CLOCK
case|:
name|optval
operator|=
name|so
operator|->
name|so_ts_clock
expr_stmt|;
goto|goto
name|integer
goto|;
case|case
name|SO_MAX_PACING_RATE
case|:
name|optval
operator|=
name|so
operator|->
name|so_max_pacing_rate
expr_stmt|;
goto|goto
name|integer
goto|;
default|default:
if|if
condition|(
name|V_socket_hhh
index|[
name|HHOOK_SOCKET_OPT
index|]
operator|->
name|hhh_nhooks
operator|>
literal|0
condition|)
name|error
operator|=
name|hhook_run_socket
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|,
name|HHOOK_SOCKET_OPT
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|MAC
name|bad
label|:
endif|#
directive|endif
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|int
name|soopt_getm
parameter_list|(
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m_prev
decl_stmt|;
name|int
name|sopt_size
init|=
name|sopt
operator|->
name|sopt_valsize
decl_stmt|;
name|MGET
argument_list|(
name|m
argument_list|,
name|sopt
operator|->
name|sopt_td
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|ENOBUFS
return|;
if|if
condition|(
name|sopt_size
operator|>
name|MLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|sopt
operator|->
name|sopt_td
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|MCLBYTES
argument_list|,
name|sopt_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|MLEN
argument_list|,
name|sopt_size
argument_list|)
expr_stmt|;
block|}
name|sopt_size
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|m_prev
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|sopt_size
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|sopt
operator|->
name|sopt_td
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
if|if
condition|(
name|sopt_size
operator|>
name|MLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|sopt
operator|->
name|sopt_td
operator|!=
name|NULL
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|MCLBYTES
argument_list|,
name|sopt_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|MLEN
argument_list|,
name|sopt_size
argument_list|)
expr_stmt|;
block|}
name|sopt_size
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|m_prev
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|m_prev
operator|=
name|m
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|int
name|soopt_mcopyin
parameter_list|(
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
init|=
name|m
decl_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_val
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|sopt
operator|->
name|sopt_valsize
operator|>=
name|m
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
name|sopt
operator|->
name|sopt_td
operator|!=
name|NULL
condition|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|sopt
operator|->
name|sopt_val
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
else|else
name|bcopy
argument_list|(
name|sopt
operator|->
name|sopt_val
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|sopt
operator|->
name|sopt_valsize
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|sopt
operator|->
name|sopt_val
operator|=
operator|(
name|char
operator|*
operator|)
name|sopt
operator|->
name|sopt_val
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
comment|/* should be allocated enoughly at ip6_sooptmcopyin() */
name|panic
argument_list|(
literal|"ip6_sooptmcopyin"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|int
name|soopt_mcopyout
parameter_list|(
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
init|=
name|m
decl_stmt|;
name|size_t
name|valsize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_val
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|sopt
operator|->
name|sopt_valsize
operator|>=
name|m
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
name|sopt
operator|->
name|sopt_td
operator|!=
name|NULL
condition|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|sopt
operator|->
name|sopt_val
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
else|else
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|sopt
operator|->
name|sopt_val
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|sopt
operator|->
name|sopt_valsize
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|sopt
operator|->
name|sopt_val
operator|=
operator|(
name|char
operator|*
operator|)
name|sopt
operator|->
name|sopt_val
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
name|valsize
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/* enough soopt buffer should be given from user-land */
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sopt
operator|->
name|sopt_valsize
operator|=
name|valsize
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * sohasoutofband(): protocol notifies socket layer of the arrival of new  * out-of-band data, which will then notify socket consumers.  */
name|void
name|sohasoutofband
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
if|if
condition|(
name|so
operator|->
name|so_sigio
operator|!=
name|NULL
condition|)
name|pgsigio
argument_list|(
operator|&
name|so
operator|->
name|so_sigio
argument_list|,
name|SIGURG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|so
operator|->
name|so_rdsel
argument_list|,
name|PSOCK
argument_list|)
expr_stmt|;
block|}
name|int
name|sopoll
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
comment|/* 	 * We do not need to set or assert curvnet as long as everyone uses 	 * sopoll_generic(). 	 */
return|return
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_sopoll
argument_list|(
name|so
argument_list|,
name|events
argument_list|,
name|active_cred
argument_list|,
name|td
argument_list|)
operator|)
return|;
block|}
name|int
name|sopoll_generic
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|revents
decl_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
operator|)
condition|)
name|revents
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|so
operator|->
name|sol_comp
argument_list|)
condition|)
name|revents
operator|=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
else|else
block|{
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|so
operator|->
name|so_rdsel
argument_list|)
expr_stmt|;
name|revents
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|revents
operator|=
literal|0
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
if|if
condition|(
name|soreadabledata
argument_list|(
name|so
argument_list|)
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
condition|)
if|if
condition|(
name|sowriteable
argument_list|(
name|so
argument_list|)
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLPRI
operator||
name|POLLRDBAND
operator|)
condition|)
if|if
condition|(
name|so
operator|->
name|so_oobmark
operator|||
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_RCVATMARK
operator|)
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLPRI
operator||
name|POLLRDBAND
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|events
operator|&
name|POLLINIGNEOF
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
block|{
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_state
operator|&
name|SBS_CANTSENDMORE
condition|)
name|revents
operator||=
name|POLLHUP
expr_stmt|;
block|}
block|}
if|if
condition|(
name|revents
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLPRI
operator||
name|POLLRDNORM
operator||
name|POLLRDBAND
operator|)
condition|)
block|{
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|so
operator|->
name|so_rdsel
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator||=
name|SB_SEL
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
condition|)
block|{
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|so
operator|->
name|so_wrsel
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator||=
name|SB_SEL
expr_stmt|;
block|}
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
block|}
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
name|int
name|soo_kqfilter
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
name|struct
name|knlist
modifier|*
name|knl
decl_stmt|;
switch|switch
condition|(
name|kn
operator|->
name|kn_filter
condition|)
block|{
case|case
name|EVFILT_READ
case|:
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|soread_filtops
expr_stmt|;
name|knl
operator|=
operator|&
name|so
operator|->
name|so_rdsel
operator|.
name|si_note
expr_stmt|;
name|sb
operator|=
operator|&
name|so
operator|->
name|so_rcv
expr_stmt|;
break|break;
case|case
name|EVFILT_WRITE
case|:
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|sowrite_filtops
expr_stmt|;
name|knl
operator|=
operator|&
name|so
operator|->
name|so_wrsel
operator|.
name|si_note
expr_stmt|;
name|sb
operator|=
operator|&
name|so
operator|->
name|so_snd
expr_stmt|;
break|break;
case|case
name|EVFILT_EMPTY
case|:
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|soempty_filtops
expr_stmt|;
name|knl
operator|=
operator|&
name|so
operator|->
name|so_wrsel
operator|.
name|si_note
expr_stmt|;
name|sb
operator|=
operator|&
name|so
operator|->
name|so_snd
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|)
block|{
name|knlist_add
argument_list|(
name|knl
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|knlist_add
argument_list|(
name|knl
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator||=
name|SB_KNOTE
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Some routines that return EOPNOTSUPP for entry points that are not  * supported by a protocol.  Fill in as needed.  */
name|int
name|pru_accept_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
name|int
name|pru_aio_queue_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|kaiocb
modifier|*
name|job
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
name|int
name|pru_attach_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
name|int
name|pru_bind_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
name|int
name|pru_bindat_notsupp
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
name|int
name|pru_connect_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
name|int
name|pru_connectat_notsupp
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
name|int
name|pru_connect2_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so1
parameter_list|,
name|struct
name|socket
modifier|*
name|so2
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
name|int
name|pru_control_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
name|int
name|pru_disconnect_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
name|int
name|pru_listen_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|backlog
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
name|int
name|pru_peeraddr_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
name|int
name|pru_rcvd_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
name|int
name|pru_rcvoob_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
name|int
name|pru_send_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
name|int
name|pru_ready_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|count
parameter_list|)
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
comment|/*  * This isn't really a ``null'' operation, but it's the default one and  * doesn't do anything destructive.  */
name|int
name|pru_sense_null
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|stat
modifier|*
name|sb
parameter_list|)
block|{
name|sb
operator|->
name|st_blksize
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
expr_stmt|;
return|return
literal|0
return|;
block|}
name|int
name|pru_shutdown_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
name|int
name|pru_sockaddr_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
name|int
name|pru_sosend_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
name|top
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
name|int
name|pru_soreceive_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|paddr
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp0
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|controlp
parameter_list|,
name|int
modifier|*
name|flagsp
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
name|int
name|pru_sopoll_notsupp
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
specifier|static
name|void
name|filt_sordetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
decl_stmt|;
name|so_rdknl_lock
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|knlist_remove
argument_list|(
operator|&
name|so
operator|->
name|so_rdsel
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SOLISTENING
argument_list|(
name|so
argument_list|)
operator|&&
name|knlist_empty
argument_list|(
operator|&
name|so
operator|->
name|so_rdsel
operator|.
name|si_note
argument_list|)
condition|)
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator|&=
operator|~
name|SB_KNOTE
expr_stmt|;
name|so_rdknl_unlock
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
comment|/*ARGSUSED*/
specifier|static
name|int
name|filt_soread
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
expr_stmt|;
if|if
condition|(
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|)
block|{
name|SOCK_LOCK_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_data
operator|=
name|so
operator|->
name|sol_qlen
expr_stmt|;
return|return
operator|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|so
operator|->
name|sol_comp
argument_list|)
operator|)
return|;
block|}
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_data
operator|=
name|sbavail
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
operator|-
name|so
operator|->
name|so_rcv
operator|.
name|sb_ctl
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
block|{
name|kn
operator|->
name|kn_flags
operator||=
name|EV_EOF
expr_stmt|;
name|kn
operator|->
name|kn_fflags
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
comment|/* temporary udp error */
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|kn
operator|->
name|kn_sfflags
operator|&
name|NOTE_LOWAT
condition|)
block|{
if|if
condition|(
name|kn
operator|->
name|kn_data
operator|>=
name|kn
operator|->
name|kn_sdata
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|sbavail
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
operator|>=
name|so
operator|->
name|so_rcv
operator|.
name|sb_lowat
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* This hook returning non-zero indicates an event, not error */
return|return
operator|(
name|hhook_run_socket
argument_list|(
name|so
argument_list|,
name|NULL
argument_list|,
name|HHOOK_FILT_SOREAD
argument_list|)
operator|)
return|;
block|}
specifier|static
name|void
name|filt_sowdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
decl_stmt|;
name|so_wrknl_lock
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|knlist_remove
argument_list|(
operator|&
name|so
operator|->
name|so_wrsel
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SOLISTENING
argument_list|(
name|so
argument_list|)
operator|&&
name|knlist_empty
argument_list|(
operator|&
name|so
operator|->
name|so_wrsel
operator|.
name|si_note
argument_list|)
condition|)
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator|&=
operator|~
name|SB_KNOTE
expr_stmt|;
name|so_wrknl_unlock
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
comment|/*ARGSUSED*/
specifier|static
name|int
name|filt_sowrite
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
expr_stmt|;
if|if
condition|(
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_data
operator|=
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|hhook_run_socket
argument_list|(
name|so
argument_list|,
name|kn
argument_list|,
name|HHOOK_FILT_SOWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_state
operator|&
name|SBS_CANTSENDMORE
condition|)
block|{
name|kn
operator|->
name|kn_flags
operator||=
name|EV_EOF
expr_stmt|;
name|kn
operator|->
name|kn_fflags
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
comment|/* temporary udp error */
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|kn
operator|->
name|kn_sfflags
operator|&
name|NOTE_LOWAT
condition|)
return|return
operator|(
name|kn
operator|->
name|kn_data
operator|>=
name|kn
operator|->
name|kn_sdata
operator|)
return|;
else|else
return|return
operator|(
name|kn
operator|->
name|kn_data
operator|>=
name|so
operator|->
name|so_snd
operator|.
name|sb_lowat
operator|)
return|;
block|}
specifier|static
name|int
name|filt_soempty
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
expr_stmt|;
if|if
condition|(
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_data
operator|=
name|sbused
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_data
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|int
name|socheckuid
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|uid_t
name|uid
parameter_list|)
block|{
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|so
operator|->
name|so_cred
operator|->
name|cr_uid
operator|!=
name|uid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * These functions are used by protocols to notify the socket layer (and its  * consumers) of state changes in the sockets driven by protocol-side events.  */
comment|/*  * Procedures to manipulate state flags of socket and do appropriate wakeups.  *  * Normal sequence from the active (originating) side is that  * soisconnecting() is called during processing of connect() call, resulting  * in an eventual call to soisconnected() if/when the connection is  * established.  When the connection is torn down soisdisconnecting() is  * called during processing of disconnect() call, and soisdisconnected() is  * called when the connection to the peer is totally severed.  The semantics  * of these routines are such that connectionless protocols can call  * soisconnected() and soisdisconnected() only, bypassing the in-progress  * calls when setting up a ``connection'' takes no time.  *  * From the passive side, a socket is created with two queues of sockets:  * so_incomp for connections in progress and so_comp for connections already  * made and awaiting user acceptance.  As a protocol is preparing incoming  * connections, it creates a socket structure queued on so_incomp by calling  * sonewconn().  When the connection is established, soisconnected() is  * called, and transfers the socket structure to so_comp, making it available  * to accept().  *  * If a socket is closed with sockets on either so_incomp or so_comp, these  * sockets are dropped.  *  * If higher-level protocols are implemented in the kernel, the wakeups done  * here will sometimes cause software-interrupt process scheduling.  */
name|void
name|soisconnecting
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_state
operator|&=
operator|~
operator|(
name|SS_ISCONNECTED
operator||
name|SS_ISDISCONNECTING
operator|)
expr_stmt|;
name|so
operator|->
name|so_state
operator||=
name|SS_ISCONNECTING
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|void
name|soisconnected
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|head
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* 	 * XXXGL: this is the only place where we acquire socket locks 	 * in reverse order: first child, then listening socket.  To 	 * avoid possible LOR, use try semantics. 	 */
name|restart
label|:
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|head
operator|=
name|so
operator|->
name|so_listen
operator|)
operator|!=
name|NULL
operator|&&
name|__predict_false
argument_list|(
name|SOLISTEN_TRYLOCK
argument_list|(
name|head
argument_list|)
operator|==
literal|0
argument_list|)
condition|)
block|{
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
name|so
operator|->
name|so_state
operator|&=
operator|~
operator|(
name|SS_ISCONNECTING
operator||
name|SS_ISDISCONNECTING
operator||
name|SS_ISCONFIRMING
operator|)
expr_stmt|;
name|so
operator|->
name|so_state
operator||=
name|SS_ISCONNECTED
expr_stmt|;
if|if
condition|(
name|head
operator|!=
name|NULL
operator|&&
operator|(
name|so
operator|->
name|so_qstate
operator|==
name|SQ_INCOMP
operator|)
condition|)
block|{
name|again
label|:
if|if
condition|(
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_ACCEPTFILTER
operator|)
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|head
operator|->
name|sol_incomp
argument_list|,
name|so
argument_list|,
name|so_list
argument_list|)
expr_stmt|;
name|head
operator|->
name|sol_incqlen
operator|--
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|head
operator|->
name|sol_comp
argument_list|,
name|so
argument_list|,
name|so_list
argument_list|)
expr_stmt|;
name|head
operator|->
name|sol_qlen
operator|++
expr_stmt|;
name|so
operator|->
name|so_qstate
operator|=
name|SQ_COMP
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|solisten_wakeup
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/* unlocks */
block|}
else|else
block|{
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|soupcall_set
argument_list|(
name|so
argument_list|,
name|SO_RCV
argument_list|,
name|head
operator|->
name|sol_accept_filter
operator|->
name|accf_callback
argument_list|,
name|head
operator|->
name|sol_accept_filter_arg
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_options
operator|&=
operator|~
name|SO_ACCEPTFILTER
expr_stmt|;
name|ret
operator|=
name|head
operator|->
name|sol_accept_filter
operator|->
name|accf_callback
argument_list|(
name|so
argument_list|,
name|head
operator|->
name|sol_accept_filter_arg
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|SU_ISCONNECTED
condition|)
block|{
name|soupcall_clear
argument_list|(
name|so
argument_list|,
name|SO_RCV
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SOLISTEN_UNLOCK
argument_list|(
name|head
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|head
operator|!=
name|NULL
condition|)
name|SOLISTEN_UNLOCK
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|so
operator|->
name|so_timeo
argument_list|)
expr_stmt|;
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sowwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|void
name|soisdisconnecting
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_state
operator|&=
operator|~
name|SS_ISCONNECTING
expr_stmt|;
name|so
operator|->
name|so_state
operator||=
name|SS_ISDISCONNECTING
expr_stmt|;
if|if
condition|(
operator|!
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|)
block|{
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|socantrcvmore_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|socantsendmore_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|so
operator|->
name|so_timeo
argument_list|)
expr_stmt|;
block|}
name|void
name|soisdisconnected
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_state
operator|&=
operator|~
operator|(
name|SS_ISCONNECTING
operator||
name|SS_ISCONNECTED
operator||
name|SS_ISDISCONNECTING
operator|)
expr_stmt|;
name|so
operator|->
name|so_state
operator||=
name|SS_ISDISCONNECTED
expr_stmt|;
if|if
condition|(
operator|!
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|)
block|{
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|socantrcvmore_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|sbdrop_locked
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
name|sbused
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
argument_list|)
expr_stmt|;
name|socantsendmore_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|so
operator|->
name|so_timeo
argument_list|)
expr_stmt|;
block|}
comment|/*  * Make a copy of a sockaddr in a malloced buffer of type M_SONAME.  */
name|struct
name|sockaddr
modifier|*
name|sodupsockaddr
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|int
name|mflags
parameter_list|)
block|{
name|struct
name|sockaddr
modifier|*
name|sa2
decl_stmt|;
name|sa2
operator|=
name|malloc
argument_list|(
name|sa
operator|->
name|sa_len
argument_list|,
name|M_SONAME
argument_list|,
name|mflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa2
condition|)
name|bcopy
argument_list|(
name|sa
argument_list|,
name|sa2
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
return|return
name|sa2
return|;
block|}
comment|/*  * Register per-socket buffer upcalls.  */
name|void
name|soupcall_set
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|which
parameter_list|,
name|so_upcall_t
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
name|SOLISTENING
argument_list|(
name|so
argument_list|)
argument_list|,
operator|(
literal|"%s: so %p listening"
operator|,
name|__func__
operator|,
name|so
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|SO_RCV
case|:
name|sb
operator|=
operator|&
name|so
operator|->
name|so_rcv
expr_stmt|;
break|break;
case|case
name|SO_SND
case|:
name|sb
operator|=
operator|&
name|so
operator|->
name|so_snd
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"soupcall_set: bad which"
argument_list|)
expr_stmt|;
block|}
name|SOCKBUF_LOCK_ASSERT
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sb
operator|->
name|sb_upcall
operator|=
name|func
expr_stmt|;
name|sb
operator|->
name|sb_upcallarg
operator|=
name|arg
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator||=
name|SB_UPCALL
expr_stmt|;
block|}
name|void
name|soupcall_clear
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|which
parameter_list|)
block|{
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
name|SOLISTENING
argument_list|(
name|so
argument_list|)
argument_list|,
operator|(
literal|"%s: so %p listening"
operator|,
name|__func__
operator|,
name|so
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|SO_RCV
case|:
name|sb
operator|=
operator|&
name|so
operator|->
name|so_rcv
expr_stmt|;
break|break;
case|case
name|SO_SND
case|:
name|sb
operator|=
operator|&
name|so
operator|->
name|so_snd
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"soupcall_clear: bad which"
argument_list|)
expr_stmt|;
block|}
name|SOCKBUF_LOCK_ASSERT
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sb
operator|->
name|sb_upcall
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: so %p no upcall to clear"
operator|,
name|__func__
operator|,
name|so
operator|)
argument_list|)
expr_stmt|;
name|sb
operator|->
name|sb_upcall
operator|=
name|NULL
expr_stmt|;
name|sb
operator|->
name|sb_upcallarg
operator|=
name|NULL
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_UPCALL
expr_stmt|;
block|}
name|void
name|solisten_upcall_set
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|so_upcall_t
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|SOLISTEN_LOCK_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|sol_upcall
operator|=
name|func
expr_stmt|;
name|so
operator|->
name|sol_upcallarg
operator|=
name|arg
expr_stmt|;
block|}
specifier|static
name|void
name|so_rdknl_lock
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|)
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
else|else
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|so_rdknl_unlock
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|)
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
else|else
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|so_rdknl_assert_locked
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|)
name|SOCK_LOCK_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
else|else
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|so_rdknl_assert_unlocked
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|)
name|SOCK_UNLOCK_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
else|else
name|SOCKBUF_UNLOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|so_wrknl_lock
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|)
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
else|else
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|so_wrknl_unlock
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|)
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
else|else
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|so_wrknl_assert_locked
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|)
name|SOCK_LOCK_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
else|else
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|so_wrknl_assert_unlocked
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|)
name|SOCK_UNLOCK_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
else|else
name|SOCKBUF_UNLOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
block|}
comment|/*  * Create an external-format (``xsocket'') structure using the information in  * the kernel-format socket structure pointed to by so.  This is done to  * reduce the spew of irrelevant information over this interface, to isolate  * user code from changes in the kernel structure, and potentially to provide  * information-hiding if we decide that some of this information should be  * hidden from users.  */
name|void
name|sotoxsocket
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|xsocket
modifier|*
name|xso
parameter_list|)
block|{
name|xso
operator|->
name|xso_len
operator|=
sizeof|sizeof
expr|*
name|xso
expr_stmt|;
name|xso
operator|->
name|xso_so
operator|=
name|so
expr_stmt|;
name|xso
operator|->
name|so_type
operator|=
name|so
operator|->
name|so_type
expr_stmt|;
name|xso
operator|->
name|so_options
operator|=
name|so
operator|->
name|so_options
expr_stmt|;
name|xso
operator|->
name|so_linger
operator|=
name|so
operator|->
name|so_linger
expr_stmt|;
name|xso
operator|->
name|so_state
operator|=
name|so
operator|->
name|so_state
expr_stmt|;
name|xso
operator|->
name|so_pcb
operator|=
name|so
operator|->
name|so_pcb
expr_stmt|;
name|xso
operator|->
name|xso_protocol
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
expr_stmt|;
name|xso
operator|->
name|xso_family
operator|=
name|so
operator|->
name|so_proto
operator|->
name|pr_domain
operator|->
name|dom_family
expr_stmt|;
name|xso
operator|->
name|so_timeo
operator|=
name|so
operator|->
name|so_timeo
expr_stmt|;
name|xso
operator|->
name|so_error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
name|xso
operator|->
name|so_uid
operator|=
name|so
operator|->
name|so_cred
operator|->
name|cr_uid
expr_stmt|;
name|xso
operator|->
name|so_pgid
operator|=
name|so
operator|->
name|so_sigio
condition|?
name|so
operator|->
name|so_sigio
operator|->
name|sio_pgid
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|SOLISTENING
argument_list|(
name|so
argument_list|)
condition|)
block|{
name|xso
operator|->
name|so_qlen
operator|=
name|so
operator|->
name|sol_qlen
expr_stmt|;
name|xso
operator|->
name|so_incqlen
operator|=
name|so
operator|->
name|sol_incqlen
expr_stmt|;
name|xso
operator|->
name|so_qlimit
operator|=
name|so
operator|->
name|sol_qlimit
expr_stmt|;
name|xso
operator|->
name|so_oobmark
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|xso
operator|->
name|so_snd
argument_list|,
sizeof|sizeof
argument_list|(
name|xso
operator|->
name|so_snd
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|xso
operator|->
name|so_rcv
argument_list|,
sizeof|sizeof
argument_list|(
name|xso
operator|->
name|so_rcv
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xso
operator|->
name|so_state
operator||=
name|so
operator|->
name|so_qstate
expr_stmt|;
name|xso
operator|->
name|so_qlen
operator|=
name|xso
operator|->
name|so_incqlen
operator|=
name|xso
operator|->
name|so_qlimit
operator|=
literal|0
expr_stmt|;
name|xso
operator|->
name|so_oobmark
operator|=
name|so
operator|->
name|so_oobmark
expr_stmt|;
name|sbtoxsockbuf
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
operator|&
name|xso
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|sbtoxsockbuf
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
operator|&
name|xso
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
block|}
name|struct
name|sockbuf
modifier|*
name|so_sockbuf_rcv
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
return|return
operator|(
operator|&
name|so
operator|->
name|so_rcv
operator|)
return|;
block|}
name|struct
name|sockbuf
modifier|*
name|so_sockbuf_snd
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
return|return
operator|(
operator|&
name|so
operator|->
name|so_snd
operator|)
return|;
block|}
name|int
name|so_state_get
parameter_list|(
specifier|const
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
return|return
operator|(
name|so
operator|->
name|so_state
operator|)
return|;
block|}
name|void
name|so_state_set
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|so
operator|->
name|so_state
operator|=
name|val
expr_stmt|;
block|}
name|int
name|so_options_get
parameter_list|(
specifier|const
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
return|return
operator|(
name|so
operator|->
name|so_options
operator|)
return|;
block|}
name|void
name|so_options_set
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|so
operator|->
name|so_options
operator|=
name|val
expr_stmt|;
block|}
name|int
name|so_error_get
parameter_list|(
specifier|const
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
return|return
operator|(
name|so
operator|->
name|so_error
operator|)
return|;
block|}
name|void
name|so_error_set
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|so
operator|->
name|so_error
operator|=
name|val
expr_stmt|;
block|}
name|int
name|so_linger_get
parameter_list|(
specifier|const
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
return|return
operator|(
name|so
operator|->
name|so_linger
operator|)
return|;
block|}
name|void
name|so_linger_set
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|so
operator|->
name|so_linger
operator|=
name|val
expr_stmt|;
block|}
name|struct
name|protosw
modifier|*
name|so_protosw_get
parameter_list|(
specifier|const
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
return|return
operator|(
name|so
operator|->
name|so_proto
operator|)
return|;
block|}
name|void
name|so_protosw_set
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|protosw
modifier|*
name|val
parameter_list|)
block|{
name|so
operator|->
name|so_proto
operator|=
name|val
expr_stmt|;
block|}
name|void
name|so_sorwakeup
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|void
name|so_sowwakeup
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|sowwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|void
name|so_sorwakeup_locked
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|sorwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|void
name|so_sowwakeup_locked
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|sowwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|void
name|so_lock
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|void
name|so_unlock
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

