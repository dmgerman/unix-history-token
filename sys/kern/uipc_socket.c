begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1988, 1990, 1993  *	The Regents of the University of California.  * Copyright (c) 2004 The FreeBSD Foundation  * Copyright (c) 2004-2006 Robert N. M. Watson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)uipc_socket.c	8.3 (Berkeley) 4/15/94  */
end_comment

begin_comment
comment|/*  * Comments on the socket life cycle:  *  * soalloc() sets of socket layer state for a socket, called only by  * socreate() and sonewconn().  Socket layer private.  *  * sodealloc() tears down socket layer state for a socket, called only by  * sofree() and sonewconn().  Socket layer private.  *  * pru_attach() associates protocol layer state with an allocated socket;  * called only once, may fail, aborting socket allocation.  This is called  * from socreate() and sonewconn().  Socket layer private.  *  * pru_detach() disassociates protocol layer state from an attached socket,  * and will be called exactly once for sockets in which pru_attach() has  * been successfully called.  If pru_attach() returned an error,  * pru_detach() will not be called.  Socket layer private.  *  * pru_abort() and pru_close() notify the protocol layer that the last  * consumer of a socket is starting to tear down the socket, and that the  * protocol should terminate the connection.  Historically, pru_abort() also  * detached protocol state from the socket state, but this is no longer the  * case.  *  * socreate() creates a socket and attaches protocol state.  This is a public  * interface that may be used by socket layer consumers to create new  * sockets.  *  * sonewconn() creates a socket and attaches protocol state.  This is a  * public interface  that may be used by protocols to create new sockets when  * a new connection is received and will be available for accept() on a  * listen socket.  *  * soclose() destroys a socket after possibly waiting for it to disconnect.  * This is a public interface that socket consumers should use to close and  * release a socket when done with it.  *  * soabort() destroys a socket without waiting for it to disconnect (used  * only for incoming connections that are already partially or fully  * connected).  This is used internally by the socket layer when clearing  * listen socket queues (due to overflow or close on the listen socket), but  * is also a public interface protocols may use to abort connections in  * their incomplete listen queues should they no longer be required.  Sockets  * placed in completed connection listen queues should not be aborted for  * reasons described in the comment above the soclose() implementation.  This  * is not a general purpose close routine, and except in the specific  * circumstances described here, should not be used.  *  * sofree() will free a socket and its protocol state if all references on  * the socket have been released, and is the public interface to attempt to  * free a socket when a reference is removed.  This is a socket layer private  * interface.  *  * NOTE: In addition to socreate() and soclose(), which provide a single  * socket reference to the consumer to be managed as required, there are two  * calls to explicitly manage socket references, soref(), and sorele().  * Currently, these are generally required only when transitioning a socket  * from a listen queue to a file descriptor, in order to prevent garbage  * collection of the socket at an untimely moment.  For a number of reasons,  * these interfaces are not preferred, and should be avoided.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|"opt_zero.h"
end_include

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mac.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_comment
comment|/* for struct knote */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_IA32
end_ifdef

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<compat/freebsd32/freebsd32.h>
end_include

begin_decl_stmt
specifier|extern
name|struct
name|sysentvec
name|ia32_freebsd_sysvec
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|soreceive_rcvoob
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filt_sordetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_soread
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filt_sowdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_sowrite
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_solisten
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|solisten_filtops
init|=
block|{
literal|1
block|,
name|NULL
block|,
name|filt_sordetach
block|,
name|filt_solisten
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|soread_filtops
init|=
block|{
literal|1
block|,
name|NULL
block|,
name|filt_sordetach
block|,
name|filt_soread
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|sowrite_filtops
init|=
block|{
literal|1
block|,
name|NULL
block|,
name|filt_sowdetach
block|,
name|filt_sowrite
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uma_zone_t
name|socket_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|so_gen_t
name|so_gencnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* generation count for sockets */
end_comment

begin_decl_stmt
name|int
name|maxsockets
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_SONAME
argument_list|,
literal|"soname"
argument_list|,
literal|"socket name"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_PCB
argument_list|,
literal|"pcb"
argument_list|,
literal|"protocol control block"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|somaxconn
init|=
name|SOMAXCONN
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|sysctl_somaxconn
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* XXX: we dont have SYSCTL_USHORT */
end_comment

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_ipc
argument_list|,
name|KIPC_SOMAXCONN
argument_list|,
name|somaxconn
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|sysctl_somaxconn
argument_list|,
literal|"I"
argument_list|,
literal|"Maximum pending socket connection "
literal|"queue size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|numopensockets
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|numopensockets
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|numopensockets
argument_list|,
literal|0
argument_list|,
literal|"Number of open sockets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ZERO_COPY_SOCKETS
end_ifdef

begin_comment
comment|/* These aren't static because they're used in other files. */
end_comment

begin_decl_stmt
name|int
name|so_zero_copy_send
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|so_zero_copy_receive
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|zero_copy
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"Zero copy controls"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc_zero_copy
argument_list|,
name|OID_AUTO
argument_list|,
name|receive
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|so_zero_copy_receive
argument_list|,
literal|0
argument_list|,
literal|"Enable zero copy receive"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_ipc_zero_copy
argument_list|,
name|OID_AUTO
argument_list|,
name|send
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|so_zero_copy_send
argument_list|,
literal|0
argument_list|,
literal|"Enable zero copy send"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ZERO_COPY_SOCKETS */
end_comment

begin_comment
comment|/*  * accept_mtx locks down per-socket fields relating to accept queues.  See  * socketvar.h for an annotation of the protected fields of struct socket.  */
end_comment

begin_decl_stmt
name|struct
name|mtx
name|accept_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|accept_mtx
argument_list|,
operator|&
name|accept_mtx
argument_list|,
literal|"accept"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * so_global_mtx protects so_gencnt, numopensockets, and the per-socket  * so_gencnt field.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|so_global_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|so_global_mtx
argument_list|,
operator|&
name|so_global_mtx
argument_list|,
literal|"so_glabel"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * General IPC sysctl name space, used by sockets and a variety of other IPC  * types.  */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|KERN_IPC
argument_list|,
name|ipc
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"IPC"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Sysctl to get and set the maximum global sockets limit.  Notify protocols  * of the change so that they can update their dependent limits as required.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_maxsockets
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|newmaxsockets
decl_stmt|;
name|newmaxsockets
operator|=
name|maxsockets
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|newmaxsockets
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
condition|)
block|{
if|if
condition|(
name|newmaxsockets
operator|>
name|maxsockets
condition|)
block|{
name|maxsockets
operator|=
name|newmaxsockets
expr_stmt|;
if|if
condition|(
name|maxsockets
operator|>
operator|(
operator|(
name|maxfiles
operator|/
literal|4
operator|)
operator|*
literal|3
operator|)
condition|)
block|{
name|maxfiles
operator|=
operator|(
name|maxsockets
operator|*
literal|5
operator|)
operator|/
literal|4
expr_stmt|;
name|maxfilesperproc
operator|=
operator|(
name|maxfiles
operator|*
literal|9
operator|)
operator|/
literal|10
expr_stmt|;
block|}
name|EVENTHANDLER_INVOKE
argument_list|(
name|maxsockets_change
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_ipc
argument_list|,
name|OID_AUTO
argument_list|,
name|maxsockets
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|maxsockets
argument_list|,
literal|0
argument_list|,
name|sysctl_maxsockets
argument_list|,
literal|"IU"
argument_list|,
literal|"Maximum number of sockets avaliable"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Initialise maxsockets.  */
end_comment

begin_function
specifier|static
name|void
name|init_maxsockets
parameter_list|(
name|void
modifier|*
name|ignored
parameter_list|)
block|{
name|TUNABLE_INT_FETCH
argument_list|(
literal|"kern.ipc.maxsockets"
argument_list|,
operator|&
name|maxsockets
argument_list|)
expr_stmt|;
name|maxsockets
operator|=
name|imax
argument_list|(
name|maxsockets
argument_list|,
name|imax
argument_list|(
name|maxfiles
argument_list|,
name|nmbclusters
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|param
argument_list|,
name|SI_SUB_TUNABLES
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|init_maxsockets
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Socket operation routines.  These routines are called by the routines in  * sys_socket.c or from a system process, and implement the semantics of  * socket operations by switching out to the protocol specific routines.  */
end_comment

begin_comment
comment|/*  * Get a socket structure from our zone, and initialize it.  Note that it  * would probably be better to allocate socket and PCB at the same time, but  * I'm not convinced that all the protocols can be easily modified to do  * this.  *  * soalloc() returns a socket with a ref count of 0.  */
end_comment

begin_function
specifier|static
name|struct
name|socket
modifier|*
name|soalloc
parameter_list|(
name|int
name|mflags
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|uma_zalloc
argument_list|(
name|socket_zone
argument_list|,
name|mflags
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
name|mac_init_socket
argument_list|(
name|so
argument_list|,
name|mflags
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|uma_zfree
argument_list|(
name|socket_zone
argument_list|,
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
endif|#
directive|endif
name|SOCKBUF_LOCK_INIT
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
literal|"so_snd"
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK_INIT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
literal|"so_rcv"
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|so
operator|->
name|so_aiojobq
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|so_global_mtx
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_gencnt
operator|=
operator|++
name|so_gencnt
expr_stmt|;
operator|++
name|numopensockets
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|so_global_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|so
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free the storage associated with a socket at the socket layer, tear down  * locks, labels, etc.  All protocol state is assumed already to have been  * torn down (and possibly never set up) by the caller.  */
end_comment

begin_function
specifier|static
name|void
name|sodealloc
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|so
operator|->
name|so_count
operator|==
literal|0
argument_list|,
operator|(
literal|"sodealloc(): so_count %d"
operator|,
name|so
operator|->
name|so_count
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|so
operator|->
name|so_pcb
operator|==
name|NULL
argument_list|,
operator|(
literal|"sodealloc(): so_pcb != NULL"
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|so_global_mtx
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_gencnt
operator|=
operator|++
name|so_gencnt
expr_stmt|;
operator|--
name|numopensockets
expr_stmt|;
comment|/* Could be below, but faster here. */
name|mtx_unlock
argument_list|(
operator|&
name|so_global_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
condition|)
operator|(
name|void
operator|)
name|chgsbsize
argument_list|(
name|so
operator|->
name|so_cred
operator|->
name|cr_uidinfo
argument_list|,
operator|&
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
argument_list|,
literal|0
argument_list|,
name|RLIM_INFINITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
condition|)
operator|(
name|void
operator|)
name|chgsbsize
argument_list|(
name|so
operator|->
name|so_cred
operator|->
name|cr_uidinfo
argument_list|,
operator|&
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
argument_list|,
literal|0
argument_list|,
name|RLIM_INFINITY
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
comment|/* remove acccept filter if one is present. */
if|if
condition|(
name|so
operator|->
name|so_accf
operator|!=
name|NULL
condition|)
name|do_setopt_accept_filter
argument_list|(
name|so
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MAC
name|mac_destroy_socket
argument_list|(
name|so
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|crfree
argument_list|(
name|so
operator|->
name|so_cred
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK_DESTROY
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK_DESTROY
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|socket_zone
argument_list|,
name|so
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * socreate returns a socket with a ref count of 1.  The socket should be  * closed with soclose().  */
end_comment

begin_function
name|int
name|socreate
parameter_list|(
name|dom
parameter_list|,
name|aso
parameter_list|,
name|type
parameter_list|,
name|proto
parameter_list|,
name|cred
parameter_list|,
name|td
parameter_list|)
name|int
name|dom
decl_stmt|;
name|struct
name|socket
modifier|*
modifier|*
name|aso
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|proto
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|protosw
modifier|*
name|prp
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|proto
condition|)
name|prp
operator|=
name|pffindproto
argument_list|(
name|dom
argument_list|,
name|proto
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|prp
operator|=
name|pffindtype
argument_list|(
name|dom
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|prp
operator|==
name|NULL
operator|||
name|prp
operator|->
name|pr_usrreqs
operator|->
name|pru_attach
operator|==
name|NULL
operator|||
name|prp
operator|->
name|pr_usrreqs
operator|->
name|pru_attach
operator|==
name|pru_attach_notsupp
condition|)
return|return
operator|(
name|EPROTONOSUPPORT
operator|)
return|;
if|if
condition|(
name|jailed
argument_list|(
name|cred
argument_list|)
operator|&&
name|jail_socket_unixiproute_only
operator|&&
name|prp
operator|->
name|pr_domain
operator|->
name|dom_family
operator|!=
name|PF_LOCAL
operator|&&
name|prp
operator|->
name|pr_domain
operator|->
name|dom_family
operator|!=
name|PF_INET
operator|&&
name|prp
operator|->
name|pr_domain
operator|->
name|dom_family
operator|!=
name|PF_ROUTE
condition|)
block|{
return|return
operator|(
name|EPROTONOSUPPORT
operator|)
return|;
block|}
if|if
condition|(
name|prp
operator|->
name|pr_type
operator|!=
name|type
condition|)
return|return
operator|(
name|EPROTOTYPE
operator|)
return|;
name|so
operator|=
name|soalloc
argument_list|(
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|TAILQ_INIT
argument_list|(
operator|&
name|so
operator|->
name|so_incomp
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|so
operator|->
name|so_comp
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_type
operator|=
name|type
expr_stmt|;
name|so
operator|->
name|so_cred
operator|=
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_proto
operator|=
name|prp
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_create_socket
argument_list|(
name|cred
argument_list|,
name|so
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|knlist_init
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
operator|.
name|sb_sel
operator|.
name|si_note
argument_list|,
name|SOCKBUF_MTX
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|knlist_init
argument_list|(
operator|&
name|so
operator|->
name|so_snd
operator|.
name|sb_sel
operator|.
name|si_note
argument_list|,
name|SOCKBUF_MTX
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_count
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Auto-sizing of socket buffers is managed by the protocols and 	 * the appropriate flags must be set in the pru_attach function. 	 */
name|error
operator|=
call|(
modifier|*
name|prp
operator|->
name|pr_usrreqs
operator|->
name|pru_attach
call|)
argument_list|(
name|so
argument_list|,
name|proto
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|KASSERT
argument_list|(
name|so
operator|->
name|so_count
operator|==
literal|1
argument_list|,
operator|(
literal|"socreate: so_count %d"
operator|,
name|so
operator|->
name|so_count
operator|)
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_count
operator|=
literal|0
expr_stmt|;
name|sodealloc
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|aso
operator|=
name|so
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|REGRESSION
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|regression_sonewconn_earlytest
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_regression
argument_list|,
name|OID_AUTO
argument_list|,
name|sonewconn_earlytest
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|regression_sonewconn_earlytest
argument_list|,
literal|0
argument_list|,
literal|"Perform early sonewconn limit test"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * When an attempt at a new connection is noted on a socket which accepts  * connections, sonewconn is called.  If the connection is possible (subject  * to space constraints, etc.) then we allocate a new structure, propoerly  * linked into the data structure of the original socket, and return this.  * Connstatus may be 0, or SO_ISCONFIRMING, or SO_ISCONNECTED.  *  * Note: the ref count on the socket is 0 on return.  */
end_comment

begin_function
name|struct
name|socket
modifier|*
name|sonewconn
parameter_list|(
name|head
parameter_list|,
name|connstatus
parameter_list|)
specifier|register
name|struct
name|socket
modifier|*
name|head
decl_stmt|;
name|int
name|connstatus
decl_stmt|;
block|{
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|over
decl_stmt|;
name|ACCEPT_LOCK
argument_list|()
expr_stmt|;
name|over
operator|=
operator|(
name|head
operator|->
name|so_qlen
operator|>
literal|3
operator|*
name|head
operator|->
name|so_qlimit
operator|/
literal|2
operator|)
expr_stmt|;
name|ACCEPT_UNLOCK
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|REGRESSION
if|if
condition|(
name|regression_sonewconn_earlytest
operator|&&
name|over
condition|)
else|#
directive|else
if|if
condition|(
name|over
condition|)
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
name|so
operator|=
name|soalloc
argument_list|(
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|head
operator|->
name|so_options
operator|&
name|SO_ACCEPTFILTER
operator|)
operator|!=
literal|0
condition|)
name|connstatus
operator|=
literal|0
expr_stmt|;
name|so
operator|->
name|so_head
operator|=
name|head
expr_stmt|;
name|so
operator|->
name|so_type
operator|=
name|head
operator|->
name|so_type
expr_stmt|;
name|so
operator|->
name|so_options
operator|=
name|head
operator|->
name|so_options
operator|&
operator|~
name|SO_ACCEPTCONN
expr_stmt|;
name|so
operator|->
name|so_linger
operator|=
name|head
operator|->
name|so_linger
expr_stmt|;
name|so
operator|->
name|so_state
operator|=
name|head
operator|->
name|so_state
operator||
name|SS_NOFDREF
expr_stmt|;
name|so
operator|->
name|so_proto
operator|=
name|head
operator|->
name|so_proto
expr_stmt|;
name|so
operator|->
name|so_cred
operator|=
name|crhold
argument_list|(
name|head
operator|->
name|so_cred
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|SOCK_LOCK
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|mac_create_socket_from_socket
argument_list|(
name|head
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|head
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|knlist_init
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
operator|.
name|sb_sel
operator|.
name|si_note
argument_list|,
name|SOCKBUF_MTX
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|knlist_init
argument_list|(
operator|&
name|so
operator|->
name|so_snd
operator|.
name|sb_sel
operator|.
name|si_note
argument_list|,
name|SOCKBUF_MTX
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|soreserve
argument_list|(
name|so
argument_list|,
name|head
operator|->
name|so_snd
operator|.
name|sb_hiwat
argument_list|,
name|head
operator|->
name|so_rcv
operator|.
name|sb_hiwat
argument_list|)
operator|||
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_attach
call|)
argument_list|(
name|so
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|sodealloc
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|so
operator|->
name|so_rcv
operator|.
name|sb_lowat
operator|=
name|head
operator|->
name|so_rcv
operator|.
name|sb_lowat
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_lowat
operator|=
name|head
operator|->
name|so_snd
operator|.
name|sb_lowat
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_timeo
operator|=
name|head
operator|->
name|so_rcv
operator|.
name|sb_timeo
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_timeo
operator|=
name|head
operator|->
name|so_snd
operator|.
name|sb_timeo
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator||=
name|head
operator|->
name|so_rcv
operator|.
name|sb_flags
operator|&
name|SB_AUTOSIZE
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator||=
name|head
operator|->
name|so_snd
operator|.
name|sb_flags
operator|&
name|SB_AUTOSIZE
expr_stmt|;
name|so
operator|->
name|so_state
operator||=
name|connstatus
expr_stmt|;
name|ACCEPT_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|connstatus
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|head
operator|->
name|so_comp
argument_list|,
name|so
argument_list|,
name|so_list
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_qstate
operator||=
name|SQ_COMP
expr_stmt|;
name|head
operator|->
name|so_qlen
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Keep removing sockets from the head until there's room for 		 * us to insert on the tail.  In pre-locking revisions, this 		 * was a simple if(), but as we could be racing with other 		 * threads and soabort() requires dropping locks, we must 		 * loop waiting for the condition to be true. 		 */
while|while
condition|(
name|head
operator|->
name|so_incqlen
operator|>
name|head
operator|->
name|so_qlimit
condition|)
block|{
name|struct
name|socket
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|head
operator|->
name|so_incomp
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|head
operator|->
name|so_incomp
argument_list|,
name|sp
argument_list|,
name|so_list
argument_list|)
expr_stmt|;
name|head
operator|->
name|so_incqlen
operator|--
expr_stmt|;
name|sp
operator|->
name|so_qstate
operator|&=
operator|~
name|SQ_INCOMP
expr_stmt|;
name|sp
operator|->
name|so_head
operator|=
name|NULL
expr_stmt|;
name|ACCEPT_UNLOCK
argument_list|()
expr_stmt|;
name|soabort
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|ACCEPT_LOCK
argument_list|()
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|head
operator|->
name|so_incomp
argument_list|,
name|so
argument_list|,
name|so_list
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_qstate
operator||=
name|SQ_INCOMP
expr_stmt|;
name|head
operator|->
name|so_incqlen
operator|++
expr_stmt|;
block|}
name|ACCEPT_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|connstatus
condition|)
block|{
name|sorwakeup
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|wakeup_one
argument_list|(
operator|&
name|head
operator|->
name|so_timeo
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|so
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sobind
parameter_list|(
name|so
parameter_list|,
name|nam
parameter_list|,
name|td
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|nam
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
return|return
operator|(
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_bind
call|)
argument_list|(
name|so
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * solisten() transitions a socket from a non-listening state to a listening  * state, but can also be used to update the listen queue depth on an  * existing listen socket.  The protocol will call back into the sockets  * layer using solisten_proto_check() and solisten_proto() to check and set  * socket-layer listen state.  Call backs are used so that the protocol can  * acquire both protocol and socket layer locks in whatever order is required  * by the protocol.  *  * Protocol implementors are advised to hold the socket lock across the  * socket-layer test and set to avoid races at the socket layer.  */
end_comment

begin_function
name|int
name|solisten
parameter_list|(
name|so
parameter_list|,
name|backlog
parameter_list|,
name|td
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|backlog
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
return|return
operator|(
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_listen
call|)
argument_list|(
name|so
argument_list|,
name|backlog
argument_list|,
name|td
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|solisten_proto_check
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
name|SOCK_LOCK_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
operator|(
name|SS_ISCONNECTED
operator||
name|SS_ISCONNECTING
operator||
name|SS_ISDISCONNECTING
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|solisten_proto
parameter_list|(
name|so
parameter_list|,
name|backlog
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|backlog
decl_stmt|;
block|{
name|SOCK_LOCK_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|backlog
operator|<
literal|0
operator|||
name|backlog
operator|>
name|somaxconn
condition|)
name|backlog
operator|=
name|somaxconn
expr_stmt|;
name|so
operator|->
name|so_qlimit
operator|=
name|backlog
expr_stmt|;
name|so
operator|->
name|so_options
operator||=
name|SO_ACCEPTCONN
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attempt to free a socket.  This should really be sotryfree().  *  * sofree() will succeed if:  *  * - There are no outstanding file descriptor references or related consumers  *   (so_count == 0).  *  * - The socket has been closed by user space, if ever open (SS_NOFDREF).  *  * - The protocol does not have an outstanding strong reference on the socket  *   (SS_PROTOREF).  *  * - The socket is not in a completed connection queue, so a process has been  *   notified that it is present.  If it is removed, the user process may  *   block in accept() despite select() saying the socket was ready.  *  * Otherwise, it will quietly abort so that a future call to sofree(), when  * conditions are right, can succeed.  */
end_comment

begin_function
name|void
name|sofree
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
name|struct
name|protosw
modifier|*
name|pr
init|=
name|so
operator|->
name|so_proto
decl_stmt|;
name|struct
name|socket
modifier|*
name|head
decl_stmt|;
name|ACCEPT_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|SOCK_LOCK_ASSERT
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NOFDREF
operator|)
operator|==
literal|0
operator|||
name|so
operator|->
name|so_count
operator|!=
literal|0
operator|||
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_PROTOREF
operator|)
operator|||
operator|(
name|so
operator|->
name|so_qstate
operator|&
name|SQ_COMP
operator|)
condition|)
block|{
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|ACCEPT_UNLOCK
argument_list|()
expr_stmt|;
return|return;
block|}
name|head
operator|=
name|so
operator|->
name|so_head
expr_stmt|;
if|if
condition|(
name|head
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|so
operator|->
name|so_qstate
operator|&
name|SQ_COMP
operator|)
operator|!=
literal|0
operator|||
operator|(
name|so
operator|->
name|so_qstate
operator|&
name|SQ_INCOMP
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"sofree: so_head != NULL, but neither SQ_COMP nor "
literal|"SQ_INCOMP"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|so
operator|->
name|so_qstate
operator|&
name|SQ_COMP
operator|)
operator|==
literal|0
operator|||
operator|(
name|so
operator|->
name|so_qstate
operator|&
name|SQ_INCOMP
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"sofree: so->so_qstate is SQ_COMP and also SQ_INCOMP"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|head
operator|->
name|so_incomp
argument_list|,
name|so
argument_list|,
name|so_list
argument_list|)
expr_stmt|;
name|head
operator|->
name|so_incqlen
operator|--
expr_stmt|;
name|so
operator|->
name|so_qstate
operator|&=
operator|~
name|SQ_INCOMP
expr_stmt|;
name|so
operator|->
name|so_head
operator|=
name|NULL
expr_stmt|;
block|}
name|KASSERT
argument_list|(
operator|(
name|so
operator|->
name|so_qstate
operator|&
name|SQ_COMP
operator|)
operator|==
literal|0
operator|&&
operator|(
name|so
operator|->
name|so_qstate
operator|&
name|SQ_INCOMP
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"sofree: so_head == NULL, but still SQ_COMP(%d) or SQ_INCOMP(%d)"
operator|,
name|so
operator|->
name|so_qstate
operator|&
name|SQ_COMP
operator|,
name|so
operator|->
name|so_qstate
operator|&
name|SQ_INCOMP
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_ACCEPTCONN
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|so
operator|->
name|so_comp
argument_list|)
operator|)
argument_list|,
operator|(
literal|"sofree: so_comp populated"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|so
operator|->
name|so_incomp
argument_list|)
operator|)
argument_list|,
operator|(
literal|"sofree: so_comp populated"
operator|)
argument_list|)
expr_stmt|;
block|}
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|ACCEPT_UNLOCK
argument_list|()
expr_stmt|;
comment|/* 	 * From this point on, we assume that no other references to this 	 * socket exist anywhere else in the stack.  Therefore, no locks need 	 * to be acquired or held. 	 * 	 * We used to do a lot of socket buffer and socket locking here, as 	 * well as invoke sorflush() and perform wakeups.  The direct call to 	 * dom_dispose() and sbrelease_internal() are an inlining of what was 	 * necessary from sorflush(). 	 * 	 * Notice that the socket buffer and kqueue state are torn down 	 * before calling pru_detach.  This means that protocols shold not 	 * assume they can perform socket wakeups, etc, in their detach 	 * code. 	 */
name|KASSERT
argument_list|(
operator|(
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator|&
name|SB_LOCK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"sofree: snd sblock"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator|&
name|SB_LOCK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"sofree: rcv sblock"
operator|)
argument_list|)
expr_stmt|;
name|sbdestroy
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|pr_flags
operator|&
name|PR_RIGHTS
operator|&&
name|pr
operator|->
name|pr_domain
operator|->
name|dom_dispose
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|pr
operator|->
name|pr_domain
operator|->
name|dom_dispose
call|)
argument_list|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|)
expr_stmt|;
name|sbdestroy
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|pr_usrreqs
operator|->
name|pru_detach
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|pr
operator|->
name|pr_usrreqs
operator|->
name|pru_detach
call|)
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|knlist_destroy
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
operator|.
name|sb_sel
operator|.
name|si_note
argument_list|)
expr_stmt|;
name|knlist_destroy
argument_list|(
operator|&
name|so
operator|->
name|so_snd
operator|.
name|sb_sel
operator|.
name|si_note
argument_list|)
expr_stmt|;
name|sodealloc
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Close a socket on last file table reference removal.  Initiate disconnect  * if connected.  Free socket when disconnect complete.  *  * This function will sorele() the socket.  Note that soclose() may be called  * prior to the ref count reaching zero.  The actual socket structure will  * not be freed until the ref count reaches zero.  */
end_comment

begin_function
name|int
name|soclose
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NOFDREF
operator|)
argument_list|,
operator|(
literal|"soclose: SS_NOFDREF on enter"
operator|)
argument_list|)
expr_stmt|;
name|funsetown
argument_list|(
operator|&
name|so
operator|->
name|so_sigio
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
condition|)
block|{
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISDISCONNECTING
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|sodisconnect
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|drop
goto|;
block|}
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_LINGER
condition|)
block|{
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISDISCONNECTING
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|)
condition|)
goto|goto
name|drop
goto|;
while|while
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
condition|)
block|{
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|so
operator|->
name|so_timeo
argument_list|,
name|PSOCK
operator||
name|PCATCH
argument_list|,
literal|"soclos"
argument_list|,
name|so
operator|->
name|so_linger
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
block|}
block|}
name|drop
label|:
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_close
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_close
call|)
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_ACCEPTCONN
condition|)
block|{
name|struct
name|socket
modifier|*
name|sp
decl_stmt|;
name|ACCEPT_LOCK
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|sp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|so
operator|->
name|so_incomp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|so
operator|->
name|so_incomp
argument_list|,
name|sp
argument_list|,
name|so_list
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_incqlen
operator|--
expr_stmt|;
name|sp
operator|->
name|so_qstate
operator|&=
operator|~
name|SQ_INCOMP
expr_stmt|;
name|sp
operator|->
name|so_head
operator|=
name|NULL
expr_stmt|;
name|ACCEPT_UNLOCK
argument_list|()
expr_stmt|;
name|soabort
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|ACCEPT_LOCK
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|sp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|so
operator|->
name|so_comp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|so
operator|->
name|so_comp
argument_list|,
name|sp
argument_list|,
name|so_list
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_qlen
operator|--
expr_stmt|;
name|sp
operator|->
name|so_qstate
operator|&=
operator|~
name|SQ_COMP
expr_stmt|;
name|sp
operator|->
name|so_head
operator|=
name|NULL
expr_stmt|;
name|ACCEPT_UNLOCK
argument_list|()
expr_stmt|;
name|soabort
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|ACCEPT_LOCK
argument_list|()
expr_stmt|;
block|}
name|ACCEPT_UNLOCK
argument_list|()
expr_stmt|;
block|}
name|ACCEPT_LOCK
argument_list|()
expr_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NOFDREF
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"soclose: NOFDREF"
operator|)
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_state
operator||=
name|SS_NOFDREF
expr_stmt|;
name|sorele
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * soabort() is used to abruptly tear down a connection, such as when a  * resource limit is reached (listen queue depth exceeded), or if a listen  * socket is closed while there are sockets waiting to be accepted.  *  * This interface is tricky, because it is called on an unreferenced socket,  * and must be called only by a thread that has actually removed the socket  * from the listen queue it was on, or races with other threads are risked.  *  * This interface will call into the protocol code, so must not be called  * with any socket locks held.  Protocols do call it while holding their own  * recursible protocol mutexes, but this is something that should be subject  * to review in the future.  */
end_comment

begin_function
name|void
name|soabort
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
comment|/* 	 * In as much as is possible, assert that no references to this 	 * socket are held.  This is not quite the same as asserting that the 	 * current thread is responsible for arranging for no references, but 	 * is as close as we can get for now. 	 */
name|KASSERT
argument_list|(
name|so
operator|->
name|so_count
operator|==
literal|0
argument_list|,
operator|(
literal|"soabort: so_count"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_PROTOREF
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"soabort: SS_PROTOREF"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|so
operator|->
name|so_state
operator|&
name|SS_NOFDREF
argument_list|,
operator|(
literal|"soabort: !SS_NOFDREF"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SQ_COMP
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"soabort: SQ_COMP"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SQ_INCOMP
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"soabort: SQ_INCOMP"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_abort
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_abort
call|)
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|ACCEPT_LOCK
argument_list|()
expr_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sofree
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|soaccept
parameter_list|(
name|so
parameter_list|,
name|nam
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NOFDREF
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"soaccept: !NOFDREF"
operator|)
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_state
operator|&=
operator|~
name|SS_NOFDREF
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_accept
call|)
argument_list|(
name|so
argument_list|,
name|nam
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|soconnect
parameter_list|(
name|so
parameter_list|,
name|nam
parameter_list|,
name|td
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|nam
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_ACCEPTCONN
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
comment|/* 	 * If protocol is connection-based, can only connect once. 	 * Otherwise, if connected, try to disconnect first.  This allows 	 * user to disconnect by connecting to, e.g., a null address. 	 */
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
operator|(
name|SS_ISCONNECTED
operator||
name|SS_ISCONNECTING
operator|)
operator|&&
operator|(
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
operator|)
operator|||
operator|(
name|error
operator|=
name|sodisconnect
argument_list|(
name|so
argument_list|)
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EISCONN
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Prevent accumulated error from previous connection from 		 * biting us. 		 */
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_connect
call|)
argument_list|(
name|so
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|soconnect2
parameter_list|(
name|so1
parameter_list|,
name|so2
parameter_list|)
name|struct
name|socket
modifier|*
name|so1
decl_stmt|;
name|struct
name|socket
modifier|*
name|so2
decl_stmt|;
block|{
return|return
operator|(
call|(
modifier|*
name|so1
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_connect2
call|)
argument_list|(
name|so1
argument_list|,
name|so2
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sodisconnect
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOTCONN
operator|)
return|;
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISDISCONNECTING
condition|)
return|return
operator|(
name|EALREADY
operator|)
return|;
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_disconnect
call|)
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ZERO_COPY_SOCKETS
end_ifdef

begin_struct
struct|struct
name|so_zerocopy_stats
block|{
name|int
name|size_ok
decl_stmt|;
name|int
name|align_ok
decl_stmt|;
name|int
name|found_ifp
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|so_zerocopy_stats
name|so_zerocp_stats
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_comment
comment|/*  * sosend_copyin() is only used if zero copy sockets are enabled.  Otherwise  * sosend_dgram() and sosend_generic() use m_uiotombuf().  *   * sosend_copyin() accepts a uio and prepares an mbuf chain holding part or  * all of the data referenced by the uio.  If desired, it uses zero-copy.  * *space will be updated to reflect data copied in.  *  * NB: If atomic I/O is requested, the caller must already have checked that  * space can hold resid bytes.  *  * NB: In the event of an error, the caller may need to free the partial  * chain pointed to by *mpp.  The contents of both *uio and *space may be  * modified even in the case of an error.  */
end_comment

begin_function
specifier|static
name|int
name|sosend_copyin
parameter_list|(
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|retmp
parameter_list|,
name|int
name|atomic
parameter_list|,
name|long
modifier|*
name|space
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|,
modifier|*
name|top
decl_stmt|;
name|long
name|len
decl_stmt|,
name|resid
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|ZERO_COPY_SOCKETS
name|int
name|cow_send
decl_stmt|;
endif|#
directive|endif
operator|*
name|retmp
operator|=
name|top
operator|=
name|NULL
expr_stmt|;
name|mp
operator|=
operator|&
name|top
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
do|do
block|{
ifdef|#
directive|ifdef
name|ZERO_COPY_SOCKETS
name|cow_send
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* ZERO_COPY_SOCKETS */
if|if
condition|(
name|resid
operator|>=
name|MINCLSIZE
condition|)
block|{
ifdef|#
directive|ifdef
name|ZERO_COPY_SOCKETS
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_TRYWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_TRYWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|so_zero_copy_send
operator|&&
name|resid
operator|>=
name|PAGE_SIZE
operator|&&
operator|*
name|space
operator|>=
name|PAGE_SIZE
operator|&&
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|>=
name|PAGE_SIZE
condition|)
block|{
name|so_zerocp_stats
operator|.
name|size_ok
operator|++
expr_stmt|;
name|so_zerocp_stats
operator|.
name|align_ok
operator|++
expr_stmt|;
name|cow_send
operator|=
name|socow_setup
argument_list|(
name|m
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|len
operator|=
name|cow_send
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cow_send
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_TRYWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|min
argument_list|(
name|min
argument_list|(
name|MCLBYTES
argument_list|,
name|resid
argument_list|)
argument_list|,
operator|*
name|space
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* ZERO_COPY_SOCKETS */
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
name|m_getcl
argument_list|(
name|M_TRYWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|m
operator|=
name|m_getcl
argument_list|(
name|M_TRYWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|min
argument_list|(
name|MCLBYTES
argument_list|,
name|resid
argument_list|)
argument_list|,
operator|*
name|space
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ZERO_COPY_SOCKETS */
block|}
else|else
block|{
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_TRYWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|min
argument_list|(
name|MHLEN
argument_list|,
name|resid
argument_list|)
argument_list|,
operator|*
name|space
argument_list|)
expr_stmt|;
comment|/* 				 * For datagram protocols, leave room 				 * for protocol headers in first mbuf. 				 */
if|if
condition|(
name|atomic
operator|&&
name|m
operator|&&
name|len
operator|<
name|MHLEN
condition|)
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|m_get
argument_list|(
name|M_TRYWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|min
argument_list|(
name|MLEN
argument_list|,
name|resid
argument_list|)
argument_list|,
operator|*
name|space
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|*
name|space
operator|-=
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|ZERO_COPY_SOCKETS
if|if
condition|(
name|cow_send
condition|)
name|error
operator|=
literal|0
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* ZERO_COPY_SOCKETS */
name|error
operator|=
name|uiomove
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|top
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|resid
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|MSG_EOR
condition|)
name|top
operator|->
name|m_flags
operator||=
name|M_EOR
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|*
name|space
operator|>
literal|0
operator|&&
name|atomic
condition|)
do|;
name|out
label|:
operator|*
name|retmp
operator|=
name|top
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*ZERO_COPY_SOCKETS*/
end_comment

begin_define
define|#
directive|define
name|SBLOCKWAIT
parameter_list|(
name|f
parameter_list|)
value|(((f)& MSG_DONTWAIT) ? M_NOWAIT : M_WAITOK)
end_define

begin_function
name|int
name|sosend_dgram
parameter_list|(
name|so
parameter_list|,
name|addr
parameter_list|,
name|uio
parameter_list|,
name|top
parameter_list|,
name|control
parameter_list|,
name|flags
parameter_list|,
name|td
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|control
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|long
name|space
decl_stmt|,
name|resid
decl_stmt|;
name|int
name|clen
init|=
literal|0
decl_stmt|,
name|error
decl_stmt|,
name|dontroute
decl_stmt|;
ifdef|#
directive|ifdef
name|ZERO_COPY_SOCKETS
name|int
name|atomic
init|=
name|sosendallatonce
argument_list|(
name|so
argument_list|)
operator|||
name|top
decl_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_DGRAM
argument_list|,
operator|(
literal|"sodgram_send: !SOCK_DGRAM"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_ATOMIC
argument_list|,
operator|(
literal|"sodgram_send: !PR_ATOMIC"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|!=
name|NULL
condition|)
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
else|else
name|resid
operator|=
name|top
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* 	 * In theory resid should be unsigned.  However, space must be 	 * signed, as it might be less than 0 if we over-committed, and we 	 * must use a signed comparison of space and resid.  On the other 	 * hand, a negative resid causes us to loop sending 0-length 	 * segments to the protocol. 	 * 	 * Also check to make sure that MSG_EOR isn't used on SOCK_STREAM 	 * type sockets since that's an error. 	 */
if|if
condition|(
name|resid
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dontroute
operator|=
operator|(
name|flags
operator|&
name|MSG_DONTROUTE
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_DONTROUTE
operator|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|td
operator|!=
name|NULL
condition|)
name|td
operator|->
name|td_proc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_msgsnd
operator|++
expr_stmt|;
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
name|clen
operator|=
name|control
operator|->
name|m_len
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_state
operator|&
name|SBS_CANTSENDMORE
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPIPE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * `sendto' and `sendmsg' is allowed on a connection-based 		 * socket if it supports implied connect.  Return ENOTCONN if 		 * not connected and no address is supplied. 		 */
if|if
condition|(
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_IMPLOPCL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONFIRMING
operator|)
operator|==
literal|0
operator|&&
operator|!
operator|(
name|resid
operator|==
literal|0
operator|&&
name|clen
operator|!=
literal|0
operator|)
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
condition|)
name|error
operator|=
name|ENOTCONN
expr_stmt|;
else|else
name|error
operator|=
name|EDESTADDRREQ
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * Do we need MSG_OOB support in SOCK_DGRAM?  Signs here may be a 	 * problem and need fixing. 	 */
name|space
operator|=
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MSG_OOB
condition|)
name|space
operator|+=
literal|1024
expr_stmt|;
name|space
operator|-=
name|clen
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|resid
operator|>
name|space
condition|)
block|{
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|uio
operator|==
name|NULL
condition|)
block|{
name|resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MSG_EOR
condition|)
name|top
operator|->
name|m_flags
operator||=
name|M_EOR
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ZERO_COPY_SOCKETS
name|error
operator|=
name|sosend_copyin
argument_list|(
name|uio
argument_list|,
operator|&
name|top
argument_list|,
name|atomic
argument_list|,
operator|&
name|space
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
else|#
directive|else
comment|/* 		 * Copy the data from userland into a mbuf chain. 		 * If no data is to be copied in, a single empty mbuf 		 * is returned. 		 */
name|top
operator|=
name|m_uiotombuf
argument_list|(
name|uio
argument_list|,
name|M_WAITOK
argument_list|,
name|space
argument_list|,
name|max_hdr
argument_list|,
operator|(
name|M_PKTHDR
operator||
operator|(
operator|(
name|flags
operator|&
name|MSG_EOR
operator|)
condition|?
name|M_EOR
else|:
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
comment|/* only possible error */
goto|goto
name|out
goto|;
block|}
name|space
operator|-=
name|resid
operator|-
name|uio
operator|->
name|uio_resid
expr_stmt|;
endif|#
directive|endif
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|resid
operator|==
literal|0
argument_list|,
operator|(
literal|"sosend_dgram: resid != 0"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * XXXRW: Frobbing SO_DONTROUTE here is even worse without sblock 	 * than with. 	 */
if|if
condition|(
name|dontroute
condition|)
block|{
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_options
operator||=
name|SO_DONTROUTE
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX all the SBS_CANTSENDMORE checks previously done could be out 	 * of date.  We could have recieved a reset packet in an interrupt or 	 * maybe we slept while doing page faults in uiomove() etc.  We could 	 * probably recheck again inside the locking protection here, but 	 * there are probably other places that this also happens.  We must 	 * rethink this. 	 */
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_send
call|)
argument_list|(
name|so
argument_list|,
operator|(
name|flags
operator|&
name|MSG_OOB
operator|)
condition|?
name|PRUS_OOB
else|:
comment|/* 	 * If the user set MSG_EOF, the protocol understands this flag and 	 * nothing left to send then use PRU_SEND_EOF instead of PRU_SEND. 	 */
operator|(
operator|(
name|flags
operator|&
name|MSG_EOF
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_IMPLOPCL
operator|)
operator|&&
operator|(
name|resid
operator|<=
literal|0
operator|)
operator|)
condition|?
name|PRUS_EOF
else|:
comment|/* If there is more to send set PRUS_MORETOCOME */
operator|(
name|resid
operator|>
literal|0
operator|&&
name|space
operator|>
literal|0
operator|)
condition|?
name|PRUS_MORETOCOME
else|:
literal|0
argument_list|,
name|top
argument_list|,
name|addr
argument_list|,
name|control
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|dontroute
condition|)
block|{
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_options
operator|&=
operator|~
name|SO_DONTROUTE
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|clen
operator|=
literal|0
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
name|top
operator|=
name|NULL
expr_stmt|;
name|out
label|:
if|if
condition|(
name|top
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send on a socket.  If send must go all at once and message is larger than  * send buffering, then hard error.  Lock against other senders.  If must go  * all at once and not enough room now, then inform user that this would  * block and do nothing.  Otherwise, if nonblocking, send as much as  * possible.  The data to be sent is described by "uio" if nonzero, otherwise  * by the mbuf chain "top" (which must be null if uio is not).  Data provided  * in mbuf chain must be small enough to send all at once.  *  * Returns nonzero on error, timeout or signal; callers must check for short  * counts if EINTR/ERESTART are returned.  Data and control buffers are freed  * on return.  */
end_comment

begin_define
define|#
directive|define
name|snderr
parameter_list|(
name|errno
parameter_list|)
value|{ error = (errno); goto release; }
end_define

begin_function
name|int
name|sosend_generic
parameter_list|(
name|so
parameter_list|,
name|addr
parameter_list|,
name|uio
parameter_list|,
name|top
parameter_list|,
name|control
parameter_list|,
name|flags
parameter_list|,
name|td
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|control
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|long
name|space
decl_stmt|,
name|resid
decl_stmt|;
name|int
name|clen
init|=
literal|0
decl_stmt|,
name|error
decl_stmt|,
name|dontroute
decl_stmt|;
name|int
name|atomic
init|=
name|sosendallatonce
argument_list|(
name|so
argument_list|)
operator|||
name|top
decl_stmt|;
if|if
condition|(
name|uio
operator|!=
name|NULL
condition|)
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
else|else
name|resid
operator|=
name|top
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* 	 * In theory resid should be unsigned.  However, space must be 	 * signed, as it might be less than 0 if we over-committed, and we 	 * must use a signed comparison of space and resid.  On the other 	 * hand, a negative resid causes us to loop sending 0-length 	 * segments to the protocol. 	 * 	 * Also check to make sure that MSG_EOR isn't used on SOCK_STREAM 	 * type sockets since that's an error. 	 */
if|if
condition|(
name|resid
operator|<
literal|0
operator|||
operator|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_STREAM
operator|&&
operator|(
name|flags
operator|&
name|MSG_EOR
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dontroute
operator|=
operator|(
name|flags
operator|&
name|MSG_DONTROUTE
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_DONTROUTE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_ATOMIC
operator|)
expr_stmt|;
if|if
condition|(
name|td
operator|!=
name|NULL
condition|)
name|td
operator|->
name|td_proc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_msgsnd
operator|++
expr_stmt|;
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
name|clen
operator|=
name|control
operator|->
name|m_len
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|restart
label|:
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|error
operator|=
name|sblock
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
name|SBLOCKWAIT
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out_locked
goto|;
do|do
block|{
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_state
operator|&
name|SBS_CANTSENDMORE
condition|)
name|snderr
argument_list|(
name|EPIPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * `sendto' and `sendmsg' is allowed on a connection- 			 * based socket if it supports implied connect. 			 * Return ENOTCONN if not connected and no address is 			 * supplied. 			 */
if|if
condition|(
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_IMPLOPCL
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONFIRMING
operator|)
operator|==
literal|0
operator|&&
operator|!
operator|(
name|resid
operator|==
literal|0
operator|&&
name|clen
operator|!=
literal|0
operator|)
condition|)
name|snderr
argument_list|(
name|ENOTCONN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
name|snderr
argument_list|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
condition|?
name|ENOTCONN
else|:
name|EDESTADDRREQ
argument_list|)
expr_stmt|;
block|}
name|space
operator|=
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MSG_OOB
condition|)
name|space
operator|+=
literal|1024
expr_stmt|;
if|if
condition|(
operator|(
name|atomic
operator|&&
name|resid
operator|>
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|)
operator|||
name|clen
operator|>
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
condition|)
name|snderr
argument_list|(
name|EMSGSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|<
name|resid
operator|+
name|clen
operator|&&
operator|(
name|atomic
operator|||
name|space
operator|<
name|so
operator|->
name|so_snd
operator|.
name|sb_lowat
operator|||
name|space
operator|<
name|clen
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|)
operator|||
operator|(
name|flags
operator|&
name|MSG_NBIO
operator|)
condition|)
name|snderr
argument_list|(
name|EWOULDBLOCK
argument_list|)
expr_stmt|;
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out_locked
goto|;
goto|goto
name|restart
goto|;
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|space
operator|-=
name|clen
expr_stmt|;
do|do
block|{
if|if
condition|(
name|uio
operator|==
name|NULL
condition|)
block|{
name|resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MSG_EOR
condition|)
name|top
operator|->
name|m_flags
operator||=
name|M_EOR
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ZERO_COPY_SOCKETS
name|error
operator|=
name|sosend_copyin
argument_list|(
name|uio
argument_list|,
operator|&
name|top
argument_list|,
name|atomic
argument_list|,
operator|&
name|space
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
goto|goto
name|release
goto|;
block|}
else|#
directive|else
comment|/* 				 * Copy the data from userland into a mbuf 				 * chain.  If no data is to be copied in, 				 * a single empty mbuf is returned. 				 */
name|top
operator|=
name|m_uiotombuf
argument_list|(
name|uio
argument_list|,
name|M_WAITOK
argument_list|,
name|space
argument_list|,
operator|(
name|atomic
condition|?
name|max_hdr
else|:
literal|0
operator|)
argument_list|,
operator|(
name|atomic
condition|?
name|M_PKTHDR
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|flags
operator|&
name|MSG_EOR
operator|)
condition|?
name|M_EOR
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
block|{
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
comment|/* only possible error */
goto|goto
name|release
goto|;
block|}
name|space
operator|-=
name|resid
operator|-
name|uio
operator|->
name|uio_resid
expr_stmt|;
endif|#
directive|endif
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
block|}
if|if
condition|(
name|dontroute
condition|)
block|{
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_options
operator||=
name|SO_DONTROUTE
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * XXX all the SBS_CANTSENDMORE checks previously 			 * done could be out of date.  We could have recieved 			 * a reset packet in an interrupt or maybe we slept 			 * while doing page faults in uiomove() etc.  We 			 * could probably recheck again inside the locking 			 * protection here, but there are probably other 			 * places that this also happens.  We must rethink 			 * this. 			 */
name|error
operator|=
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_send
call|)
argument_list|(
name|so
argument_list|,
operator|(
name|flags
operator|&
name|MSG_OOB
operator|)
condition|?
name|PRUS_OOB
else|:
comment|/* 			 * If the user set MSG_EOF, the protocol understands 			 * this flag and nothing left to send then use 			 * PRU_SEND_EOF instead of PRU_SEND. 			 */
operator|(
operator|(
name|flags
operator|&
name|MSG_EOF
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_IMPLOPCL
operator|)
operator|&&
operator|(
name|resid
operator|<=
literal|0
operator|)
operator|)
condition|?
name|PRUS_EOF
else|:
comment|/* If there is more to send set PRUS_MORETOCOME. */
operator|(
name|resid
operator|>
literal|0
operator|&&
name|space
operator|>
literal|0
operator|)
condition|?
name|PRUS_MORETOCOME
else|:
literal|0
argument_list|,
name|top
argument_list|,
name|addr
argument_list|,
name|control
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|dontroute
condition|)
block|{
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_options
operator|&=
operator|~
name|SO_DONTROUTE
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|clen
operator|=
literal|0
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
name|top
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
goto|goto
name|release
goto|;
block|}
block|}
do|while
condition|(
name|resid
operator|&&
name|space
operator|>
literal|0
condition|)
do|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|resid
condition|)
do|;
name|release
label|:
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|out_locked
label|:
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|top
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|snderr
end_undef

begin_function
name|int
name|sosend
parameter_list|(
name|so
parameter_list|,
name|addr
parameter_list|,
name|uio
parameter_list|,
name|top
parameter_list|,
name|control
parameter_list|,
name|flags
parameter_list|,
name|td
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|control
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
comment|/* XXXRW: Temporary debugging. */
name|KASSERT
argument_list|(
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_sosend
operator|!=
name|sosend
argument_list|,
operator|(
literal|"sosend: protocol calls sosend"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_sosend
argument_list|(
name|so
argument_list|,
name|addr
argument_list|,
name|uio
argument_list|,
name|top
argument_list|,
name|control
argument_list|,
name|flags
argument_list|,
name|td
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The part of soreceive() that implements reading non-inline out-of-band  * data from a socket.  For more complete comments, see soreceive(), from  * which this code originated.  *  * Note that soreceive_rcvoob(), unlike the remainder of soreceive(), is  * unable to return an mbuf chain to the caller.  */
end_comment

begin_function
specifier|static
name|int
name|soreceive_rcvoob
parameter_list|(
name|so
parameter_list|,
name|uio
parameter_list|,
name|flags
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|protosw
modifier|*
name|pr
init|=
name|so
operator|->
name|so_proto
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|flags
operator|&
name|MSG_OOB
argument_list|,
operator|(
literal|"soreceive_rcvoob: (flags& MSG_OOB) == 0"
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_get
argument_list|(
name|M_TRYWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|error
operator|=
call|(
modifier|*
name|pr
operator|->
name|pr_usrreqs
operator|->
name|pru_rcvoob
call|)
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|flags
operator|&
name|MSG_PEEK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
do|do
block|{
ifdef|#
directive|ifdef
name|ZERO_COPY_SOCKETS
if|if
condition|(
name|so_zero_copy_receive
condition|)
block|{
name|int
name|disposable
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_ext
operator|.
name|ext_type
operator|==
name|EXT_DISPOSABLE
operator|)
condition|)
name|disposable
operator|=
literal|1
expr_stmt|;
else|else
name|disposable
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|uiomoveco
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|min
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
argument_list|,
name|uio
argument_list|,
name|disposable
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* ZERO_COPY_SOCKETS */
name|error
operator|=
name|uiomove
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|min
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|uio
operator|->
name|uio_resid
operator|&&
name|error
operator|==
literal|0
operator|&&
name|m
condition|)
do|;
name|bad
label|:
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Following replacement or removal of the first mbuf on the first mbuf chain  * of a socket buffer, push necessary state changes back into the socket  * buffer so that other consumers see the values consistently.  'nextrecord'  * is the callers locally stored value of the original value of  * sb->sb_mb->m_nextpkt which must be restored when the lead mbuf changes.  * NOTE: 'nextrecord' may be NULL.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|sockbuf_pushsync
parameter_list|(
name|struct
name|sockbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|nextrecord
parameter_list|)
block|{
name|SOCKBUF_LOCK_ASSERT
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|/* 	 * First, update for the new value of nextrecord.  If necessary, make 	 * it the first record. 	 */
if|if
condition|(
name|sb
operator|->
name|sb_mb
operator|!=
name|NULL
condition|)
name|sb
operator|->
name|sb_mb
operator|->
name|m_nextpkt
operator|=
name|nextrecord
expr_stmt|;
else|else
name|sb
operator|->
name|sb_mb
operator|=
name|nextrecord
expr_stmt|;
comment|/*          * Now update any dependent socket buffer fields to reflect the new          * state.  This is an expanded inline of SB_EMPTY_FIXUP(), with the 	 * addition of a second clause that takes care of the case where 	 * sb_mb has been updated, but remains the last record.          */
if|if
condition|(
name|sb
operator|->
name|sb_mb
operator|==
name|NULL
condition|)
block|{
name|sb
operator|->
name|sb_mbtail
operator|=
name|NULL
expr_stmt|;
name|sb
operator|->
name|sb_lastrecord
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sb
operator|->
name|sb_mb
operator|->
name|m_nextpkt
operator|==
name|NULL
condition|)
name|sb
operator|->
name|sb_lastrecord
operator|=
name|sb
operator|->
name|sb_mb
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Implement receive operations on a socket.  We depend on the way that  * records are added to the sockbuf by sbappend.  In particular, each record  * (mbufs linked through m_next) must begin with an address if the protocol  * so specifies, followed by an optional mbuf or mbufs containing ancillary  * data, and then zero or more mbufs of data.  In order to allow parallelism  * between network receive and copying to user space, as well as avoid  * sleeping with a mutex held, we release the socket buffer mutex during the  * user space copy.  Although the sockbuf is locked, new data may still be  * appended, and thus we must maintain consistency of the sockbuf during that  * time.  *  * The caller may receive the data as a single mbuf chain by supplying an  * mbuf **mp0 for use in returning the chain.  The uio is then used only for  * the count in uio_resid.  */
end_comment

begin_function
name|int
name|soreceive_generic
parameter_list|(
name|so
parameter_list|,
name|psa
parameter_list|,
name|uio
parameter_list|,
name|mp0
parameter_list|,
name|controlp
parameter_list|,
name|flagsp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr
modifier|*
modifier|*
name|psa
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mp0
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|controlp
decl_stmt|;
name|int
modifier|*
name|flagsp
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|len
decl_stmt|,
name|error
decl_stmt|,
name|offset
decl_stmt|;
name|struct
name|protosw
modifier|*
name|pr
init|=
name|so
operator|->
name|so_proto
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|nextrecord
decl_stmt|;
name|int
name|moff
decl_stmt|,
name|type
init|=
literal|0
decl_stmt|;
name|int
name|orig_resid
init|=
name|uio
operator|->
name|uio_resid
decl_stmt|;
name|mp
operator|=
name|mp0
expr_stmt|;
if|if
condition|(
name|psa
operator|!=
name|NULL
condition|)
operator|*
name|psa
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
operator|*
name|controlp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|flagsp
operator|!=
name|NULL
condition|)
name|flags
operator|=
operator|*
name|flagsp
operator|&
operator|~
name|MSG_EOR
expr_stmt|;
else|else
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MSG_OOB
condition|)
return|return
operator|(
name|soreceive_rcvoob
argument_list|(
name|so
argument_list|,
name|uio
argument_list|,
name|flags
argument_list|)
operator|)
return|;
if|if
condition|(
name|mp
operator|!=
name|NULL
condition|)
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|pr
operator|->
name|pr_flags
operator|&
name|PR_WANTRCVD
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONFIRMING
operator|)
operator|&&
name|uio
operator|->
name|uio_resid
condition|)
call|(
modifier|*
name|pr
operator|->
name|pr_usrreqs
operator|->
name|pru_rcvd
call|)
argument_list|(
name|so
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|restart
label|:
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|error
operator|=
name|sblock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|SBLOCKWAIT
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
comment|/* 	 * If we have less data than requested, block awaiting more (subject 	 * to any timeout) if: 	 *   1. the current count is less than the low water mark, or 	 *   2. MSG_WAITALL is set, and it is possible to do the entire 	 *	receive operation at once if we block (resid<= hiwat). 	 *   3. MSG_DONTWAIT is not set 	 * If MSG_WAITALL is set but resid is larger than the receive buffer, 	 * we have to do the receive in sections, and thus risk returning a 	 * short count if a timeout or signal occurs after we start. 	 */
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
operator|(
operator|(
operator|(
name|flags
operator|&
name|MSG_DONTWAIT
operator|)
operator|==
literal|0
operator|&&
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|<
name|uio
operator|->
name|uio_resid
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|<
name|so
operator|->
name|so_rcv
operator|.
name|sb_lowat
operator|||
operator|(
operator|(
name|flags
operator|&
name|MSG_WAITALL
operator|)
operator|&&
name|uio
operator|->
name|uio_resid
operator|<=
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|)
operator|)
operator|&&
name|m
operator|->
name|m_nextpkt
operator|==
name|NULL
operator|&&
operator|(
name|pr
operator|->
name|pr_flags
operator|&
name|PR_ATOMIC
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|KASSERT
argument_list|(
name|m
operator|!=
name|NULL
operator|||
operator|!
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
argument_list|,
operator|(
literal|"receive: m == %p so->so_rcv.sb_cc == %u"
operator|,
name|m
operator|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
goto|goto
name|dontblock
goto|;
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
goto|goto
name|release
goto|;
block|}
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
block|{
if|if
condition|(
name|m
condition|)
goto|goto
name|dontblock
goto|;
else|else
goto|goto
name|release
goto|;
block|}
for|for
control|(
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
if|if
condition|(
name|m
operator|->
name|m_type
operator|==
name|MT_OOBDATA
operator|||
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EOR
operator|)
condition|)
block|{
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
goto|goto
name|dontblock
goto|;
block|}
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
operator|(
name|SS_ISCONNECTED
operator||
name|SS_ISCONNECTING
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
operator|)
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
goto|goto
name|release
goto|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|)
operator|||
operator|(
name|flags
operator|&
operator|(
name|MSG_DONTWAIT
operator||
name|MSG_NBIO
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
goto|goto
name|release
goto|;
block|}
name|SBLASTRECORDCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SBLASTMBUFCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
goto|goto
name|restart
goto|;
block|}
name|dontblock
label|:
comment|/* 	 * From this point onward, we maintain 'nextrecord' as a cache of the 	 * pointer to the next record in the socket buffer.  We must keep the 	 * various socket buffer pointers and local stack versions of the 	 * pointers in sync, pushing out modifications before dropping the 	 * socket buffer mutex, and re-reading them when picking it up. 	 * 	 * Otherwise, we will race with the network stack appending new data 	 * or records onto the socket buffer by using inconsistent/stale 	 * versions of the field, possibly resulting in socket buffer 	 * corruption. 	 * 	 * By holding the high-level sblock(), we prevent simultaneous 	 * readers from pulling off the front of the socket buffer. 	 */
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_td
condition|)
name|uio
operator|->
name|uio_td
operator|->
name|td_proc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_msgrcv
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|==
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
argument_list|,
operator|(
literal|"soreceive: m != so->so_rcv.sb_mb"
operator|)
argument_list|)
expr_stmt|;
name|SBLASTRECORDCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SBLASTMBUFCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|nextrecord
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|pr_flags
operator|&
name|PR_ADDR
condition|)
block|{
name|KASSERT
argument_list|(
name|m
operator|->
name|m_type
operator|==
name|MT_SONAME
argument_list|,
operator|(
literal|"m->m_type == %d"
operator|,
name|m
operator|->
name|m_type
operator|)
argument_list|)
expr_stmt|;
name|orig_resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|psa
operator|!=
name|NULL
condition|)
operator|*
name|psa
operator|=
name|sodupsockaddr
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sockaddr
operator|*
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MSG_PEEK
condition|)
block|{
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
else|else
block|{
name|sbfree
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
name|sockbuf_pushsync
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|nextrecord
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Process one or more MT_CONTROL mbufs present before any data mbufs 	 * in the first mbuf chain on the socket buffer.  If MSG_PEEK, we 	 * just copy the data; if !MSG_PEEK, we call into the protocol to 	 * perform externalization (or freeing if controlp == NULL). 	 */
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|m
operator|->
name|m_type
operator|==
name|MT_CONTROL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|cm
init|=
name|NULL
decl_stmt|,
modifier|*
name|cmn
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|cme
init|=
operator|&
name|cm
decl_stmt|;
do|do
block|{
if|if
condition|(
name|flags
operator|&
name|MSG_PEEK
condition|)
block|{
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|controlp
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|controlp
operator|=
operator|&
operator|(
operator|*
name|controlp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
else|else
block|{
name|sbfree
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
operator|*
name|cme
operator|=
name|m
expr_stmt|;
name|cme
operator|=
operator|&
operator|(
operator|*
name|cme
operator|)
operator|->
name|m_next
expr_stmt|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
block|}
block|}
do|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|m
operator|->
name|m_type
operator|==
name|MT_CONTROL
condition|)
do|;
if|if
condition|(
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
name|sockbuf_pushsync
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|nextrecord
argument_list|)
expr_stmt|;
while|while
condition|(
name|cm
operator|!=
name|NULL
condition|)
block|{
name|cmn
operator|=
name|cm
operator|->
name|m_next
expr_stmt|;
name|cm
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|pr_domain
operator|->
name|dom_externalize
operator|!=
name|NULL
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|pr
operator|->
name|pr_domain
operator|->
name|dom_externalize
call|)
argument_list|(
name|cm
argument_list|,
name|controlp
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
operator|*
name|controlp
operator|=
name|cm
expr_stmt|;
else|else
name|m_freem
argument_list|(
name|cm
argument_list|)
expr_stmt|;
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
block|{
name|orig_resid
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|controlp
operator|!=
name|NULL
condition|)
name|controlp
operator|=
operator|&
operator|(
operator|*
name|controlp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
name|cm
operator|=
name|cmn
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|nextrecord
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|->
name|m_nextpkt
expr_stmt|;
else|else
name|nextrecord
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
name|orig_resid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|m
operator|->
name|m_nextpkt
operator|==
name|nextrecord
argument_list|,
operator|(
literal|"soreceive: post-control, nextrecord !sync"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextrecord
operator|==
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|==
name|m
argument_list|,
operator|(
literal|"soreceive: post-control, sb_mb!=m"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_lastrecord
operator|==
name|m
argument_list|,
operator|(
literal|"soreceive: post-control, lastrecord!=m"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|type
operator|=
name|m
operator|->
name|m_type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|MT_OOBDATA
condition|)
name|flags
operator||=
name|MSG_OOB
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|==
name|nextrecord
argument_list|,
operator|(
literal|"soreceive: sb_mb != nextrecord"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|==
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_lastrecord
operator|==
name|NULL
argument_list|,
operator|(
literal|"soreceive: sb_lastercord != NULL"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SBLASTRECORDCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SBLASTMBUFCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* 	 * Now continue to read any data mbufs off of the head of the socket 	 * buffer until the read request is satisfied.  Note that 'type' is 	 * used to store the type of any mbuf reads that have happened so far 	 * such that soreceive() can stop reading if the type changes, which 	 * causes soreceive() to return only one of regular data and inline 	 * out-of-band data in a single socket receive operation. 	 */
name|moff
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If the type of mbuf has changed since the last mbuf 		 * examined ('type'), end the receive operation. 	 	 */
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_type
operator|==
name|MT_OOBDATA
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|MT_OOBDATA
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|MT_OOBDATA
condition|)
break|break;
else|else
name|KASSERT
argument_list|(
name|m
operator|->
name|m_type
operator|==
name|MT_DATA
argument_list|,
operator|(
literal|"m->m_type == %d"
operator|,
name|m
operator|->
name|m_type
operator|)
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&=
operator|~
name|SBS_RCVATMARK
expr_stmt|;
name|len
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_oobmark
operator|&&
name|len
operator|>
name|so
operator|->
name|so_oobmark
operator|-
name|offset
condition|)
name|len
operator|=
name|so
operator|->
name|so_oobmark
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|m
operator|->
name|m_len
operator|-
name|moff
condition|)
name|len
operator|=
name|m
operator|->
name|m_len
operator|-
name|moff
expr_stmt|;
comment|/* 		 * If mp is set, just pass back the mbufs.  Otherwise copy 		 * them out via the uio, then free.  Sockbuf must be 		 * consistent here (points to current mbuf, it points to next 		 * record) when we drop priority; we must note any additions 		 * to the sockbuf when we block interrupts again. 		 */
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
block|{
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SBLASTRECORDCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SBLASTMBUFCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZERO_COPY_SOCKETS
if|if
condition|(
name|so_zero_copy_receive
condition|)
block|{
name|int
name|disposable
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_ext
operator|.
name|ext_type
operator|==
name|EXT_DISPOSABLE
operator|)
condition|)
name|disposable
operator|=
literal|1
expr_stmt|;
else|else
name|disposable
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|uiomoveco
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|moff
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|uio
argument_list|,
name|disposable
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* ZERO_COPY_SOCKETS */
name|error
operator|=
name|uiomove
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|moff
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 				 * The MT_SONAME mbuf has already been removed 				 * from the record, so it is necessary to 				 * remove the data mbufs, if any, to preserve 				 * the invariant in the case of PR_ADDR that 				 * requires MT_SONAME mbufs at the head of 				 * each record. 				 */
if|if
condition|(
name|m
operator|&&
name|pr
operator|->
name|pr_flags
operator|&
name|PR_ATOMIC
operator|&&
operator|(
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
operator|)
condition|)
operator|(
name|void
operator|)
name|sbdroprecord_locked
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
goto|goto
name|release
goto|;
block|}
block|}
else|else
name|uio
operator|->
name|uio_resid
operator|-=
name|len
expr_stmt|;
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|m
operator|->
name|m_len
operator|-
name|moff
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EOR
condition|)
name|flags
operator||=
name|MSG_EOR
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MSG_PEEK
condition|)
block|{
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|moff
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|nextrecord
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|sbfree
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
block|}
name|sockbuf_pushsync
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|nextrecord
argument_list|)
expr_stmt|;
name|SBLASTRECORDCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SBLASTMBUFCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|flags
operator|&
name|MSG_PEEK
condition|)
name|moff
operator|+=
name|len
expr_stmt|;
else|else
block|{
if|if
condition|(
name|mp
operator|!=
name|NULL
condition|)
block|{
name|int
name|copy_flag
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|MSG_DONTWAIT
condition|)
name|copy_flag
operator|=
name|M_DONTWAIT
expr_stmt|;
else|else
name|copy_flag
operator|=
name|M_TRYWAIT
expr_stmt|;
if|if
condition|(
name|copy_flag
operator|==
name|M_TRYWAIT
condition|)
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|m_copym
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|copy_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_flag
operator|==
name|M_TRYWAIT
condition|)
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
block|{
comment|/*  						 * m_copym() couldn't 						 * allocate an mbuf.  Adjust 						 * uio_resid back (it was 						 * adjusted down by len 						 * bytes, which we didn't end 						 * up "copying" over).  						 */
name|uio
operator|->
name|uio_resid
operator|+=
name|len
expr_stmt|;
break|break;
block|}
block|}
name|m
operator|->
name|m_data
operator|+=
name|len
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|len
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|-=
name|len
expr_stmt|;
block|}
block|}
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_oobmark
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
block|{
name|so
operator|->
name|so_oobmark
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_oobmark
operator|==
literal|0
condition|)
block|{
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator||=
name|SBS_RCVATMARK
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|offset
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|offset
operator|==
name|so
operator|->
name|so_oobmark
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|MSG_EOR
condition|)
break|break;
comment|/* 		 * If the MSG_WAITALL flag is set (for non-atomic socket), we 		 * must not quit until "uio->uio_resid == 0" or an error 		 * termination.  If a signal/timeout occurs, return with a 		 * short count but without error.  Keep sockbuf locked 		 * against other readers. 		 */
while|while
condition|(
name|flags
operator|&
name|MSG_WAITALL
operator|&&
name|m
operator|==
name|NULL
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
operator|!
name|sosendallatonce
argument_list|(
name|so
argument_list|)
operator|&&
name|nextrecord
operator|==
name|NULL
condition|)
block|{
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_error
operator|||
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
break|break;
comment|/* 			 * Notify the protocol that some data has been 			 * drained before blocking. 			 */
if|if
condition|(
name|pr
operator|->
name|pr_flags
operator|&
name|PR_WANTRCVD
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pr
operator|->
name|pr_usrreqs
operator|->
name|pru_rcvd
call|)
argument_list|(
name|so
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
name|SBLASTRECORDCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SBLASTMBUFCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|release
goto|;
name|m
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|nextrecord
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
block|}
block|}
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|pr
operator|->
name|pr_flags
operator|&
name|PR_ATOMIC
condition|)
block|{
name|flags
operator||=
name|MSG_TRUNC
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|sbdroprecord_locked
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * First part is an inline SB_EMPTY_FIXUP().  Second 			 * part makes sure sb_lastrecord is up-to-date if 			 * there is still data in the socket buffer. 			 */
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|nextrecord
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|==
name|NULL
condition|)
block|{
name|so
operator|->
name|so_rcv
operator|.
name|sb_mbtail
operator|=
name|NULL
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_lastrecord
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nextrecord
operator|->
name|m_nextpkt
operator|==
name|NULL
condition|)
name|so
operator|->
name|so_rcv
operator|.
name|sb_lastrecord
operator|=
name|nextrecord
expr_stmt|;
block|}
name|SBLASTRECORDCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SBLASTMBUFCHK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* 		 * If soreceive() is being done from the socket callback, 		 * then don't need to generate ACK to peer to update window, 		 * since ACK will be generated on return to TCP. 		 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|MSG_SOCALLBCK
operator|)
operator|&&
operator|(
name|pr
operator|->
name|pr_flags
operator|&
name|PR_WANTRCVD
operator|)
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
call|(
modifier|*
name|pr
operator|->
name|pr_usrreqs
operator|->
name|pru_rcvd
call|)
argument_list|(
name|so
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
block|}
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_resid
operator|==
name|uio
operator|->
name|uio_resid
operator|&&
name|orig_resid
operator|&&
operator|(
name|flags
operator|&
name|MSG_EOR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
operator|)
operator|==
literal|0
condition|)
block|{
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
name|flagsp
operator|!=
name|NULL
condition|)
operator|*
name|flagsp
operator||=
name|flags
expr_stmt|;
name|release
label|:
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|out
label|:
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|soreceive
parameter_list|(
name|so
parameter_list|,
name|psa
parameter_list|,
name|uio
parameter_list|,
name|mp0
parameter_list|,
name|controlp
parameter_list|,
name|flagsp
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr
modifier|*
modifier|*
name|psa
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mp0
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|controlp
decl_stmt|;
name|int
modifier|*
name|flagsp
decl_stmt|;
block|{
comment|/* XXXRW: Temporary debugging. */
name|KASSERT
argument_list|(
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_soreceive
operator|!=
name|soreceive
argument_list|,
operator|(
literal|"soreceive: protocol calls soreceive"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_soreceive
argument_list|(
name|so
argument_list|,
name|psa
argument_list|,
name|uio
argument_list|,
name|mp0
argument_list|,
name|controlp
argument_list|,
name|flagsp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|soshutdown
parameter_list|(
name|so
parameter_list|,
name|how
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|how
decl_stmt|;
block|{
name|struct
name|protosw
modifier|*
name|pr
init|=
name|so
operator|->
name|so_proto
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|how
operator|==
name|SHUT_RD
operator|||
name|how
operator|==
name|SHUT_WR
operator|||
name|how
operator|==
name|SHUT_RDWR
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|how
operator|!=
name|SHUT_WR
condition|)
name|sorflush
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|how
operator|!=
name|SHUT_RD
condition|)
return|return
operator|(
call|(
modifier|*
name|pr
operator|->
name|pr_usrreqs
operator|->
name|pru_shutdown
call|)
argument_list|(
name|so
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sorflush
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
name|so
operator|->
name|so_rcv
decl_stmt|;
name|struct
name|protosw
modifier|*
name|pr
init|=
name|so
operator|->
name|so_proto
decl_stmt|;
name|struct
name|sockbuf
name|asb
decl_stmt|;
comment|/* 	 * XXXRW: This is quite ugly.  Previously, this code made a copy of 	 * the socket buffer, then zero'd the original to clear the buffer 	 * fields.  However, with mutexes in the socket buffer, this causes 	 * problems.  We only clear the zeroable bits of the original; 	 * however, we have to initialize and destroy the mutex in the copy 	 * so that dom_dispose() and sbrelease() can lock t as needed. 	 */
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator||=
name|SB_NOINTR
expr_stmt|;
operator|(
name|void
operator|)
name|sblock
argument_list|(
name|sb
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * socantrcvmore_locked() drops the socket buffer mutex so that it 	 * can safely perform wakeups.  Re-acquire the mutex before 	 * continuing. 	 */
name|socantrcvmore_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbunlock
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|/* 	 * Invalidate/clear most of the sockbuf structure, but leave selinfo 	 * and mutex data unchanged. 	 */
name|bzero
argument_list|(
operator|&
name|asb
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|sockbuf
argument_list|,
name|sb_startzero
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sb
operator|->
name|sb_startzero
argument_list|,
operator|&
name|asb
operator|.
name|sb_startzero
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sb
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|sockbuf
argument_list|,
name|sb_startzero
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sb
operator|->
name|sb_startzero
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sb
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|sockbuf
argument_list|,
name|sb_startzero
argument_list|)
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK_INIT
argument_list|(
operator|&
name|asb
argument_list|,
literal|"so_rcv"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|->
name|pr_flags
operator|&
name|PR_RIGHTS
operator|&&
name|pr
operator|->
name|pr_domain
operator|->
name|dom_dispose
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|pr
operator|->
name|pr_domain
operator|->
name|dom_dispose
call|)
argument_list|(
name|asb
operator|.
name|sb_mb
argument_list|)
expr_stmt|;
name|sbrelease
argument_list|(
operator|&
name|asb
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK_DESTROY
argument_list|(
operator|&
name|asb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perhaps this routine, and sooptcopyout(), below, ought to come in an  * additional variant to handle the case where the option value needs to be  * some kind of integer, but not a specific size.  In addition to their use  * here, these functions are also called by the protocol-level pr_ctloutput()  * routines.  */
end_comment

begin_function
name|int
name|sooptcopyin
parameter_list|(
name|sopt
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|minlen
parameter_list|)
name|struct
name|sockopt
modifier|*
name|sopt
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|size_t
name|minlen
decl_stmt|;
block|{
name|size_t
name|valsize
decl_stmt|;
comment|/* 	 * If the user gives us more than we wanted, we ignore it, but if we 	 * don't get the minimum length the caller wants, we return EINVAL. 	 * On success, sopt->sopt_valsize is set to however much we actually 	 * retrieved. 	 */
if|if
condition|(
operator|(
name|valsize
operator|=
name|sopt
operator|->
name|sopt_valsize
operator|)
operator|<
name|minlen
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|valsize
operator|>
name|len
condition|)
name|sopt
operator|->
name|sopt_valsize
operator|=
name|valsize
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_td
operator|!=
name|NULL
condition|)
return|return
operator|(
name|copyin
argument_list|(
name|sopt
operator|->
name|sopt_val
argument_list|,
name|buf
argument_list|,
name|valsize
argument_list|)
operator|)
return|;
name|bcopy
argument_list|(
name|sopt
operator|->
name|sopt_val
argument_list|,
name|buf
argument_list|,
name|valsize
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Kernel version of setsockopt(2).  *  * XXX: optlen is size_t, not socklen_t  */
end_comment

begin_function
name|int
name|so_setsockopt
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|optname
parameter_list|,
name|void
modifier|*
name|optval
parameter_list|,
name|size_t
name|optlen
parameter_list|)
block|{
name|struct
name|sockopt
name|sopt
decl_stmt|;
name|sopt
operator|.
name|sopt_level
operator|=
name|level
expr_stmt|;
name|sopt
operator|.
name|sopt_name
operator|=
name|optname
expr_stmt|;
name|sopt
operator|.
name|sopt_dir
operator|=
name|SOPT_SET
expr_stmt|;
name|sopt
operator|.
name|sopt_val
operator|=
name|optval
expr_stmt|;
name|sopt
operator|.
name|sopt_valsize
operator|=
name|optlen
expr_stmt|;
name|sopt
operator|.
name|sopt_td
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|sosetopt
argument_list|(
name|so
argument_list|,
operator|&
name|sopt
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sosetopt
parameter_list|(
name|so
parameter_list|,
name|sopt
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockopt
modifier|*
name|sopt
decl_stmt|;
block|{
name|int
name|error
decl_stmt|,
name|optval
decl_stmt|;
name|struct
name|linger
name|l
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|u_long
name|val
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|struct
name|mac
name|extmac
decl_stmt|;
endif|#
directive|endif
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_level
operator|!=
name|SOL_SOCKET
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_proto
operator|&&
name|so
operator|->
name|so_proto
operator|->
name|pr_ctloutput
condition|)
return|return
operator|(
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_ctloutput
call|)
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|)
operator|)
return|;
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|SO_ACCEPTFILTER
case|:
name|error
operator|=
name|do_setopt_accept_filter
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
break|break;
endif|#
directive|endif
case|case
name|SO_LINGER
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|l
argument_list|,
sizeof|sizeof
name|l
argument_list|,
sizeof|sizeof
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_linger
operator|=
name|l
operator|.
name|l_linger
expr_stmt|;
if|if
condition|(
name|l
operator|.
name|l_onoff
condition|)
name|so
operator|->
name|so_options
operator||=
name|SO_LINGER
expr_stmt|;
else|else
name|so
operator|->
name|so_options
operator|&=
operator|~
name|SO_LINGER
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
break|break;
case|case
name|SO_DEBUG
case|:
case|case
name|SO_KEEPALIVE
case|:
case|case
name|SO_DONTROUTE
case|:
case|case
name|SO_USELOOPBACK
case|:
case|case
name|SO_BROADCAST
case|:
case|case
name|SO_REUSEADDR
case|:
case|case
name|SO_REUSEPORT
case|:
case|case
name|SO_OOBINLINE
case|:
case|case
name|SO_TIMESTAMP
case|:
case|case
name|SO_BINTIME
case|:
case|case
name|SO_NOSIGPIPE
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|optval
condition|)
name|so
operator|->
name|so_options
operator||=
name|sopt
operator|->
name|sopt_name
expr_stmt|;
else|else
name|so
operator|->
name|so_options
operator|&=
operator|~
name|sopt
operator|->
name|sopt_name
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
break|break;
case|case
name|SO_SNDBUF
case|:
case|case
name|SO_RCVBUF
case|:
case|case
name|SO_SNDLOWAT
case|:
case|case
name|SO_RCVLOWAT
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
comment|/* 			 * Values< 1 make no sense for any of these options, 			 * so disallow them. 			 */
if|if
condition|(
name|optval
operator|<
literal|1
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|SO_SNDBUF
case|:
case|case
name|SO_RCVBUF
case|:
if|if
condition|(
name|sbreserve
argument_list|(
name|sopt
operator|->
name|sopt_name
operator|==
name|SO_SNDBUF
condition|?
operator|&
name|so
operator|->
name|so_snd
else|:
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
operator|(
name|u_long
operator|)
name|optval
argument_list|,
name|so
argument_list|,
name|curthread
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
operator|(
name|sopt
operator|->
name|sopt_name
operator|==
name|SO_SNDBUF
condition|?
operator|&
name|so
operator|->
name|so_snd
else|:
operator|&
name|so
operator|->
name|so_rcv
operator|)
operator|->
name|sb_flags
operator|&=
operator|~
name|SB_AUTOSIZE
expr_stmt|;
break|break;
comment|/* 			 * Make sure the low-water is never greater than the 			 * high-water. 			 */
case|case
name|SO_SNDLOWAT
case|:
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_lowat
operator|=
operator|(
name|optval
operator|>
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|)
condition|?
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
else|:
name|optval
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SO_RCVLOWAT
case|:
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_lowat
operator|=
operator|(
name|optval
operator|>
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|)
condition|?
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
else|:
name|optval
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SO_SNDTIMEO
case|:
case|case
name|SO_RCVTIMEO
case|:
ifdef|#
directive|ifdef
name|COMPAT_IA32
if|if
condition|(
name|curthread
operator|->
name|td_proc
operator|->
name|p_sysent
operator|==
operator|&
name|ia32_freebsd_sysvec
condition|)
block|{
name|struct
name|timeval32
name|tv32
decl_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|tv32
argument_list|,
sizeof|sizeof
name|tv32
argument_list|,
sizeof|sizeof
name|tv32
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|tv32
argument_list|,
name|tv
argument_list|,
name|tv_sec
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|tv32
argument_list|,
name|tv
argument_list|,
name|tv_usec
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|tv
argument_list|,
sizeof|sizeof
name|tv
argument_list|,
sizeof|sizeof
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
comment|/* assert(hz> 0); */
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|<
literal|0
operator|||
name|tv
operator|.
name|tv_sec
operator|>
name|INT_MAX
operator|/
name|hz
operator|||
name|tv
operator|.
name|tv_usec
operator|<
literal|0
operator|||
name|tv
operator|.
name|tv_usec
operator|>=
literal|1000000
condition|)
block|{
name|error
operator|=
name|EDOM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* assert(tick> 0); */
comment|/* assert(ULONG_MAX - INT_MAX>= 1000000); */
name|val
operator|=
call|(
name|u_long
call|)
argument_list|(
name|tv
operator|.
name|tv_sec
operator|*
name|hz
argument_list|)
operator|+
name|tv
operator|.
name|tv_usec
operator|/
name|tick
expr_stmt|;
if|if
condition|(
name|val
operator|>
name|INT_MAX
condition|)
block|{
name|error
operator|=
name|EDOM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|val
operator|==
literal|0
operator|&&
name|tv
operator|.
name|tv_usec
operator|!=
literal|0
condition|)
name|val
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|SO_SNDTIMEO
case|:
name|so
operator|->
name|so_snd
operator|.
name|sb_timeo
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|SO_RCVTIMEO
case|:
name|so
operator|->
name|so_rcv
operator|.
name|sb_timeo
operator|=
name|val
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SO_LABEL
case|:
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|extmac
argument_list|,
sizeof|sizeof
name|extmac
argument_list|,
sizeof|sizeof
name|extmac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|error
operator|=
name|mac_setsockopt_label
argument_list|(
name|sopt
operator|->
name|sopt_td
operator|->
name|td_ucred
argument_list|,
name|so
argument_list|,
operator|&
name|extmac
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|so
operator|->
name|so_proto
operator|!=
name|NULL
operator|&&
name|so
operator|->
name|so_proto
operator|->
name|pr_ctloutput
operator|!=
name|NULL
condition|)
block|{
call|(
name|void
call|)
argument_list|(
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_ctloutput
call|)
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|bad
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Helper routine for getsockopt.  */
end_comment

begin_function
name|int
name|sooptcopyout
parameter_list|(
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|size_t
name|valsize
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Documented get behavior is that we always return a value, possibly 	 * truncated to fit in the user's buffer.  Traditional behavior is 	 * that we always tell the user precisely how much we copied, rather 	 * than something useful like the total amount we had available for 	 * her.  Note that this interface is not idempotent; the entire 	 * answer must generated ahead of time. 	 */
name|valsize
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|sopt
operator|->
name|sopt_valsize
argument_list|)
expr_stmt|;
name|sopt
operator|->
name|sopt_valsize
operator|=
name|valsize
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_val
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sopt
operator|->
name|sopt_td
operator|!=
name|NULL
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|buf
argument_list|,
name|sopt
operator|->
name|sopt_val
argument_list|,
name|valsize
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|buf
argument_list|,
name|sopt
operator|->
name|sopt_val
argument_list|,
name|valsize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sogetopt
parameter_list|(
name|so
parameter_list|,
name|sopt
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockopt
modifier|*
name|sopt
decl_stmt|;
block|{
name|int
name|error
decl_stmt|,
name|optval
decl_stmt|;
name|struct
name|linger
name|l
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|struct
name|mac
name|extmac
decl_stmt|;
endif|#
directive|endif
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_level
operator|!=
name|SOL_SOCKET
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_proto
operator|&&
name|so
operator|->
name|so_proto
operator|->
name|pr_ctloutput
condition|)
block|{
return|return
operator|(
call|(
modifier|*
name|so
operator|->
name|so_proto
operator|->
name|pr_ctloutput
call|)
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
name|ENOPROTOOPT
operator|)
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|SO_ACCEPTFILTER
case|:
name|error
operator|=
name|do_getopt_accept_filter
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SO_LINGER
case|:
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|l
operator|.
name|l_onoff
operator|=
name|so
operator|->
name|so_options
operator|&
name|SO_LINGER
expr_stmt|;
name|l
operator|.
name|l_linger
operator|=
name|so
operator|->
name|so_linger
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|l
argument_list|,
sizeof|sizeof
name|l
argument_list|)
expr_stmt|;
break|break;
case|case
name|SO_USELOOPBACK
case|:
case|case
name|SO_DONTROUTE
case|:
case|case
name|SO_DEBUG
case|:
case|case
name|SO_KEEPALIVE
case|:
case|case
name|SO_REUSEADDR
case|:
case|case
name|SO_REUSEPORT
case|:
case|case
name|SO_BROADCAST
case|:
case|case
name|SO_OOBINLINE
case|:
case|case
name|SO_ACCEPTCONN
case|:
case|case
name|SO_TIMESTAMP
case|:
case|case
name|SO_BINTIME
case|:
case|case
name|SO_NOSIGPIPE
case|:
name|optval
operator|=
name|so
operator|->
name|so_options
operator|&
name|sopt
operator|->
name|sopt_name
expr_stmt|;
name|integer
label|:
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
break|break;
case|case
name|SO_TYPE
case|:
name|optval
operator|=
name|so
operator|->
name|so_type
expr_stmt|;
goto|goto
name|integer
goto|;
case|case
name|SO_ERROR
case|:
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|optval
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
goto|goto
name|integer
goto|;
case|case
name|SO_SNDBUF
case|:
name|optval
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
expr_stmt|;
goto|goto
name|integer
goto|;
case|case
name|SO_RCVBUF
case|:
name|optval
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
expr_stmt|;
goto|goto
name|integer
goto|;
case|case
name|SO_SNDLOWAT
case|:
name|optval
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_lowat
expr_stmt|;
goto|goto
name|integer
goto|;
case|case
name|SO_RCVLOWAT
case|:
name|optval
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_lowat
expr_stmt|;
goto|goto
name|integer
goto|;
case|case
name|SO_SNDTIMEO
case|:
case|case
name|SO_RCVTIMEO
case|:
name|optval
operator|=
operator|(
name|sopt
operator|->
name|sopt_name
operator|==
name|SO_SNDTIMEO
condition|?
name|so
operator|->
name|so_snd
operator|.
name|sb_timeo
else|:
name|so
operator|->
name|so_rcv
operator|.
name|sb_timeo
operator|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|optval
operator|/
name|hz
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
name|optval
operator|%
name|hz
operator|)
operator|*
name|tick
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_IA32
if|if
condition|(
name|curthread
operator|->
name|td_proc
operator|->
name|p_sysent
operator|==
operator|&
name|ia32_freebsd_sysvec
condition|)
block|{
name|struct
name|timeval32
name|tv32
decl_stmt|;
name|CP
argument_list|(
name|tv
argument_list|,
name|tv32
argument_list|,
name|tv_sec
argument_list|)
expr_stmt|;
name|CP
argument_list|(
name|tv
argument_list|,
name|tv32
argument_list|,
name|tv_usec
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|tv32
argument_list|,
sizeof|sizeof
name|tv32
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|tv
argument_list|,
sizeof|sizeof
name|tv
argument_list|)
expr_stmt|;
break|break;
case|case
name|SO_LABEL
case|:
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|extmac
argument_list|,
sizeof|sizeof
argument_list|(
name|extmac
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|extmac
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|mac_getsockopt_label
argument_list|(
name|sopt
operator|->
name|sopt_td
operator|->
name|td_ucred
argument_list|,
name|so
argument_list|,
operator|&
name|extmac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|extmac
argument_list|,
sizeof|sizeof
name|extmac
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SO_PEERLABEL
case|:
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|extmac
argument_list|,
sizeof|sizeof
argument_list|(
name|extmac
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|extmac
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|mac_getsockopt_peerlabel
argument_list|(
name|sopt
operator|->
name|sopt_td
operator|->
name|td_ucred
argument_list|,
name|so
argument_list|,
operator|&
name|extmac
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|extmac
argument_list|,
sizeof|sizeof
name|extmac
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SO_LISTENQLIMIT
case|:
name|optval
operator|=
name|so
operator|->
name|so_qlimit
expr_stmt|;
goto|goto
name|integer
goto|;
case|case
name|SO_LISTENQLEN
case|:
name|optval
operator|=
name|so
operator|->
name|so_qlen
expr_stmt|;
goto|goto
name|integer
goto|;
case|case
name|SO_LISTENINCQLEN
case|:
name|optval
operator|=
name|so
operator|->
name|so_incqlen
expr_stmt|;
goto|goto
name|integer
goto|;
default|default:
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* XXX; prepare mbuf for (__FreeBSD__< 3) routines. */
end_comment

begin_function
name|int
name|soopt_getm
parameter_list|(
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m_prev
decl_stmt|;
name|int
name|sopt_size
init|=
name|sopt
operator|->
name|sopt_valsize
decl_stmt|;
name|MGET
argument_list|(
name|m
argument_list|,
name|sopt
operator|->
name|sopt_td
condition|?
name|M_TRYWAIT
else|:
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|ENOBUFS
return|;
if|if
condition|(
name|sopt_size
operator|>
name|MLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|sopt
operator|->
name|sopt_td
condition|?
name|M_TRYWAIT
else|:
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|MCLBYTES
argument_list|,
name|sopt_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|MLEN
argument_list|,
name|sopt_size
argument_list|)
expr_stmt|;
block|}
name|sopt_size
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|m_prev
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|sopt_size
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|sopt
operator|->
name|sopt_td
condition|?
name|M_TRYWAIT
else|:
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
if|if
condition|(
name|sopt_size
operator|>
name|MLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|sopt
operator|->
name|sopt_td
operator|!=
name|NULL
condition|?
name|M_TRYWAIT
else|:
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|MCLBYTES
argument_list|,
name|sopt_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|MLEN
argument_list|,
name|sopt_size
argument_list|)
expr_stmt|;
block|}
name|sopt_size
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|m_prev
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|m_prev
operator|=
name|m
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* XXX; copyin sopt data into mbuf chain for (__FreeBSD__< 3) routines. */
end_comment

begin_function
name|int
name|soopt_mcopyin
parameter_list|(
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
init|=
name|m
decl_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_val
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|sopt
operator|->
name|sopt_valsize
operator|>=
name|m
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
name|sopt
operator|->
name|sopt_td
operator|!=
name|NULL
condition|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|sopt
operator|->
name|sopt_val
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
else|else
name|bcopy
argument_list|(
name|sopt
operator|->
name|sopt_val
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|sopt
operator|->
name|sopt_valsize
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|sopt
operator|->
name|sopt_val
operator|=
operator|(
name|char
operator|*
operator|)
name|sopt
operator|->
name|sopt_val
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
comment|/* should be allocated enoughly at ip6_sooptmcopyin() */
name|panic
argument_list|(
literal|"ip6_sooptmcopyin"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* XXX; copyout mbuf chain data into soopt for (__FreeBSD__< 3) routines. */
end_comment

begin_function
name|int
name|soopt_mcopyout
parameter_list|(
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
init|=
name|m
decl_stmt|;
name|size_t
name|valsize
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_val
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|sopt
operator|->
name|sopt_valsize
operator|>=
name|m
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
name|sopt
operator|->
name|sopt_td
operator|!=
name|NULL
condition|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|sopt
operator|->
name|sopt_val
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
else|else
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|sopt
operator|->
name|sopt_val
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|sopt
operator|->
name|sopt_valsize
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|sopt
operator|->
name|sopt_val
operator|=
operator|(
name|char
operator|*
operator|)
name|sopt
operator|->
name|sopt_val
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
name|valsize
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/* enough soopt buffer should be given from user-land */
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sopt
operator|->
name|sopt_valsize
operator|=
name|valsize
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * sohasoutofband(): protocol notifies socket layer of the arrival of new  * out-of-band data, which will then notify socket consumers.  */
end_comment

begin_function
name|void
name|sohasoutofband
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
if|if
condition|(
name|so
operator|->
name|so_sigio
operator|!=
name|NULL
condition|)
name|pgsigio
argument_list|(
operator|&
name|so
operator|->
name|so_sigio
argument_list|,
name|SIGURG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
operator|.
name|sb_sel
argument_list|,
name|PSOCK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sopoll
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
comment|/* XXXRW: Temporary debugging. */
name|KASSERT
argument_list|(
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_sopoll
operator|!=
name|sopoll
argument_list|,
operator|(
literal|"sopoll: protocol calls sopoll"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_usrreqs
operator|->
name|pru_sopoll
argument_list|(
name|so
argument_list|,
name|events
argument_list|,
name|active_cred
argument_list|,
name|td
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sopoll_generic
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|revents
init|=
literal|0
decl_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
if|if
condition|(
name|soreadable
argument_list|(
name|so
argument_list|)
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
name|POLLINIGNEOF
condition|)
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|>=
name|so
operator|->
name|so_rcv
operator|.
name|sb_lowat
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|so
operator|->
name|so_comp
argument_list|)
operator|||
name|so
operator|->
name|so_error
condition|)
name|revents
operator||=
name|POLLINIGNEOF
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
condition|)
if|if
condition|(
name|sowriteable
argument_list|(
name|so
argument_list|)
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLPRI
operator||
name|POLLRDBAND
operator|)
condition|)
if|if
condition|(
name|so
operator|->
name|so_oobmark
operator|||
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_RCVATMARK
operator|)
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLPRI
operator||
name|POLLRDBAND
operator|)
expr_stmt|;
if|if
condition|(
name|revents
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLINIGNEOF
operator||
name|POLLPRI
operator||
name|POLLRDNORM
operator||
name|POLLRDBAND
operator|)
condition|)
block|{
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|so
operator|->
name|so_rcv
operator|.
name|sb_sel
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator||=
name|SB_SEL
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
condition|)
block|{
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|so
operator|->
name|so_snd
operator|.
name|sb_sel
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator||=
name|SB_SEL
expr_stmt|;
block|}
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_function
name|int
name|soo_kqfilter
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
switch|switch
condition|(
name|kn
operator|->
name|kn_filter
condition|)
block|{
case|case
name|EVFILT_READ
case|:
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_ACCEPTCONN
condition|)
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|solisten_filtops
expr_stmt|;
else|else
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|soread_filtops
expr_stmt|;
name|sb
operator|=
operator|&
name|so
operator|->
name|so_rcv
expr_stmt|;
break|break;
case|case
name|EVFILT_WRITE
case|:
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|sowrite_filtops
expr_stmt|;
name|sb
operator|=
operator|&
name|so
operator|->
name|so_snd
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|knlist_add
argument_list|(
operator|&
name|sb
operator|->
name|sb_sel
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sb
operator|->
name|sb_flags
operator||=
name|SB_KNOTE
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|filt_sordetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
decl_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|knlist_remove
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
operator|.
name|sb_sel
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|knlist_empty
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
operator|.
name|sb_sel
operator|.
name|si_note
argument_list|)
condition|)
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator|&=
operator|~
name|SB_KNOTE
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|filt_soread
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
expr_stmt|;
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_data
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|-
name|so
operator|->
name|so_rcv
operator|.
name|sb_ctl
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
block|{
name|kn
operator|->
name|kn_flags
operator||=
name|EV_EOF
expr_stmt|;
name|kn
operator|->
name|kn_fflags
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
comment|/* temporary udp error */
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|kn
operator|->
name|kn_sfflags
operator|&
name|NOTE_LOWAT
condition|)
return|return
operator|(
name|kn
operator|->
name|kn_data
operator|>=
name|kn
operator|->
name|kn_sdata
operator|)
return|;
else|else
return|return
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|>=
name|so
operator|->
name|so_rcv
operator|.
name|sb_lowat
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|filt_sowdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
decl_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|knlist_remove
argument_list|(
operator|&
name|so
operator|->
name|so_snd
operator|.
name|sb_sel
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|knlist_empty
argument_list|(
operator|&
name|so
operator|->
name|so_snd
operator|.
name|sb_sel
operator|.
name|si_note
argument_list|)
condition|)
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator|&=
operator|~
name|SB_KNOTE
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|filt_sowrite
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
expr_stmt|;
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_data
operator|=
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_state
operator|&
name|SBS_CANTSENDMORE
condition|)
block|{
name|kn
operator|->
name|kn_flags
operator||=
name|EV_EOF
expr_stmt|;
name|kn
operator|->
name|kn_fflags
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
comment|/* temporary udp error */
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_flags
operator|&
name|PR_CONNREQUIRED
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|kn
operator|->
name|kn_sfflags
operator|&
name|NOTE_LOWAT
condition|)
return|return
operator|(
name|kn
operator|->
name|kn_data
operator|>=
name|kn
operator|->
name|kn_sdata
operator|)
return|;
else|else
return|return
operator|(
name|kn
operator|->
name|kn_data
operator|>=
name|so
operator|->
name|so_snd
operator|.
name|sb_lowat
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|filt_solisten
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
decl_stmt|;
name|kn
operator|->
name|kn_data
operator|=
name|so
operator|->
name|so_qlen
expr_stmt|;
return|return
operator|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|so
operator|->
name|so_comp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|socheckuid
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|uid_t
name|uid
parameter_list|)
block|{
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|so
operator|->
name|so_cred
operator|->
name|cr_uid
operator|!=
name|uid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_somaxconn
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|val
decl_stmt|;
name|val
operator|=
name|somaxconn
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|val
operator|<
literal|1
operator|||
name|val
operator|>
name|USHRT_MAX
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|somaxconn
operator|=
name|val
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

