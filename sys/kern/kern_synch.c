begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1990, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  * (c) UNIX System Laboratories, Inc.  * All or some portions of this file are derived from material licensed  * to the University of California by American Telephone and Telegraph  * Co. or Unix System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)kern_synch.c	8.9 (Berkeley) 5/19/95  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_ktrace.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_function_decl
specifier|static
name|void
name|sched_setup
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_macro
name|SYSINIT
argument_list|(
argument|sched_setup
argument_list|,
argument|SI_SUB_KICK_SCHEDULER
argument_list|,
argument|SI_ORDER_FIRST
argument_list|,
argument|sched_setup
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_decl_stmt
name|int
name|hogticks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lbolt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sched_quantum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Roundrobin scheduling quantum in ticks. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|callout
name|loadav_callout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|callout
name|schedcpu_callout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|callout
name|roundrobin_callout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|loadavg
name|averunnable
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
name|FSCALE
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* load average, of runnable procs */
end_comment

begin_comment
comment|/*  * Constants for averages over 1, 5, and 15 minutes  * when sampling at 5 second intervals.  */
end_comment

begin_decl_stmt
specifier|static
name|fixpt_t
name|cexp
index|[
literal|3
index|]
init|=
block|{
literal|0.9200444146293232
operator|*
name|FSCALE
block|,
comment|/* exp(-1/12) */
literal|0.9834714538216174
operator|*
name|FSCALE
block|,
comment|/* exp(-1/60) */
literal|0.9944598480048967
operator|*
name|FSCALE
block|,
comment|/* exp(-1/180) */
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|endtsleep
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|loadav
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|roundrobin
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|schedcpu
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|sysctl_kern_quantum
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|new_val
decl_stmt|;
name|new_val
operator|=
name|sched_quantum
operator|*
name|tick
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|new_val
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|new_val
operator|<
name|tick
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sched_quantum
operator|=
name|new_val
operator|/
name|tick
expr_stmt|;
name|hogticks
operator|=
literal|2
operator|*
name|sched_quantum
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|quantum
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sched_quantum
argument_list|,
name|sysctl_kern_quantum
argument_list|,
literal|"I"
argument_list|,
literal|"Roundrobin scheduling quantum in microseconds"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Arrange to reschedule if necessary, taking the priorities and  * schedulers into account.  */
end_comment

begin_function
name|void
name|maybe_resched
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_priority
operator|<
name|curthread
operator|->
name|td_priority
condition|)
name|curthread
operator|->
name|td_kse
operator|->
name|ke_flags
operator||=
name|KEF_NEEDRESCHED
expr_stmt|;
block|}
end_function

begin_function
name|int
name|roundrobin_interval
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|sched_quantum
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Force switch among equal priority processes every 100ms.  * We don't actually need to force a context switch of the current process.  * The act of firing the event triggers a context switch to softclock() and  * then switching back out again which is equivalent to a preemption, thus  * no further work is needed on the local CPU.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|roundrobin
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SMP
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|forward_roundrobin
argument_list|()
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|callout_reset
argument_list|(
operator|&
name|roundrobin_callout
argument_list|,
name|sched_quantum
argument_list|,
name|roundrobin
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Constants for digital decay and forget:  *	90% of (p_estcpu) usage in 5 * loadav time  *	95% of (p_pctcpu) usage in 60 seconds (load insensitive)  *          Note that, as ps(1) mentions, this can let percentages  *          total over 100% (I've seen 137.9% for 3 processes).  *  * Note that schedclock() updates p_estcpu and p_cpticks asynchronously.  *  * We wish to decay away 90% of p_estcpu in (5 * loadavg) seconds.  * That is, the system wants to compute a value of decay such  * that the following for loop:  * 	for (i = 0; i< (5 * loadavg); i++)  * 		p_estcpu *= decay;  * will compute  * 	p_estcpu *= 0.1;  * for all values of loadavg:  *  * Mathematically this loop can be expressed by saying:  * 	decay ** (5 * loadavg) ~= .1  *  * The system computes decay as:  * 	decay = (2 * loadavg) / (2 * loadavg + 1)  *  * We wish to prove that the system's computation of decay  * will always fulfill the equation:  * 	decay ** (5 * loadavg) ~= .1  *  * If we compute b as:  * 	b = 2 * loadavg  * then  * 	decay = b / (b + 1)  *  * We now need to prove two things:  *	1) Given factor ** (5 * loadavg) ~= .1, prove factor == b/(b+1)  *	2) Given b/(b+1) ** power ~= .1, prove power == (5 * loadavg)  *  * Facts:  *         For x close to zero, exp(x) =~ 1 + x, since  *              exp(x) = 0! + x**1/1! + x**2/2! + ... .  *              therefore exp(-1/b) =~ 1 - (1/b) = (b-1)/b.  *         For x close to zero, ln(1+x) =~ x, since  *              ln(1+x) = x - x**2/2 + x**3/3 - ...     -1< x< 1  *              therefore ln(b/(b+1)) = ln(1 - 1/(b+1)) =~ -1/(b+1).  *         ln(.1) =~ -2.30  *  * Proof of (1):  *    Solve (factor)**(power) =~ .1 given power (5*loadav):  *	solving for factor,  *      ln(factor) =~ (-2.30/5*loadav), or  *      factor =~ exp(-1/((5/2.30)*loadav)) =~ exp(-1/(2*loadav)) =  *          exp(-1/b) =~ (b-1)/b =~ b/(b+1).                    QED  *  * Proof of (2):  *    Solve (factor)**(power) =~ .1 given factor == (b/(b+1)):  *	solving for power,  *      power*ln(b/(b+1)) =~ -2.30, or  *      power =~ 2.3 * (b + 1) = 4.6*loadav + 2.3 =~ 5*loadav.  QED  *  * Actual power values for the implemented algorithm are as follows:  *      loadav: 1       2       3       4  *      power:  5.68    10.32   14.94   19.55  */
end_comment

begin_comment
comment|/* calculations for digital decay to forget 90% of usage in 5*loadav sec */
end_comment

begin_define
define|#
directive|define
name|loadfactor
parameter_list|(
name|loadav
parameter_list|)
value|(2 * (loadav))
end_define

begin_define
define|#
directive|define
name|decay_cpu
parameter_list|(
name|loadfac
parameter_list|,
name|cpu
parameter_list|)
value|(((loadfac) * (cpu)) / ((loadfac) + FSCALE))
end_define

begin_comment
comment|/* decay 95% of `p_pctcpu' in 60 seconds; see CCPU_SHIFT before changing */
end_comment

begin_decl_stmt
specifier|static
name|fixpt_t
name|ccpu
init|=
literal|0.95122942450071400909
operator|*
name|FSCALE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* exp(-1/20) */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|ccpu
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ccpu
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* kernel uses `FSCALE', userland (SHOULD) use kern.fscale */
end_comment

begin_decl_stmt
specifier|static
name|int
name|fscale
name|__unused
init|=
name|FSCALE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|fscale
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|FSCALE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * If `ccpu' is not equal to `exp(-1/20)' and you still want to use the  * faster/more-accurate formula, you'll have to estimate CCPU_SHIFT below  * and possibly adjust FSHIFT in "param.h" so that (FSHIFT>= CCPU_SHIFT).  *  * To estimate CCPU_SHIFT for exp(-1/20), the following formula was used:  *	1 - exp(-1/20) ~= 0.0487 ~= 0.0488 == 1 (fixed pt, *11* bits).  *  * If you don't want to bother with the faster/more-accurate formula, you  * can set CCPU_SHIFT to (FSHIFT + 1) which will use a slower/less-accurate  * (more general) method of calculating the %age of CPU used by a process.  */
end_comment

begin_define
define|#
directive|define
name|CCPU_SHIFT
value|11
end_define

begin_comment
comment|/*  * Recompute process priorities, every hz ticks.  * MP-safe, called without the Giant mutex.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|schedcpu
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|fixpt_t
name|loadfac
init|=
name|loadfactor
argument_list|(
name|averunnable
operator|.
name|ldavg
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|int
name|realstathz
decl_stmt|;
name|int
name|awake
decl_stmt|;
name|realstathz
operator|=
name|stathz
condition|?
name|stathz
else|:
name|hz
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|FOREACH_PROC_IN_SYSTEM
argument_list|(
argument|p
argument_list|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_swtime
operator|++
expr_stmt|;
name|FOREACH_KSEGRP_IN_PROC
argument_list|(
argument|p
argument_list|,
argument|kg
argument_list|)
block|{
name|awake
operator|=
literal|0
expr_stmt|;
name|FOREACH_KSE_IN_GROUP
argument_list|(
argument|kg
argument_list|,
argument|ke
argument_list|)
block|{
comment|/* 				 * Increment time in/out of memory and sleep 				 * time (if sleeping).  We ignore overflow; 				 * with 16-bit int's (remember them?) 				 * overflow takes 45 days. 				 */
comment|/* 				 * The kse slptimes are not touched in wakeup 				 * because the thread may not HAVE a KSE. 				 */
if|if
condition|(
name|ke
operator|->
name|ke_state
operator|==
name|KES_ONRUNQ
condition|)
block|{
name|awake
operator|=
literal|1
expr_stmt|;
name|ke
operator|->
name|ke_flags
operator|&=
operator|~
name|KEF_DIDRUN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ke
operator|->
name|ke_state
operator|==
name|KES_THREAD
operator|)
operator|&&
operator|(
name|TD_IS_RUNNING
argument_list|(
name|ke
operator|->
name|ke_thread
argument_list|)
operator|)
condition|)
block|{
name|awake
operator|=
literal|1
expr_stmt|;
comment|/* Do not clear KEF_DIDRUN */
block|}
elseif|else
if|if
condition|(
name|ke
operator|->
name|ke_flags
operator|&
name|KEF_DIDRUN
condition|)
block|{
name|awake
operator|=
literal|1
expr_stmt|;
name|ke
operator|->
name|ke_flags
operator|&=
operator|~
name|KEF_DIDRUN
expr_stmt|;
block|}
comment|/* 				 * pctcpu is only for ps? 				 * Do it per kse.. and add them up at the end? 				 * XXXKSE 				 */
name|ke
operator|->
name|ke_pctcpu
operator|=
operator|(
name|ke
operator|->
name|ke_pctcpu
operator|*
name|ccpu
operator|)
operator|>>
name|FSHIFT
expr_stmt|;
comment|/* 				 * If the kse has been idle the entire second, 				 * stop recalculating its priority until 				 * it wakes up. 				 */
if|if
condition|(
name|ke
operator|->
name|ke_cpticks
operator|==
literal|0
condition|)
continue|continue;
if|#
directive|if
operator|(
name|FSHIFT
operator|>=
name|CCPU_SHIFT
operator|)
name|ke
operator|->
name|ke_pctcpu
operator|+=
operator|(
name|realstathz
operator|==
literal|100
operator|)
condition|?
operator|(
operator|(
name|fixpt_t
operator|)
name|ke
operator|->
name|ke_cpticks
operator|)
operator|<<
operator|(
name|FSHIFT
operator|-
name|CCPU_SHIFT
operator|)
else|:
literal|100
operator|*
operator|(
operator|(
operator|(
name|fixpt_t
operator|)
name|ke
operator|->
name|ke_cpticks
operator|)
operator|<<
operator|(
name|FSHIFT
operator|-
name|CCPU_SHIFT
operator|)
operator|)
operator|/
name|realstathz
expr_stmt|;
else|#
directive|else
name|ke
operator|->
name|ke_pctcpu
operator|+=
operator|(
operator|(
name|FSCALE
operator|-
name|ccpu
operator|)
operator|*
operator|(
name|ke
operator|->
name|ke_cpticks
operator|*
name|FSCALE
operator|/
name|realstathz
operator|)
operator|)
operator|>>
name|FSHIFT
expr_stmt|;
endif|#
directive|endif
name|ke
operator|->
name|ke_cpticks
operator|=
literal|0
expr_stmt|;
block|}
comment|/* end of kse loop */
comment|/*  			 * If there are ANY running threads in this KSEGRP, 			 * then don't count it as sleeping. 			 */
if|if
condition|(
name|awake
condition|)
block|{
if|if
condition|(
name|kg
operator|->
name|kg_slptime
operator|>
literal|1
condition|)
block|{
comment|/* 					 * In an ideal world, this should not 					 * happen, because whoever woke us 					 * up from the long sleep should have 					 * unwound the slptime and reset our 					 * priority before we run at the stale 					 * priority.  Should KASSERT at some 					 * point when all the cases are fixed. 					 */
name|updatepri
argument_list|(
name|kg
argument_list|)
expr_stmt|;
block|}
name|kg
operator|->
name|kg_slptime
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|kg
operator|->
name|kg_slptime
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|kg
operator|->
name|kg_slptime
operator|>
literal|1
condition|)
continue|continue;
name|kg
operator|->
name|kg_estcpu
operator|=
name|decay_cpu
argument_list|(
name|loadfac
argument_list|,
name|kg
operator|->
name|kg_estcpu
argument_list|)
expr_stmt|;
name|resetpriority
argument_list|(
name|kg
argument_list|)
expr_stmt|;
name|FOREACH_THREAD_IN_GROUP
argument_list|(
argument|kg
argument_list|,
argument|td
argument_list|)
block|{
name|int
name|changedqueue
decl_stmt|;
if|if
condition|(
name|td
operator|->
name|td_priority
operator|>=
name|PUSER
condition|)
block|{
comment|/* 					 * Only change the priority 					 * of threads that are still at their 					 * user priority.  					 * XXXKSE This is problematic 					 * as we may need to re-order 					 * the threads on the KSEG list. 					 */
name|changedqueue
operator|=
operator|(
operator|(
name|td
operator|->
name|td_priority
operator|/
name|RQ_PPQ
operator|)
operator|!=
operator|(
name|kg
operator|->
name|kg_user_pri
operator|/
name|RQ_PPQ
operator|)
operator|)
expr_stmt|;
name|td
operator|->
name|td_priority
operator|=
name|kg
operator|->
name|kg_user_pri
expr_stmt|;
if|if
condition|(
name|changedqueue
operator|&&
name|TD_ON_RUNQ
argument_list|(
name|td
argument_list|)
condition|)
block|{
comment|/* this could be optimised */
name|remrunqueue
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_priority
operator|=
name|kg
operator|->
name|kg_user_pri
expr_stmt|;
name|setrunqueue
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|td_priority
operator|=
name|kg
operator|->
name|kg_user_pri
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* end of ksegrp loop */
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
comment|/* end of process loop */
name|sx_sunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|lbolt
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|schedcpu_callout
argument_list|,
name|hz
argument_list|,
name|schedcpu
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Recalculate the priority of a process after it has slept for a while.  * For all load averages>= 1 and max p_estcpu of 255, sleeping for at  * least six times the loadfactor will decay p_estcpu to zero.  */
end_comment

begin_function
name|void
name|updatepri
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|)
block|{
specifier|register
name|unsigned
name|int
name|newcpu
decl_stmt|;
specifier|register
name|fixpt_t
name|loadfac
init|=
name|loadfactor
argument_list|(
name|averunnable
operator|.
name|ldavg
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|newcpu
operator|=
name|kg
operator|->
name|kg_estcpu
expr_stmt|;
if|if
condition|(
name|kg
operator|->
name|kg_slptime
operator|>
literal|5
operator|*
name|loadfac
condition|)
name|kg
operator|->
name|kg_estcpu
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|kg
operator|->
name|kg_slptime
operator|--
expr_stmt|;
comment|/* the first time was done in schedcpu */
while|while
condition|(
name|newcpu
operator|&&
operator|--
name|kg
operator|->
name|kg_slptime
condition|)
name|newcpu
operator|=
name|decay_cpu
argument_list|(
name|loadfac
argument_list|,
name|newcpu
argument_list|)
expr_stmt|;
name|kg
operator|->
name|kg_estcpu
operator|=
name|newcpu
expr_stmt|;
block|}
name|resetpriority
argument_list|(
name|kg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We're only looking at 7 bits of the address; everything is  * aligned to 4, lots of things are aligned to greater powers  * of 2.  Shift right by 8, i.e. drop the bottom 256 worth.  */
end_comment

begin_define
define|#
directive|define
name|TABLESIZE
value|128
end_define

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument|slpquehead
argument_list|,
argument|thread
argument_list|)
name|slpque
index|[
name|TABLESIZE
index|]
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|LOOKUP
parameter_list|(
name|x
parameter_list|)
value|(((intptr_t)(x)>> 8)& (TABLESIZE - 1))
end_define

begin_function
name|void
name|sleepinit
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|sched_quantum
operator|=
name|hz
operator|/
literal|10
expr_stmt|;
name|hogticks
operator|=
literal|2
operator|*
name|sched_quantum
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TABLESIZE
condition|;
name|i
operator|++
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|slpque
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * General sleep call.  Suspends the current process until a wakeup is  * performed on the specified identifier.  The process will then be made  * runnable with the specified priority.  Sleeps at most timo/hz seconds  * (0 means no timeout).  If pri includes PCATCH flag, signals are checked  * before and after sleeping, else signals are not checked.  Returns 0 if  * awakened, EWOULDBLOCK if the timeout expires.  If PCATCH is set and a  * signal needs to be delivered, ERESTART is returned if the current system  * call should be restarted if possible, and EINTR is returned if the system  * call should be interrupted by the signal (return EINTR).  *  * The mutex argument is exited before the caller is suspended, and  * entered before msleep returns.  If priority includes the PDROP  * flag the mutex is not entered before returning.  */
end_comment

begin_function
name|int
name|msleep
parameter_list|(
name|ident
parameter_list|,
name|mtx
parameter_list|,
name|priority
parameter_list|,
name|wmesg
parameter_list|,
name|timo
parameter_list|)
name|void
modifier|*
name|ident
decl_stmt|;
name|struct
name|mtx
modifier|*
name|mtx
decl_stmt|;
name|int
name|priority
decl_stmt|,
name|timo
decl_stmt|;
specifier|const
name|char
modifier|*
name|wmesg
decl_stmt|;
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|int
name|sig
decl_stmt|,
name|catch
init|=
name|priority
operator|&
name|PCATCH
decl_stmt|;
name|int
name|rval
init|=
literal|0
decl_stmt|;
name|WITNESS_SAVE_DECL
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|td
argument_list|,
name|KTR_CSW
argument_list|)
condition|)
name|ktrcsw
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|WITNESS_SLEEP
argument_list|(
literal|0
argument_list|,
operator|&
name|mtx
operator|->
name|mtx_object
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|timo
operator|!=
literal|0
operator|||
name|mtx_owned
argument_list|(
operator|&
name|Giant
argument_list|)
operator|||
name|mtx
operator|!=
name|NULL
argument_list|,
operator|(
literal|"sleeping without a mutex"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we are capable of async syscalls and there isn't already 	 * another one ready to return, start a new thread 	 * and queue it as ready to run. Note that there is danger here 	 * because we need to make sure that we don't sleep allocating 	 * the thread (recursion here might be bad). 	 * Hence the TDF_INMSLEEP flag. 	 */
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_KSES
condition|)
block|{
comment|/* Just don't bother if we are exiting 				and not the exiting thread. */
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_WEXIT
operator|)
operator|&&
name|catch
operator|&&
name|p
operator|->
name|p_singlethread
operator|!=
name|td
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
if|if
condition|(
name|td
operator|->
name|td_mailbox
operator|&&
operator|(
operator|!
operator|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_INMSLEEP
operator|)
operator|)
condition|)
block|{
comment|/* 			 * If we have no queued work to do, then 			 * upcall to the UTS to see if it has more to do. 			 * We don't need to upcall now, just make it and 			 * queue it. 			 */
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|td
operator|->
name|td_ksegrp
operator|->
name|kg_runq
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* Don't recurse here! */
name|td
operator|->
name|td_flags
operator||=
name|TDF_INMSLEEP
expr_stmt|;
name|thread_schedule_upcall
argument_list|(
name|td
argument_list|,
name|td
operator|->
name|td_kse
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_INMSLEEP
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cold
condition|)
block|{
comment|/* 		 * During autoconfiguration, just give interrupts 		 * a chance, then just return. 		 * Don't run any other procs or panic below, 		 * in case this is the idle process and already asleep. 		 */
if|if
condition|(
name|mtx
operator|!=
name|NULL
operator|&&
name|priority
operator|&
name|PDROP
condition|)
name|mtx_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|DROP_GIANT
argument_list|()
expr_stmt|;
if|if
condition|(
name|mtx
operator|!=
name|NULL
condition|)
block|{
name|mtx_assert
argument_list|(
name|mtx
argument_list|,
name|MA_OWNED
operator||
name|MA_NOTRECURSED
argument_list|)
expr_stmt|;
name|WITNESS_SAVE
argument_list|(
operator|&
name|mtx
operator|->
name|mtx_object
argument_list|,
name|mtx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|priority
operator|&
name|PDROP
condition|)
name|mtx
operator|=
name|NULL
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|p
operator|!=
name|NULL
argument_list|,
operator|(
literal|"msleep1"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ident
operator|!=
name|NULL
operator|&&
name|TD_IS_RUNNING
argument_list|(
name|td
argument_list|)
argument_list|,
operator|(
literal|"msleep"
operator|)
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_PROC
argument_list|,
literal|"msleep: thread %p (pid %d, %s) on %s (%p)"
argument_list|,
name|td
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|wmesg
argument_list|,
name|ident
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_wchan
operator|=
name|ident
expr_stmt|;
name|td
operator|->
name|td_wmesg
operator|=
name|wmesg
expr_stmt|;
name|td
operator|->
name|td_ksegrp
operator|->
name|kg_slptime
operator|=
literal|0
expr_stmt|;
name|td
operator|->
name|td_priority
operator|=
name|priority
operator|&
name|PRIMASK
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|slpque
index|[
name|LOOKUP
argument_list|(
name|ident
argument_list|)
index|]
argument_list|,
name|td
argument_list|,
name|td_slpq
argument_list|)
expr_stmt|;
name|TD_SET_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|timo
condition|)
name|callout_reset
argument_list|(
operator|&
name|td
operator|->
name|td_slpcallout
argument_list|,
name|timo
argument_list|,
name|endtsleep
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* 	 * We put ourselves on the sleep queue and start our timeout 	 * before calling thread_suspend_check, as we could stop there, and 	 * a wakeup or a SIGCONT (or both) could occur while we were stopped. 	 * without resuming us, thus we must be ready for sleep 	 * when cursig is called.  If the wakeup happens while we're 	 * stopped, td->td_wchan will be 0 upon return from cursig. 	 */
if|if
condition|(
name|catch
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"msleep caught: thread %p (pid %d, %s)"
argument_list|,
name|td
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_flags
operator||=
name|TDF_SINTR
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sig
operator|=
name|cursig
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|==
literal|0
operator|&&
name|thread_suspend_check
argument_list|(
literal|1
argument_list|)
condition|)
name|sig
operator|=
name|SIGSTOP
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
condition|)
name|unsleep
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
condition|)
name|catch
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|sig
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|p
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_nvcsw
operator|++
expr_stmt|;
name|TD_SET_SLEEPING
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|mi_switch
argument_list|()
expr_stmt|;
block|}
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"msleep resume: thread %p (pid %d, %s)"
argument_list|,
name|td
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TD_IS_RUNNING
argument_list|(
name|td
argument_list|)
argument_list|,
operator|(
literal|"running but not TDS_RUNNING"
operator|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_SINTR
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_TIMEOUT
condition|)
block|{
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_TIMEOUT
expr_stmt|;
if|if
condition|(
name|sig
operator|==
literal|0
condition|)
name|rval
operator|=
name|EWOULDBLOCK
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_TIMOFAIL
condition|)
block|{
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_TIMOFAIL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|timo
operator|&&
name|callout_stop
argument_list|(
operator|&
name|td
operator|->
name|td_slpcallout
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This isn't supposed to be pretty.  If we are here, then 		 * the endtsleep() callout is currently executing on another 		 * CPU and is either spinning on the sched_lock or will be 		 * soon.  If we don't synchronize here, there is a chance 		 * that this process may msleep() again before the callout 		 * has a chance to run and the callout may end up waking up 		 * the wrong msleep().  Yuck. 		 */
name|TD_SET_SLEEPING
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_nivcsw
operator|++
expr_stmt|;
name|mi_switch
argument_list|()
expr_stmt|;
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_TIMOFAIL
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
literal|0
operator|&&
name|catch
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* XXX: shouldn't we always be calling cursig() */
if|if
condition|(
name|sig
operator|!=
literal|0
operator|||
operator|(
name|sig
operator|=
name|cursig
argument_list|(
name|td
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|SIGISMEMBER
argument_list|(
name|p
operator|->
name|p_sigacts
operator|->
name|ps_sigintr
argument_list|,
name|sig
argument_list|)
condition|)
name|rval
operator|=
name|EINTR
expr_stmt|;
else|else
name|rval
operator|=
name|ERESTART
expr_stmt|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|td
argument_list|,
name|KTR_CSW
argument_list|)
condition|)
name|ktrcsw
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
if|if
condition|(
name|mtx
operator|!=
name|NULL
condition|)
block|{
name|mtx_lock
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
name|WITNESS_RESTORE
argument_list|(
operator|&
name|mtx
operator|->
name|mtx_object
argument_list|,
name|mtx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Implement timeout for msleep()  *  * If process hasn't been awakened (wchan non-zero),  * set timeout flag and undo the sleep.  If proc  * is stopped, just unsleep so it will remain stopped.  * MP-safe, called without the Giant mutex.  */
end_comment

begin_function
specifier|static
name|void
name|endtsleep
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|struct
name|thread
modifier|*
name|td
init|=
name|arg
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"endtsleep: thread %p (pid %d, %s)"
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
comment|/* 	 * This is the other half of the synchronization with msleep() 	 * described above.  If the TDS_TIMEOUT flag is set, we lost the 	 * race and just need to put the process back on the runqueue. 	 */
if|if
condition|(
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|slpque
index|[
name|LOOKUP
argument_list|(
name|td
operator|->
name|td_wchan
argument_list|)
index|]
argument_list|,
name|td
argument_list|,
name|td_slpq
argument_list|)
expr_stmt|;
name|TD_CLR_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_flags
operator||=
name|TDF_TIMEOUT
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|td_flags
operator||=
name|TDF_TIMOFAIL
expr_stmt|;
block|}
name|TD_CLR_SLEEPING
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|setrunnable
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Abort a thread, as if an interrupt had occured.  Only abort  * interruptable waits (unfortunatly it isn't only safe to abort others).  * This is about identical to cv_abort().  * Think about merging them?  * Also, whatever the signal code does...  */
end_comment

begin_function
name|void
name|abortsleep
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * If the TDF_TIMEOUT flag is set, just leave. A 	 * timeout is scheduled anyhow. 	 */
if|if
condition|(
operator|(
name|td
operator|->
name|td_flags
operator|&
operator|(
name|TDF_TIMEOUT
operator||
name|TDF_SINTR
operator|)
operator|)
operator|==
name|TDF_SINTR
condition|)
block|{
if|if
condition|(
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|unsleep
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|TD_CLR_SLEEPING
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|setrunnable
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Remove a process from its wait queue  */
end_comment

begin_function
name|void
name|unsleep
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|slpque
index|[
name|LOOKUP
argument_list|(
name|td
operator|->
name|td_wchan
argument_list|)
index|]
argument_list|,
name|td
argument_list|,
name|td_slpq
argument_list|)
expr_stmt|;
name|TD_CLR_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make all processes sleeping on the specified identifier runnable.  */
end_comment

begin_function
name|void
name|wakeup
parameter_list|(
name|ident
parameter_list|)
specifier|register
name|void
modifier|*
name|ident
decl_stmt|;
block|{
specifier|register
name|struct
name|slpquehead
modifier|*
name|qp
decl_stmt|;
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|thread
modifier|*
name|ntd
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|qp
operator|=
operator|&
name|slpque
index|[
name|LOOKUP
argument_list|(
name|ident
argument_list|)
index|]
expr_stmt|;
name|restart
label|:
for|for
control|(
name|td
operator|=
name|TAILQ_FIRST
argument_list|(
name|qp
argument_list|)
init|;
name|td
operator|!=
name|NULL
condition|;
name|td
operator|=
name|ntd
control|)
block|{
name|ntd
operator|=
name|TAILQ_NEXT
argument_list|(
name|td
argument_list|,
name|td_slpq
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_wchan
operator|==
name|ident
condition|)
block|{
name|unsleep
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|TD_CLR_SLEEPING
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|setrunnable
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"wakeup: thread %p (pid %d, %s)"
argument_list|,
name|td
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make a process sleeping on the specified identifier runnable.  * May wake more than one process if a target process is currently  * swapped out.  */
end_comment

begin_function
name|void
name|wakeup_one
parameter_list|(
name|ident
parameter_list|)
specifier|register
name|void
modifier|*
name|ident
decl_stmt|;
block|{
specifier|register
name|struct
name|slpquehead
modifier|*
name|qp
decl_stmt|;
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
specifier|register
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|thread
modifier|*
name|ntd
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|qp
operator|=
operator|&
name|slpque
index|[
name|LOOKUP
argument_list|(
name|ident
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|td
operator|=
name|TAILQ_FIRST
argument_list|(
name|qp
argument_list|)
init|;
name|td
operator|!=
name|NULL
condition|;
name|td
operator|=
name|ntd
control|)
block|{
name|ntd
operator|=
name|TAILQ_NEXT
argument_list|(
name|td
argument_list|,
name|td_slpq
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_wchan
operator|==
name|ident
condition|)
block|{
name|unsleep
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|TD_CLR_SLEEPING
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|setrunnable
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"wakeup1: thread %p (pid %d, %s)"
argument_list|,
name|td
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The machine independent parts of mi_switch().  */
end_comment

begin_function
name|void
name|mi_switch
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|bintime
name|new_switchtime
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
comment|/* XXX */
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
comment|/* XXX */
name|struct
name|kse
modifier|*
name|ke
init|=
name|td
operator|->
name|td_kse
decl_stmt|;
if|#
directive|if
literal|0
block|register struct rlimit *rlim;
endif|#
directive|endif
name|u_int
name|sched_nest
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
operator||
name|MA_NOTRECURSED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ke
operator|->
name|ke_state
operator|==
name|KES_THREAD
operator|)
argument_list|,
operator|(
literal|"mi_switch: kse state?"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|TD_ON_RUNQ
argument_list|(
name|td
argument_list|)
argument_list|,
operator|(
literal|"mi_switch: called by old code"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
operator|!
name|TD_ON_MUTEX
argument_list|(
name|td
argument_list|)
operator|&&
operator|!
name|TD_ON_RUNQ
argument_list|(
name|td
argument_list|)
operator|&&
operator|!
name|TD_IS_RUNNING
argument_list|(
name|td
argument_list|)
condition|)
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|td
operator|->
name|td_critnest
operator|==
literal|1
argument_list|,
operator|(
literal|"mi_switch: switch in a critical section"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Compute the amount of time during which the current 	 * process was running, and add that to its total so far. 	 */
name|binuptime
argument_list|(
operator|&
name|new_switchtime
argument_list|)
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|p
operator|->
name|p_runtime
argument_list|,
operator|&
name|new_switchtime
argument_list|)
expr_stmt|;
name|bintime_sub
argument_list|(
operator|&
name|p
operator|->
name|p_runtime
argument_list|,
name|PCPU_PTR
argument_list|(
name|switchtime
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DDB
comment|/* 	 * Don't perform context switches from the debugger. 	 */
if|if
condition|(
name|db_active
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|db_error
argument_list|(
literal|"Context switches not allowed in the debugger."
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* 	 * Check if the process exceeds its cpu resource allocation. 	 * If over max, kill it. 	 * 	 * XXX drop sched_lock, pickup Giant 	 */
block|if (p->p_state != PRS_ZOMBIE&& 	    p->p_limit->p_cpulimit != RLIM_INFINITY&& 	    p->p_runtime> p->p_limit->p_cpulimit) { 		rlim =&p->p_rlimit[RLIMIT_CPU]; 		if (p->p_runtime / (rlim_t)1000000>= rlim->rlim_max) { 			mtx_unlock_spin(&sched_lock); 			PROC_LOCK(p); 			killproc(p, "exceeded maximum CPU limit"); 			mtx_lock_spin(&sched_lock); 			PROC_UNLOCK(p); 		} else { 			mtx_unlock_spin(&sched_lock); 			PROC_LOCK(p); 			psignal(p, SIGXCPU); 			mtx_lock_spin(&sched_lock); 			PROC_UNLOCK(p); 			if (rlim->rlim_cur< rlim->rlim_max) {
comment|/* XXX: we should make a private copy */
block|rlim->rlim_cur += 5; 			} 		} 	}
endif|#
directive|endif
comment|/* 	 * Finish up stats for outgoing thread. 	 */
name|cnt
operator|.
name|v_swtch
operator|++
expr_stmt|;
name|PCPU_SET
argument_list|(
name|switchtime
argument_list|,
name|new_switchtime
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"mi_switch: old thread %p (pid %d, %s)"
argument_list|,
name|td
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|sched_nest
operator|=
name|sched_lock
operator|.
name|mtx_recurse
expr_stmt|;
name|td
operator|->
name|td_lastcpu
operator|=
name|ke
operator|->
name|ke_oncpu
expr_stmt|;
name|ke
operator|->
name|ke_oncpu
operator|=
name|NOCPU
expr_stmt|;
name|ke
operator|->
name|ke_flags
operator|&=
operator|~
name|KEF_NEEDRESCHED
expr_stmt|;
comment|/* 	 * At the last moment, if this thread is still marked RUNNING, 	 * then put it back on the run queue as it has not been suspended 	 * or stopped or any thing else similar. 	 */
if|if
condition|(
name|TD_IS_RUNNING
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
operator|(
name|ke
operator|->
name|ke_flags
operator|&
name|KEF_IDLEKSE
operator|)
operator|==
literal|0
operator|)
argument_list|,
operator|(
literal|"Idle thread in mi_switch with wrong state"
operator|)
argument_list|)
expr_stmt|;
comment|/* Put us back on the run queue (kse and all). */
name|setrunqueue
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_UNBOUND
condition|)
block|{
comment|/* 		 * We will not be on the run queue. So we must be 		 * sleeping or similar. If it's available, 		 * someone else can use the KSE if they need it. 		 * XXXKSE KSE loaning will change this. 		 */
name|td
operator|->
name|td_kse
operator|=
name|NULL
expr_stmt|;
name|kse_reassign
argument_list|(
name|ke
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_KSES
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
operator|(
name|ke
operator|->
name|ke_bound
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ke
operator|->
name|ke_bound
operator|==
name|td
operator|)
operator|)
argument_list|,
operator|(
literal|"mi_switch: bad bound state"
operator|)
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_bound
operator|=
name|td
expr_stmt|;
name|kse_reassign
argument_list|(
name|ke
argument_list|)
expr_stmt|;
block|}
name|cpu_switch
argument_list|()
expr_stmt|;
comment|/* SHAZAM!!*/
comment|/*  	 * Start setting up stats etc. for the incoming thread. 	 * Similar code in fork_exit() is returned to by cpu_switch() 	 * in the case of a new thread/process. 	 */
name|td
operator|->
name|td_kse
operator|->
name|ke_oncpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|sched_lock
operator|.
name|mtx_recurse
operator|=
name|sched_nest
expr_stmt|;
name|sched_lock
operator|.
name|mtx_lock
operator|=
operator|(
name|uintptr_t
operator|)
name|td
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"mi_switch: new thread %p (pid %d, %s)"
argument_list|,
name|td
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
if|if
condition|(
name|PCPU_GET
argument_list|(
name|switchtime
operator|.
name|sec
argument_list|)
operator|==
literal|0
condition|)
name|binuptime
argument_list|(
name|PCPU_PTR
argument_list|(
name|switchtime
argument_list|)
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|switchticks
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
comment|/* 	 * Call the switchin function while still holding the scheduler lock 	 * (used by the idlezero code and the general page-zeroing code) 	 */
if|if
condition|(
name|td
operator|->
name|td_switchin
condition|)
name|td
operator|->
name|td_switchin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change process state to be runnable,  * placing it on the run queue if it is in memory,  * and awakening the swapper if it isn't in memory.  */
end_comment

begin_function
name|void
name|setrunnable
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|p_state
condition|)
block|{
case|case
name|PRS_ZOMBIE
case|:
name|panic
argument_list|(
literal|"setrunnable(1)"
argument_list|)
expr_stmt|;
default|default:
break|break;
block|}
switch|switch
condition|(
name|td
operator|->
name|td_state
condition|)
block|{
case|case
name|TDS_RUNNING
case|:
case|case
name|TDS_RUNQ
case|:
return|return;
case|case
name|TDS_INHIBITED
case|:
comment|/* 		 * If we are only inhibited because we are swapped out 		 * then arange to swap in this process. Otherwise just return. 		 */
if|if
condition|(
name|td
operator|->
name|td_inhibitors
operator|!=
name|TDI_SWAPPED
condition|)
return|return;
case|case
name|TDS_CAN_RUN
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"state is 0x%x"
argument_list|,
name|td
operator|->
name|td_state
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"setrunnable(2)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|p
operator|->
name|p_sflag
operator|&
name|PS_INMEM
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|p_sflag
operator|&
name|PS_SWAPPINGIN
operator|)
operator|==
literal|0
condition|)
block|{
name|p
operator|->
name|p_sflag
operator||=
name|PS_SWAPINREQ
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|proc0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
if|if
condition|(
name|kg
operator|->
name|kg_slptime
operator|>
literal|1
condition|)
name|updatepri
argument_list|(
name|kg
argument_list|)
expr_stmt|;
name|kg
operator|->
name|kg_slptime
operator|=
literal|0
expr_stmt|;
name|setrunqueue
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|maybe_resched
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compute the priority of a process when running in user mode.  * Arrange to reschedule if the resulting priority is better  * than that of the current process.  */
end_comment

begin_function
name|void
name|resetpriority
parameter_list|(
name|kg
parameter_list|)
specifier|register
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|newpriority
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|kg
operator|->
name|kg_pri_class
operator|==
name|PRI_TIMESHARE
condition|)
block|{
name|newpriority
operator|=
name|PUSER
operator|+
name|kg
operator|->
name|kg_estcpu
operator|/
name|INVERSE_ESTCPU_WEIGHT
operator|+
name|NICE_WEIGHT
operator|*
operator|(
name|kg
operator|->
name|kg_nice
operator|-
name|PRIO_MIN
operator|)
expr_stmt|;
name|newpriority
operator|=
name|min
argument_list|(
name|max
argument_list|(
name|newpriority
argument_list|,
name|PRI_MIN_TIMESHARE
argument_list|)
argument_list|,
name|PRI_MAX_TIMESHARE
argument_list|)
expr_stmt|;
name|kg
operator|->
name|kg_user_pri
operator|=
name|newpriority
expr_stmt|;
block|}
name|FOREACH_THREAD_IN_GROUP
argument_list|(
argument|kg
argument_list|,
argument|td
argument_list|)
block|{
name|maybe_resched
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* XXXKSE silly */
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute a tenex style load average of a quantity on  * 1, 5 and 15 minute intervals.  * XXXKSE   Needs complete rewrite when correct info is available.  * Completely Bogus.. only works with 1:1 (but compiles ok now :-)  */
end_comment

begin_function
specifier|static
name|void
name|loadav
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nrun
decl_stmt|;
name|struct
name|loadavg
modifier|*
name|avg
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|avg
operator|=
operator|&
name|averunnable
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|nrun
operator|=
literal|0
expr_stmt|;
name|FOREACH_PROC_IN_SYSTEM
argument_list|(
argument|p
argument_list|)
block|{
name|FOREACH_THREAD_IN_PROC
argument_list|(
argument|p
argument_list|,
argument|td
argument_list|)
block|{
switch|switch
condition|(
name|td
operator|->
name|td_state
condition|)
block|{
case|case
name|TDS_RUNQ
case|:
case|case
name|TDS_RUNNING
case|:
if|if
condition|(
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_NOLOAD
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|nextproc
goto|;
name|nrun
operator|++
expr_stmt|;
comment|/* XXXKSE */
default|default:
break|break;
block|}
name|nextproc
label|:
continue|continue;
block|}
block|}
name|sx_sunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|avg
operator|->
name|ldavg
index|[
name|i
index|]
operator|=
operator|(
name|cexp
index|[
name|i
index|]
operator|*
name|avg
operator|->
name|ldavg
index|[
name|i
index|]
operator|+
name|nrun
operator|*
name|FSCALE
operator|*
operator|(
name|FSCALE
operator|-
name|cexp
index|[
name|i
index|]
operator|)
operator|)
operator|>>
name|FSHIFT
expr_stmt|;
comment|/* 	 * Schedule the next update to occur after 5 seconds, but add a 	 * random variation to avoid synchronisation with processes that 	 * run at regular intervals. 	 */
name|callout_reset
argument_list|(
operator|&
name|loadav_callout
argument_list|,
name|hz
operator|*
literal|4
operator|+
call|(
name|int
call|)
argument_list|(
name|random
argument_list|()
operator|%
operator|(
name|hz
operator|*
literal|2
operator|+
literal|1
operator|)
argument_list|)
argument_list|,
name|loadav
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|sched_setup
parameter_list|(
name|dummy
parameter_list|)
name|void
modifier|*
name|dummy
decl_stmt|;
block|{
name|callout_init
argument_list|(
operator|&
name|schedcpu_callout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|roundrobin_callout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|loadav_callout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Kick off timeout driven events by calling first time. */
name|roundrobin
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|schedcpu
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|loadav
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We adjust the priority of the current process.  The priority of  * a process gets worse as it accumulates CPU time.  The cpu usage  * estimator (p_estcpu) is increased here.  resetpriority() will  * compute a different priority each time p_estcpu increases by  * INVERSE_ESTCPU_WEIGHT  * (until MAXPRI is reached).  The cpu usage estimator ramps up  * quite quickly when the process is running (linearly), and decays  * away exponentially, at a rate which is proportionally slower when  * the system is busy.  The basic principle is that the system will  * 90% forget that the process used a lot of CPU time in 5 * loadav  * seconds.  This causes the system to favor processes which haven't  * run much recently, and to round-robin among other processes.  */
end_comment

begin_function
name|void
name|schedclock
parameter_list|(
name|td
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|td
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"schedclock: null thread pointer"
operator|)
argument_list|)
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
name|ke
operator|->
name|ke_cpticks
operator|++
expr_stmt|;
name|kg
operator|->
name|kg_estcpu
operator|=
name|ESTCPULIM
argument_list|(
name|kg
operator|->
name|kg_estcpu
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kg
operator|->
name|kg_estcpu
operator|%
name|INVERSE_ESTCPU_WEIGHT
operator|)
operator|==
literal|0
condition|)
block|{
name|resetpriority
argument_list|(
name|kg
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_priority
operator|>=
name|PUSER
condition|)
name|td
operator|->
name|td_priority
operator|=
name|kg
operator|->
name|kg_user_pri
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * General purpose yield system call  */
end_comment

begin_function
name|int
name|yield
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|yield_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|ksegrp
modifier|*
name|kg
init|=
name|td
operator|->
name|td_ksegrp
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_priority
operator|=
name|PRI_MAX_TIMESHARE
expr_stmt|;
name|kg
operator|->
name|kg_proc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_nvcsw
operator|++
expr_stmt|;
name|mi_switch
argument_list|()
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

