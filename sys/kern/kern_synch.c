begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1990, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  * (c) UNIX System Laboratories, Inc.  * All or some portions of this file are derived from material licensed  * to the University of California by American Telephone and Telegraph  * Co. or Unix System Laboratories, Inc. and are reproduced herein with  * the permission of UNIX System Laboratories, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)kern_synch.c	8.9 (Berkeley) 5/19/95  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ktrace.h"
end_include

begin_include
include|#
directive|include
file|"opt_sched.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/sdt.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sleepqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_function_decl
specifier|static
name|void
name|synch_setup
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSINIT
argument_list|(
name|synch_setup
argument_list|,
name|SI_SUB_KICK_SCHEDULER
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|synch_setup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|hogticks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint8_t
name|pause_wchan
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|callout
name|loadav_callout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|loadavg
name|averunnable
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
name|FSCALE
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* load average, of runnable procs */
end_comment

begin_comment
comment|/*  * Constants for averages over 1, 5, and 15 minutes  * when sampling at 5 second intervals.  */
end_comment

begin_decl_stmt
specifier|static
name|fixpt_t
name|cexp
index|[
literal|3
index|]
init|=
block|{
literal|0.9200444146293232
operator|*
name|FSCALE
block|,
comment|/* exp(-1/12) */
literal|0.9834714538216174
operator|*
name|FSCALE
block|,
comment|/* exp(-1/60) */
literal|0.9944598480048967
operator|*
name|FSCALE
block|,
comment|/* exp(-1/180) */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* kernel uses `FSCALE', userland (SHOULD) use kern.fscale */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|fscale
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|SYSCTL_NULL_INT_PTR
argument_list|,
name|FSCALE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|loadav
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SDT_PROVIDER_DECLARE
argument_list|(
name|sched
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SDT_PROBE_DEFINE
argument_list|(
name|sched
argument_list|, , ,
name|preempt
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|sleepinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|hogticks
operator|=
operator|(
name|hz
operator|/
literal|10
operator|)
operator|*
literal|2
expr_stmt|;
comment|/* Default only. */
name|init_sleepqueues
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * vmem tries to lock the sleepq mutexes when free'ing kva, so make sure  * it is available.  */
end_comment

begin_expr_stmt
name|SYSINIT
argument_list|(
name|sleepinit
argument_list|,
name|SI_SUB_KMEM
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|sleepinit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * General sleep call.  Suspends the current thread until a wakeup is  * performed on the specified identifier.  The thread will then be made  * runnable with the specified priority.  Sleeps at most sbt units of time  * (0 means no timeout).  If pri includes the PCATCH flag, let signals  * interrupt the sleep, otherwise ignore them while sleeping.  Returns 0 if  * awakened, EWOULDBLOCK if the timeout expires.  If PCATCH is set and a  * signal becomes pending, ERESTART is returned if the current system  * call should be restarted if possible, and EINTR is returned if the system  * call should be interrupted by the signal (return EINTR).  *  * The lock argument is unlocked before the caller is suspended, and  * re-locked before _sleep() returns.  If priority includes the PDROP  * flag the lock is not re-locked before returning.  */
end_comment

begin_function
name|int
name|_sleep
parameter_list|(
name|void
modifier|*
name|ident
parameter_list|,
name|struct
name|lock_object
modifier|*
name|lock
parameter_list|,
name|int
name|priority
parameter_list|,
specifier|const
name|char
modifier|*
name|wmesg
parameter_list|,
name|sbintime_t
name|sbt
parameter_list|,
name|sbintime_t
name|pr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|lock_class
modifier|*
name|class
decl_stmt|;
name|uintptr_t
name|lock_state
decl_stmt|;
name|int
name|catch
decl_stmt|,
name|pri
decl_stmt|,
name|rval
decl_stmt|,
name|sleepq_flags
decl_stmt|;
name|WITNESS_SAVE_DECL
argument_list|(
name|lock_witness
argument_list|)
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|td
argument_list|,
name|KTR_CSW
argument_list|)
condition|)
name|ktrcsw
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|wmesg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|WITNESS_WARN
argument_list|(
name|WARN_GIANTOK
operator||
name|WARN_SLEEPOK
argument_list|,
name|lock
argument_list|,
literal|"Sleeping on \"%s\""
argument_list|,
name|wmesg
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sbt
operator|!=
literal|0
operator|||
name|mtx_owned
argument_list|(
operator|&
name|Giant
argument_list|)
operator|||
name|lock
operator|!=
name|NULL
argument_list|,
operator|(
literal|"sleeping without a lock"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ident
operator|!=
name|NULL
argument_list|,
operator|(
literal|"_sleep: NULL ident"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TD_IS_RUNNING
argument_list|(
name|td
argument_list|)
argument_list|,
operator|(
literal|"_sleep: curthread not running"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|priority
operator|&
name|PDROP
condition|)
name|KASSERT
argument_list|(
name|lock
operator|!=
name|NULL
operator|&&
name|lock
operator|!=
operator|&
name|Giant
operator|.
name|lock_object
argument_list|,
operator|(
literal|"PDROP requires a non-Giant lock"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|!=
name|NULL
condition|)
name|class
operator|=
name|LOCK_CLASS
argument_list|(
name|lock
argument_list|)
expr_stmt|;
else|else
name|class
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|SCHEDULER_STOPPED_TD
argument_list|(
name|td
argument_list|)
condition|)
block|{
if|if
condition|(
name|lock
operator|!=
name|NULL
operator|&&
name|priority
operator|&
name|PDROP
condition|)
name|class
operator|->
name|lc_unlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|catch
operator|=
name|priority
operator|&
name|PCATCH
expr_stmt|;
name|pri
operator|=
name|priority
operator|&
name|PRIMASK
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|TD_ON_SLEEPQ
argument_list|(
name|td
argument_list|)
argument_list|,
operator|(
literal|"recursive sleep"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uint8_t
operator|*
operator|)
name|ident
operator|>=
operator|&
name|pause_wchan
index|[
literal|0
index|]
operator|&&
operator|(
name|uint8_t
operator|*
operator|)
name|ident
operator|<=
operator|&
name|pause_wchan
index|[
name|MAXCPU
operator|-
literal|1
index|]
condition|)
name|sleepq_flags
operator|=
name|SLEEPQ_PAUSE
expr_stmt|;
else|else
name|sleepq_flags
operator|=
name|SLEEPQ_SLEEP
expr_stmt|;
if|if
condition|(
name|catch
condition|)
name|sleepq_flags
operator||=
name|SLEEPQ_INTERRUPTIBLE
expr_stmt|;
name|sleepq_lock
argument_list|(
name|ident
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_PROC
argument_list|,
literal|"sleep: thread %ld (pid %ld, %s) on %s (%p)"
argument_list|,
name|td
operator|->
name|td_tid
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_name
argument_list|,
name|wmesg
argument_list|,
name|ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|==
operator|&
name|Giant
operator|.
name|lock_object
condition|)
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
if|if
condition|(
name|lock
operator|!=
name|NULL
operator|&&
name|lock
operator|!=
operator|&
name|Giant
operator|.
name|lock_object
operator|&&
operator|!
operator|(
name|class
operator|->
name|lc_flags
operator|&
name|LC_SLEEPABLE
operator|)
condition|)
block|{
name|WITNESS_SAVE
argument_list|(
name|lock
argument_list|,
name|lock_witness
argument_list|)
expr_stmt|;
name|lock_state
operator|=
name|class
operator|->
name|lc_unlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* GCC needs to follow the Yellow Brick Road */
name|lock_state
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * We put ourselves on the sleep queue and start our timeout 	 * before calling thread_suspend_check, as we could stop there, 	 * and a wakeup or a SIGCONT (or both) could occur while we were 	 * stopped without resuming us.  Thus, we must be ready for sleep 	 * when cursig() is called.  If the wakeup happens while we're 	 * stopped, then td will no longer be on a sleep queue upon 	 * return from cursig(). 	 */
name|sleepq_add
argument_list|(
name|ident
argument_list|,
name|lock
argument_list|,
name|wmesg
argument_list|,
name|sleepq_flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbt
operator|!=
literal|0
condition|)
name|sleepq_set_timeout_sbt
argument_list|(
name|ident
argument_list|,
name|sbt
argument_list|,
name|pr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|!=
name|NULL
operator|&&
name|class
operator|->
name|lc_flags
operator|&
name|LC_SLEEPABLE
condition|)
block|{
name|sleepq_release
argument_list|(
name|ident
argument_list|)
expr_stmt|;
name|WITNESS_SAVE
argument_list|(
name|lock
argument_list|,
name|lock_witness
argument_list|)
expr_stmt|;
name|lock_state
operator|=
name|class
operator|->
name|lc_unlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|sleepq_lock
argument_list|(
name|ident
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sbt
operator|!=
literal|0
operator|&&
name|catch
condition|)
name|rval
operator|=
name|sleepq_timedwait_sig
argument_list|(
name|ident
argument_list|,
name|pri
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sbt
operator|!=
literal|0
condition|)
name|rval
operator|=
name|sleepq_timedwait
argument_list|(
name|ident
argument_list|,
name|pri
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|catch
condition|)
name|rval
operator|=
name|sleepq_wait_sig
argument_list|(
name|ident
argument_list|,
name|pri
argument_list|)
expr_stmt|;
else|else
block|{
name|sleepq_wait
argument_list|(
name|ident
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|td
argument_list|,
name|KTR_CSW
argument_list|)
condition|)
name|ktrcsw
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|wmesg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
if|if
condition|(
name|lock
operator|!=
name|NULL
operator|&&
name|lock
operator|!=
operator|&
name|Giant
operator|.
name|lock_object
operator|&&
operator|!
operator|(
name|priority
operator|&
name|PDROP
operator|)
condition|)
block|{
name|class
operator|->
name|lc_lock
argument_list|(
name|lock
argument_list|,
name|lock_state
argument_list|)
expr_stmt|;
name|WITNESS_RESTORE
argument_list|(
name|lock
argument_list|,
name|lock_witness
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|msleep_spin_sbt
parameter_list|(
name|void
modifier|*
name|ident
parameter_list|,
name|struct
name|mtx
modifier|*
name|mtx
parameter_list|,
specifier|const
name|char
modifier|*
name|wmesg
parameter_list|,
name|sbintime_t
name|sbt
parameter_list|,
name|sbintime_t
name|pr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|WITNESS_SAVE_DECL
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|KASSERT
argument_list|(
name|mtx
operator|!=
name|NULL
argument_list|,
operator|(
literal|"sleeping without a mutex"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ident
operator|!=
name|NULL
argument_list|,
operator|(
literal|"msleep_spin_sbt: NULL ident"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TD_IS_RUNNING
argument_list|(
name|td
argument_list|)
argument_list|,
operator|(
literal|"msleep_spin_sbt: curthread not running"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCHEDULER_STOPPED_TD
argument_list|(
name|td
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sleepq_lock
argument_list|(
name|ident
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_PROC
argument_list|,
literal|"msleep_spin: thread %ld (pid %ld, %s) on %s (%p)"
argument_list|,
name|td
operator|->
name|td_tid
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_name
argument_list|,
name|wmesg
argument_list|,
name|ident
argument_list|)
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|mtx_assert
argument_list|(
name|mtx
argument_list|,
name|MA_OWNED
operator||
name|MA_NOTRECURSED
argument_list|)
expr_stmt|;
name|WITNESS_SAVE
argument_list|(
operator|&
name|mtx
operator|->
name|lock_object
argument_list|,
name|mtx
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
comment|/* 	 * We put ourselves on the sleep queue and start our timeout. 	 */
name|sleepq_add
argument_list|(
name|ident
argument_list|,
operator|&
name|mtx
operator|->
name|lock_object
argument_list|,
name|wmesg
argument_list|,
name|SLEEPQ_SLEEP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbt
operator|!=
literal|0
condition|)
name|sleepq_set_timeout_sbt
argument_list|(
name|ident
argument_list|,
name|sbt
argument_list|,
name|pr
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 * Can't call ktrace with any spin locks held so it can lock the 	 * ktrace_mtx lock, and WITNESS_WARN considers it an error to hold 	 * any spin lock.  Thus, we have to drop the sleepq spin lock while 	 * we handle those requests.  This is safe since we have placed our 	 * thread on the sleep queue already. 	 */
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|td
argument_list|,
name|KTR_CSW
argument_list|)
condition|)
block|{
name|sleepq_release
argument_list|(
name|ident
argument_list|)
expr_stmt|;
name|ktrcsw
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|wmesg
argument_list|)
expr_stmt|;
name|sleepq_lock
argument_list|(
name|ident
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|WITNESS
name|sleepq_release
argument_list|(
name|ident
argument_list|)
expr_stmt|;
name|WITNESS_WARN
argument_list|(
name|WARN_GIANTOK
operator||
name|WARN_SLEEPOK
argument_list|,
name|NULL
argument_list|,
literal|"Sleeping on \"%s\""
argument_list|,
name|wmesg
argument_list|)
expr_stmt|;
name|sleepq_lock
argument_list|(
name|ident
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sbt
operator|!=
literal|0
condition|)
name|rval
operator|=
name|sleepq_timedwait
argument_list|(
name|ident
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|sleepq_wait
argument_list|(
name|ident
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|td
argument_list|,
name|KTR_CSW
argument_list|)
condition|)
name|ktrcsw
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|wmesg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
name|mtx_lock_spin
argument_list|(
name|mtx
argument_list|)
expr_stmt|;
name|WITNESS_RESTORE
argument_list|(
operator|&
name|mtx
operator|->
name|lock_object
argument_list|,
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * pause() delays the calling thread by the given number of system ticks.  * During cold bootup, pause() uses the DELAY() function instead of  * the tsleep() function to do the waiting. The "timo" argument must be  * greater than or equal to zero. A "timo" value of zero is equivalent  * to a "timo" value of one.  */
end_comment

begin_function
name|int
name|pause_sbt
parameter_list|(
specifier|const
name|char
modifier|*
name|wmesg
parameter_list|,
name|sbintime_t
name|sbt
parameter_list|,
name|sbintime_t
name|pr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|sbt
operator|>=
literal|0
argument_list|,
operator|(
literal|"pause: timeout must be>= 0"
operator|)
argument_list|)
expr_stmt|;
comment|/* silently convert invalid timeouts */
if|if
condition|(
name|sbt
operator|==
literal|0
condition|)
name|sbt
operator|=
name|tick_sbt
expr_stmt|;
if|if
condition|(
operator|(
name|cold
operator|&&
name|curthread
operator|==
operator|&
name|thread0
operator|)
operator|||
name|kdb_active
operator|||
name|SCHEDULER_STOPPED
argument_list|()
condition|)
block|{
comment|/* 		 * We delay one second at a time to avoid overflowing the 		 * system specific DELAY() function(s): 		 */
while|while
condition|(
name|sbt
operator|>=
name|SBT_1S
condition|)
block|{
name|DELAY
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
name|sbt
operator|-=
name|SBT_1S
expr_stmt|;
block|}
comment|/* Do the delay remainder, if any */
name|sbt
operator|=
name|howmany
argument_list|(
name|sbt
argument_list|,
name|SBT_1US
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbt
operator|>
literal|0
condition|)
name|DELAY
argument_list|(
name|sbt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|_sleep
argument_list|(
operator|&
name|pause_wchan
index|[
name|curcpu
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|wmesg
argument_list|,
name|sbt
argument_list|,
name|pr
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make all threads sleeping on the specified identifier runnable.  */
end_comment

begin_function
name|void
name|wakeup
parameter_list|(
name|void
modifier|*
name|ident
parameter_list|)
block|{
name|int
name|wakeup_swapper
decl_stmt|;
name|sleepq_lock
argument_list|(
name|ident
argument_list|)
expr_stmt|;
name|wakeup_swapper
operator|=
name|sleepq_broadcast
argument_list|(
name|ident
argument_list|,
name|SLEEPQ_SLEEP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sleepq_release
argument_list|(
name|ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|wakeup_swapper
condition|)
block|{
name|KASSERT
argument_list|(
name|ident
operator|!=
operator|&
name|proc0
argument_list|,
operator|(
literal|"wakeup and wakeup_swapper and proc0"
operator|)
argument_list|)
expr_stmt|;
name|kick_proc0
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Make a thread sleeping on the specified identifier runnable.  * May wake more than one thread if a target thread is currently  * swapped out.  */
end_comment

begin_function
name|void
name|wakeup_one
parameter_list|(
name|void
modifier|*
name|ident
parameter_list|)
block|{
name|int
name|wakeup_swapper
decl_stmt|;
name|sleepq_lock
argument_list|(
name|ident
argument_list|)
expr_stmt|;
name|wakeup_swapper
operator|=
name|sleepq_signal
argument_list|(
name|ident
argument_list|,
name|SLEEPQ_SLEEP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sleepq_release
argument_list|(
name|ident
argument_list|)
expr_stmt|;
if|if
condition|(
name|wakeup_swapper
condition|)
name|kick_proc0
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kdb_switch
parameter_list|(
name|void
parameter_list|)
block|{
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|kdb_backtrace
argument_list|()
expr_stmt|;
name|kdb_reenter
argument_list|()
expr_stmt|;
name|panic
argument_list|(
literal|"%s: did not reenter debugger"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The machine independent parts of context switching.  */
end_comment

begin_function
name|void
name|mi_switch
parameter_list|(
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|newtd
parameter_list|)
block|{
name|uint64_t
name|runtime
decl_stmt|,
name|new_switchtime
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
comment|/* XXX */
name|THREAD_LOCK_ASSERT
argument_list|(
name|td
argument_list|,
name|MA_OWNED
operator||
name|MA_NOTRECURSED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|TD_ON_RUNQ
argument_list|(
name|td
argument_list|)
argument_list|,
operator|(
literal|"mi_switch: called by old code"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
operator|!
name|TD_ON_LOCK
argument_list|(
name|td
argument_list|)
operator|&&
operator|!
name|TD_IS_RUNNING
argument_list|(
name|td
argument_list|)
condition|)
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|td
operator|->
name|td_critnest
operator|==
literal|1
operator|||
name|panicstr
argument_list|,
operator|(
literal|"mi_switch: switch in a critical section"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|flags
operator|&
operator|(
name|SW_INVOL
operator||
name|SW_VOL
operator|)
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"mi_switch: switch must be voluntary or involuntary"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|newtd
operator|!=
name|curthread
argument_list|,
operator|(
literal|"mi_switch: preempting back to ourself"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Don't perform context switches from the debugger. 	 */
if|if
condition|(
name|kdb_active
condition|)
name|kdb_switch
argument_list|()
expr_stmt|;
if|if
condition|(
name|SCHEDULER_STOPPED_TD
argument_list|(
name|td
argument_list|)
condition|)
return|return;
if|if
condition|(
name|flags
operator|&
name|SW_VOL
condition|)
block|{
name|td
operator|->
name|td_ru
operator|.
name|ru_nvcsw
operator|++
expr_stmt|;
name|td
operator|->
name|td_swvoltick
operator|=
name|ticks
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|td_ru
operator|.
name|ru_nivcsw
operator|++
expr_stmt|;
name|td
operator|->
name|td_swinvoltick
operator|=
name|ticks
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCHED_STATS
name|SCHED_STAT_INC
argument_list|(
name|sched_switch_stats
index|[
name|flags
operator|&
name|SW_TYPE_MASK
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Compute the amount of time during which the current 	 * thread was running, and add that to its total so far. 	 */
name|new_switchtime
operator|=
name|cpu_ticks
argument_list|()
expr_stmt|;
name|runtime
operator|=
name|new_switchtime
operator|-
name|PCPU_GET
argument_list|(
name|switchtime
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_runtime
operator|+=
name|runtime
expr_stmt|;
name|td
operator|->
name|td_incruntime
operator|+=
name|runtime
expr_stmt|;
name|PCPU_SET
argument_list|(
name|switchtime
argument_list|,
name|new_switchtime
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_generation
operator|++
expr_stmt|;
comment|/* bump preempt-detect counter */
name|VM_CNT_INC
argument_list|(
name|v_swtch
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|switchticks
argument_list|,
name|ticks
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_PROC
argument_list|,
literal|"mi_switch: old thread %ld (td_sched %p, pid %ld, %s)"
argument_list|,
name|td
operator|->
name|td_tid
argument_list|,
name|td_get_sched
argument_list|(
name|td
argument_list|)
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDTRACE_HOOKS
if|if
condition|(
operator|(
name|flags
operator|&
name|SW_PREEMPT
operator|)
operator|!=
literal|0
operator|||
operator|(
operator|(
name|flags
operator|&
name|SW_INVOL
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|flags
operator|&
name|SW_TYPE_MASK
operator|)
operator|==
name|SWT_NEEDRESCHED
operator|)
condition|)
name|SDT_PROBE0
argument_list|(
name|sched
argument_list|, , ,
name|preempt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sched_switch
argument_list|(
name|td
argument_list|,
name|newtd
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_PROC
argument_list|,
literal|"mi_switch: new thread %ld (td_sched %p, pid %ld, %s)"
argument_list|,
name|td
operator|->
name|td_tid
argument_list|,
name|td_get_sched
argument_list|(
name|td
argument_list|)
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_name
argument_list|)
expr_stmt|;
comment|/*  	 * If the last thread was exiting, finish cleaning it up. 	 */
if|if
condition|(
operator|(
name|td
operator|=
name|PCPU_GET
argument_list|(
name|deadthread
argument_list|)
operator|)
condition|)
block|{
name|PCPU_SET
argument_list|(
name|deadthread
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|thread_stash
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Change thread state to be runnable, placing it on the run queue if  * it is in memory.  If it is swapped out, return true so our caller  * will know to awaken the swapper.  */
end_comment

begin_function
name|int
name|setrunnable
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|THREAD_LOCK_ASSERT
argument_list|(
name|td
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_state
operator|!=
name|PRS_ZOMBIE
argument_list|,
operator|(
literal|"setrunnable: pid %d is a zombie"
operator|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|td
operator|->
name|td_state
condition|)
block|{
case|case
name|TDS_RUNNING
case|:
case|case
name|TDS_RUNQ
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|TDS_INHIBITED
case|:
comment|/* 		 * If we are only inhibited because we are swapped out 		 * then arange to swap in this process. Otherwise just return. 		 */
if|if
condition|(
name|td
operator|->
name|td_inhibitors
operator|!=
name|TDI_SWAPPED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* FALLTHROUGH */
case|case
name|TDS_CAN_RUN
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"state is 0x%x"
argument_list|,
name|td
operator|->
name|td_state
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"setrunnable(2)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_INMEM
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_SWAPINREQ
operator|)
operator|==
literal|0
condition|)
block|{
name|td
operator|->
name|td_flags
operator||=
name|TDF_SWAPINREQ
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
name|sched_wakeup
argument_list|(
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute a tenex style load average of a quantity on  * 1, 5 and 15 minute intervals.  */
end_comment

begin_function
specifier|static
name|void
name|loadav
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nrun
decl_stmt|;
name|struct
name|loadavg
modifier|*
name|avg
decl_stmt|;
name|nrun
operator|=
name|sched_load
argument_list|()
expr_stmt|;
name|avg
operator|=
operator|&
name|averunnable
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|avg
operator|->
name|ldavg
index|[
name|i
index|]
operator|=
operator|(
name|cexp
index|[
name|i
index|]
operator|*
name|avg
operator|->
name|ldavg
index|[
name|i
index|]
operator|+
name|nrun
operator|*
name|FSCALE
operator|*
operator|(
name|FSCALE
operator|-
name|cexp
index|[
name|i
index|]
operator|)
operator|)
operator|>>
name|FSHIFT
expr_stmt|;
comment|/* 	 * Schedule the next update to occur after 5 seconds, but add a 	 * random variation to avoid synchronisation with processes that 	 * run at regular intervals. 	 */
name|callout_reset_sbt
argument_list|(
operator|&
name|loadav_callout
argument_list|,
name|SBT_1US
operator|*
operator|(
literal|4000000
operator|+
call|(
name|int
call|)
argument_list|(
name|random
argument_list|()
operator|%
literal|2000001
argument_list|)
operator|)
argument_list|,
name|SBT_1US
argument_list|,
name|loadav
argument_list|,
name|NULL
argument_list|,
name|C_DIRECT_EXEC
operator||
name|C_PREL
argument_list|(
literal|32
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|synch_setup
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|callout_init
argument_list|(
operator|&
name|loadav_callout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Kick off timeout driven events by calling first time. */
name|loadav
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|should_yield
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|(
name|u_int
operator|)
name|ticks
operator|-
operator|(
name|u_int
operator|)
name|curthread
operator|->
name|td_swvoltick
operator|>=
name|hogticks
operator|)
return|;
block|}
end_function

begin_function
name|void
name|maybe_yield
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|should_yield
argument_list|()
condition|)
name|kern_yield
argument_list|(
name|PRI_USER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|kern_yield
parameter_list|(
name|int
name|prio
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|prio
operator|==
name|PRI_USER
condition|)
name|prio
operator|=
name|td
operator|->
name|td_user_pri
expr_stmt|;
if|if
condition|(
name|prio
operator|>=
literal|0
condition|)
name|sched_prio
argument_list|(
name|td
argument_list|,
name|prio
argument_list|)
expr_stmt|;
name|mi_switch
argument_list|(
name|SW_VOL
operator||
name|SWT_RELINQUISH
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * General purpose yield system call.  */
end_comment

begin_function
name|int
name|sys_yield
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|yield_args
modifier|*
name|uap
parameter_list|)
block|{
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|PRI_BASE
argument_list|(
name|td
operator|->
name|td_pri_class
argument_list|)
operator|==
name|PRI_TIMESHARE
condition|)
name|sched_prio
argument_list|(
name|td
argument_list|,
name|PRI_MAX_TIMESHARE
argument_list|)
expr_stmt|;
name|mi_switch
argument_list|(
name|SW_VOL
operator||
name|SWT_RELINQUISH
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

