begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)tty_compat.c	8.1 (Berkeley) 6/10/93  * $Id: tty_compat.c,v 1.23 1997/08/02 14:31:39 bde Exp $  */
end_comment

begin_comment
comment|/*  * mapping routines for old line discipline (yuck)  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_43
argument_list|)
operator|||
name|defined
argument_list|(
name|COMPAT_SUNOS
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl_compat.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|ttcompatgetflags
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ttcompatsetflags
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|,
expr|struct
name|termios
operator|*
name|t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ttcompatsetlflags
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|,
expr|struct
name|termios
operator|*
name|t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ttcompatspeedtab
name|__P
argument_list|(
operator|(
name|int
name|speed
operator|,
expr|struct
name|speedtab
operator|*
name|table
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ttydebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|ttydebug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ttydebug
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|speedtab
name|compatspeeds
index|[]
init|=
block|{
define|#
directive|define
name|MAX_SPEED
value|17
block|{
literal|115200
block|,
literal|17
block|}
block|,
block|{
literal|57600
block|,
literal|16
block|}
block|,
block|{
literal|38400
block|,
literal|15
block|}
block|,
block|{
literal|19200
block|,
literal|14
block|}
block|,
block|{
literal|9600
block|,
literal|13
block|}
block|,
block|{
literal|4800
block|,
literal|12
block|}
block|,
block|{
literal|2400
block|,
literal|11
block|}
block|,
block|{
literal|1800
block|,
literal|10
block|}
block|,
block|{
literal|1200
block|,
literal|9
block|}
block|,
block|{
literal|600
block|,
literal|8
block|}
block|,
block|{
literal|300
block|,
literal|7
block|}
block|,
block|{
literal|200
block|,
literal|6
block|}
block|,
block|{
literal|150
block|,
literal|5
block|}
block|,
block|{
literal|134
block|,
literal|4
block|}
block|,
block|{
literal|110
block|,
literal|3
block|}
block|,
block|{
literal|75
block|,
literal|2
block|}
block|,
block|{
literal|50
block|,
literal|1
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|compatspcodes
index|[]
init|=
block|{
literal|0
block|,
literal|50
block|,
literal|75
block|,
literal|110
block|,
literal|134
block|,
literal|150
block|,
literal|200
block|,
literal|300
block|,
literal|600
block|,
literal|1200
block|,
literal|1800
block|,
literal|2400
block|,
literal|4800
block|,
literal|9600
block|,
literal|19200
block|,
literal|38400
block|,
literal|57600
block|,
literal|115200
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ttcompatspeedtab
parameter_list|(
name|speed
parameter_list|,
name|table
parameter_list|)
name|int
name|speed
decl_stmt|;
specifier|register
name|struct
name|speedtab
modifier|*
name|table
decl_stmt|;
block|{
if|if
condition|(
name|speed
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* hangup */
for|for
control|(
init|;
name|table
operator|->
name|sp_speed
operator|>
literal|0
condition|;
name|table
operator|++
control|)
if|if
condition|(
name|table
operator|->
name|sp_speed
operator|<=
name|speed
condition|)
comment|/* nearest one, rounded down */
return|return
operator|(
name|table
operator|->
name|sp_code
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 50, min and not hangup */
block|}
end_function

begin_function
name|int
name|ttsetcompat
parameter_list|(
name|tp
parameter_list|,
name|com
parameter_list|,
name|data
parameter_list|,
name|term
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
modifier|*
name|com
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|struct
name|termios
modifier|*
name|term
decl_stmt|;
block|{
switch|switch
condition|(
operator|*
name|com
condition|)
block|{
case|case
name|TIOCSETP
case|:
case|case
name|TIOCSETN
case|:
block|{
specifier|register
name|struct
name|sgttyb
modifier|*
name|sg
init|=
operator|(
expr|struct
name|sgttyb
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|speed
decl_stmt|;
if|if
condition|(
operator|(
name|speed
operator|=
name|sg
operator|->
name|sg_ispeed
operator|)
operator|>
name|MAX_SPEED
operator|||
name|speed
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
elseif|else
if|if
condition|(
name|speed
operator|!=
name|ttcompatspeedtab
argument_list|(
name|tp
operator|->
name|t_ispeed
argument_list|,
name|compatspeeds
argument_list|)
condition|)
name|term
operator|->
name|c_ispeed
operator|=
name|compatspcodes
index|[
name|speed
index|]
expr_stmt|;
else|else
name|term
operator|->
name|c_ispeed
operator|=
name|tp
operator|->
name|t_ispeed
expr_stmt|;
if|if
condition|(
operator|(
name|speed
operator|=
name|sg
operator|->
name|sg_ospeed
operator|)
operator|>
name|MAX_SPEED
operator|||
name|speed
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
elseif|else
if|if
condition|(
name|speed
operator|!=
name|ttcompatspeedtab
argument_list|(
name|tp
operator|->
name|t_ospeed
argument_list|,
name|compatspeeds
argument_list|)
condition|)
name|term
operator|->
name|c_ospeed
operator|=
name|compatspcodes
index|[
name|speed
index|]
expr_stmt|;
else|else
name|term
operator|->
name|c_ospeed
operator|=
name|tp
operator|->
name|t_ospeed
expr_stmt|;
name|term
operator|->
name|c_cc
index|[
name|VERASE
index|]
operator|=
name|sg
operator|->
name|sg_erase
expr_stmt|;
name|term
operator|->
name|c_cc
index|[
name|VKILL
index|]
operator|=
name|sg
operator|->
name|sg_kill
expr_stmt|;
name|tp
operator|->
name|t_flags
operator|=
operator|(
name|tp
operator|->
name|t_flags
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|sg
operator|->
name|sg_flags
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|ttcompatsetflags
argument_list|(
name|tp
argument_list|,
name|term
argument_list|)
expr_stmt|;
operator|*
name|com
operator|=
operator|(
operator|*
name|com
operator|==
name|TIOCSETP
operator|)
condition|?
name|TIOCSETAF
else|:
name|TIOCSETA
expr_stmt|;
break|break;
block|}
case|case
name|TIOCSETC
case|:
block|{
name|struct
name|tchars
modifier|*
name|tc
init|=
operator|(
expr|struct
name|tchars
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|cc_t
modifier|*
name|cc
decl_stmt|;
name|cc
operator|=
name|term
operator|->
name|c_cc
expr_stmt|;
name|cc
index|[
name|VINTR
index|]
operator|=
name|tc
operator|->
name|t_intrc
expr_stmt|;
name|cc
index|[
name|VQUIT
index|]
operator|=
name|tc
operator|->
name|t_quitc
expr_stmt|;
name|cc
index|[
name|VSTART
index|]
operator|=
name|tc
operator|->
name|t_startc
expr_stmt|;
name|cc
index|[
name|VSTOP
index|]
operator|=
name|tc
operator|->
name|t_stopc
expr_stmt|;
name|cc
index|[
name|VEOF
index|]
operator|=
name|tc
operator|->
name|t_eofc
expr_stmt|;
name|cc
index|[
name|VEOL
index|]
operator|=
name|tc
operator|->
name|t_brkc
expr_stmt|;
if|if
condition|(
name|tc
operator|->
name|t_brkc
operator|==
operator|-
literal|1
condition|)
name|cc
index|[
name|VEOL2
index|]
operator|=
name|_POSIX_VDISABLE
expr_stmt|;
operator|*
name|com
operator|=
name|TIOCSETA
expr_stmt|;
break|break;
block|}
case|case
name|TIOCSLTC
case|:
block|{
name|struct
name|ltchars
modifier|*
name|ltc
init|=
operator|(
expr|struct
name|ltchars
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|cc_t
modifier|*
name|cc
decl_stmt|;
name|cc
operator|=
name|term
operator|->
name|c_cc
expr_stmt|;
name|cc
index|[
name|VSUSP
index|]
operator|=
name|ltc
operator|->
name|t_suspc
expr_stmt|;
name|cc
index|[
name|VDSUSP
index|]
operator|=
name|ltc
operator|->
name|t_dsuspc
expr_stmt|;
name|cc
index|[
name|VREPRINT
index|]
operator|=
name|ltc
operator|->
name|t_rprntc
expr_stmt|;
name|cc
index|[
name|VDISCARD
index|]
operator|=
name|ltc
operator|->
name|t_flushc
expr_stmt|;
name|cc
index|[
name|VWERASE
index|]
operator|=
name|ltc
operator|->
name|t_werasc
expr_stmt|;
name|cc
index|[
name|VLNEXT
index|]
operator|=
name|ltc
operator|->
name|t_lnextc
expr_stmt|;
operator|*
name|com
operator|=
name|TIOCSETA
expr_stmt|;
break|break;
block|}
case|case
name|TIOCLBIS
case|:
case|case
name|TIOCLBIC
case|:
case|case
name|TIOCLSET
case|:
if|if
condition|(
operator|*
name|com
operator|==
name|TIOCLSET
condition|)
name|tp
operator|->
name|t_flags
operator|=
operator|(
name|tp
operator|->
name|t_flags
operator|&
literal|0xffff
operator|)
operator||
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|<<
literal|16
expr_stmt|;
else|else
block|{
name|tp
operator|->
name|t_flags
operator|=
operator|(
name|ttcompatgetflags
argument_list|(
name|tp
argument_list|)
operator|&
literal|0xffff0000
operator|)
operator||
operator|(
name|tp
operator|->
name|t_flags
operator|&
literal|0xffff
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|com
operator|==
name|TIOCLBIS
condition|)
name|tp
operator|->
name|t_flags
operator||=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|<<
literal|16
expr_stmt|;
else|else
name|tp
operator|->
name|t_flags
operator|&=
operator|~
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|<<
literal|16
operator|)
expr_stmt|;
block|}
name|ttcompatsetlflags
argument_list|(
name|tp
argument_list|,
name|term
argument_list|)
expr_stmt|;
operator|*
name|com
operator|=
name|TIOCSETA
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|ttcompat
parameter_list|(
name|tp
parameter_list|,
name|com
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|com
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
switch|switch
condition|(
name|com
condition|)
block|{
case|case
name|TIOCSETP
case|:
case|case
name|TIOCSETN
case|:
case|case
name|TIOCSETC
case|:
case|case
name|TIOCSLTC
case|:
case|case
name|TIOCLBIS
case|:
case|case
name|TIOCLBIC
case|:
case|case
name|TIOCLSET
case|:
block|{
name|struct
name|termios
name|term
decl_stmt|;
name|int
name|error
decl_stmt|;
name|term
operator|=
name|tp
operator|->
name|t_termios
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ttsetcompat
argument_list|(
name|tp
argument_list|,
operator|&
name|com
argument_list|,
name|data
argument_list|,
operator|&
name|term
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
return|return
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|com
argument_list|,
operator|&
name|term
argument_list|,
name|flag
argument_list|)
return|;
block|}
case|case
name|TIOCGETP
case|:
block|{
specifier|register
name|struct
name|sgttyb
modifier|*
name|sg
init|=
operator|(
expr|struct
name|sgttyb
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|cc_t
modifier|*
name|cc
init|=
name|tp
operator|->
name|t_cc
decl_stmt|;
name|sg
operator|->
name|sg_ospeed
operator|=
name|ttcompatspeedtab
argument_list|(
name|tp
operator|->
name|t_ospeed
argument_list|,
name|compatspeeds
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_ispeed
operator|==
literal|0
condition|)
name|sg
operator|->
name|sg_ispeed
operator|=
name|sg
operator|->
name|sg_ospeed
expr_stmt|;
else|else
name|sg
operator|->
name|sg_ispeed
operator|=
name|ttcompatspeedtab
argument_list|(
name|tp
operator|->
name|t_ispeed
argument_list|,
name|compatspeeds
argument_list|)
expr_stmt|;
name|sg
operator|->
name|sg_erase
operator|=
name|cc
index|[
name|VERASE
index|]
expr_stmt|;
name|sg
operator|->
name|sg_kill
operator|=
name|cc
index|[
name|VKILL
index|]
expr_stmt|;
name|sg
operator|->
name|sg_flags
operator|=
name|tp
operator|->
name|t_flags
operator|=
name|ttcompatgetflags
argument_list|(
name|tp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TIOCGETC
case|:
block|{
name|struct
name|tchars
modifier|*
name|tc
init|=
operator|(
expr|struct
name|tchars
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|cc_t
modifier|*
name|cc
init|=
name|tp
operator|->
name|t_cc
decl_stmt|;
name|tc
operator|->
name|t_intrc
operator|=
name|cc
index|[
name|VINTR
index|]
expr_stmt|;
name|tc
operator|->
name|t_quitc
operator|=
name|cc
index|[
name|VQUIT
index|]
expr_stmt|;
name|tc
operator|->
name|t_startc
operator|=
name|cc
index|[
name|VSTART
index|]
expr_stmt|;
name|tc
operator|->
name|t_stopc
operator|=
name|cc
index|[
name|VSTOP
index|]
expr_stmt|;
name|tc
operator|->
name|t_eofc
operator|=
name|cc
index|[
name|VEOF
index|]
expr_stmt|;
name|tc
operator|->
name|t_brkc
operator|=
name|cc
index|[
name|VEOL
index|]
expr_stmt|;
break|break;
block|}
case|case
name|TIOCGLTC
case|:
block|{
name|struct
name|ltchars
modifier|*
name|ltc
init|=
operator|(
expr|struct
name|ltchars
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|cc_t
modifier|*
name|cc
init|=
name|tp
operator|->
name|t_cc
decl_stmt|;
name|ltc
operator|->
name|t_suspc
operator|=
name|cc
index|[
name|VSUSP
index|]
expr_stmt|;
name|ltc
operator|->
name|t_dsuspc
operator|=
name|cc
index|[
name|VDSUSP
index|]
expr_stmt|;
name|ltc
operator|->
name|t_rprntc
operator|=
name|cc
index|[
name|VREPRINT
index|]
expr_stmt|;
name|ltc
operator|->
name|t_flushc
operator|=
name|cc
index|[
name|VDISCARD
index|]
expr_stmt|;
name|ltc
operator|->
name|t_werasc
operator|=
name|cc
index|[
name|VWERASE
index|]
expr_stmt|;
name|ltc
operator|->
name|t_lnextc
operator|=
name|cc
index|[
name|VLNEXT
index|]
expr_stmt|;
break|break;
block|}
case|case
name|TIOCLGET
case|:
name|tp
operator|->
name|t_flags
operator|=
operator|(
name|ttcompatgetflags
argument_list|(
name|tp
argument_list|)
operator|&
literal|0xffff0000UL
operator|)
operator||
operator|(
name|tp
operator|->
name|t_flags
operator|&
literal|0xffff
operator|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|tp
operator|->
name|t_flags
operator|>>
literal|16
expr_stmt|;
if|if
condition|(
name|ttydebug
condition|)
name|printf
argument_list|(
literal|"CLGET: returning %x\n"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|OTIOCGETD
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|tp
operator|->
name|t_line
condition|?
name|tp
operator|->
name|t_line
else|:
literal|2
expr_stmt|;
break|break;
case|case
name|OTIOCSETD
case|:
block|{
name|int
name|ldisczero
init|=
literal|0
decl_stmt|;
return|return
operator|(
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|TIOCSETD
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|==
literal|2
condition|?
operator|(
name|caddr_t
operator|)
operator|&
name|ldisczero
else|:
name|data
argument_list|,
name|flag
argument_list|)
operator|)
return|;
block|}
case|case
name|OTIOCCONS
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|TIOCCONS
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|ENOIOCTL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttcompatgetflags
parameter_list|(
name|tp
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
specifier|register
name|tcflag_t
name|iflag
init|=
name|tp
operator|->
name|t_iflag
decl_stmt|;
specifier|register
name|tcflag_t
name|lflag
init|=
name|tp
operator|->
name|t_lflag
decl_stmt|;
specifier|register
name|tcflag_t
name|oflag
init|=
name|tp
operator|->
name|t_oflag
decl_stmt|;
specifier|register
name|tcflag_t
name|cflag
init|=
name|tp
operator|->
name|t_cflag
decl_stmt|;
specifier|register
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|IXOFF
condition|)
name|flags
operator||=
name|TANDEM
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|ICRNL
operator|||
name|oflag
operator|&
name|ONLCR
condition|)
name|flags
operator||=
name|CRMOD
expr_stmt|;
if|if
condition|(
operator|(
name|cflag
operator|&
name|CSIZE
operator|)
operator|==
name|CS8
condition|)
block|{
name|flags
operator||=
name|PASS8
expr_stmt|;
if|if
condition|(
name|iflag
operator|&
name|ISTRIP
condition|)
name|flags
operator||=
name|ANYP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cflag
operator|&
name|PARENB
condition|)
block|{
if|if
condition|(
name|iflag
operator|&
name|INPCK
condition|)
block|{
if|if
condition|(
name|cflag
operator|&
name|PARODD
condition|)
name|flags
operator||=
name|ODDP
expr_stmt|;
else|else
name|flags
operator||=
name|EVENP
expr_stmt|;
block|}
else|else
name|flags
operator||=
name|EVENP
operator||
name|ODDP
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lflag
operator|&
name|ICANON
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* fudge */
if|if
condition|(
name|iflag
operator|&
operator|(
name|INPCK
operator||
name|ISTRIP
operator||
name|IXON
operator|)
operator|||
name|lflag
operator|&
operator|(
name|IEXTEN
operator||
name|ISIG
operator|)
operator|||
name|cflag
operator|&
operator|(
name|CSIZE
operator||
name|PARENB
operator|)
operator|!=
name|CS8
condition|)
name|flags
operator||=
name|CBREAK
expr_stmt|;
else|else
name|flags
operator||=
name|RAW
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|RAW
operator|)
operator|&&
operator|!
operator|(
name|oflag
operator|&
name|OPOST
operator|)
operator|&&
name|cflag
operator|&
operator|(
name|CSIZE
operator||
name|PARENB
operator|)
operator|==
name|CS8
condition|)
name|flags
operator||=
name|LITOUT
expr_stmt|;
if|if
condition|(
name|cflag
operator|&
name|MDMBUF
condition|)
name|flags
operator||=
name|MDMBUF
expr_stmt|;
if|if
condition|(
operator|(
name|cflag
operator|&
name|HUPCL
operator|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|NOHANG
expr_stmt|;
if|if
condition|(
name|oflag
operator|&
name|OXTABS
condition|)
name|flags
operator||=
name|XTABS
expr_stmt|;
if|if
condition|(
name|lflag
operator|&
name|ECHOE
condition|)
name|flags
operator||=
name|CRTERA
operator||
name|CRTBS
expr_stmt|;
if|if
condition|(
name|lflag
operator|&
name|ECHOKE
condition|)
name|flags
operator||=
name|CRTKIL
operator||
name|CRTBS
expr_stmt|;
if|if
condition|(
name|lflag
operator|&
name|ECHOPRT
condition|)
name|flags
operator||=
name|PRTERA
expr_stmt|;
if|if
condition|(
name|lflag
operator|&
name|ECHOCTL
condition|)
name|flags
operator||=
name|CTLECH
expr_stmt|;
if|if
condition|(
operator|(
name|iflag
operator|&
name|IXANY
operator|)
operator|==
literal|0
condition|)
name|flags
operator||=
name|DECCTQ
expr_stmt|;
name|flags
operator||=
name|lflag
operator|&
operator|(
name|ECHO
operator||
name|TOSTOP
operator||
name|FLUSHO
operator||
name|PENDIN
operator||
name|NOFLSH
operator|)
expr_stmt|;
if|if
condition|(
name|ttydebug
condition|)
name|printf
argument_list|(
literal|"getflags: %x\n"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|flags
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ttcompatsetflags
parameter_list|(
name|tp
parameter_list|,
name|t
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|flags
operator|=
name|tp
operator|->
name|t_flags
expr_stmt|;
specifier|register
name|tcflag_t
name|iflag
init|=
name|t
operator|->
name|c_iflag
decl_stmt|;
specifier|register
name|tcflag_t
name|oflag
init|=
name|t
operator|->
name|c_oflag
decl_stmt|;
specifier|register
name|tcflag_t
name|lflag
init|=
name|t
operator|->
name|c_lflag
decl_stmt|;
specifier|register
name|tcflag_t
name|cflag
init|=
name|t
operator|->
name|c_cflag
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|RAW
condition|)
block|{
name|iflag
operator|=
name|IGNBRK
expr_stmt|;
name|lflag
operator|&=
operator|~
operator|(
name|ECHOCTL
operator||
name|ISIG
operator||
name|ICANON
operator||
name|IEXTEN
operator|)
expr_stmt|;
block|}
else|else
block|{
name|iflag
operator|&=
operator|~
operator|(
name|PARMRK
operator||
name|IGNPAR
operator||
name|IGNCR
operator||
name|INLCR
operator|)
expr_stmt|;
name|iflag
operator||=
name|BRKINT
operator||
name|IXON
operator||
name|IMAXBEL
expr_stmt|;
name|lflag
operator||=
name|ISIG
operator||
name|IEXTEN
operator||
name|ECHOCTL
expr_stmt|;
comment|/* XXX was echoctl on ? */
if|if
condition|(
name|flags
operator|&
name|XTABS
condition|)
name|oflag
operator||=
name|OXTABS
expr_stmt|;
else|else
name|oflag
operator|&=
operator|~
name|OXTABS
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CBREAK
condition|)
name|lflag
operator|&=
operator|~
name|ICANON
expr_stmt|;
else|else
name|lflag
operator||=
name|ICANON
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CRMOD
condition|)
block|{
name|iflag
operator||=
name|ICRNL
expr_stmt|;
name|oflag
operator||=
name|ONLCR
expr_stmt|;
block|}
else|else
block|{
name|iflag
operator|&=
operator|~
name|ICRNL
expr_stmt|;
name|oflag
operator|&=
operator|~
name|ONLCR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|ECHO
condition|)
name|lflag
operator||=
name|ECHO
expr_stmt|;
else|else
name|lflag
operator|&=
operator|~
name|ECHO
expr_stmt|;
name|cflag
operator|&=
operator|~
operator|(
name|CSIZE
operator||
name|PARENB
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|RAW
operator||
name|LITOUT
operator||
name|PASS8
operator|)
condition|)
block|{
name|cflag
operator||=
name|CS8
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|RAW
operator||
name|PASS8
operator|)
operator|)
operator|||
operator|(
name|flags
operator|&
operator|(
name|RAW
operator||
name|PASS8
operator||
name|ANYP
operator|)
operator|)
operator|==
operator|(
name|PASS8
operator||
name|ANYP
operator|)
condition|)
name|iflag
operator||=
name|ISTRIP
expr_stmt|;
else|else
name|iflag
operator|&=
operator|~
name|ISTRIP
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|RAW
operator||
name|LITOUT
operator|)
condition|)
name|oflag
operator|&=
operator|~
name|OPOST
expr_stmt|;
else|else
name|oflag
operator||=
name|OPOST
expr_stmt|;
block|}
else|else
block|{
name|cflag
operator||=
name|CS7
operator||
name|PARENB
expr_stmt|;
name|iflag
operator||=
name|ISTRIP
expr_stmt|;
name|oflag
operator||=
name|OPOST
expr_stmt|;
block|}
comment|/* XXX don't set INPCK if RAW or PASS8? */
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|EVENP
operator||
name|ODDP
operator|)
operator|)
operator|==
name|EVENP
condition|)
block|{
name|iflag
operator||=
name|INPCK
expr_stmt|;
name|cflag
operator|&=
operator|~
name|PARODD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|EVENP
operator||
name|ODDP
operator|)
operator|)
operator|==
name|ODDP
condition|)
block|{
name|iflag
operator||=
name|INPCK
expr_stmt|;
name|cflag
operator||=
name|PARODD
expr_stmt|;
block|}
else|else
name|iflag
operator|&=
operator|~
name|INPCK
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TANDEM
condition|)
name|iflag
operator||=
name|IXOFF
expr_stmt|;
else|else
name|iflag
operator|&=
operator|~
name|IXOFF
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DECCTQ
operator|)
operator|==
literal|0
condition|)
name|iflag
operator||=
name|IXANY
expr_stmt|;
else|else
name|iflag
operator|&=
operator|~
name|IXANY
expr_stmt|;
name|t
operator|->
name|c_iflag
operator|=
name|iflag
expr_stmt|;
name|t
operator|->
name|c_oflag
operator|=
name|oflag
expr_stmt|;
name|t
operator|->
name|c_lflag
operator|=
name|lflag
expr_stmt|;
name|t
operator|->
name|c_cflag
operator|=
name|cflag
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ttcompatsetlflags
parameter_list|(
name|tp
parameter_list|,
name|t
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|flags
operator|=
name|tp
operator|->
name|t_flags
expr_stmt|;
specifier|register
name|tcflag_t
name|iflag
init|=
name|t
operator|->
name|c_iflag
decl_stmt|;
specifier|register
name|tcflag_t
name|oflag
init|=
name|t
operator|->
name|c_oflag
decl_stmt|;
specifier|register
name|tcflag_t
name|lflag
init|=
name|t
operator|->
name|c_lflag
decl_stmt|;
specifier|register
name|tcflag_t
name|cflag
init|=
name|t
operator|->
name|c_cflag
decl_stmt|;
name|iflag
operator|&=
operator|~
operator|(
name|PARMRK
operator||
name|IGNPAR
operator||
name|IGNCR
operator||
name|INLCR
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CRTERA
condition|)
name|lflag
operator||=
name|ECHOE
expr_stmt|;
else|else
name|lflag
operator|&=
operator|~
name|ECHOE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CRTKIL
condition|)
name|lflag
operator||=
name|ECHOKE
expr_stmt|;
else|else
name|lflag
operator|&=
operator|~
name|ECHOKE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PRTERA
condition|)
name|lflag
operator||=
name|ECHOPRT
expr_stmt|;
else|else
name|lflag
operator|&=
operator|~
name|ECHOPRT
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|CTLECH
condition|)
name|lflag
operator||=
name|ECHOCTL
expr_stmt|;
else|else
name|lflag
operator|&=
operator|~
name|ECHOCTL
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|TANDEM
condition|)
name|iflag
operator||=
name|IXOFF
expr_stmt|;
else|else
name|iflag
operator|&=
operator|~
name|IXOFF
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DECCTQ
operator|)
operator|==
literal|0
condition|)
name|iflag
operator||=
name|IXANY
expr_stmt|;
else|else
name|iflag
operator|&=
operator|~
name|IXANY
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MDMBUF
condition|)
name|cflag
operator||=
name|MDMBUF
expr_stmt|;
else|else
name|cflag
operator|&=
operator|~
name|MDMBUF
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|NOHANG
condition|)
name|cflag
operator|&=
operator|~
name|HUPCL
expr_stmt|;
else|else
name|cflag
operator||=
name|HUPCL
expr_stmt|;
name|lflag
operator|&=
operator|~
operator|(
name|TOSTOP
operator||
name|FLUSHO
operator||
name|PENDIN
operator||
name|NOFLSH
operator|)
expr_stmt|;
name|lflag
operator||=
name|flags
operator|&
operator|(
name|TOSTOP
operator||
name|FLUSHO
operator||
name|PENDIN
operator||
name|NOFLSH
operator|)
expr_stmt|;
comment|/* 	 * The next if-else statement is copied from above so don't bother 	 * checking it separately.  We could avoid fiddlling with the 	 * character size if the mode is already RAW or if neither the 	 * LITOUT bit or the PASS8 bit is being changed, but the delta of 	 * the change is not available here and skipping the RAW case would 	 * make the code different from above. 	 */
name|cflag
operator|&=
operator|~
operator|(
name|CSIZE
operator||
name|PARENB
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|RAW
operator||
name|LITOUT
operator||
name|PASS8
operator|)
condition|)
block|{
name|cflag
operator||=
name|CS8
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|RAW
operator||
name|PASS8
operator|)
operator|)
operator|||
operator|(
name|flags
operator|&
operator|(
name|RAW
operator||
name|PASS8
operator||
name|ANYP
operator|)
operator|)
operator|==
operator|(
name|PASS8
operator||
name|ANYP
operator|)
condition|)
name|iflag
operator||=
name|ISTRIP
expr_stmt|;
else|else
name|iflag
operator|&=
operator|~
name|ISTRIP
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|RAW
operator||
name|LITOUT
operator|)
condition|)
name|oflag
operator|&=
operator|~
name|OPOST
expr_stmt|;
else|else
name|oflag
operator||=
name|OPOST
expr_stmt|;
block|}
else|else
block|{
name|cflag
operator||=
name|CS7
operator||
name|PARENB
expr_stmt|;
name|iflag
operator||=
name|ISTRIP
expr_stmt|;
name|oflag
operator||=
name|OPOST
expr_stmt|;
block|}
name|t
operator|->
name|c_iflag
operator|=
name|iflag
expr_stmt|;
name|t
operator|->
name|c_oflag
operator|=
name|oflag
expr_stmt|;
name|t
operator|->
name|c_lflag
operator|=
name|lflag
expr_stmt|;
name|t
operator|->
name|c_cflag
operator|=
name|cflag
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* COMPAT_43 || COMPAT_SUNOS */
end_comment

end_unit

