begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002, Jeffrey Roberson<jeff@freebsd.org>  * Copyright (c) 2008-2009, Lawrence Stewart<lstewart@freebsd.org>  * Copyright (c) 2009-2010, The FreeBSD Foundation  * All rights reserved.  *  * Portions of this software were developed at the Centre for Advanced  * Internet Architectures, Swinburne University of Technology, Melbourne,  * Australia by Lawrence Stewart under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/alq.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_comment
comment|/* Async. Logging Queue */
end_comment

begin_struct
struct|struct
name|alq
block|{
name|char
modifier|*
name|aq_entbuf
decl_stmt|;
comment|/* Buffer for stored entries */
name|int
name|aq_entmax
decl_stmt|;
comment|/* Max entries */
name|int
name|aq_entlen
decl_stmt|;
comment|/* Entry length */
name|int
name|aq_freebytes
decl_stmt|;
comment|/* Bytes available in buffer */
name|int
name|aq_buflen
decl_stmt|;
comment|/* Total length of our buffer */
name|int
name|aq_writehead
decl_stmt|;
comment|/* Location for next write */
name|int
name|aq_writetail
decl_stmt|;
comment|/* Flush starts at this location */
name|int
name|aq_wrapearly
decl_stmt|;
comment|/* # bytes left blank at end of buf */
name|int
name|aq_flags
decl_stmt|;
comment|/* Queue flags */
name|int
name|aq_waiters
decl_stmt|;
comment|/* Num threads waiting for resources 					 * NB: Used as a wait channel so must 					 * not be first field in the alq struct 					 */
name|struct
name|ale
name|aq_getpost
decl_stmt|;
comment|/* ALE for use by get/post */
name|struct
name|mtx
name|aq_mtx
decl_stmt|;
comment|/* Queue lock */
name|struct
name|vnode
modifier|*
name|aq_vp
decl_stmt|;
comment|/* Open vnode handle */
name|struct
name|ucred
modifier|*
name|aq_cred
decl_stmt|;
comment|/* Credentials of the opening thread */
name|LIST_ENTRY
argument_list|(
argument|alq
argument_list|)
name|aq_act
expr_stmt|;
comment|/* List of active queues */
name|LIST_ENTRY
argument_list|(
argument|alq
argument_list|)
name|aq_link
expr_stmt|;
comment|/* List of all queues */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|AQ_WANTED
value|0x0001
end_define

begin_comment
comment|/* Wakeup sleeper when io is done */
end_comment

begin_define
define|#
directive|define
name|AQ_ACTIVE
value|0x0002
end_define

begin_comment
comment|/* on the active list */
end_comment

begin_define
define|#
directive|define
name|AQ_FLUSHING
value|0x0004
end_define

begin_comment
comment|/* doing IO */
end_comment

begin_define
define|#
directive|define
name|AQ_SHUTDOWN
value|0x0008
end_define

begin_comment
comment|/* Queue no longer valid */
end_comment

begin_define
define|#
directive|define
name|AQ_ORDERED
value|0x0010
end_define

begin_comment
comment|/* Queue enforces ordered writes */
end_comment

begin_define
define|#
directive|define
name|AQ_LEGACY
value|0x0020
end_define

begin_comment
comment|/* Legacy queue (fixed length writes) */
end_comment

begin_define
define|#
directive|define
name|ALQ_LOCK
parameter_list|(
name|alq
parameter_list|)
value|mtx_lock_spin(&(alq)->aq_mtx)
end_define

begin_define
define|#
directive|define
name|ALQ_UNLOCK
parameter_list|(
name|alq
parameter_list|)
value|mtx_unlock_spin(&(alq)->aq_mtx)
end_define

begin_define
define|#
directive|define
name|HAS_PENDING_DATA
parameter_list|(
name|alq
parameter_list|)
value|((alq)->aq_freebytes != (alq)->aq_buflen)
end_define

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_ALD
argument_list|,
literal|"ALD"
argument_list|,
literal|"ALD"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The ald_mtx protects the ald_queues list and the ald_active list.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|ald_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|alq
argument_list|)
name|ald_queues
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|alq
argument_list|)
name|ald_active
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ald_shutingdown
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|thread
modifier|*
name|ald_thread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|ald_proc
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ALD_LOCK
parameter_list|()
value|mtx_lock(&ald_mtx)
end_define

begin_define
define|#
directive|define
name|ALD_UNLOCK
parameter_list|()
value|mtx_unlock(&ald_mtx)
end_define

begin_comment
comment|/* Daemon functions */
end_comment

begin_function_decl
specifier|static
name|int
name|ald_add
parameter_list|(
name|struct
name|alq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ald_rem
parameter_list|(
name|struct
name|alq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ald_startup
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ald_daemon
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ald_shutdown
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ald_activate
parameter_list|(
name|struct
name|alq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ald_deactivate
parameter_list|(
name|struct
name|alq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Internal queue functions */
end_comment

begin_function_decl
specifier|static
name|void
name|alq_shutdown
parameter_list|(
name|struct
name|alq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|alq_destroy
parameter_list|(
name|struct
name|alq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|alq_doio
parameter_list|(
name|struct
name|alq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Add a new queue to the global list.  Fail if we're shutting down.  */
end_comment

begin_function
specifier|static
name|int
name|ald_add
parameter_list|(
name|struct
name|alq
modifier|*
name|alq
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ALD_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|ald_shutingdown
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ald_queues
argument_list|,
name|alq
argument_list|,
name|aq_link
argument_list|)
expr_stmt|;
name|done
label|:
name|ALD_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a queue from the global list unless we're shutting down.  If so,  * the ald will take care of cleaning up it's resources.  */
end_comment

begin_function
specifier|static
name|int
name|ald_rem
parameter_list|(
name|struct
name|alq
modifier|*
name|alq
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ALD_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|ald_shutingdown
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|LIST_REMOVE
argument_list|(
name|alq
argument_list|,
name|aq_link
argument_list|)
expr_stmt|;
name|done
label|:
name|ALD_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Put a queue on the active list.  This will schedule it for writing.  */
end_comment

begin_function
specifier|static
name|void
name|ald_activate
parameter_list|(
name|struct
name|alq
modifier|*
name|alq
parameter_list|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ald_active
argument_list|,
name|alq
argument_list|,
name|aq_act
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|ald_active
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ald_deactivate
parameter_list|(
name|struct
name|alq
modifier|*
name|alq
parameter_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|alq
argument_list|,
name|aq_act
argument_list|)
expr_stmt|;
name|alq
operator|->
name|aq_flags
operator|&=
operator|~
name|AQ_ACTIVE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ald_startup
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|mtx_init
argument_list|(
operator|&
name|ald_mtx
argument_list|,
literal|"ALDmtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_QUIET
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ald_queues
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|ald_active
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ald_daemon
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|needwakeup
decl_stmt|;
name|struct
name|alq
modifier|*
name|alq
decl_stmt|;
name|ald_thread
operator|=
name|FIRST_THREAD_IN_PROC
argument_list|(
name|ald_proc
argument_list|)
expr_stmt|;
name|EVENTHANDLER_REGISTER
argument_list|(
name|shutdown_pre_sync
argument_list|,
name|ald_shutdown
argument_list|,
name|NULL
argument_list|,
name|SHUTDOWN_PRI_FIRST
argument_list|)
expr_stmt|;
name|ALD_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|(
name|alq
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ald_active
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|!
name|ald_shutingdown
condition|)
name|mtx_sleep
argument_list|(
operator|&
name|ald_active
argument_list|,
operator|&
name|ald_mtx
argument_list|,
name|PWAIT
argument_list|,
literal|"aldslp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't shutdown until all active ALQs are flushed. */
if|if
condition|(
name|ald_shutingdown
operator|&&
name|alq
operator|==
name|NULL
condition|)
block|{
name|ALD_UNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
name|ALQ_LOCK
argument_list|(
name|alq
argument_list|)
expr_stmt|;
name|ald_deactivate
argument_list|(
name|alq
argument_list|)
expr_stmt|;
name|ALD_UNLOCK
argument_list|()
expr_stmt|;
name|needwakeup
operator|=
name|alq_doio
argument_list|(
name|alq
argument_list|)
expr_stmt|;
name|ALQ_UNLOCK
argument_list|(
name|alq
argument_list|)
expr_stmt|;
if|if
condition|(
name|needwakeup
condition|)
name|wakeup_one
argument_list|(
name|alq
argument_list|)
expr_stmt|;
name|ALD_LOCK
argument_list|()
expr_stmt|;
block|}
name|kproc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ald_shutdown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|howto
parameter_list|)
block|{
name|struct
name|alq
modifier|*
name|alq
decl_stmt|;
name|ALD_LOCK
argument_list|()
expr_stmt|;
comment|/* Ensure no new queues can be created. */
name|ald_shutingdown
operator|=
literal|1
expr_stmt|;
comment|/* Shutdown all ALQs prior to terminating the ald_daemon. */
while|while
condition|(
operator|(
name|alq
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|ald_queues
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|alq
argument_list|,
name|aq_link
argument_list|)
expr_stmt|;
name|ALD_UNLOCK
argument_list|()
expr_stmt|;
name|alq_shutdown
argument_list|(
name|alq
argument_list|)
expr_stmt|;
name|ALD_LOCK
argument_list|()
expr_stmt|;
block|}
comment|/* At this point, all ALQs are flushed and shutdown. */
comment|/* 	 * Wake ald_daemon so that it exits. It won't be able to do 	 * anything until we mtx_sleep because we hold the ald_mtx. 	 */
name|wakeup
argument_list|(
operator|&
name|ald_active
argument_list|)
expr_stmt|;
comment|/* Wait for ald_daemon to exit. */
name|mtx_sleep
argument_list|(
name|ald_proc
argument_list|,
operator|&
name|ald_mtx
argument_list|,
name|PWAIT
argument_list|,
literal|"aldslp"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ALD_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|alq_shutdown
parameter_list|(
name|struct
name|alq
modifier|*
name|alq
parameter_list|)
block|{
name|ALQ_LOCK
argument_list|(
name|alq
argument_list|)
expr_stmt|;
comment|/* Stop any new writers. */
name|alq
operator|->
name|aq_flags
operator||=
name|AQ_SHUTDOWN
expr_stmt|;
comment|/* 	 * If the ALQ isn't active but has unwritten data (possible if 	 * the ALQ_NOACTIVATE flag has been used), explicitly activate the 	 * ALQ here so that the pending data gets flushed by the ald_daemon. 	 */
if|if
condition|(
operator|!
operator|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_ACTIVE
operator|)
operator|&&
name|HAS_PENDING_DATA
argument_list|(
name|alq
argument_list|)
condition|)
block|{
name|alq
operator|->
name|aq_flags
operator||=
name|AQ_ACTIVE
expr_stmt|;
name|ALQ_UNLOCK
argument_list|(
name|alq
argument_list|)
expr_stmt|;
name|ALD_LOCK
argument_list|()
expr_stmt|;
name|ald_activate
argument_list|(
name|alq
argument_list|)
expr_stmt|;
name|ALD_UNLOCK
argument_list|()
expr_stmt|;
name|ALQ_LOCK
argument_list|(
name|alq
argument_list|)
expr_stmt|;
block|}
comment|/* Drain IO */
while|while
condition|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_ACTIVE
condition|)
block|{
name|alq
operator|->
name|aq_flags
operator||=
name|AQ_WANTED
expr_stmt|;
name|msleep_spin
argument_list|(
name|alq
argument_list|,
operator|&
name|alq
operator|->
name|aq_mtx
argument_list|,
literal|"aldclose"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ALQ_UNLOCK
argument_list|(
name|alq
argument_list|)
expr_stmt|;
name|vn_close
argument_list|(
name|alq
operator|->
name|aq_vp
argument_list|,
name|FWRITE
argument_list|,
name|alq
operator|->
name|aq_cred
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|alq
operator|->
name|aq_cred
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|alq_destroy
parameter_list|(
name|struct
name|alq
modifier|*
name|alq
parameter_list|)
block|{
comment|/* Drain all pending IO. */
name|alq_shutdown
argument_list|(
name|alq
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|alq
operator|->
name|aq_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|alq
operator|->
name|aq_entbuf
argument_list|,
name|M_ALD
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|alq
argument_list|,
name|M_ALD
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush all pending data to disk.  This operation will block.  */
end_comment

begin_function
specifier|static
name|int
name|alq_doio
parameter_list|(
name|struct
name|alq
modifier|*
name|alq
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
index|[
literal|2
index|]
decl_stmt|;
name|int
name|totlen
decl_stmt|;
name|int
name|iov
decl_stmt|;
name|int
name|wrapearly
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|HAS_PENDING_DATA
argument_list|(
name|alq
argument_list|)
operator|)
argument_list|,
operator|(
literal|"%s: queue empty!"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|vp
operator|=
name|alq
operator|->
name|aq_vp
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|totlen
operator|=
literal|0
expr_stmt|;
name|iov
operator|=
literal|1
expr_stmt|;
name|wrapearly
operator|=
name|alq
operator|->
name|aq_wrapearly
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|aiov
argument_list|,
sizeof|sizeof
argument_list|(
name|aiov
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|auio
argument_list|,
sizeof|sizeof
argument_list|(
name|auio
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start the write from the location of our buffer tail pointer. */
name|aiov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
name|alq
operator|->
name|aq_entbuf
operator|+
name|alq
operator|->
name|aq_writetail
expr_stmt|;
if|if
condition|(
name|alq
operator|->
name|aq_writetail
operator|<
name|alq
operator|->
name|aq_writehead
condition|)
block|{
comment|/* Buffer not wrapped. */
name|totlen
operator|=
name|aiov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|alq
operator|->
name|aq_writehead
operator|-
name|alq
operator|->
name|aq_writetail
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alq
operator|->
name|aq_writehead
operator|==
literal|0
condition|)
block|{
comment|/* Buffer not wrapped (special case to avoid an empty iov). */
name|totlen
operator|=
name|aiov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|alq
operator|->
name|aq_buflen
operator|-
name|alq
operator|->
name|aq_writetail
operator|-
name|wrapearly
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Buffer wrapped, requires 2 aiov entries: 		 * - first is from writetail to end of buffer 		 * - second is from start of buffer to writehead 		 */
name|aiov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|alq
operator|->
name|aq_buflen
operator|-
name|alq
operator|->
name|aq_writetail
operator|-
name|wrapearly
expr_stmt|;
name|iov
operator|++
expr_stmt|;
name|aiov
index|[
literal|1
index|]
operator|.
name|iov_base
operator|=
name|alq
operator|->
name|aq_entbuf
expr_stmt|;
name|aiov
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
name|alq
operator|->
name|aq_writehead
expr_stmt|;
name|totlen
operator|=
name|aiov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|+
name|aiov
index|[
literal|1
index|]
operator|.
name|iov_len
expr_stmt|;
block|}
name|alq
operator|->
name|aq_flags
operator||=
name|AQ_FLUSHING
expr_stmt|;
name|ALQ_UNLOCK
argument_list|(
name|alq
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
index|[
literal|0
index|]
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_WRITE
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
name|iov
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|totlen
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
comment|/* 	 * Do all of the junk required to write now. 	 */
name|vn_start_write
argument_list|(
name|vp
argument_list|,
operator|&
name|mp
argument_list|,
name|V_WAIT
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: VOP_WRITE error checks are ignored. 	 */
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
name|mac_vnode_check_write
argument_list|(
name|alq
operator|->
name|aq_cred
argument_list|,
name|NOCRED
argument_list|,
name|vp
argument_list|)
operator|==
literal|0
condition|)
endif|#
directive|endif
name|VOP_WRITE
argument_list|(
name|vp
argument_list|,
operator|&
name|auio
argument_list|,
name|IO_UNIT
operator||
name|IO_APPEND
argument_list|,
name|alq
operator|->
name|aq_cred
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|ALQ_LOCK
argument_list|(
name|alq
argument_list|)
expr_stmt|;
name|alq
operator|->
name|aq_flags
operator|&=
operator|~
name|AQ_FLUSHING
expr_stmt|;
comment|/* Adjust writetail as required, taking into account wrapping. */
name|alq
operator|->
name|aq_writetail
operator|=
operator|(
name|alq
operator|->
name|aq_writetail
operator|+
name|totlen
operator|+
name|wrapearly
operator|)
operator|%
name|alq
operator|->
name|aq_buflen
expr_stmt|;
name|alq
operator|->
name|aq_freebytes
operator|+=
name|totlen
operator|+
name|wrapearly
expr_stmt|;
comment|/* 	 * If we just flushed part of the buffer which wrapped, reset the 	 * wrapearly indicator. 	 */
if|if
condition|(
name|wrapearly
condition|)
name|alq
operator|->
name|aq_wrapearly
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we just flushed the buffer completely, reset indexes to 0 to 	 * minimise buffer wraps. 	 * This is also required to ensure alq_getn() can't wedge itself. 	 */
if|if
condition|(
operator|!
name|HAS_PENDING_DATA
argument_list|(
name|alq
argument_list|)
condition|)
name|alq
operator|->
name|aq_writehead
operator|=
name|alq
operator|->
name|aq_writetail
operator|=
literal|0
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|alq
operator|->
name|aq_writetail
operator|>=
literal|0
operator|&&
name|alq
operator|->
name|aq_writetail
operator|<
name|alq
operator|->
name|aq_buflen
operator|)
argument_list|,
operator|(
literal|"%s: aq_writetail< 0 || aq_writetail>= aq_buflen"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_WANTED
condition|)
block|{
name|alq
operator|->
name|aq_flags
operator|&=
operator|~
name|AQ_WANTED
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|kproc_desc
name|ald_kp
init|=
block|{
literal|"ALQ Daemon"
block|,
name|ald_daemon
block|,
operator|&
name|ald_proc
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSINIT
argument_list|(
name|aldthread
argument_list|,
name|SI_SUB_KTHREAD_IDLE
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|kproc_start
argument_list|,
operator|&
name|ald_kp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSINIT
argument_list|(
name|ald
argument_list|,
name|SI_SUB_LOCK
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|ald_startup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* User visible queue functions */
end_comment

begin_comment
comment|/*  * Create the queue data structure, allocate the buffer, and open the file.  */
end_comment

begin_function
name|int
name|alq_open_flags
parameter_list|(
name|struct
name|alq
modifier|*
modifier|*
name|alqp
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|cmode
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|struct
name|alq
modifier|*
name|alq
decl_stmt|;
name|int
name|oflags
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|size
operator|>
literal|0
operator|)
argument_list|,
operator|(
literal|"%s: size<= 0"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
operator|*
name|alqp
operator|=
name|NULL
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|NOFOLLOW
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|file
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|oflags
operator|=
name|FWRITE
operator||
name|O_NOFOLLOW
operator||
name|O_CREAT
expr_stmt|;
name|error
operator|=
name|vn_open_cred
argument_list|(
operator|&
name|nd
argument_list|,
operator|&
name|oflags
argument_list|,
name|cmode
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
comment|/* We just unlock so we hold a reference */
name|VOP_UNLOCK
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|alq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|alq
argument_list|)
argument_list|,
name|M_ALD
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|alq
operator|->
name|aq_vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|alq
operator|->
name|aq_cred
operator|=
name|crhold
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|alq
operator|->
name|aq_mtx
argument_list|,
literal|"ALD Queue"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
operator||
name|MTX_QUIET
argument_list|)
expr_stmt|;
name|alq
operator|->
name|aq_buflen
operator|=
name|size
expr_stmt|;
name|alq
operator|->
name|aq_entmax
operator|=
literal|0
expr_stmt|;
name|alq
operator|->
name|aq_entlen
operator|=
literal|0
expr_stmt|;
name|alq
operator|->
name|aq_freebytes
operator|=
name|alq
operator|->
name|aq_buflen
expr_stmt|;
name|alq
operator|->
name|aq_entbuf
operator|=
name|malloc
argument_list|(
name|alq
operator|->
name|aq_buflen
argument_list|,
name|M_ALD
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|alq
operator|->
name|aq_writehead
operator|=
name|alq
operator|->
name|aq_writetail
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ALQ_ORDERED
condition|)
name|alq
operator|->
name|aq_flags
operator||=
name|AQ_ORDERED
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ald_add
argument_list|(
name|alq
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|alq_destroy
argument_list|(
name|alq
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|alqp
operator|=
name|alq
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|alq_open
parameter_list|(
name|struct
name|alq
modifier|*
modifier|*
name|alqp
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|cmode
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|count
operator|>=
literal|0
operator|)
argument_list|,
operator|(
literal|"%s: count< 0"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|ret
operator|=
name|alq_open_flags
argument_list|(
name|alqp
argument_list|,
name|file
argument_list|,
name|cred
argument_list|,
name|cmode
argument_list|,
name|size
operator|*
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
operator|*
name|alqp
operator|)
operator|->
name|aq_flags
operator||=
name|AQ_LEGACY
expr_stmt|;
operator|(
operator|*
name|alqp
operator|)
operator|->
name|aq_entmax
operator|=
name|count
expr_stmt|;
operator|(
operator|*
name|alqp
operator|)
operator|->
name|aq_entlen
operator|=
name|size
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|alq_open_flags
argument_list|(
name|alqp
argument_list|,
name|file
argument_list|,
name|cred
argument_list|,
name|cmode
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy a new entry into the queue.  If the operation would block either  * wait or return an error depending on the value of waitok.  */
end_comment

begin_function
name|int
name|alq_writen
parameter_list|(
name|struct
name|alq
modifier|*
name|alq
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|activate
decl_stmt|,
name|copy
decl_stmt|,
name|ret
decl_stmt|;
name|void
modifier|*
name|waitchan
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|len
operator|>
literal|0
operator|&&
name|len
operator|<=
name|alq
operator|->
name|aq_buflen
operator|)
argument_list|,
operator|(
literal|"%s: len<= 0 || len> aq_buflen"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|activate
operator|=
name|ret
operator|=
literal|0
expr_stmt|;
name|copy
operator|=
name|len
expr_stmt|;
name|waitchan
operator|=
name|NULL
expr_stmt|;
name|ALQ_LOCK
argument_list|(
name|alq
argument_list|)
expr_stmt|;
comment|/* 	 * Fail to perform the write and return EWOULDBLOCK if: 	 * - The message is larger than our underlying buffer. 	 * - The ALQ is being shutdown. 	 * - There is insufficient free space in our underlying buffer 	 *   to accept the message and the user can't wait for space. 	 * - There is insufficient free space in our underlying buffer 	 *   to accept the message and the alq is inactive due to prior 	 *   use of the ALQ_NOACTIVATE flag (which would lead to deadlock). 	 */
if|if
condition|(
name|len
operator|>
name|alq
operator|->
name|aq_buflen
operator|||
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_SHUTDOWN
operator|||
operator|(
operator|(
operator|(
name|flags
operator|&
name|ALQ_NOWAIT
operator|)
operator|||
operator|(
operator|!
operator|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_ACTIVE
operator|)
operator|&&
name|HAS_PENDING_DATA
argument_list|(
name|alq
argument_list|)
operator|)
operator|)
operator|&&
name|alq
operator|->
name|aq_freebytes
operator|<
name|len
operator|)
condition|)
block|{
name|ALQ_UNLOCK
argument_list|(
name|alq
argument_list|)
expr_stmt|;
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
block|}
comment|/* 	 * If we want ordered writes and there is already at least one thread 	 * waiting for resources to become available, sleep until we're woken. 	 */
if|if
condition|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_ORDERED
operator|&&
name|alq
operator|->
name|aq_waiters
operator|>
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|ALQ_NOWAIT
operator|)
argument_list|,
operator|(
literal|"%s: ALQ_NOWAIT set but incorrectly ignored!"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|alq
operator|->
name|aq_waiters
operator|++
expr_stmt|;
name|msleep_spin
argument_list|(
operator|&
name|alq
operator|->
name|aq_waiters
argument_list|,
operator|&
name|alq
operator|->
name|aq_mtx
argument_list|,
literal|"alqwnord"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|alq
operator|->
name|aq_waiters
operator|--
expr_stmt|;
block|}
comment|/* 	 * (ALQ_WAITOK&& aq_freebytes< len) or aq_freebytes>= len, either 	 * enter while loop and sleep until we have enough free bytes (former) 	 * or skip (latter). If AQ_ORDERED is set, only 1 thread at a time will 	 * be in this loop. Otherwise, multiple threads may be sleeping here 	 * competing for ALQ resources. 	 */
while|while
condition|(
name|alq
operator|->
name|aq_freebytes
operator|<
name|len
operator|&&
operator|!
operator|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_SHUTDOWN
operator|)
condition|)
block|{
name|KASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|ALQ_NOWAIT
operator|)
argument_list|,
operator|(
literal|"%s: ALQ_NOWAIT set but incorrectly ignored!"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|alq
operator|->
name|aq_flags
operator||=
name|AQ_WANTED
expr_stmt|;
name|alq
operator|->
name|aq_waiters
operator|++
expr_stmt|;
if|if
condition|(
name|waitchan
condition|)
name|wakeup
argument_list|(
name|waitchan
argument_list|)
expr_stmt|;
name|msleep_spin
argument_list|(
name|alq
argument_list|,
operator|&
name|alq
operator|->
name|aq_mtx
argument_list|,
literal|"alqwnres"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|alq
operator|->
name|aq_waiters
operator|--
expr_stmt|;
comment|/* 		 * If we're the first thread to wake after an AQ_WANTED wakeup 		 * but there isn't enough free space for us, we're going to loop 		 * and sleep again. If there are other threads waiting in this 		 * loop, schedule a wakeup so that they can see if the space 		 * they require is available. 		 */
if|if
condition|(
name|alq
operator|->
name|aq_waiters
operator|>
literal|0
operator|&&
operator|!
operator|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_ORDERED
operator|)
operator|&&
name|alq
operator|->
name|aq_freebytes
operator|<
name|len
operator|&&
operator|!
operator|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_WANTED
operator|)
condition|)
name|waitchan
operator|=
name|alq
expr_stmt|;
else|else
name|waitchan
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * If there are waiters, we need to signal the waiting threads after we 	 * complete our work. The alq ptr is used as a wait channel for threads 	 * requiring resources to be freed up. In the AQ_ORDERED case, threads 	 * are not allowed to concurrently compete for resources in the above 	 * while loop, so we use a different wait channel in this case. 	 */
if|if
condition|(
name|alq
operator|->
name|aq_waiters
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_ORDERED
condition|)
name|waitchan
operator|=
operator|&
name|alq
operator|->
name|aq_waiters
expr_stmt|;
else|else
name|waitchan
operator|=
name|alq
expr_stmt|;
block|}
else|else
name|waitchan
operator|=
name|NULL
expr_stmt|;
comment|/* Bail if we're shutting down. */
if|if
condition|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_SHUTDOWN
condition|)
block|{
name|ret
operator|=
name|EWOULDBLOCK
expr_stmt|;
goto|goto
name|unlock
goto|;
block|}
comment|/* 	 * If we need to wrap the buffer to accommodate the write, 	 * we'll need 2 calls to bcopy. 	 */
if|if
condition|(
operator|(
name|alq
operator|->
name|aq_buflen
operator|-
name|alq
operator|->
name|aq_writehead
operator|)
operator|<
name|len
condition|)
name|copy
operator|=
name|alq
operator|->
name|aq_buflen
operator|-
name|alq
operator|->
name|aq_writehead
expr_stmt|;
comment|/* Copy message (or part thereof if wrap required) to the buffer. */
name|bcopy
argument_list|(
name|data
argument_list|,
name|alq
operator|->
name|aq_entbuf
operator|+
name|alq
operator|->
name|aq_writehead
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|alq
operator|->
name|aq_writehead
operator|+=
name|copy
expr_stmt|;
if|if
condition|(
name|alq
operator|->
name|aq_writehead
operator|>=
name|alq
operator|->
name|aq_buflen
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|alq
operator|->
name|aq_writehead
operator|==
name|alq
operator|->
name|aq_buflen
operator|)
argument_list|,
operator|(
literal|"%s: alq->aq_writehead (%d)> alq->aq_buflen (%d)"
operator|,
name|__func__
operator|,
name|alq
operator|->
name|aq_writehead
operator|,
name|alq
operator|->
name|aq_buflen
operator|)
argument_list|)
expr_stmt|;
name|alq
operator|->
name|aq_writehead
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|copy
operator|!=
name|len
condition|)
block|{
comment|/* 		 * Wrap the buffer by copying the remainder of our message 		 * to the start of the buffer and resetting aq_writehead. 		 */
name|bcopy
argument_list|(
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|data
operator|)
operator|+
name|copy
argument_list|,
name|alq
operator|->
name|aq_entbuf
argument_list|,
name|len
operator|-
name|copy
argument_list|)
expr_stmt|;
name|alq
operator|->
name|aq_writehead
operator|=
name|len
operator|-
name|copy
expr_stmt|;
block|}
name|KASSERT
argument_list|(
operator|(
name|alq
operator|->
name|aq_writehead
operator|>=
literal|0
operator|&&
name|alq
operator|->
name|aq_writehead
operator|<
name|alq
operator|->
name|aq_buflen
operator|)
argument_list|,
operator|(
literal|"%s: aq_writehead< 0 || aq_writehead>= aq_buflen"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|alq
operator|->
name|aq_freebytes
operator|-=
name|len
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_ACTIVE
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ALQ_NOACTIVATE
operator|)
condition|)
block|{
name|alq
operator|->
name|aq_flags
operator||=
name|AQ_ACTIVE
expr_stmt|;
name|activate
operator|=
literal|1
expr_stmt|;
block|}
name|KASSERT
argument_list|(
operator|(
name|HAS_PENDING_DATA
argument_list|(
name|alq
argument_list|)
operator|)
argument_list|,
operator|(
literal|"%s: queue empty!"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|unlock
label|:
name|ALQ_UNLOCK
argument_list|(
name|alq
argument_list|)
expr_stmt|;
if|if
condition|(
name|activate
condition|)
block|{
name|ALD_LOCK
argument_list|()
expr_stmt|;
name|ald_activate
argument_list|(
name|alq
argument_list|)
expr_stmt|;
name|ALD_UNLOCK
argument_list|()
expr_stmt|;
block|}
comment|/* NB: We rely on wakeup_one waking threads in a FIFO manner. */
if|if
condition|(
name|waitchan
operator|!=
name|NULL
condition|)
name|wakeup_one
argument_list|(
name|waitchan
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|alq_write
parameter_list|(
name|struct
name|alq
modifier|*
name|alq
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
comment|/* Should only be called in fixed length message (legacy) mode. */
name|KASSERT
argument_list|(
operator|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_LEGACY
operator|)
argument_list|,
operator|(
literal|"%s: fixed length write on variable length queue"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|alq_writen
argument_list|(
name|alq
argument_list|,
name|data
argument_list|,
name|alq
operator|->
name|aq_entlen
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Retrieve a pointer for the ALQ to write directly into, avoiding bcopy.  */
end_comment

begin_function
name|struct
name|ale
modifier|*
name|alq_getn
parameter_list|(
name|struct
name|alq
modifier|*
name|alq
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|contigbytes
decl_stmt|;
name|void
modifier|*
name|waitchan
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|len
operator|>
literal|0
operator|&&
name|len
operator|<=
name|alq
operator|->
name|aq_buflen
operator|)
argument_list|,
operator|(
literal|"%s: len<= 0 || len> alq->aq_buflen"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|waitchan
operator|=
name|NULL
expr_stmt|;
name|ALQ_LOCK
argument_list|(
name|alq
argument_list|)
expr_stmt|;
comment|/* 	 * Determine the number of free contiguous bytes. 	 * We ensure elsewhere that if aq_writehead == aq_writetail because 	 * the buffer is empty, they will both be set to 0 and therefore 	 * aq_freebytes == aq_buflen and is fully contiguous. 	 * If they are equal and the buffer is not empty, aq_freebytes will 	 * be 0 indicating the buffer is full. 	 */
if|if
condition|(
name|alq
operator|->
name|aq_writehead
operator|<=
name|alq
operator|->
name|aq_writetail
condition|)
name|contigbytes
operator|=
name|alq
operator|->
name|aq_freebytes
expr_stmt|;
else|else
block|{
name|contigbytes
operator|=
name|alq
operator|->
name|aq_buflen
operator|-
name|alq
operator|->
name|aq_writehead
expr_stmt|;
if|if
condition|(
name|contigbytes
operator|<
name|len
condition|)
block|{
comment|/* 			 * Insufficient space at end of buffer to handle a 			 * contiguous write. Wrap early if there's space at 			 * the beginning. This will leave a hole at the end 			 * of the buffer which we will have to skip over when 			 * flushing the buffer to disk. 			 */
if|if
condition|(
name|alq
operator|->
name|aq_writetail
operator|>=
name|len
operator|||
name|flags
operator|&
name|ALQ_WAITOK
condition|)
block|{
comment|/* Keep track of # bytes left blank. */
name|alq
operator|->
name|aq_wrapearly
operator|=
name|contigbytes
expr_stmt|;
comment|/* Do the wrap and adjust counters. */
name|contigbytes
operator|=
name|alq
operator|->
name|aq_freebytes
operator|=
name|alq
operator|->
name|aq_writetail
expr_stmt|;
name|alq
operator|->
name|aq_writehead
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Return a NULL ALE if: 	 * - The message is larger than our underlying buffer. 	 * - The ALQ is being shutdown. 	 * - There is insufficient free space in our underlying buffer 	 *   to accept the message and the user can't wait for space. 	 * - There is insufficient free space in our underlying buffer 	 *   to accept the message and the alq is inactive due to prior 	 *   use of the ALQ_NOACTIVATE flag (which would lead to deadlock). 	 */
if|if
condition|(
name|len
operator|>
name|alq
operator|->
name|aq_buflen
operator|||
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_SHUTDOWN
operator|||
operator|(
operator|(
operator|(
name|flags
operator|&
name|ALQ_NOWAIT
operator|)
operator|||
operator|(
operator|!
operator|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_ACTIVE
operator|)
operator|&&
name|HAS_PENDING_DATA
argument_list|(
name|alq
argument_list|)
operator|)
operator|)
operator|&&
name|contigbytes
operator|<
name|len
operator|)
condition|)
block|{
name|ALQ_UNLOCK
argument_list|(
name|alq
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * If we want ordered writes and there is already at least one thread 	 * waiting for resources to become available, sleep until we're woken. 	 */
if|if
condition|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_ORDERED
operator|&&
name|alq
operator|->
name|aq_waiters
operator|>
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|ALQ_NOWAIT
operator|)
argument_list|,
operator|(
literal|"%s: ALQ_NOWAIT set but incorrectly ignored!"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|alq
operator|->
name|aq_waiters
operator|++
expr_stmt|;
name|msleep_spin
argument_list|(
operator|&
name|alq
operator|->
name|aq_waiters
argument_list|,
operator|&
name|alq
operator|->
name|aq_mtx
argument_list|,
literal|"alqgnord"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|alq
operator|->
name|aq_waiters
operator|--
expr_stmt|;
block|}
comment|/* 	 * (ALQ_WAITOK&& contigbytes< len) or contigbytes>= len, either enter 	 * while loop and sleep until we have enough contiguous free bytes 	 * (former) or skip (latter). If AQ_ORDERED is set, only 1 thread at a 	 * time will be in this loop. Otherwise, multiple threads may be 	 * sleeping here competing for ALQ resources. 	 */
while|while
condition|(
name|contigbytes
operator|<
name|len
operator|&&
operator|!
operator|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_SHUTDOWN
operator|)
condition|)
block|{
name|KASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|ALQ_NOWAIT
operator|)
argument_list|,
operator|(
literal|"%s: ALQ_NOWAIT set but incorrectly ignored!"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|alq
operator|->
name|aq_flags
operator||=
name|AQ_WANTED
expr_stmt|;
name|alq
operator|->
name|aq_waiters
operator|++
expr_stmt|;
if|if
condition|(
name|waitchan
condition|)
name|wakeup
argument_list|(
name|waitchan
argument_list|)
expr_stmt|;
name|msleep_spin
argument_list|(
name|alq
argument_list|,
operator|&
name|alq
operator|->
name|aq_mtx
argument_list|,
literal|"alqgnres"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|alq
operator|->
name|aq_waiters
operator|--
expr_stmt|;
if|if
condition|(
name|alq
operator|->
name|aq_writehead
operator|<=
name|alq
operator|->
name|aq_writetail
condition|)
name|contigbytes
operator|=
name|alq
operator|->
name|aq_freebytes
expr_stmt|;
else|else
name|contigbytes
operator|=
name|alq
operator|->
name|aq_buflen
operator|-
name|alq
operator|->
name|aq_writehead
expr_stmt|;
comment|/* 		 * If we're the first thread to wake after an AQ_WANTED wakeup 		 * but there isn't enough free space for us, we're going to loop 		 * and sleep again. If there are other threads waiting in this 		 * loop, schedule a wakeup so that they can see if the space 		 * they require is available. 		 */
if|if
condition|(
name|alq
operator|->
name|aq_waiters
operator|>
literal|0
operator|&&
operator|!
operator|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_ORDERED
operator|)
operator|&&
name|contigbytes
operator|<
name|len
operator|&&
operator|!
operator|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_WANTED
operator|)
condition|)
name|waitchan
operator|=
name|alq
expr_stmt|;
else|else
name|waitchan
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * If there are waiters, we need to signal the waiting threads after we 	 * complete our work. The alq ptr is used as a wait channel for threads 	 * requiring resources to be freed up. In the AQ_ORDERED case, threads 	 * are not allowed to concurrently compete for resources in the above 	 * while loop, so we use a different wait channel in this case. 	 */
if|if
condition|(
name|alq
operator|->
name|aq_waiters
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_ORDERED
condition|)
name|waitchan
operator|=
operator|&
name|alq
operator|->
name|aq_waiters
expr_stmt|;
else|else
name|waitchan
operator|=
name|alq
expr_stmt|;
block|}
else|else
name|waitchan
operator|=
name|NULL
expr_stmt|;
comment|/* Bail if we're shutting down. */
if|if
condition|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_SHUTDOWN
condition|)
block|{
name|ALQ_UNLOCK
argument_list|(
name|alq
argument_list|)
expr_stmt|;
if|if
condition|(
name|waitchan
operator|!=
name|NULL
condition|)
name|wakeup_one
argument_list|(
name|waitchan
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * If we are here, we have a contiguous number of bytes>= len 	 * available in our buffer starting at aq_writehead. 	 */
name|alq
operator|->
name|aq_getpost
operator|.
name|ae_data
operator|=
name|alq
operator|->
name|aq_entbuf
operator|+
name|alq
operator|->
name|aq_writehead
expr_stmt|;
name|alq
operator|->
name|aq_getpost
operator|.
name|ae_bytesused
operator|=
name|len
expr_stmt|;
return|return
operator|(
operator|&
name|alq
operator|->
name|aq_getpost
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|ale
modifier|*
name|alq_get
parameter_list|(
name|struct
name|alq
modifier|*
name|alq
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
comment|/* Should only be called in fixed length message (legacy) mode. */
name|KASSERT
argument_list|(
operator|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_LEGACY
operator|)
argument_list|,
operator|(
literal|"%s: fixed length get on variable length queue"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|alq_getn
argument_list|(
name|alq
argument_list|,
name|alq
operator|->
name|aq_entlen
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|alq_post_flags
parameter_list|(
name|struct
name|alq
modifier|*
name|alq
parameter_list|,
name|struct
name|ale
modifier|*
name|ale
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|activate
decl_stmt|;
name|void
modifier|*
name|waitchan
decl_stmt|;
name|activate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ale
operator|->
name|ae_bytesused
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_ACTIVE
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ALQ_NOACTIVATE
operator|)
condition|)
block|{
name|alq
operator|->
name|aq_flags
operator||=
name|AQ_ACTIVE
expr_stmt|;
name|activate
operator|=
literal|1
expr_stmt|;
block|}
name|alq
operator|->
name|aq_writehead
operator|+=
name|ale
operator|->
name|ae_bytesused
expr_stmt|;
name|alq
operator|->
name|aq_freebytes
operator|-=
name|ale
operator|->
name|ae_bytesused
expr_stmt|;
comment|/* Wrap aq_writehead if we filled to the end of the buffer. */
if|if
condition|(
name|alq
operator|->
name|aq_writehead
operator|==
name|alq
operator|->
name|aq_buflen
condition|)
name|alq
operator|->
name|aq_writehead
operator|=
literal|0
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|alq
operator|->
name|aq_writehead
operator|>=
literal|0
operator|&&
name|alq
operator|->
name|aq_writehead
operator|<
name|alq
operator|->
name|aq_buflen
operator|)
argument_list|,
operator|(
literal|"%s: aq_writehead< 0 || aq_writehead>= aq_buflen"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|HAS_PENDING_DATA
argument_list|(
name|alq
argument_list|)
operator|)
argument_list|,
operator|(
literal|"%s: queue empty!"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there are waiters, we need to signal the waiting threads after we 	 * complete our work. The alq ptr is used as a wait channel for threads 	 * requiring resources to be freed up. In the AQ_ORDERED case, threads 	 * are not allowed to concurrently compete for resources in the 	 * alq_getn() while loop, so we use a different wait channel in this case. 	 */
if|if
condition|(
name|alq
operator|->
name|aq_waiters
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_ORDERED
condition|)
name|waitchan
operator|=
operator|&
name|alq
operator|->
name|aq_waiters
expr_stmt|;
else|else
name|waitchan
operator|=
name|alq
expr_stmt|;
block|}
else|else
name|waitchan
operator|=
name|NULL
expr_stmt|;
name|ALQ_UNLOCK
argument_list|(
name|alq
argument_list|)
expr_stmt|;
if|if
condition|(
name|activate
condition|)
block|{
name|ALD_LOCK
argument_list|()
expr_stmt|;
name|ald_activate
argument_list|(
name|alq
argument_list|)
expr_stmt|;
name|ALD_UNLOCK
argument_list|()
expr_stmt|;
block|}
comment|/* NB: We rely on wakeup_one waking threads in a FIFO manner. */
if|if
condition|(
name|waitchan
operator|!=
name|NULL
condition|)
name|wakeup_one
argument_list|(
name|waitchan
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|alq_flush
parameter_list|(
name|struct
name|alq
modifier|*
name|alq
parameter_list|)
block|{
name|int
name|needwakeup
init|=
literal|0
decl_stmt|;
name|ALD_LOCK
argument_list|()
expr_stmt|;
name|ALQ_LOCK
argument_list|(
name|alq
argument_list|)
expr_stmt|;
comment|/* 	 * Pull the lever iff there is data to flush and we're 	 * not already in the middle of a flush operation. 	 */
if|if
condition|(
name|HAS_PENDING_DATA
argument_list|(
name|alq
argument_list|)
operator|&&
operator|!
operator|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_FLUSHING
operator|)
condition|)
block|{
if|if
condition|(
name|alq
operator|->
name|aq_flags
operator|&
name|AQ_ACTIVE
condition|)
name|ald_deactivate
argument_list|(
name|alq
argument_list|)
expr_stmt|;
name|ALD_UNLOCK
argument_list|()
expr_stmt|;
name|needwakeup
operator|=
name|alq_doio
argument_list|(
name|alq
argument_list|)
expr_stmt|;
block|}
else|else
name|ALD_UNLOCK
argument_list|()
expr_stmt|;
name|ALQ_UNLOCK
argument_list|(
name|alq
argument_list|)
expr_stmt|;
if|if
condition|(
name|needwakeup
condition|)
name|wakeup_one
argument_list|(
name|alq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush remaining data, close the file and free all resources.  */
end_comment

begin_function
name|void
name|alq_close
parameter_list|(
name|struct
name|alq
modifier|*
name|alq
parameter_list|)
block|{
comment|/* Only flush and destroy alq if not already shutting down. */
if|if
condition|(
name|ald_rem
argument_list|(
name|alq
argument_list|)
operator|==
literal|0
condition|)
name|alq_destroy
argument_list|(
name|alq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|alq_load_handler
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|MOD_LOAD
case|:
case|case
name|MOD_SHUTDOWN
case|:
break|break;
case|case
name|MOD_QUIESCE
case|:
name|ALD_LOCK
argument_list|()
expr_stmt|;
comment|/* Only allow unload if there are no open queues. */
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|ald_queues
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ald_shutingdown
operator|=
literal|1
expr_stmt|;
name|ALD_UNLOCK
argument_list|()
expr_stmt|;
name|ald_shutdown
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ald_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ALD_UNLOCK
argument_list|()
expr_stmt|;
name|ret
operator|=
name|EBUSY
expr_stmt|;
block|}
break|break;
case|case
name|MOD_UNLOAD
case|:
comment|/* If MOD_QUIESCE failed we must fail here too. */
if|if
condition|(
name|ald_shutingdown
operator|==
literal|0
condition|)
name|ret
operator|=
name|EBUSY
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|alq_mod
init|=
block|{
literal|"alq"
block|,
name|alq_load_handler
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|alq
argument_list|,
name|alq_mod
argument_list|,
name|SI_SUB_SMP
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|alq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

