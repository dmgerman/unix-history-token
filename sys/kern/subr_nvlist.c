begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2013 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Pawel Jakub Dawidek under sponsorship from  * the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_define
define|#
directive|define
name|_WITH_DPRINTF
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"msgio.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PJDLOG
end_ifdef

begin_include
include|#
directive|include
file|<pjdlog.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/nv.h>
end_include

begin_include
include|#
directive|include
file|<sys/nv_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/nvlist_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/nvpair_impl.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_PJDLOG
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_define
define|#
directive|define
name|PJDLOG_ASSERT
parameter_list|(
modifier|...
parameter_list|)
value|MPASS(__VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|PJDLOG_RASSERT
parameter_list|(
name|expr
parameter_list|,
modifier|...
parameter_list|)
value|KASSERT(expr, (__VA_ARGS__))
end_define

begin_define
define|#
directive|define
name|PJDLOG_ABORT
parameter_list|(
modifier|...
parameter_list|)
value|panic(__VA_ARGS__)
end_define

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_define
define|#
directive|define
name|PJDLOG_ASSERT
parameter_list|(
modifier|...
parameter_list|)
value|assert(__VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|PJDLOG_RASSERT
parameter_list|(
name|expr
parameter_list|,
modifier|...
parameter_list|)
value|assert(expr)
end_define

begin_define
define|#
directive|define
name|PJDLOG_ABORT
parameter_list|(
modifier|...
parameter_list|)
value|do {				\ 	fprintf(stderr, "%s:%u: ", __FILE__, __LINE__);			\ 	fprintf(stderr, __VA_ARGS__);					\ 	fprintf(stderr, "\n");						\ 	abort();							\ } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NV_FLAG_PRIVATE_MASK
value|(NV_FLAG_BIG_ENDIAN)
end_define

begin_define
define|#
directive|define
name|NV_FLAG_PUBLIC_MASK
value|(NV_FLAG_IGNORE_CASE)
end_define

begin_define
define|#
directive|define
name|NV_FLAG_ALL_MASK
value|(NV_FLAG_PRIVATE_MASK | NV_FLAG_PUBLIC_MASK)
end_define

begin_define
define|#
directive|define
name|NVLIST_MAGIC
value|0x6e766c
end_define

begin_comment
comment|/* "nvl" */
end_comment

begin_struct
struct|struct
name|nvlist
block|{
name|int
name|nvl_magic
decl_stmt|;
name|int
name|nvl_error
decl_stmt|;
name|int
name|nvl_flags
decl_stmt|;
name|nvpair_t
modifier|*
name|nvl_parent
decl_stmt|;
name|struct
name|nvl_head
name|nvl_head
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NVLIST_ASSERT
parameter_list|(
name|nvl
parameter_list|)
value|do {					\ 	PJDLOG_ASSERT((nvl) != NULL);					\ 	PJDLOG_ASSERT((nvl)->nvl_magic == NVLIST_MAGIC);		\ } while (0)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NVLIST
argument_list|,
literal|"nvlist"
argument_list|,
literal|"kernel nvlist"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NVPAIR_ASSERT
parameter_list|(
name|nvp
parameter_list|)
value|nvpair_assert(nvp)
end_define

begin_define
define|#
directive|define
name|NVLIST_HEADER_MAGIC
value|0x6c
end_define

begin_define
define|#
directive|define
name|NVLIST_HEADER_VERSION
value|0x00
end_define

begin_struct
struct|struct
name|nvlist_header
block|{
name|uint8_t
name|nvlh_magic
decl_stmt|;
name|uint8_t
name|nvlh_version
decl_stmt|;
name|uint8_t
name|nvlh_flags
decl_stmt|;
name|uint64_t
name|nvlh_descriptors
decl_stmt|;
name|uint64_t
name|nvlh_size
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_function
name|nvlist_t
modifier|*
name|nvlist_create
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvl
decl_stmt|;
name|PJDLOG_ASSERT
argument_list|(
operator|(
name|flags
operator|&
operator|~
operator|(
name|NV_FLAG_PUBLIC_MASK
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nvl
operator|=
name|nv_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nvl
argument_list|)
argument_list|)
expr_stmt|;
name|nvl
operator|->
name|nvl_error
operator|=
literal|0
expr_stmt|;
name|nvl
operator|->
name|nvl_flags
operator|=
name|flags
expr_stmt|;
name|nvl
operator|->
name|nvl_parent
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|nvl
operator|->
name|nvl_head
argument_list|)
expr_stmt|;
name|nvl
operator|->
name|nvl_magic
operator|=
name|NVLIST_MAGIC
expr_stmt|;
return|return
operator|(
name|nvl
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nvlist_destroy
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvl
operator|==
name|NULL
condition|)
return|return;
name|ERRNO_SAVE
argument_list|()
expr_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|nvp
operator|=
name|nvlist_first_nvpair
argument_list|(
name|nvl
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|nvlist_remove_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
name|nvpair_free
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
block|}
name|nvl
operator|->
name|nvl_magic
operator|=
literal|0
expr_stmt|;
name|nv_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|ERRNO_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_set_error
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|PJDLOG_ASSERT
argument_list|(
name|error
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Check for error != 0 so that we don't do the wrong thing if somebody 	 * tries to abuse this API when asserts are disabled. 	 */
if|if
condition|(
name|nvl
operator|!=
name|NULL
operator|&&
name|error
operator|!=
literal|0
operator|&&
name|nvl
operator|->
name|nvl_error
operator|==
literal|0
condition|)
name|nvl
operator|->
name|nvl_error
operator|=
name|error
expr_stmt|;
block|}
end_function

begin_function
name|int
name|nvlist_error
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
if|if
condition|(
name|nvl
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|nvl
operator|->
name|nvl_error
operator|)
return|;
block|}
end_function

begin_function
name|nvpair_t
modifier|*
name|nvlist_get_nvpair_parent
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|nvl
operator|->
name|nvl_parent
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|nvlist_t
modifier|*
name|nvlist_get_parent
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|nvp
operator|=
name|nvl
operator|->
name|nvl_parent
expr_stmt|;
if|if
condition|(
name|cookiep
operator|!=
name|NULL
condition|)
operator|*
name|cookiep
operator|=
name|nvp
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|nvpair_nvlist
argument_list|(
name|nvp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nvlist_set_parent
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|nvpair_t
modifier|*
name|parent
parameter_list|)
block|{
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|nvl
operator|->
name|nvl_parent
operator|=
name|parent
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|nvlist_empty
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvl
operator|->
name|nvl_error
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|nvlist_first_nvpair
argument_list|(
name|nvl
argument_list|)
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nvlist_report_missing
parameter_list|(
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|PJDLOG_ABORT
argument_list|(
literal|"Element '%s' of type %s doesn't exist."
argument_list|,
name|name
argument_list|,
name|nvpair_type_string
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|nvpair_t
modifier|*
name|nvlist_find
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvl
operator|->
name|nvl_error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|type
operator|==
name|NV_TYPE_NONE
operator|||
operator|(
name|type
operator|>=
name|NV_TYPE_FIRST
operator|&&
name|type
operator|<=
name|NV_TYPE_LAST
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|nvp
operator|=
name|nvlist_first_nvpair
argument_list|(
name|nvl
argument_list|)
init|;
name|nvp
operator|!=
name|NULL
condition|;
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
control|)
block|{
if|if
condition|(
name|type
operator|!=
name|NV_TYPE_NONE
operator|&&
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
operator|!=
name|type
condition|)
continue|continue;
if|if
condition|(
operator|(
name|nvl
operator|->
name|nvl_flags
operator|&
name|NV_FLAG_IGNORE_CASE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
name|ERRNO_SET
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
return|return
operator|(
name|nvp
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|nvlist_exists_type
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvl
operator|->
name|nvl_error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|type
operator|==
name|NV_TYPE_NONE
operator|||
operator|(
name|type
operator|>=
name|NV_TYPE_FIRST
operator|&&
name|type
operator|<=
name|NV_TYPE_LAST
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|nvlist_find
argument_list|(
name|nvl
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nvlist_free_type
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvl
operator|->
name|nvl_error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|type
operator|==
name|NV_TYPE_NONE
operator|||
operator|(
name|type
operator|>=
name|NV_TYPE_FIRST
operator|&&
name|type
operator|<=
name|NV_TYPE_LAST
operator|)
argument_list|)
expr_stmt|;
name|nvp
operator|=
name|nvlist_find
argument_list|(
name|nvl
argument_list|,
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|!=
name|NULL
condition|)
name|nvlist_free_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
else|else
name|nvlist_report_missing
argument_list|(
name|type
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|nvlist_t
modifier|*
name|nvlist_clone
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|newnvl
decl_stmt|;
name|nvpair_t
modifier|*
name|nvp
decl_stmt|,
modifier|*
name|newnvp
decl_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvl
operator|->
name|nvl_error
operator|!=
literal|0
condition|)
block|{
name|ERRNO_SET
argument_list|(
name|nvl
operator|->
name|nvl_error
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|newnvl
operator|=
name|nvlist_create
argument_list|(
name|nvl
operator|->
name|nvl_flags
operator|&
name|NV_FLAG_PUBLIC_MASK
argument_list|)
expr_stmt|;
for|for
control|(
name|nvp
operator|=
name|nvlist_first_nvpair
argument_list|(
name|nvl
argument_list|)
init|;
name|nvp
operator|!=
name|NULL
condition|;
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
control|)
block|{
name|newnvp
operator|=
name|nvpair_clone
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|newnvp
operator|==
name|NULL
condition|)
break|break;
name|nvlist_move_nvpair
argument_list|(
name|newnvl
argument_list|,
name|newnvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nvp
operator|!=
name|NULL
condition|)
block|{
name|nvlist_destroy
argument_list|(
name|newnvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|newnvl
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_function
specifier|static
name|bool
name|nvlist_dump_error_check
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|level
parameter_list|)
block|{
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dprintf
argument_list|(
name|fd
argument_list|,
literal|"%*serror: %d\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dump content of nvlist.  */
end_comment

begin_function
name|void
name|nvlist_dump
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
specifier|const
name|nvlist_t
modifier|*
name|tmpnvl
decl_stmt|;
name|nvpair_t
modifier|*
name|nvp
decl_stmt|,
modifier|*
name|tmpnvp
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|int
name|level
decl_stmt|;
name|level
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nvlist_dump_error_check
argument_list|(
name|nvl
argument_list|,
name|fd
argument_list|,
name|level
argument_list|)
condition|)
return|return;
name|nvp
operator|=
name|nvlist_first_nvpair
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
while|while
condition|(
name|nvp
operator|!=
name|NULL
condition|)
block|{
name|dprintf
argument_list|(
name|fd
argument_list|,
literal|"%*s%s (%s):"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|nvpair_type_string
argument_list|(
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
condition|)
block|{
case|case
name|NV_TYPE_NULL
case|:
name|dprintf
argument_list|(
name|fd
argument_list|,
literal|" null\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NV_TYPE_BOOL
case|:
name|dprintf
argument_list|(
name|fd
argument_list|,
literal|" %s\n"
argument_list|,
name|nvpair_get_bool
argument_list|(
name|nvp
argument_list|)
condition|?
literal|"TRUE"
else|:
literal|"FALSE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NV_TYPE_NUMBER
case|:
name|dprintf
argument_list|(
name|fd
argument_list|,
literal|" %ju (%jd) (0x%jx)\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|nvpair_get_number
argument_list|(
name|nvp
argument_list|)
argument_list|,
operator|(
name|intmax_t
operator|)
name|nvpair_get_number
argument_list|(
name|nvp
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|nvpair_get_number
argument_list|(
name|nvp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NV_TYPE_STRING
case|:
name|dprintf
argument_list|(
name|fd
argument_list|,
literal|" [%s]\n"
argument_list|,
name|nvpair_get_string
argument_list|(
name|nvp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NV_TYPE_NVLIST
case|:
name|dprintf
argument_list|(
name|fd
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|tmpnvl
operator|=
name|nvpair_get_nvlist
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_dump_error_check
argument_list|(
name|tmpnvl
argument_list|,
name|fd
argument_list|,
name|level
operator|+
literal|1
argument_list|)
condition|)
break|break;
name|tmpnvp
operator|=
name|nvlist_first_nvpair
argument_list|(
name|tmpnvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpnvp
operator|!=
name|NULL
condition|)
block|{
name|nvl
operator|=
name|tmpnvl
expr_stmt|;
name|nvp
operator|=
name|tmpnvp
expr_stmt|;
name|level
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|NV_TYPE_DESCRIPTOR
case|:
name|dprintf
argument_list|(
name|fd
argument_list|,
literal|" %d\n"
argument_list|,
name|nvpair_get_descriptor
argument_list|(
name|nvp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NV_TYPE_BINARY
case|:
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|binary
decl_stmt|;
name|unsigned
name|int
name|ii
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|binary
operator|=
name|nvpair_get_binary
argument_list|(
name|nvp
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
name|fd
argument_list|,
literal|" %zu "
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|size
condition|;
name|ii
operator|++
control|)
name|dprintf
argument_list|(
name|fd
argument_list|,
literal|"%02hhx"
argument_list|,
name|binary
index|[
name|ii
index|]
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
name|fd
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|PJDLOG_ABORT
argument_list|(
literal|"Unknown type: %d."
argument_list|,
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|cookie
operator|=
name|NULL
expr_stmt|;
name|nvl
operator|=
name|nvlist_get_parent
argument_list|(
name|nvl
argument_list|,
operator|&
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvl
operator|==
name|NULL
condition|)
return|return;
name|nvp
operator|=
name|cookie
expr_stmt|;
name|level
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|nvlist_fdump
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|nvlist_dump
argument_list|(
name|nvl
argument_list|,
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The function obtains size of the nvlist after nvlist_pack().  */
end_comment

begin_function
name|size_t
name|nvlist_size
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
specifier|const
name|nvlist_t
modifier|*
name|tmpnvl
decl_stmt|;
specifier|const
name|nvpair_t
modifier|*
name|nvp
decl_stmt|,
modifier|*
name|tmpnvp
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvl
operator|->
name|nvl_error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|nvlist_header
argument_list|)
expr_stmt|;
name|nvp
operator|=
name|nvlist_first_nvpair
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
while|while
condition|(
name|nvp
operator|!=
name|NULL
condition|)
block|{
name|size
operator|+=
name|nvpair_header_size
argument_list|()
expr_stmt|;
name|size
operator|+=
name|strlen
argument_list|(
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
operator|==
name|NV_TYPE_NVLIST
condition|)
block|{
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|nvlist_header
argument_list|)
expr_stmt|;
name|size
operator|+=
name|nvpair_header_size
argument_list|()
operator|+
literal|1
expr_stmt|;
name|tmpnvl
operator|=
name|nvpair_get_nvlist
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|tmpnvl
operator|->
name|nvl_error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tmpnvp
operator|=
name|nvlist_first_nvpair
argument_list|(
name|tmpnvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpnvp
operator|!=
name|NULL
condition|)
block|{
name|nvl
operator|=
name|tmpnvl
expr_stmt|;
name|nvp
operator|=
name|tmpnvp
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|size
operator|+=
name|nvpair_size
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|cookie
operator|=
name|NULL
expr_stmt|;
name|nvl
operator|=
name|nvlist_get_parent
argument_list|(
name|nvl
argument_list|,
operator|&
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvl
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|nvp
operator|=
name|cookie
expr_stmt|;
block|}
block|}
name|out
label|:
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_function
specifier|static
name|int
modifier|*
name|nvlist_xdescriptors
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
modifier|*
name|descs
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvl
operator|->
name|nvl_error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nvp
operator|=
name|NULL
expr_stmt|;
do|do
block|{
while|while
condition|(
operator|(
name|name
operator|=
name|nvlist_next
argument_list|(
name|nvl
argument_list|,
operator|&
name|type
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|nvp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|NV_TYPE_DESCRIPTOR
case|:
operator|*
name|descs
operator|=
name|nvpair_get_descriptor
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|descs
operator|++
expr_stmt|;
break|break;
case|case
name|NV_TYPE_NVLIST
case|:
name|nvl
operator|=
name|nvpair_get_nvlist
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|nvp
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|nvl
operator|=
name|nvlist_get_parent
argument_list|(
name|nvl
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|nvp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|;
return|return
operator|(
name|descs
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_function
name|int
modifier|*
name|nvlist_descriptors
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|size_t
modifier|*
name|nitemsp
parameter_list|)
block|{
name|size_t
name|nitems
decl_stmt|;
name|int
modifier|*
name|fds
decl_stmt|;
name|nitems
operator|=
name|nvlist_ndescriptors
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|fds
operator|=
name|nv_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|)
operator|*
operator|(
name|nitems
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fds
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|nitems
operator|>
literal|0
condition|)
name|nvlist_xdescriptors
argument_list|(
name|nvl
argument_list|,
name|fds
argument_list|)
expr_stmt|;
name|fds
index|[
name|nitems
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nitemsp
operator|!=
name|NULL
condition|)
operator|*
name|nitemsp
operator|=
name|nitems
expr_stmt|;
return|return
operator|(
name|fds
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|size_t
name|nvlist_ndescriptors
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|_KERNEL
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|size_t
name|ndescs
decl_stmt|;
name|int
name|type
decl_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvl
operator|->
name|nvl_error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ndescs
operator|=
literal|0
expr_stmt|;
name|nvp
operator|=
name|NULL
expr_stmt|;
do|do
block|{
while|while
condition|(
operator|(
name|name
operator|=
name|nvlist_next
argument_list|(
name|nvl
argument_list|,
operator|&
name|type
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|nvp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|NV_TYPE_DESCRIPTOR
case|:
name|ndescs
operator|++
expr_stmt|;
break|break;
case|case
name|NV_TYPE_NVLIST
case|:
name|nvl
operator|=
name|nvpair_get_nvlist
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|nvp
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
operator|(
name|nvl
operator|=
name|nvlist_get_parent
argument_list|(
name|nvl
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|nvp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
do|;
return|return
operator|(
name|ndescs
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|nvlist_pack_header
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|,
name|size_t
modifier|*
name|leftp
parameter_list|)
block|{
name|struct
name|nvlist_header
name|nvlhdr
decl_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|nvlhdr
operator|.
name|nvlh_magic
operator|=
name|NVLIST_HEADER_MAGIC
expr_stmt|;
name|nvlhdr
operator|.
name|nvlh_version
operator|=
name|NVLIST_HEADER_VERSION
expr_stmt|;
name|nvlhdr
operator|.
name|nvlh_flags
operator|=
name|nvl
operator|->
name|nvl_flags
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|nvlhdr
operator|.
name|nvlh_flags
operator||=
name|NV_FLAG_BIG_ENDIAN
expr_stmt|;
endif|#
directive|endif
name|nvlhdr
operator|.
name|nvlh_descriptors
operator|=
name|nvlist_ndescriptors
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|nvlhdr
operator|.
name|nvlh_size
operator|=
operator|*
name|leftp
operator|-
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
operator|*
name|leftp
operator|>=
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|nvlhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
expr_stmt|;
operator|*
name|leftp
operator|-=
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|nvlist_xpack
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int64_t
modifier|*
name|fdidxp
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|left
decl_stmt|,
name|size
decl_stmt|;
specifier|const
name|nvlist_t
modifier|*
name|tmpnvl
decl_stmt|;
name|nvpair_t
modifier|*
name|nvp
decl_stmt|,
modifier|*
name|tmpnvp
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvl
operator|->
name|nvl_error
operator|!=
literal|0
condition|)
block|{
name|ERRNO_SET
argument_list|(
name|nvl
operator|->
name|nvl_error
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|size
operator|=
name|nvlist_size
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|buf
operator|=
name|nv_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ptr
operator|=
name|buf
expr_stmt|;
name|left
operator|=
name|size
expr_stmt|;
name|ptr
operator|=
name|nvlist_pack_header
argument_list|(
name|nvl
argument_list|,
name|ptr
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
name|nvp
operator|=
name|nvlist_first_nvpair
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
while|while
condition|(
name|nvp
operator|!=
name|NULL
condition|)
block|{
name|NVPAIR_ASSERT
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|nvpair_init_datasize
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|nvpair_pack_header
argument_list|(
name|nvp
argument_list|,
name|ptr
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|nv_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
switch|switch
condition|(
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
condition|)
block|{
case|case
name|NV_TYPE_NULL
case|:
name|ptr
operator|=
name|nvpair_pack_null
argument_list|(
name|nvp
argument_list|,
name|ptr
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
break|break;
case|case
name|NV_TYPE_BOOL
case|:
name|ptr
operator|=
name|nvpair_pack_bool
argument_list|(
name|nvp
argument_list|,
name|ptr
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
break|break;
case|case
name|NV_TYPE_NUMBER
case|:
name|ptr
operator|=
name|nvpair_pack_number
argument_list|(
name|nvp
argument_list|,
name|ptr
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
break|break;
case|case
name|NV_TYPE_STRING
case|:
name|ptr
operator|=
name|nvpair_pack_string
argument_list|(
name|nvp
argument_list|,
name|ptr
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
break|break;
case|case
name|NV_TYPE_NVLIST
case|:
name|tmpnvl
operator|=
name|nvpair_get_nvlist
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|nvlist_pack_header
argument_list|(
name|tmpnvl
argument_list|,
name|ptr
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|tmpnvp
operator|=
name|nvlist_first_nvpair
argument_list|(
name|tmpnvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpnvp
operator|!=
name|NULL
condition|)
block|{
name|nvl
operator|=
name|tmpnvl
expr_stmt|;
name|nvp
operator|=
name|tmpnvp
expr_stmt|;
continue|continue;
block|}
name|ptr
operator|=
name|nvpair_pack_nvlist_up
argument_list|(
name|ptr
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|_KERNEL
case|case
name|NV_TYPE_DESCRIPTOR
case|:
name|ptr
operator|=
name|nvpair_pack_descriptor
argument_list|(
name|nvp
argument_list|,
name|ptr
argument_list|,
name|fdidxp
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|NV_TYPE_BINARY
case|:
name|ptr
operator|=
name|nvpair_pack_binary
argument_list|(
name|nvp
argument_list|,
name|ptr
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
break|break;
default|default:
name|PJDLOG_ABORT
argument_list|(
literal|"Invalid type (%d)."
argument_list|,
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|nv_free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|cookie
operator|=
name|NULL
expr_stmt|;
name|nvl
operator|=
name|nvlist_get_parent
argument_list|(
name|nvl
argument_list|,
operator|&
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvl
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|nvp
operator|=
name|cookie
expr_stmt|;
name|ptr
operator|=
name|nvpair_pack_nvlist_up
argument_list|(
name|ptr
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
if|if
condition|(
name|sizep
operator|!=
name|NULL
condition|)
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|nvlist_pack
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvl
operator|->
name|nvl_error
operator|!=
literal|0
condition|)
block|{
name|ERRNO_SET
argument_list|(
name|nvl
operator|->
name|nvl_error
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_ndescriptors
argument_list|(
name|nvl
argument_list|)
operator|>
literal|0
condition|)
block|{
name|ERRNO_SET
argument_list|(
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|nvlist_xpack
argument_list|(
name|nvl
argument_list|,
name|NULL
argument_list|,
name|sizep
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|nvlist_check_header
parameter_list|(
name|struct
name|nvlist_header
modifier|*
name|nvlhdrp
parameter_list|)
block|{
if|if
condition|(
name|nvlhdrp
operator|->
name|nvlh_magic
operator|!=
name|NVLIST_HEADER_MAGIC
condition|)
block|{
name|ERRNO_SET
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|nvlhdrp
operator|->
name|nvlh_flags
operator|&
operator|~
name|NV_FLAG_ALL_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|ERRNO_SET
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
if|if
condition|(
operator|(
name|nvlhdrp
operator|->
name|nvlh_flags
operator|&
name|NV_FLAG_BIG_ENDIAN
operator|)
operator|==
literal|0
condition|)
block|{
name|nvlhdrp
operator|->
name|nvlh_size
operator|=
name|le64toh
argument_list|(
name|nvlhdrp
operator|->
name|nvlh_size
argument_list|)
expr_stmt|;
name|nvlhdrp
operator|->
name|nvlh_descriptors
operator|=
name|le64toh
argument_list|(
name|nvlhdrp
operator|->
name|nvlh_descriptors
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|nvlhdrp
operator|->
name|nvlh_flags
operator|&
name|NV_FLAG_BIG_ENDIAN
operator|)
operator|!=
literal|0
condition|)
block|{
name|nvlhdrp
operator|->
name|nvlh_size
operator|=
name|be64toh
argument_list|(
name|nvlhdrp
operator|->
name|nvlh_size
argument_list|)
expr_stmt|;
name|nvlhdrp
operator|->
name|nvlh_descriptors
operator|=
name|be64toh
argument_list|(
name|nvlhdrp
operator|->
name|nvlh_descriptors
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|unsigned
name|char
modifier|*
name|nvlist_unpack_header
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|,
name|size_t
name|nfds
parameter_list|,
name|bool
modifier|*
name|isbep
parameter_list|,
name|size_t
modifier|*
name|leftp
parameter_list|)
block|{
name|struct
name|nvlist_header
name|nvlhdr
decl_stmt|;
if|if
condition|(
operator|*
name|leftp
operator|<
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
condition|)
goto|goto
name|failed
goto|;
name|memcpy
argument_list|(
operator|&
name|nvlhdr
argument_list|,
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nvlist_check_header
argument_list|(
operator|&
name|nvlhdr
argument_list|)
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|nvlhdr
operator|.
name|nvlh_size
operator|!=
operator|*
name|leftp
operator|-
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
condition|)
goto|goto
name|failed
goto|;
comment|/* 	 * nvlh_descriptors might be smaller than nfds in embedded nvlists. 	 */
if|if
condition|(
name|nvlhdr
operator|.
name|nvlh_descriptors
operator|>
name|nfds
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
operator|(
name|nvlhdr
operator|.
name|nvlh_flags
operator|&
operator|~
name|NV_FLAG_ALL_MASK
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|failed
goto|;
name|nvl
operator|->
name|nvl_flags
operator|=
operator|(
name|nvlhdr
operator|.
name|nvlh_flags
operator|&
name|NV_FLAG_PUBLIC_MASK
operator|)
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|isbep
operator|!=
name|NULL
condition|)
operator|*
name|isbep
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|nvlhdr
operator|.
name|nvlh_flags
operator|&
name|NV_FLAG_BIG_ENDIAN
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
operator|*
name|leftp
operator|-=
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
name|failed
label|:
name|ERRNO_SET
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|nvlist_t
modifier|*
name|nvlist_xunpack
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|int
modifier|*
name|fds
parameter_list|,
name|size_t
name|nfds
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
decl_stmt|,
modifier|*
name|retnvl
decl_stmt|,
modifier|*
name|tmpnvl
decl_stmt|;
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|size_t
name|left
decl_stmt|;
name|bool
name|isbe
decl_stmt|;
name|left
operator|=
name|size
expr_stmt|;
name|ptr
operator|=
name|buf
expr_stmt|;
name|tmpnvl
operator|=
name|NULL
expr_stmt|;
name|nvl
operator|=
name|retnvl
operator|=
name|nvlist_create
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvl
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
name|ptr
operator|=
name|nvlist_unpack_header
argument_list|(
name|nvl
argument_list|,
name|ptr
argument_list|,
name|nfds
argument_list|,
operator|&
name|isbe
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
name|ptr
operator|=
name|nvpair_unpack
argument_list|(
name|isbe
argument_list|,
name|ptr
argument_list|,
operator|&
name|left
argument_list|,
operator|&
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
switch|switch
condition|(
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
condition|)
block|{
case|case
name|NV_TYPE_NULL
case|:
name|ptr
operator|=
name|nvpair_unpack_null
argument_list|(
name|isbe
argument_list|,
name|nvp
argument_list|,
name|ptr
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
break|break;
case|case
name|NV_TYPE_BOOL
case|:
name|ptr
operator|=
name|nvpair_unpack_bool
argument_list|(
name|isbe
argument_list|,
name|nvp
argument_list|,
name|ptr
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
break|break;
case|case
name|NV_TYPE_NUMBER
case|:
name|ptr
operator|=
name|nvpair_unpack_number
argument_list|(
name|isbe
argument_list|,
name|nvp
argument_list|,
name|ptr
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
break|break;
case|case
name|NV_TYPE_STRING
case|:
name|ptr
operator|=
name|nvpair_unpack_string
argument_list|(
name|isbe
argument_list|,
name|nvp
argument_list|,
name|ptr
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
break|break;
case|case
name|NV_TYPE_NVLIST
case|:
name|ptr
operator|=
name|nvpair_unpack_nvlist
argument_list|(
name|isbe
argument_list|,
name|nvp
argument_list|,
name|ptr
argument_list|,
operator|&
name|left
argument_list|,
name|nfds
argument_list|,
operator|&
name|tmpnvl
argument_list|)
expr_stmt|;
name|nvlist_set_parent
argument_list|(
name|tmpnvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|_KERNEL
case|case
name|NV_TYPE_DESCRIPTOR
case|:
name|ptr
operator|=
name|nvpair_unpack_descriptor
argument_list|(
name|isbe
argument_list|,
name|nvp
argument_list|,
name|ptr
argument_list|,
operator|&
name|left
argument_list|,
name|fds
argument_list|,
name|nfds
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|NV_TYPE_BINARY
case|:
name|ptr
operator|=
name|nvpair_unpack_binary
argument_list|(
name|isbe
argument_list|,
name|nvp
argument_list|,
name|ptr
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
break|break;
case|case
name|NV_TYPE_NVLIST_UP
case|:
if|if
condition|(
name|nvl
operator|->
name|nvl_parent
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
name|nvl
operator|=
name|nvpair_nvlist
argument_list|(
name|nvl
operator|->
name|nvl_parent
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|PJDLOG_ABORT
argument_list|(
literal|"Invalid type (%d)."
argument_list|,
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpnvl
operator|!=
name|NULL
condition|)
block|{
name|nvl
operator|=
name|tmpnvl
expr_stmt|;
name|tmpnvl
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|retnvl
operator|)
return|;
name|failed
label|:
name|nvlist_destroy
argument_list|(
name|retnvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|nvlist_t
modifier|*
name|nvlist_unpack
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|nvlist_xunpack
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_function
name|int
name|nvlist_send
parameter_list|(
name|int
name|sock
parameter_list|,
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|size_t
name|datasize
decl_stmt|,
name|nfds
decl_stmt|;
name|int
modifier|*
name|fds
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|int64_t
name|fdidx
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ERRNO_SET
argument_list|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fds
operator|=
name|nvlist_descriptors
argument_list|(
name|nvl
argument_list|,
operator|&
name|nfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|fds
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
name|data
operator|=
name|NULL
expr_stmt|;
name|fdidx
operator|=
literal|0
expr_stmt|;
name|data
operator|=
name|nvlist_xpack
argument_list|(
name|nvl
argument_list|,
operator|&
name|fdidx
argument_list|,
operator|&
name|datasize
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|buf_send
argument_list|(
name|sock
argument_list|,
name|data
argument_list|,
name|datasize
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|nfds
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fd_send
argument_list|(
name|sock
argument_list|,
name|fds
argument_list|,
name|nfds
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|ERRNO_SAVE
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|fds
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|ERRNO_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|nvlist_t
modifier|*
name|nvlist_recv
parameter_list|(
name|int
name|sock
parameter_list|)
block|{
name|struct
name|nvlist_header
name|nvlhdr
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|nfds
decl_stmt|,
name|size
decl_stmt|,
name|i
decl_stmt|;
name|int
modifier|*
name|fds
decl_stmt|;
if|if
condition|(
name|buf_recv
argument_list|(
name|sock
argument_list|,
operator|&
name|nvlhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|!
name|nvlist_check_header
argument_list|(
operator|&
name|nvlhdr
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|nfds
operator|=
operator|(
name|size_t
operator|)
name|nvlhdr
operator|.
name|nvlh_descriptors
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
operator|+
operator|(
name|size_t
operator|)
name|nvlhdr
operator|.
name|nvlh_size
expr_stmt|;
name|buf
operator|=
name|nv_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|nvlhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
name|fds
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|buf_recv
argument_list|(
name|sock
argument_list|,
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
argument_list|,
name|size
operator|-
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|nfds
operator|>
literal|0
condition|)
block|{
name|fds
operator|=
name|nv_malloc
argument_list|(
name|nfds
operator|*
sizeof|sizeof
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fds
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|fd_recv
argument_list|(
name|sock
argument_list|,
name|fds
argument_list|,
name|nfds
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|out
goto|;
block|}
name|nvl
operator|=
name|nvlist_xunpack
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|fds
argument_list|,
name|nfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvl
operator|==
name|NULL
condition|)
block|{
name|ERRNO_SAVE
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfds
condition|;
name|i
operator|++
control|)
name|close
argument_list|(
name|fds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ERRNO_RESTORE
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|nvl
expr_stmt|;
name|out
label|:
name|ERRNO_SAVE
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fds
argument_list|)
expr_stmt|;
name|ERRNO_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|nvlist_t
modifier|*
name|nvlist_xfer
parameter_list|(
name|int
name|sock
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
if|if
condition|(
name|nvlist_send
argument_list|(
name|sock
argument_list|,
name|nvl
argument_list|)
operator|<
literal|0
condition|)
block|{
name|nvlist_destroy
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|nvlist_destroy
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|nvlist_recv
argument_list|(
name|sock
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|nvpair_t
modifier|*
name|nvlist_first_nvpair
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|nvl
operator|->
name|nvl_head
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|nvpair_t
modifier|*
name|nvlist_next_nvpair
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|retnvp
decl_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|NVPAIR_ASSERT
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvpair_nvlist
argument_list|(
name|nvp
argument_list|)
operator|==
name|nvl
argument_list|)
expr_stmt|;
name|retnvp
operator|=
name|nvpair_next
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|retnvp
operator|==
name|NULL
operator|||
name|nvpair_nvlist
argument_list|(
name|retnvp
argument_list|)
operator|==
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|retnvp
operator|)
return|;
block|}
end_function

begin_function
name|nvpair_t
modifier|*
name|nvlist_prev_nvpair
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|retnvp
decl_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|NVPAIR_ASSERT
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvpair_nvlist
argument_list|(
name|nvp
argument_list|)
operator|==
name|nvl
argument_list|)
expr_stmt|;
name|retnvp
operator|=
name|nvpair_prev
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvpair_nvlist
argument_list|(
name|retnvp
argument_list|)
operator|==
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|retnvp
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|nvlist_next
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
modifier|*
name|typep
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|cookiep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cookiep
operator|==
name|NULL
condition|)
name|nvp
operator|=
name|nvlist_first_nvpair
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
else|else
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
operator|*
name|cookiep
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|typep
operator|!=
name|NULL
condition|)
operator|*
name|typep
operator|=
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
operator|*
name|cookiep
operator|=
name|nvp
expr_stmt|;
return|return
operator|(
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|nvlist_exists
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|nvlist_find
argument_list|(
name|nvl
argument_list|,
name|NV_TYPE_NONE
argument_list|,
name|name
argument_list|)
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NVLIST_EXISTS
parameter_list|(
name|type
parameter_list|,
name|TYPE
parameter_list|)
define|\
value|bool									\ nvlist_exists_##type(const nvlist_t *nvl, const char *name)		\ {									\ 									\ 	return (nvlist_find(nvl, NV_TYPE_##TYPE, name) != NULL);	\ }
end_define

begin_macro
name|NVLIST_EXISTS
argument_list|(
argument|null
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_macro
name|NVLIST_EXISTS
argument_list|(
argument|bool
argument_list|,
argument|BOOL
argument_list|)
end_macro

begin_macro
name|NVLIST_EXISTS
argument_list|(
argument|number
argument_list|,
argument|NUMBER
argument_list|)
end_macro

begin_macro
name|NVLIST_EXISTS
argument_list|(
argument|string
argument_list|,
argument|STRING
argument_list|)
end_macro

begin_macro
name|NVLIST_EXISTS
argument_list|(
argument|nvlist
argument_list|,
argument|NVLIST
argument_list|)
end_macro

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_macro
name|NVLIST_EXISTS
argument_list|(
argument|descriptor
argument_list|,
argument|DESCRIPTOR
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|NVLIST_EXISTS
argument_list|(
argument|binary
argument_list|,
argument|BINARY
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|NVLIST_EXISTS
end_undef

begin_function
name|void
name|nvlist_add_nvpair
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|newnvp
decl_stmt|;
name|NVPAIR_ASSERT
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ERRNO_SET
argument_list|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nvlist_exists
argument_list|(
name|nvl
argument_list|,
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
argument_list|)
condition|)
block|{
name|nvl
operator|->
name|nvl_error
operator|=
name|EEXIST
expr_stmt|;
name|ERRNO_SET
argument_list|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|newnvp
operator|=
name|nvpair_clone
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|newnvp
operator|==
name|NULL
condition|)
block|{
name|nvl
operator|->
name|nvl_error
operator|=
name|ERRNO_OR_DEFAULT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|ERRNO_SET
argument_list|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvpair_insert
argument_list|(
operator|&
name|nvl
operator|->
name|nvl_head
argument_list|,
name|newnvp
argument_list|,
name|nvl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_add_stringf
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|valuefmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|valueap
decl_stmt|;
name|va_start
argument_list|(
name|valueap
argument_list|,
name|valuefmt
argument_list|)
expr_stmt|;
name|nvlist_add_stringv
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|valuefmt
argument_list|,
name|valueap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|valueap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_add_stringv
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|valuefmt
parameter_list|,
name|va_list
name|valueap
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ERRNO_SET
argument_list|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_create_stringv
argument_list|(
name|name
argument_list|,
name|valuefmt
argument_list|,
name|valueap
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
block|{
name|nvl
operator|->
name|nvl_error
operator|=
name|ERRNO_OR_DEFAULT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|ERRNO_SET
argument_list|(
name|nvl
operator|->
name|nvl_error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|nvlist_add_null
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ERRNO_SET
argument_list|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_create_null
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
block|{
name|nvl
operator|->
name|nvl_error
operator|=
name|ERRNO_OR_DEFAULT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|ERRNO_SET
argument_list|(
name|nvl
operator|->
name|nvl_error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|nvlist_add_bool
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bool
name|value
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ERRNO_SET
argument_list|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_create_bool
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
block|{
name|nvl
operator|->
name|nvl_error
operator|=
name|ERRNO_OR_DEFAULT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|ERRNO_SET
argument_list|(
name|nvl
operator|->
name|nvl_error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|nvlist_add_number
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ERRNO_SET
argument_list|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_create_number
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
block|{
name|nvl
operator|->
name|nvl_error
operator|=
name|ERRNO_OR_DEFAULT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|ERRNO_SET
argument_list|(
name|nvl
operator|->
name|nvl_error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|nvlist_add_string
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ERRNO_SET
argument_list|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_create_string
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
block|{
name|nvl
operator|->
name|nvl_error
operator|=
name|ERRNO_OR_DEFAULT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|ERRNO_SET
argument_list|(
name|nvl
operator|->
name|nvl_error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|nvlist_add_nvlist
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|nvlist_t
modifier|*
name|value
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ERRNO_SET
argument_list|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_create_nvlist
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
block|{
name|nvl
operator|->
name|nvl_error
operator|=
name|ERRNO_OR_DEFAULT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|ERRNO_SET
argument_list|(
name|nvl
operator|->
name|nvl_error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_function
name|void
name|nvlist_add_descriptor
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_create_descriptor
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
name|nvl
operator|->
name|nvl_error
operator|=
name|errno
operator|=
operator|(
name|errno
operator|!=
literal|0
condition|?
name|errno
else|:
name|ENOMEM
operator|)
expr_stmt|;
else|else
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|nvlist_add_binary
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|void
modifier|*
name|value
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ERRNO_SET
argument_list|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_create_binary
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
block|{
name|nvl
operator|->
name|nvl_error
operator|=
name|ERRNO_OR_DEFAULT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|ERRNO_SET
argument_list|(
name|nvl
operator|->
name|nvl_error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|nvlist_move_nvpair
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
name|NVPAIR_ASSERT
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvpair_nvlist
argument_list|(
name|nvp
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvpair_free
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|ERRNO_SET
argument_list|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nvlist_exists
argument_list|(
name|nvl
argument_list|,
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
argument_list|)
condition|)
block|{
name|nvpair_free
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|nvl
operator|->
name|nvl_error
operator|=
name|EEXIST
expr_stmt|;
name|ERRNO_SET
argument_list|(
name|nvl
operator|->
name|nvl_error
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvpair_insert
argument_list|(
operator|&
name|nvl
operator|->
name|nvl_head
argument_list|,
name|nvp
argument_list|,
name|nvl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_move_string
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|value
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nv_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|ERRNO_SET
argument_list|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_move_string
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
block|{
name|nvl
operator|->
name|nvl_error
operator|=
name|ERRNO_OR_DEFAULT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|ERRNO_SET
argument_list|(
name|nvl
operator|->
name|nvl_error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|nvlist_move_nvlist
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
name|value
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|!=
name|NULL
operator|&&
name|nvlist_get_nvpair_parent
argument_list|(
name|value
argument_list|)
operator|!=
name|NULL
condition|)
name|nvlist_destroy
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|ERRNO_SET
argument_list|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_move_nvlist
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
block|{
name|nvl
operator|->
name|nvl_error
operator|=
name|ERRNO_OR_DEFAULT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|ERRNO_SET
argument_list|(
name|nvl
operator|->
name|nvl_error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_function
name|void
name|nvlist_move_descriptor
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|ERRNO_SET
argument_list|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_move_descriptor
argument_list|(
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
block|{
name|nvl
operator|->
name|nvl_error
operator|=
name|ERRNO_OR_DEFAULT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|ERRNO_SET
argument_list|(
name|nvl
operator|->
name|nvl_error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|nvlist_move_binary
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|value
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nv_free
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|ERRNO_SET
argument_list|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_move_binary
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
block|{
name|nvl
operator|->
name|nvl_error
operator|=
name|ERRNO_OR_DEFAULT
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|ERRNO_SET
argument_list|(
name|nvl
operator|->
name|nvl_error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|const
name|nvpair_t
modifier|*
name|nvlist_get_nvpair
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|nvlist_find
argument_list|(
name|nvl
argument_list|,
name|NV_TYPE_NONE
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NVLIST_GET
parameter_list|(
name|ftype
parameter_list|,
name|type
parameter_list|,
name|TYPE
parameter_list|)
define|\
value|ftype									\ nvlist_get_##type(const nvlist_t *nvl, const char *name)		\ {									\ 	const nvpair_t *nvp;						\ 									\ 	nvp = nvlist_find(nvl, NV_TYPE_##TYPE, name);			\ 	if (nvp == NULL)						\ 		nvlist_report_missing(NV_TYPE_##TYPE, name);		\ 	return (nvpair_get_##type(nvp));				\ }
end_define

begin_macro
name|NVLIST_GET
argument_list|(
argument|bool
argument_list|,
argument|bool
argument_list|,
argument|BOOL
argument_list|)
end_macro

begin_macro
name|NVLIST_GET
argument_list|(
argument|uint64_t
argument_list|,
argument|number
argument_list|,
argument|NUMBER
argument_list|)
end_macro

begin_macro
name|NVLIST_GET
argument_list|(
argument|const char *
argument_list|,
argument|string
argument_list|,
argument|STRING
argument_list|)
end_macro

begin_macro
name|NVLIST_GET
argument_list|(
argument|const nvlist_t *
argument_list|,
argument|nvlist
argument_list|,
argument|NVLIST
argument_list|)
end_macro

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_macro
name|NVLIST_GET
argument_list|(
argument|int
argument_list|,
argument|descriptor
argument_list|,
argument|DESCRIPTOR
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|NVLIST_GET
end_undef

begin_function
specifier|const
name|void
modifier|*
name|nvlist_get_binary
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|nvp
operator|=
name|nvlist_find
argument_list|(
name|nvl
argument_list|,
name|NV_TYPE_BINARY
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
name|nvlist_report_missing
argument_list|(
name|NV_TYPE_BINARY
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|nvpair_get_binary
argument_list|(
name|nvp
argument_list|,
name|sizep
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NVLIST_TAKE
parameter_list|(
name|ftype
parameter_list|,
name|type
parameter_list|,
name|TYPE
parameter_list|)
define|\
value|ftype									\ nvlist_take_##type(nvlist_t *nvl, const char *name)			\ {									\ 	nvpair_t *nvp;							\ 	ftype value;							\ 									\ 	nvp = nvlist_find(nvl, NV_TYPE_##TYPE, name);			\ 	if (nvp == NULL)						\ 		nvlist_report_missing(NV_TYPE_##TYPE, name);		\ 	value = (ftype)(intptr_t)nvpair_get_##type(nvp);		\ 	nvlist_remove_nvpair(nvl, nvp);					\ 	nvpair_free_structure(nvp);					\ 	return (value);							\ }
end_define

begin_macro
name|NVLIST_TAKE
argument_list|(
argument|bool
argument_list|,
argument|bool
argument_list|,
argument|BOOL
argument_list|)
end_macro

begin_macro
name|NVLIST_TAKE
argument_list|(
argument|uint64_t
argument_list|,
argument|number
argument_list|,
argument|NUMBER
argument_list|)
end_macro

begin_macro
name|NVLIST_TAKE
argument_list|(
argument|char *
argument_list|,
argument|string
argument_list|,
argument|STRING
argument_list|)
end_macro

begin_macro
name|NVLIST_TAKE
argument_list|(
argument|nvlist_t *
argument_list|,
argument|nvlist
argument_list|,
argument|NVLIST
argument_list|)
end_macro

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_macro
name|NVLIST_TAKE
argument_list|(
argument|int
argument_list|,
argument|descriptor
argument_list|,
argument|DESCRIPTOR
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_undef
undef|#
directive|undef
name|NVLIST_TAKE
end_undef

begin_function
name|void
modifier|*
name|nvlist_take_binary
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|void
modifier|*
name|value
decl_stmt|;
name|nvp
operator|=
name|nvlist_find
argument_list|(
name|nvl
argument_list|,
name|NV_TYPE_BINARY
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
name|nvlist_report_missing
argument_list|(
name|NV_TYPE_BINARY
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|nvpair_get_binary
argument_list|(
name|nvp
argument_list|,
name|sizep
argument_list|)
expr_stmt|;
name|nvlist_remove_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
name|nvpair_free_structure
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nvlist_remove_nvpair
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|NVPAIR_ASSERT
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvpair_nvlist
argument_list|(
name|nvp
argument_list|)
operator|==
name|nvl
argument_list|)
expr_stmt|;
name|nvpair_remove
argument_list|(
operator|&
name|nvl
operator|->
name|nvl_head
argument_list|,
name|nvp
argument_list|,
name|nvl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_free
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|nvlist_free_type
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|NV_TYPE_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|NVLIST_FREE
parameter_list|(
name|type
parameter_list|,
name|TYPE
parameter_list|)
define|\
value|void									\ nvlist_free_##type(nvlist_t *nvl, const char *name)			\ {									\ 									\ 	nvlist_free_type(nvl, name, NV_TYPE_##TYPE);			\ }
end_define

begin_macro
name|NVLIST_FREE
argument_list|(
argument|null
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_macro
name|NVLIST_FREE
argument_list|(
argument|bool
argument_list|,
argument|BOOL
argument_list|)
end_macro

begin_macro
name|NVLIST_FREE
argument_list|(
argument|number
argument_list|,
argument|NUMBER
argument_list|)
end_macro

begin_macro
name|NVLIST_FREE
argument_list|(
argument|string
argument_list|,
argument|STRING
argument_list|)
end_macro

begin_macro
name|NVLIST_FREE
argument_list|(
argument|nvlist
argument_list|,
argument|NVLIST
argument_list|)
end_macro

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_macro
name|NVLIST_FREE
argument_list|(
argument|descriptor
argument_list|,
argument|DESCRIPTOR
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|NVLIST_FREE
argument_list|(
argument|binary
argument_list|,
argument|BINARY
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|NVLIST_FREE
end_undef

begin_function
name|void
name|nvlist_free_nvpair
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|NVPAIR_ASSERT
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvpair_nvlist
argument_list|(
name|nvp
argument_list|)
operator|==
name|nvl
argument_list|)
expr_stmt|;
name|nvlist_remove_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
name|nvpair_free
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

