begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1999 Peter Wemm<peter@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rtprio.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_comment
comment|/*  * We have NQS (32) run queues per scheduling class.  For the normal  * class, there are 128 priorities scaled onto these 32 queues.  New  * processes are added to the last entry in each queue, and processes  * are selected for running by taking them from the head and maintaining  * a simple FIFO arrangement.  Realtime and Idle priority processes have  * and explicit 0-31 priority which maps directly onto their class queue  * index.  When a queue has something in it, the corresponding bit is  * set in the queuebits variable, allowing a single read to determine  * the state of all 32 queues and then a ffs() to find the first busy  * queue.  */
end_comment

begin_decl_stmt
name|struct
name|rq
name|queues
index|[
name|NQS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rq
name|rtqueues
index|[
name|NQS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rq
name|idqueues
index|[
name|NQS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
name|queuebits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
name|rtqueuebits
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
name|idqueuebits
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initialize the run queues at boot time.  */
end_comment

begin_function
specifier|static
name|void
name|rqinit
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NQS
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|queues
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|rtqueues
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|idqueues
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|runqueue
argument_list|,
argument|SI_SUB_RUN_QUEUE
argument_list|,
argument|SI_ORDER_FIRST
argument_list|,
argument|rqinit
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_comment
comment|/*  * setrunqueue() examines a process priority and class and inserts it on  * the tail of it's appropriate run queue (based on class and priority).  * This sets the queue busy bit.  * The process must be runnable.  * This must be called at splhigh().  */
end_comment

begin_function
name|void
name|setrunqueue
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|rq
modifier|*
name|q
decl_stmt|;
name|u_int8_t
name|pri
decl_stmt|;
name|KASSERT
argument_list|(
name|p
operator|->
name|p_stat
operator|==
name|SRUN
argument_list|,
operator|(
literal|"setrunqueue: proc not SRUN"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_rtprio
operator|.
name|type
operator|==
name|RTP_PRIO_NORMAL
condition|)
block|{
name|pri
operator|=
name|p
operator|->
name|p_priority
operator|>>
literal|2
expr_stmt|;
name|q
operator|=
operator|&
name|queues
index|[
name|pri
index|]
expr_stmt|;
name|queuebits
operator||=
literal|1
operator|<<
name|pri
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|p_rtprio
operator|.
name|type
operator|==
name|RTP_PRIO_REALTIME
operator|||
name|p
operator|->
name|p_rtprio
operator|.
name|type
operator|==
name|RTP_PRIO_FIFO
condition|)
block|{
name|pri
operator|=
name|p
operator|->
name|p_rtprio
operator|.
name|prio
expr_stmt|;
name|q
operator|=
operator|&
name|rtqueues
index|[
name|pri
index|]
expr_stmt|;
name|rtqueuebits
operator||=
literal|1
operator|<<
name|pri
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|p_rtprio
operator|.
name|type
operator|==
name|RTP_PRIO_IDLE
condition|)
block|{
name|pri
operator|=
name|p
operator|->
name|p_rtprio
operator|.
name|prio
expr_stmt|;
name|q
operator|=
operator|&
name|idqueues
index|[
name|pri
index|]
expr_stmt|;
name|idqueuebits
operator||=
literal|1
operator|<<
name|pri
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"setrunqueue: invalid rtprio type"
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|p_rqindex
operator|=
name|pri
expr_stmt|;
comment|/* remember the queue index */
name|TAILQ_INSERT_TAIL
argument_list|(
name|q
argument_list|,
name|p
argument_list|,
name|p_procq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remrunqueue() removes a given process from the run queue that it is on,  * clearing the queue busy bit if it becomes empty.  * This must be called at splhigh().  */
end_comment

begin_function
name|void
name|remrunqueue
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|rq
modifier|*
name|q
decl_stmt|;
name|u_int32_t
modifier|*
name|which
decl_stmt|;
name|u_int8_t
name|pri
decl_stmt|;
name|pri
operator|=
name|p
operator|->
name|p_rqindex
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_rtprio
operator|.
name|type
operator|==
name|RTP_PRIO_NORMAL
condition|)
block|{
name|q
operator|=
operator|&
name|queues
index|[
name|pri
index|]
expr_stmt|;
name|which
operator|=
operator|&
name|queuebits
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|p_rtprio
operator|.
name|type
operator|==
name|RTP_PRIO_REALTIME
operator|||
name|p
operator|->
name|p_rtprio
operator|.
name|type
operator|==
name|RTP_PRIO_FIFO
condition|)
block|{
name|q
operator|=
operator|&
name|rtqueues
index|[
name|pri
index|]
expr_stmt|;
name|which
operator|=
operator|&
name|rtqueuebits
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|p_rtprio
operator|.
name|type
operator|==
name|RTP_PRIO_IDLE
condition|)
block|{
name|q
operator|=
operator|&
name|idqueues
index|[
name|pri
index|]
expr_stmt|;
name|which
operator|=
operator|&
name|idqueuebits
expr_stmt|;
block|}
else|else
block|{
name|panic
argument_list|(
literal|"remrunqueue: invalid rtprio type"
argument_list|)
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
name|q
argument_list|,
name|p
argument_list|,
name|p_procq
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
operator|*
name|which
operator|&
operator|(
literal|1
operator|<<
name|pri
operator|)
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"remrunqueue: remove from empty queue"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|which
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|pri
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * procrunnable() returns a boolean true (non-zero) value if there are  * any runnable processes.  This is intended to be called from the idle  * loop to avoid the more expensive (and destructive) chooseproc().  *  * MP SAFE.  CALLED WITHOUT THE MP LOCK  */
end_comment

begin_function
name|u_int32_t
name|procrunnable
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|rtqueuebits
operator|||
name|queuebits
operator|||
name|idqueuebits
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * chooseproc() selects the next process to run.  Ideally, cpu_switch()  * would have determined that there is a process available before calling  * this, but it is not a requirement.  The selected process is removed  * from it's queue, and the queue busy bit is cleared if it becomes empty.  * This must be called at splhigh().  *  * For SMP, trivial affinity is implemented by locating the first process  * on the queue that has a matching lastcpu id.  Since normal priorities  * are mapped four priority levels per queue, this may allow the cpu to  * choose a slightly lower priority process in order to preserve the cpu  * caches.  */
end_comment

begin_function
name|struct
name|proc
modifier|*
name|chooseproc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|rq
modifier|*
name|q
decl_stmt|;
name|u_int32_t
modifier|*
name|which
decl_stmt|;
name|u_int32_t
name|pri
decl_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|u_char
name|id
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rtqueuebits
condition|)
block|{
name|pri
operator|=
name|ffs
argument_list|(
name|rtqueuebits
argument_list|)
operator|-
literal|1
expr_stmt|;
name|q
operator|=
operator|&
name|rtqueues
index|[
name|pri
index|]
expr_stmt|;
name|which
operator|=
operator|&
name|rtqueuebits
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|queuebits
condition|)
block|{
name|pri
operator|=
name|ffs
argument_list|(
name|queuebits
argument_list|)
operator|-
literal|1
expr_stmt|;
name|q
operator|=
operator|&
name|queues
index|[
name|pri
index|]
expr_stmt|;
name|which
operator|=
operator|&
name|queuebits
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|idqueuebits
condition|)
block|{
name|pri
operator|=
name|ffs
argument_list|(
name|idqueuebits
argument_list|)
operator|-
literal|1
expr_stmt|;
name|q
operator|=
operator|&
name|idqueues
index|[
name|pri
index|]
expr_stmt|;
name|which
operator|=
operator|&
name|idqueuebits
expr_stmt|;
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
name|p
operator|=
name|TAILQ_FIRST
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|p
argument_list|,
operator|(
literal|"chooseproc: no proc on busy queue"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
comment|/* wander down the current run queue for this pri level for a match */
name|id
operator|=
name|cpuid
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|p_lastcpu
operator|!=
name|id
condition|)
block|{
name|p
operator|=
name|TAILQ_NEXT
argument_list|(
name|p
argument_list|,
name|p_procq
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
name|TAILQ_FIRST
argument_list|(
name|q
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
name|TAILQ_REMOVE
argument_list|(
name|q
argument_list|,
name|p
argument_list|,
name|p_procq
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
name|q
argument_list|)
condition|)
operator|*
name|which
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|pri
operator|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

end_unit

