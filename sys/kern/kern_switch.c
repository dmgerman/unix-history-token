begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Jake Burkholder<jake@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*** Here is the logic..  If there are N processors, then there are at most N KSEs (kernel schedulable entities) working to process threads that belong to a KSEGROUP (kg). If there are X of these KSEs actually running at the moment in question, then there are at most M (N-X) of these KSEs on the run queue, as running KSEs are not on the queue.  Runnable threads are queued off the KSEGROUP in priority order. If there are M or more threads runnable, the top M threads (by priority) are 'preassigned' to the M KSEs not running. The KSEs take their priority from those threads and are put on the run queue.  The last thread that had a priority high enough to have a KSE associated with it, AND IS ON THE RUN QUEUE is pointed to by kg->kg_last_assigned. If no threads queued off the KSEGROUP have KSEs assigned as all the available KSEs are activly running, or because there are no threads queued, that pointer is NULL.  When a KSE is removed from the run queue to become runnable, we know it was associated with the highest priority thread in the queue (at the head of the queue). If it is also the last assigned we know M was 1 and must now be 0. Since the thread is no longer queued that pointer must be removed from it. Since we know there were no more KSEs available, (M was 1 and is now 0) and since we are not FREEING our KSE but using it, we know there are STILL no more KSEs available, we can prove that the next thread in the ksegrp list will not have a KSE to assign to it, so we can show that the pointer must be made 'invalid' (NULL).  The pointer exists so that when a new thread is made runnable, it can have its priority compared with the last assigned thread to see if it should 'steal' its KSE or not.. i.e. is it 'earlier' on the list than that thread or later.. If it's earlier, then the KSE is removed from the last assigned (which is now not assigned a KSE) and reassigned to the new thread, which is placed earlier in the list. The pointer is then backed up to the previous thread (which may or may not be the new thread).  When a thread sleeps or is removed, the KSE becomes available and if there  are queued threads that are not assigned KSEs, the highest priority one of them is assigned the KSE, which is then placed back on the run queue at the approipriate place, and the kg->kg_last_assigned pointer is adjusted down to point to it.  The following diagram shows 2 KSEs and 3 threads from a single process.   RUNQ: --->KSE---KSE--...    (KSEs queued at priorities from threads)               \    \____                   \        \     KSEGROUP---thread--thread--thread    (queued in priority order)         \                 /           \_______________/           (last_assigned)  The result of this scheme is that the M available KSEs are always queued at the priorities they have inherrited from the M highest priority threads for that KSEGROUP. If this situation changes, the KSEs are  reassigned to keep this true. ***/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_sched.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|KERN_SWITCH_INCLUDE
end_ifndef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* KERN_SWITCH_INCLUDE */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|)
end_if

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
name|defined
argument_list|(
name|SCHED_4BSD
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FULL_PREEMPTION
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|PREEMPTION
end_ifndef

begin_error
error|#
directive|error
literal|"The FULL_PREEMPTION option requires the PREEMPTION option"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|CTASSERT
argument_list|(
operator|(
name|RQB_BPW
operator|*
name|RQB_LEN
operator|)
operator|==
name|RQ_NQS
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|td_kse
value|td_sched
end_define

begin_comment
comment|/*  * kern.sched.preemption allows user space to determine if preemption support  * is compiled in or not.  It is not currently a boot or runtime flag that  * can be changed.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PREEMPTION
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|kern_sched_preemption
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|kern_sched_preemption
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|preemption
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|kern_sched_preemption
argument_list|,
literal|0
argument_list|,
literal|"Kernel preemption enabled"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/************************************************************************  * Functions that manipulate runnability from a thread perspective.	*  ************************************************************************/
end_comment

begin_comment
comment|/*  * Select the KSE that will be run next.  From that find the thread, and  * remove it from the KSEGRP's run queue.  If there is thread clustering,  * this will be what does it.  */
end_comment

begin_function
name|struct
name|thread
modifier|*
name|choosethread
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|)
if|if
condition|(
name|smp_active
operator|==
literal|0
operator|&&
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Shutting down, run idlethread on AP's */
name|td
operator|=
name|PCPU_GET
argument_list|(
name|idlethread
argument_list|)
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"choosethread: td=%p (idle)"
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_flags
operator||=
name|KEF_DIDRUN
expr_stmt|;
name|TD_SET_RUNNING
argument_list|(
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|td
operator|)
return|;
block|}
endif|#
directive|endif
name|retry
label|:
name|ke
operator|=
name|sched_choose
argument_list|()
expr_stmt|;
if|if
condition|(
name|ke
condition|)
block|{
name|td
operator|=
name|ke
operator|->
name|ke_thread
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|td
operator|->
name|td_kse
operator|==
name|ke
operator|)
argument_list|,
operator|(
literal|"kse/thread mismatch"
operator|)
argument_list|)
expr_stmt|;
name|kg
operator|=
name|ke
operator|->
name|ke_ksegrp
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator|&
name|P_HADTHREADS
condition|)
block|{
if|if
condition|(
name|kg
operator|->
name|kg_last_assigned
operator|==
name|td
condition|)
block|{
name|kg
operator|->
name|kg_last_assigned
operator|=
name|TAILQ_PREV
argument_list|(
name|td
argument_list|,
name|threadqueue
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kg
operator|->
name|kg_runq
argument_list|,
name|td
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
block|}
name|CTR2
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"choosethread: td=%p pri=%d"
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_priority
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Simulate runq_choose() having returned the idle thread */
name|td
operator|=
name|PCPU_GET
argument_list|(
name|idlethread
argument_list|)
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"choosethread: td=%p (idle)"
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
name|ke
operator|->
name|ke_flags
operator||=
name|KEF_DIDRUN
expr_stmt|;
comment|/* 	 * If we are in panic, only allow system threads, 	 * plus the one we are running in, to be run. 	 */
if|if
condition|(
name|panicstr
operator|&&
operator|(
operator|(
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator|&
name|P_SYSTEM
operator|)
operator|==
literal|0
operator|&&
operator|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_INPANIC
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* note that it is no longer on the run queue */
name|TD_SET_CAN_RUN
argument_list|(
name|td
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|TD_SET_RUNNING
argument_list|(
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|td
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a surplus system slot, try assign a new runnable thread to it.  * Called from:  *  sched_thread_exit()  (local)  *  sched_switch()  (local)  *  sched_thread_exit()  (local)  *  remrunqueue()  (local)  (not at the moment)  */
end_comment

begin_function
specifier|static
name|void
name|slot_fill
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
while|while
condition|(
name|kg
operator|->
name|kg_avail_opennings
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Find the first unassigned thread 		 */
if|if
condition|(
operator|(
name|td
operator|=
name|kg
operator|->
name|kg_last_assigned
operator|)
operator|!=
name|NULL
condition|)
name|td
operator|=
name|TAILQ_NEXT
argument_list|(
name|td
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
else|else
name|td
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|kg
operator|->
name|kg_runq
argument_list|)
expr_stmt|;
comment|/* 		 * If we found one, send it to the system scheduler. 		 */
if|if
condition|(
name|td
condition|)
block|{
name|kg
operator|->
name|kg_last_assigned
operator|=
name|td
expr_stmt|;
name|sched_add
argument_list|(
name|td
argument_list|,
name|SRQ_YIELDING
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"slot_fill: td%p -> kg%p"
argument_list|,
name|td
argument_list|,
name|kg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* no threads to use up the slots. quit now */
break|break;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCHED_4BSD
end_ifdef

begin_comment
comment|/*  * Remove a thread from its KSEGRP's run queue.  * This in turn may remove it from a KSE if it was already assigned  * to one, possibly causing a new thread to be assigned to the KSE  * and the KSE getting a new priority.  */
end_comment

begin_function
specifier|static
name|void
name|remrunqueue
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td2
decl_stmt|,
modifier|*
name|td3
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|TD_ON_RUNQ
argument_list|(
name|td
argument_list|)
operator|)
argument_list|,
operator|(
literal|"remrunqueue: Bad state on run queue"
operator|)
argument_list|)
expr_stmt|;
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"remrunqueue: td%p"
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|TD_SET_CAN_RUN
argument_list|(
name|td
argument_list|)
expr_stmt|;
comment|/* 	 * If it is not a threaded process, take the shortcut. 	 */
if|if
condition|(
operator|(
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator|&
name|P_HADTHREADS
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* remve from sys run queue and free up a slot */
name|sched_rem
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_state
operator|=
name|KES_THREAD
expr_stmt|;
return|return;
block|}
name|td3
operator|=
name|TAILQ_PREV
argument_list|(
name|td
argument_list|,
name|threadqueue
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kg
operator|->
name|kg_runq
argument_list|,
name|td
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_state
operator|==
name|KES_ONRUNQ
condition|)
block|{
comment|/* 		 * This thread has been assigned to the system run queue. 		 * We need to dissociate it and try assign the 		 * KSE to the next available thread. Then, we should 		 * see if we need to move the KSE in the run queues. 		 */
name|sched_rem
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_state
operator|=
name|KES_THREAD
expr_stmt|;
name|td2
operator|=
name|kg
operator|->
name|kg_last_assigned
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|td2
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"last assigned has wrong value"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|td2
operator|==
name|td
condition|)
name|kg
operator|->
name|kg_last_assigned
operator|=
name|td3
expr_stmt|;
comment|/* slot_fill(kg); */
comment|/* will replace it with another */
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Change the priority of a thread that is on the run queue.  */
end_comment

begin_function
name|void
name|adjustrunqueue
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|newpri
parameter_list|)
block|{
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|TD_ON_RUNQ
argument_list|(
name|td
argument_list|)
operator|)
argument_list|,
operator|(
literal|"adjustrunqueue: Bad state on run queue"
operator|)
argument_list|)
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"adjustrunqueue: td%p"
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* 	 * If it is not a threaded process, take the shortcut. 	 */
if|if
condition|(
operator|(
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator|&
name|P_HADTHREADS
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* We only care about the kse in the run queue. */
name|td
operator|->
name|td_priority
operator|=
name|newpri
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_rqindex
operator|!=
operator|(
name|newpri
operator|/
name|RQ_PPQ
operator|)
condition|)
block|{
name|sched_rem
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|sched_add
argument_list|(
name|td
argument_list|,
name|SRQ_BORING
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* It is a threaded process */
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_state
operator|==
name|KES_ONRUNQ
ifdef|#
directive|ifdef
name|SCHED_ULE
operator|||
operator|(
operator|(
name|ke
operator|->
name|ke_flags
operator|&
name|KEF_ASSIGNED
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ke
operator|->
name|ke_flags
operator|&
name|KEF_REMOVED
operator|)
operator|==
literal|0
operator|)
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|kg
operator|->
name|kg_last_assigned
operator|==
name|td
condition|)
block|{
name|kg
operator|->
name|kg_last_assigned
operator|=
name|TAILQ_PREV
argument_list|(
name|td
argument_list|,
name|threadqueue
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
block|}
name|sched_rem
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kg
operator|->
name|kg_runq
argument_list|,
name|td
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
name|TD_SET_CAN_RUN
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_priority
operator|=
name|newpri
expr_stmt|;
name|setrunqueue
argument_list|(
name|td
argument_list|,
name|SRQ_BORING
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function is called when a thread is about to be put on a  * ksegrp run queue because it has been made runnable or its   * priority has been adjusted and the ksegrp does not have a   * free kse slot.  It determines if a thread from the same ksegrp  * should be preempted.  If so, it tries to switch threads  * if the thread is on the same cpu or notifies another cpu that  * it should switch threads.   */
end_comment

begin_function
specifier|static
name|void
name|maybe_preempt_in_ksegrp
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SMP
argument_list|)
block|{
name|struct
name|thread
modifier|*
name|ctd
decl_stmt|;
ifdef|#
directive|ifdef
name|PREEMPTION
name|int
name|cpri
decl_stmt|,
name|pri
decl_stmt|;
endif|#
directive|endif
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ctd
operator|=
name|curthread
expr_stmt|;
ifdef|#
directive|ifdef
name|PREEMPTION
name|KASSERT
argument_list|(
operator|(
name|ctd
operator|->
name|td_kse
operator|!=
name|NULL
operator|&&
name|ctd
operator|->
name|td_kse
operator|->
name|ke_thread
operator|==
name|ctd
operator|)
argument_list|,
operator|(
literal|"thread has no (or wrong) sched-private part."
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|td
operator|->
name|td_inhibitors
operator|==
literal|0
operator|)
argument_list|,
operator|(
literal|"maybe_preempt: trying to run inhibitted thread"
operator|)
argument_list|)
expr_stmt|;
name|pri
operator|=
name|td
operator|->
name|td_priority
expr_stmt|;
name|cpri
operator|=
name|ctd
operator|->
name|td_priority
expr_stmt|;
if|if
condition|(
name|panicstr
operator|!=
name|NULL
operator|||
name|pri
operator|>=
name|cpri
operator|||
name|cold
comment|/* || dumping */
operator|||
name|TD_IS_INHIBITED
argument_list|(
name|ctd
argument_list|)
operator|||
name|td
operator|->
name|td_kse
operator|->
name|ke_state
operator|!=
name|KES_THREAD
condition|)
return|return;
if|if
condition|(
name|ctd
operator|->
name|td_ksegrp
operator|!=
name|td
operator|->
name|td_ksegrp
condition|)
return|return;
ifndef|#
directive|ifndef
name|FULL_PREEMPTION
if|if
condition|(
name|td
operator|->
name|td_priority
operator|>
name|PRI_MAX_ITHD
condition|)
block|{
name|ctd
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* FULL_PREEMPTION */
if|if
condition|(
name|ctd
operator|->
name|td_critnest
operator|>
literal|1
condition|)
name|ctd
operator|->
name|td_owepreempt
operator|=
literal|1
expr_stmt|;
else|else
name|mi_switch
argument_list|(
name|SW_INVOL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* PREEMPTION */
name|ctd
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
endif|#
directive|endif
comment|/* PREEMPTION */
return|return;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SMP */
end_comment

begin_block
block|{
name|struct
name|thread
modifier|*
name|ctd
decl_stmt|;
ifdef|#
directive|ifdef
name|PREEMPTION
name|int
name|cpri
decl_stmt|,
name|pri
decl_stmt|;
endif|#
directive|endif
name|int
name|worst_pri
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|cpumask_t
name|cpumask
decl_stmt|,
name|dontuse
decl_stmt|;
name|struct
name|pcpu
modifier|*
name|pc
decl_stmt|;
name|struct
name|pcpu
modifier|*
name|best_pcpu
decl_stmt|;
name|struct
name|thread
modifier|*
name|cputhread
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ctd
operator|=
name|curthread
expr_stmt|;
ifdef|#
directive|ifdef
name|PREEMPTION
name|KASSERT
argument_list|(
operator|(
name|ctd
operator|->
name|td_kse
operator|!=
name|NULL
operator|&&
name|ctd
operator|->
name|td_kse
operator|->
name|ke_thread
operator|==
name|ctd
operator|)
argument_list|,
operator|(
literal|"thread has no (or wrong) sched-private part."
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|td
operator|->
name|td_inhibitors
operator|==
literal|0
operator|)
argument_list|,
operator|(
literal|"maybe_preempt: trying to run inhibitted thread"
operator|)
argument_list|)
expr_stmt|;
name|pri
operator|=
name|td
operator|->
name|td_priority
expr_stmt|;
name|cpri
operator|=
name|ctd
operator|->
name|td_priority
expr_stmt|;
if|if
condition|(
name|panicstr
operator|!=
name|NULL
operator|||
name|pri
operator|>=
name|cpri
operator|||
name|cold
comment|/* || dumping */
operator|||
name|TD_IS_INHIBITED
argument_list|(
name|ctd
argument_list|)
operator|||
name|td
operator|->
name|td_kse
operator|->
name|ke_state
operator|!=
name|KES_THREAD
condition|)
return|return;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|KSEG_PEEMPT_BEST_CPU
argument_list|)
if|if
condition|(
name|ctd
operator|->
name|td_ksegrp
operator|!=
name|td
operator|->
name|td_ksegrp
condition|)
block|{
endif|#
directive|endif
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
comment|/* if someone is ahead of this thread, wait our turn */
if|if
condition|(
name|td
operator|!=
name|TAILQ_FIRST
argument_list|(
operator|&
name|kg
operator|->
name|kg_runq
argument_list|)
condition|)
return|return;
name|worst_pri
operator|=
name|td
operator|->
name|td_priority
expr_stmt|;
name|best_pcpu
operator|=
name|NULL
expr_stmt|;
name|dontuse
operator|=
name|stopped_cpus
operator||
name|idle_cpus_mask
expr_stmt|;
comment|/*  		 * Find a cpu with the worst priority that runs at thread from 		 * the same  ksegrp - if multiple exist give first the last run 		 * cpu and then the current cpu priority  		 */
name|SLIST_FOREACH
argument_list|(
argument|pc
argument_list|,
argument|&cpuhead
argument_list|,
argument|pc_allcpu
argument_list|)
block|{
name|cpumask
operator|=
name|pc
operator|->
name|pc_cpumask
expr_stmt|;
name|cputhread
operator|=
name|pc
operator|->
name|pc_curthread
expr_stmt|;
if|if
condition|(
operator|(
name|cpumask
operator|&
name|dontuse
operator|)
operator|||
name|cputhread
operator|->
name|td_ksegrp
operator|!=
name|kg
condition|)
continue|continue;
if|if
condition|(
name|cputhread
operator|->
name|td_priority
operator|>
name|worst_pri
condition|)
block|{
name|worst_pri
operator|=
name|cputhread
operator|->
name|td_priority
expr_stmt|;
name|best_pcpu
operator|=
name|pc
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cputhread
operator|->
name|td_priority
operator|==
name|worst_pri
operator|&&
name|best_pcpu
operator|!=
name|NULL
operator|&&
operator|(
name|td
operator|->
name|td_lastcpu
operator|==
name|pc
operator|->
name|pc_cpuid
operator|||
operator|(
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
operator|==
name|cpumask
operator|&&
name|td
operator|->
name|td_lastcpu
operator|!=
name|best_pcpu
operator|->
name|pc_cpuid
operator|)
operator|)
condition|)
name|best_pcpu
operator|=
name|pc
expr_stmt|;
block|}
comment|/* Check if we need to preempt someone */
if|if
condition|(
name|best_pcpu
operator|==
name|NULL
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|IPI_PREEMPTION
argument_list|)
operator|&&
name|defined
argument_list|(
name|PREEMPTION
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FULL_PREEMPTION
argument_list|)
if|if
condition|(
name|td
operator|->
name|td_priority
operator|<=
name|PRI_MAX_ITHD
condition|)
endif|#
directive|endif
comment|/* ! FULL_PREEMPTION */
block|{
name|ipi_selected
argument_list|(
name|best_pcpu
operator|->
name|pc_cpumask
argument_list|,
name|IPI_PREEMPT
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* defined(IPI_PREEMPTION)&& defined(PREEMPTION) */
if|if
condition|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
operator|!=
name|best_pcpu
operator|->
name|pc_cpuid
condition|)
block|{
name|best_pcpu
operator|->
name|pc_curthread
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
name|ipi_selected
argument_list|(
name|best_pcpu
operator|->
name|pc_cpumask
argument_list|,
name|IPI_AST
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|KSEG_PEEMPT_BEST_CPU
argument_list|)
block|}
endif|#
directive|endif
if|if
condition|(
name|td
operator|->
name|td_priority
operator|>=
name|ctd
operator|->
name|td_priority
condition|)
return|return;
ifdef|#
directive|ifdef
name|PREEMPTION
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FULL_PREEMPTION
argument_list|)
if|if
condition|(
name|td
operator|->
name|td_priority
operator|>
name|PRI_MAX_ITHD
condition|)
name|ctd
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
endif|#
directive|endif
comment|/* ! FULL_PREEMPTION */
if|if
condition|(
name|ctd
operator|->
name|td_critnest
operator|>
literal|1
condition|)
name|ctd
operator|->
name|td_owepreempt
operator|=
literal|1
expr_stmt|;
else|else
name|mi_switch
argument_list|(
name|SW_INVOL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* PREEMPTION */
name|ctd
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
endif|#
directive|endif
comment|/* PREEMPTION */
return|return;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SMP */
end_comment

begin_decl_stmt
name|int
name|limitcount
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|setrunqueue
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|struct
name|thread
modifier|*
name|td2
decl_stmt|;
name|struct
name|thread
modifier|*
name|tda
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"setrunqueue: td:%p kg:%p pid:%d"
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_ksegrp
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_SCHED
argument_list|,
literal|"setrunqueue: %p(%s) prio %d by %p(%s)"
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|,
name|td
operator|->
name|td_priority
argument_list|,
name|curthread
argument_list|,
name|curthread
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|td
operator|->
name|td_inhibitors
operator|==
literal|0
operator|)
argument_list|,
operator|(
literal|"setrunqueue: trying to run inhibitted thread"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|TD_CAN_RUN
argument_list|(
name|td
argument_list|)
operator|||
name|TD_IS_RUNNING
argument_list|(
name|td
argument_list|)
operator|)
argument_list|,
operator|(
literal|"setrunqueue: bad thread state"
operator|)
argument_list|)
expr_stmt|;
name|TD_SET_RUNQ
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
if|if
condition|(
operator|(
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator|&
name|P_HADTHREADS
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Common path optimisation: Only one of everything 		 * and the KSE is always already attached. 		 * Totally ignore the ksegrp run queue. 		 */
if|if
condition|(
name|kg
operator|->
name|kg_avail_opennings
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|limitcount
operator|<
literal|1
condition|)
block|{
name|limitcount
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"pid %d: corrected slot count (%d->1)\n"
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|kg
operator|->
name|kg_avail_opennings
argument_list|)
expr_stmt|;
block|}
name|kg
operator|->
name|kg_avail_opennings
operator|=
literal|1
expr_stmt|;
block|}
name|sched_add
argument_list|(
name|td
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  	 * If the concurrency has reduced, and we would go in the  	 * assigned section, then keep removing entries from the  	 * system run queue, until we are not in that section  	 * or there is room for us to be put in that section. 	 * What we MUST avoid is the case where there are threads of less 	 * priority than the new one scheduled, but it can not 	 * be scheduled itself. That would lead to a non contiguous set 	 * of scheduled threads, and everything would break. 	 */
name|tda
operator|=
name|kg
operator|->
name|kg_last_assigned
expr_stmt|;
while|while
condition|(
operator|(
name|kg
operator|->
name|kg_avail_opennings
operator|<=
literal|0
operator|)
operator|&&
operator|(
name|tda
operator|&&
operator|(
name|tda
operator|->
name|td_priority
operator|>
name|td
operator|->
name|td_priority
operator|)
operator|)
condition|)
block|{
comment|/* 		 * None free, but there is one we can commandeer. 		 */
name|CTR2
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"setrunqueue: kg:%p: take slot from td: %p"
argument_list|,
name|kg
argument_list|,
name|tda
argument_list|)
expr_stmt|;
name|sched_rem
argument_list|(
name|tda
argument_list|)
expr_stmt|;
name|tda
operator|=
name|kg
operator|->
name|kg_last_assigned
operator|=
name|TAILQ_PREV
argument_list|(
name|tda
argument_list|,
name|threadqueue
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Add the thread to the ksegrp's run queue at 	 * the appropriate place. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|td2
argument_list|,
argument|&kg->kg_runq
argument_list|,
argument|td_runq
argument_list|)
block|{
if|if
condition|(
name|td2
operator|->
name|td_priority
operator|>
name|td
operator|->
name|td_priority
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|td2
argument_list|,
name|td
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|td2
operator|==
name|NULL
condition|)
block|{
comment|/* We ran off the end of the TAILQ or it was empty. */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|kg
operator|->
name|kg_runq
argument_list|,
name|td
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we have a slot to use, then put the thread on the system 	 * run queue and if needed, readjust the last_assigned pointer. 	 * it may be that we need to schedule something anyhow 	 * even if the availabel slots are -ve so that 	 * all the items< last_assigned are scheduled. 	 */
if|if
condition|(
name|kg
operator|->
name|kg_avail_opennings
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|tda
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * No pre-existing last assigned so whoever is first 			 * gets the slot.. (maybe us) 			 */
name|td2
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|kg
operator|->
name|kg_runq
argument_list|)
expr_stmt|;
name|kg
operator|->
name|kg_last_assigned
operator|=
name|td2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tda
operator|->
name|td_priority
operator|>
name|td
operator|->
name|td_priority
condition|)
block|{
name|td2
operator|=
name|td
expr_stmt|;
block|}
else|else
block|{
comment|/*  			 * We are past last_assigned, so  			 * give the next slot to whatever is next, 			 * which may or may not be us. 			 */
name|td2
operator|=
name|TAILQ_NEXT
argument_list|(
name|tda
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
name|kg
operator|->
name|kg_last_assigned
operator|=
name|td2
expr_stmt|;
block|}
name|sched_add
argument_list|(
name|td2
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CTR3
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"setrunqueue: held: td%p kg%p pid%d"
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_ksegrp
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SRQ_YIELDING
operator|)
operator|==
literal|0
condition|)
name|maybe_preempt_in_ksegrp
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Kernel thread preemption implementation.  Critical sections mark  * regions of code in which preemptions are not allowed.  */
end_comment

begin_function
name|void
name|critical_enter
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|td
operator|->
name|td_critnest
operator|++
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CRITICAL
argument_list|,
literal|"critical_enter by thread %p (%ld, %s) to %d"
argument_list|,
name|td
argument_list|,
operator|(
name|long
operator|)
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|,
name|td
operator|->
name|td_critnest
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|critical_exit
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|KASSERT
argument_list|(
name|td
operator|->
name|td_critnest
operator|!=
literal|0
argument_list|,
operator|(
literal|"critical_exit: td_critnest == 0"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PREEMPTION
if|if
condition|(
name|td
operator|->
name|td_critnest
operator|==
literal|1
condition|)
block|{
name|td
operator|->
name|td_critnest
operator|=
literal|0
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_owepreempt
condition|)
block|{
name|td
operator|->
name|td_critnest
operator|=
literal|1
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_critnest
operator|--
expr_stmt|;
name|mi_switch
argument_list|(
name|SW_INVOL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
name|td
operator|->
name|td_critnest
operator|--
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_CRITICAL
argument_list|,
literal|"critical_exit by thread %p (%ld, %s) to %d"
argument_list|,
name|td
argument_list|,
operator|(
name|long
operator|)
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|,
name|td
operator|->
name|td_critnest
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function is called when a thread is about to be put on run queue  * because it has been made runnable or its priority has been adjusted.  It  * determines if the new thread should be immediately preempted to.  If so,  * it switches to it and eventually returns true.  If not, it returns false  * so that the caller may place the thread on an appropriate run queue.  */
end_comment

begin_function
name|int
name|maybe_preempt
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PREEMPTION
name|struct
name|thread
modifier|*
name|ctd
decl_stmt|;
name|int
name|cpri
decl_stmt|,
name|pri
decl_stmt|;
endif|#
directive|endif
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PREEMPTION
comment|/* 	 * The new thread should not preempt the current thread if any of the 	 * following conditions are true: 	 * 	 *  - The kernel is in the throes of crashing (panicstr). 	 *  - The current thread has a higher (numerically lower) or 	 *    equivalent priority.  Note that this prevents curthread from 	 *    trying to preempt to itself. 	 *  - It is too early in the boot for context switches (cold is set). 	 *  - The current thread has an inhibitor set or is in the process of 	 *    exiting.  In this case, the current thread is about to switch 	 *    out anyways, so there's no point in preempting.  If we did, 	 *    the current thread would not be properly resumed as well, so 	 *    just avoid that whole landmine. 	 *  - If the new thread's priority is not a realtime priority and 	 *    the current thread's priority is not an idle priority and 	 *    FULL_PREEMPTION is disabled. 	 * 	 * If all of these conditions are false, but the current thread is in 	 * a nested critical section, then we have to defer the preemption 	 * until we exit the critical section.  Otherwise, switch immediately 	 * to the new thread. 	 */
name|ctd
operator|=
name|curthread
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ctd
operator|->
name|td_kse
operator|!=
name|NULL
operator|&&
name|ctd
operator|->
name|td_kse
operator|->
name|ke_thread
operator|==
name|ctd
operator|)
argument_list|,
operator|(
literal|"thread has no (or wrong) sched-private part."
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|td
operator|->
name|td_inhibitors
operator|==
literal|0
operator|)
argument_list|,
operator|(
literal|"maybe_preempt: trying to run inhibitted thread"
operator|)
argument_list|)
expr_stmt|;
name|pri
operator|=
name|td
operator|->
name|td_priority
expr_stmt|;
name|cpri
operator|=
name|ctd
operator|->
name|td_priority
expr_stmt|;
if|if
condition|(
name|panicstr
operator|!=
name|NULL
operator|||
name|pri
operator|>=
name|cpri
operator|||
name|cold
comment|/* || dumping */
operator|||
name|TD_IS_INHIBITED
argument_list|(
name|ctd
argument_list|)
operator|||
name|td
operator|->
name|td_kse
operator|->
name|ke_state
operator|!=
name|KES_THREAD
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifndef|#
directive|ifndef
name|FULL_PREEMPTION
if|if
condition|(
name|pri
operator|>
name|PRI_MAX_ITHD
operator|&&
name|cpri
operator|<
name|PRI_MIN_IDLE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
name|ctd
operator|->
name|td_critnest
operator|>
literal|1
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_PROC
argument_list|,
literal|"maybe_preempt: in critical section %d"
argument_list|,
name|ctd
operator|->
name|td_critnest
argument_list|)
expr_stmt|;
name|ctd
operator|->
name|td_owepreempt
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Thread is runnable but not yet put on system run queue. 	 */
name|MPASS
argument_list|(
name|TD_ON_RUNQ
argument_list|(
name|td
argument_list|)
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|td
operator|->
name|td_sched
operator|->
name|ke_state
operator|!=
name|KES_ONRUNQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator|&
name|P_HADTHREADS
condition|)
block|{
comment|/* 		 * If this is a threaded process we actually ARE on the 		 * ksegrp run queue so take it off that first. 		 * Also undo any damage done to the last_assigned pointer. 		 * XXX Fix setrunqueue so this isn't needed 		 */
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
if|if
condition|(
name|kg
operator|->
name|kg_last_assigned
operator|==
name|td
condition|)
name|kg
operator|->
name|kg_last_assigned
operator|=
name|TAILQ_PREV
argument_list|(
name|td
argument_list|,
name|threadqueue
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kg
operator|->
name|kg_runq
argument_list|,
name|td
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
block|}
name|TD_SET_RUNNING
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_PROC
argument_list|,
literal|"preempting to thread %p (pid %d, %s)\n"
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|mi_switch
argument_list|(
name|SW_INVOL
operator||
name|SW_PREEMPT
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|PREEMPTION
end_ifndef

begin_comment
comment|/* XXX: There should be a non-static version of this. */
end_comment

begin_endif
unit|static void printf_caddr_t(void *data) { 	printf("%s", (char *)data); } static char preempt_warning[] =     "WARNING: Kernel preemption is disabled, expect reduced performance.\n"; SYSINIT(preempt_warning, SI_SUB_COPYRIGHT, SI_ORDER_ANY, printf_caddr_t,     preempt_warning)
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/************************************************************************  * SYSTEM RUN QUEUE manipulations and tests				*  ************************************************************************/
end_comment

begin_comment
comment|/*  * Initialize a run structure.  */
end_comment

begin_function
name|void
name|runq_init
parameter_list|(
name|struct
name|runq
modifier|*
name|rq
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
name|rq
argument_list|,
sizeof|sizeof
expr|*
name|rq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RQ_NQS
condition|;
name|i
operator|++
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|rq
operator|->
name|rq_queues
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear the status bit of the queue corresponding to priority level pri,  * indicating that it is empty.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|runq_clrbit
parameter_list|(
name|struct
name|runq
modifier|*
name|rq
parameter_list|,
name|int
name|pri
parameter_list|)
block|{
name|struct
name|rqbits
modifier|*
name|rqb
decl_stmt|;
name|rqb
operator|=
operator|&
name|rq
operator|->
name|rq_status
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"runq_clrbit: bits=%#x %#x bit=%#x word=%d"
argument_list|,
name|rqb
operator|->
name|rqb_bits
index|[
name|RQB_WORD
argument_list|(
name|pri
argument_list|)
index|]
argument_list|,
name|rqb
operator|->
name|rqb_bits
index|[
name|RQB_WORD
argument_list|(
name|pri
argument_list|)
index|]
operator|&
operator|~
name|RQB_BIT
argument_list|(
name|pri
argument_list|)
argument_list|,
name|RQB_BIT
argument_list|(
name|pri
argument_list|)
argument_list|,
name|RQB_WORD
argument_list|(
name|pri
argument_list|)
argument_list|)
expr_stmt|;
name|rqb
operator|->
name|rqb_bits
index|[
name|RQB_WORD
argument_list|(
name|pri
argument_list|)
index|]
operator|&=
operator|~
name|RQB_BIT
argument_list|(
name|pri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the index of the first non-empty run queue.  This is done by  * scanning the status bits, a set bit indicates a non-empty queue.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|runq_findbit
parameter_list|(
name|struct
name|runq
modifier|*
name|rq
parameter_list|)
block|{
name|struct
name|rqbits
modifier|*
name|rqb
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rqb
operator|=
operator|&
name|rq
operator|->
name|rq_status
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RQB_LEN
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rqb
operator|->
name|rqb_bits
index|[
name|i
index|]
condition|)
block|{
name|pri
operator|=
name|RQB_FFS
argument_list|(
name|rqb
operator|->
name|rqb_bits
index|[
name|i
index|]
argument_list|)
operator|+
operator|(
name|i
operator|<<
name|RQB_L2BPW
operator|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"runq_findbit: bits=%#x i=%d pri=%d"
argument_list|,
name|rqb
operator|->
name|rqb_bits
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|pri
argument_list|)
expr_stmt|;
return|return
operator|(
name|pri
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the status bit of the queue corresponding to priority level pri,  * indicating that it is non-empty.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|runq_setbit
parameter_list|(
name|struct
name|runq
modifier|*
name|rq
parameter_list|,
name|int
name|pri
parameter_list|)
block|{
name|struct
name|rqbits
modifier|*
name|rqb
decl_stmt|;
name|rqb
operator|=
operator|&
name|rq
operator|->
name|rq_status
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"runq_setbit: bits=%#x %#x bit=%#x word=%d"
argument_list|,
name|rqb
operator|->
name|rqb_bits
index|[
name|RQB_WORD
argument_list|(
name|pri
argument_list|)
index|]
argument_list|,
name|rqb
operator|->
name|rqb_bits
index|[
name|RQB_WORD
argument_list|(
name|pri
argument_list|)
index|]
operator||
name|RQB_BIT
argument_list|(
name|pri
argument_list|)
argument_list|,
name|RQB_BIT
argument_list|(
name|pri
argument_list|)
argument_list|,
name|RQB_WORD
argument_list|(
name|pri
argument_list|)
argument_list|)
expr_stmt|;
name|rqb
operator|->
name|rqb_bits
index|[
name|RQB_WORD
argument_list|(
name|pri
argument_list|)
index|]
operator||=
name|RQB_BIT
argument_list|(
name|pri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add the KSE to the queue specified by its priority, and set the  * corresponding status bit.  */
end_comment

begin_function
name|void
name|runq_add
parameter_list|(
name|struct
name|runq
modifier|*
name|rq
parameter_list|,
name|struct
name|kse
modifier|*
name|ke
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|rqhead
modifier|*
name|rqh
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|pri
operator|=
name|ke
operator|->
name|ke_thread
operator|->
name|td_priority
operator|/
name|RQ_PPQ
expr_stmt|;
name|ke
operator|->
name|ke_rqindex
operator|=
name|pri
expr_stmt|;
name|runq_setbit
argument_list|(
name|rq
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|rqh
operator|=
operator|&
name|rq
operator|->
name|rq_queues
index|[
name|pri
index|]
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"runq_add: td=%p ke=%p pri=%d %d rqh=%p"
argument_list|,
name|ke
operator|->
name|ke_thread
argument_list|,
name|ke
argument_list|,
name|ke
operator|->
name|ke_thread
operator|->
name|td_priority
argument_list|,
name|pri
argument_list|,
name|rqh
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SRQ_PREEMPTED
condition|)
block|{
name|TAILQ_INSERT_HEAD
argument_list|(
name|rqh
argument_list|,
name|ke
argument_list|,
name|ke_procq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
name|rqh
argument_list|,
name|ke
argument_list|,
name|ke_procq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return true if there are runnable processes of any priority on the run  * queue, false otherwise.  Has no side effects, does not modify the run  * queue structure.  */
end_comment

begin_function
name|int
name|runq_check
parameter_list|(
name|struct
name|runq
modifier|*
name|rq
parameter_list|)
block|{
name|struct
name|rqbits
modifier|*
name|rqb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rqb
operator|=
operator|&
name|rq
operator|->
name|rq_status
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RQB_LEN
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rqb
operator|->
name|rqb_bits
index|[
name|i
index|]
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"runq_check: bits=%#x i=%d"
argument_list|,
name|rqb
operator|->
name|rqb_bits
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|CTR0
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"runq_check: empty"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
name|defined
argument_list|(
name|SCHED_4BSD
argument_list|)
end_if

begin_decl_stmt
name|int
name|runq_fuzz
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|runq_fuzz
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|runq_fuzz
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Find the highest priority process on the run queue.  */
end_comment

begin_function
name|struct
name|kse
modifier|*
name|runq_choose
parameter_list|(
name|struct
name|runq
modifier|*
name|rq
parameter_list|)
block|{
name|struct
name|rqhead
modifier|*
name|rqh
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pri
operator|=
name|runq_findbit
argument_list|(
name|rq
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|rqh
operator|=
operator|&
name|rq
operator|->
name|rq_queues
index|[
name|pri
index|]
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
name|defined
argument_list|(
name|SCHED_4BSD
argument_list|)
comment|/* fuzz == 1 is normal.. 0 or less are ignored */
if|if
condition|(
name|runq_fuzz
operator|>
literal|1
condition|)
block|{
comment|/* 			 * In the first couple of entries, check if 			 * there is one for our CPU as a preference. 			 */
name|int
name|count
init|=
name|runq_fuzz
decl_stmt|;
name|int
name|cpu
init|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke2
decl_stmt|;
name|ke2
operator|=
name|ke
operator|=
name|TAILQ_FIRST
argument_list|(
name|rqh
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|&&
name|ke2
condition|)
block|{
if|if
condition|(
name|ke
operator|->
name|ke_thread
operator|->
name|td_lastcpu
operator|==
name|cpu
condition|)
block|{
name|ke
operator|=
name|ke2
expr_stmt|;
break|break;
block|}
name|ke2
operator|=
name|TAILQ_NEXT
argument_list|(
name|ke2
argument_list|,
name|ke_procq
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
name|ke
operator|=
name|TAILQ_FIRST
argument_list|(
name|rqh
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ke
operator|!=
name|NULL
argument_list|,
operator|(
literal|"runq_choose: no proc on busy queue"
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"runq_choose: pri=%d kse=%p rqh=%p"
argument_list|,
name|pri
argument_list|,
name|ke
argument_list|,
name|rqh
argument_list|)
expr_stmt|;
return|return
operator|(
name|ke
operator|)
return|;
block|}
name|CTR1
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"runq_choose: idleproc pri=%d"
argument_list|,
name|pri
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove the KSE from the queue specified by its priority, and clear the  * corresponding status bit if the queue becomes empty.  * Caller must set ke->ke_state afterwards.  */
end_comment

begin_function
name|void
name|runq_remove
parameter_list|(
name|struct
name|runq
modifier|*
name|rq
parameter_list|,
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
name|struct
name|rqhead
modifier|*
name|rqh
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|KASSERT
argument_list|(
name|ke
operator|->
name|ke_proc
operator|->
name|p_sflag
operator|&
name|PS_INMEM
argument_list|,
operator|(
literal|"runq_remove: process swapped out"
operator|)
argument_list|)
expr_stmt|;
name|pri
operator|=
name|ke
operator|->
name|ke_rqindex
expr_stmt|;
name|rqh
operator|=
operator|&
name|rq
operator|->
name|rq_queues
index|[
name|pri
index|]
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"runq_remove: td=%p, ke=%p pri=%d %d rqh=%p"
argument_list|,
name|ke
operator|->
name|ke_thread
argument_list|,
name|ke
argument_list|,
name|ke
operator|->
name|ke_thread
operator|->
name|td_priority
argument_list|,
name|pri
argument_list|,
name|rqh
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ke
operator|!=
name|NULL
argument_list|,
operator|(
literal|"runq_remove: no proc on busy queue"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|rqh
argument_list|,
name|ke
argument_list|,
name|ke_procq
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
name|rqh
argument_list|)
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"runq_remove: empty"
argument_list|)
expr_stmt|;
name|runq_clrbit
argument_list|(
name|rq
argument_list|,
name|pri
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/****** functions that are temporarily here ***********/
end_comment

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_decl_stmt
specifier|extern
name|struct
name|mtx
name|kse_zombie_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  Allocate scheduler specific per-process resources.  * The thread and ksegrp have already been linked in.  * In this case just set the default concurrency value.  *  * Called from:  *  proc_init() (UMA init method)  */
end_comment

begin_function
name|void
name|sched_newproc
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
comment|/* This can go in sched_fork */
name|sched_init_concurrency
argument_list|(
name|kg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * thread is being either created or recycled.  * Fix up the per-scheduler resources associated with it.  * Called from:  *  sched_fork_thread()  *  thread_dtor()  (*may go away)  *  thread_init()  (*may go away)  */
end_comment

begin_function
name|void
name|sched_newthread
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|td_sched
modifier|*
name|ke
decl_stmt|;
name|ke
operator|=
operator|(
expr|struct
name|td_sched
operator|*
operator|)
operator|(
name|td
operator|+
literal|1
operator|)
expr_stmt|;
name|bzero
argument_list|(
name|ke
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ke
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_sched
operator|=
name|ke
expr_stmt|;
name|ke
operator|->
name|ke_thread
operator|=
name|td
expr_stmt|;
name|ke
operator|->
name|ke_state
operator|=
name|KES_THREAD
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set up an initial concurrency of 1  * and set the given thread (if given) to be using that  * concurrency slot.  * May be used "offline"..before the ksegrp is attached to the world  * and thus wouldn't need schedlock in that case.  * Called from:  *  thr_create()  *  proc_init() (UMA) via sched_newproc()  */
end_comment

begin_function
name|void
name|sched_init_concurrency
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|)
block|{
name|CTR1
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"kg %p init slots and concurrency to 1"
argument_list|,
name|kg
argument_list|)
expr_stmt|;
name|kg
operator|->
name|kg_concurrency
operator|=
literal|1
expr_stmt|;
name|kg
operator|->
name|kg_avail_opennings
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change the concurrency of an existing ksegrp to N  * Called from:  *  kse_create()  *  kse_exit()  *  thread_exit()  *  thread_single()  */
end_comment

begin_function
name|void
name|sched_set_concurrency
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|,
name|int
name|concurrency
parameter_list|)
block|{
name|CTR4
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"kg %p set concurrency to %d, slots %d -> %d"
argument_list|,
name|kg
argument_list|,
name|concurrency
argument_list|,
name|kg
operator|->
name|kg_avail_opennings
argument_list|,
name|kg
operator|->
name|kg_avail_opennings
operator|+
operator|(
name|concurrency
operator|-
name|kg
operator|->
name|kg_concurrency
operator|)
argument_list|)
expr_stmt|;
name|kg
operator|->
name|kg_avail_opennings
operator|+=
operator|(
name|concurrency
operator|-
name|kg
operator|->
name|kg_concurrency
operator|)
expr_stmt|;
name|kg
operator|->
name|kg_concurrency
operator|=
name|concurrency
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called from thread_exit() for all exiting thread  *  * Not to be confused with sched_exit_thread()  * that is only called from thread_exit() for threads exiting  * without the rest of the process exiting because it is also called from  * sched_exit() and we wouldn't want to call it twice.  * XXX This can probably be fixed.  */
end_comment

begin_function
name|void
name|sched_thread_exit
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|SLOT_RELEASE
argument_list|(
name|td
operator|->
name|td_ksegrp
argument_list|)
expr_stmt|;
name|slot_fill
argument_list|(
name|td
operator|->
name|td_ksegrp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERN_SWITCH_INCLUDE */
end_comment

end_unit

