begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2001 Jake Burkholder<jake@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/***  Here is the logic..  If there are N processors, then there are at most N KSEs (kernel schedulable entities) working to process threads that belong to a KSEGOUP (kg). If there are X of these KSEs actually running at the moment in question, then there are at most M (N-X) of these KSEs on the run queue, as running KSEs are not on the queue.  Runnable threads are queued off the KSEGROUP in priority order. If there are M or more threads runnable, the top M threads (by priority) are 'preassigned' to the M KSEs not running. The KSEs take their priority from those threads and are put on the run queue.  The last thread that had a priority high enough to have a KSE associated with it, AND IS ON THE RUN QUEUE is pointed to by kg->kg_last_assigned. If no threads queued off the KSEGROUP have KSEs assigned as all the available KSEs are activly running, or because there are no threads queued, that pointer is NULL.  When a KSE is removed from the run queue to become runnable, we know it was associated with the highest priority thread in the queue (at the head of the queue). If it is also the last assigned we know M was 1 and must now be 0. Since the thread is no longer queued that pointer must be removed from it. Since we know there were no more KSEs available, (M was 1 and is now 0) and since we are not FREEING our KSE but using it, we know there are STILL no more KSEs available, we can prove that the next thread in the ksegrp list will not have a KSE to assign to it, so we can show that the pointer must be made 'invalid' (NULL).  The pointer exists so that when a new thread is made runnable, it can have its priority compared with the last assigned thread to see if it should 'steal' its KSE or not.. i.e. is it 'earlier' on the list than that thread or later.. If it's earlier, then the KSE is removed from the last assigned (which is now not assigned a KSE) and reassigned to the new thread, which is placed earlier in the list. The pointer is then backed up to the previous thread (which may or may not be the new thread).  When a thread sleeps or is removed, the KSE becomes available and if there  are queued threads that are not assigned KSEs, the highest priority one of them is assigned the KSE, which is then placed back on the run queue at the approipriate place, and the kg->kg_last_assigned pointer is adjusted down to point to it.  The following diagram shows 2 KSEs and 3 threads from a single process.   RUNQ: --->KSE---KSE--...    (KSEs queued at priorities from threads)               \    \____                   \        \     KSEGROUP---thread--thread--thread    (queued in priority order)         \                 /           \_______________/           (last_assigned)  The result of this scheme is that the M available KSEs are always queued at the priorities they have inherrited from the M highest priority threads for that KSEGROUP. If this situation changes, the KSEs are  reassigned to keep this true.     */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<machine/critical.h>
end_include

begin_expr_stmt
name|CTASSERT
argument_list|(
operator|(
name|RQB_BPW
operator|*
name|RQB_LEN
operator|)
operator|==
name|RQ_NQS
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Global run queue.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|runq
name|runq
decl_stmt|;
end_decl_stmt

begin_macro
name|SYSINIT
argument_list|(
argument|runq
argument_list|,
argument|SI_SUB_RUN_QUEUE
argument_list|,
argument|SI_ORDER_FIRST
argument_list|,
argument|runq_init
argument_list|,
argument|&runq
argument_list|)
end_macro

begin_function_decl
specifier|static
name|void
name|runq_readjust
parameter_list|(
name|struct
name|runq
modifier|*
name|rq
parameter_list|,
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/************************************************************************  * Functions that manipulate runnability from a thread perspective.	*  ************************************************************************/
end_comment

begin_comment
comment|/*  * Select the KSE that will be run next.  From that find the thread, and x  * remove it from the KSEGRP's run queue.  If there is thread clustering,  * this will be what does it.  */
end_comment

begin_function
name|struct
name|thread
modifier|*
name|choosethread
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
if|if
condition|(
operator|(
name|ke
operator|=
name|runq_choose
argument_list|(
operator|&
name|runq
argument_list|)
operator|)
condition|)
block|{
name|td
operator|=
name|ke
operator|->
name|ke_thread
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|td
operator|->
name|td_kse
operator|==
name|ke
operator|)
argument_list|,
operator|(
literal|"kse/thread mismatch"
operator|)
argument_list|)
expr_stmt|;
name|kg
operator|=
name|ke
operator|->
name|ke_ksegrp
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_UNBOUND
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kg
operator|->
name|kg_runq
argument_list|,
name|td
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
if|if
condition|(
name|kg
operator|->
name|kg_last_assigned
operator|==
name|td
condition|)
if|if
condition|(
name|TAILQ_PREV
argument_list|(
name|td
argument_list|,
name|threadqueue
argument_list|,
name|td_runq
argument_list|)
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"Yo MAMA!\n"
argument_list|)
expr_stmt|;
name|kg
operator|->
name|kg_last_assigned
operator|=
name|TAILQ_PREV
argument_list|(
name|td
argument_list|,
name|threadqueue
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
comment|/* 			 *  If we have started running an upcall, 			 * Then TDF_UNBOUND WAS set because the thread was  			 * created without a KSE. Now that we have one, 			 * and it is our time to run, we make sure 			 * that BOUND semantics apply for the rest of 			 * the journey to userland, and into the UTS. 			 */
ifdef|#
directive|ifdef
name|NOTYET
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_UPCALLING
condition|)
name|tdf
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_UNBOUND
expr_stmt|;
endif|#
directive|endif
block|}
name|kg
operator|->
name|kg_runnable
operator|--
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"choosethread: td=%p pri=%d"
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_priority
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Pretend the idle thread was on the run queue. */
name|td
operator|=
name|PCPU_GET
argument_list|(
name|idlethread
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_kse
operator|->
name|ke_state
operator|=
name|KES_UNQUEUED
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"choosethread: td=%p (idle)"
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_state
operator|=
name|TDS_RUNNING
expr_stmt|;
return|return
operator|(
name|td
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a KSE (now surplus), either assign a new runable thread to it  * (and put it in the run queue) or put it in the ksegrp's idle KSE list.  * Assumes the kse is not linked to any threads any more. (has been cleaned).  */
end_comment

begin_function
name|void
name|kse_reassign
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|kg
operator|=
name|ke
operator|->
name|ke_ksegrp
expr_stmt|;
comment|/* 	 * Find the first unassigned thread 	 * If there is a 'last assigned' then see what's next. 	 * otherwise look at what is first. 	 */
if|if
condition|(
operator|(
name|td
operator|=
name|kg
operator|->
name|kg_last_assigned
operator|)
condition|)
block|{
name|td
operator|=
name|TAILQ_NEXT
argument_list|(
name|td
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|td
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|kg
operator|->
name|kg_runq
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we found one assign it the kse, otherwise idle the kse. 	 */
if|if
condition|(
name|td
condition|)
block|{
name|kg
operator|->
name|kg_last_assigned
operator|=
name|td
expr_stmt|;
name|td
operator|->
name|td_kse
operator|=
name|ke
expr_stmt|;
name|ke
operator|->
name|ke_thread
operator|=
name|td
expr_stmt|;
name|runq_add
argument_list|(
operator|&
name|runq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"kse_reassign: ke%p -> td%p"
argument_list|,
name|ke
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
operator|(
name|ke
operator|->
name|ke_state
operator|!=
name|KES_IDLE
operator|)
argument_list|,
operator|(
literal|"kse already idle"
operator|)
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_state
operator|=
name|KES_IDLE
expr_stmt|;
name|ke
operator|->
name|ke_thread
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|kg
operator|->
name|kg_iq
argument_list|,
name|ke
argument_list|,
name|ke_kgrlist
argument_list|)
expr_stmt|;
name|kg
operator|->
name|kg_idle_kses
operator|++
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"kse_reassign: ke%p idled"
argument_list|,
name|ke
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|kserunnable
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|runq_check
argument_list|(
operator|&
name|runq
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a thread from its KSEGRP's run queue.  * This in turn may remove it from a KSE if it was already assigned  * to one, possibly causing a new thread to be assigned to the KSE  * and the KSE getting a new priority (unless it's a BOUND thread/KSE pair).  */
end_comment

begin_function
name|void
name|remrunqueue
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td2
decl_stmt|,
modifier|*
name|td3
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|td
operator|->
name|td_state
operator|==
name|TDS_RUNQ
operator|)
argument_list|,
operator|(
literal|"remrunqueue: Bad state on run queue"
operator|)
argument_list|)
expr_stmt|;
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
comment|/* 	 * If it's a bound thread/KSE pair, take the shortcut. All non-KSE 	 * threads are BOUND. 	 */
name|CTR1
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"remrunqueue: td%p"
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_state
operator|=
name|TDS_UNQUEUED
expr_stmt|;
name|kg
operator|->
name|kg_runnable
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_UNBOUND
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Bring its kse with it, leave the thread attached */
name|runq_remove
argument_list|(
operator|&
name|runq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_state
operator|=
name|KES_UNQUEUED
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ke
condition|)
block|{
comment|/* 		 * This thread has been assigned to a KSE. 		 * We need to dissociate it and try assign the 		 * KSE to the next available thread. Then, we should 		 * see if we need to move the KSE in the run queues. 		 */
name|td2
operator|=
name|kg
operator|->
name|kg_last_assigned
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|td2
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"last assigned has wrong value "
operator|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_kse
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|td3
operator|=
name|TAILQ_NEXT
argument_list|(
name|td2
argument_list|,
name|td_runq
argument_list|)
operator|)
condition|)
block|{
name|KASSERT
argument_list|(
name|td3
operator|!=
name|td
argument_list|,
operator|(
literal|"td3 somehow matched td"
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Give the next unassigned thread to the KSE 			 * so the number of runnable KSEs remains 			 * constant. 			 */
name|td3
operator|->
name|td_kse
operator|=
name|ke
expr_stmt|;
name|ke
operator|->
name|ke_thread
operator|=
name|td3
expr_stmt|;
name|kg
operator|->
name|kg_last_assigned
operator|=
name|td3
expr_stmt|;
name|runq_readjust
argument_list|(
operator|&
name|runq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * There is no unassigned thread. 			 * If we were the last assigned one, 			 * adjust the last assigned pointer back 			 * one, which may result in NULL. 			 */
if|if
condition|(
name|td
operator|==
name|td2
condition|)
block|{
name|kg
operator|->
name|kg_last_assigned
operator|=
name|TAILQ_PREV
argument_list|(
name|td
argument_list|,
name|threadqueue
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
block|}
name|runq_remove
argument_list|(
operator|&
name|runq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ke
operator|->
name|ke_state
operator|!=
name|KES_IDLE
operator|)
argument_list|,
operator|(
literal|"kse already idle"
operator|)
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_state
operator|=
name|KES_IDLE
expr_stmt|;
name|ke
operator|->
name|ke_thread
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|kg
operator|->
name|kg_iq
argument_list|,
name|ke
argument_list|,
name|ke_kgrlist
argument_list|)
expr_stmt|;
name|kg
operator|->
name|kg_idle_kses
operator|++
expr_stmt|;
block|}
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kg
operator|->
name|kg_runq
argument_list|,
name|td
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|1
end_if

begin_comment
comment|/* use the first version */
end_comment

begin_function
name|void
name|setrunqueue
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|struct
name|thread
modifier|*
name|td2
decl_stmt|;
name|struct
name|thread
modifier|*
name|tda
decl_stmt|;
name|CTR1
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"setrunqueue: td%p"
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|td
operator|->
name|td_state
operator|!=
name|TDS_RUNQ
operator|)
argument_list|,
operator|(
literal|"setrunqueue: bad thread state"
operator|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_state
operator|=
name|TDS_RUNQ
expr_stmt|;
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
name|kg
operator|->
name|kg_runnable
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_UNBOUND
operator|)
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|td
operator|->
name|td_kse
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"queueing BAD thread to run queue"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Common path optimisation: Only one of everything 		 * and the KSE is always already attached. 		 * Totally ignore the ksegrp run queue. 		 */
name|runq_add
argument_list|(
operator|&
name|runq
argument_list|,
name|td
operator|->
name|td_kse
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  	 * Ok, so we are threading with this thread. 	 * We don't have a KSE, see if we can get one.. 	 */
name|tda
operator|=
name|kg
operator|->
name|kg_last_assigned
expr_stmt|;
if|if
condition|(
operator|(
name|ke
operator|=
name|td
operator|->
name|td_kse
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * We will need a KSE, see if there is one.. 		 * First look for a free one, before getting desperate. 		 * If we can't get one, our priority is not high enough.. 		 * that's ok.. 		 */
if|if
condition|(
name|kg
operator|->
name|kg_idle_kses
condition|)
block|{
comment|/* 			 * There is a free one so it's ours for the asking.. 			 */
name|ke
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|kg
operator|->
name|kg_iq
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kg
operator|->
name|kg_iq
argument_list|,
name|ke
argument_list|,
name|ke_kgrlist
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_state
operator|=
name|KES_UNQUEUED
expr_stmt|;
name|kg
operator|->
name|kg_idle_kses
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tda
operator|&&
operator|(
name|tda
operator|->
name|td_priority
operator|>
name|td
operator|->
name|td_priority
operator|)
condition|)
block|{
comment|/* 			 * None free, but there is one we can commandeer. 			 */
name|ke
operator|=
name|tda
operator|->
name|td_kse
expr_stmt|;
name|tda
operator|->
name|td_kse
operator|=
name|NULL
expr_stmt|;
name|ke
operator|->
name|ke_thread
operator|=
name|NULL
expr_stmt|;
name|tda
operator|=
name|kg
operator|->
name|kg_last_assigned
operator|=
name|TAILQ_PREV
argument_list|(
name|tda
argument_list|,
name|threadqueue
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
name|runq_remove
argument_list|(
operator|&
name|runq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|ke
operator|->
name|ke_thread
operator|==
name|td
argument_list|,
operator|(
literal|"KSE/thread mismatch"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ke
operator|->
name|ke_state
operator|!=
name|KES_IDLE
argument_list|,
operator|(
literal|"KSE unexpectedly idle"
operator|)
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_thread
operator|=
name|NULL
expr_stmt|;
name|td
operator|->
name|td_kse
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Add the thread to the ksegrp's run queue at 	 * the appropriate place. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|td2
argument_list|,
argument|&kg->kg_runq
argument_list|,
argument|td_runq
argument_list|)
block|{
if|if
condition|(
name|td2
operator|->
name|td_priority
operator|>
name|td
operator|->
name|td_priority
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|td2
argument_list|,
name|td
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|td2
operator|==
name|NULL
condition|)
block|{
comment|/* We ran off the end of the TAILQ or it was empty. */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|kg
operator|->
name|kg_runq
argument_list|,
name|td
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we have a ke to use, then put it on the run queue and 	 * If needed, readjust the last_assigned pointer. 	 */
if|if
condition|(
name|ke
condition|)
block|{
if|if
condition|(
name|tda
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * No pre-existing last assigned so whoever is first 			 * gets the KSE we borught in.. (may be us) 			 */
name|td2
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|kg
operator|->
name|kg_runq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|td2
operator|->
name|td_kse
operator|==
name|NULL
operator|)
argument_list|,
operator|(
literal|"unexpected ke present"
operator|)
argument_list|)
expr_stmt|;
name|td2
operator|->
name|td_kse
operator|=
name|ke
expr_stmt|;
name|ke
operator|->
name|ke_thread
operator|=
name|td2
expr_stmt|;
name|kg
operator|->
name|kg_last_assigned
operator|=
name|td2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tda
operator|->
name|td_priority
operator|>
name|td
operator|->
name|td_priority
condition|)
block|{
comment|/* 			 * It's ours, grab it, but last_assigned is past us 			 * so don't change it. 			 */
name|td
operator|->
name|td_kse
operator|=
name|ke
expr_stmt|;
name|ke
operator|->
name|ke_thread
operator|=
name|td
expr_stmt|;
block|}
else|else
block|{
comment|/*  			 * We are past last_assigned, so  			 * put the new kse on whatever is next, 			 * which may or may not be us. 			 */
name|td2
operator|=
name|TAILQ_NEXT
argument_list|(
name|tda
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
name|kg
operator|->
name|kg_last_assigned
operator|=
name|td2
expr_stmt|;
name|td2
operator|->
name|td_kse
operator|=
name|ke
expr_stmt|;
name|ke
operator|->
name|ke_thread
operator|=
name|td2
expr_stmt|;
block|}
name|runq_add
argument_list|(
operator|&
name|runq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|setrunqueue
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|struct
name|thread
modifier|*
name|td2
decl_stmt|;
name|CTR1
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"setrunqueue: td%p"
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|td
operator|->
name|td_state
operator|!=
name|TDS_RUNQ
operator|)
argument_list|,
operator|(
literal|"setrunqueue: bad thread state"
operator|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_state
operator|=
name|TDS_RUNQ
expr_stmt|;
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
name|kg
operator|->
name|kg_runnable
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_UNBOUND
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Common path optimisation: Only one of everything 		 * and the KSE is always already attached. 		 * Totally ignore the ksegrp run queue. 		 */
name|runq_add
argument_list|(
operator|&
name|runq
argument_list|,
name|td
operator|->
name|td_kse
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * First add the thread to the ksegrp's run queue at 	 * the appropriate place. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|td2
argument_list|,
argument|&kg->kg_runq
argument_list|,
argument|td_runq
argument_list|)
block|{
if|if
condition|(
name|td2
operator|->
name|td_priority
operator|>
name|td
operator|->
name|td_priority
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|td2
argument_list|,
name|td
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|td2
operator|==
name|NULL
condition|)
block|{
comment|/* We ran off the end of the TAILQ or it was empty. */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|kg
operator|->
name|kg_runq
argument_list|,
name|td
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The following could be achieved by simply doing: 	 * td->td_kse = NULL; kse_reassign(ke); 	 * but I felt that I'd try do it inline here. 	 * All this work may not be worth it. 	 */
if|if
condition|(
operator|(
name|ke
operator|=
name|td
operator|->
name|td_kse
operator|)
condition|)
block|{
comment|/* XXXKSE */
comment|/* 		 * We have a KSE already. See whether we can keep it 		 * or if we need to give it to someone else. 		 * Either way it will need to be inserted into 		 * the runq. kse_reassign() will do this as will runq_add(). 		 */
if|if
condition|(
operator|(
name|kg
operator|->
name|kg_last_assigned
operator|)
operator|&&
operator|(
name|kg
operator|->
name|kg_last_assigned
operator|->
name|td_priority
operator|>
name|td
operator|->
name|td_priority
operator|)
condition|)
block|{
comment|/* 			 * We can definitly keep the KSE 			 * as the "last assignead thread" has 			 * less priority than we do. 			 * The "last assigned" pointer stays the same. 			 */
name|runq_add
argument_list|(
operator|&
name|runq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Give it to the correct thread, 		 * which may be (often is) us, but may not be. 		 */
name|td
operator|->
name|td_kse
operator|=
name|NULL
expr_stmt|;
name|kse_reassign
argument_list|(
name|ke
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * There are two cases where KSE adjustment is needed. 	 * Usurpation of an already assigned KSE, and assignment 	 * of a previously IDLE KSE. 	 */
if|if
condition|(
name|kg
operator|->
name|kg_idle_kses
condition|)
block|{
comment|/* 		 * If there are unassigned KSEs then we definitly 		 * will be assigned one from the idle KSE list. 		 * If we are the last, we should get the "last 		 * assigned" pointer set to us as well. 		 */
name|ke
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|kg
operator|->
name|kg_iq
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kg
operator|->
name|kg_iq
argument_list|,
name|ke
argument_list|,
name|ke_kgrlist
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_state
operator|=
name|KES_UNQUEUED
expr_stmt|;
name|kg
operator|->
name|kg_idle_kses
operator|--
expr_stmt|;
name|ke
operator|->
name|ke_thread
operator|=
name|td
expr_stmt|;
name|td
operator|->
name|td_kse
operator|=
name|ke
expr_stmt|;
name|runq_add
argument_list|(
operator|&
name|runq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_NEXT
argument_list|(
name|td
argument_list|,
name|td_runq
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|kg
operator|->
name|kg_last_assigned
operator|=
name|td
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|kg
operator|->
name|kg_last_assigned
operator|&&
operator|(
name|kg
operator|->
name|kg_last_assigned
operator|->
name|td_priority
operator|>
name|td
operator|->
name|td_priority
operator|)
condition|)
block|{
comment|/* 		 * If there were none last-assigned, all KSEs 		 * are actually out running as we speak. 		 * If there was a last assigned, but we didn't see it, 		 * we must be inserting before it, so take the KSE from 		 * the last assigned, and back it up one entry. Then, 		 * assign the KSE to the new thread and adjust its priority. 		 */
name|td2
operator|=
name|kg
operator|->
name|kg_last_assigned
expr_stmt|;
name|ke
operator|=
name|td2
operator|->
name|td_kse
expr_stmt|;
name|kg
operator|->
name|kg_last_assigned
operator|=
name|TAILQ_PREV
argument_list|(
name|td2
argument_list|,
name|threadqueue
argument_list|,
name|td_runq
argument_list|)
expr_stmt|;
name|td2
operator|->
name|td_kse
operator|=
name|NULL
expr_stmt|;
name|td
operator|->
name|td_kse
operator|=
name|ke
expr_stmt|;
name|ke
operator|->
name|ke_thread
operator|=
name|td
expr_stmt|;
name|runq_readjust
argument_list|(
operator|&
name|runq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/************************************************************************  * Critical section marker functions					*  ************************************************************************/
end_comment

begin_comment
comment|/* Critical sections that prevent preemption. */
end_comment

begin_function
name|void
name|critical_enter
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_critnest
operator|==
literal|0
condition|)
name|cpu_critical_enter
argument_list|()
expr_stmt|;
name|td
operator|->
name|td_critnest
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|critical_exit
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_critnest
operator|==
literal|1
condition|)
block|{
name|td
operator|->
name|td_critnest
operator|=
literal|0
expr_stmt|;
name|cpu_critical_exit
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|td_critnest
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/************************************************************************  * SYSTEM RUN QUEUE manipulations and tests				*  ************************************************************************/
end_comment

begin_comment
comment|/*  * Initialize a run structure.  */
end_comment

begin_function
name|void
name|runq_init
parameter_list|(
name|struct
name|runq
modifier|*
name|rq
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|bzero
argument_list|(
name|rq
argument_list|,
sizeof|sizeof
expr|*
name|rq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RQ_NQS
condition|;
name|i
operator|++
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|rq
operator|->
name|rq_queues
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear the status bit of the queue corresponding to priority level pri,  * indicating that it is empty.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|runq_clrbit
parameter_list|(
name|struct
name|runq
modifier|*
name|rq
parameter_list|,
name|int
name|pri
parameter_list|)
block|{
name|struct
name|rqbits
modifier|*
name|rqb
decl_stmt|;
name|rqb
operator|=
operator|&
name|rq
operator|->
name|rq_status
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"runq_clrbit: bits=%#x %#x bit=%#x word=%d"
argument_list|,
name|rqb
operator|->
name|rqb_bits
index|[
name|RQB_WORD
argument_list|(
name|pri
argument_list|)
index|]
argument_list|,
name|rqb
operator|->
name|rqb_bits
index|[
name|RQB_WORD
argument_list|(
name|pri
argument_list|)
index|]
operator|&
operator|~
name|RQB_BIT
argument_list|(
name|pri
argument_list|)
argument_list|,
name|RQB_BIT
argument_list|(
name|pri
argument_list|)
argument_list|,
name|RQB_WORD
argument_list|(
name|pri
argument_list|)
argument_list|)
expr_stmt|;
name|rqb
operator|->
name|rqb_bits
index|[
name|RQB_WORD
argument_list|(
name|pri
argument_list|)
index|]
operator|&=
operator|~
name|RQB_BIT
argument_list|(
name|pri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find the index of the first non-empty run queue.  This is done by  * scanning the status bits, a set bit indicates a non-empty queue.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|runq_findbit
parameter_list|(
name|struct
name|runq
modifier|*
name|rq
parameter_list|)
block|{
name|struct
name|rqbits
modifier|*
name|rqb
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rqb
operator|=
operator|&
name|rq
operator|->
name|rq_status
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RQB_LEN
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rqb
operator|->
name|rqb_bits
index|[
name|i
index|]
condition|)
block|{
name|pri
operator|=
name|RQB_FFS
argument_list|(
name|rqb
operator|->
name|rqb_bits
index|[
name|i
index|]
argument_list|)
operator|+
operator|(
name|i
operator|<<
name|RQB_L2BPW
operator|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"runq_findbit: bits=%#x i=%d pri=%d"
argument_list|,
name|rqb
operator|->
name|rqb_bits
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|pri
argument_list|)
expr_stmt|;
return|return
operator|(
name|pri
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the status bit of the queue corresponding to priority level pri,  * indicating that it is non-empty.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|runq_setbit
parameter_list|(
name|struct
name|runq
modifier|*
name|rq
parameter_list|,
name|int
name|pri
parameter_list|)
block|{
name|struct
name|rqbits
modifier|*
name|rqb
decl_stmt|;
name|rqb
operator|=
operator|&
name|rq
operator|->
name|rq_status
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"runq_setbit: bits=%#x %#x bit=%#x word=%d"
argument_list|,
name|rqb
operator|->
name|rqb_bits
index|[
name|RQB_WORD
argument_list|(
name|pri
argument_list|)
index|]
argument_list|,
name|rqb
operator|->
name|rqb_bits
index|[
name|RQB_WORD
argument_list|(
name|pri
argument_list|)
index|]
operator||
name|RQB_BIT
argument_list|(
name|pri
argument_list|)
argument_list|,
name|RQB_BIT
argument_list|(
name|pri
argument_list|)
argument_list|,
name|RQB_WORD
argument_list|(
name|pri
argument_list|)
argument_list|)
expr_stmt|;
name|rqb
operator|->
name|rqb_bits
index|[
name|RQB_WORD
argument_list|(
name|pri
argument_list|)
index|]
operator||=
name|RQB_BIT
argument_list|(
name|pri
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add the KSE to the queue specified by its priority, and set the  * corresponding status bit.  */
end_comment

begin_function
name|void
name|runq_add
parameter_list|(
name|struct
name|runq
modifier|*
name|rq
parameter_list|,
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
name|struct
name|rqhead
modifier|*
name|rqh
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ke
operator|->
name|ke_thread
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"runq_add: No thread on KSE"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ke
operator|->
name|ke_thread
operator|->
name|td_kse
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"runq_add: No KSE on thread"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_state
operator|==
name|KES_ONRUNQ
condition|)
return|return;
if|#
directive|if
name|defined
argument_list|(
name|INVARIANTS
argument_list|)
operator|&&
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
name|KASSERT
argument_list|(
name|ke
operator|->
name|ke_state
operator|!=
name|KES_ONRUNQ
argument_list|,
operator|(
literal|"runq_add: kse %p (%s) already in run queue"
operator|,
name|ke
operator|,
name|ke
operator|->
name|ke_proc
operator|->
name|p_comm
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pri
operator|=
name|ke
operator|->
name|ke_thread
operator|->
name|td_priority
operator|/
name|RQ_PPQ
expr_stmt|;
name|ke
operator|->
name|ke_rqindex
operator|=
name|pri
expr_stmt|;
name|runq_setbit
argument_list|(
name|rq
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|rqh
operator|=
operator|&
name|rq
operator|->
name|rq_queues
index|[
name|pri
index|]
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"runq_add: p=%p pri=%d %d rqh=%p"
argument_list|,
name|ke
operator|->
name|ke_proc
argument_list|,
name|ke
operator|->
name|ke_thread
operator|->
name|td_priority
argument_list|,
name|pri
argument_list|,
name|rqh
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|rqh
argument_list|,
name|ke
argument_list|,
name|ke_procq
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_ksegrp
operator|->
name|kg_runq_kses
operator|++
expr_stmt|;
name|ke
operator|->
name|ke_state
operator|=
name|KES_ONRUNQ
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return true if there are runnable processes of any priority on the run  * queue, false otherwise.  Has no side effects, does not modify the run  * queue structure.  */
end_comment

begin_function
name|int
name|runq_check
parameter_list|(
name|struct
name|runq
modifier|*
name|rq
parameter_list|)
block|{
name|struct
name|rqbits
modifier|*
name|rqb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rqb
operator|=
operator|&
name|rq
operator|->
name|rq_status
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RQB_LEN
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rqb
operator|->
name|rqb_bits
index|[
name|i
index|]
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"runq_check: bits=%#x i=%d"
argument_list|,
name|rqb
operator|->
name|rqb_bits
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|CTR0
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"runq_check: empty"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find and remove the highest priority process from the run queue.  * If there are no runnable processes, the per-cpu idle process is  * returned.  Will not return NULL under any circumstances.  */
end_comment

begin_function
name|struct
name|kse
modifier|*
name|runq_choose
parameter_list|(
name|struct
name|runq
modifier|*
name|rq
parameter_list|)
block|{
name|struct
name|rqhead
modifier|*
name|rqh
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pri
operator|=
name|runq_findbit
argument_list|(
name|rq
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|rqh
operator|=
operator|&
name|rq
operator|->
name|rq_queues
index|[
name|pri
index|]
expr_stmt|;
name|ke
operator|=
name|TAILQ_FIRST
argument_list|(
name|rqh
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ke
operator|!=
name|NULL
argument_list|,
operator|(
literal|"runq_choose: no proc on busy queue"
operator|)
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"runq_choose: pri=%d kse=%p rqh=%p"
argument_list|,
name|pri
argument_list|,
name|ke
argument_list|,
name|rqh
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|rqh
argument_list|,
name|ke
argument_list|,
name|ke_procq
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_ksegrp
operator|->
name|kg_runq_kses
operator|--
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
name|rqh
argument_list|)
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"runq_choose: empty"
argument_list|)
expr_stmt|;
name|runq_clrbit
argument_list|(
name|rq
argument_list|,
name|pri
argument_list|)
expr_stmt|;
block|}
name|ke
operator|->
name|ke_state
operator|=
name|KES_RUNNING
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ke
operator|->
name|ke_thread
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"runq_choose: No thread on KSE"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ke
operator|->
name|ke_thread
operator|->
name|td_kse
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"runq_choose: No KSE on thread"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ke
operator|)
return|;
block|}
name|CTR1
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"runq_choose: idleproc pri=%d"
argument_list|,
name|pri
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove the KSE from the queue specified by its priority, and clear the  * corresponding status bit if the queue becomes empty.  * Caller must set ke->ke_state afterwards.  */
end_comment

begin_function
name|void
name|runq_remove
parameter_list|(
name|struct
name|runq
modifier|*
name|rq
parameter_list|,
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
name|struct
name|rqhead
modifier|*
name|rqh
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ke
operator|->
name|ke_state
operator|==
name|KES_ONRUNQ
operator|)
argument_list|,
operator|(
literal|"KSE not on run queue"
operator|)
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|pri
operator|=
name|ke
operator|->
name|ke_rqindex
expr_stmt|;
name|rqh
operator|=
operator|&
name|rq
operator|->
name|rq_queues
index|[
name|pri
index|]
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"runq_remove: p=%p pri=%d %d rqh=%p"
argument_list|,
name|ke
argument_list|,
name|ke
operator|->
name|ke_thread
operator|->
name|td_priority
argument_list|,
name|pri
argument_list|,
name|rqh
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ke
operator|!=
name|NULL
argument_list|,
operator|(
literal|"runq_remove: no proc on busy queue"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|rqh
argument_list|,
name|ke
argument_list|,
name|ke_procq
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
name|rqh
argument_list|)
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"runq_remove: empty"
argument_list|)
expr_stmt|;
name|runq_clrbit
argument_list|(
name|rq
argument_list|,
name|pri
argument_list|)
expr_stmt|;
block|}
name|ke
operator|->
name|ke_state
operator|=
name|KES_UNQUEUED
expr_stmt|;
name|ke
operator|->
name|ke_ksegrp
operator|->
name|kg_runq_kses
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|runq_readjust
parameter_list|(
name|struct
name|runq
modifier|*
name|rq
parameter_list|,
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
if|if
condition|(
name|ke
operator|->
name|ke_rqindex
operator|!=
operator|(
name|ke
operator|->
name|ke_thread
operator|->
name|td_priority
operator|/
name|RQ_PPQ
operator|)
condition|)
block|{
name|runq_remove
argument_list|(
name|rq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|runq_add
argument_list|(
name|rq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_if
unit|void thread_sanity_check(struct thread *td) { 	struct proc *p; 	struct ksegrp *kg; 	struct kse *ke; 	struct thread *td2; 	unsigned int prevpri; 	int	saw_lastassigned; 	int unassigned; 	int assigned;  	p = td->td_proc; 	kg = td->td_ksegrp; 	ke = td->td_kse;  	if (kg !=&p->p_ksegrp) { 		panic ("wrong ksegrp"); 	}  	if (ke) { 		if (ke !=&p->p_kse) { 			panic("wrong kse"); 		} 		if (ke->ke_thread != td) { 			panic("wrong thread"); 		} 	} 	 	if ((p->p_flag& P_KSES) == 0) { 		if (ke == NULL) { 			panic("non KSE thread lost kse"); 		} 	} else { 		prevpri = 0; 		saw_lastassigned = 0; 		unassigned = 0; 		assigned = 0; 		TAILQ_FOREACH(td2,&kg->kg_runq, td_runq) { 			if (td2->td_priority< prevpri) { 				panic("thread runqueue unosorted"); 			} 			prevpri = td2->td_priority; 			if (td2->td_kse) { 				assigned++; 				if (unassigned) { 					panic("unassigned before assigned"); 				}  				if  (kg->kg_last_assigned == NULL) { 					panic("lastassigned corrupt"); 				} 				if (saw_lastassigned) { 					panic("last assigned not last"); 				} 				if (td2->td_kse->ke_thread != td2) { 					panic("mismatched kse/thread"); 				} 			} else { 				unassigned++; 			} 			if (td2 == kg->kg_last_assigned) { 				saw_lastassigned = 1; 				if (td2->td_kse == NULL) { 					panic("last assigned not assigned"); 				} 			} 		} 		if (kg->kg_last_assigned&& (saw_lastassigned == 0)) { 			panic("where on earth does lastassigned point?"); 		} 		FOREACH_THREAD_IN_GROUP(kg, td2) { 			if (((td2->td_flags& TDF_UNBOUND) == 0)&&  			    (td2->td_state == TDS_RUNQ)) { 				assigned++; 				if (td2->td_kse == NULL) { 					panic ("BOUND thread with no KSE"); 				} 			} 		}
if|#
directive|if
literal|0
end_if

begin_endif
unit|if ((unassigned + assigned) != kg->kg_runnable) { 			panic("wrong number in runnable"); 		}
endif|#
directive|endif
end_endif

begin_endif
unit|} }
endif|#
directive|endif
end_endif

end_unit

