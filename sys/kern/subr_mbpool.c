begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003  *	Fraunhofer Institute for Open Communication Systems (FhG Fokus).  * 	All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Author: Hartmut Brandt<harti@freebsd.org>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbpool.h>
end_include

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|libmbpool
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Memory is allocated as DMA-able pages. Each page is divided into a number  * of equal chunks where the last 4 bytes of each chunk are occupied by  * the page number and the chunk number. The caller must take these four  * bytes into account when specifying the chunk size. Each page is mapped by  * its own DMA map using the user specified DMA tag.  *  * Each chunk has a used and a card bit in the high bits of its page number.  *  0    0	chunk is free and may be allocated  *  1    1	chunk has been given to the interface  *  0    1	chunk is traveling through the system  *  1    0	illegal  */
end_comment

begin_struct
struct|struct
name|mbtrail
block|{
name|uint16_t
name|chunk
decl_stmt|;
name|uint16_t
name|page
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MBP_CARD
value|0x8000
end_define

begin_define
define|#
directive|define
name|MBP_USED
value|0x4000
end_define

begin_define
define|#
directive|define
name|MBP_PMSK
value|0x3fff
end_define

begin_comment
comment|/* page number mask */
end_comment

begin_define
define|#
directive|define
name|MBP_CMSK
value|0x01ff
end_define

begin_comment
comment|/* chunk number mask */
end_comment

begin_struct
struct|struct
name|mbfree
block|{
name|SLIST_ENTRY
argument_list|(
argument|mbfree
argument_list|)
name|link
expr_stmt|;
comment|/* link on free list */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mbpage
block|{
name|bus_dmamap_t
name|map
decl_stmt|;
comment|/* map for this page */
name|bus_addr_t
name|phy
decl_stmt|;
comment|/* physical address */
name|void
modifier|*
name|va
decl_stmt|;
comment|/* the memory */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mbpool
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* a name for this pool */
name|bus_dma_tag_t
name|dmat
decl_stmt|;
comment|/* tag for mapping */
name|u_int
name|max_pages
decl_stmt|;
comment|/* maximum number of pages */
name|size_t
name|page_size
decl_stmt|;
comment|/* size of each allocation */
name|size_t
name|chunk_size
decl_stmt|;
comment|/* size of each external mbuf */
name|struct
name|mtx
name|free_lock
decl_stmt|;
comment|/* lock of free list */
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|mbfree
argument_list|)
name|free_list
expr_stmt|;
comment|/* free list */
name|u_int
name|npages
decl_stmt|;
comment|/* current number of pages */
name|u_int
name|nchunks
decl_stmt|;
comment|/* chunks per page */
name|struct
name|mbpage
name|pages
index|[]
decl_stmt|;
comment|/* pages */
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_MBPOOL
argument_list|,
literal|"mbpools"
argument_list|,
literal|"mbuf pools"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Make a trail pointer from a chunk pointer  */
end_comment

begin_define
define|#
directive|define
name|C2T
parameter_list|(
name|P
parameter_list|,
name|C
parameter_list|)
value|((struct mbtrail *)((char *)(C) + (P)->chunk_size - \ 			    sizeof(struct mbtrail)))
end_define

begin_comment
comment|/*  * Make a free chunk pointer from a chunk number  */
end_comment

begin_define
define|#
directive|define
name|N2C
parameter_list|(
name|P
parameter_list|,
name|PG
parameter_list|,
name|C
parameter_list|)
value|((struct mbfree *)((char *)(PG)->va + \ 			    (C) * (P)->chunk_size))
end_define

begin_comment
comment|/*  * Make/parse handles  */
end_comment

begin_define
define|#
directive|define
name|HMAKE
parameter_list|(
name|P
parameter_list|,
name|C
parameter_list|)
value|((((P)& MBP_PMSK)<< 16) | ((C)<< 7))
end_define

begin_define
define|#
directive|define
name|HPAGE
parameter_list|(
name|H
parameter_list|)
value|(((H)>> 16)& MBP_PMSK)
end_define

begin_define
define|#
directive|define
name|HCHUNK
parameter_list|(
name|H
parameter_list|)
value|(((H)>>  7)& MBP_CMSK)
end_define

begin_comment
comment|/*  * initialize a pool  */
end_comment

begin_function
name|int
name|mbp_create
parameter_list|(
name|struct
name|mbpool
modifier|*
modifier|*
name|pp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bus_dma_tag_t
name|dmat
parameter_list|,
name|u_int
name|max_pages
parameter_list|,
name|size_t
name|page_size
parameter_list|,
name|size_t
name|chunk_size
parameter_list|)
block|{
name|u_int
name|nchunks
decl_stmt|;
if|if
condition|(
name|max_pages
operator|>
name|MBPOOL_MAX_MAXPAGES
operator|||
name|chunk_size
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|nchunks
operator|=
name|page_size
operator|/
name|chunk_size
expr_stmt|;
if|if
condition|(
name|nchunks
operator|==
literal|0
operator|||
name|nchunks
operator|>
name|MBPOOL_MAX_CHUNKS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|(
operator|*
name|pp
operator|)
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mbpool
argument_list|)
operator|+
name|max_pages
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mbpage
argument_list|)
argument_list|,
name|M_MBPOOL
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|->
name|name
operator|=
name|name
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|->
name|dmat
operator|=
name|dmat
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|->
name|max_pages
operator|=
name|max_pages
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|->
name|page_size
operator|=
name|page_size
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|->
name|chunk_size
operator|=
name|chunk_size
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|->
name|nchunks
operator|=
name|nchunks
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|free_list
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|free_lock
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * destroy a pool  */
end_comment

begin_function
name|void
name|mbp_destroy
parameter_list|(
name|struct
name|mbpool
modifier|*
name|p
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|struct
name|mbpage
modifier|*
name|pg
decl_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|struct
name|mbtrail
modifier|*
name|tr
decl_stmt|;
name|u_int
name|b
decl_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|npages
condition|;
name|i
operator|++
control|)
block|{
name|pg
operator|=
operator|&
name|p
operator|->
name|pages
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|p
operator|->
name|nchunks
condition|;
name|b
operator|++
control|)
block|{
name|tr
operator|=
name|C2T
argument_list|(
name|p
argument_list|,
name|N2C
argument_list|(
name|p
argument_list|,
name|pg
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|page
operator|&
name|MBP_CARD
condition|)
name|printf
argument_list|(
literal|"%s: (%s) buf still on card"
literal|" %u/%u\n"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|i
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|page
operator|&
name|MBP_USED
condition|)
name|printf
argument_list|(
literal|"%s: (%s) sbuf still in use"
literal|" %u/%u\n"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|i
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|bus_dmamap_unload
argument_list|(
name|p
operator|->
name|dmat
argument_list|,
name|pg
operator|->
name|map
argument_list|)
expr_stmt|;
name|bus_dmamem_free
argument_list|(
name|p
operator|->
name|dmat
argument_list|,
name|pg
operator|->
name|va
argument_list|,
name|pg
operator|->
name|map
argument_list|)
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|p
operator|->
name|free_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|,
name|M_MBPOOL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Helper function when loading a one segment DMA buffer.  */
end_comment

begin_function
specifier|static
name|void
name|mbp_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new page  */
end_comment

begin_function
specifier|static
name|void
name|mbp_alloc_page
parameter_list|(
name|struct
name|mbpool
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|mbpage
modifier|*
name|pg
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|struct
name|mbfree
modifier|*
name|f
decl_stmt|;
name|struct
name|mbtrail
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|npages
operator|==
name|p
operator|->
name|max_pages
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|printf
argument_list|(
literal|"%s: (%s) page limit reached %u\n"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|max_pages
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|pg
operator|=
operator|&
name|p
operator|->
name|pages
index|[
name|p
operator|->
name|npages
index|]
expr_stmt|;
name|error
operator|=
name|bus_dmamem_alloc
argument_list|(
name|p
operator|->
name|dmat
argument_list|,
operator|&
name|pg
operator|->
name|va
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|,
operator|&
name|pg
operator|->
name|map
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|pg
argument_list|,
name|M_MBPOOL
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
operator|=
name|bus_dmamap_load
argument_list|(
name|p
operator|->
name|dmat
argument_list|,
name|pg
operator|->
name|map
argument_list|,
name|pg
operator|->
name|va
argument_list|,
name|p
operator|->
name|page_size
argument_list|,
name|mbp_callback
argument_list|,
operator|&
name|pg
operator|->
name|phy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|p
operator|->
name|dmat
argument_list|,
name|pg
operator|->
name|va
argument_list|,
name|pg
operator|->
name|map
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pg
argument_list|,
name|M_MBPOOL
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|nchunks
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|=
name|N2C
argument_list|(
name|p
argument_list|,
name|pg
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|t
operator|=
name|C2T
argument_list|(
name|p
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|t
operator|->
name|page
operator|=
name|p
operator|->
name|npages
expr_stmt|;
name|t
operator|->
name|chunk
operator|=
name|i
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|p
operator|->
name|free_list
argument_list|,
name|f
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|npages
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * allocate a chunk  */
end_comment

begin_function
name|void
modifier|*
name|mbp_alloc
parameter_list|(
name|struct
name|mbpool
modifier|*
name|p
parameter_list|,
name|bus_addr_t
modifier|*
name|pap
parameter_list|,
name|uint32_t
modifier|*
name|hp
parameter_list|)
block|{
name|struct
name|mbfree
modifier|*
name|cf
decl_stmt|;
name|struct
name|mbtrail
modifier|*
name|t
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|p
operator|->
name|free_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cf
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|p
operator|->
name|free_list
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mbp_alloc_page
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|cf
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|p
operator|->
name|free_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cf
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|p
operator|->
name|free_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|p
operator|->
name|free_list
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|p
operator|->
name|free_lock
argument_list|)
expr_stmt|;
name|t
operator|=
name|C2T
argument_list|(
name|p
argument_list|,
name|cf
argument_list|)
expr_stmt|;
operator|*
name|pap
operator|=
name|p
operator|->
name|pages
index|[
name|t
operator|->
name|page
index|]
operator|.
name|phy
operator|+
name|t
operator|->
name|chunk
operator|*
name|p
operator|->
name|chunk_size
expr_stmt|;
operator|*
name|hp
operator|=
name|HMAKE
argument_list|(
name|t
operator|->
name|page
argument_list|,
name|t
operator|->
name|chunk
argument_list|)
expr_stmt|;
name|t
operator|->
name|page
operator||=
name|MBP_CARD
operator||
name|MBP_USED
expr_stmt|;
return|return
operator|(
name|cf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a chunk  */
end_comment

begin_function
name|void
name|mbp_free
parameter_list|(
name|struct
name|mbpool
modifier|*
name|p
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|mbtrail
modifier|*
name|t
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|p
operator|->
name|free_lock
argument_list|)
expr_stmt|;
name|t
operator|=
name|C2T
argument_list|(
name|p
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|t
operator|->
name|page
operator|&=
operator|~
operator|(
name|MBP_USED
operator||
name|MBP_CARD
operator|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|p
operator|->
name|free_list
argument_list|,
operator|(
expr|struct
name|mbfree
operator|*
operator|)
name|ptr
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|p
operator|->
name|free_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mbuf system external mbuf free routine  */
end_comment

begin_function
name|void
name|mbp_ext_free
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|mbp_free
argument_list|(
name|arg
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free all buffers that are marked as beeing on the card  */
end_comment

begin_function
name|void
name|mbp_card_free
parameter_list|(
name|struct
name|mbpool
modifier|*
name|p
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|,
name|b
decl_stmt|;
name|struct
name|mbpage
modifier|*
name|pg
decl_stmt|;
name|struct
name|mbtrail
modifier|*
name|tr
decl_stmt|;
name|struct
name|mbfree
modifier|*
name|cf
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|p
operator|->
name|free_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|npages
condition|;
name|i
operator|++
control|)
block|{
name|pg
operator|=
operator|&
name|p
operator|->
name|pages
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|p
operator|->
name|nchunks
condition|;
name|b
operator|++
control|)
block|{
name|cf
operator|=
name|N2C
argument_list|(
name|p
argument_list|,
name|pg
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|tr
operator|=
name|C2T
argument_list|(
name|p
argument_list|,
name|cf
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|page
operator|&
name|MBP_CARD
condition|)
block|{
name|tr
operator|->
name|page
operator|&=
name|MBP_PMSK
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|p
operator|->
name|free_list
argument_list|,
name|cf
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|p
operator|->
name|free_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Count buffers  */
end_comment

begin_function
name|void
name|mbp_count
parameter_list|(
name|struct
name|mbpool
modifier|*
name|p
parameter_list|,
name|u_int
modifier|*
name|used
parameter_list|,
name|u_int
modifier|*
name|card
parameter_list|,
name|u_int
modifier|*
name|free
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|,
name|b
decl_stmt|;
name|struct
name|mbpage
modifier|*
name|pg
decl_stmt|;
name|struct
name|mbtrail
modifier|*
name|tr
decl_stmt|;
name|struct
name|mbfree
modifier|*
name|cf
decl_stmt|;
operator|*
name|used
operator|=
operator|*
name|card
operator|=
operator|*
name|free
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|p
operator|->
name|npages
condition|;
name|i
operator|++
control|)
block|{
name|pg
operator|=
operator|&
name|p
operator|->
name|pages
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|b
operator|=
literal|0
init|;
name|b
operator|<
name|p
operator|->
name|nchunks
condition|;
name|b
operator|++
control|)
block|{
name|tr
operator|=
name|C2T
argument_list|(
name|p
argument_list|,
name|N2C
argument_list|(
name|p
argument_list|,
name|pg
argument_list|,
name|b
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|page
operator|&
name|MBP_CARD
condition|)
operator|(
operator|*
name|card
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|page
operator|&
name|MBP_USED
condition|)
operator|(
operator|*
name|used
operator|)
operator|++
expr_stmt|;
block|}
block|}
name|mtx_lock
argument_list|(
operator|&
name|p
operator|->
name|free_lock
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
name|cf
argument_list|,
operator|&
name|p
operator|->
name|free_list
argument_list|,
name|link
argument_list|)
argument_list|(
operator|*
name|free
argument_list|)
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|p
operator|->
name|free_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get the buffer from a handle and clear the card flag.  */
end_comment

begin_function
name|void
modifier|*
name|mbp_get
parameter_list|(
name|struct
name|mbpool
modifier|*
name|p
parameter_list|,
name|uint32_t
name|h
parameter_list|)
block|{
name|struct
name|mbfree
modifier|*
name|cf
decl_stmt|;
name|struct
name|mbtrail
modifier|*
name|tr
decl_stmt|;
name|cf
operator|=
name|N2C
argument_list|(
name|p
argument_list|,
operator|&
name|p
operator|->
name|pages
index|[
name|HPAGE
argument_list|(
name|h
argument_list|)
index|]
argument_list|,
name|HCHUNK
argument_list|(
name|h
argument_list|)
argument_list|)
expr_stmt|;
name|tr
operator|=
name|C2T
argument_list|(
name|p
argument_list|,
name|cf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|tr
operator|->
name|page
operator|&
name|MBP_CARD
operator|)
condition|)
name|printf
argument_list|(
literal|"%s: (%s) chunk %u page %u not on card\n"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|HCHUNK
argument_list|(
name|h
argument_list|)
argument_list|,
name|HPAGE
argument_list|(
name|h
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tr
operator|->
name|page
operator|&=
operator|~
name|MBP_CARD
expr_stmt|;
return|return
operator|(
name|cf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the buffer from a handle and keep the card flag.  */
end_comment

begin_function
name|void
modifier|*
name|mbp_get_keep
parameter_list|(
name|struct
name|mbpool
modifier|*
name|p
parameter_list|,
name|uint32_t
name|h
parameter_list|)
block|{
name|struct
name|mbfree
modifier|*
name|cf
decl_stmt|;
name|struct
name|mbtrail
modifier|*
name|tr
decl_stmt|;
name|cf
operator|=
name|N2C
argument_list|(
name|p
argument_list|,
operator|&
name|p
operator|->
name|pages
index|[
name|HPAGE
argument_list|(
name|h
argument_list|)
index|]
argument_list|,
name|HCHUNK
argument_list|(
name|h
argument_list|)
argument_list|)
expr_stmt|;
name|tr
operator|=
name|C2T
argument_list|(
name|p
argument_list|,
name|cf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|tr
operator|->
name|page
operator|&
name|MBP_CARD
operator|)
condition|)
name|printf
argument_list|(
literal|"%s: (%s) chunk %u page %u not on card\n"
argument_list|,
name|__func__
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|HCHUNK
argument_list|(
name|h
argument_list|)
argument_list|,
name|HPAGE
argument_list|(
name|h
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|cf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * sync the chunk  */
end_comment

begin_function
name|void
name|mbp_sync
parameter_list|(
name|struct
name|mbpool
modifier|*
name|p
parameter_list|,
name|uint32_t
name|h
parameter_list|,
name|bus_addr_t
name|off
parameter_list|,
name|bus_size_t
name|len
parameter_list|,
name|u_int
name|op
parameter_list|)
block|{
if|#
directive|if
literal|0
block|bus_dmamap_sync_size(p->dmat, p->pages[HPAGE(h)].map, 	    HCHUNK(h) * p->chunk_size + off, len, op);
endif|#
directive|endif
block|}
end_function

end_unit

