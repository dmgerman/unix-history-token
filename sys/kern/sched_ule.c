begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003, Jeffrey Roberson<jeff@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_comment
comment|/* decay 95% of `p_pctcpu' in 60 seconds; see CCPU_SHIFT before changing */
end_comment

begin_comment
comment|/* XXX This is bogus compatability crap for ps */
end_comment

begin_decl_stmt
specifier|static
name|fixpt_t
name|ccpu
init|=
literal|0.95122942450071400909
operator|*
name|FSCALE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* exp(-1/20) */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|ccpu
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ccpu
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|sched_setup
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_macro
name|SYSINIT
argument_list|(
argument|sched_setup
argument_list|,
argument|SI_SUB_RUN_QUEUE
argument_list|,
argument|SI_ORDER_FIRST
argument_list|,
argument|sched_setup
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_comment
comment|/*  * These datastructures are allocated within their parent datastructure but  * are scheduler specific.  */
end_comment

begin_struct
struct|struct
name|ke_sched
block|{
name|int
name|ske_slice
decl_stmt|;
name|struct
name|runq
modifier|*
name|ske_runq
decl_stmt|;
comment|/* The following variables are only used for pctcpu calculation */
name|int
name|ske_ltick
decl_stmt|;
comment|/* Last tick that we were running on */
name|int
name|ske_ftick
decl_stmt|;
comment|/* First tick that we were running on */
name|int
name|ske_ticks
decl_stmt|;
comment|/* Tick count */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ke_slice
value|ke_sched->ske_slice
end_define

begin_define
define|#
directive|define
name|ke_runq
value|ke_sched->ske_runq
end_define

begin_define
define|#
directive|define
name|ke_ltick
value|ke_sched->ske_ltick
end_define

begin_define
define|#
directive|define
name|ke_ftick
value|ke_sched->ske_ftick
end_define

begin_define
define|#
directive|define
name|ke_ticks
value|ke_sched->ske_ticks
end_define

begin_struct
struct|struct
name|kg_sched
block|{
name|int
name|skg_slptime
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|kg_slptime
value|kg_sched->skg_slptime
end_define

begin_struct
struct|struct
name|td_sched
block|{
name|int
name|std_slptime
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|td_slptime
value|td_sched->std_slptime
end_define

begin_decl_stmt
name|struct
name|ke_sched
name|ke_sched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|kg_sched
name|kg_sched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|td_sched
name|td_sched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ke_sched
modifier|*
name|kse0_sched
init|=
operator|&
name|ke_sched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|kg_sched
modifier|*
name|ksegrp0_sched
init|=
operator|&
name|kg_sched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|p_sched
modifier|*
name|proc0_sched
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|td_sched
modifier|*
name|thread0_sched
init|=
operator|&
name|td_sched
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This priority range has 20 priorities on either end that are reachable  * only through nice values.  */
end_comment

begin_define
define|#
directive|define
name|SCHED_PRI_NRESV
value|40
end_define

begin_define
define|#
directive|define
name|SCHED_PRI_RANGE
value|((PRI_MAX_TIMESHARE - PRI_MIN_TIMESHARE + 1) - \     SCHED_PRI_NRESV)
end_define

begin_comment
comment|/*  * These determine how sleep time effects the priority of a process.  *  * SLP_MAX:	Maximum amount of accrued sleep time.  * SLP_SCALE:	Scale the number of ticks slept across the dynamic priority  *		range.  * SLP_TOPRI:	Convert a number of ticks slept into a priority value.  * SLP_DECAY:	Reduce the sleep time to 50% for every granted slice.  */
end_comment

begin_define
define|#
directive|define
name|SCHED_SLP_MAX
value|(hz * 2)
end_define

begin_define
define|#
directive|define
name|SCHED_SLP_SCALE
parameter_list|(
name|slp
parameter_list|)
value|(((slp) * SCHED_PRI_RANGE) / SCHED_SLP_MAX)
end_define

begin_define
define|#
directive|define
name|SCHED_SLP_TOPRI
parameter_list|(
name|slp
parameter_list|)
value|(SCHED_PRI_RANGE - SCHED_SLP_SCALE((slp)) + \     SCHED_PRI_NRESV / 2)
end_define

begin_define
define|#
directive|define
name|SCHED_SLP_DECAY
parameter_list|(
name|slp
parameter_list|)
value|((slp) / 2)
end_define

begin_comment
comment|/* XXX Multiple kses break */
end_comment

begin_comment
comment|/*  * These parameters and macros determine the size of the time slice that is  * granted to each thread.  *  * SLICE_MIN:	Minimum time slice granted, in units of ticks.  * SLICE_MAX:	Maximum time slice granted.  * SLICE_RANGE:	Range of available time slices scaled by hz.  * SLICE_SCALE:	The number slices granted per unit of pri or slp.  * PRI_TOSLICE:	Compute a slice size that is proportional to the priority.  * SLP_TOSLICE:	Compute a slice size that is inversely proportional to the  *		amount of time slept. (smaller slices for interactive ksegs)  * PRI_COMP:	This determines what fraction of the actual slice comes from   *		the slice size computed from the priority.  * SLP_COMP:	This determines what component of the actual slice comes from  *		the slize size computed from the sleep time.  */
end_comment

begin_define
define|#
directive|define
name|SCHED_SLICE_MIN
value|(hz / 100)
end_define

begin_define
define|#
directive|define
name|SCHED_SLICE_MAX
value|(hz / 10)
end_define

begin_define
define|#
directive|define
name|SCHED_SLICE_RANGE
value|(SCHED_SLICE_MAX - SCHED_SLICE_MIN + 1)
end_define

begin_define
define|#
directive|define
name|SCHED_SLICE_SCALE
parameter_list|(
name|val
parameter_list|,
name|max
parameter_list|)
value|(((val) * SCHED_SLICE_RANGE) / (max))
end_define

begin_define
define|#
directive|define
name|SCHED_PRI_TOSLICE
parameter_list|(
name|pri
parameter_list|)
define|\
value|(SCHED_SLICE_MAX - SCHED_SLICE_SCALE((pri), SCHED_PRI_RANGE))
end_define

begin_define
define|#
directive|define
name|SCHED_SLP_TOSLICE
parameter_list|(
name|slp
parameter_list|)
define|\
value|(SCHED_SLICE_MAX - SCHED_SLICE_SCALE((slp), SCHED_SLP_MAX))
end_define

begin_define
define|#
directive|define
name|SCHED_SLP_COMP
parameter_list|(
name|slice
parameter_list|)
value|(((slice) / 5) * 3)
end_define

begin_comment
comment|/* 60% */
end_comment

begin_define
define|#
directive|define
name|SCHED_PRI_COMP
parameter_list|(
name|slice
parameter_list|)
value|(((slice) / 5) * 2)
end_define

begin_comment
comment|/* 40% */
end_comment

begin_comment
comment|/*  * This macro determines whether or not the kse belongs on the current or  * next run queue.  */
end_comment

begin_define
define|#
directive|define
name|SCHED_CURR
parameter_list|(
name|kg
parameter_list|)
value|((kg)->kg_slptime> (hz / 4) || \     (kg)->kg_pri_class != PRI_TIMESHARE)
end_define

begin_comment
comment|/*  * Cpu percentage computation macros and defines.  *  * SCHED_CPU_TIME:	Number of seconds to average the cpu usage across.  * SCHED_CPU_TICKS:	Number of hz ticks to average the cpu usage across.  */
end_comment

begin_define
define|#
directive|define
name|SCHED_CPU_TIME
value|60
end_define

begin_define
define|#
directive|define
name|SCHED_CPU_TICKS
value|(hz * SCHED_CPU_TIME)
end_define

begin_comment
comment|/*  * kseq - pair of runqs per processor  */
end_comment

begin_struct
struct|struct
name|kseq
block|{
name|struct
name|runq
name|ksq_runqs
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|runq
modifier|*
name|ksq_curr
decl_stmt|;
name|struct
name|runq
modifier|*
name|ksq_next
decl_stmt|;
name|int
name|ksq_load
decl_stmt|;
comment|/* Total runnable */
block|}
struct|;
end_struct

begin_comment
comment|/*  * One kse queue per processor.  */
end_comment

begin_decl_stmt
name|struct
name|kseq
name|kseq_cpu
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|sched_slice
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sched_priority
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sched_pctcpu_update
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sched_pickcpu
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|sched_setup
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
comment|/* init kseqs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
block|{
name|kseq_cpu
index|[
name|i
index|]
operator|.
name|ksq_load
operator|=
literal|0
expr_stmt|;
name|kseq_cpu
index|[
name|i
index|]
operator|.
name|ksq_curr
operator|=
operator|&
name|kseq_cpu
index|[
name|i
index|]
operator|.
name|ksq_runqs
index|[
literal|0
index|]
expr_stmt|;
name|kseq_cpu
index|[
name|i
index|]
operator|.
name|ksq_next
operator|=
operator|&
name|kseq_cpu
index|[
name|i
index|]
operator|.
name|ksq_runqs
index|[
literal|1
index|]
expr_stmt|;
name|runq_init
argument_list|(
name|kseq_cpu
index|[
name|i
index|]
operator|.
name|ksq_curr
argument_list|)
expr_stmt|;
name|runq_init
argument_list|(
name|kseq_cpu
index|[
name|i
index|]
operator|.
name|ksq_next
argument_list|)
expr_stmt|;
block|}
comment|/* CPU0 has proc0 */
name|kseq_cpu
index|[
literal|0
index|]
operator|.
name|ksq_load
operator|++
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Scale the scheduling priority according to the "interactivity" of this  * process.  */
end_comment

begin_function
specifier|static
name|int
name|sched_priority
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|)
block|{
name|int
name|pri
decl_stmt|;
if|if
condition|(
name|kg
operator|->
name|kg_pri_class
operator|!=
name|PRI_TIMESHARE
condition|)
return|return
operator|(
name|kg
operator|->
name|kg_user_pri
operator|)
return|;
name|pri
operator|=
name|SCHED_SLP_TOPRI
argument_list|(
name|kg
operator|->
name|kg_slptime
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"sched_priority: slptime: %d\tpri: %d"
argument_list|,
name|kg
operator|->
name|kg_slptime
argument_list|,
name|pri
argument_list|)
expr_stmt|;
name|pri
operator|+=
name|PRI_MIN_TIMESHARE
expr_stmt|;
name|pri
operator|+=
name|kg
operator|->
name|kg_nice
expr_stmt|;
if|if
condition|(
name|pri
operator|>
name|PRI_MAX_TIMESHARE
condition|)
name|pri
operator|=
name|PRI_MAX_TIMESHARE
expr_stmt|;
elseif|else
if|if
condition|(
name|pri
operator|<
name|PRI_MIN_TIMESHARE
condition|)
name|pri
operator|=
name|PRI_MIN_TIMESHARE
expr_stmt|;
name|kg
operator|->
name|kg_user_pri
operator|=
name|pri
expr_stmt|;
return|return
operator|(
name|kg
operator|->
name|kg_user_pri
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate a time slice based on the process priority.  */
end_comment

begin_function
specifier|static
name|int
name|sched_slice
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|)
block|{
name|int
name|pslice
decl_stmt|;
name|int
name|sslice
decl_stmt|;
name|int
name|slice
decl_stmt|;
name|int
name|pri
decl_stmt|;
name|pri
operator|=
name|kg
operator|->
name|kg_user_pri
expr_stmt|;
name|pri
operator|-=
name|PRI_MIN_TIMESHARE
expr_stmt|;
name|pslice
operator|=
name|SCHED_PRI_TOSLICE
argument_list|(
name|pri
argument_list|)
expr_stmt|;
name|sslice
operator|=
name|SCHED_SLP_TOSLICE
argument_list|(
name|kg
operator|->
name|kg_slptime
argument_list|)
expr_stmt|;
name|slice
operator|=
name|SCHED_SLP_COMP
argument_list|(
name|sslice
argument_list|)
operator|+
name|SCHED_PRI_COMP
argument_list|(
name|pslice
argument_list|)
expr_stmt|;
name|kg
operator|->
name|kg_slptime
operator|=
name|SCHED_SLP_DECAY
argument_list|(
name|kg
operator|->
name|kg_slptime
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"sched_slice: pri: %d\tsslice: %d\tpslice: %d\tslice: %d"
argument_list|,
name|pri
argument_list|,
name|sslice
argument_list|,
name|pslice
argument_list|,
name|slice
argument_list|)
expr_stmt|;
if|if
condition|(
name|slice
operator|<
name|SCHED_SLICE_MIN
condition|)
name|slice
operator|=
name|SCHED_SLICE_MIN
expr_stmt|;
elseif|else
if|if
condition|(
name|slice
operator|>
name|SCHED_SLICE_MAX
condition|)
name|slice
operator|=
name|SCHED_SLICE_MAX
expr_stmt|;
return|return
operator|(
name|slice
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sched_rr_interval
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|SCHED_SLICE_MAX
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sched_pctcpu_update
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
comment|/* 	 * Adjust counters and watermark for pctcpu calc. 	 */
name|ke
operator|->
name|ke_ticks
operator|=
operator|(
name|ke
operator|->
name|ke_ticks
operator|/
operator|(
name|ke
operator|->
name|ke_ltick
operator|-
name|ke
operator|->
name|ke_ftick
operator|)
operator|)
operator|*
name|SCHED_CPU_TICKS
expr_stmt|;
name|ke
operator|->
name|ke_ltick
operator|=
name|ticks
expr_stmt|;
name|ke
operator|->
name|ke_ftick
operator|=
name|ke
operator|->
name|ke_ltick
operator|-
name|SCHED_CPU_TICKS
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function
name|int
name|sched_pickcpu
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|cpu
decl_stmt|;
name|int
name|load
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|smp_started
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|load
operator|=
name|kseq_cpu
index|[
name|cpu
index|]
operator|.
name|ksq_load
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp_maxid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|kseq_cpu
index|[
name|i
index|]
operator|.
name|ksq_load
operator|<
name|load
condition|)
block|{
name|cpu
operator|=
name|i
expr_stmt|;
name|load
operator|=
name|kseq_cpu
index|[
name|i
index|]
operator|.
name|ksq_load
expr_stmt|;
block|}
block|}
name|CTR1
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"sched_pickcpu: %d"
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
return|return
operator|(
name|cpu
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|int
name|sched_pickcpu
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|sched_prio
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|u_char
name|prio
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|struct
name|runq
modifier|*
name|rq
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|td
operator|->
name|td_priority
operator|=
name|prio
expr_stmt|;
if|if
condition|(
name|TD_ON_RUNQ
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|rq
operator|=
name|ke
operator|->
name|ke_runq
expr_stmt|;
name|runq_remove
argument_list|(
name|rq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|runq_add
argument_list|(
name|rq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sched_switchout
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|td
operator|->
name|td_last_kse
operator|=
name|ke
expr_stmt|;
name|td
operator|->
name|td_lastcpu
operator|=
name|ke
operator|->
name|ke_oncpu
expr_stmt|;
name|ke
operator|->
name|ke_flags
operator|&=
operator|~
name|KEF_NEEDRESCHED
expr_stmt|;
if|if
condition|(
name|TD_IS_RUNNING
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|setrunqueue
argument_list|(
name|td
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|td
operator|->
name|td_kse
operator|->
name|ke_runq
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * We will not be on the run queue. So we must be 	 * sleeping or similar. 	 */
if|if
condition|(
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator|&
name|P_KSES
condition|)
name|kse_reassign
argument_list|(
name|ke
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_switchin
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
comment|/* struct kse *ke = td->td_kse; */
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_kse
operator|->
name|ke_oncpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|td
operator|->
name|td_ksegrp
operator|->
name|kg_pri_class
operator|==
name|PRI_TIMESHARE
operator|&&
name|td
operator|->
name|td_priority
operator|!=
name|td
operator|->
name|td_ksegrp
operator|->
name|kg_user_pri
condition|)
name|curthread
operator|->
name|td_kse
operator|->
name|ke_flags
operator||=
name|KEF_NEEDRESCHED
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_nice
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|,
name|int
name|nice
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|kg
operator|->
name|kg_nice
operator|=
name|nice
expr_stmt|;
name|sched_priority
argument_list|(
name|kg
argument_list|)
expr_stmt|;
name|FOREACH_THREAD_IN_GROUP
argument_list|(
argument|kg
argument_list|,
argument|td
argument_list|)
block|{
name|td
operator|->
name|td_kse
operator|->
name|ke_flags
operator||=
name|KEF_NEEDRESCHED
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sched_sleep
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|u_char
name|prio
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_slptime
operator|=
name|ticks
expr_stmt|;
name|td
operator|->
name|td_priority
operator|=
name|prio
expr_stmt|;
comment|/* 	 * If this is an interactive task clear its queue so it moves back 	 * on to curr when it wakes up.  Otherwise let it stay on the queue 	 * that it was assigned to. 	 */
if|if
condition|(
name|SCHED_CURR
argument_list|(
name|td
operator|->
name|td_kse
operator|->
name|ke_ksegrp
argument_list|)
condition|)
name|td
operator|->
name|td_kse
operator|->
name|ke_runq
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_wakeup
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Let the kseg know how long we slept for.  This is because process 	 * interactivity behavior is modeled in the kseg. 	 */
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_slptime
condition|)
block|{
name|kg
operator|->
name|kg_slptime
operator|+=
name|ticks
operator|-
name|td
operator|->
name|td_slptime
expr_stmt|;
if|if
condition|(
name|kg
operator|->
name|kg_slptime
operator|>
name|SCHED_SLP_MAX
condition|)
name|kg
operator|->
name|kg_slptime
operator|=
name|SCHED_SLP_MAX
expr_stmt|;
name|td
operator|->
name|td_priority
operator|=
name|sched_priority
argument_list|(
name|kg
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_slptime
operator|=
literal|0
expr_stmt|;
name|setrunqueue
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_priority
operator|<
name|curthread
operator|->
name|td_priority
condition|)
name|curthread
operator|->
name|td_kse
operator|->
name|ke_flags
operator||=
name|KEF_NEEDRESCHED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Penalize the parent for creating a new child and initialize the child's  * priority.  */
end_comment

begin_function
name|void
name|sched_fork
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|,
name|struct
name|ksegrp
modifier|*
name|child
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ckse
decl_stmt|;
name|struct
name|kse
modifier|*
name|pkse
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ckse
operator|=
name|FIRST_KSE_IN_KSEGRP
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|pkse
operator|=
name|FIRST_KSE_IN_KSEGRP
argument_list|(
name|kg
argument_list|)
expr_stmt|;
comment|/* XXX Need something better here */
name|child
operator|->
name|kg_slptime
operator|=
name|kg
operator|->
name|kg_slptime
expr_stmt|;
name|child
operator|->
name|kg_user_pri
operator|=
name|kg
operator|->
name|kg_user_pri
expr_stmt|;
name|ckse
operator|->
name|ke_slice
operator|=
name|pkse
operator|->
name|ke_slice
expr_stmt|;
name|ckse
operator|->
name|ke_oncpu
operator|=
name|sched_pickcpu
argument_list|()
expr_stmt|;
name|ckse
operator|->
name|ke_runq
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Claim that we've been running for one second for statistical 	 * purposes. 	 */
name|ckse
operator|->
name|ke_ticks
operator|=
literal|0
expr_stmt|;
name|ckse
operator|->
name|ke_ltick
operator|=
name|ticks
expr_stmt|;
name|ckse
operator|->
name|ke_ftick
operator|=
name|ticks
operator|-
name|hz
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return some of the child's priority and interactivity to the parent.  */
end_comment

begin_function
name|void
name|sched_exit
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|,
name|struct
name|ksegrp
modifier|*
name|child
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
comment|/* XXX Need something better here */
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|kg
operator|->
name|kg_slptime
operator|=
name|child
operator|->
name|kg_slptime
expr_stmt|;
name|sched_priority
argument_list|(
name|kg
argument_list|)
expr_stmt|;
comment|/* 	 * We drop the load here so that the running process leaves us with a 	 * load of at least one. 	 */
name|ke
operator|=
name|FIRST_KSE_IN_KSEGRP
argument_list|(
name|kg
argument_list|)
expr_stmt|;
name|kseq
operator|=
operator|&
name|kseq_cpu
index|[
name|ke
operator|->
name|ke_oncpu
index|]
expr_stmt|;
name|kseq
operator|->
name|ksq_load
operator|--
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|sched_clock_switches
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|sched_clock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|struct
name|kse
modifier|*
name|nke
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|int
name|cpu
decl_stmt|;
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|kseq
operator|=
operator|&
name|kseq_cpu
index|[
name|cpu
index|]
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|td
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"schedclock: null thread pointer"
operator|)
argument_list|)
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
name|nke
operator|=
name|runq_choose
argument_list|(
name|kseq
operator|->
name|ksq_curr
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_kse
operator|->
name|ke_flags
operator|&
name|KEF_IDLEKSE
condition|)
block|{
if|#
directive|if
literal|0
block|if (nke&& nke->ke_ksegrp->kg_pri_class == PRI_TIMESHARE) { 			printf("Idle running with %s on the runq!\n", 			    nke->ke_proc->p_comm); 			Debugger("stop"); 		}
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|nke
operator|&&
name|nke
operator|->
name|ke_thread
operator|&&
name|nke
operator|->
name|ke_thread
operator|->
name|td_priority
operator|<
name|td
operator|->
name|td_priority
condition|)
block|{
name|sched_clock_switches
operator|++
expr_stmt|;
name|ke
operator|->
name|ke_flags
operator||=
name|KEF_NEEDRESCHED
expr_stmt|;
block|}
comment|/* 	 * We used a tick, decrease our total sleep time.  This decreases our 	 * "interactivity". 	 */
if|if
condition|(
name|kg
operator|->
name|kg_slptime
condition|)
name|kg
operator|->
name|kg_slptime
operator|--
expr_stmt|;
comment|/* 	 * We used up one time slice. 	 */
name|ke
operator|->
name|ke_slice
operator|--
expr_stmt|;
comment|/* 	 * We're out of time, recompute priorities and requeue 	 */
if|if
condition|(
name|ke
operator|->
name|ke_slice
operator|==
literal|0
condition|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|kseq
operator|=
operator|&
name|kseq_cpu
index|[
name|ke
operator|->
name|ke_oncpu
index|]
expr_stmt|;
name|td
operator|->
name|td_priority
operator|=
name|sched_priority
argument_list|(
name|kg
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_slice
operator|=
name|sched_slice
argument_list|(
name|kg
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_flags
operator||=
name|KEF_NEEDRESCHED
expr_stmt|;
name|ke
operator|->
name|ke_runq
operator|=
name|NULL
expr_stmt|;
block|}
name|ke
operator|->
name|ke_ticks
operator|+=
literal|10000
expr_stmt|;
name|ke
operator|->
name|ke_ltick
operator|=
name|ticks
expr_stmt|;
comment|/* Go up to one second beyond our max and then trim back down */
if|if
condition|(
name|ke
operator|->
name|ke_ftick
operator|+
name|SCHED_CPU_TICKS
operator|+
name|hz
operator|<
name|ke
operator|->
name|ke_ltick
condition|)
name|sched_pctcpu_update
argument_list|(
name|ke
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sched_runnable
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|int
name|cpu
decl_stmt|;
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|kseq
operator|=
operator|&
name|kseq_cpu
index|[
name|cpu
index|]
expr_stmt|;
if|if
condition|(
name|runq_check
argument_list|(
name|kseq
operator|->
name|ksq_curr
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|runq_check
argument_list|(
name|kseq
operator|->
name|ksq_next
argument_list|)
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sched_userret
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_priority
operator|!=
name|kg
operator|->
name|kg_user_pri
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_priority
operator|=
name|kg
operator|->
name|kg_user_pri
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|kse
modifier|*
name|sched_choose
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|struct
name|runq
modifier|*
name|swap
decl_stmt|;
name|int
name|cpu
decl_stmt|;
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|kseq
operator|=
operator|&
name|kseq_cpu
index|[
name|cpu
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ke
operator|=
name|runq_choose
argument_list|(
name|kseq
operator|->
name|ksq_curr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|swap
operator|=
name|kseq
operator|->
name|ksq_curr
expr_stmt|;
name|kseq
operator|->
name|ksq_curr
operator|=
name|kseq
operator|->
name|ksq_next
expr_stmt|;
name|kseq
operator|->
name|ksq_next
operator|=
name|swap
expr_stmt|;
name|ke
operator|=
name|runq_choose
argument_list|(
name|kseq
operator|->
name|ksq_curr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ke
condition|)
block|{
name|runq_remove
argument_list|(
name|ke
operator|->
name|ke_runq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_state
operator|=
name|KES_THREAD
expr_stmt|;
block|}
return|return
operator|(
name|ke
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sched_add
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|int
name|cpu
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ke
operator|->
name|ke_thread
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"runq_add: No thread on KSE"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ke
operator|->
name|ke_thread
operator|->
name|td_kse
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"runq_add: No KSE on thread"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ke
operator|->
name|ke_state
operator|!=
name|KES_ONRUNQ
argument_list|,
operator|(
literal|"runq_add: kse %p (%s) already in run queue"
operator|,
name|ke
operator|,
name|ke
operator|->
name|ke_proc
operator|->
name|p_comm
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ke
operator|->
name|ke_proc
operator|->
name|p_sflag
operator|&
name|PS_INMEM
argument_list|,
operator|(
literal|"runq_add: process swapped out"
operator|)
argument_list|)
expr_stmt|;
comment|/* cpu = PCPU_GET(cpuid); */
name|cpu
operator|=
name|ke
operator|->
name|ke_oncpu
expr_stmt|;
name|kseq
operator|=
operator|&
name|kseq_cpu
index|[
name|cpu
index|]
expr_stmt|;
name|kseq
operator|->
name|ksq_load
operator|++
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_runq
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|SCHED_CURR
argument_list|(
name|ke
operator|->
name|ke_ksegrp
argument_list|)
condition|)
name|ke
operator|->
name|ke_runq
operator|=
name|kseq
operator|->
name|ksq_curr
expr_stmt|;
else|else
name|ke
operator|->
name|ke_runq
operator|=
name|kseq
operator|->
name|ksq_next
expr_stmt|;
block|}
name|ke
operator|->
name|ke_ksegrp
operator|->
name|kg_runq_kses
operator|++
expr_stmt|;
name|ke
operator|->
name|ke_state
operator|=
name|KES_ONRUNQ
expr_stmt|;
name|runq_add
argument_list|(
name|ke
operator|->
name|ke_runq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sched_rem
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* KASSERT((ke->ke_state == KES_ONRUNQ), ("KSE not on run queue")); */
name|kseq
operator|=
operator|&
name|kseq_cpu
index|[
name|ke
operator|->
name|ke_oncpu
index|]
expr_stmt|;
name|kseq
operator|->
name|ksq_load
operator|--
expr_stmt|;
name|runq_remove
argument_list|(
name|ke
operator|->
name|ke_runq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_runq
operator|=
name|NULL
expr_stmt|;
name|ke
operator|->
name|ke_state
operator|=
name|KES_THREAD
expr_stmt|;
name|ke
operator|->
name|ke_ksegrp
operator|->
name|kg_runq_kses
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|fixpt_t
name|sched_pctcpu
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
name|fixpt_t
name|pctcpu
decl_stmt|;
name|pctcpu
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_ticks
condition|)
block|{
name|int
name|rtick
decl_stmt|;
comment|/* Update to account for time potentially spent sleeping */
name|ke
operator|->
name|ke_ltick
operator|=
name|ticks
expr_stmt|;
name|sched_pctcpu_update
argument_list|(
name|ke
argument_list|)
expr_stmt|;
comment|/* How many rtick per second ? */
name|rtick
operator|=
name|ke
operator|->
name|ke_ticks
operator|/
operator|(
name|SCHED_CPU_TIME
operator|*
literal|10000
operator|)
expr_stmt|;
name|pctcpu
operator|=
operator|(
name|FSCALE
operator|*
operator|(
operator|(
name|FSCALE
operator|*
name|rtick
operator|)
operator|/
name|stathz
operator|)
operator|)
operator|>>
name|FSHIFT
expr_stmt|;
block|}
name|ke
operator|->
name|ke_proc
operator|->
name|p_swtime
operator|=
name|ke
operator|->
name|ke_ltick
operator|-
name|ke
operator|->
name|ke_ftick
expr_stmt|;
return|return
operator|(
name|pctcpu
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sched_sizeof_kse
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|kse
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ke_sched
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sched_sizeof_ksegrp
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ksegrp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|kg_sched
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sched_sizeof_proc
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sched_sizeof_thread
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|td_sched
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

