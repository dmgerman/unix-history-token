begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2003, Jeffrey Roberson<jeff@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_define
define|#
directive|define
name|KTR_ULE
value|KTR_NFS
end_define

begin_comment
comment|/* decay 95% of `p_pctcpu' in 60 seconds; see CCPU_SHIFT before changing */
end_comment

begin_comment
comment|/* XXX This is bogus compatability crap for ps */
end_comment

begin_decl_stmt
specifier|static
name|fixpt_t
name|ccpu
init|=
literal|0.95122942450071400909
operator|*
name|FSCALE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* exp(-1/20) */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|ccpu
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ccpu
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|sched_setup
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_macro
name|SYSINIT
argument_list|(
argument|sched_setup
argument_list|,
argument|SI_SUB_RUN_QUEUE
argument_list|,
argument|SI_ORDER_FIRST
argument_list|,
argument|sched_setup
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|sched
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"SCHED"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|sched_strict
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|strict
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|sched_strict
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|slice_min
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|slice_min
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|slice_min
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|slice_max
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_sched
argument_list|,
name|OID_AUTO
argument_list|,
name|slice_max
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|slice_max
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|realstathz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tickincr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_comment
comment|/* Callout to handle load balancing SMP systems. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|callout
name|kseq_lb_callout
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * These datastructures are allocated within their parent datastructure but  * are scheduler specific.  */
end_comment

begin_struct
struct|struct
name|ke_sched
block|{
name|int
name|ske_slice
decl_stmt|;
name|struct
name|runq
modifier|*
name|ske_runq
decl_stmt|;
comment|/* The following variables are only used for pctcpu calculation */
name|int
name|ske_ltick
decl_stmt|;
comment|/* Last tick that we were running on */
name|int
name|ske_ftick
decl_stmt|;
comment|/* First tick that we were running on */
name|int
name|ske_ticks
decl_stmt|;
comment|/* Tick count */
comment|/* CPU that we have affinity for. */
name|u_char
name|ske_cpu
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ke_slice
value|ke_sched->ske_slice
end_define

begin_define
define|#
directive|define
name|ke_runq
value|ke_sched->ske_runq
end_define

begin_define
define|#
directive|define
name|ke_ltick
value|ke_sched->ske_ltick
end_define

begin_define
define|#
directive|define
name|ke_ftick
value|ke_sched->ske_ftick
end_define

begin_define
define|#
directive|define
name|ke_ticks
value|ke_sched->ske_ticks
end_define

begin_define
define|#
directive|define
name|ke_cpu
value|ke_sched->ske_cpu
end_define

begin_struct
struct|struct
name|kg_sched
block|{
name|int
name|skg_slptime
decl_stmt|;
comment|/* Number of ticks we vol. slept */
name|int
name|skg_runtime
decl_stmt|;
comment|/* Number of ticks we were running */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|kg_slptime
value|kg_sched->skg_slptime
end_define

begin_define
define|#
directive|define
name|kg_runtime
value|kg_sched->skg_runtime
end_define

begin_struct
struct|struct
name|td_sched
block|{
name|int
name|std_slptime
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|td_slptime
value|td_sched->std_slptime
end_define

begin_decl_stmt
name|struct
name|td_sched
name|td_sched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ke_sched
name|ke_sched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|kg_sched
name|kg_sched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ke_sched
modifier|*
name|kse0_sched
init|=
operator|&
name|ke_sched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|kg_sched
modifier|*
name|ksegrp0_sched
init|=
operator|&
name|kg_sched
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|p_sched
modifier|*
name|proc0_sched
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|td_sched
modifier|*
name|thread0_sched
init|=
operator|&
name|td_sched
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The priority is primarily determined by the interactivity score.  Thus, we  * give lower(better) priorities to kse groups that use less CPU.  The nice  * value is then directly added to this to allow nice to have some effect  * on latency.  *  * PRI_RANGE:	Total priority range for timeshare threads.  * PRI_NRESV:	Number of nice values.  * PRI_BASE:	The start of the dynamic range.  */
end_comment

begin_define
define|#
directive|define
name|SCHED_PRI_RANGE
value|(PRI_MAX_TIMESHARE - PRI_MIN_TIMESHARE + 1)
end_define

begin_define
define|#
directive|define
name|SCHED_PRI_NRESV
value|PRIO_TOTAL
end_define

begin_define
define|#
directive|define
name|SCHED_PRI_NHALF
value|(PRIO_TOTAL / 2)
end_define

begin_define
define|#
directive|define
name|SCHED_PRI_NTHRESH
value|(SCHED_PRI_NHALF - 1)
end_define

begin_define
define|#
directive|define
name|SCHED_PRI_BASE
value|(PRI_MIN_TIMESHARE)
end_define

begin_define
define|#
directive|define
name|SCHED_PRI_INTERACT
parameter_list|(
name|score
parameter_list|)
define|\
value|((score) * SCHED_PRI_RANGE / SCHED_INTERACT_MAX)
end_define

begin_comment
comment|/*  * These determine the interactivity of a process.  *  * SLP_RUN_MAX:	Maximum amount of sleep time + run time we'll accumulate  *		before throttling back.  * SLP_RUN_THROTTLE:	Divisor for reducing slp/run time at fork time.  * INTERACT_MAX:	Maximum interactivity value.  Smaller is better.  * INTERACT_THRESH:	Threshhold for placement on the current runq.  */
end_comment

begin_define
define|#
directive|define
name|SCHED_SLP_RUN_MAX
value|((hz * 5)<< 10)
end_define

begin_define
define|#
directive|define
name|SCHED_SLP_RUN_THROTTLE
value|(100)
end_define

begin_define
define|#
directive|define
name|SCHED_INTERACT_MAX
value|(100)
end_define

begin_define
define|#
directive|define
name|SCHED_INTERACT_HALF
value|(SCHED_INTERACT_MAX / 2)
end_define

begin_define
define|#
directive|define
name|SCHED_INTERACT_THRESH
value|(30)
end_define

begin_comment
comment|/*  * These parameters and macros determine the size of the time slice that is  * granted to each thread.  *  * SLICE_MIN:	Minimum time slice granted, in units of ticks.  * SLICE_MAX:	Maximum time slice granted.  * SLICE_RANGE:	Range of available time slices scaled by hz.  * SLICE_SCALE:	The number slices granted per val in the range of [0, max].  * SLICE_NICE:  Determine the amount of slice granted to a scaled nice.  */
end_comment

begin_define
define|#
directive|define
name|SCHED_SLICE_MIN
value|(slice_min)
end_define

begin_define
define|#
directive|define
name|SCHED_SLICE_MAX
value|(slice_max)
end_define

begin_define
define|#
directive|define
name|SCHED_SLICE_RANGE
value|(SCHED_SLICE_MAX - SCHED_SLICE_MIN + 1)
end_define

begin_define
define|#
directive|define
name|SCHED_SLICE_SCALE
parameter_list|(
name|val
parameter_list|,
name|max
parameter_list|)
value|(((val) * SCHED_SLICE_RANGE) / (max))
end_define

begin_define
define|#
directive|define
name|SCHED_SLICE_NICE
parameter_list|(
name|nice
parameter_list|)
define|\
value|(SCHED_SLICE_MAX - SCHED_SLICE_SCALE((nice), SCHED_PRI_NTHRESH))
end_define

begin_comment
comment|/*  * This macro determines whether or not the kse belongs on the current or  * next run queue.  *   * XXX nice value should effect how interactive a kg is.  */
end_comment

begin_define
define|#
directive|define
name|SCHED_INTERACTIVE
parameter_list|(
name|kg
parameter_list|)
define|\
value|(sched_interact_score(kg)< SCHED_INTERACT_THRESH)
end_define

begin_define
define|#
directive|define
name|SCHED_CURR
parameter_list|(
name|kg
parameter_list|,
name|ke
parameter_list|)
define|\
value|(ke->ke_thread->td_priority != kg->kg_user_pri ||			\     SCHED_INTERACTIVE(kg))
end_define

begin_comment
comment|/*  * Cpu percentage computation macros and defines.  *  * SCHED_CPU_TIME:	Number of seconds to average the cpu usage across.  * SCHED_CPU_TICKS:	Number of hz ticks to average the cpu usage across.  */
end_comment

begin_define
define|#
directive|define
name|SCHED_CPU_TIME
value|10
end_define

begin_define
define|#
directive|define
name|SCHED_CPU_TICKS
value|(hz * SCHED_CPU_TIME)
end_define

begin_comment
comment|/*  * kseq - per processor runqs and statistics.  */
end_comment

begin_define
define|#
directive|define
name|KSEQ_NCLASS
value|(PRI_IDLE + 1)
end_define

begin_comment
comment|/* Number of run classes. */
end_comment

begin_struct
struct|struct
name|kseq
block|{
name|struct
name|runq
name|ksq_idle
decl_stmt|;
comment|/* Queue of IDLE threads. */
name|struct
name|runq
name|ksq_timeshare
index|[
literal|2
index|]
decl_stmt|;
comment|/* Run queues for !IDLE. */
name|struct
name|runq
modifier|*
name|ksq_next
decl_stmt|;
comment|/* Next timeshare queue. */
name|struct
name|runq
modifier|*
name|ksq_curr
decl_stmt|;
comment|/* Current queue. */
name|int
name|ksq_loads
index|[
name|KSEQ_NCLASS
index|]
decl_stmt|;
comment|/* Load for each class */
name|int
name|ksq_load
decl_stmt|;
comment|/* Aggregate load. */
name|short
name|ksq_nice
index|[
name|PRIO_TOTAL
operator|+
literal|1
index|]
decl_stmt|;
comment|/* KSEs in each nice bin. */
name|short
name|ksq_nicemin
decl_stmt|;
comment|/* Least nice. */
ifdef|#
directive|ifdef
name|SMP
name|int
name|ksq_cpus
decl_stmt|;
comment|/* Count of CPUs in this kseq. */
name|unsigned
name|int
name|ksq_rslices
decl_stmt|;
comment|/* Slices on run queue */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/*  * One kse queue per processor.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_decl_stmt
name|struct
name|kseq
name|kseq_cpu
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|kseq
modifier|*
name|kseq_idmap
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KSEQ_SELF
parameter_list|()
value|(kseq_idmap[PCPU_GET(cpuid)])
end_define

begin_define
define|#
directive|define
name|KSEQ_CPU
parameter_list|(
name|x
parameter_list|)
value|(kseq_idmap[(x)])
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|struct
name|kseq
name|kseq_cpu
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KSEQ_SELF
parameter_list|()
value|(&kseq_cpu)
end_define

begin_define
define|#
directive|define
name|KSEQ_CPU
parameter_list|(
name|x
parameter_list|)
value|(&kseq_cpu)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|sched_slice
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sched_priority
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sched_interact_score
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sched_interact_update
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|sched_pctcpu_update
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sched_pickcpu
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Operations on per processor queues */
end_comment

begin_function_decl
specifier|static
name|struct
name|kse
modifier|*
name|kseq_choose
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|,
name|int
name|steal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kseq_setup
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kseq_add
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|,
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kseq_rem
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|,
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kseq_nice_add
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|,
name|int
name|nice
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kseq_nice_rem
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|,
name|int
name|nice
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|kseq_print
parameter_list|(
name|int
name|cpu
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function_decl
name|struct
name|kseq
modifier|*
name|kseq_load_highest
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|kseq_balance
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|kseq_move
parameter_list|(
name|struct
name|kseq
modifier|*
name|from
parameter_list|,
name|int
name|cpu
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|kseq_print
parameter_list|(
name|int
name|cpu
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|int
name|i
decl_stmt|;
name|kseq
operator|=
name|KSEQ_CPU
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"kseq:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tload:           %d\n"
argument_list|,
name|kseq
operator|->
name|ksq_load
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tload ITHD:      %d\n"
argument_list|,
name|kseq
operator|->
name|ksq_loads
index|[
name|PRI_ITHD
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tload REALTIME:  %d\n"
argument_list|,
name|kseq
operator|->
name|ksq_loads
index|[
name|PRI_REALTIME
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tload TIMESHARE: %d\n"
argument_list|,
name|kseq
operator|->
name|ksq_loads
index|[
name|PRI_TIMESHARE
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tload IDLE:      %d\n"
argument_list|,
name|kseq
operator|->
name|ksq_loads
index|[
name|PRI_IDLE
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tnicemin:\t%d\n"
argument_list|,
name|kseq
operator|->
name|ksq_nicemin
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tnice counts:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PRIO_TOTAL
operator|+
literal|1
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|kseq
operator|->
name|ksq_nice
index|[
name|i
index|]
condition|)
name|printf
argument_list|(
literal|"\t\t%d = %d\n"
argument_list|,
name|i
operator|-
name|SCHED_PRI_NHALF
argument_list|,
name|kseq
operator|->
name|ksq_nice
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kseq_add
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|,
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|kseq
operator|->
name|ksq_loads
index|[
name|PRI_BASE
argument_list|(
name|ke
operator|->
name|ke_ksegrp
operator|->
name|kg_pri_class
argument_list|)
index|]
operator|++
expr_stmt|;
name|kseq
operator|->
name|ksq_load
operator|++
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_ksegrp
operator|->
name|kg_pri_class
operator|==
name|PRI_TIMESHARE
condition|)
name|CTR6
argument_list|(
name|KTR_ULE
argument_list|,
literal|"Add kse %p to %p (slice: %d, pri: %d, nice: %d(%d))"
argument_list|,
name|ke
argument_list|,
name|ke
operator|->
name|ke_runq
argument_list|,
name|ke
operator|->
name|ke_slice
argument_list|,
name|ke
operator|->
name|ke_thread
operator|->
name|td_priority
argument_list|,
name|ke
operator|->
name|ke_ksegrp
operator|->
name|kg_nice
argument_list|,
name|kseq
operator|->
name|ksq_nicemin
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_ksegrp
operator|->
name|kg_pri_class
operator|==
name|PRI_TIMESHARE
condition|)
name|kseq_nice_add
argument_list|(
name|kseq
argument_list|,
name|ke
operator|->
name|ke_ksegrp
operator|->
name|kg_nice
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|kseq
operator|->
name|ksq_rslices
operator|+=
name|ke
operator|->
name|ke_slice
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|kseq_rem
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|,
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|kseq
operator|->
name|ksq_loads
index|[
name|PRI_BASE
argument_list|(
name|ke
operator|->
name|ke_ksegrp
operator|->
name|kg_pri_class
argument_list|)
index|]
operator|--
expr_stmt|;
name|kseq
operator|->
name|ksq_load
operator|--
expr_stmt|;
name|ke
operator|->
name|ke_runq
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_ksegrp
operator|->
name|kg_pri_class
operator|==
name|PRI_TIMESHARE
condition|)
name|kseq_nice_rem
argument_list|(
name|kseq
argument_list|,
name|ke
operator|->
name|ke_ksegrp
operator|->
name|kg_nice
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|kseq
operator|->
name|ksq_rslices
operator|-=
name|ke
operator|->
name|ke_slice
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|kseq_nice_add
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|,
name|int
name|nice
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Normalize to zero. */
name|kseq
operator|->
name|ksq_nice
index|[
name|nice
operator|+
name|SCHED_PRI_NHALF
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|nice
operator|<
name|kseq
operator|->
name|ksq_nicemin
operator|||
name|kseq
operator|->
name|ksq_loads
index|[
name|PRI_TIMESHARE
index|]
operator|==
literal|1
condition|)
name|kseq
operator|->
name|ksq_nicemin
operator|=
name|nice
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kseq_nice_rem
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|,
name|int
name|nice
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Normalize to zero. */
name|n
operator|=
name|nice
operator|+
name|SCHED_PRI_NHALF
expr_stmt|;
name|kseq
operator|->
name|ksq_nice
index|[
name|n
index|]
operator|--
expr_stmt|;
name|KASSERT
argument_list|(
name|kseq
operator|->
name|ksq_nice
index|[
name|n
index|]
operator|>=
literal|0
argument_list|,
operator|(
literal|"Negative nice count."
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If this wasn't the smallest nice value or there are more in 	 * this bucket we can just return.  Otherwise we have to recalculate 	 * the smallest nice. 	 */
if|if
condition|(
name|nice
operator|!=
name|kseq
operator|->
name|ksq_nicemin
operator|||
name|kseq
operator|->
name|ksq_nice
index|[
name|n
index|]
operator|!=
literal|0
operator|||
name|kseq
operator|->
name|ksq_loads
index|[
name|PRI_TIMESHARE
index|]
operator|==
literal|0
condition|)
return|return;
for|for
control|(
init|;
name|n
operator|<
name|SCHED_PRI_NRESV
operator|+
literal|1
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|kseq
operator|->
name|ksq_nice
index|[
name|n
index|]
condition|)
block|{
name|kseq
operator|->
name|ksq_nicemin
operator|=
name|n
operator|-
name|SCHED_PRI_NHALF
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_comment
comment|/*  * kseq_balance is a simple CPU load balancing algorithm.  It operates by  * finding the least loaded and most loaded cpu and equalizing their load  * by migrating some processes.  *  * Dealing only with two CPUs at a time has two advantages.  Firstly, most  * installations will only have 2 cpus.  Secondly, load balancing too much at  * once can have an unpleasant effect on the system.  The scheduler rarely has  * enough information to make perfect decisions.  So this algorithm chooses  * algorithm simplicity and more gradual effects on load in larger systems.  *  * It could be improved by considering the priorities and slices assigned to  * each task prior to balancing them.  There are many pathological cases with  * any approach and so the semi random algorithm below may work as well as any.  *  */
end_comment

begin_function
name|void
name|kseq_balance
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|int
name|high_load
decl_stmt|;
name|int
name|low_load
decl_stmt|;
name|int
name|high_cpu
decl_stmt|;
name|int
name|low_cpu
decl_stmt|;
name|int
name|move
decl_stmt|;
name|int
name|diff
decl_stmt|;
name|int
name|i
decl_stmt|;
name|high_cpu
operator|=
literal|0
expr_stmt|;
name|low_cpu
operator|=
literal|0
expr_stmt|;
name|high_load
operator|=
literal|0
expr_stmt|;
name|low_load
operator|=
operator|-
literal|1
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|smp_started
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp_maxid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
operator|||
operator|(
name|i
operator|&
name|stopped_cpus
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|kseq
operator|=
name|KSEQ_CPU
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|kseq
operator|->
name|ksq_load
operator|>
name|high_load
condition|)
block|{
name|high_load
operator|=
name|kseq
operator|->
name|ksq_load
expr_stmt|;
name|high_cpu
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|low_load
operator|==
operator|-
literal|1
operator|||
name|kseq
operator|->
name|ksq_load
operator|<
name|low_load
condition|)
block|{
name|low_load
operator|=
name|kseq
operator|->
name|ksq_load
expr_stmt|;
name|low_cpu
operator|=
name|i
expr_stmt|;
block|}
block|}
name|kseq
operator|=
name|KSEQ_CPU
argument_list|(
name|high_cpu
argument_list|)
expr_stmt|;
comment|/* 	 * Nothing to do. 	 */
if|if
condition|(
name|high_load
operator|<
name|kseq
operator|->
name|ksq_cpus
operator|+
literal|1
condition|)
goto|goto
name|out
goto|;
name|high_load
operator|-=
name|kseq
operator|->
name|ksq_cpus
expr_stmt|;
if|if
condition|(
name|low_load
operator|>=
name|high_load
condition|)
goto|goto
name|out
goto|;
name|diff
operator|=
name|high_load
operator|-
name|low_load
expr_stmt|;
name|move
operator|=
name|diff
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|diff
operator|&
literal|0x1
condition|)
name|move
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|move
condition|;
name|i
operator|++
control|)
name|kseq_move
argument_list|(
name|kseq
argument_list|,
name|low_cpu
argument_list|)
expr_stmt|;
name|out
label|:
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|kseq_lb_callout
argument_list|,
name|hz
argument_list|,
name|kseq_balance
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|struct
name|kseq
modifier|*
name|kseq_load_highest
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|int
name|load
decl_stmt|;
name|int
name|cpu
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|cpu
operator|=
literal|0
expr_stmt|;
name|load
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp_maxid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
operator|||
operator|(
name|i
operator|&
name|stopped_cpus
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|kseq
operator|=
name|KSEQ_CPU
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|kseq
operator|->
name|ksq_load
operator|>
name|load
condition|)
block|{
name|load
operator|=
name|kseq
operator|->
name|ksq_load
expr_stmt|;
name|cpu
operator|=
name|i
expr_stmt|;
block|}
block|}
name|kseq
operator|=
name|KSEQ_CPU
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|load
operator|>
name|kseq
operator|->
name|ksq_cpus
condition|)
return|return
operator|(
name|kseq
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|kseq_move
parameter_list|(
name|struct
name|kseq
modifier|*
name|from
parameter_list|,
name|int
name|cpu
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|ke
operator|=
name|kseq_choose
argument_list|(
name|from
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|runq_remove
argument_list|(
name|ke
operator|->
name|ke_runq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_state
operator|=
name|KES_THREAD
expr_stmt|;
name|kseq_rem
argument_list|(
name|from
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_cpu
operator|=
name|cpu
expr_stmt|;
name|sched_add
argument_list|(
name|ke
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Pick the highest priority task we have and return it.   If steal is 1 we  * will return kses that have been denied slices due to their nice being too  * low.  In the future we should prohibit stealing interrupt threads as well.  */
end_comment

begin_function
name|struct
name|kse
modifier|*
name|kseq_choose
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|,
name|int
name|steal
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|struct
name|runq
modifier|*
name|swap
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|swap
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ke
operator|=
name|runq_choose
argument_list|(
name|kseq
operator|->
name|ksq_curr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * We already swaped once and didn't get anywhere. 			 */
if|if
condition|(
name|swap
condition|)
break|break;
name|swap
operator|=
name|kseq
operator|->
name|ksq_curr
expr_stmt|;
name|kseq
operator|->
name|ksq_curr
operator|=
name|kseq
operator|->
name|ksq_next
expr_stmt|;
name|kseq
operator|->
name|ksq_next
operator|=
name|swap
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * If we encounter a slice of 0 the kse is in a 		 * TIMESHARE kse group and its nice was too far out 		 * of the range that receives slices.  		 */
if|if
condition|(
name|ke
operator|->
name|ke_slice
operator|==
literal|0
operator|&&
name|steal
operator|==
literal|0
condition|)
block|{
name|runq_remove
argument_list|(
name|ke
operator|->
name|ke_runq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|sched_slice
argument_list|(
name|ke
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_runq
operator|=
name|kseq
operator|->
name|ksq_next
expr_stmt|;
name|runq_add
argument_list|(
name|ke
operator|->
name|ke_runq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
name|ke
operator|)
return|;
block|}
return|return
operator|(
name|runq_choose
argument_list|(
operator|&
name|kseq
operator|->
name|ksq_idle
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kseq_setup
parameter_list|(
name|struct
name|kseq
modifier|*
name|kseq
parameter_list|)
block|{
name|runq_init
argument_list|(
operator|&
name|kseq
operator|->
name|ksq_timeshare
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|runq_init
argument_list|(
operator|&
name|kseq
operator|->
name|ksq_timeshare
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|runq_init
argument_list|(
operator|&
name|kseq
operator|->
name|ksq_idle
argument_list|)
expr_stmt|;
name|kseq
operator|->
name|ksq_curr
operator|=
operator|&
name|kseq
operator|->
name|ksq_timeshare
index|[
literal|0
index|]
expr_stmt|;
name|kseq
operator|->
name|ksq_next
operator|=
operator|&
name|kseq
operator|->
name|ksq_timeshare
index|[
literal|1
index|]
expr_stmt|;
name|kseq
operator|->
name|ksq_loads
index|[
name|PRI_ITHD
index|]
operator|=
literal|0
expr_stmt|;
name|kseq
operator|->
name|ksq_loads
index|[
name|PRI_REALTIME
index|]
operator|=
literal|0
expr_stmt|;
name|kseq
operator|->
name|ksq_loads
index|[
name|PRI_TIMESHARE
index|]
operator|=
literal|0
expr_stmt|;
name|kseq
operator|->
name|ksq_loads
index|[
name|PRI_IDLE
index|]
operator|=
literal|0
expr_stmt|;
name|kseq
operator|->
name|ksq_load
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|kseq
operator|->
name|ksq_rslices
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|sched_setup
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SMP
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|slice_min
operator|=
operator|(
name|hz
operator|/
literal|100
operator|)
expr_stmt|;
comment|/* 10ms */
name|slice_max
operator|=
operator|(
name|hz
operator|/
literal|7
operator|)
expr_stmt|;
comment|/* ~140ms */
ifdef|#
directive|ifdef
name|SMP
comment|/* init kseqs */
comment|/* Create the idmap. */
ifdef|#
directive|ifdef
name|ULE_HTT_EXPERIMENTAL
if|if
condition|(
name|smp_topology
operator|==
name|NULL
condition|)
block|{
else|#
directive|else
if|if
condition|(
literal|1
condition|)
block|{
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
block|{
name|kseq_setup
argument_list|(
operator|&
name|kseq_cpu
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kseq_idmap
index|[
name|i
index|]
operator|=
operator|&
name|kseq_cpu
index|[
name|i
index|]
expr_stmt|;
name|kseq_cpu
index|[
name|i
index|]
operator|.
name|ksq_cpus
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|smp_topology
operator|->
name|ct_count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|cpu_group
modifier|*
name|cg
decl_stmt|;
name|cg
operator|=
operator|&
name|smp_topology
operator|->
name|ct_group
index|[
name|i
index|]
expr_stmt|;
name|kseq_setup
argument_list|(
operator|&
name|kseq_cpu
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXCPU
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|cg
operator|->
name|cg_mask
operator|&
operator|(
literal|1
operator|<<
name|j
operator|)
operator|)
operator|!=
literal|0
condition|)
name|kseq_idmap
index|[
name|j
index|]
operator|=
operator|&
name|kseq_cpu
index|[
name|i
index|]
expr_stmt|;
name|kseq_cpu
index|[
name|i
index|]
operator|.
name|ksq_cpus
operator|=
name|cg
operator|->
name|cg_count
expr_stmt|;
block|}
block|}
name|callout_init
argument_list|(
operator|&
name|kseq_lb_callout
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|kseq_balance
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|kseq_setup
argument_list|(
name|KSEQ_SELF
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|kseq_add
argument_list|(
name|KSEQ_SELF
argument_list|()
argument_list|,
operator|&
name|kse0
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
comment|/*  * Scale the scheduling priority according to the "interactivity" of this  * process.  */
specifier|static
name|void
name|sched_priority
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|)
block|{
name|int
name|pri
decl_stmt|;
if|if
condition|(
name|kg
operator|->
name|kg_pri_class
operator|!=
name|PRI_TIMESHARE
condition|)
return|return;
name|pri
operator|=
name|SCHED_PRI_INTERACT
argument_list|(
name|sched_interact_score
argument_list|(
name|kg
argument_list|)
argument_list|)
expr_stmt|;
name|pri
operator|+=
name|SCHED_PRI_BASE
expr_stmt|;
name|pri
operator|+=
name|kg
operator|->
name|kg_nice
expr_stmt|;
if|if
condition|(
name|pri
operator|>
name|PRI_MAX_TIMESHARE
condition|)
name|pri
operator|=
name|PRI_MAX_TIMESHARE
expr_stmt|;
elseif|else
if|if
condition|(
name|pri
operator|<
name|PRI_MIN_TIMESHARE
condition|)
name|pri
operator|=
name|PRI_MIN_TIMESHARE
expr_stmt|;
name|kg
operator|->
name|kg_user_pri
operator|=
name|pri
expr_stmt|;
return|return;
block|}
comment|/*  * Calculate a time slice based on the properties of the kseg and the runq  * that we're on.  This is only for PRI_TIMESHARE ksegrps.  */
specifier|static
name|void
name|sched_slice
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|kg
operator|=
name|ke
operator|->
name|ke_ksegrp
expr_stmt|;
name|kseq
operator|=
name|KSEQ_CPU
argument_list|(
name|ke
operator|->
name|ke_cpu
argument_list|)
expr_stmt|;
comment|/* 	 * Rationale: 	 * KSEs in interactive ksegs get the minimum slice so that we 	 * quickly notice if it abuses its advantage. 	 * 	 * KSEs in non-interactive ksegs are assigned a slice that is 	 * based on the ksegs nice value relative to the least nice kseg 	 * on the run queue for this cpu. 	 * 	 * If the KSE is less nice than all others it gets the maximum 	 * slice and other KSEs will adjust their slice relative to 	 * this when they first expire. 	 * 	 * There is 20 point window that starts relative to the least 	 * nice kse on the run queue.  Slice size is determined by 	 * the kse distance from the last nice ksegrp. 	 * 	 * If you are outside of the window you will get no slice and 	 * you will be reevaluated each time you are selected on the 	 * run queue. 	 *	 	 */
if|if
condition|(
operator|!
name|SCHED_INTERACTIVE
argument_list|(
name|kg
argument_list|)
condition|)
block|{
name|int
name|nice
decl_stmt|;
name|nice
operator|=
name|kg
operator|->
name|kg_nice
operator|+
operator|(
literal|0
operator|-
name|kseq
operator|->
name|ksq_nicemin
operator|)
expr_stmt|;
if|if
condition|(
name|kseq
operator|->
name|ksq_loads
index|[
name|PRI_TIMESHARE
index|]
operator|==
literal|0
operator|||
name|kg
operator|->
name|kg_nice
operator|<
name|kseq
operator|->
name|ksq_nicemin
condition|)
name|ke
operator|->
name|ke_slice
operator|=
name|SCHED_SLICE_MAX
expr_stmt|;
elseif|else
if|if
condition|(
name|nice
operator|<=
name|SCHED_PRI_NTHRESH
condition|)
name|ke
operator|->
name|ke_slice
operator|=
name|SCHED_SLICE_NICE
argument_list|(
name|nice
argument_list|)
expr_stmt|;
else|else
name|ke
operator|->
name|ke_slice
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ke
operator|->
name|ke_slice
operator|=
name|SCHED_SLICE_MIN
expr_stmt|;
name|CTR6
argument_list|(
name|KTR_ULE
argument_list|,
literal|"Sliced %p(%d) (nice: %d, nicemin: %d, load: %d, interactive: %d)"
argument_list|,
name|ke
argument_list|,
name|ke
operator|->
name|ke_slice
argument_list|,
name|kg
operator|->
name|kg_nice
argument_list|,
name|kseq
operator|->
name|ksq_nicemin
argument_list|,
name|kseq
operator|->
name|ksq_loads
index|[
name|PRI_TIMESHARE
index|]
argument_list|,
name|SCHED_INTERACTIVE
argument_list|(
name|kg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check to see if we need to scale back the slp and run time 	 * in the kg.  This will cause us to forget old interactivity 	 * while maintaining the current ratio. 	 */
name|sched_interact_update
argument_list|(
name|kg
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|static
name|void
name|sched_interact_update
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|)
block|{
comment|/* XXX Fixme, use a linear algorithm and not a while loop. */
while|while
condition|(
operator|(
name|kg
operator|->
name|kg_runtime
operator|+
name|kg
operator|->
name|kg_slptime
operator|)
operator|>
name|SCHED_SLP_RUN_MAX
condition|)
block|{
name|kg
operator|->
name|kg_runtime
operator|=
operator|(
name|kg
operator|->
name|kg_runtime
operator|/
literal|5
operator|)
operator|*
literal|4
expr_stmt|;
name|kg
operator|->
name|kg_slptime
operator|=
operator|(
name|kg
operator|->
name|kg_slptime
operator|/
literal|5
operator|)
operator|*
literal|4
expr_stmt|;
block|}
block|}
specifier|static
name|int
name|sched_interact_score
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|)
block|{
name|int
name|div
decl_stmt|;
if|if
condition|(
name|kg
operator|->
name|kg_runtime
operator|>
name|kg
operator|->
name|kg_slptime
condition|)
block|{
name|div
operator|=
name|max
argument_list|(
literal|1
argument_list|,
name|kg
operator|->
name|kg_runtime
operator|/
name|SCHED_INTERACT_HALF
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCHED_INTERACT_HALF
operator|+
operator|(
name|SCHED_INTERACT_HALF
operator|-
operator|(
name|kg
operator|->
name|kg_slptime
operator|/
name|div
operator|)
operator|)
operator|)
return|;
block|}
if|if
condition|(
name|kg
operator|->
name|kg_slptime
operator|>
name|kg
operator|->
name|kg_runtime
condition|)
block|{
name|div
operator|=
name|max
argument_list|(
literal|1
argument_list|,
name|kg
operator|->
name|kg_slptime
operator|/
name|SCHED_INTERACT_HALF
argument_list|)
expr_stmt|;
return|return
operator|(
name|kg
operator|->
name|kg_runtime
operator|/
name|div
operator|)
return|;
block|}
comment|/* 	 * This can happen if slptime and runtime are 0. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * This is only somewhat accurate since given many processes of the same  * priority they will switch when their slices run out, which will be  * at most SCHED_SLICE_MAX.  */
name|int
name|sched_rr_interval
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|SCHED_SLICE_MAX
operator|)
return|;
block|}
name|void
name|sched_pctcpu_update
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|)
block|{
comment|/* 	 * Adjust counters and watermark for pctcpu calc. 	 */
if|if
condition|(
name|ke
operator|->
name|ke_ltick
operator|>
name|ticks
operator|-
name|SCHED_CPU_TICKS
condition|)
block|{
comment|/* 		 * Shift the tick count out so that the divide doesn't 		 * round away our results. 		 */
name|ke
operator|->
name|ke_ticks
operator|<<=
literal|10
expr_stmt|;
name|ke
operator|->
name|ke_ticks
operator|=
operator|(
name|ke
operator|->
name|ke_ticks
operator|/
operator|(
name|ticks
operator|-
name|ke
operator|->
name|ke_ftick
operator|)
operator|)
operator|*
name|SCHED_CPU_TICKS
expr_stmt|;
name|ke
operator|->
name|ke_ticks
operator|>>=
literal|10
expr_stmt|;
block|}
else|else
name|ke
operator|->
name|ke_ticks
operator|=
literal|0
expr_stmt|;
name|ke
operator|->
name|ke_ltick
operator|=
name|ticks
expr_stmt|;
name|ke
operator|->
name|ke_ftick
operator|=
name|ke
operator|->
name|ke_ltick
operator|-
name|SCHED_CPU_TICKS
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SMP
comment|/* XXX Should be changed to kseq_load_lowest() */
name|int
name|sched_pickcpu
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|int
name|load
decl_stmt|;
name|int
name|cpu
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|smp_started
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|load
operator|=
literal|0
expr_stmt|;
name|cpu
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp_maxid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
operator|||
operator|(
name|i
operator|&
name|stopped_cpus
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|kseq
operator|=
name|KSEQ_CPU
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|kseq
operator|->
name|ksq_load
operator|<
name|load
condition|)
block|{
name|cpu
operator|=
name|i
expr_stmt|;
name|load
operator|=
name|kseq
operator|->
name|ksq_load
expr_stmt|;
block|}
block|}
name|CTR1
argument_list|(
name|KTR_RUNQ
argument_list|,
literal|"sched_pickcpu: %d"
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
return|return
operator|(
name|cpu
operator|)
return|;
block|}
else|#
directive|else
name|int
name|sched_pickcpu
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
name|void
name|sched_prio
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|u_char
name|prio
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|TD_ON_RUNQ
argument_list|(
name|td
argument_list|)
condition|)
block|{
name|adjustrunqueue
argument_list|(
name|td
argument_list|,
name|prio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|td_priority
operator|=
name|prio
expr_stmt|;
block|}
block|}
name|void
name|sched_switchout
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|td
operator|->
name|td_last_kse
operator|=
name|ke
expr_stmt|;
name|td
operator|->
name|td_lastcpu
operator|=
name|td
operator|->
name|td_oncpu
expr_stmt|;
name|td
operator|->
name|td_oncpu
operator|=
name|NOCPU
expr_stmt|;
name|td
operator|->
name|td_flags
operator|&=
operator|~
name|TDF_NEEDRESCHED
expr_stmt|;
if|if
condition|(
name|TD_IS_RUNNING
argument_list|(
name|td
argument_list|)
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator|&
name|P_SA
condition|)
block|{
name|kseq_rem
argument_list|(
name|KSEQ_CPU
argument_list|(
name|ke
operator|->
name|ke_cpu
argument_list|)
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|setrunqueue
argument_list|(
name|td
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * This queue is always correct except for idle threads which 			 * have a higher priority due to priority propagation. 			 */
if|if
condition|(
name|ke
operator|->
name|ke_ksegrp
operator|->
name|kg_pri_class
operator|==
name|PRI_IDLE
operator|&&
name|ke
operator|->
name|ke_thread
operator|->
name|td_priority
operator|>
name|PRI_MIN_IDLE
condition|)
name|ke
operator|->
name|ke_runq
operator|=
name|KSEQ_SELF
argument_list|()
operator|->
name|ksq_curr
expr_stmt|;
name|runq_add
argument_list|(
name|ke
operator|->
name|ke_runq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
comment|/* setrunqueue(td); */
block|}
return|return;
block|}
if|if
condition|(
name|ke
operator|->
name|ke_runq
condition|)
name|kseq_rem
argument_list|(
name|KSEQ_CPU
argument_list|(
name|ke
operator|->
name|ke_cpu
argument_list|)
argument_list|,
name|ke
argument_list|)
expr_stmt|;
comment|/* 	 * We will not be on the run queue. So we must be 	 * sleeping or similar. 	 */
if|if
condition|(
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator|&
name|P_SA
condition|)
name|kse_reassign
argument_list|(
name|ke
argument_list|)
expr_stmt|;
block|}
name|void
name|sched_switchin
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
comment|/* struct kse *ke = td->td_kse; */
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_oncpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
block|}
name|void
name|sched_nice
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|,
name|int
name|nice
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|PROC_LOCK_ASSERT
argument_list|(
name|kg
operator|->
name|kg_proc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * We need to adjust the nice counts for running KSEs. 	 */
if|if
condition|(
name|kg
operator|->
name|kg_pri_class
operator|==
name|PRI_TIMESHARE
condition|)
name|FOREACH_KSE_IN_GROUP
argument_list|(
argument|kg
argument_list|,
argument|ke
argument_list|)
block|{
if|if
condition|(
name|ke
operator|->
name|ke_runq
operator|==
name|NULL
condition|)
continue|continue;
name|kseq
operator|=
name|KSEQ_CPU
argument_list|(
name|ke
operator|->
name|ke_cpu
argument_list|)
expr_stmt|;
name|kseq_nice_rem
argument_list|(
name|kseq
argument_list|,
name|kg
operator|->
name|kg_nice
argument_list|)
expr_stmt|;
name|kseq_nice_add
argument_list|(
name|kseq
argument_list|,
name|nice
argument_list|)
expr_stmt|;
block|}
name|kg
operator|->
name|kg_nice
operator|=
name|nice
expr_stmt|;
name|sched_priority
argument_list|(
name|kg
argument_list|)
expr_stmt|;
name|FOREACH_THREAD_IN_GROUP
argument_list|(
argument|kg
argument_list|,
argument|td
argument_list|)
name|td
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
block|}
name|void
name|sched_sleep
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|u_char
name|prio
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_slptime
operator|=
name|ticks
expr_stmt|;
name|td
operator|->
name|td_priority
operator|=
name|prio
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_ULE
argument_list|,
literal|"sleep kse %p (tick: %d)"
argument_list|,
name|td
operator|->
name|td_kse
argument_list|,
name|td
operator|->
name|td_slptime
argument_list|)
expr_stmt|;
block|}
name|void
name|sched_wakeup
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Let the kseg know how long we slept for.  This is because process 	 * interactivity behavior is modeled in the kseg. 	 */
if|if
condition|(
name|td
operator|->
name|td_slptime
condition|)
block|{
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|int
name|hzticks
decl_stmt|;
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
name|hzticks
operator|=
name|ticks
operator|-
name|td
operator|->
name|td_slptime
expr_stmt|;
name|kg
operator|->
name|kg_slptime
operator|+=
name|hzticks
operator|<<
literal|10
expr_stmt|;
name|sched_interact_update
argument_list|(
name|kg
argument_list|)
expr_stmt|;
name|sched_priority
argument_list|(
name|kg
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_kse
condition|)
name|sched_slice
argument_list|(
name|td
operator|->
name|td_kse
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_ULE
argument_list|,
literal|"wakeup kse %p (%d ticks)"
argument_list|,
name|td
operator|->
name|td_kse
argument_list|,
name|hzticks
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_slptime
operator|=
literal|0
expr_stmt|;
block|}
name|setrunqueue
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_priority
operator|<
name|curthread
operator|->
name|td_priority
condition|)
name|curthread
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
block|}
comment|/*  * Penalize the parent for creating a new child and initialize the child's  * priority.  */
name|void
name|sched_fork
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|proc
modifier|*
name|p1
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sched_fork_ksegrp
argument_list|(
name|FIRST_KSEGRP_IN_PROC
argument_list|(
name|p
argument_list|)
argument_list|,
name|FIRST_KSEGRP_IN_PROC
argument_list|(
name|p1
argument_list|)
argument_list|)
expr_stmt|;
name|sched_fork_kse
argument_list|(
name|FIRST_KSE_IN_PROC
argument_list|(
name|p
argument_list|)
argument_list|,
name|FIRST_KSE_IN_PROC
argument_list|(
name|p1
argument_list|)
argument_list|)
expr_stmt|;
name|sched_fork_thread
argument_list|(
name|FIRST_THREAD_IN_PROC
argument_list|(
name|p
argument_list|)
argument_list|,
name|FIRST_THREAD_IN_PROC
argument_list|(
name|p1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|sched_fork_kse
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|,
name|struct
name|kse
modifier|*
name|child
parameter_list|)
block|{
name|child
operator|->
name|ke_slice
operator|=
literal|1
expr_stmt|;
comment|/* Attempt to quickly learn interactivity. */
name|child
operator|->
name|ke_cpu
operator|=
name|ke
operator|->
name|ke_cpu
expr_stmt|;
comment|/* sched_pickcpu(); */
name|child
operator|->
name|ke_runq
operator|=
name|NULL
expr_stmt|;
comment|/* Grab our parents cpu estimation information. */
name|child
operator|->
name|ke_ticks
operator|=
name|ke
operator|->
name|ke_ticks
expr_stmt|;
name|child
operator|->
name|ke_ltick
operator|=
name|ke
operator|->
name|ke_ltick
expr_stmt|;
name|child
operator|->
name|ke_ftick
operator|=
name|ke
operator|->
name|ke_ftick
expr_stmt|;
block|}
name|void
name|sched_fork_ksegrp
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|,
name|struct
name|ksegrp
modifier|*
name|child
parameter_list|)
block|{
name|PROC_LOCK_ASSERT
argument_list|(
name|child
operator|->
name|kg_proc
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* XXX Need something better here */
name|child
operator|->
name|kg_slptime
operator|=
name|kg
operator|->
name|kg_slptime
operator|/
name|SCHED_SLP_RUN_THROTTLE
expr_stmt|;
name|child
operator|->
name|kg_runtime
operator|=
name|kg
operator|->
name|kg_runtime
operator|/
name|SCHED_SLP_RUN_THROTTLE
expr_stmt|;
name|kg
operator|->
name|kg_runtime
operator|+=
name|tickincr
operator|<<
literal|10
expr_stmt|;
name|sched_interact_update
argument_list|(
name|kg
argument_list|)
expr_stmt|;
name|child
operator|->
name|kg_user_pri
operator|=
name|kg
operator|->
name|kg_user_pri
expr_stmt|;
name|child
operator|->
name|kg_nice
operator|=
name|kg
operator|->
name|kg_nice
expr_stmt|;
block|}
name|void
name|sched_fork_thread
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|thread
modifier|*
name|child
parameter_list|)
block|{ }
name|void
name|sched_class
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|,
name|int
name|class
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|kg
operator|->
name|kg_pri_class
operator|==
name|class
condition|)
return|return;
name|FOREACH_KSE_IN_GROUP
argument_list|(
argument|kg
argument_list|,
argument|ke
argument_list|)
block|{
if|if
condition|(
name|ke
operator|->
name|ke_state
operator|!=
name|KES_ONRUNQ
operator|&&
name|ke
operator|->
name|ke_state
operator|!=
name|KES_THREAD
condition|)
continue|continue;
name|kseq
operator|=
name|KSEQ_CPU
argument_list|(
name|ke
operator|->
name|ke_cpu
argument_list|)
expr_stmt|;
name|kseq
operator|->
name|ksq_loads
index|[
name|PRI_BASE
argument_list|(
name|kg
operator|->
name|kg_pri_class
argument_list|)
index|]
operator|--
expr_stmt|;
name|kseq
operator|->
name|ksq_loads
index|[
name|PRI_BASE
argument_list|(
name|class
argument_list|)
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|kg
operator|->
name|kg_pri_class
operator|==
name|PRI_TIMESHARE
condition|)
name|kseq_nice_rem
argument_list|(
name|kseq
argument_list|,
name|kg
operator|->
name|kg_nice
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|class
operator|==
name|PRI_TIMESHARE
condition|)
name|kseq_nice_add
argument_list|(
name|kseq
argument_list|,
name|kg
operator|->
name|kg_nice
argument_list|)
expr_stmt|;
block|}
name|kg
operator|->
name|kg_pri_class
operator|=
name|class
expr_stmt|;
block|}
comment|/*  * Return some of the child's priority and interactivity to the parent.  */
name|void
name|sched_exit
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|proc
modifier|*
name|child
parameter_list|)
block|{
comment|/* XXX Need something better here */
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sched_exit_kse
argument_list|(
name|FIRST_KSE_IN_PROC
argument_list|(
name|p
argument_list|)
argument_list|,
name|FIRST_KSE_IN_PROC
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|sched_exit_ksegrp
argument_list|(
name|FIRST_KSEGRP_IN_PROC
argument_list|(
name|p
argument_list|)
argument_list|,
name|FIRST_KSEGRP_IN_PROC
argument_list|(
name|child
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
name|sched_exit_kse
parameter_list|(
name|struct
name|kse
modifier|*
name|ke
parameter_list|,
name|struct
name|kse
modifier|*
name|child
parameter_list|)
block|{
name|kseq_rem
argument_list|(
name|KSEQ_CPU
argument_list|(
name|child
operator|->
name|ke_cpu
argument_list|)
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
name|void
name|sched_exit_ksegrp
parameter_list|(
name|struct
name|ksegrp
modifier|*
name|kg
parameter_list|,
name|struct
name|ksegrp
modifier|*
name|child
parameter_list|)
block|{
comment|/* kg->kg_slptime += child->kg_slptime; */
name|kg
operator|->
name|kg_runtime
operator|+=
name|child
operator|->
name|kg_runtime
expr_stmt|;
name|sched_interact_update
argument_list|(
name|kg
argument_list|)
expr_stmt|;
block|}
name|void
name|sched_exit_thread
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|thread
modifier|*
name|child
parameter_list|)
block|{ }
name|void
name|sched_clock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
if|#
directive|if
literal|0
block|struct kse *nke;
endif|#
directive|endif
comment|/* 	 * sched_setup() apparently happens prior to stathz being set.  We 	 * need to resolve the timers earlier in the boot so we can avoid 	 * calculating this here. 	 */
if|if
condition|(
name|realstathz
operator|==
literal|0
condition|)
block|{
name|realstathz
operator|=
name|stathz
condition|?
name|stathz
else|:
name|hz
expr_stmt|;
name|tickincr
operator|=
name|hz
operator|/
name|realstathz
expr_stmt|;
comment|/* 		 * XXX This does not work for values of stathz that are much 		 * larger than hz. 		 */
if|if
condition|(
name|tickincr
operator|==
literal|0
condition|)
name|tickincr
operator|=
literal|1
expr_stmt|;
block|}
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|kg
operator|=
name|ke
operator|->
name|ke_ksegrp
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|td
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"schedclock: null thread pointer"
operator|)
argument_list|)
expr_stmt|;
comment|/* Adjust ticks for pctcpu */
name|ke
operator|->
name|ke_ticks
operator|++
expr_stmt|;
name|ke
operator|->
name|ke_ltick
operator|=
name|ticks
expr_stmt|;
comment|/* Go up to one second beyond our max and then trim back down */
if|if
condition|(
name|ke
operator|->
name|ke_ftick
operator|+
name|SCHED_CPU_TICKS
operator|+
name|hz
operator|<
name|ke
operator|->
name|ke_ltick
condition|)
name|sched_pctcpu_update
argument_list|(
name|ke
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_flags
operator|&
name|TDF_IDLETD
condition|)
return|return;
name|CTR4
argument_list|(
name|KTR_ULE
argument_list|,
literal|"Tick kse %p (slice: %d, slptime: %d, runtime: %d)"
argument_list|,
name|ke
argument_list|,
name|ke
operator|->
name|ke_slice
argument_list|,
name|kg
operator|->
name|kg_slptime
operator|>>
literal|10
argument_list|,
name|kg
operator|->
name|kg_runtime
operator|>>
literal|10
argument_list|)
expr_stmt|;
comment|/* 	 * We only do slicing code for TIMESHARE ksegrps. 	 */
if|if
condition|(
name|kg
operator|->
name|kg_pri_class
operator|!=
name|PRI_TIMESHARE
condition|)
return|return;
comment|/* 	 * Check for a higher priority task on the run queue.  This can happen 	 * on SMP if another processor woke up a process on our runq. 	 */
name|kseq
operator|=
name|KSEQ_SELF
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|if (kseq->ksq_load> 1&& (nke = kseq_choose(kseq, 0)) != NULL) { 		if (sched_strict&& 		    nke->ke_thread->td_priority< td->td_priority) 			td->td_flags |= TDF_NEEDRESCHED; 		else if (nke->ke_thread->td_priority< 		    td->td_priority SCHED_PRIO_SLOP) 		     		if (nke->ke_thread->td_priority< td->td_priority) 			td->td_flags |= TDF_NEEDRESCHED; 	}
endif|#
directive|endif
comment|/* 	 * We used a tick charge it to the ksegrp so that we can compute our 	 * interactivity. 	 */
name|kg
operator|->
name|kg_runtime
operator|+=
name|tickincr
operator|<<
literal|10
expr_stmt|;
name|sched_interact_update
argument_list|(
name|kg
argument_list|)
expr_stmt|;
comment|/* 	 * We used up one time slice. 	 */
name|ke
operator|->
name|ke_slice
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|kseq
operator|->
name|ksq_rslices
operator|--
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ke
operator|->
name|ke_slice
operator|>
literal|0
condition|)
return|return;
comment|/* 	 * We're out of time, recompute priorities and requeue. 	 */
name|kseq_rem
argument_list|(
name|kseq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|sched_priority
argument_list|(
name|kg
argument_list|)
expr_stmt|;
name|sched_slice
argument_list|(
name|ke
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCHED_CURR
argument_list|(
name|kg
argument_list|,
name|ke
argument_list|)
condition|)
name|ke
operator|->
name|ke_runq
operator|=
name|kseq
operator|->
name|ksq_curr
expr_stmt|;
else|else
name|ke
operator|->
name|ke_runq
operator|=
name|kseq
operator|->
name|ksq_next
expr_stmt|;
name|kseq_add
argument_list|(
name|kseq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
block|}
name|int
name|sched_runnable
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|int
name|load
decl_stmt|;
name|load
operator|=
literal|1
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|kseq
operator|=
name|KSEQ_SELF
argument_list|()
expr_stmt|;
if|if
condition|(
name|kseq
operator|->
name|ksq_load
condition|)
goto|goto
name|out
goto|;
ifdef|#
directive|ifdef
name|SMP
comment|/* 	 * For SMP we may steal other processor's KSEs.  Just search until we 	 * verify that at least on other cpu has a runnable task. 	 */
if|if
condition|(
name|smp_started
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp_maxid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
operator|||
operator|(
name|i
operator|&
name|stopped_cpus
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|kseq
operator|=
name|KSEQ_CPU
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|kseq
operator|->
name|ksq_load
operator|>
name|kseq
operator|->
name|ksq_cpus
condition|)
goto|goto
name|out
goto|;
block|}
block|}
endif|#
directive|endif
name|load
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|load
operator|)
return|;
block|}
name|void
name|sched_userret
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
if|#
directive|if
literal|0
block|struct kseq *kseq; 	struct kse *ke;
endif|#
directive|endif
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_priority
operator|!=
name|kg
operator|->
name|kg_user_pri
condition|)
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_priority
operator|=
name|kg
operator|->
name|kg_user_pri
expr_stmt|;
comment|/* 		 * This optimization is temporarily disabled because it 		 * breaks priority propagation. 		 */
if|#
directive|if
literal|0
block|kseq = KSEQ_SELF(); 		if (td->td_ksegrp->kg_pri_class == PRI_TIMESHARE&&
ifdef|#
directive|ifdef
name|SMP
block|kseq->ksq_load> kseq->ksq_cpus&&
else|#
directive|else
block|kseq->ksq_load> 1&&
endif|#
directive|endif
block|(ke = kseq_choose(kseq, 0)) != NULL&& 		    ke->ke_thread->td_priority< td->td_priority)
endif|#
directive|endif
name|curthread
operator|->
name|td_flags
operator||=
name|TDF_NEEDRESCHED
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
block|}
name|struct
name|kse
modifier|*
name|sched_choose
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|retry
label|:
endif|#
directive|endif
name|kseq
operator|=
name|KSEQ_SELF
argument_list|()
expr_stmt|;
name|ke
operator|=
name|kseq_choose
argument_list|(
name|kseq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
condition|)
block|{
name|runq_remove
argument_list|(
name|ke
operator|->
name|ke_runq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_state
operator|=
name|KES_THREAD
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_ksegrp
operator|->
name|kg_pri_class
operator|==
name|PRI_TIMESHARE
condition|)
block|{
name|CTR4
argument_list|(
name|KTR_ULE
argument_list|,
literal|"Run kse %p from %p (slice: %d, pri: %d)"
argument_list|,
name|ke
argument_list|,
name|ke
operator|->
name|ke_runq
argument_list|,
name|ke
operator|->
name|ke_slice
argument_list|,
name|ke
operator|->
name|ke_thread
operator|->
name|td_priority
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ke
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SMP
if|if
condition|(
name|smp_started
condition|)
block|{
comment|/* 		 * Find the cpu with the highest load and steal one proc. 		 */
if|if
condition|(
operator|(
name|kseq
operator|=
name|kseq_load_highest
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 		 * Remove this kse from this kseq and runq and then requeue 		 * on the current processor.  Then we will dequeue it 		 * normally above. 		 */
name|kseq_move
argument_list|(
name|kseq
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|void
name|sched_add
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|struct
name|ksegrp
modifier|*
name|kg
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|kg
operator|=
name|td
operator|->
name|td_ksegrp
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ke
operator|->
name|ke_thread
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"sched_add: No thread on KSE"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ke
operator|->
name|ke_thread
operator|->
name|td_kse
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
literal|"sched_add: No KSE on thread"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ke
operator|->
name|ke_state
operator|!=
name|KES_ONRUNQ
argument_list|,
operator|(
literal|"sched_add: kse %p (%s) already in run queue"
operator|,
name|ke
operator|,
name|ke
operator|->
name|ke_proc
operator|->
name|p_comm
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ke
operator|->
name|ke_proc
operator|->
name|p_sflag
operator|&
name|PS_INMEM
argument_list|,
operator|(
literal|"sched_add: process swapped out"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ke
operator|->
name|ke_runq
operator|==
name|NULL
argument_list|,
operator|(
literal|"sched_add: KSE %p is still assigned to a run queue"
operator|,
name|ke
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|PRI_BASE
argument_list|(
name|kg
operator|->
name|kg_pri_class
argument_list|)
condition|)
block|{
case|case
name|PRI_ITHD
case|:
case|case
name|PRI_REALTIME
case|:
name|kseq
operator|=
name|KSEQ_SELF
argument_list|()
expr_stmt|;
name|ke
operator|->
name|ke_runq
operator|=
name|kseq
operator|->
name|ksq_curr
expr_stmt|;
name|ke
operator|->
name|ke_slice
operator|=
name|SCHED_SLICE_MAX
expr_stmt|;
name|ke
operator|->
name|ke_cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRI_TIMESHARE
case|:
name|kseq
operator|=
name|KSEQ_CPU
argument_list|(
name|ke
operator|->
name|ke_cpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCHED_CURR
argument_list|(
name|kg
argument_list|,
name|ke
argument_list|)
condition|)
name|ke
operator|->
name|ke_runq
operator|=
name|kseq
operator|->
name|ksq_curr
expr_stmt|;
else|else
name|ke
operator|->
name|ke_runq
operator|=
name|kseq
operator|->
name|ksq_next
expr_stmt|;
break|break;
case|case
name|PRI_IDLE
case|:
name|kseq
operator|=
name|KSEQ_CPU
argument_list|(
name|ke
operator|->
name|ke_cpu
argument_list|)
expr_stmt|;
comment|/* 		 * This is for priority prop. 		 */
if|if
condition|(
name|ke
operator|->
name|ke_thread
operator|->
name|td_priority
operator|>
name|PRI_MIN_IDLE
condition|)
name|ke
operator|->
name|ke_runq
operator|=
name|kseq
operator|->
name|ksq_curr
expr_stmt|;
else|else
name|ke
operator|->
name|ke_runq
operator|=
operator|&
name|kseq
operator|->
name|ksq_idle
expr_stmt|;
name|ke
operator|->
name|ke_slice
operator|=
name|SCHED_SLICE_MIN
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Unknown pri class.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|ke
operator|->
name|ke_ksegrp
operator|->
name|kg_runq_kses
operator|++
expr_stmt|;
name|ke
operator|->
name|ke_state
operator|=
name|KES_ONRUNQ
expr_stmt|;
name|runq_add
argument_list|(
name|ke
operator|->
name|ke_runq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|kseq_add
argument_list|(
name|kseq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
block|}
name|void
name|sched_rem
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kseq
modifier|*
name|kseq
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ke
operator|->
name|ke_state
operator|==
name|KES_ONRUNQ
operator|)
argument_list|,
operator|(
literal|"KSE not on run queue"
operator|)
argument_list|)
expr_stmt|;
name|ke
operator|->
name|ke_state
operator|=
name|KES_THREAD
expr_stmt|;
name|ke
operator|->
name|ke_ksegrp
operator|->
name|kg_runq_kses
operator|--
expr_stmt|;
name|kseq
operator|=
name|KSEQ_CPU
argument_list|(
name|ke
operator|->
name|ke_cpu
argument_list|)
expr_stmt|;
name|runq_remove
argument_list|(
name|ke
operator|->
name|ke_runq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
name|kseq_rem
argument_list|(
name|kseq
argument_list|,
name|ke
argument_list|)
expr_stmt|;
block|}
name|fixpt_t
name|sched_pctcpu
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|fixpt_t
name|pctcpu
decl_stmt|;
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|pctcpu
operator|=
literal|0
expr_stmt|;
name|ke
operator|=
name|td
operator|->
name|td_kse
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ke
operator|->
name|ke_ticks
condition|)
block|{
name|int
name|rtick
decl_stmt|;
comment|/* 		 * Don't update more frequently than twice a second.  Allowing 		 * this causes the cpu usage to decay away too quickly due to 		 * rounding errors. 		 */
if|if
condition|(
name|ke
operator|->
name|ke_ltick
operator|<
operator|(
name|ticks
operator|-
operator|(
name|hz
operator|/
literal|2
operator|)
operator|)
condition|)
name|sched_pctcpu_update
argument_list|(
name|ke
argument_list|)
expr_stmt|;
comment|/* How many rtick per second ? */
name|rtick
operator|=
name|min
argument_list|(
name|ke
operator|->
name|ke_ticks
operator|/
name|SCHED_CPU_TIME
argument_list|,
name|SCHED_CPU_TICKS
argument_list|)
expr_stmt|;
name|pctcpu
operator|=
operator|(
name|FSCALE
operator|*
operator|(
operator|(
name|FSCALE
operator|*
name|rtick
operator|)
operator|/
name|realstathz
operator|)
operator|)
operator|>>
name|FSHIFT
expr_stmt|;
block|}
name|ke
operator|->
name|ke_proc
operator|->
name|p_swtime
operator|=
name|ke
operator|->
name|ke_ltick
operator|-
name|ke
operator|->
name|ke_ftick
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|pctcpu
operator|)
return|;
block|}
name|int
name|sched_sizeof_kse
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|kse
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ke_sched
argument_list|)
operator|)
return|;
block|}
name|int
name|sched_sizeof_ksegrp
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ksegrp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|kg_sched
argument_list|)
operator|)
return|;
block|}
name|int
name|sched_sizeof_proc
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|proc
argument_list|)
operator|)
return|;
block|}
name|int
name|sched_sizeof_thread
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|td_sched
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

