begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999,2000 Jonathan Lemon<jlemon@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_zone.h>
end_include

begin_function_decl
specifier|static
name|int
name|filt_nullattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_rwtypattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_kqattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filt_kqdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_kqueue
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_procattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filt_procdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_proc
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kqueue_create
parameter_list|(
name|struct
name|kqueue
modifier|*
modifier|*
name|kqp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kqueue_scan
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|int
name|maxevents
parameter_list|,
name|struct
name|kevent
modifier|*
name|ulistp
parameter_list|,
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kqueue_read
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kqueue_write
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kqueue_ioctl
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|u_long
name|com
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kqueue_poll
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kqueue_stat
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kqueue_close
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kqueue_wakeup
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|knote_attach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|struct
name|filedesc
modifier|*
name|fdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|knote_drop
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|knote_enqueue
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|knote_dequeue
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|knote_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|knote
modifier|*
name|knote_alloc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|knote_free
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|vm_zone_t
name|knote_zone
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KNOTE_ACTIVATE
parameter_list|(
name|kn
parameter_list|)
value|do { 					\ 	kn->kn_status |= KN_ACTIVE;					\ 	if ((kn->kn_status& (KN_QUEUED | KN_DISABLED)) == 0)		\ 		knote_enqueue(kn);					\ } while(0)
end_define

begin_define
define|#
directive|define
name|KN_HASHSIZE
value|64
end_define

begin_comment
comment|/* XXX should be tunable */
end_comment

begin_define
define|#
directive|define
name|KN_HASH
parameter_list|(
name|val
parameter_list|,
name|mask
parameter_list|)
value|(((val) ^ (val>> 8))& (mask))
end_define

begin_decl_stmt
specifier|static
name|struct
name|fileops
name|kqueueops
init|=
block|{
name|kqueue_read
block|,
name|kqueue_write
block|,
name|kqueue_ioctl
block|,
name|kqueue_poll
block|,
name|kqueue_stat
block|,
name|kqueue_close
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|filterops
name|so_rwfiltops
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|filterops
name|fifo_rwfiltops
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|filterops
name|pipe_rwfiltops
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|filterops
name|vn_rwfiltops
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|kq_rwfiltops
index|[]
init|=
block|{
block|{
literal|1
block|,
name|filt_kqattach
block|,
name|filt_kqdetach
block|,
name|filt_kqueue
block|}
block|,
block|{
literal|1
block|,
name|filt_nullattach
block|,
name|NULL
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|filterops
name|aio_filtops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|filterops
name|sig_filtops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|filterops
name|vn_filtops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|rwtype_filtops
init|=
block|{
literal|1
block|,
name|filt_rwtypattach
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|proc_filtops
init|=
block|{
literal|0
block|,
name|filt_procattach
block|,
name|filt_procdetach
block|,
name|filt_proc
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * XXX  * These must match the order of defines in<sys/file.h>  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|filterops
modifier|*
name|rwtypfilt_sw
index|[]
init|=
block|{
name|NULL
block|,
comment|/* 0 */
name|vn_rwfiltops
block|,
comment|/* DTYPE_VNODE */
name|so_rwfiltops
block|,
comment|/* DTYPE_SOCKET */
name|pipe_rwfiltops
block|,
comment|/* DTYPE_PIPE */
name|fifo_rwfiltops
block|,
comment|/* DTYPE_FIFO */
name|kq_rwfiltops
block|,
comment|/* DTYPE_KQUEUE */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * table for for all system-defined filters.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|filterops
modifier|*
name|sysfilt_ops
index|[]
init|=
block|{
operator|&
name|rwtype_filtops
block|,
comment|/* EVFILT_READ */
operator|&
name|rwtype_filtops
block|,
comment|/* EVFILT_WRITE */
operator|&
name|aio_filtops
block|,
comment|/* EVFILT_AIO */
operator|&
name|vn_filtops
block|,
comment|/* EVFILT_VNODE */
operator|&
name|proc_filtops
block|,
comment|/* EVFILT_PROC */
operator|&
name|sig_filtops
block|,
comment|/* EVFILT_SIGNAL */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|filt_nullattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * file-type specific attach routine for read/write filters  */
end_comment

begin_function
specifier|static
name|int
name|filt_rwtypattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|filterops
modifier|*
name|fops
decl_stmt|;
name|fops
operator|=
name|rwtypfilt_sw
index|[
name|kn
operator|->
name|kn_fp
operator|->
name|f_type
index|]
expr_stmt|;
if|if
condition|(
name|fops
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|fops
index|[
operator|~
name|kn
operator|->
name|kn_filter
index|]
expr_stmt|;
comment|/* convert to 0-base index */
return|return
operator|(
name|kn
operator|->
name|kn_fop
operator|->
name|f_attach
argument_list|(
name|kn
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|filt_kqattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
init|=
operator|(
expr|struct
name|kqueue
operator|*
operator|)
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
decl_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
name|kn_selnext
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|filt_kqdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
init|=
operator|(
expr|struct
name|kqueue
operator|*
operator|)
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
decl_stmt|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
name|knote
argument_list|,
name|kn_selnext
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|filt_kqueue
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
init|=
operator|(
expr|struct
name|kqueue
operator|*
operator|)
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
decl_stmt|;
name|kn
operator|->
name|kn_data
operator|=
name|kq
operator|->
name|kq_count
expr_stmt|;
return|return
operator|(
name|kn
operator|->
name|kn_data
operator|>
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|filt_procattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|pfind
argument_list|(
name|kn
operator|->
name|kn_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
if|if
condition|(
operator|!
name|PRISON_CHECK
argument_list|(
name|curproc
argument_list|,
name|p
argument_list|)
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
name|kn
operator|->
name|kn_ptr
operator|.
name|p_proc
operator|=
name|p
expr_stmt|;
name|kn
operator|->
name|kn_flags
operator||=
name|EV_CLEAR
expr_stmt|;
comment|/* automatically set */
comment|/* 	 * internal flag indicating registration done by kernel 	 */
if|if
condition|(
name|kn
operator|->
name|kn_flags
operator|&
name|EV_FLAG1
condition|)
block|{
name|kn
operator|->
name|kn_data
operator|=
name|kn
operator|->
name|kn_sdata
expr_stmt|;
comment|/* ppid */
name|kn
operator|->
name|kn_fflags
operator|=
name|NOTE_CHILD
expr_stmt|;
name|kn
operator|->
name|kn_flags
operator|&=
operator|~
name|EV_FLAG1
expr_stmt|;
block|}
comment|/* XXX lock the proc here while adding to the list? */
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|p
operator|->
name|p_klist
argument_list|,
name|kn
argument_list|,
name|kn_selnext
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The knote may be attached to a different process, which may exit,  * leaving nothing for the knote to be attached to.  So when the process  * exits, the knote is marked as DETACHED and also flagged as ONESHOT so  * it will be deleted when read out.  However, as part of the knote deletion,  * this routine is called, so a check is needed to avoid actually performing  * a detach, because the original process does not exist any more.  */
end_comment

begin_function
specifier|static
name|void
name|filt_procdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|kn
operator|->
name|kn_ptr
operator|.
name|p_proc
decl_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_DETACHED
condition|)
return|return;
comment|/* XXX locking?  this might modify another process. */
name|SLIST_REMOVE
argument_list|(
operator|&
name|p
operator|->
name|p_klist
argument_list|,
name|kn
argument_list|,
name|knote
argument_list|,
name|kn_selnext
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|filt_proc
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|u_int
name|event
decl_stmt|;
comment|/* 	 * mask off extra data 	 */
name|event
operator|=
operator|(
name|u_int
operator|)
name|hint
operator|&
name|NOTE_PCTRLMASK
expr_stmt|;
comment|/* 	 * if the user is interested in this event, record it. 	 */
if|if
condition|(
name|kn
operator|->
name|kn_sfflags
operator|&
name|event
condition|)
name|kn
operator|->
name|kn_fflags
operator||=
name|event
expr_stmt|;
comment|/* 	 * process is gone, so flag the event as finished. 	 */
if|if
condition|(
name|event
operator|==
name|NOTE_EXIT
condition|)
block|{
name|kn
operator|->
name|kn_status
operator||=
name|KN_DETACHED
expr_stmt|;
name|kn
operator|->
name|kn_flags
operator||=
operator|(
name|EV_EOF
operator||
name|EV_ONESHOT
operator|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * process forked, and user wants to track the new process, 	 * so attach a new knote to it, and immediately report an 	 * event with the parent's pid. 	 */
if|if
condition|(
operator|(
name|event
operator|==
name|NOTE_FORK
operator|)
operator|&&
operator|(
name|kn
operator|->
name|kn_sfflags
operator|&
name|NOTE_TRACK
operator|)
condition|)
block|{
name|struct
name|kevent
name|kev
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 		 * register knote with new process. 		 */
name|kev
operator|.
name|ident
operator|=
name|hint
operator|&
name|NOTE_PDATAMASK
expr_stmt|;
comment|/* pid */
name|kev
operator|.
name|filter
operator|=
name|kn
operator|->
name|kn_filter
expr_stmt|;
name|kev
operator|.
name|flags
operator|=
name|kn
operator|->
name|kn_flags
operator||
name|EV_ADD
operator||
name|EV_ENABLE
operator||
name|EV_FLAG1
expr_stmt|;
name|kev
operator|.
name|fflags
operator|=
name|kn
operator|->
name|kn_sfflags
expr_stmt|;
name|kev
operator|.
name|data
operator|=
name|kn
operator|->
name|kn_id
expr_stmt|;
comment|/* parent */
name|error
operator|=
name|kqueue_register
argument_list|(
name|kn
operator|->
name|kn_kq
argument_list|,
operator|&
name|kev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|kn
operator|->
name|kn_fflags
operator||=
name|NOTE_TRACKERR
expr_stmt|;
block|}
return|return
operator|(
name|kn
operator|->
name|kn_fflags
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kqueue_create
parameter_list|(
name|struct
name|kqueue
modifier|*
modifier|*
name|kqp
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|kq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|kqueue
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|kq
operator|==
name|NULL
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
name|bzero
argument_list|(
name|kq
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|kq
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|)
expr_stmt|;
operator|*
name|kqp
operator|=
name|kq
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kqueue
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|kqueue_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
init|=
name|p
operator|->
name|p_fd
decl_stmt|;
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|error
decl_stmt|;
name|error
operator|=
name|falloc
argument_list|(
name|p
argument_list|,
operator|&
name|fp
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|fp
operator|->
name|f_flag
operator|=
name|FREAD
operator||
name|FWRITE
expr_stmt|;
name|fp
operator|->
name|f_type
operator|=
name|DTYPE_KQUEUE
expr_stmt|;
name|fp
operator|->
name|f_ops
operator|=
operator|&
name|kqueueops
expr_stmt|;
name|error
operator|=
name|kqueue_create
argument_list|(
operator|&
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|fdp
operator|->
name|fd_ofiles
index|[
name|fd
index|]
operator|=
literal|0
expr_stmt|;
name|ffree
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fp
operator|->
name|f_data
operator|=
operator|(
name|caddr_t
operator|)
name|kq
expr_stmt|;
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|fd
expr_stmt|;
block|}
name|fdp
operator|->
name|fd_knlistsize
operator|=
literal|0
expr_stmt|;
comment|/* mark this fdesc as having a kq */
name|kq
operator|->
name|kq_fdp
operator|=
name|fdp
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|kevent_args
block|{
name|int
name|fd
decl_stmt|;
name|int
name|nchanges
decl_stmt|;
name|struct
name|kevent
modifier|*
modifier|*
name|changelist
decl_stmt|;
name|int
name|nevents
decl_stmt|;
name|struct
name|kevent
modifier|*
name|eventlist
decl_stmt|;
name|struct
name|timespec
modifier|*
name|timeout
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|kevent
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|kevent_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
init|=
name|p
operator|->
name|p_fd
decl_stmt|;
name|struct
name|kevent
name|kev
decl_stmt|;
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|nerrors
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|u_int
operator|)
name|uap
operator|->
name|fd
operator|)
operator|>=
name|fdp
operator|->
name|fd_nfiles
operator|||
operator|(
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|uap
operator|->
name|fd
index|]
operator|)
operator|==
name|NULL
operator|||
operator|(
name|fp
operator|->
name|f_type
operator|!=
name|DTYPE_KQUEUE
operator|)
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
if|if
condition|(
name|uap
operator|->
name|timeout
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|timeout
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ts
argument_list|,
sizeof|sizeof
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|uap
operator|->
name|timeout
operator|=
operator|&
name|ts
expr_stmt|;
block|}
name|kq
operator|=
operator|(
expr|struct
name|kqueue
operator|*
operator|)
name|fp
operator|->
name|f_data
expr_stmt|;
name|nerrors
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|uap
operator|->
name|nchanges
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|uap
operator|->
name|nchanges
operator|>
name|KQ_NEVENTS
condition|?
name|KQ_NEVENTS
else|:
name|uap
operator|->
name|nchanges
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|changelist
argument_list|,
operator|(
name|caddr_t
operator|)
name|kq
operator|->
name|kq_kevp
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|kq
operator|->
name|kq_kevp
index|[
name|i
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|kev
argument_list|,
sizeof|sizeof
argument_list|(
name|kev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|kev
operator|.
name|flags
operator|&=
operator|~
name|EV_SYSFLAGS
expr_stmt|;
name|error
operator|=
name|kqueue_register
argument_list|(
name|kq
argument_list|,
operator|&
name|kev
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|uap
operator|->
name|nevents
operator|!=
literal|0
condition|)
block|{
name|kev
operator|.
name|flags
operator|=
name|EV_ERROR
expr_stmt|;
name|kev
operator|.
name|data
operator|=
name|error
expr_stmt|;
operator|(
name|void
operator|)
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|kev
argument_list|,
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|eventlist
argument_list|,
sizeof|sizeof
argument_list|(
name|kev
argument_list|)
argument_list|)
expr_stmt|;
name|uap
operator|->
name|eventlist
operator|++
expr_stmt|;
name|uap
operator|->
name|nevents
operator|--
expr_stmt|;
name|nerrors
operator|++
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
block|}
name|uap
operator|->
name|nchanges
operator|-=
name|n
expr_stmt|;
name|uap
operator|->
name|changelist
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|nerrors
condition|)
block|{
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|nerrors
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
name|kqueue_scan
argument_list|(
name|fp
argument_list|,
name|uap
operator|->
name|nevents
argument_list|,
name|uap
operator|->
name|eventlist
argument_list|,
name|uap
operator|->
name|timeout
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kqueue_register
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|,
name|struct
name|kevent
modifier|*
name|kev
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
init|=
name|kq
operator|->
name|kq_fdp
decl_stmt|;
name|struct
name|filterops
modifier|*
name|fops
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|struct
name|knote
modifier|*
name|kn
init|=
name|NULL
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|kev
operator|->
name|filter
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|kev
operator|->
name|filter
operator|+
name|EVFILT_SYSCOUNT
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|fops
operator|=
name|sysfilt_ops
index|[
operator|~
name|kev
operator|->
name|filter
index|]
expr_stmt|;
comment|/* to 0-base index */
block|}
else|else
block|{
comment|/* 		 * XXX 		 * filter attach routine is responsible for insuring that 		 * the identifier can be attached to it. 		 */
name|printf
argument_list|(
literal|"unknown filter: %d\n"
argument_list|,
name|kev
operator|->
name|filter
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|fops
operator|->
name|f_isfd
condition|)
block|{
comment|/* validate descriptor; ignore invalid descriptors */
if|if
condition|(
operator|(
name|u_int
operator|)
name|kev
operator|->
name|ident
operator|>=
name|fdp
operator|->
name|fd_nfiles
operator|||
operator|(
name|fp
operator|=
name|fdp
operator|->
name|fd_ofiles
index|[
name|kev
operator|->
name|ident
index|]
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|kev
operator|->
name|ident
operator|<
name|fdp
operator|->
name|fd_knlistsize
condition|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|kn
argument_list|,
argument|&fdp->fd_knlist[kev->ident]
argument_list|,
argument|kn_link
argument_list|)
if|if
condition|(
name|kq
operator|==
name|kn
operator|->
name|kn_kq
operator|&&
name|kev
operator|->
name|filter
operator|==
name|kn
operator|->
name|kn_filter
condition|)
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|fdp
operator|->
name|fd_knhashmask
operator|!=
literal|0
condition|)
block|{
name|struct
name|klist
modifier|*
name|list
decl_stmt|;
name|list
operator|=
operator|&
name|fdp
operator|->
name|fd_knhash
index|[
name|KN_HASH
argument_list|(
operator|(
name|u_long
operator|)
name|kev
operator|->
name|ident
argument_list|,
name|fdp
operator|->
name|fd_knhashmask
argument_list|)
index|]
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|kn
argument_list|,
argument|list
argument_list|,
argument|kn_link
argument_list|)
if|if
condition|(
name|kev
operator|->
name|ident
operator|==
name|kn
operator|->
name|kn_id
operator|&&
name|kq
operator|==
name|kn
operator|->
name|kn_kq
operator|&&
name|kev
operator|->
name|filter
operator|==
name|kn
operator|->
name|kn_filter
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|kn
operator|==
name|NULL
operator|&&
operator|(
operator|(
name|kev
operator|->
name|flags
operator|&
name|EV_ADD
operator|)
operator|==
literal|0
operator|)
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * kn now contains the matching knote, or NULL if no match 	 */
if|if
condition|(
name|kev
operator|->
name|flags
operator|&
name|EV_ADD
condition|)
block|{
name|int
name|attach
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|kn
operator|==
name|NULL
condition|)
block|{
name|kn
operator|=
name|knote_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|kn
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
name|fhold
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_fp
operator|=
name|fp
expr_stmt|;
name|kn
operator|->
name|kn_kq
operator|=
name|kq
expr_stmt|;
name|kn
operator|->
name|kn_fop
operator|=
name|fops
expr_stmt|;
name|attach
operator|=
literal|1
expr_stmt|;
block|}
name|kn
operator|->
name|kn_sfflags
operator|=
name|kev
operator|->
name|fflags
expr_stmt|;
name|kn
operator|->
name|kn_sdata
operator|=
name|kev
operator|->
name|data
expr_stmt|;
name|kev
operator|->
name|fflags
operator|=
literal|0
expr_stmt|;
name|kev
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|kn
operator|->
name|kn_kevent
operator|=
operator|*
name|kev
expr_stmt|;
if|if
condition|(
name|attach
condition|)
block|{
name|knote_attach
argument_list|(
name|kn
argument_list|,
name|fdp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fops
operator|->
name|f_attach
argument_list|(
name|kn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|knote_drop
argument_list|(
name|kn
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_fop
operator|->
name|f_event
argument_list|(
name|kn
argument_list|,
literal|0
argument_list|)
condition|)
name|KNOTE_ACTIVATE
argument_list|(
name|kn
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kev
operator|->
name|flags
operator|&
name|EV_DELETE
condition|)
block|{
name|kn
operator|->
name|kn_fop
operator|->
name|f_detach
argument_list|(
name|kn
argument_list|)
expr_stmt|;
name|knote_drop
argument_list|(
name|kn
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|kev
operator|->
name|flags
operator|&
name|EV_DISABLE
operator|)
operator|&&
operator|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_DISABLED
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|kn
operator|->
name|kn_status
operator||=
name|KN_DISABLED
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|kev
operator|->
name|flags
operator|&
name|EV_ENABLE
operator|)
operator|&&
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_DISABLED
operator|)
condition|)
block|{
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|kn
operator|->
name|kn_status
operator|&=
operator|~
name|KN_DISABLED
expr_stmt|;
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_ACTIVE
operator|)
operator|&&
operator|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_QUEUED
operator|)
operator|==
literal|0
operator|)
condition|)
name|knote_enqueue
argument_list|(
name|kn
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|done
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kqueue_scan
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|int
name|maxevents
parameter_list|,
name|struct
name|kevent
modifier|*
name|ulistp
parameter_list|,
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
init|=
operator|(
expr|struct
name|kqueue
operator|*
operator|)
name|fp
operator|->
name|f_data
decl_stmt|;
name|struct
name|kevent
modifier|*
name|kevp
decl_stmt|;
name|struct
name|timeval
name|atv
decl_stmt|,
name|rtv
decl_stmt|,
name|ttv
decl_stmt|;
name|struct
name|knote
modifier|*
name|kn
decl_stmt|,
name|marker
decl_stmt|;
name|int
name|s
decl_stmt|,
name|count
decl_stmt|,
name|timeout
decl_stmt|,
name|nkev
init|=
literal|0
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|count
operator|=
name|maxevents
expr_stmt|;
if|if
condition|(
name|count
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|tsp
operator|!=
name|NULL
condition|)
block|{
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|atv
argument_list|,
name|tsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|itimerfix
argument_list|(
operator|&
name|atv
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|timeout
operator|=
name|atv
operator|.
name|tv_sec
operator|>
literal|24
operator|*
literal|60
operator|*
literal|60
condition|?
literal|24
operator|*
literal|60
operator|*
literal|60
operator|*
name|hz
else|:
name|tvtohz
argument_list|(
operator|&
name|atv
argument_list|)
expr_stmt|;
name|getmicrouptime
argument_list|(
operator|&
name|rtv
argument_list|)
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|atv
argument_list|,
operator|&
name|rtv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|atv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|start
goto|;
name|retry
label|:
if|if
condition|(
name|atv
operator|.
name|tv_sec
condition|)
block|{
name|getmicrouptime
argument_list|(
operator|&
name|rtv
argument_list|)
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|rtv
argument_list|,
operator|&
name|atv
argument_list|,
operator|>=
argument_list|)
condition|)
goto|goto
name|done
goto|;
name|ttv
operator|=
name|atv
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|ttv
argument_list|,
operator|&
name|rtv
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|ttv
operator|.
name|tv_sec
operator|>
literal|24
operator|*
literal|60
operator|*
literal|60
condition|?
literal|24
operator|*
literal|60
operator|*
literal|60
operator|*
name|hz
else|:
name|tvtohz
argument_list|(
operator|&
name|ttv
argument_list|)
expr_stmt|;
block|}
name|start
label|:
name|kevp
operator|=
name|kq
operator|->
name|kq_kev
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|kq
operator|->
name|kq_count
operator|==
literal|0
condition|)
block|{
name|kq
operator|->
name|kq_state
operator||=
name|KQ_SLEEP
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
name|kq
argument_list|,
name|PSOCK
operator||
name|PCATCH
argument_list|,
literal|"kqread"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
goto|goto
name|retry
goto|;
comment|/* don't restart after signals... */
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|,
operator|&
name|marker
argument_list|,
name|kn_tqe
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|kn
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|,
name|kn
argument_list|,
name|kn_tqe
argument_list|)
expr_stmt|;
if|if
condition|(
name|kn
operator|==
operator|&
name|marker
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|maxevents
condition|)
goto|goto
name|retry
goto|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_DISABLED
condition|)
block|{
name|kn
operator|->
name|kn_status
operator|&=
operator|~
name|KN_QUEUED
expr_stmt|;
name|kq
operator|->
name|kq_count
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_flags
operator|&
name|EV_ONESHOT
operator|)
operator|==
literal|0
operator|&&
name|kn
operator|->
name|kn_fop
operator|->
name|f_event
argument_list|(
name|kn
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|kn
operator|->
name|kn_status
operator|&=
operator|~
operator|(
name|KN_QUEUED
operator||
name|KN_ACTIVE
operator|)
expr_stmt|;
name|kq
operator|->
name|kq_count
operator|--
expr_stmt|;
continue|continue;
block|}
operator|*
name|kevp
operator|=
name|kn
operator|->
name|kn_kevent
expr_stmt|;
name|kevp
operator|++
expr_stmt|;
name|nkev
operator|++
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_flags
operator|&
name|EV_ONESHOT
condition|)
block|{
name|kn
operator|->
name|kn_status
operator|&=
operator|~
name|KN_QUEUED
expr_stmt|;
name|kq
operator|->
name|kq_count
operator|--
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_fop
operator|->
name|f_detach
argument_list|(
name|kn
argument_list|)
expr_stmt|;
name|knote_drop
argument_list|(
name|kn
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kn
operator|->
name|kn_flags
operator|&
name|EV_CLEAR
condition|)
block|{
name|kn
operator|->
name|kn_data
operator|=
literal|0
expr_stmt|;
name|kn
operator|->
name|kn_fflags
operator|=
literal|0
expr_stmt|;
name|kn
operator|->
name|kn_status
operator|&=
operator|~
operator|(
name|KN_QUEUED
operator||
name|KN_ACTIVE
operator|)
expr_stmt|;
name|kq
operator|->
name|kq_count
operator|--
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|,
name|kn
argument_list|,
name|kn_tqe
argument_list|)
expr_stmt|;
block|}
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|nkev
operator|==
name|KQ_NEVENTS
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|kq
operator|->
name|kq_kev
argument_list|,
operator|(
name|caddr_t
operator|)
name|ulistp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
operator|*
name|nkev
argument_list|)
expr_stmt|;
name|ulistp
operator|+=
name|nkev
expr_stmt|;
name|nkev
operator|=
literal|0
expr_stmt|;
name|kevp
operator|=
name|kq
operator|->
name|kq_kev
expr_stmt|;
name|s
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|,
operator|&
name|marker
argument_list|,
name|kn_tqe
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|nkev
operator|!=
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|kq
operator|->
name|kq_kev
argument_list|,
operator|(
name|caddr_t
operator|)
name|ulistp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
operator|*
name|nkev
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_retval
index|[
literal|0
index|]
operator|=
name|maxevents
operator|-
name|count
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX  * This could be expanded to call kqueue_scan, if desired.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|kqueue_read
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|kqueue_write
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|kqueue_ioctl
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|u_long
name|com
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|kqueue_poll
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
init|=
operator|(
expr|struct
name|kqueue
operator|*
operator|)
name|fp
operator|->
name|f_data
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
if|if
condition|(
name|kq
operator|->
name|kq_count
condition|)
block|{
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
else|else
block|{
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|kq
operator|->
name|kq_sel
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_state
operator||=
name|KQ_SEL
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|kqueue_stat
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
init|=
operator|(
expr|struct
name|kqueue
operator|*
operator|)
name|fp
operator|->
name|f_data
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|st
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|st
argument_list|)
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_size
operator|=
name|kq
operator|->
name|kq_count
expr_stmt|;
name|st
operator|->
name|st_blksize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|kqueue_close
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
init|=
operator|(
expr|struct
name|kqueue
operator|*
operator|)
name|fp
operator|->
name|f_data
decl_stmt|;
name|struct
name|filedesc
modifier|*
name|fdp
init|=
name|p
operator|->
name|p_fd
decl_stmt|;
name|struct
name|knote
modifier|*
modifier|*
name|knp
decl_stmt|,
modifier|*
name|kn
decl_stmt|,
modifier|*
name|kn0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fdp
operator|->
name|fd_knlistsize
condition|;
name|i
operator|++
control|)
block|{
name|knp
operator|=
operator|&
name|SLIST_FIRST
argument_list|(
operator|&
name|fdp
operator|->
name|fd_knlist
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kn
operator|=
operator|*
name|knp
expr_stmt|;
while|while
condition|(
name|kn
operator|!=
name|NULL
condition|)
block|{
name|kn0
operator|=
name|SLIST_NEXT
argument_list|(
name|kn
argument_list|,
name|kn_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|kq
operator|==
name|kn
operator|->
name|kn_kq
condition|)
block|{
name|kn
operator|->
name|kn_fop
operator|->
name|f_detach
argument_list|(
name|kn
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|kn
operator|->
name|kn_fp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|knote_free
argument_list|(
name|kn
argument_list|)
expr_stmt|;
operator|*
name|knp
operator|=
name|kn0
expr_stmt|;
block|}
else|else
block|{
name|knp
operator|=
operator|&
name|SLIST_NEXT
argument_list|(
name|kn
argument_list|,
name|kn_link
argument_list|)
expr_stmt|;
block|}
name|kn
operator|=
name|kn0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fdp
operator|->
name|fd_knhashmask
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fdp
operator|->
name|fd_knhashmask
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|knp
operator|=
operator|&
name|SLIST_FIRST
argument_list|(
operator|&
name|fdp
operator|->
name|fd_knhash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kn
operator|=
operator|*
name|knp
expr_stmt|;
while|while
condition|(
name|kn
operator|!=
name|NULL
condition|)
block|{
name|kn0
operator|=
name|SLIST_NEXT
argument_list|(
name|kn
argument_list|,
name|kn_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|kq
operator|==
name|kn
operator|->
name|kn_kq
condition|)
block|{
name|kn
operator|->
name|kn_fop
operator|->
name|f_detach
argument_list|(
name|kn
argument_list|)
expr_stmt|;
comment|/* XXX non-fd release of kn->kn_ptr */
name|knote_free
argument_list|(
name|kn
argument_list|)
expr_stmt|;
operator|*
name|knp
operator|=
name|kn0
expr_stmt|;
block|}
else|else
block|{
name|knp
operator|=
operator|&
name|SLIST_NEXT
argument_list|(
name|kn
argument_list|,
name|kn_link
argument_list|)
expr_stmt|;
block|}
name|kn
operator|=
name|kn0
expr_stmt|;
block|}
block|}
block|}
name|free
argument_list|(
name|kq
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kqueue_wakeup
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|)
block|{
if|if
condition|(
name|kq
operator|->
name|kq_state
operator|&
name|KQ_SLEEP
condition|)
block|{
name|kq
operator|->
name|kq_state
operator|&=
operator|~
name|KQ_SLEEP
expr_stmt|;
name|wakeup
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kq
operator|->
name|kq_state
operator|&
name|KQ_SEL
condition|)
block|{
name|kq
operator|->
name|kq_state
operator|&=
operator|~
name|KQ_SEL
expr_stmt|;
name|selwakeup
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
argument_list|)
expr_stmt|;
block|}
name|KNOTE
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
operator|.
name|si_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * walk down a list of knotes, activating them if their event has triggered.  */
end_comment

begin_function
name|void
name|knote
parameter_list|(
name|struct
name|klist
modifier|*
name|list
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|knote
modifier|*
name|kn
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|kn
argument_list|,
argument|list
argument_list|,
argument|kn_selnext
argument_list|)
if|if
condition|(
name|kn
operator|->
name|kn_fop
operator|->
name|f_event
argument_list|(
name|kn
argument_list|,
name|hint
argument_list|)
condition|)
name|KNOTE_ACTIVATE
argument_list|(
name|kn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove all knotes from a specified klist  */
end_comment

begin_function
name|void
name|knote_remove
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|klist
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|knote
modifier|*
name|kn
decl_stmt|;
while|while
condition|(
operator|(
name|kn
operator|=
name|SLIST_FIRST
argument_list|(
name|list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|kn
operator|->
name|kn_fop
operator|->
name|f_detach
argument_list|(
name|kn
argument_list|)
expr_stmt|;
name|knote_drop
argument_list|(
name|kn
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * remove all knotes referencing a specified fd  */
end_comment

begin_function
name|void
name|knote_fdclose
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
init|=
name|p
operator|->
name|p_fd
decl_stmt|;
name|struct
name|klist
modifier|*
name|list
init|=
operator|&
name|fdp
operator|->
name|fd_knlist
index|[
name|fd
index|]
decl_stmt|;
name|knote_remove
argument_list|(
name|p
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|knote_attach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|struct
name|filedesc
modifier|*
name|fdp
parameter_list|)
block|{
name|struct
name|klist
modifier|*
name|list
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|kn
operator|->
name|kn_fop
operator|->
name|f_isfd
condition|)
block|{
if|if
condition|(
name|fdp
operator|->
name|fd_knhashmask
operator|==
literal|0
condition|)
name|fdp
operator|->
name|fd_knhash
operator|=
name|hashinit
argument_list|(
name|KN_HASHSIZE
argument_list|,
name|M_TEMP
argument_list|,
operator|&
name|fdp
operator|->
name|fd_knhashmask
argument_list|)
expr_stmt|;
name|list
operator|=
operator|&
name|fdp
operator|->
name|fd_knhash
index|[
name|KN_HASH
argument_list|(
name|kn
operator|->
name|kn_id
argument_list|,
name|fdp
operator|->
name|fd_knhashmask
argument_list|)
index|]
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|fdp
operator|->
name|fd_knlistsize
operator|<=
name|kn
operator|->
name|kn_id
condition|)
block|{
name|size
operator|=
name|fdp
operator|->
name|fd_knlistsize
expr_stmt|;
while|while
condition|(
name|size
operator|<=
name|kn
operator|->
name|kn_id
condition|)
name|size
operator|+=
name|KQEXTENT
expr_stmt|;
name|MALLOC
argument_list|(
name|list
argument_list|,
expr|struct
name|klist
operator|*
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|klist
operator|*
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|fdp
operator|->
name|fd_knlist
argument_list|,
operator|(
name|caddr_t
operator|)
name|list
argument_list|,
name|fdp
operator|->
name|fd_knlistsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|klist
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|list
operator|+
name|fdp
operator|->
name|fd_knlistsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|klist
operator|*
argument_list|)
argument_list|,
operator|(
name|size
operator|-
name|fdp
operator|->
name|fd_knlistsize
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|klist
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdp
operator|->
name|fd_knlist
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|fdp
operator|->
name|fd_knlist
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|fdp
operator|->
name|fd_knlistsize
operator|=
name|size
expr_stmt|;
name|fdp
operator|->
name|fd_knlist
operator|=
name|list
expr_stmt|;
block|}
name|list
operator|=
operator|&
name|fdp
operator|->
name|fd_knlist
index|[
name|kn
operator|->
name|kn_id
index|]
expr_stmt|;
name|done
label|:
name|SLIST_INSERT_HEAD
argument_list|(
name|list
argument_list|,
name|kn
argument_list|,
name|kn_link
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * should be called at spl == 0, since we don't want to hold spl  * while calling fdrop and free.  */
end_comment

begin_function
specifier|static
name|void
name|knote_drop
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
init|=
name|p
operator|->
name|p_fd
decl_stmt|;
name|struct
name|klist
modifier|*
name|list
decl_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_fop
operator|->
name|f_isfd
condition|)
name|list
operator|=
operator|&
name|fdp
operator|->
name|fd_knlist
index|[
name|kn
operator|->
name|kn_id
index|]
expr_stmt|;
else|else
name|list
operator|=
operator|&
name|fdp
operator|->
name|fd_knhash
index|[
name|KN_HASH
argument_list|(
name|kn
operator|->
name|kn_id
argument_list|,
name|fdp
operator|->
name|fd_knhashmask
argument_list|)
index|]
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
name|list
argument_list|,
name|kn
argument_list|,
name|knote
argument_list|,
name|kn_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_QUEUED
condition|)
name|knote_dequeue
argument_list|(
name|kn
argument_list|)
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_fop
operator|->
name|f_isfd
condition|)
name|fdrop
argument_list|(
name|kn
operator|->
name|kn_fp
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|knote_free
argument_list|(
name|kn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|knote_enqueue
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
init|=
name|kn
operator|->
name|kn_kq
decl_stmt|;
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_QUEUED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"knote already queued"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|,
name|kn
argument_list|,
name|kn_tqe
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator||=
name|KN_QUEUED
expr_stmt|;
name|kq
operator|->
name|kq_count
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|kqueue_wakeup
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|knote_dequeue
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
init|=
name|kn
operator|->
name|kn_kq
decl_stmt|;
name|int
name|s
init|=
name|splhigh
argument_list|()
decl_stmt|;
name|KASSERT
argument_list|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_QUEUED
argument_list|,
operator|(
literal|"knote not queued"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|,
name|kn
argument_list|,
name|kn_tqe
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator|&=
operator|~
name|KN_QUEUED
expr_stmt|;
name|kq
operator|->
name|kq_count
operator|--
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|knote_init
parameter_list|(
name|void
parameter_list|)
block|{
name|knote_zone
operator|=
name|zinit
argument_list|(
literal|"KNOTE"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|knote
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|knote
argument_list|,
argument|SI_SUB_PSEUDO
argument_list|,
argument|SI_ORDER_ANY
argument_list|,
argument|knote_init
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_function
specifier|static
name|struct
name|knote
modifier|*
name|knote_alloc
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|(
expr|struct
name|knote
operator|*
operator|)
name|zalloc
argument_list|(
name|knote_zone
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|knote_free
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|zfree
argument_list|(
name|knote_zone
argument_list|,
name|kn
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

