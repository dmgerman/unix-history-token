begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999,2000,2001 Jonathan Lemon<jlemon@FreeBSD.org>  * Copyright 2004 John-Mark Gurney<jmg@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ktrace.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/sigio.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KTRACE
end_ifdef

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_KQUEUE
argument_list|,
literal|"kqueue"
argument_list|,
literal|"memory for kqueue system"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This lock is used if multiple kq locks are required.  This possibly  * should be made into a per proc lock.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|kq_global
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|kq_global
argument_list|,
operator|&
name|kq_global
argument_list|,
literal|"kqueue order"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|KQ_GLOBAL_LOCK
parameter_list|(
name|lck
parameter_list|,
name|haslck
parameter_list|)
value|do {	\ 	if (!haslck)				\ 		mtx_lock(lck);			\ 	haslck = 1;				\ } while (0)
end_define

begin_define
define|#
directive|define
name|KQ_GLOBAL_UNLOCK
parameter_list|(
name|lck
parameter_list|,
name|haslck
parameter_list|)
value|do {	\ 	if (haslck)				\ 		mtx_unlock(lck);			\ 	haslck = 0;				\ } while (0)
end_define

begin_expr_stmt
name|TASKQUEUE_DEFINE_THREAD
argument_list|(
name|kqueue
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|kevent_copyout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|kevent
modifier|*
name|kevp
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kevent_copyin
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|kevent
modifier|*
name|kevp
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kqueue_register
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|,
name|struct
name|kevent
modifier|*
name|kev
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|waitok
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kqueue_aquire
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|kqueue
modifier|*
modifier|*
name|kqp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kqueue_release
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|,
name|int
name|locked
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kqueue_expand
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|,
name|struct
name|filterops
modifier|*
name|fops
parameter_list|,
name|uintptr_t
name|ident
parameter_list|,
name|int
name|waitok
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kqueue_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|kqueue_scan
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|,
name|int
name|maxevents
parameter_list|,
name|struct
name|kevent_copyops
modifier|*
name|k_ops
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|,
name|struct
name|kevent
modifier|*
name|keva
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kqueue_wakeup
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|filterops
modifier|*
name|kqueue_fo_find
parameter_list|(
name|int
name|filt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kqueue_fo_release
parameter_list|(
name|int
name|filt
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|fo_rdwr_t
name|kqueue_read
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_rdwr_t
name|kqueue_write
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_ioctl_t
name|kqueue_ioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_poll_t
name|kqueue_poll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_kqfilter_t
name|kqueue_kqfilter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_stat_t
name|kqueue_stat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fo_close_t
name|kqueue_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fileops
name|kqueueops
init|=
block|{
operator|.
name|fo_read
operator|=
name|kqueue_read
block|,
operator|.
name|fo_write
operator|=
name|kqueue_write
block|,
operator|.
name|fo_ioctl
operator|=
name|kqueue_ioctl
block|,
operator|.
name|fo_poll
operator|=
name|kqueue_poll
block|,
operator|.
name|fo_kqfilter
operator|=
name|kqueue_kqfilter
block|,
operator|.
name|fo_stat
operator|=
name|kqueue_stat
block|,
operator|.
name|fo_close
operator|=
name|kqueue_close
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|knote_attach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|knote_drop
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|knote_enqueue
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|knote_dequeue
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|knote_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|knote
modifier|*
name|knote_alloc
parameter_list|(
name|int
name|waitok
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|knote_free
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filt_kqdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_kqueue
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_procattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filt_procdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_proc
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_fileattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filt_timerexpire
parameter_list|(
name|void
modifier|*
name|knx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_timerattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filt_timerdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_timer
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|file_filtops
init|=
block|{
literal|1
block|,
name|filt_fileattach
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|kqread_filtops
init|=
block|{
literal|1
block|,
name|NULL
block|,
name|filt_kqdetach
block|,
name|filt_kqueue
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX - move to kern_proc.c?  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|proc_filtops
init|=
block|{
literal|0
block|,
name|filt_procattach
block|,
name|filt_procdetach
block|,
name|filt_proc
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|timer_filtops
init|=
block|{
literal|0
block|,
name|filt_timerattach
block|,
name|filt_timerdetach
block|,
name|filt_timer
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|knote_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kq_ncallouts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|kq_calloutmax
init|=
operator|(
literal|4
operator|*
literal|1024
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|kq_calloutmax
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|kq_calloutmax
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of callouts allocated for kqueue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* XXX - ensure not KN_INFLUX?? */
end_comment

begin_define
define|#
directive|define
name|KNOTE_ACTIVATE
parameter_list|(
name|kn
parameter_list|,
name|islock
parameter_list|)
value|do { 				\ 	if ((islock))							\ 		mtx_assert(&(kn)->kn_kq->kq_lock, MA_OWNED);		\ 	else								\ 		KQ_LOCK((kn)->kn_kq);					\ 	(kn)->kn_status |= KN_ACTIVE;					\ 	if (((kn)->kn_status& (KN_QUEUED | KN_DISABLED)) == 0)		\ 		knote_enqueue((kn));					\ 	if (!(islock))							\ 		KQ_UNLOCK((kn)->kn_kq);					\ } while(0)
end_define

begin_define
define|#
directive|define
name|KQ_LOCK
parameter_list|(
name|kq
parameter_list|)
value|do {						\ 	mtx_lock(&(kq)->kq_lock);					\ } while (0)
end_define

begin_define
define|#
directive|define
name|KQ_FLUX_WAKEUP
parameter_list|(
name|kq
parameter_list|)
value|do {						\ 	if (((kq)->kq_state& KQ_FLUXWAIT) == KQ_FLUXWAIT) {		\ 		(kq)->kq_state&= ~KQ_FLUXWAIT;				\ 		wakeup((kq));						\ 	}								\ } while (0)
end_define

begin_define
define|#
directive|define
name|KQ_UNLOCK_FLUX
parameter_list|(
name|kq
parameter_list|)
value|do {						\ 	KQ_FLUX_WAKEUP(kq);						\ 	mtx_unlock(&(kq)->kq_lock);					\ } while (0)
end_define

begin_define
define|#
directive|define
name|KQ_UNLOCK
parameter_list|(
name|kq
parameter_list|)
value|do {						\ 	mtx_unlock(&(kq)->kq_lock);					\ } while (0)
end_define

begin_define
define|#
directive|define
name|KQ_OWNED
parameter_list|(
name|kq
parameter_list|)
value|do {						\ 	mtx_assert(&(kq)->kq_lock, MA_OWNED);				\ } while (0)
end_define

begin_define
define|#
directive|define
name|KQ_NOTOWNED
parameter_list|(
name|kq
parameter_list|)
value|do {						\ 	mtx_assert(&(kq)->kq_lock, MA_NOTOWNED);			\ } while (0)
end_define

begin_define
define|#
directive|define
name|KN_LIST_LOCK
parameter_list|(
name|kn
parameter_list|)
value|do {						\ 	if (kn->kn_knlist != NULL)					\ 		kn->kn_knlist->kl_lock(kn->kn_knlist->kl_lockarg);	\ } while (0)
end_define

begin_define
define|#
directive|define
name|KN_LIST_UNLOCK
parameter_list|(
name|kn
parameter_list|)
value|do {						\ 	if (kn->kn_knlist != NULL) 					\ 		kn->kn_knlist->kl_unlock(kn->kn_knlist->kl_lockarg);	\ } while (0)
end_define

begin_define
define|#
directive|define
name|KNL_ASSERT_LOCK
parameter_list|(
name|knl
parameter_list|,
name|islocked
parameter_list|)
value|do {				\ 	if (islocked)							\ 		KNL_ASSERT_LOCKED(knl);				\ 	else								\ 		KNL_ASSERT_UNLOCKED(knl);				\ } while (0)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANTS
end_ifdef

begin_define
define|#
directive|define
name|KNL_ASSERT_LOCKED
parameter_list|(
name|knl
parameter_list|)
value|do {					\ 	if (!knl->kl_locked((knl)->kl_lockarg))				\ 			panic("knlist not locked, but should be");	\ } while (0)
end_define

begin_define
define|#
directive|define
name|KNL_ASSERT_UNLOCKED
parameter_list|(
name|knl
parameter_list|)
value|do {				\ 	if (knl->kl_locked((knl)->kl_lockarg))				\ 		panic("knlist locked, but should not be");		\ } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !INVARIANTS */
end_comment

begin_define
define|#
directive|define
name|KNL_ASSERT_LOCKED
parameter_list|(
name|knl
parameter_list|)
value|do {} while(0)
end_define

begin_define
define|#
directive|define
name|KNL_ASSERT_UNLOCKED
parameter_list|(
name|knl
parameter_list|)
value|do {} while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INVARIANTS */
end_comment

begin_define
define|#
directive|define
name|KN_HASHSIZE
value|64
end_define

begin_comment
comment|/* XXX should be tunable */
end_comment

begin_define
define|#
directive|define
name|KN_HASH
parameter_list|(
name|val
parameter_list|,
name|mask
parameter_list|)
value|(((val) ^ (val>> 8))& (mask))
end_define

begin_function
specifier|static
name|int
name|filt_nullattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|struct
name|filterops
name|null_filtops
init|=
block|{
literal|0
block|,
name|filt_nullattach
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX - make SYSINIT to add these, and move into respective modules. */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|filterops
name|sig_filtops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|filterops
name|fs_filtops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Table for for all system-defined filters.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|filterops_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|kqueue_filterops
argument_list|,
operator|&
name|filterops_lock
argument_list|,
literal|"protect sysfilt_ops"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
specifier|static
struct|struct
block|{
name|struct
name|filterops
modifier|*
name|for_fop
decl_stmt|;
name|int
name|for_refcnt
decl_stmt|;
block|}
name|sysfilt_ops
index|[
name|EVFILT_SYSCOUNT
index|]
init|=
block|{
block|{
operator|&
name|file_filtops
block|}
block|,
comment|/* EVFILT_READ */
block|{
operator|&
name|file_filtops
block|}
block|,
comment|/* EVFILT_WRITE */
block|{
operator|&
name|null_filtops
block|}
block|,
comment|/* EVFILT_AIO */
block|{
operator|&
name|file_filtops
block|}
block|,
comment|/* EVFILT_VNODE */
block|{
operator|&
name|proc_filtops
block|}
block|,
comment|/* EVFILT_PROC */
block|{
operator|&
name|sig_filtops
block|}
block|,
comment|/* EVFILT_SIGNAL */
block|{
operator|&
name|timer_filtops
block|}
block|,
comment|/* EVFILT_TIMER */
block|{
operator|&
name|file_filtops
block|}
block|,
comment|/* EVFILT_NETDEV */
block|{
operator|&
name|fs_filtops
block|}
block|,
comment|/* EVFILT_FS */
block|{
operator|&
name|null_filtops
block|}
block|,
comment|/* EVFILT_LIO */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Simple redirection for all cdevsw style objects to call their fo_kqfilter  * method.  */
end_comment

begin_function
specifier|static
name|int
name|filt_fileattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
return|return
operator|(
name|fo_kqfilter
argument_list|(
name|kn
operator|->
name|kn_fp
argument_list|,
name|kn
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|kqueue_kqfilter
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
init|=
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
decl_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_filter
operator|!=
name|EVFILT_READ
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|kn
operator|->
name|kn_status
operator||=
name|KN_KQUEUE
expr_stmt|;
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|kqread_filtops
expr_stmt|;
name|knlist_add
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|filt_kqdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
init|=
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
decl_stmt|;
name|knlist_remove
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|filt_kqueue
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
init|=
name|kn
operator|->
name|kn_fp
operator|->
name|f_data
decl_stmt|;
name|kn
operator|->
name|kn_data
operator|=
name|kq
operator|->
name|kq_count
expr_stmt|;
return|return
operator|(
name|kn
operator|->
name|kn_data
operator|>
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* XXX - move to kern_proc.c?  */
end_comment

begin_function
specifier|static
name|int
name|filt_procattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|immediate
decl_stmt|;
name|int
name|error
decl_stmt|;
name|immediate
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|pfind
argument_list|(
name|kn
operator|->
name|kn_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|&&
operator|(
name|kn
operator|->
name|kn_sfflags
operator|&
name|NOTE_EXIT
operator|)
condition|)
block|{
name|p
operator|=
name|zpfind
argument_list|(
name|kn
operator|->
name|kn_id
argument_list|)
expr_stmt|;
name|immediate
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|(
name|p
operator|->
name|p_flag
operator|&
name|P_WEXIT
operator|)
condition|)
block|{
name|immediate
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|p_cansee
argument_list|(
name|curthread
argument_list|,
name|p
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|kn
operator|->
name|kn_ptr
operator|.
name|p_proc
operator|=
name|p
expr_stmt|;
name|kn
operator|->
name|kn_flags
operator||=
name|EV_CLEAR
expr_stmt|;
comment|/* automatically set */
comment|/* 	 * internal flag indicating registration done by kernel 	 */
if|if
condition|(
name|kn
operator|->
name|kn_flags
operator|&
name|EV_FLAG1
condition|)
block|{
name|kn
operator|->
name|kn_data
operator|=
name|kn
operator|->
name|kn_sdata
expr_stmt|;
comment|/* ppid */
name|kn
operator|->
name|kn_fflags
operator|=
name|NOTE_CHILD
expr_stmt|;
name|kn
operator|->
name|kn_flags
operator|&=
operator|~
name|EV_FLAG1
expr_stmt|;
block|}
if|if
condition|(
name|immediate
operator|==
literal|0
condition|)
name|knlist_add
argument_list|(
operator|&
name|p
operator|->
name|p_klist
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Immediately activate any exit notes if the target process is a 	 * zombie.  This is necessary to handle the case where the target 	 * process, e.g. a child, dies before the kevent is registered. 	 */
if|if
condition|(
name|immediate
operator|&&
name|filt_proc
argument_list|(
name|kn
argument_list|,
name|NOTE_EXIT
argument_list|)
condition|)
name|KNOTE_ACTIVATE
argument_list|(
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The knote may be attached to a different process, which may exit,  * leaving nothing for the knote to be attached to.  So when the process  * exits, the knote is marked as DETACHED and also flagged as ONESHOT so  * it will be deleted when read out.  However, as part of the knote deletion,  * this routine is called, so a check is needed to avoid actually performing  * a detach, because the original process does not exist any more.  */
end_comment

begin_comment
comment|/* XXX - move to kern_proc.c?  */
end_comment

begin_function
specifier|static
name|void
name|filt_procdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|kn
operator|->
name|kn_ptr
operator|.
name|p_proc
expr_stmt|;
name|knlist_remove
argument_list|(
operator|&
name|p
operator|->
name|p_klist
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_ptr
operator|.
name|p_proc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX - move to kern_proc.c?  */
end_comment

begin_function
specifier|static
name|int
name|filt_proc
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|kn
operator|->
name|kn_ptr
operator|.
name|p_proc
decl_stmt|;
name|u_int
name|event
decl_stmt|;
comment|/* 	 * mask off extra data 	 */
name|event
operator|=
operator|(
name|u_int
operator|)
name|hint
operator|&
name|NOTE_PCTRLMASK
expr_stmt|;
comment|/* 	 * if the user is interested in this event, record it. 	 */
if|if
condition|(
name|kn
operator|->
name|kn_sfflags
operator|&
name|event
condition|)
name|kn
operator|->
name|kn_fflags
operator||=
name|event
expr_stmt|;
comment|/* 	 * process is gone, so flag the event as finished. 	 */
if|if
condition|(
name|event
operator|==
name|NOTE_EXIT
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_DETACHED
operator|)
condition|)
name|knlist_remove_inevent
argument_list|(
operator|&
name|p
operator|->
name|p_klist
argument_list|,
name|kn
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_flags
operator||=
operator|(
name|EV_EOF
operator||
name|EV_ONESHOT
operator|)
expr_stmt|;
name|kn
operator|->
name|kn_data
operator|=
name|p
operator|->
name|p_xstat
expr_stmt|;
name|kn
operator|->
name|kn_ptr
operator|.
name|p_proc
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * process forked, and user wants to track the new process, 	 * so attach a new knote to it, and immediately report an 	 * event with the parent's pid. 	 */
if|if
condition|(
operator|(
name|event
operator|==
name|NOTE_FORK
operator|)
operator|&&
operator|(
name|kn
operator|->
name|kn_sfflags
operator|&
name|NOTE_TRACK
operator|)
condition|)
block|{
name|struct
name|kevent
name|kev
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 		 * register knote with new process. 		 */
name|kev
operator|.
name|ident
operator|=
name|hint
operator|&
name|NOTE_PDATAMASK
expr_stmt|;
comment|/* pid */
name|kev
operator|.
name|filter
operator|=
name|kn
operator|->
name|kn_filter
expr_stmt|;
name|kev
operator|.
name|flags
operator|=
name|kn
operator|->
name|kn_flags
operator||
name|EV_ADD
operator||
name|EV_ENABLE
operator||
name|EV_FLAG1
expr_stmt|;
name|kev
operator|.
name|fflags
operator|=
name|kn
operator|->
name|kn_sfflags
expr_stmt|;
name|kev
operator|.
name|data
operator|=
name|kn
operator|->
name|kn_id
expr_stmt|;
comment|/* parent */
name|kev
operator|.
name|udata
operator|=
name|kn
operator|->
name|kn_kevent
operator|.
name|udata
expr_stmt|;
comment|/* preserve udata */
name|error
operator|=
name|kqueue_register
argument_list|(
name|kn
operator|->
name|kn_kq
argument_list|,
operator|&
name|kev
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|kn
operator|->
name|kn_fflags
operator||=
name|NOTE_TRACKERR
expr_stmt|;
block|}
return|return
operator|(
name|kn
operator|->
name|kn_fflags
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|timertoticks
parameter_list|(
name|intptr_t
name|data
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|tticks
decl_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|data
operator|/
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
name|data
operator|%
literal|1000
operator|)
operator|*
literal|1000
expr_stmt|;
name|tticks
operator|=
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
return|return
name|tticks
return|;
block|}
end_function

begin_comment
comment|/* XXX - move to kern_timeout.c? */
end_comment

begin_function
specifier|static
name|void
name|filt_timerexpire
parameter_list|(
name|void
modifier|*
name|knx
parameter_list|)
block|{
name|struct
name|knote
modifier|*
name|kn
init|=
name|knx
decl_stmt|;
name|struct
name|callout
modifier|*
name|calloutp
decl_stmt|;
name|kn
operator|->
name|kn_data
operator|++
expr_stmt|;
name|KNOTE_ACTIVATE
argument_list|(
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX - handle locking */
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_flags
operator|&
name|EV_ONESHOT
operator|)
operator|!=
name|EV_ONESHOT
condition|)
block|{
name|calloutp
operator|=
operator|(
expr|struct
name|callout
operator|*
operator|)
name|kn
operator|->
name|kn_hook
expr_stmt|;
name|callout_reset
argument_list|(
name|calloutp
argument_list|,
name|timertoticks
argument_list|(
name|kn
operator|->
name|kn_sdata
argument_list|)
argument_list|,
name|filt_timerexpire
argument_list|,
name|kn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * data contains amount of time to sleep, in milliseconds  */
end_comment

begin_comment
comment|/* XXX - move to kern_timeout.c? */
end_comment

begin_function
specifier|static
name|int
name|filt_timerattach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|callout
modifier|*
name|calloutp
decl_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|kq_ncallouts
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|kq_ncallouts
operator|>=
name|kq_calloutmax
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|kq_ncallouts
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|kn
operator|->
name|kn_flags
operator||=
name|EV_CLEAR
expr_stmt|;
comment|/* automatically set */
name|kn
operator|->
name|kn_status
operator|&=
operator|~
name|KN_DETACHED
expr_stmt|;
comment|/* knlist_add usually sets it */
name|MALLOC
argument_list|(
name|calloutp
argument_list|,
expr|struct
name|callout
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|calloutp
argument_list|)
argument_list|,
name|M_KQUEUE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
name|calloutp
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_hook
operator|=
name|calloutp
expr_stmt|;
name|callout_reset
argument_list|(
name|calloutp
argument_list|,
name|timertoticks
argument_list|(
name|kn
operator|->
name|kn_sdata
argument_list|)
argument_list|,
name|filt_timerexpire
argument_list|,
name|kn
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* XXX - move to kern_timeout.c? */
end_comment

begin_function
specifier|static
name|void
name|filt_timerdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|callout
modifier|*
name|calloutp
decl_stmt|;
name|calloutp
operator|=
operator|(
expr|struct
name|callout
operator|*
operator|)
name|kn
operator|->
name|kn_hook
expr_stmt|;
name|callout_drain
argument_list|(
name|calloutp
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|calloutp
argument_list|,
name|M_KQUEUE
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|kq_ncallouts
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator||=
name|KN_DETACHED
expr_stmt|;
comment|/* knlist_remove usually clears it */
block|}
end_function

begin_comment
comment|/* XXX - move to kern_timeout.c? */
end_comment

begin_function
specifier|static
name|int
name|filt_timer
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
return|return
operator|(
name|kn
operator|->
name|kn_data
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kqueue
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kqueue_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|error
decl_stmt|;
name|fdp
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_fd
expr_stmt|;
name|error
operator|=
name|falloc
argument_list|(
name|td
argument_list|,
operator|&
name|fp
argument_list|,
operator|&
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done2
goto|;
comment|/* An extra reference on `nfp' has been held for us by falloc(). */
name|kq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|kq
argument_list|,
name|M_KQUEUE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
literal|"kqueue"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_DUPOK
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_fdp
operator|=
name|fdp
expr_stmt|;
name|knlist_init
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
operator|.
name|si_note
argument_list|,
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|kq
operator|->
name|kq_task
argument_list|,
literal|0
argument_list|,
name|kqueue_task
argument_list|,
name|kq
argument_list|)
expr_stmt|;
name|FILEDESC_LOCK_FAST
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|fdp
operator|->
name|fd_kqlist
argument_list|,
name|kq
argument_list|,
name|kq_list
argument_list|)
expr_stmt|;
name|FILEDESC_UNLOCK_FAST
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
name|FILE_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_flag
operator|=
name|FREAD
operator||
name|FWRITE
expr_stmt|;
name|fp
operator|->
name|f_type
operator|=
name|DTYPE_KQUEUE
expr_stmt|;
name|fp
operator|->
name|f_ops
operator|=
operator|&
name|kqueueops
expr_stmt|;
name|fp
operator|->
name|f_data
operator|=
name|kq
expr_stmt|;
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|fd
expr_stmt|;
name|done2
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SYSPROTO_H_
end_ifndef

begin_struct
struct|struct
name|kevent_args
block|{
name|int
name|fd
decl_stmt|;
specifier|const
name|struct
name|kevent
modifier|*
name|changelist
decl_stmt|;
name|int
name|nchanges
decl_stmt|;
name|struct
name|kevent
modifier|*
name|eventlist
decl_stmt|;
name|int
name|nevents
decl_stmt|;
specifier|const
name|struct
name|timespec
modifier|*
name|timeout
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|kevent
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|kevent_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timespec
name|ts
decl_stmt|,
modifier|*
name|tsp
decl_stmt|;
name|struct
name|kevent_copyops
name|k_ops
init|=
block|{
name|uap
block|,
name|kevent_copyout
block|,
name|kevent_copyin
block|}
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
name|struct
name|uio
name|ktruio
decl_stmt|;
name|struct
name|iovec
name|ktriov
decl_stmt|;
name|struct
name|uio
modifier|*
name|ktruioin
init|=
name|NULL
decl_stmt|;
name|struct
name|uio
modifier|*
name|ktruioout
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|uap
operator|->
name|timeout
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|timeout
argument_list|,
operator|&
name|ts
argument_list|,
sizeof|sizeof
argument_list|(
name|ts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tsp
operator|=
operator|&
name|ts
expr_stmt|;
block|}
else|else
name|tsp
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|KTRPOINT
argument_list|(
name|td
argument_list|,
name|KTR_GENIO
argument_list|)
condition|)
block|{
name|ktriov
operator|.
name|iov_base
operator|=
name|uap
operator|->
name|changelist
expr_stmt|;
name|ktriov
operator|.
name|iov_len
operator|=
name|uap
operator|->
name|nchanges
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
expr_stmt|;
name|ktruio
operator|=
operator|(
expr|struct
name|uio
operator|)
block|{
operator|.
name|uio_iov
operator|=
operator|&
name|ktriov
block|,
operator|.
name|uio_iovcnt
operator|=
literal|1
block|,
operator|.
name|uio_segflg
operator|=
name|UIO_USERSPACE
block|,
operator|.
name|uio_rw
operator|=
name|UIO_READ
block|,
operator|.
name|uio_td
operator|=
name|td
block|}
expr_stmt|;
name|ktruioin
operator|=
name|cloneuio
argument_list|(
operator|&
name|ktruio
argument_list|)
expr_stmt|;
name|ktriov
operator|.
name|iov_base
operator|=
name|uap
operator|->
name|eventlist
expr_stmt|;
name|ktriov
operator|.
name|iov_len
operator|=
name|uap
operator|->
name|nevents
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
expr_stmt|;
name|ktruioout
operator|=
name|cloneuio
argument_list|(
operator|&
name|ktruio
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|error
operator|=
name|kern_kevent
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
name|uap
operator|->
name|nchanges
argument_list|,
name|uap
operator|->
name|nevents
argument_list|,
operator|&
name|k_ops
argument_list|,
name|tsp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KTRACE
if|if
condition|(
name|ktruioin
operator|!=
name|NULL
condition|)
block|{
name|ktruioin
operator|->
name|uio_resid
operator|=
name|uap
operator|->
name|nchanges
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
expr_stmt|;
name|ktrgenio
argument_list|(
name|uap
operator|->
name|fd
argument_list|,
name|UIO_WRITE
argument_list|,
name|ktruioin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ktruioout
operator|->
name|uio_resid
operator|=
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
expr_stmt|;
name|ktrgenio
argument_list|(
name|uap
operator|->
name|fd
argument_list|,
name|UIO_READ
argument_list|,
name|ktruioout
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy 'count' items into the destination list pointed to by uap->eventlist.  */
end_comment

begin_function
specifier|static
name|int
name|kevent_copyout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|kevent
modifier|*
name|kevp
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|kevent_args
modifier|*
name|uap
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|count
operator|<=
name|KQ_NEVENTS
argument_list|,
operator|(
literal|"count (%d)> KQ_NEVENTS"
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
name|uap
operator|=
operator|(
expr|struct
name|kevent_args
operator|*
operator|)
name|arg
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|kevp
argument_list|,
name|uap
operator|->
name|eventlist
argument_list|,
name|count
operator|*
sizeof|sizeof
expr|*
name|kevp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|uap
operator|->
name|eventlist
operator|+=
name|count
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy 'count' items from the list pointed to by uap->changelist.  */
end_comment

begin_function
specifier|static
name|int
name|kevent_copyin
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|kevent
modifier|*
name|kevp
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|kevent_args
modifier|*
name|uap
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|count
operator|<=
name|KQ_NEVENTS
argument_list|,
operator|(
literal|"count (%d)> KQ_NEVENTS"
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
name|uap
operator|=
operator|(
expr|struct
name|kevent_args
operator|*
operator|)
name|arg
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|changelist
argument_list|,
name|kevp
argument_list|,
name|count
operator|*
sizeof|sizeof
expr|*
name|kevp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|uap
operator|->
name|changelist
operator|+=
name|count
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kern_kevent
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|nchanges
parameter_list|,
name|int
name|nevents
parameter_list|,
name|struct
name|kevent_copyops
modifier|*
name|k_ops
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|)
block|{
name|struct
name|kevent
name|keva
index|[
name|KQ_NEVENTS
index|]
decl_stmt|;
name|struct
name|kevent
modifier|*
name|kevp
decl_stmt|,
modifier|*
name|changes
decl_stmt|;
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|nerrors
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fget
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
operator|&
name|fp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|kqueue_aquire
argument_list|(
name|fp
argument_list|,
operator|&
name|kq
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|done_norel
goto|;
name|nerrors
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nchanges
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|nchanges
operator|>
name|KQ_NEVENTS
condition|?
name|KQ_NEVENTS
else|:
name|nchanges
expr_stmt|;
name|error
operator|=
name|k_ops
operator|->
name|k_copyin
argument_list|(
name|k_ops
operator|->
name|arg
argument_list|,
name|keva
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
name|changes
operator|=
name|keva
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|kevp
operator|=
operator|&
name|changes
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|kevp
operator|->
name|filter
condition|)
continue|continue;
name|kevp
operator|->
name|flags
operator|&=
operator|~
name|EV_SYSFLAGS
expr_stmt|;
name|error
operator|=
name|kqueue_register
argument_list|(
name|kq
argument_list|,
name|kevp
argument_list|,
name|td
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|nevents
operator|!=
literal|0
condition|)
block|{
name|kevp
operator|->
name|flags
operator|=
name|EV_ERROR
expr_stmt|;
name|kevp
operator|->
name|data
operator|=
name|error
expr_stmt|;
operator|(
name|void
operator|)
name|k_ops
operator|->
name|k_copyout
argument_list|(
name|k_ops
operator|->
name|arg
argument_list|,
name|kevp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nevents
operator|--
expr_stmt|;
name|nerrors
operator|++
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|done
goto|;
block|}
block|}
block|}
name|nchanges
operator|-=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|nerrors
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|nerrors
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|error
operator|=
name|kqueue_scan
argument_list|(
name|kq
argument_list|,
name|nevents
argument_list|,
name|k_ops
argument_list|,
name|timeout
argument_list|,
name|keva
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|done
label|:
name|kqueue_release
argument_list|(
name|kq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|done_norel
label|:
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kqueue_add_filteropts
parameter_list|(
name|int
name|filt
parameter_list|,
name|struct
name|filterops
modifier|*
name|filtops
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|filt
operator|>
literal|0
operator|||
name|filt
operator|+
name|EVFILT_SYSCOUNT
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"trying to add a filterop that is out of range: %d is beyond %d\n"
argument_list|,
operator|~
name|filt
argument_list|,
name|EVFILT_SYSCOUNT
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|filterops_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_fop
operator|!=
operator|&
name|null_filtops
operator|&&
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_fop
operator|!=
name|NULL
condition|)
name|error
operator|=
name|EEXIST
expr_stmt|;
else|else
block|{
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_fop
operator|=
name|filtops
expr_stmt|;
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_refcnt
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|filterops_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|kqueue_del_filteropts
parameter_list|(
name|int
name|filt
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|filt
operator|>
literal|0
operator|||
name|filt
operator|+
name|EVFILT_SYSCOUNT
operator|<
literal|0
condition|)
return|return
name|EINVAL
return|;
name|mtx_lock
argument_list|(
operator|&
name|filterops_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_fop
operator|==
operator|&
name|null_filtops
operator|||
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_fop
operator|==
name|NULL
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
elseif|else
if|if
condition|(
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_refcnt
operator|!=
literal|0
condition|)
name|error
operator|=
name|EBUSY
expr_stmt|;
else|else
block|{
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_fop
operator|=
operator|&
name|null_filtops
expr_stmt|;
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_refcnt
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|filterops_lock
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|filterops
modifier|*
name|kqueue_fo_find
parameter_list|(
name|int
name|filt
parameter_list|)
block|{
if|if
condition|(
name|filt
operator|>
literal|0
operator|||
name|filt
operator|+
name|EVFILT_SYSCOUNT
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|mtx_lock
argument_list|(
operator|&
name|filterops_lock
argument_list|)
expr_stmt|;
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_refcnt
operator|++
expr_stmt|;
if|if
condition|(
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_fop
operator|==
name|NULL
condition|)
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_fop
operator|=
operator|&
name|null_filtops
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|filterops_lock
argument_list|)
expr_stmt|;
return|return
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_fop
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kqueue_fo_release
parameter_list|(
name|int
name|filt
parameter_list|)
block|{
if|if
condition|(
name|filt
operator|>
literal|0
operator|||
name|filt
operator|+
name|EVFILT_SYSCOUNT
operator|<
literal|0
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|filterops_lock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_refcnt
operator|>
literal|0
argument_list|,
operator|(
literal|"filter object refcount not valid on release"
operator|)
argument_list|)
expr_stmt|;
name|sysfilt_ops
index|[
operator|~
name|filt
index|]
operator|.
name|for_refcnt
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|filterops_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A ref to kq (obtained via kqueue_aquire) must be held.  waitok will  * influence if memory allocation should wait.  Make sure it is 0 if you  * hold any mutexes.  */
end_comment

begin_function
specifier|static
name|int
name|kqueue_register
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|,
name|struct
name|kevent
modifier|*
name|kev
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|waitok
parameter_list|)
block|{
name|struct
name|filterops
modifier|*
name|fops
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|knote
modifier|*
name|kn
decl_stmt|,
modifier|*
name|tkn
decl_stmt|;
name|int
name|error
decl_stmt|,
name|filt
decl_stmt|,
name|event
decl_stmt|;
name|int
name|haskqglobal
decl_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
name|kn
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|haskqglobal
operator|=
literal|0
expr_stmt|;
name|filt
operator|=
name|kev
operator|->
name|filter
expr_stmt|;
name|fops
operator|=
name|kqueue_fo_find
argument_list|(
name|filt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fops
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
name|tkn
operator|=
name|knote_alloc
argument_list|(
name|waitok
argument_list|)
expr_stmt|;
comment|/* prevent waiting with locks */
name|findkn
label|:
if|if
condition|(
name|fops
operator|->
name|f_isfd
condition|)
block|{
name|KASSERT
argument_list|(
name|td
operator|!=
name|NULL
argument_list|,
operator|(
literal|"td is NULL"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|fget
argument_list|(
name|td
argument_list|,
name|kev
operator|->
name|ident
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|(
name|kev
operator|->
name|flags
operator|&
name|EV_ADD
operator|)
operator|==
name|EV_ADD
operator|&&
name|kqueue_expand
argument_list|(
name|kq
argument_list|,
name|fops
argument_list|,
name|kev
operator|->
name|ident
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* try again */
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|kqueue_expand
argument_list|(
name|kq
argument_list|,
name|fops
argument_list|,
name|kev
operator|->
name|ident
argument_list|,
name|waitok
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|done
goto|;
goto|goto
name|findkn
goto|;
block|}
if|if
condition|(
name|fp
operator|->
name|f_type
operator|==
name|DTYPE_KQUEUE
condition|)
block|{
comment|/* 			 * if we add some inteligence about what we are doing, 			 * we should be able to support events on ourselves. 			 * We need to know when we are doing this to prevent 			 * getting both the knlist lock and the kq lock since 			 * they are the same thing. 			 */
if|if
condition|(
name|fp
operator|->
name|f_data
operator|==
name|kq
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|KQ_GLOBAL_LOCK
argument_list|(
operator|&
name|kq_global
argument_list|,
name|haskqglobal
argument_list|)
expr_stmt|;
block|}
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|kev
operator|->
name|ident
operator|<
name|kq
operator|->
name|kq_knlistsize
condition|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|kn
argument_list|,
argument|&kq->kq_knlist[kev->ident]
argument_list|,
argument|kn_link
argument_list|)
if|if
condition|(
name|kev
operator|->
name|filter
operator|==
name|kn
operator|->
name|kn_filter
condition|)
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|kev
operator|->
name|flags
operator|&
name|EV_ADD
operator|)
operator|==
name|EV_ADD
condition|)
name|kqueue_expand
argument_list|(
name|kq
argument_list|,
name|fops
argument_list|,
name|kev
operator|->
name|ident
argument_list|,
name|waitok
argument_list|)
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|kq
operator|->
name|kq_knhashmask
operator|!=
literal|0
condition|)
block|{
name|struct
name|klist
modifier|*
name|list
decl_stmt|;
name|list
operator|=
operator|&
name|kq
operator|->
name|kq_knhash
index|[
name|KN_HASH
argument_list|(
operator|(
name|u_long
operator|)
name|kev
operator|->
name|ident
argument_list|,
name|kq
operator|->
name|kq_knhashmask
argument_list|)
index|]
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|kn
argument_list|,
argument|list
argument_list|,
argument|kn_link
argument_list|)
if|if
condition|(
name|kev
operator|->
name|ident
operator|==
name|kn
operator|->
name|kn_id
operator|&&
name|kev
operator|->
name|filter
operator|==
name|kn
operator|->
name|kn_filter
condition|)
break|break;
block|}
block|}
comment|/* knote is in the process of changing, wait for it to stablize. */
if|if
condition|(
name|kn
operator|!=
name|NULL
operator|&&
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_INFLUX
operator|)
operator|==
name|KN_INFLUX
condition|)
block|{
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
name|KQ_GLOBAL_UNLOCK
argument_list|(
operator|&
name|kq_global
argument_list|,
name|haskqglobal
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_state
operator||=
name|KQ_FLUXWAIT
expr_stmt|;
name|msleep
argument_list|(
name|kq
argument_list|,
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|PSOCK
operator||
name|PDROP
argument_list|,
literal|"kqflxwt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|findkn
goto|;
block|}
if|if
condition|(
name|kn
operator|==
name|NULL
operator|&&
operator|(
operator|(
name|kev
operator|->
name|flags
operator|&
name|EV_ADD
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * kn now contains the matching knote, or NULL if no match 	 */
if|if
condition|(
name|kev
operator|->
name|flags
operator|&
name|EV_ADD
condition|)
block|{
if|if
condition|(
name|kn
operator|==
name|NULL
condition|)
block|{
name|kn
operator|=
name|tkn
expr_stmt|;
name|tkn
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|kn
operator|==
name|NULL
condition|)
block|{
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|kn
operator|->
name|kn_fp
operator|=
name|fp
expr_stmt|;
name|kn
operator|->
name|kn_kq
operator|=
name|kq
expr_stmt|;
name|kn
operator|->
name|kn_fop
operator|=
name|fops
expr_stmt|;
comment|/* 			 * apply reference counts to knote structure, and 			 * do not release it at the end of this routine. 			 */
name|fops
operator|=
name|NULL
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
name|kn
operator|->
name|kn_sfflags
operator|=
name|kev
operator|->
name|fflags
expr_stmt|;
name|kn
operator|->
name|kn_sdata
operator|=
name|kev
operator|->
name|data
expr_stmt|;
name|kev
operator|->
name|fflags
operator|=
literal|0
expr_stmt|;
name|kev
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|kn
operator|->
name|kn_kevent
operator|=
operator|*
name|kev
expr_stmt|;
name|kn
operator|->
name|kn_kevent
operator|.
name|flags
operator|&=
operator|~
operator|(
name|EV_ADD
operator||
name|EV_DELETE
operator||
name|EV_ENABLE
operator||
name|EV_DISABLE
operator|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator|=
name|KN_INFLUX
operator||
name|KN_DETACHED
expr_stmt|;
name|error
operator|=
name|knote_attach
argument_list|(
name|kn
argument_list|,
name|kq
argument_list|)
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|tkn
operator|=
name|kn
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|kn
operator|->
name|kn_fop
operator|->
name|f_attach
argument_list|(
name|kn
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|knote_drop
argument_list|(
name|kn
argument_list|,
name|td
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|KN_LIST_LOCK
argument_list|(
name|kn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * The user may change some filter values after the 			 * initial EV_ADD, but doing so will not reset any 			 * filter which has already been triggered. 			 */
name|kn
operator|->
name|kn_status
operator||=
name|KN_INFLUX
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|KN_LIST_LOCK
argument_list|(
name|kn
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_sfflags
operator|=
name|kev
operator|->
name|fflags
expr_stmt|;
name|kn
operator|->
name|kn_sdata
operator|=
name|kev
operator|->
name|data
expr_stmt|;
name|kn
operator|->
name|kn_kevent
operator|.
name|udata
operator|=
name|kev
operator|->
name|udata
expr_stmt|;
block|}
comment|/* 		 * We can get here with kn->kn_knlist == NULL. 		 * This can happen when the initial attach event decides that 		 * the event is "completed" already.  i.e. filt_procattach 		 * is called on a zombie process.  It will call filt_proc 		 * which will remove it from the list, and NULL kn_knlist. 		 */
name|event
operator|=
name|kn
operator|->
name|kn_fop
operator|->
name|f_event
argument_list|(
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
condition|)
name|KNOTE_ACTIVATE
argument_list|(
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator|&=
operator|~
name|KN_INFLUX
expr_stmt|;
name|KN_LIST_UNLOCK
argument_list|(
name|kn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kev
operator|->
name|flags
operator|&
name|EV_DELETE
condition|)
block|{
name|kn
operator|->
name|kn_status
operator||=
name|KN_INFLUX
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_DETACHED
operator|)
condition|)
name|kn
operator|->
name|kn_fop
operator|->
name|f_detach
argument_list|(
name|kn
argument_list|)
expr_stmt|;
name|knote_drop
argument_list|(
name|kn
argument_list|,
name|td
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|kev
operator|->
name|flags
operator|&
name|EV_DISABLE
operator|)
operator|&&
operator|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_DISABLED
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|kn
operator|->
name|kn_status
operator||=
name|KN_DISABLED
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|kev
operator|->
name|flags
operator|&
name|EV_ENABLE
operator|)
operator|&&
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_DISABLED
operator|)
condition|)
block|{
name|kn
operator|->
name|kn_status
operator|&=
operator|~
name|KN_DISABLED
expr_stmt|;
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_ACTIVE
operator|)
operator|&&
operator|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_QUEUED
operator|)
operator|==
literal|0
operator|)
condition|)
name|knote_enqueue
argument_list|(
name|kn
argument_list|)
expr_stmt|;
block|}
name|KQ_UNLOCK_FLUX
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|done
label|:
name|KQ_GLOBAL_UNLOCK
argument_list|(
operator|&
name|kq_global
argument_list|,
name|haskqglobal
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|tkn
operator|!=
name|NULL
condition|)
name|knote_free
argument_list|(
name|tkn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fops
operator|!=
name|NULL
condition|)
name|kqueue_fo_release
argument_list|(
name|filt
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|kqueue_aquire
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|kqueue
modifier|*
modifier|*
name|kqp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|FILE_LOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
do|do
block|{
name|kq
operator|=
name|fp
operator|->
name|f_data
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_type
operator|!=
name|DTYPE_KQUEUE
operator|||
name|kq
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBADF
expr_stmt|;
break|break;
block|}
operator|*
name|kqp
operator|=
name|kq
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kq
operator|->
name|kq_state
operator|&
name|KQ_CLOSING
operator|)
operator|==
name|KQ_CLOSING
condition|)
block|{
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBADF
expr_stmt|;
break|break;
block|}
name|kq
operator|->
name|kq_refcnt
operator|++
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|FILE_UNLOCK
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kqueue_release
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|,
name|int
name|locked
parameter_list|)
block|{
if|if
condition|(
name|locked
condition|)
name|KQ_OWNED
argument_list|(
name|kq
argument_list|)
expr_stmt|;
else|else
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_refcnt
operator|--
expr_stmt|;
if|if
condition|(
name|kq
operator|->
name|kq_refcnt
operator|==
literal|1
condition|)
name|wakeup
argument_list|(
operator|&
name|kq
operator|->
name|kq_refcnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kqueue_schedtask
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|)
block|{
name|KQ_OWNED
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
operator|(
name|kq
operator|->
name|kq_state
operator|&
name|KQ_TASKDRAIN
operator|)
operator|!=
name|KQ_TASKDRAIN
operator|)
argument_list|,
operator|(
literal|"scheduling kqueue task while draining"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kq
operator|->
name|kq_state
operator|&
name|KQ_TASKSCHED
operator|)
operator|!=
name|KQ_TASKSCHED
condition|)
block|{
name|taskqueue_enqueue
argument_list|(
name|taskqueue_kqueue
argument_list|,
operator|&
name|kq
operator|->
name|kq_task
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_state
operator||=
name|KQ_TASKSCHED
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Expand the kq to make sure we have storage for fops/ident pair.  *  * Return 0 on success (or no work necessary), return errno on failure.  *  * Not calling hashinit w/ waitok (proper malloc flag) should be safe.  * If kqueue_register is called from a non-fd context, there usually/should  * be no locks held.  */
end_comment

begin_function
specifier|static
name|int
name|kqueue_expand
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|,
name|struct
name|filterops
modifier|*
name|fops
parameter_list|,
name|uintptr_t
name|ident
parameter_list|,
name|int
name|waitok
parameter_list|)
block|{
name|struct
name|klist
modifier|*
name|list
decl_stmt|,
modifier|*
name|tmp_knhash
decl_stmt|;
name|u_long
name|tmp_knhashmask
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|mflag
init|=
name|waitok
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
decl_stmt|;
name|KQ_NOTOWNED
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|fops
operator|->
name|f_isfd
condition|)
block|{
name|fd
operator|=
name|ident
expr_stmt|;
if|if
condition|(
name|kq
operator|->
name|kq_knlistsize
operator|<=
name|fd
condition|)
block|{
name|size
operator|=
name|kq
operator|->
name|kq_knlistsize
expr_stmt|;
while|while
condition|(
name|size
operator|<=
name|fd
condition|)
name|size
operator|+=
name|KQEXTENT
expr_stmt|;
name|MALLOC
argument_list|(
name|list
argument_list|,
expr|struct
name|klist
operator|*
argument_list|,
name|size
operator|*
sizeof|sizeof
name|list
argument_list|,
name|M_KQUEUE
argument_list|,
name|mflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|kq
operator|->
name|kq_knlistsize
operator|>
name|fd
condition|)
block|{
name|FREE
argument_list|(
name|list
argument_list|,
name|M_KQUEUE
argument_list|)
expr_stmt|;
name|list
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|kq
operator|->
name|kq_knlist
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|kq
operator|->
name|kq_knlist
argument_list|,
name|list
argument_list|,
name|kq
operator|->
name|kq_knlistsize
operator|*
sizeof|sizeof
name|list
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|kq
operator|->
name|kq_knlist
argument_list|,
name|M_KQUEUE
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_knlist
operator|=
name|NULL
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|list
operator|+
name|kq
operator|->
name|kq_knlistsize
operator|*
sizeof|sizeof
name|list
argument_list|,
operator|(
name|size
operator|-
name|kq
operator|->
name|kq_knlistsize
operator|)
operator|*
sizeof|sizeof
name|list
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_knlistsize
operator|=
name|size
expr_stmt|;
name|kq
operator|->
name|kq_knlist
operator|=
name|list
expr_stmt|;
block|}
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|kq
operator|->
name|kq_knhashmask
operator|==
literal|0
condition|)
block|{
name|tmp_knhash
operator|=
name|hashinit
argument_list|(
name|KN_HASHSIZE
argument_list|,
name|M_KQUEUE
argument_list|,
operator|&
name|tmp_knhashmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_knhash
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|kq
operator|->
name|kq_knhashmask
operator|==
literal|0
condition|)
block|{
name|kq
operator|->
name|kq_knhash
operator|=
name|tmp_knhash
expr_stmt|;
name|kq
operator|->
name|kq_knhashmask
operator|=
name|tmp_knhashmask
expr_stmt|;
block|}
else|else
block|{
name|free
argument_list|(
name|tmp_knhash
argument_list|,
name|M_KQUEUE
argument_list|)
expr_stmt|;
block|}
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
block|}
name|KQ_NOTOWNED
argument_list|(
name|kq
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kqueue_task
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|int
name|haskqglobal
decl_stmt|;
name|haskqglobal
operator|=
literal|0
expr_stmt|;
name|kq
operator|=
name|arg
expr_stmt|;
name|KQ_GLOBAL_LOCK
argument_list|(
operator|&
name|kq_global
argument_list|,
name|haskqglobal
argument_list|)
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|KNOTE_LOCKED
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
operator|.
name|si_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_state
operator|&=
operator|~
name|KQ_TASKSCHED
expr_stmt|;
if|if
condition|(
operator|(
name|kq
operator|->
name|kq_state
operator|&
name|KQ_TASKDRAIN
operator|)
operator|==
name|KQ_TASKDRAIN
condition|)
block|{
name|wakeup
argument_list|(
operator|&
name|kq
operator|->
name|kq_state
argument_list|)
expr_stmt|;
block|}
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|KQ_GLOBAL_UNLOCK
argument_list|(
operator|&
name|kq_global
argument_list|,
name|haskqglobal
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Scan, update kn_data (if not ONESHOT), and copyout triggered events.  * We treat KN_MARKER knotes as if they are INFLUX.  */
end_comment

begin_function
specifier|static
name|int
name|kqueue_scan
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|,
name|int
name|maxevents
parameter_list|,
name|struct
name|kevent_copyops
modifier|*
name|k_ops
parameter_list|,
specifier|const
name|struct
name|timespec
modifier|*
name|tsp
parameter_list|,
name|struct
name|kevent
modifier|*
name|keva
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kevent
modifier|*
name|kevp
decl_stmt|;
name|struct
name|timeval
name|atv
decl_stmt|,
name|rtv
decl_stmt|,
name|ttv
decl_stmt|;
name|struct
name|knote
modifier|*
name|kn
decl_stmt|,
modifier|*
name|marker
decl_stmt|;
name|int
name|count
decl_stmt|,
name|timeout
decl_stmt|,
name|nkev
decl_stmt|,
name|error
decl_stmt|;
name|int
name|haskqglobal
decl_stmt|;
name|count
operator|=
name|maxevents
expr_stmt|;
name|nkev
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|haskqglobal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|maxevents
operator|==
literal|0
condition|)
goto|goto
name|done_nl
goto|;
if|if
condition|(
name|tsp
operator|!=
name|NULL
condition|)
block|{
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|atv
argument_list|,
name|tsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|itimerfix
argument_list|(
operator|&
name|atv
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|done_nl
goto|;
block|}
if|if
condition|(
name|tsp
operator|->
name|tv_sec
operator|==
literal|0
operator|&&
name|tsp
operator|->
name|tv_nsec
operator|==
literal|0
condition|)
name|timeout
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|timeout
operator|=
name|atv
operator|.
name|tv_sec
operator|>
literal|24
operator|*
literal|60
operator|*
literal|60
condition|?
literal|24
operator|*
literal|60
operator|*
literal|60
operator|*
name|hz
else|:
name|tvtohz
argument_list|(
operator|&
name|atv
argument_list|)
expr_stmt|;
name|getmicrouptime
argument_list|(
operator|&
name|rtv
argument_list|)
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|atv
argument_list|,
operator|&
name|rtv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|atv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|atv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|timeout
operator|=
literal|0
expr_stmt|;
block|}
name|marker
operator|=
name|knote_alloc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|marker
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|done_nl
goto|;
block|}
name|marker
operator|->
name|kn_status
operator|=
name|KN_MARKER
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
goto|goto
name|start
goto|;
name|retry
label|:
if|if
condition|(
name|atv
operator|.
name|tv_sec
operator|||
name|atv
operator|.
name|tv_usec
condition|)
block|{
name|getmicrouptime
argument_list|(
operator|&
name|rtv
argument_list|)
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|rtv
argument_list|,
operator|&
name|atv
argument_list|,
operator|>=
argument_list|)
condition|)
goto|goto
name|done
goto|;
name|ttv
operator|=
name|atv
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|ttv
argument_list|,
operator|&
name|rtv
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|ttv
operator|.
name|tv_sec
operator|>
literal|24
operator|*
literal|60
operator|*
literal|60
condition|?
literal|24
operator|*
literal|60
operator|*
literal|60
operator|*
name|hz
else|:
name|tvtohz
argument_list|(
operator|&
name|ttv
argument_list|)
expr_stmt|;
block|}
name|start
label|:
name|kevp
operator|=
name|keva
expr_stmt|;
if|if
condition|(
name|kq
operator|->
name|kq_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|timeout
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
block|}
else|else
block|{
name|kq
operator|->
name|kq_state
operator||=
name|KQ_SLEEP
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
name|kq
argument_list|,
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|PSOCK
operator||
name|PCATCH
argument_list|,
literal|"kqread"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
goto|goto
name|retry
goto|;
comment|/* don't restart after signals... */
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|,
name|marker
argument_list|,
name|kn_tqe
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|KQ_OWNED
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|kn
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_status
operator|==
name|KN_MARKER
operator|&&
name|kn
operator|!=
name|marker
operator|)
operator|||
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_INFLUX
operator|)
operator|==
name|KN_INFLUX
condition|)
block|{
name|kq
operator|->
name|kq_state
operator||=
name|KQ_FLUXWAIT
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
name|kq
argument_list|,
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|PSOCK
argument_list|,
literal|"kqflxwt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|,
name|kn
argument_list|,
name|kn_tqe
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_DISABLED
operator|)
operator|==
name|KN_DISABLED
condition|)
block|{
name|kn
operator|->
name|kn_status
operator|&=
operator|~
name|KN_QUEUED
expr_stmt|;
name|kq
operator|->
name|kq_count
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|kn
operator|==
name|marker
condition|)
block|{
name|KQ_FLUX_WAKEUP
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|==
name|maxevents
condition|)
goto|goto
name|retry
goto|;
goto|goto
name|done
goto|;
block|}
name|KASSERT
argument_list|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_INFLUX
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"KN_INFLUX set when not suppose to be"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_flags
operator|&
name|EV_ONESHOT
operator|)
operator|==
name|EV_ONESHOT
condition|)
block|{
name|kn
operator|->
name|kn_status
operator|&=
operator|~
name|KN_QUEUED
expr_stmt|;
name|kn
operator|->
name|kn_status
operator||=
name|KN_INFLUX
expr_stmt|;
name|kq
operator|->
name|kq_count
operator|--
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
comment|/* 			 * We don't need to lock the list since we've marked 			 * it _INFLUX. 			 */
operator|*
name|kevp
operator|=
name|kn
operator|->
name|kn_kevent
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_DETACHED
operator|)
condition|)
name|kn
operator|->
name|kn_fop
operator|->
name|f_detach
argument_list|(
name|kn
argument_list|)
expr_stmt|;
name|knote_drop
argument_list|(
name|kn
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|kn
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|kn
operator|->
name|kn_status
operator||=
name|KN_INFLUX
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_KQUEUE
operator|)
operator|==
name|KN_KQUEUE
condition|)
name|KQ_GLOBAL_LOCK
argument_list|(
operator|&
name|kq_global
argument_list|,
name|haskqglobal
argument_list|)
expr_stmt|;
name|KN_LIST_LOCK
argument_list|(
name|kn
argument_list|)
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_fop
operator|->
name|f_event
argument_list|(
name|kn
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|KQ_GLOBAL_UNLOCK
argument_list|(
operator|&
name|kq_global
argument_list|,
name|haskqglobal
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator|&=
operator|~
operator|(
name|KN_QUEUED
operator||
name|KN_ACTIVE
operator||
name|KN_INFLUX
operator|)
expr_stmt|;
name|kq
operator|->
name|kq_count
operator|--
expr_stmt|;
name|KN_LIST_UNLOCK
argument_list|(
name|kn
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|kevp
operator|=
name|kn
operator|->
name|kn_kevent
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|KQ_GLOBAL_UNLOCK
argument_list|(
operator|&
name|kq_global
argument_list|,
name|haskqglobal
argument_list|)
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_flags
operator|&
name|EV_CLEAR
condition|)
block|{
name|kn
operator|->
name|kn_data
operator|=
literal|0
expr_stmt|;
name|kn
operator|->
name|kn_fflags
operator|=
literal|0
expr_stmt|;
name|kn
operator|->
name|kn_status
operator|&=
operator|~
operator|(
name|KN_QUEUED
operator||
name|KN_ACTIVE
operator|)
expr_stmt|;
name|kq
operator|->
name|kq_count
operator|--
expr_stmt|;
block|}
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|,
name|kn
argument_list|,
name|kn_tqe
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator|&=
operator|~
operator|(
name|KN_INFLUX
operator|)
expr_stmt|;
name|KN_LIST_UNLOCK
argument_list|(
name|kn
argument_list|)
expr_stmt|;
block|}
comment|/* we are returning a copy to the user */
name|kevp
operator|++
expr_stmt|;
name|nkev
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|nkev
operator|==
name|KQ_NEVENTS
condition|)
block|{
name|KQ_UNLOCK_FLUX
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|error
operator|=
name|k_ops
operator|->
name|k_copyout
argument_list|(
name|k_ops
operator|->
name|arg
argument_list|,
name|keva
argument_list|,
name|nkev
argument_list|)
expr_stmt|;
name|nkev
operator|=
literal|0
expr_stmt|;
name|kevp
operator|=
name|keva
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|,
name|marker
argument_list|,
name|kn_tqe
argument_list|)
expr_stmt|;
name|done
label|:
name|KQ_OWNED
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|KQ_UNLOCK_FLUX
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|knote_free
argument_list|(
name|marker
argument_list|)
expr_stmt|;
name|done_nl
label|:
name|KQ_NOTOWNED
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|nkev
operator|!=
literal|0
condition|)
name|error
operator|=
name|k_ops
operator|->
name|k_copyout
argument_list|(
name|k_ops
operator|->
name|arg
argument_list|,
name|keva
argument_list|,
name|nkev
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|maxevents
operator|-
name|count
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX  * This could be expanded to call kqueue_scan, if desired.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|kqueue_read
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|kqueue_write
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|kqueue_ioctl
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
comment|/* 	 * Enabling sigio causes two major problems: 	 * 1) infinite recursion: 	 * Synopsys: kevent is being used to track signals and have FIOASYNC 	 * set.  On receipt of a signal this will cause a kqueue to recurse 	 * into itself over and over.  Sending the sigio causes the kqueue 	 * to become ready, which in turn posts sigio again, forever. 	 * Solution: this can be solved by setting a flag in the kqueue that 	 * we have a SIGIO in progress. 	 * 2) locking problems: 	 * Synopsys: Kqueue is a leaf subsystem, but adding signalling puts 	 * us above the proc and pgrp locks. 	 * Solution: Post a signal using an async mechanism, being sure to 	 * record a generation count in the delivery so that we do not deliver 	 * a signal to the wrong process. 	 * 	 * Note, these two mechanisms are somewhat mutually exclusive! 	 */
if|#
directive|if
literal|0
block|struct kqueue *kq;  	kq = fp->f_data; 	switch (cmd) { 	case FIOASYNC: 		if (*(int *)data) { 			kq->kq_state |= KQ_ASYNC; 		} else { 			kq->kq_state&= ~KQ_ASYNC; 		} 		return (0);  	case FIOSETOWN: 		return (fsetown(*(int *)data,&kq->kq_sigio));  	case FIOGETOWN: 		*(int *)data = fgetown(&kq->kq_sigio); 		return (0); 	}
endif|#
directive|endif
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|kqueue_poll
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|kqueue_aquire
argument_list|(
name|fp
argument_list|,
operator|&
name|kq
argument_list|)
operator|)
condition|)
return|return
name|POLLERR
return|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
if|if
condition|(
name|kq
operator|->
name|kq_count
condition|)
block|{
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
block|}
else|else
block|{
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|kq
operator|->
name|kq_sel
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_state
operator||=
name|KQ_SEL
expr_stmt|;
block|}
block|}
name|kqueue_release
argument_list|(
name|kq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|kqueue_stat
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|stat
modifier|*
name|st
parameter_list|,
name|struct
name|ucred
modifier|*
name|active_cred
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|st
argument_list|,
sizeof|sizeof
expr|*
name|st
argument_list|)
expr_stmt|;
comment|/* 	 * We no longer return kq_count because the unlocked value is useless. 	 * If you spent all this time getting the count, why not spend your 	 * syscall better by calling kevent? 	 * 	 * XXX - This is needed for libc_r. 	 */
name|st
operator|->
name|st_mode
operator|=
name|S_IFIFO
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|kqueue_close
parameter_list|(
name|struct
name|file
modifier|*
name|fp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
init|=
name|fp
operator|->
name|f_data
decl_stmt|;
name|struct
name|filedesc
modifier|*
name|fdp
decl_stmt|;
name|struct
name|knote
modifier|*
name|kn
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|kqueue_aquire
argument_list|(
name|fp
argument_list|,
operator|&
name|kq
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|kq
operator|->
name|kq_state
operator|&
name|KQ_CLOSING
operator|)
operator|!=
name|KQ_CLOSING
argument_list|,
operator|(
literal|"kqueue already closing"
operator|)
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_state
operator||=
name|KQ_CLOSING
expr_stmt|;
if|if
condition|(
name|kq
operator|->
name|kq_refcnt
operator|>
literal|1
condition|)
name|msleep
argument_list|(
operator|&
name|kq
operator|->
name|kq_refcnt
argument_list|,
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|PSOCK
argument_list|,
literal|"kqclose"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|kq
operator|->
name|kq_refcnt
operator|==
literal|1
argument_list|,
operator|(
literal|"other refs are out there!"
operator|)
argument_list|)
expr_stmt|;
name|fdp
operator|=
name|kq
operator|->
name|kq_fdp
expr_stmt|;
name|KASSERT
argument_list|(
name|knlist_empty
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
operator|.
name|si_note
argument_list|)
argument_list|,
operator|(
literal|"kqueue's knlist not empty"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|kq
operator|->
name|kq_knlistsize
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|kn
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|kq
operator|->
name|kq_knlist
index|[
name|i
index|]
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_INFLUX
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"KN_INFLUX set when not suppose to be"
operator|)
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator||=
name|KN_INFLUX
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_DETACHED
operator|)
condition|)
name|kn
operator|->
name|kn_fop
operator|->
name|f_detach
argument_list|(
name|kn
argument_list|)
expr_stmt|;
name|knote_drop
argument_list|(
name|kn
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|kq
operator|->
name|kq_knhashmask
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|kq
operator|->
name|kq_knhashmask
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|(
name|kn
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|kq
operator|->
name|kq_knhash
index|[
name|i
index|]
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_INFLUX
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"KN_INFLUX set when not suppose to be"
operator|)
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator||=
name|KN_INFLUX
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_DETACHED
operator|)
condition|)
name|kn
operator|->
name|kn_fop
operator|->
name|f_detach
argument_list|(
name|kn
argument_list|)
expr_stmt|;
name|knote_drop
argument_list|(
name|kn
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|kq
operator|->
name|kq_state
operator|&
name|KQ_TASKSCHED
operator|)
operator|==
name|KQ_TASKSCHED
condition|)
block|{
name|kq
operator|->
name|kq_state
operator||=
name|KQ_TASKDRAIN
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|kq
operator|->
name|kq_state
argument_list|,
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|PSOCK
argument_list|,
literal|"kqtqdr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|kq
operator|->
name|kq_state
operator|&
name|KQ_SEL
operator|)
operator|==
name|KQ_SEL
condition|)
block|{
name|kq
operator|->
name|kq_state
operator|&=
operator|~
name|KQ_SEL
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
argument_list|,
name|PSOCK
argument_list|)
expr_stmt|;
block|}
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|FILEDESC_LOCK_FAST
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|fdp
operator|->
name|fd_kqlist
argument_list|,
name|kq
argument_list|,
name|kqueue
argument_list|,
name|kq_list
argument_list|)
expr_stmt|;
name|FILEDESC_UNLOCK_FAST
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
name|knlist_destroy
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
operator|.
name|si_note
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_fdp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|kq
operator|->
name|kq_knhash
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|kq
operator|->
name|kq_knhash
argument_list|,
name|M_KQUEUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|kq
operator|->
name|kq_knlist
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|kq
operator|->
name|kq_knlist
argument_list|,
name|M_KQUEUE
argument_list|)
expr_stmt|;
name|funsetown
argument_list|(
operator|&
name|kq
operator|->
name|kq_sigio
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|kq
argument_list|,
name|M_KQUEUE
argument_list|)
expr_stmt|;
name|fp
operator|->
name|f_data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kqueue_wakeup
parameter_list|(
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|)
block|{
name|KQ_OWNED
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kq
operator|->
name|kq_state
operator|&
name|KQ_SLEEP
operator|)
operator|==
name|KQ_SLEEP
condition|)
block|{
name|kq
operator|->
name|kq_state
operator|&=
operator|~
name|KQ_SLEEP
expr_stmt|;
name|wakeup
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|kq
operator|->
name|kq_state
operator|&
name|KQ_SEL
operator|)
operator|==
name|KQ_SEL
condition|)
block|{
name|kq
operator|->
name|kq_state
operator|&=
operator|~
name|KQ_SEL
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
argument_list|,
name|PSOCK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|knlist_empty
argument_list|(
operator|&
name|kq
operator|->
name|kq_sel
operator|.
name|si_note
argument_list|)
condition|)
name|kqueue_schedtask
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kq
operator|->
name|kq_state
operator|&
name|KQ_ASYNC
operator|)
operator|==
name|KQ_ASYNC
condition|)
block|{
name|pgsigio
argument_list|(
operator|&
name|kq
operator|->
name|kq_sigio
argument_list|,
name|SIGIO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Walk down a list of knotes, activating them if their event has triggered.  *  * There is a possibility to optimize in the case of one kq watching another.  * Instead of scheduling a task to wake it up, you could pass enough state  * down the chain to make up the parent kqueue.  Make this code functional  * first.  */
end_comment

begin_function
name|void
name|knote
parameter_list|(
name|struct
name|knlist
modifier|*
name|list
parameter_list|,
name|long
name|hint
parameter_list|,
name|int
name|islocked
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|struct
name|knote
modifier|*
name|kn
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return;
name|KNL_ASSERT_LOCK
argument_list|(
name|list
argument_list|,
name|islocked
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|islocked
condition|)
name|list
operator|->
name|kl_lock
argument_list|(
name|list
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
comment|/* 	 * If we unlock the list lock (and set KN_INFLUX), we can eliminate 	 * the kqueue scheduling, but this will introduce four 	 * lock/unlock's for each knote to test.  If we do, continue to use 	 * SLIST_FOREACH, SLIST_FOREACH_SAFE is not safe in our case, it is 	 * only safe if you want to remove the current item, which we are 	 * not doing. 	 */
name|SLIST_FOREACH
argument_list|(
argument|kn
argument_list|,
argument|&list->kl_list
argument_list|,
argument|kn_selnext
argument_list|)
block|{
name|kq
operator|=
name|kn
operator|->
name|kn_kq
expr_stmt|;
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_INFLUX
operator|)
operator|!=
name|KN_INFLUX
condition|)
block|{
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_INFLUX
operator|)
operator|!=
name|KN_INFLUX
condition|)
block|{
name|kn
operator|->
name|kn_status
operator||=
name|KN_HASKQLOCK
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_fop
operator|->
name|f_event
argument_list|(
name|kn
argument_list|,
name|hint
argument_list|)
condition|)
name|KNOTE_ACTIVATE
argument_list|(
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator|&=
operator|~
name|KN_HASKQLOCK
expr_stmt|;
block|}
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
name|kq
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|islocked
condition|)
name|list
operator|->
name|kl_unlock
argument_list|(
name|list
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * add a knote to a knlist  */
end_comment

begin_function
name|void
name|knlist_add
parameter_list|(
name|struct
name|knlist
modifier|*
name|knl
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|int
name|islocked
parameter_list|)
block|{
name|KNL_ASSERT_LOCK
argument_list|(
name|knl
argument_list|,
name|islocked
argument_list|)
expr_stmt|;
name|KQ_NOTOWNED
argument_list|(
name|kn
operator|->
name|kn_kq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
operator|(
name|KN_INFLUX
operator||
name|KN_DETACHED
operator|)
operator|)
operator|==
operator|(
name|KN_INFLUX
operator||
name|KN_DETACHED
operator|)
argument_list|,
operator|(
literal|"knote not KN_INFLUX and KN_DETACHED"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|islocked
condition|)
name|knl
operator|->
name|kl_lock
argument_list|(
name|knl
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|knl
operator|->
name|kl_list
argument_list|,
name|kn
argument_list|,
name|kn_selnext
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|islocked
condition|)
name|knl
operator|->
name|kl_unlock
argument_list|(
name|knl
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kn
operator|->
name|kn_kq
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_knlist
operator|=
name|knl
expr_stmt|;
name|kn
operator|->
name|kn_status
operator|&=
operator|~
name|KN_DETACHED
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kn
operator|->
name|kn_kq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|knlist_remove_kq
parameter_list|(
name|struct
name|knlist
modifier|*
name|knl
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|int
name|knlislocked
parameter_list|,
name|int
name|kqislocked
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|!
operator|(
operator|!
operator|!
name|kqislocked
operator|&&
operator|!
name|knlislocked
operator|)
argument_list|,
operator|(
literal|"kq locked w/o knl locked"
operator|)
argument_list|)
expr_stmt|;
name|KNL_ASSERT_LOCK
argument_list|(
name|knl
argument_list|,
name|knlislocked
argument_list|)
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|kn
operator|->
name|kn_kq
operator|->
name|kq_lock
argument_list|,
name|kqislocked
condition|?
name|MA_OWNED
else|:
name|MA_NOTOWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kqislocked
condition|)
name|KASSERT
argument_list|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
operator|(
name|KN_INFLUX
operator||
name|KN_DETACHED
operator|)
operator|)
operator|==
name|KN_INFLUX
argument_list|,
operator|(
literal|"knlist_remove called w/o knote being KN_INFLUX or already removed"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|knlislocked
condition|)
name|knl
operator|->
name|kl_lock
argument_list|(
name|knl
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|knl
operator|->
name|kl_list
argument_list|,
name|kn
argument_list|,
name|knote
argument_list|,
name|kn_selnext
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_knlist
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|knlislocked
condition|)
name|knl
operator|->
name|kl_unlock
argument_list|(
name|knl
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kqislocked
condition|)
name|KQ_LOCK
argument_list|(
name|kn
operator|->
name|kn_kq
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator||=
name|KN_DETACHED
expr_stmt|;
if|if
condition|(
operator|!
name|kqislocked
condition|)
name|KQ_UNLOCK
argument_list|(
name|kn
operator|->
name|kn_kq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove all knotes from a specified klist  */
end_comment

begin_function
name|void
name|knlist_remove
parameter_list|(
name|struct
name|knlist
modifier|*
name|knl
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|int
name|islocked
parameter_list|)
block|{
name|knlist_remove_kq
argument_list|(
name|knl
argument_list|,
name|kn
argument_list|,
name|islocked
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove knote from a specified klist while in f_event handler.  */
end_comment

begin_function
name|void
name|knlist_remove_inevent
parameter_list|(
name|struct
name|knlist
modifier|*
name|knl
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|knlist_remove_kq
argument_list|(
name|knl
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|,
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_HASKQLOCK
operator|)
operator|==
name|KN_HASKQLOCK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|knlist_empty
parameter_list|(
name|struct
name|knlist
modifier|*
name|knl
parameter_list|)
block|{
name|KNL_ASSERT_LOCKED
argument_list|(
name|knl
argument_list|)
expr_stmt|;
return|return
name|SLIST_EMPTY
argument_list|(
operator|&
name|knl
operator|->
name|kl_list
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|knlist_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|knlist_lock
argument_list|,
operator|&
name|knlist_lock
argument_list|,
literal|"knlist lock for lockless objects"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|knlist_mtx_lock
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|knlist_mtx_unlock
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|knlist_mtx_locked
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|knlist_mtx_lock
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|(
expr|struct
name|mtx
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|knlist_mtx_unlock
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|mtx_unlock
argument_list|(
operator|(
expr|struct
name|mtx
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|knlist_mtx_locked
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
name|mtx_owned
argument_list|(
operator|(
expr|struct
name|mtx
operator|*
operator|)
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|knlist_init
parameter_list|(
name|struct
name|knlist
modifier|*
name|knl
parameter_list|,
name|void
modifier|*
name|lock
parameter_list|,
name|void
function_decl|(
modifier|*
name|kl_lock
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|kl_unlock
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|kl_locked
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
if|if
condition|(
name|lock
operator|==
name|NULL
condition|)
name|knl
operator|->
name|kl_lockarg
operator|=
operator|&
name|knlist_lock
expr_stmt|;
else|else
name|knl
operator|->
name|kl_lockarg
operator|=
name|lock
expr_stmt|;
if|if
condition|(
name|kl_lock
operator|==
name|NULL
condition|)
name|knl
operator|->
name|kl_lock
operator|=
name|knlist_mtx_lock
expr_stmt|;
else|else
name|knl
operator|->
name|kl_lock
operator|=
name|kl_lock
expr_stmt|;
if|if
condition|(
name|kl_unlock
operator|==
name|NULL
condition|)
name|knl
operator|->
name|kl_unlock
operator|=
name|knlist_mtx_unlock
expr_stmt|;
else|else
name|knl
operator|->
name|kl_unlock
operator|=
name|kl_unlock
expr_stmt|;
if|if
condition|(
name|kl_locked
operator|==
name|NULL
condition|)
name|knl
operator|->
name|kl_locked
operator|=
name|knlist_mtx_locked
expr_stmt|;
else|else
name|knl
operator|->
name|kl_locked
operator|=
name|kl_locked
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|knl
operator|->
name|kl_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|knlist_destroy
parameter_list|(
name|struct
name|knlist
modifier|*
name|knl
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
comment|/* 	 * if we run across this error, we need to find the offending 	 * driver and have it call knlist_clear. 	 */
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|knl
operator|->
name|kl_list
argument_list|)
condition|)
name|printf
argument_list|(
literal|"WARNING: destroying knlist w/ knotes on it!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|knl
operator|->
name|kl_lockarg
operator|=
name|knl
operator|->
name|kl_lock
operator|=
name|knl
operator|->
name|kl_unlock
operator|=
name|NULL
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|knl
operator|->
name|kl_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Even if we are locked, we may need to drop the lock to allow any influx  * knotes time to "settle".  */
end_comment

begin_function
name|void
name|knlist_cleardel
parameter_list|(
name|struct
name|knlist
modifier|*
name|knl
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|islocked
parameter_list|,
name|int
name|killkn
parameter_list|)
block|{
name|struct
name|knote
modifier|*
name|kn
decl_stmt|,
modifier|*
name|kn2
decl_stmt|;
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
if|if
condition|(
name|islocked
condition|)
name|KNL_ASSERT_LOCKED
argument_list|(
name|knl
argument_list|)
expr_stmt|;
else|else
block|{
name|KNL_ASSERT_UNLOCKED
argument_list|(
name|knl
argument_list|)
expr_stmt|;
name|again
label|:
comment|/* need to reaquire lock since we have dropped it */
name|knl
operator|->
name|kl_lock
argument_list|(
name|knl
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
block|}
name|SLIST_FOREACH_SAFE
argument_list|(
argument|kn
argument_list|,
argument|&knl->kl_list
argument_list|,
argument|kn_selnext
argument_list|,
argument|kn2
argument_list|)
block|{
name|kq
operator|=
name|kn
operator|->
name|kn_kq
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_INFLUX
operator|)
condition|)
block|{
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|knlist_remove_kq
argument_list|(
name|knl
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|killkn
condition|)
block|{
name|kn
operator|->
name|kn_status
operator||=
name|KN_INFLUX
operator||
name|KN_DETACHED
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|knote_drop
argument_list|(
name|kn
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Make sure cleared knotes disappear soon */
name|kn
operator|->
name|kn_flags
operator||=
operator|(
name|EV_EOF
operator||
name|EV_ONESHOT
operator|)
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
name|kq
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|knl
operator|->
name|kl_list
argument_list|)
condition|)
block|{
comment|/* there are still KN_INFLUX remaining */
name|kn
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|knl
operator|->
name|kl_list
argument_list|)
expr_stmt|;
name|kq
operator|=
name|kn
operator|->
name|kn_kq
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_INFLUX
argument_list|,
operator|(
literal|"knote removed w/o list lock"
operator|)
argument_list|)
expr_stmt|;
name|knl
operator|->
name|kl_unlock
argument_list|(
name|knl
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_state
operator||=
name|KQ_FLUXWAIT
expr_stmt|;
name|msleep
argument_list|(
name|kq
argument_list|,
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|PSOCK
operator||
name|PDROP
argument_list|,
literal|"kqkclr"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kq
operator|=
name|NULL
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|islocked
condition|)
name|KNL_ASSERT_LOCKED
argument_list|(
name|knl
argument_list|)
expr_stmt|;
else|else
block|{
name|knl
operator|->
name|kl_unlock
argument_list|(
name|knl
operator|->
name|kl_lockarg
argument_list|)
expr_stmt|;
name|KNL_ASSERT_UNLOCKED
argument_list|(
name|knl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * remove all knotes referencing a specified fd  * must be called with FILEDESC lock.  This prevents a race where a new fd  * comes along and occupies the entry and we attach a knote to the fd.  */
end_comment

begin_function
name|void
name|knote_fdclose
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|struct
name|filedesc
modifier|*
name|fdp
init|=
name|td
operator|->
name|td_proc
operator|->
name|p_fd
decl_stmt|;
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|struct
name|knote
modifier|*
name|kn
decl_stmt|;
name|int
name|influx
decl_stmt|;
name|FILEDESC_LOCK_ASSERT
argument_list|(
name|fdp
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * We shouldn't have to worry about new kevents appearing on fd 	 * since filedesc is locked. 	 */
name|SLIST_FOREACH
argument_list|(
argument|kq
argument_list|,
argument|&fdp->fd_kqlist
argument_list|,
argument|kq_list
argument_list|)
block|{
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|again
label|:
name|influx
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|kq
operator|->
name|kq_knlistsize
operator|>
name|fd
operator|&&
operator|(
name|kn
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|kq
operator|->
name|kq_knlist
index|[
name|fd
index|]
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_INFLUX
condition|)
block|{
comment|/* someone else might be waiting on our knote */
if|if
condition|(
name|influx
condition|)
name|wakeup
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_state
operator||=
name|KQ_FLUXWAIT
expr_stmt|;
name|msleep
argument_list|(
name|kq
argument_list|,
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|PSOCK
argument_list|,
literal|"kqflxwt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|kn
operator|->
name|kn_status
operator||=
name|KN_INFLUX
expr_stmt|;
name|KQ_UNLOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_DETACHED
operator|)
condition|)
name|kn
operator|->
name|kn_fop
operator|->
name|f_detach
argument_list|(
name|kn
argument_list|)
expr_stmt|;
name|knote_drop
argument_list|(
name|kn
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|influx
operator|=
literal|1
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
name|KQ_UNLOCK_FLUX
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|knote_attach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|struct
name|kqueue
modifier|*
name|kq
parameter_list|)
block|{
name|struct
name|klist
modifier|*
name|list
decl_stmt|;
name|KASSERT
argument_list|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_INFLUX
argument_list|,
operator|(
literal|"knote not marked INFLUX"
operator|)
argument_list|)
expr_stmt|;
name|KQ_OWNED
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_fop
operator|->
name|f_isfd
condition|)
block|{
if|if
condition|(
name|kn
operator|->
name|kn_id
operator|>=
name|kq
operator|->
name|kq_knlistsize
condition|)
return|return
name|ENOMEM
return|;
name|list
operator|=
operator|&
name|kq
operator|->
name|kq_knlist
index|[
name|kn
operator|->
name|kn_id
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|kq
operator|->
name|kq_knhash
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|list
operator|=
operator|&
name|kq
operator|->
name|kq_knhash
index|[
name|KN_HASH
argument_list|(
name|kn
operator|->
name|kn_id
argument_list|,
name|kq
operator|->
name|kq_knhashmask
argument_list|)
index|]
expr_stmt|;
block|}
name|SLIST_INSERT_HEAD
argument_list|(
name|list
argument_list|,
name|kn
argument_list|,
name|kn_link
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * knote must already have been detached using the f_detach method.  * no lock need to be held, it is assumed that the KN_INFLUX flag is set  * to prevent other removal.  */
end_comment

begin_function
specifier|static
name|void
name|knote_drop
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|struct
name|klist
modifier|*
name|list
decl_stmt|;
name|kq
operator|=
name|kn
operator|->
name|kn_kq
expr_stmt|;
name|KQ_NOTOWNED
argument_list|(
name|kq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_INFLUX
operator|)
operator|==
name|KN_INFLUX
argument_list|,
operator|(
literal|"knote_drop called without KN_INFLUX set in kn_status"
operator|)
argument_list|)
expr_stmt|;
name|KQ_LOCK
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_fop
operator|->
name|f_isfd
condition|)
name|list
operator|=
operator|&
name|kq
operator|->
name|kq_knlist
index|[
name|kn
operator|->
name|kn_id
index|]
expr_stmt|;
else|else
name|list
operator|=
operator|&
name|kq
operator|->
name|kq_knhash
index|[
name|KN_HASH
argument_list|(
name|kn
operator|->
name|kn_id
argument_list|,
name|kq
operator|->
name|kq_knhashmask
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
name|list
argument_list|)
condition|)
name|SLIST_REMOVE
argument_list|(
name|list
argument_list|,
name|kn
argument_list|,
name|knote
argument_list|,
name|kn_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_QUEUED
condition|)
name|knote_dequeue
argument_list|(
name|kn
argument_list|)
expr_stmt|;
name|KQ_UNLOCK_FLUX
argument_list|(
name|kq
argument_list|)
expr_stmt|;
if|if
condition|(
name|kn
operator|->
name|kn_fop
operator|->
name|f_isfd
condition|)
block|{
name|fdrop
argument_list|(
name|kn
operator|->
name|kn_fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_fp
operator|=
name|NULL
expr_stmt|;
block|}
name|kqueue_fo_release
argument_list|(
name|kn
operator|->
name|kn_kevent
operator|.
name|filter
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_fop
operator|=
name|NULL
expr_stmt|;
name|knote_free
argument_list|(
name|kn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|knote_enqueue
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
init|=
name|kn
operator|->
name|kn_kq
decl_stmt|;
name|KQ_OWNED
argument_list|(
name|kn
operator|->
name|kn_kq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_QUEUED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"knote already queued"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|,
name|kn
argument_list|,
name|kn_tqe
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator||=
name|KN_QUEUED
expr_stmt|;
name|kq
operator|->
name|kq_count
operator|++
expr_stmt|;
name|kqueue_wakeup
argument_list|(
name|kq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|knote_dequeue
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
init|=
name|kn
operator|->
name|kn_kq
decl_stmt|;
name|KQ_OWNED
argument_list|(
name|kn
operator|->
name|kn_kq
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|kn
operator|->
name|kn_status
operator|&
name|KN_QUEUED
argument_list|,
operator|(
literal|"knote not queued"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kq
operator|->
name|kq_head
argument_list|,
name|kn
argument_list|,
name|kn_tqe
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_status
operator|&=
operator|~
name|KN_QUEUED
expr_stmt|;
name|kq
operator|->
name|kq_count
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|knote_init
parameter_list|(
name|void
parameter_list|)
block|{
name|knote_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"KNOTE"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|knote
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|knote
argument_list|,
argument|SI_SUB_PSEUDO
argument_list|,
argument|SI_ORDER_ANY
argument_list|,
argument|knote_init
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_function
specifier|static
name|struct
name|knote
modifier|*
name|knote_alloc
parameter_list|(
name|int
name|waitok
parameter_list|)
block|{
return|return
operator|(
operator|(
expr|struct
name|knote
operator|*
operator|)
name|uma_zalloc
argument_list|(
name|knote_zone
argument_list|,
operator|(
name|waitok
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
operator|)
operator||
name|M_ZERO
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|knote_free
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
if|if
condition|(
name|kn
operator|!=
name|NULL
condition|)
name|uma_zfree
argument_list|(
name|knote_zone
argument_list|,
name|kn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Register the kev w/ the kq specified by fd.  */
end_comment

begin_function
name|int
name|kqfd_register
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|kevent
modifier|*
name|kev
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|waitok
parameter_list|)
block|{
name|struct
name|kqueue
modifier|*
name|kq
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fget
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
operator|&
name|fp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|kqueue_aquire
argument_list|(
name|fp
argument_list|,
operator|&
name|kq
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|noaquire
goto|;
name|error
operator|=
name|kqueue_register
argument_list|(
name|kq
argument_list|,
name|kev
argument_list|,
name|td
argument_list|,
name|waitok
argument_list|)
expr_stmt|;
name|kqueue_release
argument_list|(
name|kq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|noaquire
label|:
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

end_unit

